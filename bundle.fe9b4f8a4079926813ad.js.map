{"version":3,"file":"bundle.fe9b4f8a4079926813ad.js","mappings":";sBAAAA,SAASC,KAAKC,iBAAiB,eAAeC,GAAKA,EAAEC,iBAAmBD,EAAEE,oBAC1EL,SAASC,KAAKC,iBAAiB,aAgC/B,UAAuBI,QAASC,EAAGC,QAASC,IAC3CC,GAAU,EACVC,EAAUJ,EACVK,EAAUH,EAEVI,EAAMC,MAAMC,YAAY,MAAQ,GAAER,OAClCM,EAAMC,MAAMC,YAAY,MAAQ,GAAEN,OAClCI,EAAMG,UAAUC,IAAI,KACrB,IAtCAjB,SAASC,KAAKC,iBAAiB,WAwC/B,WACCQ,GAAU,EACVG,EAAMK,aAAa,cAAe,GAClCL,EAAMG,UAAUG,OAAO,MACRC,MAATC,GAAsBA,GAAQ,IAC7BC,OAAOC,SAASC,KAAOC,EAAMJ,GAErC,IA7CArB,SAASC,KAAKC,iBAAiB,YAAawB,GAC5C1B,SAASC,KAAKC,iBAAiB,aAAaC,GAAKuB,EAAYvB,EAAEwB,QAAQ,MAEvE,IAAIN,EAAOX,EAASC,EAASC,EAASgB,EAAM,IAC5C,MAAMf,EAAQb,SAAS6B,cAAc,UAC/BJ,EAAQ,CAAC,eAAgB,aAAc,iBAAkB,cAAe,0BAA2B,iBAAkB,+BAAgC,kBA0C3J,SAASC,GAAcpB,QAASC,EAAGC,QAASC,IAC3C,IAAKC,EAAS,OAEd,IAAIoB,EAAKvB,EAAII,EACToB,EAAKtB,EAAIG,EAEToB,EAAQ,EAEZ,GAHUC,KAAKC,KAAKJ,EAAKA,EAAKC,EAAKA,IAGxBH,EAAK,CACf,IAAIO,EAAMF,KAAKG,MAAML,EAAID,GAAM,KAAQG,KAAKI,GAC5C,KAAOF,EAAM,GAAGA,GAAiB,EAAVF,KAAKI,GAC5BL,EAAQC,KAAKK,MAAMH,EAAMF,KAAKI,GAAK,GAAK,CACzC,CAEAxB,EAAMK,aAAa,cAAec,GAC/BX,EAAQW,EAAM,EACdO,QAAQC,IAAIR,EAChB,CAzDI,iBAAkBhC,SAASyC,kBAE9B5B,EAAMG,UAAUC,IAAI,eACpBJ,EAAMG,UAAUC,IAAI,mBAEpBjB,SAAS0C,eAAe,QAAQC,QAAU,WACtC3C,SAAS0C,eAAe,UAAU1B,UAAU4B,SAAS,eACvDlC,GAAU,EACVG,EAAMG,UAAUG,OAAO,MACvBN,EAAMG,UAAUC,IAAI,mBACpBjB,SAAS0C,eAAe,UAAU1B,UAAUG,OAAO,gBAEnDT,GAAU,EACVV,SAAS0C,eAAe,UAAU1B,UAAUC,IAAI,cAChDJ,EAAMG,UAAUG,OAAO,mBAEvBN,EAAMG,UAAUC,IAAI,MAEtB,qNCdG4B,EAA0B,IAA4B,KACtDC,EAAqC,IAAgC,KACrEC,EAAqC,IAAgC,KACrEC,EAAqC,IAAgC,KACrEC,EAAqC,IAAgC,KACrEC,EAAqC,IAAgC,KACrEC,EAAqC,IAAgC,KACrEC,EAAqC,IAAgC,KACrEC,EAAqC,IAAgC,KACrEC,EAAqC,IAAgC,KACrEC,EAAqC,IAAgC,KACrEC,EAAsC,IAAgC,KACtEC,EAAsC,IAAgC,KAE1EZ,EAAwBa,KAAK,CAACC,EAAOC,GAAI,kHAAsHd,EAAqC,w7BAA07BC,EAAqC,mxBAAqxBC,EAAqC,0LAA4LC,EAAqC,yVAA2VC,EAAqC,mIAAqIC,EAAqC,kIAAoIC,EAAqC,kIAAoIC,EAAqC,8NAAgOC,EAAqC,iXAAmXC,EAAqC,uhIAAyjIC,EAAsC,sFAAwFC,EAAsC,0JAA2J,GAAG,CAAC,QAAU,EAAE,QAAU,CAAC,mCAAmC,MAAQ,GAAG,SAAW,6zGAA6zG,eAAiB,CAAC,m/QAAm/Q,WAAa,MAEl/nB,gCCxBAE,EAAOE,QAAU,SAAUC,GACzB,IAAIC,EAAO,GAuDX,OArDAA,EAAKC,SAAW,WACd,OAAOC,KAAKC,KAAI,SAAUC,GACxB,IAAIC,EAAUN,EAAuBK,GAErC,OAAIA,EAAK,GACA,UAAUE,OAAOF,EAAK,GAAI,MAAME,OAAOD,EAAS,KAGlDA,CACT,IAAGE,KAAK,GACV,EAIAP,EAAKQ,EAAI,SAAUC,EAASC,EAAYC,GACf,iBAAZF,IAETA,EAAU,CAAC,CAAC,KAAMA,EAAS,MAG7B,IAAIG,EAAyB,CAAC,EAE9B,GAAID,EACF,IAAK,IAAIH,EAAI,EAAGA,EAAIN,KAAKW,OAAQL,IAAK,CAEpC,IAAIX,EAAKK,KAAKM,GAAG,GAEP,MAANX,IACFe,EAAuBf,IAAM,EAEjC,CAGF,IAAK,IAAIiB,EAAK,EAAGA,EAAKL,EAAQI,OAAQC,IAAM,CAC1C,IAAIV,EAAO,GAAGE,OAAOG,EAAQK,IAEzBH,GAAUC,EAAuBR,EAAK,MAKtCM,IACGN,EAAK,GAGRA,EAAK,GAAK,GAAGE,OAAOI,EAAY,SAASJ,OAAOF,EAAK,IAFrDA,EAAK,GAAKM,GAMdV,EAAKL,KAAKS,GACZ,CACF,EAEOJ,CACT,uBCzDA,SAASe,EAAkBC,EAAKC,IAAkB,MAAPA,GAAeA,EAAMD,EAAIH,UAAQI,EAAMD,EAAIH,QAAQ,IAAK,IAAIL,EAAI,EAAGU,EAAO,IAAIC,MAAMF,GAAMT,EAAIS,EAAKT,IAAOU,EAAKV,GAAKQ,EAAIR,GAAM,OAAOU,CAAM,CAMtLtB,EAAOE,QAAU,SAAgCM,GAC/C,IAbsBY,EAAKR,EAavBY,GAbuBZ,EAaM,EAHnC,SAAyBQ,GAAO,GAAIG,MAAME,QAAQL,GAAM,OAAOA,CAAK,CAV3BM,CAAjBN,EAaKZ,IAL7B,SAA+BY,EAAKR,GAAK,IAAIM,EAAKE,IAA0B,oBAAXO,QAA0BP,EAAIO,OAAOC,WAAaR,EAAI,eAAgB,GAAU,MAANF,EAAJ,CAAwB,IAAkDW,EAAIC,EAAlDC,EAAO,GAAQC,GAAK,EAAUC,GAAK,EAAmB,IAAM,IAAKf,EAAKA,EAAGgB,KAAKd,KAAQY,GAAMH,EAAKX,EAAGiB,QAAQC,QAAoBL,EAAKhC,KAAK8B,EAAGnE,QAAYkD,GAAKmB,EAAKd,SAAWL,GAA3DoB,GAAK,GAAkE,CAAE,MAAOK,GAAOJ,GAAK,EAAMH,EAAKO,CAAK,CAAE,QAAU,IAAWL,GAAsB,MAAhBd,EAAW,QAAWA,EAAW,QAAK,CAAE,QAAU,GAAIe,EAAI,MAAMH,CAAI,CAAE,CAAE,OAAOC,CAAjV,CAAuV,CARnbO,CAAsBlB,EAAKR,IAI5F,SAAqC2B,EAAGC,GAAU,GAAKD,EAAL,CAAgB,GAAiB,iBAANA,EAAgB,OAAOpB,EAAkBoB,EAAGC,GAAS,IAAIC,EAAIC,OAAOC,UAAUtC,SAAS6B,KAAKK,GAAGK,MAAM,GAAI,GAAiE,MAAnD,WAANH,GAAkBF,EAAEM,cAAaJ,EAAIF,EAAEM,YAAYC,MAAgB,QAANL,GAAqB,QAANA,EAAoBlB,MAAMwB,KAAKR,GAAc,cAANE,GAAqB,2CAA2CO,KAAKP,GAAWtB,EAAkBoB,EAAGC,QAAzG,CAA7O,CAA+V,CAJ7TS,CAA4B7B,EAAKR,IAEnI,WAA8B,MAAM,IAAIsC,UAAU,4IAA8I,CAFvDC,IAcnI1C,EAAUe,EAAM,GAChB4B,EAAa5B,EAAM,GAEvB,IAAK4B,EACH,OAAO3C,EAGT,GAAoB,mBAAT4C,KAAqB,CAE9B,IAAIC,EAASD,KAAKE,SAASC,mBAAmBC,KAAKC,UAAUN,MACzDO,EAAO,+DAA+DjD,OAAO4C,GAC7EM,EAAgB,OAAOlD,OAAOiD,EAAM,OACpCE,EAAaT,EAAWU,QAAQvD,KAAI,SAAUwD,GAChD,MAAO,iBAAiBrD,OAAO0C,EAAWY,YAAc,IAAItD,OAAOqD,EAAQ,MAC7E,IACA,MAAO,CAACtD,GAASC,OAAOmD,GAAYnD,OAAO,CAACkD,IAAgBjD,KAAK,KACnE,CAEA,MAAO,CAACF,GAASE,KAAK,KACxB,wBCjCAX,EAAOE,QAAU,SAAU+D,EAAKC,GAS9B,OARKA,IAEHA,EAAU,CAAC,GAMM,iBAFnBD,EAAMA,GAAOA,EAAIE,WAAaF,EAAIG,QAAUH,GAGnCA,GAIL,eAAejB,KAAKiB,KAEtBA,EAAMA,EAAIrB,MAAM,GAAI,IAGlBsB,EAAQG,OAEVJ,GAAOC,EAAQG,MAKb,cAAcrB,KAAKiB,IAAQC,EAAQI,WAC9B,IAAK5D,OAAOuD,EAAIM,QAAQ,KAAM,OAAOA,QAAQ,MAAO,OAAQ,KAG9DN,EACT,8BC/BA,IACMO,EAeFC,EAAY,WACd,IAAID,EAAO,CAAC,EACZ,OAAO,SAAkBE,GACvB,QAA4B,IAAjBF,EAAKE,GAAyB,CACvC,IAAIC,EAActI,SAAS6B,cAAcwG,GAEzC,GAAI/G,OAAOiH,mBAAqBD,aAAuBhH,OAAOiH,kBAC5D,IAGED,EAAcA,EAAYE,gBAAgBC,IAC5C,CAAE,MAAOtI,GAEPmI,EAAc,IAChB,CAGFH,EAAKE,GAAUC,CACjB,CAEA,OAAOH,EAAKE,EACd,CACF,CAtBgB,GAwBZK,EAAc,GAElB,SAASC,EAAqBC,GAG5B,IAFA,IAAIC,GAAU,EAELtE,EAAI,EAAGA,EAAImE,EAAY9D,OAAQL,IACtC,GAAImE,EAAYnE,GAAGqE,aAAeA,EAAY,CAC5CC,EAAStE,EACT,KACF,CAGF,OAAOsE,CACT,CAEA,SAASC,EAAa/E,EAAM8D,GAI1B,IAHA,IAAIkB,EAAa,CAAC,EACdC,EAAc,GAETzE,EAAI,EAAGA,EAAIR,EAAKa,OAAQL,IAAK,CACpC,IAAIJ,EAAOJ,EAAKQ,GACZX,EAAKiE,EAAQoB,KAAO9E,EAAK,GAAK0D,EAAQoB,KAAO9E,EAAK,GAClD+E,EAAQH,EAAWnF,IAAO,EAC1BgF,EAAa,GAAGvE,OAAOT,EAAI,KAAKS,OAAO6E,GAC3CH,EAAWnF,GAAMsF,EAAQ,EACzB,IAAIlH,EAAQ2G,EAAqBC,GAC7BO,EAAM,CACRC,IAAKjF,EAAK,GACVkF,MAAOlF,EAAK,GACZmF,UAAWnF,EAAK,KAGH,IAAXnC,GACF0G,EAAY1G,GAAOuH,aACnBb,EAAY1G,GAAOwH,QAAQL,IAE3BT,EAAYhF,KAAK,CACfkF,WAAYA,EACZY,QAASC,EAASN,EAAKtB,GACvB0B,WAAY,IAIhBP,EAAYtF,KAAKkF,EACnB,CAEA,OAAOI,CACT,CAEA,SAASU,EAAmB7B,GAC1B,IAAI/G,EAAQd,SAAS2J,cAAc,SAC/BC,EAAa/B,EAAQ+B,YAAc,CAAC,EAExC,QAAgC,IAArBA,EAAWC,MAAuB,CAC3C,IAAIA,EAAmD,KAEnDA,IACFD,EAAWC,MAAQA,EAEvB,CAMA,GAJAxD,OAAOyD,KAAKF,GAAYG,SAAQ,SAAUC,GACxClJ,EAAMI,aAAa8I,EAAKJ,EAAWI,GACrC,IAE8B,mBAAnBnC,EAAQoC,OACjBpC,EAAQoC,OAAOnJ,OACV,CACL,IAAIuH,EAASD,EAAUP,EAAQoC,QAAU,QAEzC,IAAK5B,EACH,MAAM,IAAI6B,MAAM,2GAGlB7B,EAAO8B,YAAYrJ,EACrB,CAEA,OAAOA,CACT,CAaA,IACMsJ,EADFC,GACED,EAAY,GACT,SAAiBpI,EAAOsI,GAE7B,OADAF,EAAUpI,GAASsI,EACZF,EAAUG,OAAOC,SAASlG,KAAK,KACxC,GAGF,SAASmG,EAAoB3J,EAAOkB,EAAOb,EAAQgI,GACjD,IAAIC,EAAMjI,EAAS,GAAKgI,EAAIE,MAAQ,UAAUhF,OAAO8E,EAAIE,MAAO,MAAMhF,OAAO8E,EAAIC,IAAK,KAAOD,EAAIC,IAIjG,GAAItI,EAAM4J,WACR5J,EAAM4J,WAAWC,QAAUN,EAAYrI,EAAOoH,OACzC,CACL,IAAIwB,EAAU5K,SAAS6K,eAAezB,GAClC0B,EAAahK,EAAMgK,WAEnBA,EAAW9I,IACblB,EAAMiK,YAAYD,EAAW9I,IAG3B8I,EAAWlG,OACb9D,EAAMkK,aAAaJ,EAASE,EAAW9I,IAEvClB,EAAMqJ,YAAYS,EAEtB,CACF,CAEA,SAASK,EAAWnK,EAAO+G,EAASsB,GAClC,IAAIC,EAAMD,EAAIC,IACVC,EAAQF,EAAIE,MACZC,EAAYH,EAAIG,UAepB,GAbID,EACFvI,EAAMI,aAAa,QAASmI,GAE5BvI,EAAMoK,gBAAgB,SAGpB5B,GAA6B,oBAATtC,OACtBoC,GAAO,uDAAuD/E,OAAO2C,KAAKE,SAASC,mBAAmBC,KAAKC,UAAUiC,MAAe,QAMlIxI,EAAM4J,WACR5J,EAAM4J,WAAWC,QAAUvB,MACtB,CACL,KAAOtI,EAAMqK,YACXrK,EAAMiK,YAAYjK,EAAMqK,YAG1BrK,EAAMqJ,YAAYnK,SAAS6K,eAAezB,GAC5C,CACF,CAEA,IAAIgC,EAAY,KACZC,EAAmB,EAEvB,SAAS5B,EAASN,EAAKtB,GACrB,IAAI/G,EACAwK,EACAnK,EAEJ,GAAI0G,EAAQuD,UAAW,CACrB,IAAIG,EAAaF,IACjBvK,EAAQsK,IAAcA,EAAY1B,EAAmB7B,IACrDyD,EAASb,EAAoBe,KAAK,KAAM1K,EAAOyK,GAAY,GAC3DpK,EAASsJ,EAAoBe,KAAK,KAAM1K,EAAOyK,GAAY,EAC7D,MACEzK,EAAQ4I,EAAmB7B,GAC3ByD,EAASL,EAAWO,KAAK,KAAM1K,EAAO+G,GAEtC1G,EAAS,YAxFb,SAA4BL,GAE1B,GAAyB,OAArBA,EAAM2K,WACR,OAAO,EAGT3K,EAAM2K,WAAWV,YAAYjK,EAC/B,CAkFM4K,CAAmB5K,EACrB,EAIF,OADAwK,EAAOnC,GACA,SAAqBwC,GAC1B,GAAIA,EAAQ,CACV,GAAIA,EAAOvC,MAAQD,EAAIC,KAAOuC,EAAOtC,QAAUF,EAAIE,OAASsC,EAAOrC,YAAcH,EAAIG,UACnF,OAGFgC,EAAOnC,EAAMwC,EACf,MACExK,GAEJ,CACF,CAEAwC,EAAOE,QAAU,SAAUE,EAAM8D,IAC/BA,EAAUA,GAAW,CAAC,GAGTuD,WAA0C,kBAAtBvD,EAAQuD,YACvCvD,EAAQuD,gBArOY,IAATjD,IAMTA,EAAOqC,QAAQlJ,QAAUtB,UAAYA,SAAS4L,MAAQtK,OAAOuK,OAGxD1D,IAgOT,IAAI2D,EAAkBhD,EADtB/E,EAAOA,GAAQ,GAC0B8D,GACzC,OAAO,SAAgBkE,GAGrB,GAFAA,EAAUA,GAAW,GAE2B,mBAA5C1F,OAAOC,UAAUtC,SAAS6B,KAAKkG,GAAnC,CAIA,IAAK,IAAIxH,EAAI,EAAGA,EAAIuH,EAAgBlH,OAAQL,IAAK,CAC/C,IACIvC,EAAQ2G,EADKmD,EAAgBvH,IAEjCmE,EAAY1G,GAAOuH,YACrB,CAIA,IAFA,IAAIyC,EAAqBlD,EAAaiD,EAASlE,GAEtChD,EAAK,EAAGA,EAAKiH,EAAgBlH,OAAQC,IAAM,CAClD,IAEIoH,EAAStD,EAFKmD,EAAgBjH,IAIK,IAAnC6D,EAAYuD,GAAQ1C,aACtBb,EAAYuD,GAAQzC,UAEpBd,EAAYwD,OAAOD,EAAQ,GAE/B,CAEAH,EAAkBE,CAtBlB,CAuBF,CACF,+CC5QA,083BCAA,sspGCAA,06GCAA,kzqqCCAA,s73BCAA,k/MCAA,0mCCAA,8m4BCAA,kk5BCAA,kqQCAA,0uhDCAA,+71DCCIG,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBjL,IAAjBkL,EACH,OAAOA,EAAazI,QAGrB,IAAIF,EAASwI,EAAyBE,GAAY,CACjDzI,GAAIyI,EAEJxI,QAAS,CAAC,GAOX,OAHA0I,EAAoBF,GAAU1I,EAAQA,EAAOE,QAASuI,GAG/CzI,EAAOE,OACf,CCrBAuI,EAAoBhG,EAAKzC,IACxB,IAAI6I,EAAS7I,GAAUA,EAAOmE,WAC7B,IAAOnE,EAAiB,QACxB,IAAM,EAEP,OADAyI,EAAoBK,EAAED,EAAQ,CAAEE,EAAGF,IAC5BA,CAAM,ECLdJ,EAAoBK,EAAI,CAAC5I,EAAS8I,KACjC,IAAI,IAAI3C,KAAO2C,EACXP,EAAoBlG,EAAEyG,EAAY3C,KAASoC,EAAoBlG,EAAErC,EAASmG,IAC5E3D,OAAOuG,eAAe/I,EAASmG,EAAK,CAAE6C,YAAY,EAAMC,IAAKH,EAAW3C,IAE1E,ECNDoC,EAAoBlG,EAAI,CAACiD,EAAK4D,IAAU1G,OAAOC,UAAU0G,eAAenH,KAAKsD,EAAK4D,GCClFX,EAAoBa,EAAKpJ,IACH,oBAAXyB,QAA0BA,OAAO4H,aAC1C7G,OAAOuG,eAAe/I,EAASyB,OAAO4H,YAAa,CAAE7L,MAAO,WAE7DgF,OAAOuG,eAAe/I,EAAS,aAAc,CAAExC,OAAO,GAAO,ECL9D+K,EAAoBe,QAAK/L,+zBCQZ,IAAI,IALH,CAEdyG,OAAiB,OACjBA,WAAoB,IAML,IAAQuF,OAAvB,MCPMC,EAAW,MASXC,EAAe,EACfC,EAAmB,EACnBC,EAAe,EACfC,EAAY,EAEZC,EAAa,EAQbC,EAAc,IAwBdC,EAAoB,EACpBC,EAAe,EACfC,EAAe,EACfC,EAAgB,EAChBC,EAAoB,EACpBC,EAAsB,EACtBC,EAAoB,EACpBC,EAAwB,EACxBC,EAAoB,EAGpBC,EAAwB,IACxBC,EAAwB,IAGxBC,EAA0B,IAC1BC,EAAiB,IACjBC,EAAsB,KACtBC,EAAyB,KACzBC,EAAgB,KAChBC,EAA6B,KAE7BC,EAA4B,KAE5BC,EAAe,KACfC,EAA4B,KAE5BC,EAA2B,KAE3BC,EAAmB,KAGnBC,EAAoB,KAEpBC,EAAkB,KAClBC,EAAY,KACZC,EAAgB,KAGhBC,EAAqB,KAErBC,EAAa,KAGbC,EAAc,KACdC,EAAqB,KAOrBC,EAAuB,MACvBC,EAAwB,MACxBC,EAAwB,MACxBC,EAAwB,MAsBxBC,EAAmB,MAQnBC,EAAsB,KACtBC,EAAoB,KACpBC,EAAoB,KAMpBC,EAAoB,EACpBC,EAAwB,EACxBC,EAAsB,EAItBC,EAAe,KAQfC,GAAiB,OACjBC,GAAuB,cACvBC,GAAsB,aAGtBC,GAAgB,KA0BhBC,GAAkB,MAWlBC,GAAQ,SAERC,GAAe,KAEfC,GAAwB,IACxBC,GAAyB,KAM/B,MAAMC,GAEL7Q,iBAAkB8Q,EAAMC,QAEE7P,IAApB6C,KAAKiN,aAA2BjN,KAAKiN,WAAa,CAAC,GAExD,MAAMC,EAAYlN,KAAKiN,gBAEI9P,IAAtB+P,EAAWH,KAEfG,EAAWH,GAAS,KAI4B,IAA5CG,EAAWH,GAAOI,QAASH,IAE/BE,EAAWH,GAAOtN,KAAMuN,EAI1B,CAEAI,iBAAkBL,EAAMC,GAEvB,QAAyB7P,IAApB6C,KAAKiN,WAA2B,OAAO,EAE5C,MAAMC,EAAYlN,KAAKiN,WAEvB,YAA6B9P,IAAtB+P,EAAWH,KAAoE,IAA5CG,EAAWH,GAAOI,QAASH,EAEtE,CAEAK,oBAAqBN,EAAMC,GAE1B,QAAyB7P,IAApB6C,KAAKiN,WAA2B,OAErC,MACMK,EADYtN,KAAKiN,WACUF,GAEjC,QAAuB5P,IAAlBmQ,EAA8B,CAElC,MAAMvP,EAAQuP,EAAcH,QAASH,IAEpB,IAAZjP,GAEJuP,EAAcrF,OAAQlK,EAAO,EAI/B,CAED,CAEAwP,cAAeC,GAEd,QAAyBrQ,IAApB6C,KAAKiN,WAA2B,OAErC,MACMK,EADYtN,KAAKiN,WACUO,EAAMT,MAEvC,QAAuB5P,IAAlBmQ,EAA8B,CAElCE,EAAMpJ,OAASpE,KAGf,MAAMyN,EAAQH,EAAchL,MAAO,GAEnC,IAAM,IAAIhC,EAAI,EAAGoN,EAAID,EAAM9M,OAAQL,EAAIoN,EAAGpN,IAEzCmN,EAAOnN,GAAIsB,KAAM5B,KAAMwN,GAIxBA,EAAMpJ,OAAS,IAEhB,CAED,EAID,MAAMuJ,GAAO,CAAE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAEzgD,IAAIC,GAAQ,QAGZ,MAAMC,GAAU7P,KAAKI,GAAK,IACpB0P,GAAU,IAAM9P,KAAKI,GAG3B,SAAS2P,KAER,MAAMC,EAAqB,WAAhBhQ,KAAKiQ,SAAwB,EAClCC,EAAqB,WAAhBlQ,KAAKiQ,SAAwB,EAClCE,EAAqB,WAAhBnQ,KAAKiQ,SAAwB,EAClCG,EAAqB,WAAhBpQ,KAAKiQ,SAAwB,EAOxC,OANaN,GAAW,IAALK,GAAcL,GAAMK,GAAM,EAAI,KAASL,GAAMK,GAAM,GAAK,KAASL,GAAMK,GAAM,GAAK,KAAS,IAC5GL,GAAW,IAALO,GAAcP,GAAMO,GAAM,EAAI,KAAS,IAAMP,GAAMO,GAAM,GAAK,GAAO,IAASP,GAAMO,GAAM,GAAK,KAAS,IAC9GP,GAAW,GAALQ,EAAY,KAASR,GAAMQ,GAAM,EAAI,KAAS,IAAMR,GAAMQ,GAAM,GAAK,KAASR,GAAMQ,GAAM,GAAK,KACrGR,GAAW,IAALS,GAAcT,GAAMS,GAAM,EAAI,KAAST,GAAMS,GAAM,GAAK,KAAST,GAAMS,GAAM,GAAK,MAG9EC,aAEb,CAEA,SAASC,GAAOlR,EAAOO,EAAK4Q,GAE3B,OAAOvQ,KAAKuQ,IAAK5Q,EAAKK,KAAKL,IAAK4Q,EAAKnR,GAEtC,CAIA,SAASoR,GAAiBrM,EAAGsM,GAE5B,OAAWtM,EAAIsM,EAAMA,GAAMA,CAE5B,CAyBA,SAASC,GAAMpS,EAAGE,EAAGmS,GAEpB,OAAS,EAAIA,GAAMrS,EAAIqS,EAAInS,CAE5B,CAyFA,SAASoS,GAAcxR,GAEtB,OAAqC,IAA5BA,EAAUA,EAAQ,IAAyB,IAAVA,CAE3C,CAEA,SAASyR,GAAgBzR,GAExB,OAAOY,KAAK8Q,IAAK,EAAG9Q,KAAK+Q,KAAM/Q,KAAKO,IAAKnB,GAAUY,KAAKgR,KAEzD,CAEA,SAASC,GAAiB7R,GAEzB,OAAOY,KAAK8Q,IAAK,EAAG9Q,KAAKK,MAAOL,KAAKO,IAAKnB,GAAUY,KAAKgR,KAE1D,CA0DA,SAASE,GAAa9R,EAAOqQ,GAE5B,OAASA,EAAMlL,aAEd,KAAK4M,aAEJ,OAAO/R,EAER,KAAKgS,YAEJ,OAAOhS,EAAQ,WAEhB,KAAKiS,YAEJ,OAAOjS,EAAQ,MAEhB,KAAKkS,WAEJ,OAAOlS,EAAQ,IAEhB,KAAKmS,WAEJ,OAAOvR,KAAKuQ,IAAKnR,EAAQ,YAAgB,GAE1C,KAAKoS,WAEJ,OAAOxR,KAAKuQ,IAAKnR,EAAQ,OAAW,GAErC,KAAKqS,UAEJ,OAAOzR,KAAKuQ,IAAKnR,EAAQ,KAAS,GAEnC,QAEC,MAAM,IAAI6I,MAAO,2BAIpB,CAEA,SAASyJ,GAAWtS,EAAOqQ,GAE1B,OAASA,EAAMlL,aAEd,KAAK4M,aAEJ,OAAO/R,EAER,KAAKgS,YAEJ,OAAOpR,KAAK2R,MAAe,WAARvS,GAEpB,KAAKiS,YAEJ,OAAOrR,KAAK2R,MAAe,MAARvS,GAEpB,KAAKkS,WAEJ,OAAOtR,KAAK2R,MAAe,IAARvS,GAEpB,KAAKmS,WAEJ,OAAOvR,KAAK2R,MAAe,WAARvS,GAEpB,KAAKoS,WAEJ,OAAOxR,KAAK2R,MAAe,MAARvS,GAEpB,KAAKqS,UAEJ,OAAOzR,KAAK2R,MAAe,IAARvS,GAEpB,QAEC,MAAM,IAAI6I,MAAO,2BAIpB,CAEA,MAAM2J,GAAY,CACjB/B,QAASA,GACTC,QAASA,GACTC,aAAcA,GACdO,MAAOA,GACPE,gBAAiBA,GACjBqB,UAnRD,SAAoBvT,EAAGwT,EAAIC,EAAIC,EAAIC,GAElC,OAAOD,GAAO1T,EAAIwT,IAASG,EAAKD,IAASD,EAAKD,EAE/C,EAgRCI,YA7QD,SAAsB5T,EAAGE,EAAGY,GAE3B,OAAKd,IAAME,GAEDY,EAAQd,IAAQE,EAAIF,GAItB,CAIT,EAkQCoS,KAAMA,GACNyB,KAzPD,SAAe7T,EAAGE,EAAG4T,EAAQC,GAE5B,OAAO3B,GAAMpS,EAAGE,EAAG,EAAIwB,KAAKsS,KAAOF,EAASC,GAE7C,EAsPCE,SAnPD,SAAmBjU,EAAGqE,EAAS,GAE9B,OAAOA,EAAS3C,KAAKwS,IAAKhC,GAAiBlS,EAAY,EAATqE,GAAeA,EAE9D,EAgPC8P,WA7OD,SAAqBnU,EAAGqB,EAAK4Q,GAE5B,OAAKjS,GAAKqB,EAAa,EAClBrB,GAAKiS,EAAa,GAEvBjS,GAAMA,EAAIqB,IAAU4Q,EAAM5Q,IAEfrB,GAAM,EAAI,EAAIA,EAE1B,EAqOCoU,aAnOD,SAAuBpU,EAAGqB,EAAK4Q,GAE9B,OAAKjS,GAAKqB,EAAa,EAClBrB,GAAKiS,EAAa,GAEvBjS,GAAMA,EAAIqB,IAAU4Q,EAAM5Q,IAEfrB,EAAIA,GAAMA,GAAU,EAAJA,EAAQ,IAAO,GAE3C,EA2NCqU,QAxND,SAAkBC,EAAKC,GAEtB,OAAOD,EAAM5S,KAAKK,MAAOL,KAAKiQ,UAAa4C,EAAOD,EAAM,GAEzD,EAqNCE,UAlND,SAAoBF,EAAKC,GAExB,OAAOD,EAAM5S,KAAKiQ,UAAa4C,EAAOD,EAEvC,EA+MCG,gBA5MD,SAA0BC,GAEzB,OAAOA,GAAU,GAAMhT,KAAKiQ,SAE7B,EAyMCgD,aAtMD,SAAuBC,QAEX/T,IAAN+T,IAAkBtD,GAAQsD,GAI/B,IAAIvC,EAAIf,IAAS,WAMjB,OAJAe,EAAI3Q,KAAKmT,KAAMxC,EAAIA,IAAM,GAAQ,EAAJA,GAE7BA,GAAKA,EAAI3Q,KAAKmT,KAAMxC,EAAIA,IAAM,EAAO,GAAJA,KAEtBA,EAAIA,IAAM,MAAS,GAAM,UAErC,EAyLCyC,SAvLD,SAAmBC,GAElB,OAAOA,EAAUxD,EAElB,EAoLCyD,SAlLD,SAAmBC,GAElB,OAAOA,EAAUzD,EAElB,EA+KCc,aAAcA,GACdC,eAAgBA,GAChBI,gBAAiBA,GACjBuC,6BA9JD,SAAuCC,EAAGhJ,EAAGiJ,EAAGC,EAAGC,GAQlD,MAAMC,EAAM7T,KAAK6T,IACXC,EAAM9T,KAAK8T,IAEXC,EAAKF,EAAKH,EAAI,GACdM,EAAKF,EAAKJ,EAAI,GAEdO,EAAMJ,GAAOpJ,EAAIkJ,GAAM,GACvBO,EAAMJ,GAAOrJ,EAAIkJ,GAAM,GAEvBQ,EAAON,GAAOpJ,EAAIkJ,GAAM,GACxBS,EAAON,GAAOrJ,EAAIkJ,GAAM,GAExBU,EAAOR,GAAOF,EAAIlJ,GAAM,GACxB6J,EAAOR,GAAOH,EAAIlJ,GAAM,GAE9B,OAASmJ,GAER,IAAK,MACJH,EAAEc,IAAKR,EAAKG,EAAKF,EAAKG,EAAMH,EAAKI,EAAML,EAAKE,GAC5C,MAED,IAAK,MACJR,EAAEc,IAAKP,EAAKI,EAAML,EAAKG,EAAKF,EAAKG,EAAMJ,EAAKE,GAC5C,MAED,IAAK,MACJR,EAAEc,IAAKP,EAAKG,EAAMH,EAAKI,EAAML,EAAKG,EAAKH,EAAKE,GAC5C,MAED,IAAK,MACJR,EAAEc,IAAKR,EAAKG,EAAKF,EAAKM,EAAMN,EAAKK,EAAMN,EAAKE,GAC5C,MAED,IAAK,MACJR,EAAEc,IAAKP,EAAKK,EAAMN,EAAKG,EAAKF,EAAKM,EAAMP,EAAKE,GAC5C,MAED,IAAK,MACJR,EAAEc,IAAKP,EAAKM,EAAMN,EAAKK,EAAMN,EAAKG,EAAKH,EAAKE,GAC5C,MAED,QACC3T,QAAQkU,KAAM,kFAAoFZ,GAIrG,EAyGClC,UAAWA,GACXR,YAAaA,IAGd,MAAMuD,GAELlQ,YAAajG,EAAI,EAAGE,EAAI,GAEvBiW,GAAQpQ,UAAUqQ,WAAY,EAE9B1S,KAAK1D,EAAIA,EACT0D,KAAKxD,EAAIA,CAEV,CAEImW,YAEH,OAAO3S,KAAK1D,CAEb,CAEIqW,UAAOvV,GAEV4C,KAAK1D,EAAIc,CAEV,CAEIwV,aAEH,OAAO5S,KAAKxD,CAEb,CAEIoW,WAAQxV,GAEX4C,KAAKxD,EAAIY,CAEV,CAEAmV,IAAKjW,EAAGE,GAKP,OAHAwD,KAAK1D,EAAIA,EACT0D,KAAKxD,EAAIA,EAEFwD,IAER,CAEA6S,UAAWC,GAKV,OAHA9S,KAAK1D,EAAIwW,EACT9S,KAAKxD,EAAIsW,EAEF9S,IAER,CAEA+S,KAAMzW,GAIL,OAFA0D,KAAK1D,EAAIA,EAEF0D,IAER,CAEAgT,KAAMxW,GAIL,OAFAwD,KAAKxD,EAAIA,EAEFwD,IAER,CAEAiT,aAAclV,EAAOX,GAEpB,OAASW,GAER,KAAK,EAAGiC,KAAK1D,EAAIc,EAAO,MACxB,KAAK,EAAG4C,KAAKxD,EAAIY,EAAO,MACxB,QAAS,MAAM,IAAI6I,MAAO,0BAA4BlI,GAIvD,OAAOiC,IAER,CAEAkT,aAAcnV,GAEb,OAASA,GAER,KAAK,EAAG,OAAOiC,KAAK1D,EACpB,KAAK,EAAG,OAAO0D,KAAKxD,EACpB,QAAS,MAAM,IAAIyJ,MAAO,0BAA4BlI,GAIxD,CAEAoV,QAEC,OAAO,IAAInT,KAAKuC,YAAavC,KAAK1D,EAAG0D,KAAKxD,EAE3C,CAEA4W,KAAMC,GAKL,OAHArT,KAAK1D,EAAI+W,EAAE/W,EACX0D,KAAKxD,EAAI6W,EAAE7W,EAEJwD,IAER,CAEAhD,IAAKqW,GAKJ,OAHArT,KAAK1D,GAAK+W,EAAE/W,EACZ0D,KAAKxD,GAAK6W,EAAE7W,EAELwD,IAER,CAEAsT,UAAWpC,GAKV,OAHAlR,KAAK1D,GAAK4U,EACVlR,KAAKxD,GAAK0U,EAEHlR,IAER,CAEAuT,WAAY9K,EAAGiJ,GAKd,OAHA1R,KAAK1D,EAAImM,EAAEnM,EAAIoV,EAAEpV,EACjB0D,KAAKxD,EAAIiM,EAAEjM,EAAIkV,EAAElV,EAEVwD,IAER,CAEAwT,gBAAiBH,EAAGnC,GAKnB,OAHAlR,KAAK1D,GAAK+W,EAAE/W,EAAI4U,EAChBlR,KAAKxD,GAAK6W,EAAE7W,EAAI0U,EAETlR,IAER,CAEAyT,IAAKJ,GAKJ,OAHArT,KAAK1D,GAAK+W,EAAE/W,EACZ0D,KAAKxD,GAAK6W,EAAE7W,EAELwD,IAER,CAEA0T,UAAWxC,GAKV,OAHAlR,KAAK1D,GAAK4U,EACVlR,KAAKxD,GAAK0U,EAEHlR,IAER,CAEA2T,WAAYlL,EAAGiJ,GAKd,OAHA1R,KAAK1D,EAAImM,EAAEnM,EAAIoV,EAAEpV,EACjB0D,KAAKxD,EAAIiM,EAAEjM,EAAIkV,EAAElV,EAEVwD,IAER,CAEA4T,SAAUP,GAKT,OAHArT,KAAK1D,GAAK+W,EAAE/W,EACZ0D,KAAKxD,GAAK6W,EAAE7W,EAELwD,IAER,CAEA6T,eAAgBf,GAKf,OAHA9S,KAAK1D,GAAKwW,EACV9S,KAAKxD,GAAKsW,EAEH9S,IAER,CAEA8T,OAAQT,GAKP,OAHArT,KAAK1D,GAAK+W,EAAE/W,EACZ0D,KAAKxD,GAAK6W,EAAE7W,EAELwD,IAER,CAEA+T,aAAcjB,GAEb,OAAO9S,KAAK6T,eAAgB,EAAIf,EAEjC,CAEAkB,aAAcvF,GAEb,MAAMnS,EAAI0D,KAAK1D,EAAGE,EAAIwD,KAAKxD,EACrBN,EAAIuS,EAAEwF,SAKZ,OAHAjU,KAAK1D,EAAIJ,EAAG,GAAMI,EAAIJ,EAAG,GAAMM,EAAIN,EAAG,GACtC8D,KAAKxD,EAAIN,EAAG,GAAMI,EAAIJ,EAAG,GAAMM,EAAIN,EAAG,GAE/B8D,IAER,CAEArC,IAAK0V,GAKJ,OAHArT,KAAK1D,EAAI0B,KAAKL,IAAKqC,KAAK1D,EAAG+W,EAAE/W,GAC7B0D,KAAKxD,EAAIwB,KAAKL,IAAKqC,KAAKxD,EAAG6W,EAAE7W,GAEtBwD,IAER,CAEAuO,IAAK8E,GAKJ,OAHArT,KAAK1D,EAAI0B,KAAKuQ,IAAKvO,KAAK1D,EAAG+W,EAAE/W,GAC7B0D,KAAKxD,EAAIwB,KAAKuQ,IAAKvO,KAAKxD,EAAG6W,EAAE7W,GAEtBwD,IAER,CAEAsO,MAAO3Q,EAAK4Q,GAOX,OAHAvO,KAAK1D,EAAI0B,KAAKuQ,IAAK5Q,EAAIrB,EAAG0B,KAAKL,IAAK4Q,EAAIjS,EAAG0D,KAAK1D,IAChD0D,KAAKxD,EAAIwB,KAAKuQ,IAAK5Q,EAAInB,EAAGwB,KAAKL,IAAK4Q,EAAI/R,EAAGwD,KAAKxD,IAEzCwD,IAER,CAEAkU,YAAaC,EAAQC,GAKpB,OAHApU,KAAK1D,EAAI0B,KAAKuQ,IAAK4F,EAAQnW,KAAKL,IAAKyW,EAAQpU,KAAK1D,IAClD0D,KAAKxD,EAAIwB,KAAKuQ,IAAK4F,EAAQnW,KAAKL,IAAKyW,EAAQpU,KAAKxD,IAE3CwD,IAER,CAEAqU,YAAa1W,EAAK4Q,GAEjB,MAAM5N,EAASX,KAAKW,SAEpB,OAAOX,KAAK+T,aAAcpT,GAAU,GAAIkT,eAAgB7V,KAAKuQ,IAAK5Q,EAAKK,KAAKL,IAAK4Q,EAAK5N,IAEvF,CAEAtC,QAKC,OAHA2B,KAAK1D,EAAI0B,KAAKK,MAAO2B,KAAK1D,GAC1B0D,KAAKxD,EAAIwB,KAAKK,MAAO2B,KAAKxD,GAEnBwD,IAER,CAEA+O,OAKC,OAHA/O,KAAK1D,EAAI0B,KAAK+Q,KAAM/O,KAAK1D,GACzB0D,KAAKxD,EAAIwB,KAAK+Q,KAAM/O,KAAKxD,GAElBwD,IAER,CAEA2P,QAKC,OAHA3P,KAAK1D,EAAI0B,KAAK2R,MAAO3P,KAAK1D,GAC1B0D,KAAKxD,EAAIwB,KAAK2R,MAAO3P,KAAKxD,GAEnBwD,IAER,CAEAsU,cAKC,OAHAtU,KAAK1D,EAAM0D,KAAK1D,EAAI,EAAM0B,KAAK+Q,KAAM/O,KAAK1D,GAAM0B,KAAKK,MAAO2B,KAAK1D,GACjE0D,KAAKxD,EAAMwD,KAAKxD,EAAI,EAAMwB,KAAK+Q,KAAM/O,KAAKxD,GAAMwB,KAAKK,MAAO2B,KAAKxD,GAE1DwD,IAER,CAEAuU,SAKC,OAHAvU,KAAK1D,GAAM0D,KAAK1D,EAChB0D,KAAKxD,GAAMwD,KAAKxD,EAETwD,IAER,CAEAwU,IAAKnB,GAEJ,OAAOrT,KAAK1D,EAAI+W,EAAE/W,EAAI0D,KAAKxD,EAAI6W,EAAE7W,CAElC,CAEAiY,MAAOpB,GAEN,OAAOrT,KAAK1D,EAAI+W,EAAE7W,EAAIwD,KAAKxD,EAAI6W,EAAE/W,CAElC,CAEAoY,WAEC,OAAO1U,KAAK1D,EAAI0D,KAAK1D,EAAI0D,KAAKxD,EAAIwD,KAAKxD,CAExC,CAEAmE,SAEC,OAAO3C,KAAKC,KAAM+B,KAAK1D,EAAI0D,KAAK1D,EAAI0D,KAAKxD,EAAIwD,KAAKxD,EAEnD,CAEAmY,kBAEC,OAAO3W,KAAKwS,IAAKxQ,KAAK1D,GAAM0B,KAAKwS,IAAKxQ,KAAKxD,EAE5C,CAEAkT,YAEC,OAAO1P,KAAK+T,aAAc/T,KAAKW,UAAY,EAE5C,CAEAiU,QAMC,OAFc5W,KAAKG,OAAS6B,KAAKxD,GAAKwD,KAAK1D,GAAM0B,KAAKI,EAIvD,CAEAyW,QAASxB,GAER,MAAMyB,EAAc9W,KAAKC,KAAM+B,KAAK0U,WAAarB,EAAEqB,YAEnD,GAAqB,IAAhBI,EAAoB,OAAO9W,KAAKI,GAAK,EAE1C,MAAM2W,EAAQ/U,KAAKwU,IAAKnB,GAAMyB,EAI9B,OAAO9W,KAAKgX,KAAM1G,GAAOyG,GAAS,EAAG,GAEtC,CAEAE,WAAY5B,GAEX,OAAOrV,KAAKC,KAAM+B,KAAKkV,kBAAmB7B,GAE3C,CAEA6B,kBAAmB7B,GAElB,MAAMxV,EAAKmC,KAAK1D,EAAI+W,EAAE/W,EAAGwB,EAAKkC,KAAKxD,EAAI6W,EAAE7W,EACzC,OAAOqB,EAAKA,EAAKC,EAAKA,CAEvB,CAEAqX,oBAAqB9B,GAEpB,OAAOrV,KAAKwS,IAAKxQ,KAAK1D,EAAI+W,EAAE/W,GAAM0B,KAAKwS,IAAKxQ,KAAKxD,EAAI6W,EAAE7W,EAExD,CAEA4Y,UAAWzU,GAEV,OAAOX,KAAK0P,YAAYmE,eAAgBlT,EAEzC,CAEA+N,KAAM2E,EAAGgC,GAKR,OAHArV,KAAK1D,IAAO+W,EAAE/W,EAAI0D,KAAK1D,GAAM+Y,EAC7BrV,KAAKxD,IAAO6W,EAAE7W,EAAIwD,KAAKxD,GAAM6Y,EAEtBrV,IAER,CAEAsV,YAAaC,EAAIC,EAAIH,GAKpB,OAHArV,KAAK1D,EAAIiZ,EAAGjZ,GAAMkZ,EAAGlZ,EAAIiZ,EAAGjZ,GAAM+Y,EAClCrV,KAAKxD,EAAI+Y,EAAG/Y,GAAMgZ,EAAGhZ,EAAI+Y,EAAG/Y,GAAM6Y,EAE3BrV,IAER,CAEAyV,OAAQpC,GAEP,OAAWA,EAAE/W,IAAM0D,KAAK1D,GAAS+W,EAAE7W,IAAMwD,KAAKxD,CAE/C,CAEAkZ,UAAWjI,EAAOkI,EAAS,GAK1B,OAHA3V,KAAK1D,EAAImR,EAAOkI,GAChB3V,KAAKxD,EAAIiR,EAAOkI,EAAS,GAElB3V,IAER,CAEA4V,QAASnI,EAAQ,GAAIkI,EAAS,GAK7B,OAHAlI,EAAOkI,GAAW3V,KAAK1D,EACvBmR,EAAOkI,EAAS,GAAM3V,KAAKxD,EAEpBiR,CAER,CAEAoI,oBAAqBC,EAAW/X,GAK/B,OAHAiC,KAAK1D,EAAIwZ,EAAUC,KAAMhY,GACzBiC,KAAKxD,EAAIsZ,EAAUE,KAAMjY,GAElBiC,IAER,CAEAiW,aAAcC,EAAQtB,GAErB,MAAMjD,EAAI3T,KAAK6T,IAAK+C,GAAS1D,EAAIlT,KAAK8T,IAAK8C,GAErCtY,EAAI0D,KAAK1D,EAAI4Z,EAAO5Z,EACpBE,EAAIwD,KAAKxD,EAAI0Z,EAAO1Z,EAK1B,OAHAwD,KAAK1D,EAAIA,EAAIqV,EAAInV,EAAI0U,EAAIgF,EAAO5Z,EAChC0D,KAAKxD,EAAIF,EAAI4U,EAAI1U,EAAImV,EAAIuE,EAAO1Z,EAEzBwD,IAER,CAEAiO,SAKC,OAHAjO,KAAK1D,EAAI0B,KAAKiQ,SACdjO,KAAKxD,EAAIwB,KAAKiQ,SAEPjO,IAER,CAEA,EAAGqB,OAAOC,kBAEHtB,KAAK1D,QACL0D,KAAKxD,CAEZ,EAID,MAAM2Z,GAEL5T,YAAa6T,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,GAEpDT,GAAQ9T,UAAUwU,WAAY,EAE9B7W,KAAKiU,SAAW,CAEf,EAAG,EAAG,EACN,EAAG,EAAG,EACN,EAAG,EAAG,QAIM9W,IAARiZ,GAEJpW,KAAKuS,IAAK6D,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAIpD,CAEArE,IAAK6D,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,GAE5C,MAAME,EAAK9W,KAAKiU,SAMhB,OAJA6C,EAAI,GAAMV,EAAKU,EAAI,GAAMP,EAAKO,EAAI,GAAMJ,EACxCI,EAAI,GAAMT,EAAKS,EAAI,GAAMN,EAAKM,EAAI,GAAMH,EACxCG,EAAI,GAAMR,EAAKQ,EAAI,GAAML,EAAKK,EAAI,GAAMF,EAEjC5W,IAER,CAEA+W,WAUC,OARA/W,KAAKuS,IAEJ,EAAG,EAAG,EACN,EAAG,EAAG,EACN,EAAG,EAAG,GAIAvS,IAER,CAEAoT,KAAM3E,GAEL,MAAMqI,EAAK9W,KAAKiU,SACV+C,EAAKvI,EAAEwF,SAMb,OAJA6C,EAAI,GAAME,EAAI,GAAKF,EAAI,GAAME,EAAI,GAAKF,EAAI,GAAME,EAAI,GACpDF,EAAI,GAAME,EAAI,GAAKF,EAAI,GAAME,EAAI,GAAKF,EAAI,GAAME,EAAI,GACpDF,EAAI,GAAME,EAAI,GAAKF,EAAI,GAAME,EAAI,GAAKF,EAAI,GAAME,EAAI,GAE7ChX,IAER,CAEAiX,aAAcC,EAAOC,EAAOC,GAM3B,OAJAF,EAAMG,qBAAsBrX,KAAM,GAClCmX,EAAME,qBAAsBrX,KAAM,GAClCoX,EAAMC,qBAAsBrX,KAAM,GAE3BA,IAER,CAEAsX,eAAgB7I,GAEf,MAAMuI,EAAKvI,EAAEwF,SAUb,OARAjU,KAAKuS,IAEJyE,EAAI,GAAKA,EAAI,GAAKA,EAAI,GACtBA,EAAI,GAAKA,EAAI,GAAKA,EAAI,GACtBA,EAAI,GAAKA,EAAI,GAAKA,EAAI,KAIhBhX,IAER,CAEA4T,SAAUnF,GAET,OAAOzO,KAAKuX,iBAAkBvX,KAAMyO,EAErC,CAEA+I,YAAa/I,GAEZ,OAAOzO,KAAKuX,iBAAkB9I,EAAGzO,KAElC,CAEAuX,iBAAkB9O,EAAGiJ,GAEpB,MAAM+F,EAAKhP,EAAEwL,SACPyD,EAAKhG,EAAEuC,SACP6C,EAAK9W,KAAKiU,SAEV0D,EAAMF,EAAI,GAAKG,EAAMH,EAAI,GAAKI,EAAMJ,EAAI,GACxCK,EAAML,EAAI,GAAKM,EAAMN,EAAI,GAAKO,EAAMP,EAAI,GACxCQ,EAAMR,EAAI,GAAKS,EAAMT,EAAI,GAAKU,EAAMV,EAAI,GAExCW,EAAMV,EAAI,GAAKW,EAAMX,EAAI,GAAKY,EAAMZ,EAAI,GACxCa,EAAMb,EAAI,GAAKc,EAAMd,EAAI,GAAKe,EAAMf,EAAI,GACxCgB,EAAMhB,EAAI,GAAKiB,EAAMjB,EAAI,GAAKkB,EAAMlB,EAAI,GAc9C,OAZAZ,EAAI,GAAMa,EAAMS,EAAMR,EAAMW,EAAMV,EAAMa,EACxC5B,EAAI,GAAMa,EAAMU,EAAMT,EAAMY,EAAMX,EAAMc,EACxC7B,EAAI,GAAMa,EAAMW,EAAMV,EAAMa,EAAMZ,EAAMe,EAExC9B,EAAI,GAAMgB,EAAMM,EAAML,EAAMQ,EAAMP,EAAMU,EACxC5B,EAAI,GAAMgB,EAAMO,EAAMN,EAAMS,EAAMR,EAAMW,EACxC7B,EAAI,GAAMgB,EAAMQ,EAAMP,EAAMU,EAAMT,EAAMY,EAExC9B,EAAI,GAAMmB,EAAMG,EAAMF,EAAMK,EAAMJ,EAAMO,EACxC5B,EAAI,GAAMmB,EAAMI,EAAMH,EAAMM,EAAML,EAAMQ,EACxC7B,EAAI,GAAMmB,EAAMK,EAAMJ,EAAMO,EAAMN,EAAMS,EAEjC5Y,IAER,CAEA6T,eAAgB3C,GAEf,MAAM4F,EAAK9W,KAAKiU,SAMhB,OAJA6C,EAAI,IAAO5F,EAAG4F,EAAI,IAAO5F,EAAG4F,EAAI,IAAO5F,EACvC4F,EAAI,IAAO5F,EAAG4F,EAAI,IAAO5F,EAAG4F,EAAI,IAAO5F,EACvC4F,EAAI,IAAO5F,EAAG4F,EAAI,IAAO5F,EAAG4F,EAAI,IAAO5F,EAEhClR,IAER,CAEA6Y,cAEC,MAAM/B,EAAK9W,KAAKiU,SAEVxL,EAAIqO,EAAI,GAAKpF,EAAIoF,EAAI,GAAKnF,EAAImF,EAAI,GACvCtO,EAAIsO,EAAI,GAAK5a,EAAI4a,EAAI,GAAKgC,EAAIhC,EAAI,GAClCiC,EAAIjC,EAAI,GAAKkC,EAAIlC,EAAI,GAAKxW,EAAIwW,EAAI,GAEnC,OAAOrO,EAAIvM,EAAIoE,EAAImI,EAAIqQ,EAAIE,EAAItH,EAAIlJ,EAAIlI,EAAIoR,EAAIoH,EAAIC,EAAIpH,EAAInJ,EAAIwQ,EAAIrH,EAAIzV,EAAI6c,CAE5E,CAEAE,SAEC,MAAMnC,EAAK9W,KAAKiU,SAEfmC,EAAMU,EAAI,GAAKP,EAAMO,EAAI,GAAKJ,EAAMI,EAAI,GACxCT,EAAMS,EAAI,GAAKN,EAAMM,EAAI,GAAKH,EAAMG,EAAI,GACxCR,EAAMQ,EAAI,GAAKL,EAAMK,EAAI,GAAKF,EAAME,EAAI,GAExCoC,EAAMtC,EAAMJ,EAAMG,EAAMF,EACxB0C,EAAMxC,EAAML,EAAMM,EAAMP,EACxB+C,EAAM3C,EAAMJ,EAAMG,EAAMF,EAExB+C,EAAMjD,EAAM8C,EAAM3C,EAAM4C,EAAMzC,EAAM0C,EAErC,GAAa,IAARC,EAAY,OAAOrZ,KAAKuS,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAE1D,MAAM+G,EAAS,EAAID,EAcnB,OAZAvC,EAAI,GAAMoC,EAAMI,EAChBxC,EAAI,IAAQJ,EAAMD,EAAMG,EAAML,GAAQ+C,EACtCxC,EAAI,IAAQH,EAAMJ,EAAMG,EAAMF,GAAQ8C,EAEtCxC,EAAI,GAAMqC,EAAMG,EAChBxC,EAAI,IAAQF,EAAMR,EAAMM,EAAMJ,GAAQgD,EACtCxC,EAAI,IAAQJ,EAAML,EAAMM,EAAMP,GAAQkD,EAEtCxC,EAAI,GAAMsC,EAAME,EAChBxC,EAAI,IAAQP,EAAMD,EAAMG,EAAML,GAAQkD,EACtCxC,EAAI,IAAQN,EAAMJ,EAAMG,EAAMF,GAAQiD,EAE/BtZ,IAER,CAEAuZ,YAEC,IAAIC,EACJ,MAAM/K,EAAIzO,KAAKiU,SAMf,OAJAuF,EAAM/K,EAAG,GAAKA,EAAG,GAAMA,EAAG,GAAKA,EAAG,GAAM+K,EACxCA,EAAM/K,EAAG,GAAKA,EAAG,GAAMA,EAAG,GAAKA,EAAG,GAAM+K,EACxCA,EAAM/K,EAAG,GAAKA,EAAG,GAAMA,EAAG,GAAKA,EAAG,GAAM+K,EAEjCxZ,IAER,CAEAyZ,gBAAiBC,GAEhB,OAAO1Z,KAAKsX,eAAgBoC,GAAUT,SAASM,WAEhD,CAEAI,mBAAoB3Q,GAEnB,MAAMyF,EAAIzO,KAAKiU,SAYf,OAVAjL,EAAG,GAAMyF,EAAG,GACZzF,EAAG,GAAMyF,EAAG,GACZzF,EAAG,GAAMyF,EAAG,GACZzF,EAAG,GAAMyF,EAAG,GACZzF,EAAG,GAAMyF,EAAG,GACZzF,EAAG,GAAMyF,EAAG,GACZzF,EAAG,GAAMyF,EAAG,GACZzF,EAAG,GAAMyF,EAAG,GACZzF,EAAG,GAAMyF,EAAG,GAELzO,IAER,CAEA4Z,eAAgBC,EAAIC,EAAIC,EAAIC,EAAIC,EAAUC,EAAIC,GAE7C,MAAMxI,EAAI3T,KAAK6T,IAAKoI,GACd/I,EAAIlT,KAAK8T,IAAKmI,GAQpB,OANAja,KAAKuS,IACJwH,EAAKpI,EAAGoI,EAAK7I,GAAK6I,GAAOpI,EAAIuI,EAAKhJ,EAAIiJ,GAAOD,EAAKL,GAChDG,EAAK9I,EAAG8I,EAAKrI,GAAKqI,IAAS9I,EAAIgJ,EAAKvI,EAAIwI,GAAOA,EAAKL,EACtD,EAAG,EAAG,GAGA9Z,IAER,CAIAoa,MAAOL,EAAIC,GAIV,OAFAha,KAAKwX,YAAa6C,GAAIC,UAAWP,EAAIC,IAE9Bha,IAER,CAEAua,OAAQxF,GAIP,OAFA/U,KAAKwX,YAAa6C,GAAIG,cAAgBzF,IAE/B/U,IAER,CAEAya,UAAWZ,EAAIC,GAId,OAFA9Z,KAAKwX,YAAa6C,GAAIK,gBAAiBb,EAAIC,IAEpC9Z,IAER,CAIA0a,gBAAiBpe,EAAGE,GAwBnB,OAtBKF,EAAEoW,UAEN1S,KAAKuS,IAEJ,EAAG,EAAGjW,EAAEA,EACR,EAAG,EAAGA,EAAEE,EACR,EAAG,EAAG,GAMPwD,KAAKuS,IAEJ,EAAG,EAAGjW,EACN,EAAG,EAAGE,EACN,EAAG,EAAG,GAMDwD,IAER,CAEAwa,aAAczF,GAIb,MAAMpD,EAAI3T,KAAK6T,IAAKkD,GACd7D,EAAIlT,KAAK8T,IAAKiD,GAUpB,OARA/U,KAAKuS,IAEJZ,GAAKT,EAAG,EACRA,EAAGS,EAAG,EACN,EAAG,EAAG,GAIA3R,IAER,CAEAsa,UAAWhe,EAAGE,GAUb,OARAwD,KAAKuS,IAEJjW,EAAG,EAAG,EACN,EAAGE,EAAG,EACN,EAAG,EAAG,GAIAwD,IAER,CAIAyV,OAAQkF,GAEP,MAAM7D,EAAK9W,KAAKiU,SACV+C,EAAK2D,EAAO1G,SAElB,IAAM,IAAI3T,EAAI,EAAGA,EAAI,EAAGA,IAEvB,GAAKwW,EAAIxW,KAAQ0W,EAAI1W,GAAM,OAAO,EAInC,OAAO,CAER,CAEAoV,UAAWjI,EAAOkI,EAAS,GAE1B,IAAM,IAAIrV,EAAI,EAAGA,EAAI,EAAGA,IAEvBN,KAAKiU,SAAU3T,GAAMmN,EAAOnN,EAAIqV,GAIjC,OAAO3V,IAER,CAEA4V,QAASnI,EAAQ,GAAIkI,EAAS,GAE7B,MAAMmB,EAAK9W,KAAKiU,SAchB,OAZAxG,EAAOkI,GAAWmB,EAAI,GACtBrJ,EAAOkI,EAAS,GAAMmB,EAAI,GAC1BrJ,EAAOkI,EAAS,GAAMmB,EAAI,GAE1BrJ,EAAOkI,EAAS,GAAMmB,EAAI,GAC1BrJ,EAAOkI,EAAS,GAAMmB,EAAI,GAC1BrJ,EAAOkI,EAAS,GAAMmB,EAAI,GAE1BrJ,EAAOkI,EAAS,GAAMmB,EAAI,GAC1BrJ,EAAOkI,EAAS,GAAMmB,EAAI,GAC1BrJ,EAAOkI,EAAS,GAAMmB,EAAI,GAEnBrJ,CAER,CAEA0F,QAEC,OAAO,IAAInT,KAAKuC,aAAcmT,UAAW1V,KAAKiU,SAE/C,EAID,MAAMoG,GAAoB,IAAIlE,GAE9B,SAASyE,GAAkBnN,GAI1B,IAAM,IAAInN,EAAImN,EAAM9M,OAAS,EAAGL,GAAK,IAAMA,EAE1C,GAAKmN,EAAOnN,IAAO,MAAQ,OAAO,EAInC,OAAO,CAER,CAoBA,SAASua,GAAiBrY,GAEzB,OAAOzG,SAAS8e,gBAAiB,+BAAgCrY,EAElE,CArBYiN,UACCH,WACOwL,kBACPtL,WACCH,YACDE,WACCH,YACCD,aACA4L,aAef,MAAMC,GAAS,CAAC,EAEhB,SAASC,GAAUC,GAEbA,KAAWF,KAEhBA,GAAQE,IAAY,EAEpB5c,QAAQkU,KAAM0I,GAEf,CAEA,SAASC,GAAcxJ,GAEtB,OAASA,EAAI,OAAgB,YAAJA,EAAmB3T,KAAK8Q,IAAS,YAAJ6C,EAAmB,YAAc,IAExF,CAEA,SAASyJ,GAAczJ,GAEtB,OAASA,EAAI,SAAkB,MAAJA,EAAY,MAAU3T,KAAK8Q,IAAK6C,EAAG,QAAc,IAE7E,CAcA,MAAM0J,IAAiD,IAAIlF,IAAUT,UAAW,CAC/E,SAAW,SAAW,SACtB,QAAW,SAAW,UACpB,KAAW,KAAW,WAGnB4F,IAAiD,IAAInF,IAAUT,UAAW,CAC/E,WAAa,UAAa,UACxB,SAAW,WAAa,SAC1B,KAAW,EAAW,YAkBjB6F,GAAY,CACjB,CAAEjP,IAA0BkP,GAAWA,EACvC,CAAEnP,IAAoBmP,GAAWA,EAAMC,sBACvC,CAAElP,IAlBH,SAAgCiP,GAG/B,OAAOA,EAAMC,sBAAsBzH,aAAcsH,GAElD,GAiBMI,GAAc,CACnB,CAAEpP,IAA0BkP,GAAWA,EACvC,CAAEnP,IAAoBmP,GAAWA,EAAMG,sBACvC,CAAEpP,IAlBH,SAAgCiP,GAG/B,OAAOA,EAAMxH,aAAcqH,IAAmCM,qBAE/D,GAgBMC,GAAkB,CAEvBC,SAAS,EAELC,iBAIH,OAFAxd,QAAQkU,KAAM,+EAELxS,KAAK6b,OAEf,EAEIC,eAAYA,GAEfxd,QAAQkU,KAAM,8EAEdxS,KAAK6b,SAAYC,CAElB,EAEIC,wBAEH,OAAOzP,EAER,EAEIyP,sBAAmBC,GAEtB1d,QAAQkU,KAAM,yDAEf,EAEAyJ,QAAS,SAAWT,EAAOU,EAAkBC,GAE5C,IAAsB,IAAjBnc,KAAK6b,SAAqBK,IAAqBC,IAAsBD,IAAsBC,EAE/F,OAAOX,EAIR,MAAMY,EAAiBb,GAAWW,GAC5BG,EAAmBX,GAAaS,GAEtC,QAAwBhf,IAAnBif,QAAqDjf,IAArBkf,EAEpC,MAAM,IAAIpW,MAAO,wCAAyCiW,UAA2BC,OAItF,OAAOE,EAAkBD,EAAgBZ,GAE1C,EAEAc,sBAAuB,SAAWd,EAAOW,GAExC,OAAOnc,KAAKic,QAAST,EAAOxb,KAAK+b,kBAAmBI,EAErD,EAEAI,oBAAqB,SAAWf,EAAOU,GAEtC,OAAOlc,KAAKic,QAAST,EAAOU,EAAkBlc,KAAK+b,kBAEpD,GAID,IAAIS,GAEJ,MAAMC,GAELC,kBAAmBC,GAElB,GAAK,UAAUja,KAAMia,EAAMC,KAE1B,OAAOD,EAAMC,IAId,GAAkC,oBAAtBC,kBAEX,OAAOF,EAAMC,IAId,IAAIE,EAEJ,GAAKH,aAAiBE,kBAErBC,EAASH,MAEH,MAEWxf,IAAZqf,KAAwBA,GAAU3B,GAAiB,WAExD2B,GAAQ7J,MAAQgK,EAAMhK,MACtB6J,GAAQ5J,OAAS+J,EAAM/J,OAEvB,MAAMmK,EAAUP,GAAQQ,WAAY,MAE/BL,aAAiBM,UAErBF,EAAQG,aAAcP,EAAO,EAAG,GAIhCI,EAAQI,UAAWR,EAAO,EAAG,EAAGA,EAAMhK,MAAOgK,EAAM/J,QAIpDkK,EAASN,EAEV,CAEA,OAAKM,EAAOnK,MAAQ,MAAQmK,EAAOlK,OAAS,MAE3CtU,QAAQkU,KAAM,8EAA+EmK,GAEtFG,EAAOM,UAAW,aAAc,KAIhCN,EAAOM,UAAW,YAI3B,CAEAV,oBAAqBC,GAEpB,GAAmC,oBAArBU,kBAAoCV,aAAiBU,kBACnC,oBAAtBR,mBAAqCF,aAAiBE,mBACtC,oBAAhBS,aAA+BX,aAAiBW,YAAgB,CAEzE,MAAMR,EAASjC,GAAiB,UAEhCiC,EAAOnK,MAAQgK,EAAMhK,MACrBmK,EAAOlK,OAAS+J,EAAM/J,OAEtB,MAAMmK,EAAUD,EAAOE,WAAY,MACnCD,EAAQI,UAAWR,EAAO,EAAG,EAAGA,EAAMhK,MAAOgK,EAAM/J,QAEnD,MAAM2K,EAAYR,EAAQS,aAAc,EAAG,EAAGb,EAAMhK,MAAOgK,EAAM/J,QAC3DvP,EAAOka,EAAUla,KAEvB,IAAM,IAAI/C,EAAI,EAAGA,EAAI+C,EAAK1C,OAAQL,IAEjC+C,EAAM/C,GAAwC,IAAlC6a,GAAc9X,EAAM/C,GAAM,KAMvC,OAFAyc,EAAQG,aAAcK,EAAW,EAAG,GAE7BT,CAER,CAAO,GAAKH,EAAMtZ,KAAO,CAExB,MAAMA,EAAOsZ,EAAMtZ,KAAKf,MAAO,GAE/B,IAAM,IAAIhC,EAAI,EAAGA,EAAI+C,EAAK1C,OAAQL,IAE5B+C,aAAgBiM,YAAcjM,aAAgByX,kBAElDzX,EAAM/C,GAAMtC,KAAKK,MAAyC,IAAlC8c,GAAc9X,EAAM/C,GAAM,MAMlD+C,EAAM/C,GAAM6a,GAAc9X,EAAM/C,IAMlC,MAAO,CACN+C,KAAMA,EACNsP,MAAOgK,EAAMhK,MACbC,OAAQ+J,EAAM/J,OAGhB,CAGC,OADAtU,QAAQkU,KAAM,+FACPmK,CAIT,EAID,IAAIc,GAAW,EAEf,MAAMC,GAELnb,YAAac,EAAO,MAEnBrD,KAAK2d,UAAW,EAEhBvb,OAAOuG,eAAgB3I,KAAM,KAAM,CAAE5C,MAAOqgB,OAE5Czd,KAAK4d,KAAO7P,KAEZ/N,KAAKqD,KAAOA,EAEZrD,KAAK6d,QAAU,CAEhB,CAEIC,gBAAa1gB,IAED,IAAVA,GAAiB4C,KAAK6d,SAE5B,CAEAE,OAAQC,GAEP,MAAMC,OAA0B9gB,IAAT6gB,GAAsC,iBAATA,EAEpD,IAAOC,QAA6C9gB,IAA7B6gB,EAAKE,OAAQle,KAAK4d,MAExC,OAAOI,EAAKE,OAAQle,KAAK4d,MAI1B,MAAMO,EAAS,CACdP,KAAM5d,KAAK4d,KACXja,IAAK,IAGAN,EAAOrD,KAAKqD,KAElB,GAAc,OAATA,EAAgB,CAEpB,IAAIM,EAEJ,GAAK1C,MAAME,QAASkC,GAAS,CAI5BM,EAAM,GAEN,IAAM,IAAIrD,EAAI,EAAGoN,EAAIrK,EAAK1C,OAAQL,EAAIoN,EAAGpN,IAEnC+C,EAAM/C,GAAI8d,cAEdza,EAAIlE,KAAM4e,GAAgBhb,EAAM/C,GAAIqc,QAIpChZ,EAAIlE,KAAM4e,GAAgBhb,EAAM/C,IAMnC,MAICqD,EAAM0a,GAAgBhb,GAIvB8a,EAAOxa,IAAMA,CAEd,CAQA,OANOsa,IAEND,EAAKE,OAAQle,KAAK4d,MAASO,GAIrBA,CAER,EAID,SAASE,GAAgB1B,GAExB,MAAmC,oBAArBU,kBAAoCV,aAAiBU,kBACnC,oBAAtBR,mBAAqCF,aAAiBE,mBACtC,oBAAhBS,aAA+BX,aAAiBW,YAIlDb,GAAW6B,WAAY3B,GAIzBA,EAAMtZ,KAIH,CACNA,KAAMpC,MAAMwB,KAAMka,EAAMtZ,MACxBsP,MAAOgK,EAAMhK,MACbC,OAAQ+J,EAAM/J,OACd7F,KAAM4P,EAAMtZ,KAAKd,YAAYC,OAK9BlE,QAAQkU,KAAM,+CACP,CAAC,EAMX,CAEA,IAAI+L,GAAY,EAEhB,MAAMC,WAAgB1R,GAErBvK,YAAaoa,EAAQ6B,GAAQC,cAAeC,EAAUF,GAAQG,gBAAiBC,EAAQpU,EAAqBqU,EAAQrU,EAAqBsU,EAAYjU,EAAckU,EAAYhU,EAA0BiU,EAAS1T,KAAYyB,EAAO/B,KAAkBiU,EAAaT,GAAQU,mBAAoBlD,EAAamD,IAE5SC,QAEApf,KAAKqf,WAAY,EAEjBjd,OAAOuG,eAAgB3I,KAAM,KAAM,CAAE5C,MAAOmhB,OAE5Cve,KAAK4d,KAAO7P,KAEZ/N,KAAKwC,KAAO,GAEZxC,KAAKyD,OAAS,IAAIia,GAAQf,GAC1B3c,KAAKsf,QAAU,GAEftf,KAAK0e,QAAUA,EACf1e,KAAKuf,QAAU,EAEfvf,KAAK4e,MAAQA,EACb5e,KAAK6e,MAAQA,EAEb7e,KAAK8e,UAAYA,EACjB9e,KAAK+e,UAAYA,EAEjB/e,KAAKif,WAAaA,EAElBjf,KAAKgf,OAASA,EACdhf,KAAKwf,eAAiB,KACtBxf,KAAK+M,KAAOA,EAEZ/M,KAAK2V,OAAS,IAAIlD,GAAS,EAAG,GAC9BzS,KAAKyf,OAAS,IAAIhN,GAAS,EAAG,GAC9BzS,KAAKkW,OAAS,IAAIzD,GAAS,EAAG,GAC9BzS,KAAKia,SAAW,EAEhBja,KAAK0f,kBAAmB,EACxB1f,KAAK2a,OAAS,IAAIxE,GAElBnW,KAAK2f,iBAAkB,EACvB3f,KAAK4f,kBAAmB,EACxB5f,KAAK6f,OAAQ,EACb7f,KAAK8f,gBAAkB,EAEI,iBAAf9D,EAEXhc,KAAKgc,WAAaA,GAIlBf,GAAU,uEACVjb,KAAKgc,WAAaA,IAAe5P,EAAeC,GA1xD9B,IA+xDnBrM,KAAK+f,SAAW,CAAC,EAEjB/f,KAAK6d,QAAU,EACf7d,KAAKggB,SAAW,KAEhBhgB,KAAKigB,uBAAwB,EAC7BjgB,KAAKkgB,kBAAmB,CAEzB,CAEIvD,YAEH,OAAO3c,KAAKyD,OAAOJ,IAEpB,CAEIsZ,UAAOvf,EAAQ,MAElB4C,KAAKyD,OAAOJ,KAAOjG,CAEpB,CAEA+iB,eAECngB,KAAK2a,OAAOf,eAAgB5Z,KAAK2V,OAAOrZ,EAAG0D,KAAK2V,OAAOnZ,EAAGwD,KAAKyf,OAAOnjB,EAAG0D,KAAKyf,OAAOjjB,EAAGwD,KAAKia,SAAUja,KAAKkW,OAAO5Z,EAAG0D,KAAKkW,OAAO1Z,EAEnI,CAEA2W,QAEC,OAAO,IAAInT,KAAKuC,aAAc6Q,KAAMpT,KAErC,CAEAoT,KAAM3P,GAwCL,OAtCAzD,KAAKwC,KAAOiB,EAAOjB,KAEnBxC,KAAKyD,OAASA,EAAOA,OACrBzD,KAAKsf,QAAU7b,EAAO6b,QAAQhd,MAAO,GAErCtC,KAAK0e,QAAUjb,EAAOib,QACtB1e,KAAKuf,QAAU9b,EAAO8b,QAEtBvf,KAAK4e,MAAQnb,EAAOmb,MACpB5e,KAAK6e,MAAQpb,EAAOob,MAEpB7e,KAAK8e,UAAYrb,EAAOqb,UACxB9e,KAAK+e,UAAYtb,EAAOsb,UAExB/e,KAAKif,WAAaxb,EAAOwb,WAEzBjf,KAAKgf,OAASvb,EAAOub,OACrBhf,KAAKwf,eAAiB/b,EAAO+b,eAC7Bxf,KAAK+M,KAAOtJ,EAAOsJ,KAEnB/M,KAAK2V,OAAOvC,KAAM3P,EAAOkS,QACzB3V,KAAKyf,OAAOrM,KAAM3P,EAAOgc,QACzBzf,KAAKkW,OAAO9C,KAAM3P,EAAOyS,QACzBlW,KAAKia,SAAWxW,EAAOwW,SAEvBja,KAAK0f,iBAAmBjc,EAAOic,iBAC/B1f,KAAK2a,OAAOvH,KAAM3P,EAAOkX,QAEzB3a,KAAK2f,gBAAkBlc,EAAOkc,gBAC9B3f,KAAK4f,iBAAmBnc,EAAOmc,iBAC/B5f,KAAK6f,MAAQpc,EAAOoc,MACpB7f,KAAK8f,gBAAkBrc,EAAOqc,gBAC9B9f,KAAKgc,WAAavY,EAAOuY,WAEzBhc,KAAK+f,SAAW5c,KAAKid,MAAOjd,KAAKC,UAAWK,EAAOsc,WAEnD/f,KAAK8d,aAAc,EAEZ9d,IAER,CAEA+d,OAAQC,GAEP,MAAMC,OAA0B9gB,IAAT6gB,GAAsC,iBAATA,EAEpD,IAAOC,QAA+C9gB,IAA/B6gB,EAAKqC,SAAUrgB,KAAK4d,MAE1C,OAAOI,EAAKqC,SAAUrgB,KAAK4d,MAI5B,MAAMO,EAAS,CAEdmC,SAAU,CACTzC,QAAS,IACT9Q,KAAM,UACNwT,UAAW,kBAGZ3C,KAAM5d,KAAK4d,KACXpb,KAAMxC,KAAKwC,KAEXma,MAAO3c,KAAKyD,OAAOsa,OAAQC,GAAOJ,KAElCc,QAAS1e,KAAK0e,QACda,QAASvf,KAAKuf,QAEdE,OAAQ,CAAEzf,KAAKyf,OAAOnjB,EAAG0D,KAAKyf,OAAOjjB,GACrCmZ,OAAQ,CAAE3V,KAAK2V,OAAOrZ,EAAG0D,KAAK2V,OAAOnZ,GACrC0Z,OAAQ,CAAElW,KAAKkW,OAAO5Z,EAAG0D,KAAKkW,OAAO1Z,GACrCyd,SAAUja,KAAKia,SAEfuG,KAAM,CAAExgB,KAAK4e,MAAO5e,KAAK6e,OAEzBG,OAAQhf,KAAKgf,OACbQ,eAAgBxf,KAAKwf,eACrBzS,KAAM/M,KAAK+M,KACXiP,WAAYhc,KAAKgc,WAEjB+C,UAAW/e,KAAK+e,UAChBD,UAAW9e,KAAK8e,UAChBG,WAAYjf,KAAKif,WAEjBY,MAAO7f,KAAK6f,MAEZF,gBAAiB3f,KAAK2f,gBACtBC,iBAAkB5f,KAAK4f,iBACvBE,gBAAiB9f,KAAK8f,iBAYvB,OARK1d,OAAOyD,KAAM7F,KAAK+f,UAAWpf,OAAS,IAAIwd,EAAO4B,SAAW/f,KAAK+f,UAE/D9B,IAEND,EAAKqC,SAAUrgB,KAAK4d,MAASO,GAIvBA,CAER,CAEAsC,UAECzgB,KAAKuN,cAAe,CAAER,KAAM,WAE7B,CAEA2T,YAAaC,GAEZ,GAnhEgB,MAmhEX3gB,KAAK0e,QAAwB,OAAOiC,EAIzC,GAFAA,EAAG3M,aAAchU,KAAK2a,QAEjBgG,EAAGrkB,EAAI,GAAKqkB,EAAGrkB,EAAI,EAEvB,OAAS0D,KAAK4e,OAEb,KAAKrU,EAEJoW,EAAGrkB,EAAIqkB,EAAGrkB,EAAI0B,KAAKK,MAAOsiB,EAAGrkB,GAC7B,MAED,KAAKkO,EAEJmW,EAAGrkB,EAAIqkB,EAAGrkB,EAAI,EAAI,EAAI,EACtB,MAED,KAAKmO,EAEwC,IAAvCzM,KAAKwS,IAAKxS,KAAKK,MAAOsiB,EAAGrkB,GAAM,GAEnCqkB,EAAGrkB,EAAI0B,KAAK+Q,KAAM4R,EAAGrkB,GAAMqkB,EAAGrkB,EAI9BqkB,EAAGrkB,EAAIqkB,EAAGrkB,EAAI0B,KAAKK,MAAOsiB,EAAGrkB,GAUjC,GAAKqkB,EAAGnkB,EAAI,GAAKmkB,EAAGnkB,EAAI,EAEvB,OAASwD,KAAK6e,OAEb,KAAKtU,EAEJoW,EAAGnkB,EAAImkB,EAAGnkB,EAAIwB,KAAKK,MAAOsiB,EAAGnkB,GAC7B,MAED,KAAKgO,EAEJmW,EAAGnkB,EAAImkB,EAAGnkB,EAAI,EAAI,EAAI,EACtB,MAED,KAAKiO,EAEwC,IAAvCzM,KAAKwS,IAAKxS,KAAKK,MAAOsiB,EAAGnkB,GAAM,GAEnCmkB,EAAGnkB,EAAIwB,KAAK+Q,KAAM4R,EAAGnkB,GAAMmkB,EAAGnkB,EAI9BmkB,EAAGnkB,EAAImkB,EAAGnkB,EAAIwB,KAAKK,MAAOsiB,EAAGnkB,GAgBjC,OANKwD,KAAK6f,QAETc,EAAGnkB,EAAI,EAAImkB,EAAGnkB,GAIRmkB,CAER,CAEI7C,gBAAa1gB,IAED,IAAVA,IAEJ4C,KAAK6d,UACL7d,KAAKyD,OAAOqa,aAAc,EAI5B,CAEI8C,eAGH,OADA3F,GAAU,uEACHjb,KAAKgc,aAAe3P,GAAiBD,EAxhEvB,GA0hEtB,CAEIwU,aAAUA,GAEb3F,GAAU,uEACVjb,KAAKgc,WAAa4E,IAAaxU,EAAeC,GAthE3B,EAwhEpB,EAIDmS,GAAQC,cAAgB,KACxBD,GAAQG,gBA7nEU,IA8nElBH,GAAQU,mBAAqB,EAE7B,MAAM2B,GAELte,YAAajG,EAAI,EAAGE,EAAI,EAAGskB,EAAI,EAAGC,EAAI,GAErCF,GAAQxe,UAAU2e,WAAY,EAE9BhhB,KAAK1D,EAAIA,EACT0D,KAAKxD,EAAIA,EACTwD,KAAK8gB,EAAIA,EACT9gB,KAAK+gB,EAAIA,CAEV,CAEIpO,YAEH,OAAO3S,KAAK8gB,CAEb,CAEInO,UAAOvV,GAEV4C,KAAK8gB,EAAI1jB,CAEV,CAEIwV,aAEH,OAAO5S,KAAK+gB,CAEb,CAEInO,WAAQxV,GAEX4C,KAAK+gB,EAAI3jB,CAEV,CAEAmV,IAAKjW,EAAGE,EAAGskB,EAAGC,GAOb,OALA/gB,KAAK1D,EAAIA,EACT0D,KAAKxD,EAAIA,EACTwD,KAAK8gB,EAAIA,EACT9gB,KAAK+gB,EAAIA,EAEF/gB,IAER,CAEA6S,UAAWC,GAOV,OALA9S,KAAK1D,EAAIwW,EACT9S,KAAKxD,EAAIsW,EACT9S,KAAK8gB,EAAIhO,EACT9S,KAAK+gB,EAAIjO,EAEF9S,IAER,CAEA+S,KAAMzW,GAIL,OAFA0D,KAAK1D,EAAIA,EAEF0D,IAER,CAEAgT,KAAMxW,GAIL,OAFAwD,KAAKxD,EAAIA,EAEFwD,IAER,CAEAihB,KAAMH,GAIL,OAFA9gB,KAAK8gB,EAAIA,EAEF9gB,IAER,CAEAkhB,KAAMH,GAIL,OAFA/gB,KAAK+gB,EAAIA,EAEF/gB,IAER,CAEAiT,aAAclV,EAAOX,GAEpB,OAASW,GAER,KAAK,EAAGiC,KAAK1D,EAAIc,EAAO,MACxB,KAAK,EAAG4C,KAAKxD,EAAIY,EAAO,MACxB,KAAK,EAAG4C,KAAK8gB,EAAI1jB,EAAO,MACxB,KAAK,EAAG4C,KAAK+gB,EAAI3jB,EAAO,MACxB,QAAS,MAAM,IAAI6I,MAAO,0BAA4BlI,GAIvD,OAAOiC,IAER,CAEAkT,aAAcnV,GAEb,OAASA,GAER,KAAK,EAAG,OAAOiC,KAAK1D,EACpB,KAAK,EAAG,OAAO0D,KAAKxD,EACpB,KAAK,EAAG,OAAOwD,KAAK8gB,EACpB,KAAK,EAAG,OAAO9gB,KAAK+gB,EACpB,QAAS,MAAM,IAAI9a,MAAO,0BAA4BlI,GAIxD,CAEAoV,QAEC,OAAO,IAAInT,KAAKuC,YAAavC,KAAK1D,EAAG0D,KAAKxD,EAAGwD,KAAK8gB,EAAG9gB,KAAK+gB,EAE3D,CAEA3N,KAAMC,GAOL,OALArT,KAAK1D,EAAI+W,EAAE/W,EACX0D,KAAKxD,EAAI6W,EAAE7W,EACXwD,KAAK8gB,EAAIzN,EAAEyN,EACX9gB,KAAK+gB,OAAc5jB,IAARkW,EAAE0N,EAAoB1N,EAAE0N,EAAI,EAEhC/gB,IAER,CAEAhD,IAAKqW,GAOJ,OALArT,KAAK1D,GAAK+W,EAAE/W,EACZ0D,KAAKxD,GAAK6W,EAAE7W,EACZwD,KAAK8gB,GAAKzN,EAAEyN,EACZ9gB,KAAK+gB,GAAK1N,EAAE0N,EAEL/gB,IAER,CAEAsT,UAAWpC,GAOV,OALAlR,KAAK1D,GAAK4U,EACVlR,KAAKxD,GAAK0U,EACVlR,KAAK8gB,GAAK5P,EACVlR,KAAK+gB,GAAK7P,EAEHlR,IAER,CAEAuT,WAAY9K,EAAGiJ,GAOd,OALA1R,KAAK1D,EAAImM,EAAEnM,EAAIoV,EAAEpV,EACjB0D,KAAKxD,EAAIiM,EAAEjM,EAAIkV,EAAElV,EACjBwD,KAAK8gB,EAAIrY,EAAEqY,EAAIpP,EAAEoP,EACjB9gB,KAAK+gB,EAAItY,EAAEsY,EAAIrP,EAAEqP,EAEV/gB,IAER,CAEAwT,gBAAiBH,EAAGnC,GAOnB,OALAlR,KAAK1D,GAAK+W,EAAE/W,EAAI4U,EAChBlR,KAAKxD,GAAK6W,EAAE7W,EAAI0U,EAChBlR,KAAK8gB,GAAKzN,EAAEyN,EAAI5P,EAChBlR,KAAK+gB,GAAK1N,EAAE0N,EAAI7P,EAETlR,IAER,CAEAyT,IAAKJ,GAOJ,OALArT,KAAK1D,GAAK+W,EAAE/W,EACZ0D,KAAKxD,GAAK6W,EAAE7W,EACZwD,KAAK8gB,GAAKzN,EAAEyN,EACZ9gB,KAAK+gB,GAAK1N,EAAE0N,EAEL/gB,IAER,CAEA0T,UAAWxC,GAOV,OALAlR,KAAK1D,GAAK4U,EACVlR,KAAKxD,GAAK0U,EACVlR,KAAK8gB,GAAK5P,EACVlR,KAAK+gB,GAAK7P,EAEHlR,IAER,CAEA2T,WAAYlL,EAAGiJ,GAOd,OALA1R,KAAK1D,EAAImM,EAAEnM,EAAIoV,EAAEpV,EACjB0D,KAAKxD,EAAIiM,EAAEjM,EAAIkV,EAAElV,EACjBwD,KAAK8gB,EAAIrY,EAAEqY,EAAIpP,EAAEoP,EACjB9gB,KAAK+gB,EAAItY,EAAEsY,EAAIrP,EAAEqP,EAEV/gB,IAER,CAEA4T,SAAUP,GAOT,OALArT,KAAK1D,GAAK+W,EAAE/W,EACZ0D,KAAKxD,GAAK6W,EAAE7W,EACZwD,KAAK8gB,GAAKzN,EAAEyN,EACZ9gB,KAAK+gB,GAAK1N,EAAE0N,EAEL/gB,IAER,CAEA6T,eAAgBf,GAOf,OALA9S,KAAK1D,GAAKwW,EACV9S,KAAKxD,GAAKsW,EACV9S,KAAK8gB,GAAKhO,EACV9S,KAAK+gB,GAAKjO,EAEH9S,IAER,CAEAmhB,aAAc1S,GAEb,MAAMnS,EAAI0D,KAAK1D,EAAGE,EAAIwD,KAAKxD,EAAGskB,EAAI9gB,KAAK8gB,EAAGC,EAAI/gB,KAAK+gB,EAC7C7kB,EAAIuS,EAAEwF,SAOZ,OALAjU,KAAK1D,EAAIJ,EAAG,GAAMI,EAAIJ,EAAG,GAAMM,EAAIN,EAAG,GAAM4kB,EAAI5kB,EAAG,IAAO6kB,EAC1D/gB,KAAKxD,EAAIN,EAAG,GAAMI,EAAIJ,EAAG,GAAMM,EAAIN,EAAG,GAAM4kB,EAAI5kB,EAAG,IAAO6kB,EAC1D/gB,KAAK8gB,EAAI5kB,EAAG,GAAMI,EAAIJ,EAAG,GAAMM,EAAIN,EAAG,IAAO4kB,EAAI5kB,EAAG,IAAO6kB,EAC3D/gB,KAAK+gB,EAAI7kB,EAAG,GAAMI,EAAIJ,EAAG,GAAMM,EAAIN,EAAG,IAAO4kB,EAAI5kB,EAAG,IAAO6kB,EAEpD/gB,IAER,CAEA+T,aAAcjB,GAEb,OAAO9S,KAAK6T,eAAgB,EAAIf,EAEjC,CAEAsO,2BAA4B3P,GAM3BzR,KAAK+gB,EAAI,EAAI/iB,KAAKgX,KAAMvD,EAAEsP,GAE1B,MAAM7P,EAAIlT,KAAKC,KAAM,EAAIwT,EAAEsP,EAAItP,EAAEsP,GAgBjC,OAdK7P,EAAI,MAERlR,KAAK1D,EAAI,EACT0D,KAAKxD,EAAI,EACTwD,KAAK8gB,EAAI,IAIT9gB,KAAK1D,EAAImV,EAAEnV,EAAI4U,EACflR,KAAKxD,EAAIiV,EAAEjV,EAAI0U,EACflR,KAAK8gB,EAAIrP,EAAEqP,EAAI5P,GAITlR,IAER,CAEAqhB,+BAAgC5S,GAM/B,IAAImG,EAAOtY,EAAGE,EAAGskB,EACjB,MAAMQ,EAAU,IACfC,EAAW,GAEXzK,EAAKrI,EAAEwF,SAEPuN,EAAM1K,EAAI,GAAK2K,EAAM3K,EAAI,GAAK4K,EAAM5K,EAAI,GACxC6K,EAAM7K,EAAI,GAAK8K,EAAM9K,EAAI,GAAK+K,EAAM/K,EAAI,GACxCgL,EAAMhL,EAAI,GAAKiL,EAAMjL,EAAI,GAAKkL,EAAMlL,EAAI,IAEzC,GAAO9Y,KAAKwS,IAAKiR,EAAME,GAAQL,GACxBtjB,KAAKwS,IAAKkR,EAAMI,GAAQR,GACxBtjB,KAAKwS,IAAKqR,EAAME,GAAQT,EAAY,CAM1C,GAAOtjB,KAAKwS,IAAKiR,EAAME,GAAQJ,GACxBvjB,KAAKwS,IAAKkR,EAAMI,GAAQP,GACxBvjB,KAAKwS,IAAKqR,EAAME,GAAQR,GACxBvjB,KAAKwS,IAAKgR,EAAMI,EAAMI,EAAM,GAAMT,EAMxC,OAFAvhB,KAAKuS,IAAK,EAAG,EAAG,EAAG,GAEZvS,KAMR4U,EAAQ5W,KAAKI,GAEb,MAAM6jB,GAAOT,EAAM,GAAM,EACnBU,GAAON,EAAM,GAAM,EACnBO,GAAOH,EAAM,GAAM,EACnBI,GAAOX,EAAME,GAAQ,EACrBU,GAAOX,EAAMI,GAAQ,EACrBQ,GAAOT,EAAME,GAAQ,EA4D3B,OA1DOE,EAAKC,GAAUD,EAAKE,EAIrBF,EAAKX,GAEThlB,EAAI,EACJE,EAAI,WACJskB,EAAI,aAIJxkB,EAAI0B,KAAKC,KAAMgkB,GACfzlB,EAAI4lB,EAAK9lB,EACTwkB,EAAIuB,EAAK/lB,GAIC4lB,EAAKC,EAIXD,EAAKZ,GAEThlB,EAAI,WACJE,EAAI,EACJskB,EAAI,aAIJtkB,EAAIwB,KAAKC,KAAMikB,GACf5lB,EAAI8lB,EAAK5lB,EACTskB,EAAIwB,EAAK9lB,GAQL2lB,EAAKb,GAEThlB,EAAI,WACJE,EAAI,WACJskB,EAAI,IAIJA,EAAI9iB,KAAKC,KAAMkkB,GACf7lB,EAAI+lB,EAAKvB,EACTtkB,EAAI8lB,EAAKxB,GAMX9gB,KAAKuS,IAAKjW,EAAGE,EAAGskB,EAAGlM,GAEZ5U,IAER,CAIA,IAAIkR,EAAIlT,KAAKC,MAAQ8jB,EAAMF,IAAUE,EAAMF,IACxCH,EAAMI,IAAUJ,EAAMI,IACtBH,EAAMF,IAAUE,EAAMF,IAYzB,OAVKzjB,KAAKwS,IAAKU,GAAM,OAAQA,EAAI,GAKjClR,KAAK1D,GAAMylB,EAAMF,GAAQ3Q,EACzBlR,KAAKxD,GAAMklB,EAAMI,GAAQ5Q,EACzBlR,KAAK8gB,GAAMa,EAAMF,GAAQvQ,EACzBlR,KAAK+gB,EAAI/iB,KAAKgX,MAAQwM,EAAMI,EAAMI,EAAM,GAAM,GAEvChiB,IAER,CAEArC,IAAK0V,GAOJ,OALArT,KAAK1D,EAAI0B,KAAKL,IAAKqC,KAAK1D,EAAG+W,EAAE/W,GAC7B0D,KAAKxD,EAAIwB,KAAKL,IAAKqC,KAAKxD,EAAG6W,EAAE7W,GAC7BwD,KAAK8gB,EAAI9iB,KAAKL,IAAKqC,KAAK8gB,EAAGzN,EAAEyN,GAC7B9gB,KAAK+gB,EAAI/iB,KAAKL,IAAKqC,KAAK+gB,EAAG1N,EAAE0N,GAEtB/gB,IAER,CAEAuO,IAAK8E,GAOJ,OALArT,KAAK1D,EAAI0B,KAAKuQ,IAAKvO,KAAK1D,EAAG+W,EAAE/W,GAC7B0D,KAAKxD,EAAIwB,KAAKuQ,IAAKvO,KAAKxD,EAAG6W,EAAE7W,GAC7BwD,KAAK8gB,EAAI9iB,KAAKuQ,IAAKvO,KAAK8gB,EAAGzN,EAAEyN,GAC7B9gB,KAAK+gB,EAAI/iB,KAAKuQ,IAAKvO,KAAK+gB,EAAG1N,EAAE0N,GAEtB/gB,IAER,CAEAsO,MAAO3Q,EAAK4Q,GASX,OALAvO,KAAK1D,EAAI0B,KAAKuQ,IAAK5Q,EAAIrB,EAAG0B,KAAKL,IAAK4Q,EAAIjS,EAAG0D,KAAK1D,IAChD0D,KAAKxD,EAAIwB,KAAKuQ,IAAK5Q,EAAInB,EAAGwB,KAAKL,IAAK4Q,EAAI/R,EAAGwD,KAAKxD,IAChDwD,KAAK8gB,EAAI9iB,KAAKuQ,IAAK5Q,EAAImjB,EAAG9iB,KAAKL,IAAK4Q,EAAIuS,EAAG9gB,KAAK8gB,IAChD9gB,KAAK+gB,EAAI/iB,KAAKuQ,IAAK5Q,EAAIojB,EAAG/iB,KAAKL,IAAK4Q,EAAIwS,EAAG/gB,KAAK+gB,IAEzC/gB,IAER,CAEAkU,YAAaC,EAAQC,GAOpB,OALApU,KAAK1D,EAAI0B,KAAKuQ,IAAK4F,EAAQnW,KAAKL,IAAKyW,EAAQpU,KAAK1D,IAClD0D,KAAKxD,EAAIwB,KAAKuQ,IAAK4F,EAAQnW,KAAKL,IAAKyW,EAAQpU,KAAKxD,IAClDwD,KAAK8gB,EAAI9iB,KAAKuQ,IAAK4F,EAAQnW,KAAKL,IAAKyW,EAAQpU,KAAK8gB,IAClD9gB,KAAK+gB,EAAI/iB,KAAKuQ,IAAK4F,EAAQnW,KAAKL,IAAKyW,EAAQpU,KAAK+gB,IAE3C/gB,IAER,CAEAqU,YAAa1W,EAAK4Q,GAEjB,MAAM5N,EAASX,KAAKW,SAEpB,OAAOX,KAAK+T,aAAcpT,GAAU,GAAIkT,eAAgB7V,KAAKuQ,IAAK5Q,EAAKK,KAAKL,IAAK4Q,EAAK5N,IAEvF,CAEAtC,QAOC,OALA2B,KAAK1D,EAAI0B,KAAKK,MAAO2B,KAAK1D,GAC1B0D,KAAKxD,EAAIwB,KAAKK,MAAO2B,KAAKxD,GAC1BwD,KAAK8gB,EAAI9iB,KAAKK,MAAO2B,KAAK8gB,GAC1B9gB,KAAK+gB,EAAI/iB,KAAKK,MAAO2B,KAAK+gB,GAEnB/gB,IAER,CAEA+O,OAOC,OALA/O,KAAK1D,EAAI0B,KAAK+Q,KAAM/O,KAAK1D,GACzB0D,KAAKxD,EAAIwB,KAAK+Q,KAAM/O,KAAKxD,GACzBwD,KAAK8gB,EAAI9iB,KAAK+Q,KAAM/O,KAAK8gB,GACzB9gB,KAAK+gB,EAAI/iB,KAAK+Q,KAAM/O,KAAK+gB,GAElB/gB,IAER,CAEA2P,QAOC,OALA3P,KAAK1D,EAAI0B,KAAK2R,MAAO3P,KAAK1D,GAC1B0D,KAAKxD,EAAIwB,KAAK2R,MAAO3P,KAAKxD,GAC1BwD,KAAK8gB,EAAI9iB,KAAK2R,MAAO3P,KAAK8gB,GAC1B9gB,KAAK+gB,EAAI/iB,KAAK2R,MAAO3P,KAAK+gB,GAEnB/gB,IAER,CAEAsU,cAOC,OALAtU,KAAK1D,EAAM0D,KAAK1D,EAAI,EAAM0B,KAAK+Q,KAAM/O,KAAK1D,GAAM0B,KAAKK,MAAO2B,KAAK1D,GACjE0D,KAAKxD,EAAMwD,KAAKxD,EAAI,EAAMwB,KAAK+Q,KAAM/O,KAAKxD,GAAMwB,KAAKK,MAAO2B,KAAKxD,GACjEwD,KAAK8gB,EAAM9gB,KAAK8gB,EAAI,EAAM9iB,KAAK+Q,KAAM/O,KAAK8gB,GAAM9iB,KAAKK,MAAO2B,KAAK8gB,GACjE9gB,KAAK+gB,EAAM/gB,KAAK+gB,EAAI,EAAM/iB,KAAK+Q,KAAM/O,KAAK+gB,GAAM/iB,KAAKK,MAAO2B,KAAK+gB,GAE1D/gB,IAER,CAEAuU,SAOC,OALAvU,KAAK1D,GAAM0D,KAAK1D,EAChB0D,KAAKxD,GAAMwD,KAAKxD,EAChBwD,KAAK8gB,GAAM9gB,KAAK8gB,EAChB9gB,KAAK+gB,GAAM/gB,KAAK+gB,EAET/gB,IAER,CAEAwU,IAAKnB,GAEJ,OAAOrT,KAAK1D,EAAI+W,EAAE/W,EAAI0D,KAAKxD,EAAI6W,EAAE7W,EAAIwD,KAAK8gB,EAAIzN,EAAEyN,EAAI9gB,KAAK+gB,EAAI1N,EAAE0N,CAEhE,CAEArM,WAEC,OAAO1U,KAAK1D,EAAI0D,KAAK1D,EAAI0D,KAAKxD,EAAIwD,KAAKxD,EAAIwD,KAAK8gB,EAAI9gB,KAAK8gB,EAAI9gB,KAAK+gB,EAAI/gB,KAAK+gB,CAE5E,CAEApgB,SAEC,OAAO3C,KAAKC,KAAM+B,KAAK1D,EAAI0D,KAAK1D,EAAI0D,KAAKxD,EAAIwD,KAAKxD,EAAIwD,KAAK8gB,EAAI9gB,KAAK8gB,EAAI9gB,KAAK+gB,EAAI/gB,KAAK+gB,EAEvF,CAEApM,kBAEC,OAAO3W,KAAKwS,IAAKxQ,KAAK1D,GAAM0B,KAAKwS,IAAKxQ,KAAKxD,GAAMwB,KAAKwS,IAAKxQ,KAAK8gB,GAAM9iB,KAAKwS,IAAKxQ,KAAK+gB,EAEtF,CAEArR,YAEC,OAAO1P,KAAK+T,aAAc/T,KAAKW,UAAY,EAE5C,CAEAyU,UAAWzU,GAEV,OAAOX,KAAK0P,YAAYmE,eAAgBlT,EAEzC,CAEA+N,KAAM2E,EAAGgC,GAOR,OALArV,KAAK1D,IAAO+W,EAAE/W,EAAI0D,KAAK1D,GAAM+Y,EAC7BrV,KAAKxD,IAAO6W,EAAE7W,EAAIwD,KAAKxD,GAAM6Y,EAC7BrV,KAAK8gB,IAAOzN,EAAEyN,EAAI9gB,KAAK8gB,GAAMzL,EAC7BrV,KAAK+gB,IAAO1N,EAAE0N,EAAI/gB,KAAK+gB,GAAM1L,EAEtBrV,IAER,CAEAsV,YAAaC,EAAIC,EAAIH,GAOpB,OALArV,KAAK1D,EAAIiZ,EAAGjZ,GAAMkZ,EAAGlZ,EAAIiZ,EAAGjZ,GAAM+Y,EAClCrV,KAAKxD,EAAI+Y,EAAG/Y,GAAMgZ,EAAGhZ,EAAI+Y,EAAG/Y,GAAM6Y,EAClCrV,KAAK8gB,EAAIvL,EAAGuL,GAAMtL,EAAGsL,EAAIvL,EAAGuL,GAAMzL,EAClCrV,KAAK+gB,EAAIxL,EAAGwL,GAAMvL,EAAGuL,EAAIxL,EAAGwL,GAAM1L,EAE3BrV,IAER,CAEAyV,OAAQpC,GAEP,OAAWA,EAAE/W,IAAM0D,KAAK1D,GAAS+W,EAAE7W,IAAMwD,KAAKxD,GAAS6W,EAAEyN,IAAM9gB,KAAK8gB,GAASzN,EAAE0N,IAAM/gB,KAAK+gB,CAE3F,CAEArL,UAAWjI,EAAOkI,EAAS,GAO1B,OALA3V,KAAK1D,EAAImR,EAAOkI,GAChB3V,KAAKxD,EAAIiR,EAAOkI,EAAS,GACzB3V,KAAK8gB,EAAIrT,EAAOkI,EAAS,GACzB3V,KAAK+gB,EAAItT,EAAOkI,EAAS,GAElB3V,IAER,CAEA4V,QAASnI,EAAQ,GAAIkI,EAAS,GAO7B,OALAlI,EAAOkI,GAAW3V,KAAK1D,EACvBmR,EAAOkI,EAAS,GAAM3V,KAAKxD,EAC3BiR,EAAOkI,EAAS,GAAM3V,KAAK8gB,EAC3BrT,EAAOkI,EAAS,GAAM3V,KAAK+gB,EAEpBtT,CAER,CAEAoI,oBAAqBC,EAAW/X,GAO/B,OALAiC,KAAK1D,EAAIwZ,EAAUC,KAAMhY,GACzBiC,KAAKxD,EAAIsZ,EAAUE,KAAMjY,GACzBiC,KAAK8gB,EAAIhL,EAAUyM,KAAMxkB,GACzBiC,KAAK+gB,EAAIjL,EAAU0M,KAAMzkB,GAElBiC,IAER,CAEAiO,SAOC,OALAjO,KAAK1D,EAAI0B,KAAKiQ,SACdjO,KAAKxD,EAAIwB,KAAKiQ,SACdjO,KAAK8gB,EAAI9iB,KAAKiQ,SACdjO,KAAK+gB,EAAI/iB,KAAKiQ,SAEPjO,IAER,CAEA,EAAGqB,OAAOC,kBAEHtB,KAAK1D,QACL0D,KAAKxD,QACLwD,KAAK8gB,QACL9gB,KAAK+gB,CAEZ,EASD,MAAM0B,WAA0B3V,GAE/BvK,YAAaoQ,EAAQ,EAAGC,EAAS,EAAGhP,EAAU,CAAC,GAE9Cwb,QAEApf,KAAK0iB,qBAAsB,EAE3B1iB,KAAK2S,MAAQA,EACb3S,KAAK4S,OAASA,EACd5S,KAAK2iB,MAAQ,EAEb3iB,KAAK4iB,QAAU,IAAI/B,GAAS,EAAG,EAAGlO,EAAOC,GACzC5S,KAAK6iB,aAAc,EAEnB7iB,KAAK8iB,SAAW,IAAIjC,GAAS,EAAG,EAAGlO,EAAOC,GAE1C,MAAM+J,EAAQ,CAAEhK,MAAOA,EAAOC,OAAQA,EAAQ+P,MAAO,QAE3BxlB,IAArByG,EAAQgd,WAGZ3F,GAAU,oFACVrX,EAAQoY,WAAapY,EAAQgd,WAAaxU,EAAeC,GA/rFvC,IAmsFnBrM,KAAK+iB,QAAU,IAAIvE,GAAS7B,EAAO/Y,EAAQ8a,QAAS9a,EAAQgb,MAAOhb,EAAQib,MAAOjb,EAAQkb,UAAWlb,EAAQmb,UAAWnb,EAAQob,OAAQpb,EAAQmJ,KAAMnJ,EAAQqb,WAAYrb,EAAQoY,YAClLhc,KAAK+iB,QAAQ9C,uBAAwB,EAErCjgB,KAAK+iB,QAAQlD,OAAQ,EACrB7f,KAAK+iB,QAAQpD,qBAA8CxiB,IAA5ByG,EAAQ+b,iBAAgC/b,EAAQ+b,gBAC/E3f,KAAK+iB,QAAQvD,oBAA4CriB,IAA3ByG,EAAQ4b,eAA+B5b,EAAQ4b,eAAiB,KAC9Fxf,KAAK+iB,QAAQhE,eAAkC5hB,IAAtByG,EAAQmb,UAA0Bnb,EAAQmb,UAAYlU,EAE/E7K,KAAKgjB,iBAAsC7lB,IAAxByG,EAAQof,aAA4Bpf,EAAQof,YAC/DhjB,KAAKijB,mBAA0C9lB,IAA1ByG,EAAQqf,eAA8Brf,EAAQqf,cAEnEjjB,KAAKkjB,kBAAwC/lB,IAAzByG,EAAQsf,aAA6Btf,EAAQsf,aAAe,KAEhFljB,KAAKmjB,aAA8BhmB,IAApByG,EAAQuf,QAAwBvf,EAAQuf,QAAU,CAElE,CAEAC,QAASzQ,EAAOC,EAAQ+P,EAAQ,GAE1B3iB,KAAK2S,QAAUA,GAAS3S,KAAK4S,SAAWA,GAAU5S,KAAK2iB,QAAUA,IAErE3iB,KAAK2S,MAAQA,EACb3S,KAAK4S,OAASA,EACd5S,KAAK2iB,MAAQA,EAEb3iB,KAAK+iB,QAAQpG,MAAMhK,MAAQA,EAC3B3S,KAAK+iB,QAAQpG,MAAM/J,OAASA,EAC5B5S,KAAK+iB,QAAQpG,MAAMgG,MAAQA,EAE3B3iB,KAAKygB,WAINzgB,KAAK8iB,SAASvQ,IAAK,EAAG,EAAGI,EAAOC,GAChC5S,KAAK4iB,QAAQrQ,IAAK,EAAG,EAAGI,EAAOC,EAEhC,CAEAO,QAEC,OAAO,IAAInT,KAAKuC,aAAc6Q,KAAMpT,KAErC,CAEAoT,KAAM3P,GAELzD,KAAK2S,MAAQlP,EAAOkP,MACpB3S,KAAK4S,OAASnP,EAAOmP,OACrB5S,KAAK2iB,MAAQlf,EAAOkf,MAEpB3iB,KAAK4iB,QAAQxP,KAAM3P,EAAOmf,SAC1B5iB,KAAK6iB,YAAcpf,EAAOof,YAE1B7iB,KAAK8iB,SAAS1P,KAAM3P,EAAOqf,UAE3B9iB,KAAK+iB,QAAUtf,EAAOsf,QAAQ5P,QAC9BnT,KAAK+iB,QAAQ9C,uBAAwB,EAIrC,MAAMtD,EAAQva,OAAOihB,OAAQ,CAAC,EAAG5f,EAAOsf,QAAQpG,OAUhD,OATA3c,KAAK+iB,QAAQtf,OAAS,IAAIia,GAAQf,GAElC3c,KAAKgjB,YAAcvf,EAAOuf,YAC1BhjB,KAAKijB,cAAgBxf,EAAOwf,cAEC,OAAxBxf,EAAOyf,eAAwBljB,KAAKkjB,aAAezf,EAAOyf,aAAa/P,SAE5EnT,KAAKmjB,QAAU1f,EAAO0f,QAEfnjB,IAER,CAEAygB,UAECzgB,KAAKuN,cAAe,CAAER,KAAM,WAE7B,EAID,MAAMuW,WAAyB9E,GAE9Bjc,YAAac,EAAO,KAAMsP,EAAQ,EAAGC,EAAS,EAAG+P,EAAQ,GAExDvD,MAAO,MAEPpf,KAAKujB,oBAAqB,EAE1BvjB,KAAK2c,MAAQ,CAAEtZ,OAAMsP,QAAOC,SAAQ+P,SAEpC3iB,KAAK8e,UAAYpU,EACjB1K,KAAK+e,UAAYrU,EAEjB1K,KAAKwjB,MAAQhZ,EAEbxK,KAAK2f,iBAAkB,EACvB3f,KAAK6f,OAAQ,EACb7f,KAAK8f,gBAAkB,CAExB,EAsBD,MAAM2D,WAAsBjF,GAE3Bjc,YAAac,EAAO,KAAMsP,EAAQ,EAAGC,EAAS,EAAG+P,EAAQ,GAUxDvD,MAAO,MAEPpf,KAAK0jB,iBAAkB,EAEvB1jB,KAAK2c,MAAQ,CAAEtZ,OAAMsP,QAAOC,SAAQ+P,SAEpC3iB,KAAK8e,UAAYpU,EACjB1K,KAAK+e,UAAYrU,EAEjB1K,KAAKwjB,MAAQhZ,EAEbxK,KAAK2f,iBAAkB,EACvB3f,KAAK6f,OAAQ,EACb7f,KAAK8f,gBAAkB,CAExB,EAuGD,MAAM6D,GAELphB,YAAajG,EAAI,EAAGE,EAAI,EAAGskB,EAAI,EAAGC,EAAI,GAErC/gB,KAAK4jB,cAAe,EAEpB5jB,KAAK6jB,GAAKvnB,EACV0D,KAAK8jB,GAAKtnB,EACVwD,KAAK+jB,GAAKjD,EACV9gB,KAAKgkB,GAAKjD,CAEX,CAEArE,iBAAkBuH,EAAKC,EAAWC,EAAMC,EAAYC,EAAMC,EAAY3V,GAIrE,IAAI4V,EAAKJ,EAAMC,EAAa,GAC3BI,EAAKL,EAAMC,EAAa,GACxBK,EAAKN,EAAMC,EAAa,GACxBM,EAAKP,EAAMC,EAAa,GAEzB,MAAMO,EAAKN,EAAMC,EAAa,GAC7BM,EAAKP,EAAMC,EAAa,GACxBO,EAAKR,EAAMC,EAAa,GACxBQ,EAAKT,EAAMC,EAAa,GAEzB,GAAW,IAAN3V,EAMJ,OAJAsV,EAAKC,EAAY,GAAMK,EACvBN,EAAKC,EAAY,GAAMM,EACvBP,EAAKC,EAAY,GAAMO,OACvBR,EAAKC,EAAY,GAAMQ,GAKxB,GAAW,IAAN/V,EAMJ,OAJAsV,EAAKC,EAAY,GAAMS,EACvBV,EAAKC,EAAY,GAAMU,EACvBX,EAAKC,EAAY,GAAMW,OACvBZ,EAAKC,EAAY,GAAMY,GAKxB,GAAKJ,IAAOI,GAAMP,IAAOI,GAAMH,IAAOI,GAAMH,IAAOI,EAAK,CAEvD,IAAI3T,EAAI,EAAIvC,EACZ,MAAMkD,EAAM0S,EAAKI,EAAKH,EAAKI,EAAKH,EAAKI,EAAKH,EAAKI,EAC9CC,EAAQlT,GAAO,EAAI,GAAM,EACzBmT,EAAS,EAAInT,EAAMA,EAGpB,GAAKmT,EAASC,OAAOC,QAAU,CAE9B,MAAMpT,EAAM9T,KAAKC,KAAM+mB,GACtBjkB,EAAM/C,KAAKG,MAAO2T,EAAKD,EAAMkT,GAE9B7T,EAAIlT,KAAK8T,IAAKZ,EAAInQ,GAAQ+Q,EAC1BnD,EAAI3Q,KAAK8T,IAAKnD,EAAI5N,GAAQ+Q,CAE3B,CAEA,MAAMqT,EAAOxW,EAAIoW,EAQjB,GANAR,EAAKA,EAAKrT,EAAIyT,EAAKQ,EACnBX,EAAKA,EAAKtT,EAAI0T,EAAKO,EACnBV,EAAKA,EAAKvT,EAAI2T,EAAKM,EACnBT,EAAKA,EAAKxT,EAAI4T,EAAKK,EAGdjU,IAAM,EAAIvC,EAAI,CAElB,MAAMmK,EAAI,EAAI9a,KAAKC,KAAMsmB,EAAKA,EAAKC,EAAKA,EAAKC,EAAKA,EAAKC,EAAKA,GAE5DH,GAAMzL,EACN0L,GAAM1L,EACN2L,GAAM3L,EACN4L,GAAM5L,CAEP,CAED,CAEAmL,EAAKC,GAAcK,EACnBN,EAAKC,EAAY,GAAMM,EACvBP,EAAKC,EAAY,GAAMO,EACvBR,EAAKC,EAAY,GAAMQ,CAExB,CAEAhI,+BAAgCuH,EAAKC,EAAWC,EAAMC,EAAYC,EAAMC,GAEvE,MAAMC,EAAKJ,EAAMC,GACXI,EAAKL,EAAMC,EAAa,GACxBK,EAAKN,EAAMC,EAAa,GACxBM,EAAKP,EAAMC,EAAa,GAExBO,EAAKN,EAAMC,GACXM,EAAKP,EAAMC,EAAa,GACxBO,EAAKR,EAAMC,EAAa,GACxBQ,EAAKT,EAAMC,EAAa,GAO9B,OALAL,EAAKC,GAAcK,EAAKO,EAAKJ,EAAKC,EAAKH,EAAKK,EAAKJ,EAAKG,EACtDX,EAAKC,EAAY,GAAMM,EAAKM,EAAKJ,EAAKE,EAAKH,EAAKE,EAAKJ,EAAKM,EAC1DZ,EAAKC,EAAY,GAAMO,EAAKK,EAAKJ,EAAKG,EAAKN,EAAKK,EAAKJ,EAAKG,EAC1DV,EAAKC,EAAY,GAAMQ,EAAKI,EAAKP,EAAKI,EAAKH,EAAKI,EAAKH,EAAKI,EAEnDZ,CAER,CAEI3nB,QAEH,OAAO0D,KAAK6jB,EAEb,CAEIvnB,MAAGc,GAEN4C,KAAK6jB,GAAKzmB,EACV4C,KAAKolB,mBAEN,CAEI5oB,QAEH,OAAOwD,KAAK8jB,EAEb,CAEItnB,MAAGY,GAEN4C,KAAK8jB,GAAK1mB,EACV4C,KAAKolB,mBAEN,CAEItE,QAEH,OAAO9gB,KAAK+jB,EAEb,CAEIjD,MAAG1jB,GAEN4C,KAAK+jB,GAAK3mB,EACV4C,KAAKolB,mBAEN,CAEIrE,QAEH,OAAO/gB,KAAKgkB,EAEb,CAEIjD,MAAG3jB,GAEN4C,KAAKgkB,GAAK5mB,EACV4C,KAAKolB,mBAEN,CAEA7S,IAAKjW,EAAGE,EAAGskB,EAAGC,GASb,OAPA/gB,KAAK6jB,GAAKvnB,EACV0D,KAAK8jB,GAAKtnB,EACVwD,KAAK+jB,GAAKjD,EACV9gB,KAAKgkB,GAAKjD,EAEV/gB,KAAKolB,oBAEEplB,IAER,CAEAmT,QAEC,OAAO,IAAInT,KAAKuC,YAAavC,KAAK6jB,GAAI7jB,KAAK8jB,GAAI9jB,KAAK+jB,GAAI/jB,KAAKgkB,GAE9D,CAEA5Q,KAAMiS,GASL,OAPArlB,KAAK6jB,GAAKwB,EAAW/oB,EACrB0D,KAAK8jB,GAAKuB,EAAW7oB,EACrBwD,KAAK+jB,GAAKsB,EAAWvE,EACrB9gB,KAAKgkB,GAAKqB,EAAWtE,EAErB/gB,KAAKolB,oBAEEplB,IAER,CAEAslB,aAAcC,EAAOle,GAEpB,MAAM/K,EAAIipB,EAAM1B,GAAIrnB,EAAI+oB,EAAMzB,GAAIhD,EAAIyE,EAAMxB,GAAInS,EAAQ2T,EAAMC,OAMxD3T,EAAM7T,KAAK6T,IACXC,EAAM9T,KAAK8T,IAEX2T,EAAK5T,EAAKvV,EAAI,GACdyV,EAAKF,EAAKrV,EAAI,GACdkpB,EAAK7T,EAAKiP,EAAI,GAEd6E,EAAK7T,EAAKxV,EAAI,GACd0V,EAAKF,EAAKtV,EAAI,GACdopB,EAAK9T,EAAKgP,EAAI,GAEpB,OAASlP,GAER,IAAK,MACJ5R,KAAK6jB,GAAK8B,EAAK5T,EAAK2T,EAAKD,EAAKzT,EAAK4T,EACnC5lB,KAAK8jB,GAAK2B,EAAKzT,EAAK0T,EAAKC,EAAK5T,EAAK6T,EACnC5lB,KAAK+jB,GAAK0B,EAAK1T,EAAK6T,EAAKD,EAAK3T,EAAK0T,EACnC1lB,KAAKgkB,GAAKyB,EAAK1T,EAAK2T,EAAKC,EAAK3T,EAAK4T,EACnC,MAED,IAAK,MACJ5lB,KAAK6jB,GAAK8B,EAAK5T,EAAK2T,EAAKD,EAAKzT,EAAK4T,EACnC5lB,KAAK8jB,GAAK2B,EAAKzT,EAAK0T,EAAKC,EAAK5T,EAAK6T,EACnC5lB,KAAK+jB,GAAK0B,EAAK1T,EAAK6T,EAAKD,EAAK3T,EAAK0T,EACnC1lB,KAAKgkB,GAAKyB,EAAK1T,EAAK2T,EAAKC,EAAK3T,EAAK4T,EACnC,MAED,IAAK,MACJ5lB,KAAK6jB,GAAK8B,EAAK5T,EAAK2T,EAAKD,EAAKzT,EAAK4T,EACnC5lB,KAAK8jB,GAAK2B,EAAKzT,EAAK0T,EAAKC,EAAK5T,EAAK6T,EACnC5lB,KAAK+jB,GAAK0B,EAAK1T,EAAK6T,EAAKD,EAAK3T,EAAK0T,EACnC1lB,KAAKgkB,GAAKyB,EAAK1T,EAAK2T,EAAKC,EAAK3T,EAAK4T,EACnC,MAED,IAAK,MACJ5lB,KAAK6jB,GAAK8B,EAAK5T,EAAK2T,EAAKD,EAAKzT,EAAK4T,EACnC5lB,KAAK8jB,GAAK2B,EAAKzT,EAAK0T,EAAKC,EAAK5T,EAAK6T,EACnC5lB,KAAK+jB,GAAK0B,EAAK1T,EAAK6T,EAAKD,EAAK3T,EAAK0T,EACnC1lB,KAAKgkB,GAAKyB,EAAK1T,EAAK2T,EAAKC,EAAK3T,EAAK4T,EACnC,MAED,IAAK,MACJ5lB,KAAK6jB,GAAK8B,EAAK5T,EAAK2T,EAAKD,EAAKzT,EAAK4T,EACnC5lB,KAAK8jB,GAAK2B,EAAKzT,EAAK0T,EAAKC,EAAK5T,EAAK6T,EACnC5lB,KAAK+jB,GAAK0B,EAAK1T,EAAK6T,EAAKD,EAAK3T,EAAK0T,EACnC1lB,KAAKgkB,GAAKyB,EAAK1T,EAAK2T,EAAKC,EAAK3T,EAAK4T,EACnC,MAED,IAAK,MACJ5lB,KAAK6jB,GAAK8B,EAAK5T,EAAK2T,EAAKD,EAAKzT,EAAK4T,EACnC5lB,KAAK8jB,GAAK2B,EAAKzT,EAAK0T,EAAKC,EAAK5T,EAAK6T,EACnC5lB,KAAK+jB,GAAK0B,EAAK1T,EAAK6T,EAAKD,EAAK3T,EAAK0T,EACnC1lB,KAAKgkB,GAAKyB,EAAK1T,EAAK2T,EAAKC,EAAK3T,EAAK4T,EACnC,MAED,QACCtnB,QAAQkU,KAAM,mEAAqEZ,GAMrF,OAFgB,IAAXvK,GAAmBrH,KAAKolB,oBAEtBplB,IAER,CAEA6lB,iBAAkBC,EAAMlR,GAMvB,MAAMmR,EAAYnR,EAAQ,EAAG1D,EAAIlT,KAAK8T,IAAKiU,GAS3C,OAPA/lB,KAAK6jB,GAAKiC,EAAKxpB,EAAI4U,EACnBlR,KAAK8jB,GAAKgC,EAAKtpB,EAAI0U,EACnBlR,KAAK+jB,GAAK+B,EAAKhF,EAAI5P,EACnBlR,KAAKgkB,GAAKhmB,KAAK6T,IAAKkU,GAEpB/lB,KAAKolB,oBAEEplB,IAER,CAEAgmB,sBAAuBvX,GAMtB,MAAMqI,EAAKrI,EAAEwF,SAEZuN,EAAM1K,EAAI,GAAK2K,EAAM3K,EAAI,GAAK4K,EAAM5K,EAAI,GACxC6K,EAAM7K,EAAI,GAAK8K,EAAM9K,EAAI,GAAK+K,EAAM/K,EAAI,GACxCgL,EAAMhL,EAAI,GAAKiL,EAAMjL,EAAI,GAAKkL,EAAMlL,EAAI,IAExCmP,EAAQzE,EAAMI,EAAMI,EAErB,GAAKiE,EAAQ,EAAI,CAEhB,MAAM/U,EAAI,GAAMlT,KAAKC,KAAMgoB,EAAQ,GAEnCjmB,KAAKgkB,GAAK,IAAO9S,EACjBlR,KAAK6jB,IAAO9B,EAAMF,GAAQ3Q,EAC1BlR,KAAK8jB,IAAOpC,EAAMI,GAAQ5Q,EAC1BlR,KAAK+jB,IAAOpC,EAAMF,GAAQvQ,CAE3B,MAAO,GAAKsQ,EAAMI,GAAOJ,EAAMQ,EAAM,CAEpC,MAAM9Q,EAAI,EAAMlT,KAAKC,KAAM,EAAMujB,EAAMI,EAAMI,GAE7ChiB,KAAKgkB,IAAOjC,EAAMF,GAAQ3Q,EAC1BlR,KAAK6jB,GAAK,IAAO3S,EACjBlR,KAAK8jB,IAAOrC,EAAME,GAAQzQ,EAC1BlR,KAAK+jB,IAAOrC,EAAMI,GAAQ5Q,CAE3B,MAAO,GAAK0Q,EAAMI,EAAM,CAEvB,MAAM9Q,EAAI,EAAMlT,KAAKC,KAAM,EAAM2jB,EAAMJ,EAAMQ,GAE7ChiB,KAAKgkB,IAAOtC,EAAMI,GAAQ5Q,EAC1BlR,KAAK6jB,IAAOpC,EAAME,GAAQzQ,EAC1BlR,KAAK8jB,GAAK,IAAO5S,EACjBlR,KAAK+jB,IAAOlC,EAAME,GAAQ7Q,CAE3B,KAAO,CAEN,MAAMA,EAAI,EAAMlT,KAAKC,KAAM,EAAM+jB,EAAMR,EAAMI,GAE7C5hB,KAAKgkB,IAAOrC,EAAMF,GAAQvQ,EAC1BlR,KAAK6jB,IAAOnC,EAAMI,GAAQ5Q,EAC1BlR,KAAK8jB,IAAOjC,EAAME,GAAQ7Q,EAC1BlR,KAAK+jB,GAAK,IAAO7S,CAElB,CAIA,OAFAlR,KAAKolB,oBAEEplB,IAER,CAEAkmB,mBAAoBC,EAAOC,GAI1B,IAAIpd,EAAImd,EAAM3R,IAAK4R,GAAQ,EAmC3B,OAjCKpd,EAAIic,OAAOC,SAIflc,EAAI,EAEChL,KAAKwS,IAAK2V,EAAM7pB,GAAM0B,KAAKwS,IAAK2V,EAAMrF,IAE1C9gB,KAAK6jB,IAAOsC,EAAM3pB,EAClBwD,KAAK8jB,GAAKqC,EAAM7pB,EAChB0D,KAAK+jB,GAAK,EACV/jB,KAAKgkB,GAAKhb,IAIVhJ,KAAK6jB,GAAK,EACV7jB,KAAK8jB,IAAOqC,EAAMrF,EAClB9gB,KAAK+jB,GAAKoC,EAAM3pB,EAChBwD,KAAKgkB,GAAKhb,KAQXhJ,KAAK6jB,GAAKsC,EAAM3pB,EAAI4pB,EAAItF,EAAIqF,EAAMrF,EAAIsF,EAAI5pB,EAC1CwD,KAAK8jB,GAAKqC,EAAMrF,EAAIsF,EAAI9pB,EAAI6pB,EAAM7pB,EAAI8pB,EAAItF,EAC1C9gB,KAAK+jB,GAAKoC,EAAM7pB,EAAI8pB,EAAI5pB,EAAI2pB,EAAM3pB,EAAI4pB,EAAI9pB,EAC1C0D,KAAKgkB,GAAKhb,GAIJhJ,KAAK0P,WAEb,CAEAmF,QAASpD,GAER,OAAO,EAAIzT,KAAKgX,KAAMhX,KAAKwS,IAAKlC,GAAOtO,KAAKwU,IAAK/C,IAAO,EAAG,IAE5D,CAEA4U,cAAe5U,EAAG6U,GAEjB,MAAM1R,EAAQ5U,KAAK6U,QAASpD,GAE5B,GAAe,IAAVmD,EAAc,OAAO5U,KAE1B,MAAM2O,EAAI3Q,KAAKL,IAAK,EAAG2oB,EAAO1R,GAI9B,OAFA5U,KAAKumB,MAAO9U,EAAG9C,GAER3O,IAER,CAEA+W,WAEC,OAAO/W,KAAKuS,IAAK,EAAG,EAAG,EAAG,EAE3B,CAEA0G,SAIC,OAAOjZ,KAAKwmB,WAEb,CAEAA,YAQC,OANAxmB,KAAK6jB,KAAQ,EACb7jB,KAAK8jB,KAAQ,EACb9jB,KAAK+jB,KAAQ,EAEb/jB,KAAKolB,oBAEEplB,IAER,CAEAwU,IAAKnB,GAEJ,OAAOrT,KAAK6jB,GAAKxQ,EAAEwQ,GAAK7jB,KAAK8jB,GAAKzQ,EAAEyQ,GAAK9jB,KAAK+jB,GAAK1Q,EAAE0Q,GAAK/jB,KAAKgkB,GAAK3Q,EAAE2Q,EAEvE,CAEAtP,WAEC,OAAO1U,KAAK6jB,GAAK7jB,KAAK6jB,GAAK7jB,KAAK8jB,GAAK9jB,KAAK8jB,GAAK9jB,KAAK+jB,GAAK/jB,KAAK+jB,GAAK/jB,KAAKgkB,GAAKhkB,KAAKgkB,EAEnF,CAEArjB,SAEC,OAAO3C,KAAKC,KAAM+B,KAAK6jB,GAAK7jB,KAAK6jB,GAAK7jB,KAAK8jB,GAAK9jB,KAAK8jB,GAAK9jB,KAAK+jB,GAAK/jB,KAAK+jB,GAAK/jB,KAAKgkB,GAAKhkB,KAAKgkB,GAE9F,CAEAtU,YAEC,IAAIhC,EAAI1N,KAAKW,SAsBb,OApBW,IAAN+M,GAEJ1N,KAAK6jB,GAAK,EACV7jB,KAAK8jB,GAAK,EACV9jB,KAAK+jB,GAAK,EACV/jB,KAAKgkB,GAAK,IAIVtW,EAAI,EAAIA,EAER1N,KAAK6jB,GAAK7jB,KAAK6jB,GAAKnW,EACpB1N,KAAK8jB,GAAK9jB,KAAK8jB,GAAKpW,EACpB1N,KAAK+jB,GAAK/jB,KAAK+jB,GAAKrW,EACpB1N,KAAKgkB,GAAKhkB,KAAKgkB,GAAKtW,GAIrB1N,KAAKolB,oBAEEplB,IAER,CAEA4T,SAAUnC,GAET,OAAOzR,KAAKymB,oBAAqBzmB,KAAMyR,EAExC,CAEA+F,YAAa/F,GAEZ,OAAOzR,KAAKymB,oBAAqBhV,EAAGzR,KAErC,CAEAymB,oBAAqBhe,EAAGiJ,GAIvB,MAAMgV,EAAMje,EAAEob,GAAI8C,EAAMle,EAAEqb,GAAI8C,EAAMne,EAAEsb,GAAI8C,EAAMpe,EAAEub,GAC5C8C,EAAMpV,EAAEmS,GAAIkD,EAAMrV,EAAEoS,GAAIkD,EAAMtV,EAAEqS,GAAIkD,EAAMvV,EAAEsS,GASlD,OAPAhkB,KAAK6jB,GAAK6C,EAAMO,EAAMJ,EAAMC,EAAMH,EAAMK,EAAMJ,EAAMG,EACpD/mB,KAAK8jB,GAAK6C,EAAMM,EAAMJ,EAAME,EAAMH,EAAME,EAAMJ,EAAMM,EACpDhnB,KAAK+jB,GAAK6C,EAAMK,EAAMJ,EAAMG,EAAMN,EAAMK,EAAMJ,EAAMG,EACpD9mB,KAAKgkB,GAAK6C,EAAMI,EAAMP,EAAMI,EAAMH,EAAMI,EAAMH,EAAMI,EAEpDhnB,KAAKolB,oBAEEplB,IAER,CAEAumB,MAAOW,EAAIvY,GAEV,GAAW,IAANA,EAAU,OAAO3O,KACtB,GAAW,IAAN2O,EAAU,OAAO3O,KAAKoT,KAAM8T,GAEjC,MAAM5qB,EAAI0D,KAAK6jB,GAAIrnB,EAAIwD,KAAK8jB,GAAIhD,EAAI9gB,KAAK+jB,GAAIhD,EAAI/gB,KAAKgkB,GAItD,IAAImD,EAAepG,EAAImG,EAAGlD,GAAK1nB,EAAI4qB,EAAGrD,GAAKrnB,EAAI0qB,EAAGpD,GAAKhD,EAAIoG,EAAGnD,GAiB9D,GAfKoD,EAAe,GAEnBnnB,KAAKgkB,IAAOkD,EAAGlD,GACfhkB,KAAK6jB,IAAOqD,EAAGrD,GACf7jB,KAAK8jB,IAAOoD,EAAGpD,GACf9jB,KAAK+jB,IAAOmD,EAAGnD,GAEfoD,GAAiBA,GAIjBnnB,KAAKoT,KAAM8T,GAIPC,GAAgB,EAOpB,OALAnnB,KAAKgkB,GAAKjD,EACV/gB,KAAK6jB,GAAKvnB,EACV0D,KAAK8jB,GAAKtnB,EACVwD,KAAK+jB,GAAKjD,EAEH9gB,KAIR,MAAMonB,EAAkB,EAAMD,EAAeA,EAE7C,GAAKC,GAAmBnC,OAAOC,QAAU,CAExC,MAAMhU,EAAI,EAAIvC,EASd,OARA3O,KAAKgkB,GAAK9S,EAAI6P,EAAIpS,EAAI3O,KAAKgkB,GAC3BhkB,KAAK6jB,GAAK3S,EAAI5U,EAAIqS,EAAI3O,KAAK6jB,GAC3B7jB,KAAK8jB,GAAK5S,EAAI1U,EAAImS,EAAI3O,KAAK8jB,GAC3B9jB,KAAK+jB,GAAK7S,EAAI4P,EAAInS,EAAI3O,KAAK+jB,GAE3B/jB,KAAK0P,YACL1P,KAAKolB,oBAEEplB,IAER,CAEA,MAAMqnB,EAAerpB,KAAKC,KAAMmpB,GAC1BE,EAAYtpB,KAAKG,MAAOkpB,EAAcF,GACtCI,EAASvpB,KAAK8T,KAAO,EAAInD,GAAM2Y,GAAcD,EAClDG,EAASxpB,KAAK8T,IAAKnD,EAAI2Y,GAAcD,EAStC,OAPArnB,KAAKgkB,GAAOjD,EAAIwG,EAASvnB,KAAKgkB,GAAKwD,EACnCxnB,KAAK6jB,GAAOvnB,EAAIirB,EAASvnB,KAAK6jB,GAAK2D,EACnCxnB,KAAK8jB,GAAOtnB,EAAI+qB,EAASvnB,KAAK8jB,GAAK0D,EACnCxnB,KAAK+jB,GAAOjD,EAAIyG,EAASvnB,KAAK+jB,GAAKyD,EAEnCxnB,KAAKolB,oBAEEplB,IAER,CAEAynB,iBAAkBC,EAAIR,EAAIvY,GAEzB,OAAO3O,KAAKoT,KAAMsU,GAAKnB,MAAOW,EAAIvY,EAEnC,CAEAV,SAMC,MAAM0Z,EAAK3pB,KAAKiQ,SACV2Z,EAAU5pB,KAAKC,KAAM,EAAI0pB,GACzBE,EAAS7pB,KAAKC,KAAM0pB,GAEpBG,EAAK,EAAI9pB,KAAKI,GAAKJ,KAAKiQ,SAExB8Z,EAAK,EAAI/pB,KAAKI,GAAKJ,KAAKiQ,SAE9B,OAAOjO,KAAKuS,IACXqV,EAAU5pB,KAAK6T,IAAKiW,GACpBD,EAAS7pB,KAAK8T,IAAKiW,GACnBF,EAAS7pB,KAAK6T,IAAKkW,GACnBH,EAAU5pB,KAAK8T,IAAKgW,GAGtB,CAEArS,OAAQ4P,GAEP,OAASA,EAAWxB,KAAO7jB,KAAK6jB,IAAUwB,EAAWvB,KAAO9jB,KAAK8jB,IAAUuB,EAAWtB,KAAO/jB,KAAK+jB,IAAUsB,EAAWrB,KAAOhkB,KAAKgkB,EAEpI,CAEAtO,UAAWjI,EAAOkI,EAAS,GAS1B,OAPA3V,KAAK6jB,GAAKpW,EAAOkI,GACjB3V,KAAK8jB,GAAKrW,EAAOkI,EAAS,GAC1B3V,KAAK+jB,GAAKtW,EAAOkI,EAAS,GAC1B3V,KAAKgkB,GAAKvW,EAAOkI,EAAS,GAE1B3V,KAAKolB,oBAEEplB,IAER,CAEA4V,QAASnI,EAAQ,GAAIkI,EAAS,GAO7B,OALAlI,EAAOkI,GAAW3V,KAAK6jB,GACvBpW,EAAOkI,EAAS,GAAM3V,KAAK8jB,GAC3BrW,EAAOkI,EAAS,GAAM3V,KAAK+jB,GAC3BtW,EAAOkI,EAAS,GAAM3V,KAAKgkB,GAEpBvW,CAER,CAEAoI,oBAAqBC,EAAW/X,GAO/B,OALAiC,KAAK6jB,GAAK/N,EAAUC,KAAMhY,GAC1BiC,KAAK8jB,GAAKhO,EAAUE,KAAMjY,GAC1BiC,KAAK+jB,GAAKjO,EAAUyM,KAAMxkB,GAC1BiC,KAAKgkB,GAAKlO,EAAU0M,KAAMzkB,GAEnBiC,IAER,CAEA+d,SAEC,OAAO/d,KAAK4V,SAEb,CAEAoS,UAAWC,GAIV,OAFAjoB,KAAKolB,kBAAoB6C,EAElBjoB,IAER,CAEAolB,oBAAqB,CAErB,EAAG/jB,OAAOC,kBAEHtB,KAAK6jB,SACL7jB,KAAK8jB,SACL9jB,KAAK+jB,SACL/jB,KAAKgkB,EAEZ,EAID,MAAM,GAELzhB,YAAajG,EAAI,EAAGE,EAAI,EAAGskB,EAAI,GAE9B,GAAQze,UAAU6lB,WAAY,EAE9BloB,KAAK1D,EAAIA,EACT0D,KAAKxD,EAAIA,EACTwD,KAAK8gB,EAAIA,CAEV,CAEAvO,IAAKjW,EAAGE,EAAGskB,GAQV,YANW3jB,IAAN2jB,IAAkBA,EAAI9gB,KAAK8gB,GAEhC9gB,KAAK1D,EAAIA,EACT0D,KAAKxD,EAAIA,EACTwD,KAAK8gB,EAAIA,EAEF9gB,IAER,CAEA6S,UAAWC,GAMV,OAJA9S,KAAK1D,EAAIwW,EACT9S,KAAKxD,EAAIsW,EACT9S,KAAK8gB,EAAIhO,EAEF9S,IAER,CAEA+S,KAAMzW,GAIL,OAFA0D,KAAK1D,EAAIA,EAEF0D,IAER,CAEAgT,KAAMxW,GAIL,OAFAwD,KAAKxD,EAAIA,EAEFwD,IAER,CAEAihB,KAAMH,GAIL,OAFA9gB,KAAK8gB,EAAIA,EAEF9gB,IAER,CAEAiT,aAAclV,EAAOX,GAEpB,OAASW,GAER,KAAK,EAAGiC,KAAK1D,EAAIc,EAAO,MACxB,KAAK,EAAG4C,KAAKxD,EAAIY,EAAO,MACxB,KAAK,EAAG4C,KAAK8gB,EAAI1jB,EAAO,MACxB,QAAS,MAAM,IAAI6I,MAAO,0BAA4BlI,GAIvD,OAAOiC,IAER,CAEAkT,aAAcnV,GAEb,OAASA,GAER,KAAK,EAAG,OAAOiC,KAAK1D,EACpB,KAAK,EAAG,OAAO0D,KAAKxD,EACpB,KAAK,EAAG,OAAOwD,KAAK8gB,EACpB,QAAS,MAAM,IAAI7a,MAAO,0BAA4BlI,GAIxD,CAEAoV,QAEC,OAAO,IAAInT,KAAKuC,YAAavC,KAAK1D,EAAG0D,KAAKxD,EAAGwD,KAAK8gB,EAEnD,CAEA1N,KAAMC,GAML,OAJArT,KAAK1D,EAAI+W,EAAE/W,EACX0D,KAAKxD,EAAI6W,EAAE7W,EACXwD,KAAK8gB,EAAIzN,EAAEyN,EAEJ9gB,IAER,CAEAhD,IAAKqW,GAMJ,OAJArT,KAAK1D,GAAK+W,EAAE/W,EACZ0D,KAAKxD,GAAK6W,EAAE7W,EACZwD,KAAK8gB,GAAKzN,EAAEyN,EAEL9gB,IAER,CAEAsT,UAAWpC,GAMV,OAJAlR,KAAK1D,GAAK4U,EACVlR,KAAKxD,GAAK0U,EACVlR,KAAK8gB,GAAK5P,EAEHlR,IAER,CAEAuT,WAAY9K,EAAGiJ,GAMd,OAJA1R,KAAK1D,EAAImM,EAAEnM,EAAIoV,EAAEpV,EACjB0D,KAAKxD,EAAIiM,EAAEjM,EAAIkV,EAAElV,EACjBwD,KAAK8gB,EAAIrY,EAAEqY,EAAIpP,EAAEoP,EAEV9gB,IAER,CAEAwT,gBAAiBH,EAAGnC,GAMnB,OAJAlR,KAAK1D,GAAK+W,EAAE/W,EAAI4U,EAChBlR,KAAKxD,GAAK6W,EAAE7W,EAAI0U,EAChBlR,KAAK8gB,GAAKzN,EAAEyN,EAAI5P,EAETlR,IAER,CAEAyT,IAAKJ,GAMJ,OAJArT,KAAK1D,GAAK+W,EAAE/W,EACZ0D,KAAKxD,GAAK6W,EAAE7W,EACZwD,KAAK8gB,GAAKzN,EAAEyN,EAEL9gB,IAER,CAEA0T,UAAWxC,GAMV,OAJAlR,KAAK1D,GAAK4U,EACVlR,KAAKxD,GAAK0U,EACVlR,KAAK8gB,GAAK5P,EAEHlR,IAER,CAEA2T,WAAYlL,EAAGiJ,GAMd,OAJA1R,KAAK1D,EAAImM,EAAEnM,EAAIoV,EAAEpV,EACjB0D,KAAKxD,EAAIiM,EAAEjM,EAAIkV,EAAElV,EACjBwD,KAAK8gB,EAAIrY,EAAEqY,EAAIpP,EAAEoP,EAEV9gB,IAER,CAEA4T,SAAUP,GAMT,OAJArT,KAAK1D,GAAK+W,EAAE/W,EACZ0D,KAAKxD,GAAK6W,EAAE7W,EACZwD,KAAK8gB,GAAKzN,EAAEyN,EAEL9gB,IAER,CAEA6T,eAAgBf,GAMf,OAJA9S,KAAK1D,GAAKwW,EACV9S,KAAKxD,GAAKsW,EACV9S,KAAK8gB,GAAKhO,EAEH9S,IAER,CAEAmoB,gBAAiB1f,EAAGiJ,GAMnB,OAJA1R,KAAK1D,EAAImM,EAAEnM,EAAIoV,EAAEpV,EACjB0D,KAAKxD,EAAIiM,EAAEjM,EAAIkV,EAAElV,EACjBwD,KAAK8gB,EAAIrY,EAAEqY,EAAIpP,EAAEoP,EAEV9gB,IAER,CAEAooB,WAAY7C,GAEX,OAAOvlB,KAAKqoB,gBAAiBC,GAAchD,aAAcC,GAE1D,CAEAgD,eAAgBzC,EAAMlR,GAErB,OAAO5U,KAAKqoB,gBAAiBC,GAAczC,iBAAkBC,EAAMlR,GAEpE,CAEAZ,aAAcvF,GAEb,MAAMnS,EAAI0D,KAAK1D,EAAGE,EAAIwD,KAAKxD,EAAGskB,EAAI9gB,KAAK8gB,EACjC5kB,EAAIuS,EAAEwF,SAMZ,OAJAjU,KAAK1D,EAAIJ,EAAG,GAAMI,EAAIJ,EAAG,GAAMM,EAAIN,EAAG,GAAM4kB,EAC5C9gB,KAAKxD,EAAIN,EAAG,GAAMI,EAAIJ,EAAG,GAAMM,EAAIN,EAAG,GAAM4kB,EAC5C9gB,KAAK8gB,EAAI5kB,EAAG,GAAMI,EAAIJ,EAAG,GAAMM,EAAIN,EAAG,GAAM4kB,EAErC9gB,IAER,CAEAwoB,kBAAmB/Z,GAElB,OAAOzO,KAAKgU,aAAcvF,GAAIiB,WAE/B,CAEAyR,aAAc1S,GAEb,MAAMnS,EAAI0D,KAAK1D,EAAGE,EAAIwD,KAAKxD,EAAGskB,EAAI9gB,KAAK8gB,EACjC5kB,EAAIuS,EAAEwF,SAEN8M,EAAI,GAAM7kB,EAAG,GAAMI,EAAIJ,EAAG,GAAMM,EAAIN,EAAG,IAAO4kB,EAAI5kB,EAAG,KAM3D,OAJA8D,KAAK1D,GAAMJ,EAAG,GAAMI,EAAIJ,EAAG,GAAMM,EAAIN,EAAG,GAAM4kB,EAAI5kB,EAAG,KAAS6kB,EAC9D/gB,KAAKxD,GAAMN,EAAG,GAAMI,EAAIJ,EAAG,GAAMM,EAAIN,EAAG,GAAM4kB,EAAI5kB,EAAG,KAAS6kB,EAC9D/gB,KAAK8gB,GAAM5kB,EAAG,GAAMI,EAAIJ,EAAG,GAAMM,EAAIN,EAAG,IAAO4kB,EAAI5kB,EAAG,KAAS6kB,EAExD/gB,IAER,CAEAqoB,gBAAiB5W,GAEhB,MAAMnV,EAAI0D,KAAK1D,EAAGE,EAAIwD,KAAKxD,EAAGskB,EAAI9gB,KAAK8gB,EACjC2H,EAAKhX,EAAEnV,EAAGosB,EAAKjX,EAAEjV,EAAGmsB,EAAKlX,EAAEqP,EAAG8H,EAAKnX,EAAEsP,EAIrC8H,EAAKD,EAAKtsB,EAAIosB,EAAK5H,EAAI6H,EAAKnsB,EAC5BssB,EAAKF,EAAKpsB,EAAImsB,EAAKrsB,EAAImsB,EAAK3H,EAC5BiI,EAAKH,EAAK9H,EAAI2H,EAAKjsB,EAAIksB,EAAKpsB,EAC5B0sB,GAAOP,EAAKnsB,EAAIosB,EAAKlsB,EAAImsB,EAAK7H,EAQpC,OAJA9gB,KAAK1D,EAAIusB,EAAKD,EAAKI,GAAOP,EAAKK,GAAOH,EAAKI,GAAOL,EAClD1oB,KAAKxD,EAAIssB,EAAKF,EAAKI,GAAON,EAAKK,GAAON,EAAKI,GAAOF,EAClD3oB,KAAK8gB,EAAIiI,EAAKH,EAAKI,GAAOL,EAAKE,GAAOH,EAAKI,GAAOL,EAE3CzoB,IAER,CAEAipB,QAASC,GAER,OAAOlpB,KAAKmhB,aAAc+H,EAAOC,oBAAqBhI,aAAc+H,EAAOE,iBAE5E,CAEAC,UAAWH,GAEV,OAAOlpB,KAAKmhB,aAAc+H,EAAOI,yBAA0BnI,aAAc+H,EAAOK,YAEjF,CAEAC,mBAAoB/a,GAKnB,MAAMnS,EAAI0D,KAAK1D,EAAGE,EAAIwD,KAAKxD,EAAGskB,EAAI9gB,KAAK8gB,EACjC5kB,EAAIuS,EAAEwF,SAMZ,OAJAjU,KAAK1D,EAAIJ,EAAG,GAAMI,EAAIJ,EAAG,GAAMM,EAAIN,EAAG,GAAM4kB,EAC5C9gB,KAAKxD,EAAIN,EAAG,GAAMI,EAAIJ,EAAG,GAAMM,EAAIN,EAAG,GAAM4kB,EAC5C9gB,KAAK8gB,EAAI5kB,EAAG,GAAMI,EAAIJ,EAAG,GAAMM,EAAIN,EAAG,IAAO4kB,EAEtC9gB,KAAK0P,WAEb,CAEAoE,OAAQT,GAMP,OAJArT,KAAK1D,GAAK+W,EAAE/W,EACZ0D,KAAKxD,GAAK6W,EAAE7W,EACZwD,KAAK8gB,GAAKzN,EAAEyN,EAEL9gB,IAER,CAEA+T,aAAcjB,GAEb,OAAO9S,KAAK6T,eAAgB,EAAIf,EAEjC,CAEAnV,IAAK0V,GAMJ,OAJArT,KAAK1D,EAAI0B,KAAKL,IAAKqC,KAAK1D,EAAG+W,EAAE/W,GAC7B0D,KAAKxD,EAAIwB,KAAKL,IAAKqC,KAAKxD,EAAG6W,EAAE7W,GAC7BwD,KAAK8gB,EAAI9iB,KAAKL,IAAKqC,KAAK8gB,EAAGzN,EAAEyN,GAEtB9gB,IAER,CAEAuO,IAAK8E,GAMJ,OAJArT,KAAK1D,EAAI0B,KAAKuQ,IAAKvO,KAAK1D,EAAG+W,EAAE/W,GAC7B0D,KAAKxD,EAAIwB,KAAKuQ,IAAKvO,KAAKxD,EAAG6W,EAAE7W,GAC7BwD,KAAK8gB,EAAI9iB,KAAKuQ,IAAKvO,KAAK8gB,EAAGzN,EAAEyN,GAEtB9gB,IAER,CAEAsO,MAAO3Q,EAAK4Q,GAQX,OAJAvO,KAAK1D,EAAI0B,KAAKuQ,IAAK5Q,EAAIrB,EAAG0B,KAAKL,IAAK4Q,EAAIjS,EAAG0D,KAAK1D,IAChD0D,KAAKxD,EAAIwB,KAAKuQ,IAAK5Q,EAAInB,EAAGwB,KAAKL,IAAK4Q,EAAI/R,EAAGwD,KAAKxD,IAChDwD,KAAK8gB,EAAI9iB,KAAKuQ,IAAK5Q,EAAImjB,EAAG9iB,KAAKL,IAAK4Q,EAAIuS,EAAG9gB,KAAK8gB,IAEzC9gB,IAER,CAEAkU,YAAaC,EAAQC,GAMpB,OAJApU,KAAK1D,EAAI0B,KAAKuQ,IAAK4F,EAAQnW,KAAKL,IAAKyW,EAAQpU,KAAK1D,IAClD0D,KAAKxD,EAAIwB,KAAKuQ,IAAK4F,EAAQnW,KAAKL,IAAKyW,EAAQpU,KAAKxD,IAClDwD,KAAK8gB,EAAI9iB,KAAKuQ,IAAK4F,EAAQnW,KAAKL,IAAKyW,EAAQpU,KAAK8gB,IAE3C9gB,IAER,CAEAqU,YAAa1W,EAAK4Q,GAEjB,MAAM5N,EAASX,KAAKW,SAEpB,OAAOX,KAAK+T,aAAcpT,GAAU,GAAIkT,eAAgB7V,KAAKuQ,IAAK5Q,EAAKK,KAAKL,IAAK4Q,EAAK5N,IAEvF,CAEAtC,QAMC,OAJA2B,KAAK1D,EAAI0B,KAAKK,MAAO2B,KAAK1D,GAC1B0D,KAAKxD,EAAIwB,KAAKK,MAAO2B,KAAKxD,GAC1BwD,KAAK8gB,EAAI9iB,KAAKK,MAAO2B,KAAK8gB,GAEnB9gB,IAER,CAEA+O,OAMC,OAJA/O,KAAK1D,EAAI0B,KAAK+Q,KAAM/O,KAAK1D,GACzB0D,KAAKxD,EAAIwB,KAAK+Q,KAAM/O,KAAKxD,GACzBwD,KAAK8gB,EAAI9iB,KAAK+Q,KAAM/O,KAAK8gB,GAElB9gB,IAER,CAEA2P,QAMC,OAJA3P,KAAK1D,EAAI0B,KAAK2R,MAAO3P,KAAK1D,GAC1B0D,KAAKxD,EAAIwB,KAAK2R,MAAO3P,KAAKxD,GAC1BwD,KAAK8gB,EAAI9iB,KAAK2R,MAAO3P,KAAK8gB,GAEnB9gB,IAER,CAEAsU,cAMC,OAJAtU,KAAK1D,EAAM0D,KAAK1D,EAAI,EAAM0B,KAAK+Q,KAAM/O,KAAK1D,GAAM0B,KAAKK,MAAO2B,KAAK1D,GACjE0D,KAAKxD,EAAMwD,KAAKxD,EAAI,EAAMwB,KAAK+Q,KAAM/O,KAAKxD,GAAMwB,KAAKK,MAAO2B,KAAKxD,GACjEwD,KAAK8gB,EAAM9gB,KAAK8gB,EAAI,EAAM9iB,KAAK+Q,KAAM/O,KAAK8gB,GAAM9iB,KAAKK,MAAO2B,KAAK8gB,GAE1D9gB,IAER,CAEAuU,SAMC,OAJAvU,KAAK1D,GAAM0D,KAAK1D,EAChB0D,KAAKxD,GAAMwD,KAAKxD,EAChBwD,KAAK8gB,GAAM9gB,KAAK8gB,EAET9gB,IAER,CAEAwU,IAAKnB,GAEJ,OAAOrT,KAAK1D,EAAI+W,EAAE/W,EAAI0D,KAAKxD,EAAI6W,EAAE7W,EAAIwD,KAAK8gB,EAAIzN,EAAEyN,CAEjD,CAIApM,WAEC,OAAO1U,KAAK1D,EAAI0D,KAAK1D,EAAI0D,KAAKxD,EAAIwD,KAAKxD,EAAIwD,KAAK8gB,EAAI9gB,KAAK8gB,CAE1D,CAEAngB,SAEC,OAAO3C,KAAKC,KAAM+B,KAAK1D,EAAI0D,KAAK1D,EAAI0D,KAAKxD,EAAIwD,KAAKxD,EAAIwD,KAAK8gB,EAAI9gB,KAAK8gB,EAErE,CAEAnM,kBAEC,OAAO3W,KAAKwS,IAAKxQ,KAAK1D,GAAM0B,KAAKwS,IAAKxQ,KAAKxD,GAAMwB,KAAKwS,IAAKxQ,KAAK8gB,EAEjE,CAEApR,YAEC,OAAO1P,KAAK+T,aAAc/T,KAAKW,UAAY,EAE5C,CAEAyU,UAAWzU,GAEV,OAAOX,KAAK0P,YAAYmE,eAAgBlT,EAEzC,CAEA+N,KAAM2E,EAAGgC,GAMR,OAJArV,KAAK1D,IAAO+W,EAAE/W,EAAI0D,KAAK1D,GAAM+Y,EAC7BrV,KAAKxD,IAAO6W,EAAE7W,EAAIwD,KAAKxD,GAAM6Y,EAC7BrV,KAAK8gB,IAAOzN,EAAEyN,EAAI9gB,KAAK8gB,GAAMzL,EAEtBrV,IAER,CAEAsV,YAAaC,EAAIC,EAAIH,GAMpB,OAJArV,KAAK1D,EAAIiZ,EAAGjZ,GAAMkZ,EAAGlZ,EAAIiZ,EAAGjZ,GAAM+Y,EAClCrV,KAAKxD,EAAI+Y,EAAG/Y,GAAMgZ,EAAGhZ,EAAI+Y,EAAG/Y,GAAM6Y,EAClCrV,KAAK8gB,EAAIvL,EAAGuL,GAAMtL,EAAGsL,EAAIvL,EAAGuL,GAAMzL,EAE3BrV,IAER,CAEAyU,MAAOpB,GAEN,OAAOrT,KAAKypB,aAAczpB,KAAMqT,EAEjC,CAEAoW,aAAchhB,EAAGiJ,GAEhB,MAAMgY,EAAKjhB,EAAEnM,EAAGqtB,EAAKlhB,EAAEjM,EAAGotB,EAAKnhB,EAAEqY,EAC3B+I,EAAKnY,EAAEpV,EAAGwtB,EAAKpY,EAAElV,EAAGutB,EAAKrY,EAAEoP,EAMjC,OAJA9gB,KAAK1D,EAAIqtB,EAAKI,EAAKH,EAAKE,EACxB9pB,KAAKxD,EAAIotB,EAAKC,EAAKH,EAAKK,EACxB/pB,KAAK8gB,EAAI4I,EAAKI,EAAKH,EAAKE,EAEjB7pB,IAER,CAEAgqB,gBAAiB3W,GAEhB,MAAMyB,EAAczB,EAAEqB,WAEtB,GAAqB,IAAhBI,EAAoB,OAAO9U,KAAKuS,IAAK,EAAG,EAAG,GAEhD,MAAMO,EAASO,EAAEmB,IAAKxU,MAAS8U,EAE/B,OAAO9U,KAAKoT,KAAMC,GAAIQ,eAAgBf,EAEvC,CAEAmX,eAAgBC,GAIf,OAFAC,GAAU/W,KAAMpT,MAAOgqB,gBAAiBE,GAEjClqB,KAAKyT,IAAK0W,GAElB,CAEAC,QAASC,GAKR,OAAOrqB,KAAKyT,IAAK0W,GAAU/W,KAAMiX,GAASxW,eAAgB,EAAI7T,KAAKwU,IAAK6V,IAEzE,CAEAxV,QAASxB,GAER,MAAMyB,EAAc9W,KAAKC,KAAM+B,KAAK0U,WAAarB,EAAEqB,YAEnD,GAAqB,IAAhBI,EAAoB,OAAO9W,KAAKI,GAAK,EAE1C,MAAM2W,EAAQ/U,KAAKwU,IAAKnB,GAAMyB,EAI9B,OAAO9W,KAAKgX,KAAM1G,GAAOyG,GAAS,EAAG,GAEtC,CAEAE,WAAY5B,GAEX,OAAOrV,KAAKC,KAAM+B,KAAKkV,kBAAmB7B,GAE3C,CAEA6B,kBAAmB7B,GAElB,MAAMxV,EAAKmC,KAAK1D,EAAI+W,EAAE/W,EAAGwB,EAAKkC,KAAKxD,EAAI6W,EAAE7W,EAAG8tB,EAAKtqB,KAAK8gB,EAAIzN,EAAEyN,EAE5D,OAAOjjB,EAAKA,EAAKC,EAAKA,EAAKwsB,EAAKA,CAEjC,CAEAnV,oBAAqB9B,GAEpB,OAAOrV,KAAKwS,IAAKxQ,KAAK1D,EAAI+W,EAAE/W,GAAM0B,KAAKwS,IAAKxQ,KAAKxD,EAAI6W,EAAE7W,GAAMwB,KAAKwS,IAAKxQ,KAAK8gB,EAAIzN,EAAEyN,EAEnF,CAEAyJ,iBAAkBrZ,GAEjB,OAAOlR,KAAKwqB,uBAAwBtZ,EAAEuZ,OAAQvZ,EAAEwZ,IAAKxZ,EAAE6D,MAExD,CAEAyV,uBAAwBC,EAAQC,EAAK3V,GAEpC,MAAM4V,EAAe3sB,KAAK8T,IAAK4Y,GAAQD,EAMvC,OAJAzqB,KAAK1D,EAAIquB,EAAe3sB,KAAK8T,IAAKiD,GAClC/U,KAAKxD,EAAIwB,KAAK6T,IAAK6Y,GAAQD,EAC3BzqB,KAAK8gB,EAAI6J,EAAe3sB,KAAK6T,IAAKkD,GAE3B/U,IAER,CAEA4qB,mBAAoBjZ,GAEnB,OAAO3R,KAAK6qB,yBAA0BlZ,EAAE8Y,OAAQ9Y,EAAEoD,MAAOpD,EAAEnV,EAE5D,CAEAquB,yBAA0BJ,EAAQ1V,EAAOvY,GAMxC,OAJAwD,KAAK1D,EAAImuB,EAASzsB,KAAK8T,IAAKiD,GAC5B/U,KAAKxD,EAAIA,EACTwD,KAAK8gB,EAAI2J,EAASzsB,KAAK6T,IAAKkD,GAErB/U,IAER,CAEA8qB,sBAAuBrc,GAEtB,MAAMvS,EAAIuS,EAAEwF,SAMZ,OAJAjU,KAAK1D,EAAIJ,EAAG,IACZ8D,KAAKxD,EAAIN,EAAG,IACZ8D,KAAK8gB,EAAI5kB,EAAG,IAEL8D,IAER,CAEA+qB,mBAAoBtc,GAEnB,MAAMsL,EAAK/Z,KAAKgrB,oBAAqBvc,EAAG,GAAI9N,SACtCqZ,EAAKha,KAAKgrB,oBAAqBvc,EAAG,GAAI9N,SACtCsqB,EAAKjrB,KAAKgrB,oBAAqBvc,EAAG,GAAI9N,SAM5C,OAJAX,KAAK1D,EAAIyd,EACT/Z,KAAKxD,EAAIwd,EACTha,KAAK8gB,EAAImK,EAEFjrB,IAER,CAEAgrB,oBAAqBvc,EAAG1Q,GAEvB,OAAOiC,KAAK0V,UAAWjH,EAAEwF,SAAkB,EAARlW,EAEpC,CAEAsZ,qBAAsB5I,EAAG1Q,GAExB,OAAOiC,KAAK0V,UAAWjH,EAAEwF,SAAkB,EAARlW,EAEpC,CAEAunB,aAAcppB,GAMb,OAJA8D,KAAK1D,EAAIJ,EAAE2nB,GACX7jB,KAAKxD,EAAIN,EAAE4nB,GACX9jB,KAAK8gB,EAAI5kB,EAAE6nB,GAEJ/jB,IAER,CAEAkrB,aAAcvZ,GAMb,OAJA3R,KAAK1D,EAAIqV,EAAE3I,EACXhJ,KAAKxD,EAAImV,EAAEoH,EACX/Y,KAAK8gB,EAAInP,EAAED,EAEJ1R,IAER,CAEAyV,OAAQpC,GAEP,OAAWA,EAAE/W,IAAM0D,KAAK1D,GAAS+W,EAAE7W,IAAMwD,KAAKxD,GAAS6W,EAAEyN,IAAM9gB,KAAK8gB,CAErE,CAEApL,UAAWjI,EAAOkI,EAAS,GAM1B,OAJA3V,KAAK1D,EAAImR,EAAOkI,GAChB3V,KAAKxD,EAAIiR,EAAOkI,EAAS,GACzB3V,KAAK8gB,EAAIrT,EAAOkI,EAAS,GAElB3V,IAER,CAEA4V,QAASnI,EAAQ,GAAIkI,EAAS,GAM7B,OAJAlI,EAAOkI,GAAW3V,KAAK1D,EACvBmR,EAAOkI,EAAS,GAAM3V,KAAKxD,EAC3BiR,EAAOkI,EAAS,GAAM3V,KAAK8gB,EAEpBrT,CAER,CAEAoI,oBAAqBC,EAAW/X,GAM/B,OAJAiC,KAAK1D,EAAIwZ,EAAUC,KAAMhY,GACzBiC,KAAKxD,EAAIsZ,EAAUE,KAAMjY,GACzBiC,KAAK8gB,EAAIhL,EAAUyM,KAAMxkB,GAElBiC,IAER,CAEAiO,SAMC,OAJAjO,KAAK1D,EAAI0B,KAAKiQ,SACdjO,KAAKxD,EAAIwB,KAAKiQ,SACdjO,KAAK8gB,EAAI9iB,KAAKiQ,SAEPjO,IAER,CAEAmrB,kBAIC,MAAMC,EAA8B,GAAxBptB,KAAKiQ,SAAW,IACtBU,EAAI3Q,KAAKiQ,SAAWjQ,KAAKI,GAAK,EAC9B0a,EAAI9a,KAAKC,KAAM,EAAImtB,GAAK,GAM9B,OAJAprB,KAAK1D,EAAIwc,EAAI9a,KAAK6T,IAAKlD,GACvB3O,KAAKxD,EAAIsc,EAAI9a,KAAK8T,IAAKnD,GACvB3O,KAAK8gB,EAAIsK,EAEFprB,IAER,CAEA,EAAGqB,OAAOC,kBAEHtB,KAAK1D,QACL0D,KAAKxD,QACLwD,KAAK8gB,CAEZ,EAID,MAAMqJ,GAA0B,IAAI,GAC9B7B,GAA8B,IAAI3E,GAExC,MAAM0H,GAEL9oB,YAAa5E,EAAM,IAAI,GAAS,IAAY,IAAY,KAAc4Q,EAAM,IAAI,IAAS,KAAY,KAAY,MAEhHvO,KAAKsrB,QAAS,EAEdtrB,KAAKrC,IAAMA,EACXqC,KAAKuO,IAAMA,CAEZ,CAEAgE,IAAK5U,EAAK4Q,GAKT,OAHAvO,KAAKrC,IAAIyV,KAAMzV,GACfqC,KAAKuO,IAAI6E,KAAM7E,GAERvO,IAER,CAEAurB,aAAc9d,GAEbzN,KAAKwrB,YAEL,IAAM,IAAIlrB,EAAI,EAAGmrB,EAAKhe,EAAM9M,OAAQL,EAAImrB,EAAInrB,GAAK,EAEhDN,KAAK0rB,cAAeC,GAAUjW,UAAWjI,EAAOnN,IAIjD,OAAON,IAER,CAEA4rB,uBAAwB9V,GAEvB9V,KAAKwrB,YAEL,IAAM,IAAIlrB,EAAI,EAAGmrB,EAAK3V,EAAU7Q,MAAO3E,EAAImrB,EAAInrB,IAE9CN,KAAK0rB,cAAeC,GAAU9V,oBAAqBC,EAAWxV,IAI/D,OAAON,IAER,CAEA6rB,cAAeC,GAEd9rB,KAAKwrB,YAEL,IAAM,IAAIlrB,EAAI,EAAGmrB,EAAKK,EAAOnrB,OAAQL,EAAImrB,EAAInrB,IAE5CN,KAAK0rB,cAAeI,EAAQxrB,IAI7B,OAAON,IAER,CAEA+rB,qBAAsB7V,EAAQ8V,GAE7B,MAAMC,EAAWN,GAAUvY,KAAM4Y,GAAOnY,eAAgB,IAKxD,OAHA7T,KAAKrC,IAAIyV,KAAM8C,GAASzC,IAAKwY,GAC7BjsB,KAAKuO,IAAI6E,KAAM8C,GAASlZ,IAAKivB,GAEtBjsB,IAER,CAEAksB,cAAeC,EAAQC,GAAU,GAIhC,OAFApsB,KAAKwrB,YAEExrB,KAAKqsB,eAAgBF,EAAQC,EAErC,CAEAjZ,QAEC,OAAO,IAAInT,KAAKuC,aAAc6Q,KAAMpT,KAErC,CAEAoT,KAAMkZ,GAKL,OAHAtsB,KAAKrC,IAAIyV,KAAMkZ,EAAI3uB,KACnBqC,KAAKuO,IAAI6E,KAAMkZ,EAAI/d,KAEZvO,IAER,CAEAwrB,YAKC,OAHAxrB,KAAKrC,IAAIrB,EAAI0D,KAAKrC,IAAInB,EAAIwD,KAAKrC,IAAImjB,EAAI,IACvC9gB,KAAKuO,IAAIjS,EAAI0D,KAAKuO,IAAI/R,EAAIwD,KAAKuO,IAAIuS,GAAI,IAEhC9gB,IAER,CAEAusB,UAIC,OAASvsB,KAAKuO,IAAIjS,EAAI0D,KAAKrC,IAAIrB,GAAS0D,KAAKuO,IAAI/R,EAAIwD,KAAKrC,IAAInB,GAASwD,KAAKuO,IAAIuS,EAAI9gB,KAAKrC,IAAImjB,CAE9F,CAEA0L,UAAWpoB,GAEV,OAAOpE,KAAKusB,UAAYnoB,EAAOmO,IAAK,EAAG,EAAG,GAAMnO,EAAOmP,WAAYvT,KAAKrC,IAAKqC,KAAKuO,KAAMsF,eAAgB,GAEzG,CAEA4Y,QAASroB,GAER,OAAOpE,KAAKusB,UAAYnoB,EAAOmO,IAAK,EAAG,EAAG,GAAMnO,EAAOuP,WAAY3T,KAAKuO,IAAKvO,KAAKrC,IAEnF,CAEA+tB,cAAegB,GAKd,OAHA1sB,KAAKrC,IAAIA,IAAK+uB,GACd1sB,KAAKuO,IAAIA,IAAKme,GAEP1sB,IAER,CAEA2sB,eAAgBC,GAKf,OAHA5sB,KAAKrC,IAAI8V,IAAKmZ,GACd5sB,KAAKuO,IAAIvR,IAAK4vB,GAEP5sB,IAER,CAEA6sB,eAAgB/Z,GAKf,OAHA9S,KAAKrC,IAAI2V,WAAaR,GACtB9S,KAAKuO,IAAI+E,UAAWR,GAEb9S,IAER,CAEAqsB,eAAgBF,EAAQC,GAAU,GAOjC,GAFAD,EAAOW,mBAAmB,GAAO,QAEL3vB,IAAvBgvB,EAAOY,YAEiB,OAAvBZ,EAAOY,aAEXZ,EAAOa,qBAIRC,GAAO7Z,KAAM+Y,EAAOY,aACpBE,GAAO9L,aAAcgL,EAAO5C,aAE5BvpB,KAAKktB,MAAOD,QAEN,CAEN,MAAME,EAAWhB,EAAOgB,SAExB,QAAkBhwB,IAAbgwB,EAEJ,GAAKf,QAAmCjvB,IAAxBgwB,EAASxnB,iBAA6DxI,IAAjCgwB,EAASxnB,WAAWynB,SAAyB,CAEjG,MAAMA,EAAWD,EAASxnB,WAAWynB,SACrC,IAAM,IAAI9sB,EAAI,EAAGoN,EAAI0f,EAASnoB,MAAO3E,EAAIoN,EAAGpN,IAE3CqrB,GAAU9V,oBAAqBuX,EAAU9sB,GAAI6gB,aAAcgL,EAAO5C,aAClEvpB,KAAK0rB,cAAeC,GAItB,MAE+B,OAAzBwB,EAASJ,aAEbI,EAASH,qBAIVC,GAAO7Z,KAAM+Z,EAASJ,aACtBE,GAAO9L,aAAcgL,EAAO5C,aAE5BvpB,KAAKktB,MAAOD,GAMf,CAEA,MAAMI,EAAWlB,EAAOkB,SAExB,IAAM,IAAI/sB,EAAI,EAAGoN,EAAI2f,EAAS1sB,OAAQL,EAAIoN,EAAGpN,IAE5CN,KAAKqsB,eAAgBgB,EAAU/sB,GAAK8rB,GAIrC,OAAOpsB,IAER,CAEAstB,cAAeZ,GAEd,QAAOA,EAAMpwB,EAAI0D,KAAKrC,IAAIrB,GAAKowB,EAAMpwB,EAAI0D,KAAKuO,IAAIjS,GACjDowB,EAAMlwB,EAAIwD,KAAKrC,IAAInB,GAAKkwB,EAAMlwB,EAAIwD,KAAKuO,IAAI/R,GAC3CkwB,EAAM5L,EAAI9gB,KAAKrC,IAAImjB,GAAK4L,EAAM5L,EAAI9gB,KAAKuO,IAAIuS,EAE7C,CAEAyM,YAAajB,GAEZ,OAAOtsB,KAAKrC,IAAIrB,GAAKgwB,EAAI3uB,IAAIrB,GAAKgwB,EAAI/d,IAAIjS,GAAK0D,KAAKuO,IAAIjS,GACvD0D,KAAKrC,IAAInB,GAAK8vB,EAAI3uB,IAAInB,GAAK8vB,EAAI/d,IAAI/R,GAAKwD,KAAKuO,IAAI/R,GACjDwD,KAAKrC,IAAImjB,GAAKwL,EAAI3uB,IAAImjB,GAAKwL,EAAI/d,IAAIuS,GAAK9gB,KAAKuO,IAAIuS,CAEnD,CAEA0M,aAAcd,EAAOtoB,GAKpB,OAAOA,EAAOmO,KACXma,EAAMpwB,EAAI0D,KAAKrC,IAAIrB,IAAQ0D,KAAKuO,IAAIjS,EAAI0D,KAAKrC,IAAIrB,IACjDowB,EAAMlwB,EAAIwD,KAAKrC,IAAInB,IAAQwD,KAAKuO,IAAI/R,EAAIwD,KAAKrC,IAAInB,IACjDkwB,EAAM5L,EAAI9gB,KAAKrC,IAAImjB,IAAQ9gB,KAAKuO,IAAIuS,EAAI9gB,KAAKrC,IAAImjB,GAGrD,CAEA2M,cAAenB,GAGd,QAAOA,EAAI/d,IAAIjS,EAAI0D,KAAKrC,IAAIrB,GAAKgwB,EAAI3uB,IAAIrB,EAAI0D,KAAKuO,IAAIjS,GACrDgwB,EAAI/d,IAAI/R,EAAIwD,KAAKrC,IAAInB,GAAK8vB,EAAI3uB,IAAInB,EAAIwD,KAAKuO,IAAI/R,GAC/C8vB,EAAI/d,IAAIuS,EAAI9gB,KAAKrC,IAAImjB,GAAKwL,EAAI3uB,IAAImjB,EAAI9gB,KAAKuO,IAAIuS,EAEjD,CAEA4M,iBAAkBC,GAMjB,OAHA3tB,KAAK4tB,WAAYD,EAAOzX,OAAQyV,IAGzBA,GAAUzW,kBAAmByY,EAAOzX,SAAcyX,EAAOlD,OAASkD,EAAOlD,MAEjF,CAEAoD,gBAAiBC,GAKhB,IAAInwB,EAAK4Q,EAsCT,OApCKuf,EAAMzD,OAAO/tB,EAAI,GAErBqB,EAAMmwB,EAAMzD,OAAO/tB,EAAI0D,KAAKrC,IAAIrB,EAChCiS,EAAMuf,EAAMzD,OAAO/tB,EAAI0D,KAAKuO,IAAIjS,IAIhCqB,EAAMmwB,EAAMzD,OAAO/tB,EAAI0D,KAAKuO,IAAIjS,EAChCiS,EAAMuf,EAAMzD,OAAO/tB,EAAI0D,KAAKrC,IAAIrB,GAI5BwxB,EAAMzD,OAAO7tB,EAAI,GAErBmB,GAAOmwB,EAAMzD,OAAO7tB,EAAIwD,KAAKrC,IAAInB,EACjC+R,GAAOuf,EAAMzD,OAAO7tB,EAAIwD,KAAKuO,IAAI/R,IAIjCmB,GAAOmwB,EAAMzD,OAAO7tB,EAAIwD,KAAKuO,IAAI/R,EACjC+R,GAAOuf,EAAMzD,OAAO7tB,EAAIwD,KAAKrC,IAAInB,GAI7BsxB,EAAMzD,OAAOvJ,EAAI,GAErBnjB,GAAOmwB,EAAMzD,OAAOvJ,EAAI9gB,KAAKrC,IAAImjB,EACjCvS,GAAOuf,EAAMzD,OAAOvJ,EAAI9gB,KAAKuO,IAAIuS,IAIjCnjB,GAAOmwB,EAAMzD,OAAOvJ,EAAI9gB,KAAKuO,IAAIuS,EACjCvS,GAAOuf,EAAMzD,OAAOvJ,EAAI9gB,KAAKrC,IAAImjB,GAIzBnjB,IAASmwB,EAAMC,UAAYxf,IAASuf,EAAMC,QAEpD,CAEAC,mBAAoBC,GAEnB,GAAKjuB,KAAKusB,UAET,OAAO,EAKRvsB,KAAKwsB,UAAW0B,IAChBC,GAASxa,WAAY3T,KAAKuO,IAAK2f,IAG/BE,GAAMza,WAAYsa,EAASxlB,EAAGylB,IAC9BG,GAAM1a,WAAYsa,EAASvc,EAAGwc,IAC9BI,GAAM3a,WAAYsa,EAAStc,EAAGuc,IAG9BK,GAAI5a,WAAY0a,GAAOD,IACvBI,GAAI7a,WAAY2a,GAAOD,IACvBI,GAAI9a,WAAYya,GAAOE,IAKvB,IAAII,EAAO,CACV,GAAKH,GAAIzN,EAAGyN,GAAI/xB,EAAG,GAAKgyB,GAAI1N,EAAG0N,GAAIhyB,EAAG,GAAKiyB,GAAI3N,EAAG2N,GAAIjyB,EACtD+xB,GAAIzN,EAAG,GAAKyN,GAAIjyB,EAAGkyB,GAAI1N,EAAG,GAAK0N,GAAIlyB,EAAGmyB,GAAI3N,EAAG,GAAK2N,GAAInyB,GACpDiyB,GAAI/xB,EAAG+xB,GAAIjyB,EAAG,GAAKkyB,GAAIhyB,EAAGgyB,GAAIlyB,EAAG,GAAKmyB,GAAIjyB,EAAGiyB,GAAInyB,EAAG,GAEvD,QAAOqyB,GAAYD,EAAMN,GAAOC,GAAOC,GAAOH,MAO9CO,EAAO,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KAC1BC,GAAYD,EAAMN,GAAOC,GAAOC,GAAOH,MAQ9CS,GAAgBnF,aAAc8E,GAAKC,IACnCE,EAAO,CAAEE,GAAgBtyB,EAAGsyB,GAAgBpyB,EAAGoyB,GAAgB9N,GAExD6N,GAAYD,EAAMN,GAAOC,GAAOC,GAAOH,KAE/C,CAEAP,WAAYlB,EAAOtoB,GAElB,OAAOA,EAAOgP,KAAMsZ,GAAQpe,MAAOtO,KAAKrC,IAAKqC,KAAKuO,IAEnD,CAEAsgB,gBAAiBnC,GAEhB,OAAO1sB,KAAK4tB,WAAYlB,EAAOf,IAAY1W,WAAYyX,EAExD,CAEAoC,kBAAmB1qB,GAclB,OAZKpE,KAAKusB,UAETnoB,EAAOonB,aAIPxrB,KAAKwsB,UAAWpoB,EAAO8R,QAEvB9R,EAAOqmB,OAA8C,GAArCzqB,KAAKysB,QAASd,IAAYhrB,UAIpCyD,CAER,CAEA2qB,UAAWzC,GAQV,OANAtsB,KAAKrC,IAAI4Q,IAAK+d,EAAI3uB,KAClBqC,KAAKuO,IAAI5Q,IAAK2uB,EAAI/d,KAGbvO,KAAKusB,WAAYvsB,KAAKwrB,YAEpBxrB,IAER,CAEAktB,MAAOZ,GAKN,OAHAtsB,KAAKrC,IAAIA,IAAK2uB,EAAI3uB,KAClBqC,KAAKuO,IAAIA,IAAK+d,EAAI/d,KAEXvO,IAER,CAEAmhB,aAAcxG,GAGb,OAAK3a,KAAKusB,YAGVyC,GAAS,GAAIzc,IAAKvS,KAAKrC,IAAIrB,EAAG0D,KAAKrC,IAAInB,EAAGwD,KAAKrC,IAAImjB,GAAIK,aAAcxG,GACrEqU,GAAS,GAAIzc,IAAKvS,KAAKrC,IAAIrB,EAAG0D,KAAKrC,IAAInB,EAAGwD,KAAKuO,IAAIuS,GAAIK,aAAcxG,GACrEqU,GAAS,GAAIzc,IAAKvS,KAAKrC,IAAIrB,EAAG0D,KAAKuO,IAAI/R,EAAGwD,KAAKrC,IAAImjB,GAAIK,aAAcxG,GACrEqU,GAAS,GAAIzc,IAAKvS,KAAKrC,IAAIrB,EAAG0D,KAAKuO,IAAI/R,EAAGwD,KAAKuO,IAAIuS,GAAIK,aAAcxG,GACrEqU,GAAS,GAAIzc,IAAKvS,KAAKuO,IAAIjS,EAAG0D,KAAKrC,IAAInB,EAAGwD,KAAKrC,IAAImjB,GAAIK,aAAcxG,GACrEqU,GAAS,GAAIzc,IAAKvS,KAAKuO,IAAIjS,EAAG0D,KAAKrC,IAAInB,EAAGwD,KAAKuO,IAAIuS,GAAIK,aAAcxG,GACrEqU,GAAS,GAAIzc,IAAKvS,KAAKuO,IAAIjS,EAAG0D,KAAKuO,IAAI/R,EAAGwD,KAAKrC,IAAImjB,GAAIK,aAAcxG,GACrEqU,GAAS,GAAIzc,IAAKvS,KAAKuO,IAAIjS,EAAG0D,KAAKuO,IAAI/R,EAAGwD,KAAKuO,IAAIuS,GAAIK,aAAcxG,GAErE3a,KAAK6rB,cAAemD,KAZShvB,IAgB9B,CAEAya,UAAW9E,GAKV,OAHA3V,KAAKrC,IAAIX,IAAK2Y,GACd3V,KAAKuO,IAAIvR,IAAK2Y,GAEP3V,IAER,CAEAyV,OAAQ6W,GAEP,OAAOA,EAAI3uB,IAAI8X,OAAQzV,KAAKrC,MAAS2uB,EAAI/d,IAAIkH,OAAQzV,KAAKuO,IAE3D,EAID,MAAMygB,GAAU,CACD,IAAI,GACJ,IAAI,GACJ,IAAI,GACJ,IAAI,GACJ,IAAI,GACJ,IAAI,GACJ,IAAI,GACJ,IAAI,IAGbrD,GAA0B,IAAI,GAE9BsB,GAAuB,IAAI5B,GAI3B+C,GAAsB,IAAI,GAC1BC,GAAsB,IAAI,GAC1BC,GAAsB,IAAI,GAI1BC,GAAoB,IAAI,GACxBC,GAAoB,IAAI,GACxBC,GAAoB,IAAI,GAExBP,GAAwB,IAAI,GAC5BC,GAAyB,IAAI,GAC7BS,GAAgC,IAAI,GACpCK,GAA0B,IAAI,GAEpC,SAASN,GAAYD,EAAMQ,EAAI3Z,EAAIC,EAAI2Z,GAEtC,IAAM,IAAI7uB,EAAI,EAAG8uB,EAAIV,EAAK/tB,OAAS,EAAGL,GAAK8uB,EAAG9uB,GAAK,EAAI,CAEtD2uB,GAAUvZ,UAAWgZ,EAAMpuB,GAE3B,MAAM0I,EAAImmB,EAAQ7yB,EAAI0B,KAAKwS,IAAKye,GAAU3yB,GAAM6yB,EAAQ3yB,EAAIwB,KAAKwS,IAAKye,GAAUzyB,GAAM2yB,EAAQrO,EAAI9iB,KAAKwS,IAAKye,GAAUnO,GAEhHuO,EAAKH,EAAG1a,IAAKya,IACbK,EAAK/Z,EAAGf,IAAKya,IACbM,EAAK/Z,EAAGhB,IAAKya,IAEnB,GAAKjxB,KAAKuQ,KAAOvQ,KAAKuQ,IAAK8gB,EAAIC,EAAIC,GAAMvxB,KAAKL,IAAK0xB,EAAIC,EAAIC,IAASvmB,EAInE,OAAO,CAIT,CAEA,OAAO,CAER,CAEA,MAAMwmB,GAAuB,IAAInE,GAC3BoE,GAAsB,IAAI,GAC1BC,GAAsB,IAAI,GAEhC,MAAMC,GAELptB,YAAa2T,EAAS,IAAI,GAAWuU,GAAS,GAE7CzqB,KAAKkW,OAASA,EACdlW,KAAKyqB,OAASA,CAEf,CAEAlY,IAAK2D,EAAQuU,GAKZ,OAHAzqB,KAAKkW,OAAO9C,KAAM8C,GAClBlW,KAAKyqB,OAASA,EAEPzqB,IAER,CAEA6rB,cAAeC,EAAQ8D,GAEtB,MAAM1Z,EAASlW,KAAKkW,YAEI/Y,IAAnByyB,EAEJ1Z,EAAO9C,KAAMwc,GAIbJ,GAAO3D,cAAeC,GAASU,UAAWtW,GAI3C,IAAI2Z,EAAc,EAElB,IAAM,IAAIvvB,EAAI,EAAGmrB,EAAKK,EAAOnrB,OAAQL,EAAImrB,EAAInrB,IAE5CuvB,EAAc7xB,KAAKuQ,IAAKshB,EAAa3Z,EAAOhB,kBAAmB4W,EAAQxrB,KAMxE,OAFAN,KAAKyqB,OAASzsB,KAAKC,KAAM4xB,GAElB7vB,IAER,CAEAoT,KAAMua,GAKL,OAHA3tB,KAAKkW,OAAO9C,KAAMua,EAAOzX,QACzBlW,KAAKyqB,OAASkD,EAAOlD,OAEdzqB,IAER,CAEAusB,UAEC,OAASvsB,KAAKyqB,OAAS,CAExB,CAEAe,YAKC,OAHAxrB,KAAKkW,OAAO3D,IAAK,EAAG,EAAG,GACvBvS,KAAKyqB,QAAW,EAETzqB,IAER,CAEAstB,cAAeZ,GAEd,OAASA,EAAMxX,kBAAmBlV,KAAKkW,SAAclW,KAAKyqB,OAASzqB,KAAKyqB,MAEzE,CAEAoE,gBAAiBnC,GAEhB,OAASA,EAAMzX,WAAYjV,KAAKkW,QAAWlW,KAAKyqB,MAEjD,CAEAiD,iBAAkBC,GAEjB,MAAMmC,EAAY9vB,KAAKyqB,OAASkD,EAAOlD,OAEvC,OAAOkD,EAAOzX,OAAOhB,kBAAmBlV,KAAKkW,SAAc4Z,EAAYA,CAExE,CAEArC,cAAenB,GAEd,OAAOA,EAAIoB,iBAAkB1tB,KAE9B,CAEA6tB,gBAAiBC,GAEhB,OAAO9vB,KAAKwS,IAAKsd,EAAMe,gBAAiB7uB,KAAKkW,UAAclW,KAAKyqB,MAEjE,CAEAmD,WAAYlB,EAAOtoB,GAElB,MAAM2rB,EAAgB/vB,KAAKkW,OAAOhB,kBAAmBwX,GAWrD,OATAtoB,EAAOgP,KAAMsZ,GAERqD,EAAkB/vB,KAAKyqB,OAASzqB,KAAKyqB,SAEzCrmB,EAAOqP,IAAKzT,KAAKkW,QAASxG,YAC1BtL,EAAOyP,eAAgB7T,KAAKyqB,QAASztB,IAAKgD,KAAKkW,SAIzC9R,CAER,CAEA4rB,eAAgB5rB,GAEf,OAAKpE,KAAKusB,WAGTnoB,EAAOonB,YACApnB,IAIRA,EAAOmO,IAAKvS,KAAKkW,OAAQlW,KAAKkW,QAC9B9R,EAAOyoB,eAAgB7sB,KAAKyqB,QAErBrmB,EAER,CAEA+c,aAAcxG,GAKb,OAHA3a,KAAKkW,OAAOiL,aAAcxG,GAC1B3a,KAAKyqB,OAASzqB,KAAKyqB,OAAS9P,EAAOsV,oBAE5BjwB,IAER,CAEAya,UAAW9E,GAIV,OAFA3V,KAAKkW,OAAOlZ,IAAK2Y,GAEV3V,IAER,CAEA0rB,cAAegB,GAEd,GAAK1sB,KAAKusB,UAMT,OAJAvsB,KAAKkW,OAAO9C,KAAMsZ,GAElB1sB,KAAKyqB,OAAS,EAEPzqB,KAIRyvB,GAAM9b,WAAY+Y,EAAO1sB,KAAKkW,QAE9B,MAAMxB,EAAW+a,GAAM/a,WAEvB,GAAKA,EAAa1U,KAAKyqB,OAASzqB,KAAKyqB,OAAW,CAI/C,MAAM9pB,EAAS3C,KAAKC,KAAMyW,GAEpBwb,EAAmC,IAAzBvvB,EAASX,KAAKyqB,QAE9BzqB,KAAKkW,OAAO1C,gBAAiBic,GAAOS,EAAQvvB,GAE5CX,KAAKyqB,QAAUyF,CAEhB,CAEA,OAAOlwB,IAER,CAEAktB,MAAOS,GAEN,OAAKA,EAAOpB,UAEJvsB,KAIHA,KAAKusB,WAETvsB,KAAKoT,KAAMua,GAEJ3tB,QAIqC,IAAxCA,KAAKkW,OAAOT,OAAQkY,EAAOzX,QAE9BlW,KAAKyqB,OAASzsB,KAAKuQ,IAAKvO,KAAKyqB,OAAQkD,EAAOlD,SAI7CiF,GAAM/b,WAAYga,EAAOzX,OAAQlW,KAAKkW,QAASd,UAAWuY,EAAOlD,QAEjEzqB,KAAK0rB,cAAe+D,GAAMrc,KAAMua,EAAOzX,QAASlZ,IAAK0yB,KAErD1vB,KAAK0rB,cAAe+D,GAAMrc,KAAMua,EAAOzX,QAASzC,IAAKic,MAI/C1vB,KAER,CAEAyV,OAAQkY,GAEP,OAAOA,EAAOzX,OAAOT,OAAQzV,KAAKkW,SAAcyX,EAAOlD,SAAWzqB,KAAKyqB,MAExE,CAEAtX,QAEC,OAAO,IAAInT,KAAKuC,aAAc6Q,KAAMpT,KAErC,EAID,MAAMmwB,GAA0B,IAAI,GAC9BC,GAA2B,IAAI,GAC/BC,GAAwB,IAAI,GAC5BC,GAAsB,IAAI,GAE1BC,GAAuB,IAAI,GAC3BC,GAAuB,IAAI,GAC3BC,GAA0B,IAAI,GAEpC,MAAMC,GAELnuB,YAAaouB,EAAS,IAAI,GAAWC,EAAY,IAAI,GAAS,EAAG,GAAK,IAErE5wB,KAAK2wB,OAASA,EACd3wB,KAAK4wB,UAAYA,CAElB,CAEAre,IAAKoe,EAAQC,GAKZ,OAHA5wB,KAAK2wB,OAAOvd,KAAMud,GAClB3wB,KAAK4wB,UAAUxd,KAAMwd,GAEd5wB,IAER,CAEAoT,KAAMyd,GAKL,OAHA7wB,KAAK2wB,OAAOvd,KAAMyd,EAAIF,QACtB3wB,KAAK4wB,UAAUxd,KAAMyd,EAAID,WAElB5wB,IAER,CAEA8wB,GAAIniB,EAAGvK,GAEN,OAAOA,EAAOgP,KAAMpT,KAAK2wB,QAASnd,gBAAiBxT,KAAK4wB,UAAWjiB,EAEpE,CAEAoiB,OAAQ1d,GAIP,OAFArT,KAAK4wB,UAAUxd,KAAMC,GAAII,IAAKzT,KAAK2wB,QAASjhB,YAErC1P,IAER,CAEAgxB,OAAQriB,GAIP,OAFA3O,KAAK2wB,OAAOvd,KAAMpT,KAAK8wB,GAAIniB,EAAGwhB,KAEvBnwB,IAER,CAEAixB,oBAAqBvE,EAAOtoB,GAE3BA,EAAOuP,WAAY+Y,EAAO1sB,KAAK2wB,QAE/B,MAAMO,EAAoB9sB,EAAOoQ,IAAKxU,KAAK4wB,WAE3C,OAAKM,EAAoB,EAEjB9sB,EAAOgP,KAAMpT,KAAK2wB,QAInBvsB,EAAOgP,KAAMpT,KAAK2wB,QAASnd,gBAAiBxT,KAAK4wB,UAAWM,EAEpE,CAEArC,gBAAiBnC,GAEhB,OAAO1uB,KAAKC,KAAM+B,KAAKmxB,kBAAmBzE,GAE3C,CAEAyE,kBAAmBzE,GAElB,MAAMwE,EAAoBf,GAAUxc,WAAY+Y,EAAO1sB,KAAK2wB,QAASnc,IAAKxU,KAAK4wB,WAI/E,OAAKM,EAAoB,EAEjBlxB,KAAK2wB,OAAOzb,kBAAmBwX,IAIvCyD,GAAU/c,KAAMpT,KAAK2wB,QAASnd,gBAAiBxT,KAAK4wB,UAAWM,GAExDf,GAAUjb,kBAAmBwX,GAErC,CAEA0E,oBAAqBlC,EAAI3Z,EAAI8b,EAAoBC,GAShDlB,GAAWhd,KAAM8b,GAAKlyB,IAAKuY,GAAK1B,eAAgB,IAChDwc,GAAQjd,KAAMmC,GAAK9B,IAAKyb,GAAKxf,YAC7B4gB,GAAMld,KAAMpT,KAAK2wB,QAASld,IAAK2c,IAE/B,MAAMmB,EAAkC,GAAtBrC,EAAGja,WAAYM,GAC3Bic,GAAQxxB,KAAK4wB,UAAUpc,IAAK6b,IAC5BoB,EAAKnB,GAAM9b,IAAKxU,KAAK4wB,WACrB5gB,GAAOsgB,GAAM9b,IAAK6b,IAClB1e,EAAI2e,GAAM5b,WACV2E,EAAMrb,KAAKwS,IAAK,EAAIghB,EAAMA,GAChC,IAAIE,EAAI/L,EAAIgM,EAASC,EAErB,GAAKvY,EAAM,EAQV,GAJAqY,EAAKF,EAAMxhB,EAAKyhB,EAChB9L,EAAK6L,EAAMC,EAAKzhB,EAChB4hB,EAASL,EAAYlY,EAEhBqY,GAAM,EAEV,GAAK/L,IAAQiM,EAEZ,GAAKjM,GAAMiM,EAAS,CAKnB,MAAMC,EAAS,EAAIxY,EACnBqY,GAAMG,EACNlM,GAAMkM,EACNF,EAAUD,GAAOA,EAAKF,EAAM7L,EAAK,EAAI8L,GAAO9L,GAAO6L,EAAME,EAAK/L,EAAK,EAAI3V,GAAO2B,CAE/E,MAICgU,EAAK4L,EACLG,EAAK1zB,KAAKuQ,IAAK,IAAOijB,EAAM7L,EAAK8L,IACjCE,GAAYD,EAAKA,EAAK/L,GAAOA,EAAK,EAAI3V,GAAO2B,OAQ9CgU,GAAO4L,EACPG,EAAK1zB,KAAKuQ,IAAK,IAAOijB,EAAM7L,EAAK8L,IACjCE,GAAYD,EAAKA,EAAK/L,GAAOA,EAAK,EAAI3V,GAAO2B,OAMzCgU,IAAQiM,GAIZF,EAAK1zB,KAAKuQ,IAAK,KAASijB,EAAMD,EAAYE,IAC1C9L,EAAO+L,EAAK,GAAQH,EAAYvzB,KAAKL,IAAKK,KAAKuQ,KAAOgjB,GAAavhB,GAAMuhB,GACzEI,GAAYD,EAAKA,EAAK/L,GAAOA,EAAK,EAAI3V,GAAO2B,GAElCgU,GAAMiM,GAIjBF,EAAK,EACL/L,EAAK3nB,KAAKL,IAAKK,KAAKuQ,KAAOgjB,GAAavhB,GAAMuhB,GAC9CI,EAAUhM,GAAOA,EAAK,EAAI3V,GAAO2B,IAMjC+f,EAAK1zB,KAAKuQ,IAAK,IAAOijB,EAAMD,EAAYE,IACxC9L,EAAO+L,EAAK,EAAMH,EAAYvzB,KAAKL,IAAKK,KAAKuQ,KAAOgjB,GAAavhB,GAAMuhB,GACvEI,GAAYD,EAAKA,EAAK/L,GAAOA,EAAK,EAAI3V,GAAO2B,QAU/CgU,EAAO6L,EAAM,GAAQD,EAAYA,EACjCG,EAAK1zB,KAAKuQ,IAAK,IAAOijB,EAAM7L,EAAK8L,IACjCE,GAAYD,EAAKA,EAAK/L,GAAOA,EAAK,EAAI3V,GAAO2B,EAgB9C,OAZK0f,GAEJA,EAAmBje,KAAMpT,KAAK2wB,QAASnd,gBAAiBxT,KAAK4wB,UAAWc,GAIpEJ,GAEJA,EAAuBle,KAAMgd,IAAa5c,gBAAiB6c,GAAS1K,GAI9DgM,CAER,CAEAG,gBAAiBnE,EAAQvpB,GAExB+rB,GAAUxc,WAAYga,EAAOzX,OAAQlW,KAAK2wB,QAC1C,MAAMoB,EAAM5B,GAAU3b,IAAKxU,KAAK4wB,WAC1BziB,EAAKgiB,GAAU3b,IAAK2b,IAAc4B,EAAMA,EACxCC,EAAUrE,EAAOlD,OAASkD,EAAOlD,OAEvC,GAAKtc,EAAK6jB,EAAU,OAAO,KAE3B,MAAMC,EAAMj0B,KAAKC,KAAM+zB,EAAU7jB,GAG3B+jB,EAAKH,EAAME,EAGXE,EAAKJ,EAAME,EAGjB,OAAKE,EAAK,EAAW,KAKhBD,EAAK,EAAWlyB,KAAK8wB,GAAIqB,EAAI/tB,GAG3BpE,KAAK8wB,GAAIoB,EAAI9tB,EAErB,CAEAspB,iBAAkBC,GAEjB,OAAO3tB,KAAKmxB,kBAAmBxD,EAAOzX,SAAcyX,EAAOlD,OAASkD,EAAOlD,MAE5E,CAEA2H,gBAAiBtE,GAEhB,MAAMhZ,EAAcgZ,EAAMzD,OAAO7V,IAAKxU,KAAK4wB,WAE3C,GAAqB,IAAhB9b,EAGJ,OAA8C,IAAzCgZ,EAAMe,gBAAiB7uB,KAAK2wB,QAEzB,EAMD,KAIR,MAAMhiB,IAAQ3O,KAAK2wB,OAAOnc,IAAKsZ,EAAMzD,QAAWyD,EAAMC,UAAajZ,EAInE,OAAOnG,GAAK,EAAIA,EAAI,IAErB,CAEA0jB,eAAgBvE,EAAO1pB,GAEtB,MAAMuK,EAAI3O,KAAKoyB,gBAAiBtE,GAEhC,OAAW,OAANnf,EAEG,KAID3O,KAAK8wB,GAAIniB,EAAGvK,EAEpB,CAEAypB,gBAAiBC,GAIhB,MAAMwE,EAAcxE,EAAMe,gBAAiB7uB,KAAK2wB,QAEhD,OAAqB,IAAhB2B,GAMexE,EAAMzD,OAAO7V,IAAKxU,KAAK4wB,WAExB0B,EAAc,CAUlC,CAEAC,aAAcjG,EAAKloB,GAElB,IAAIouB,EAAMC,EAAMC,EAAOC,EAAOC,EAAOC,EAErC,MAAMC,EAAU,EAAI9yB,KAAK4wB,UAAUt0B,EAClCy2B,EAAU,EAAI/yB,KAAK4wB,UAAUp0B,EAC7Bw2B,EAAU,EAAIhzB,KAAK4wB,UAAU9P,EAExB6P,EAAS3wB,KAAK2wB,OA0BpB,OAxBKmC,GAAW,GAEfN,GAASlG,EAAI3uB,IAAIrB,EAAIq0B,EAAOr0B,GAAMw2B,EAClCL,GAASnG,EAAI/d,IAAIjS,EAAIq0B,EAAOr0B,GAAMw2B,IAIlCN,GAASlG,EAAI/d,IAAIjS,EAAIq0B,EAAOr0B,GAAMw2B,EAClCL,GAASnG,EAAI3uB,IAAIrB,EAAIq0B,EAAOr0B,GAAMw2B,GAI9BC,GAAW,GAEfL,GAAUpG,EAAI3uB,IAAInB,EAAIm0B,EAAOn0B,GAAMu2B,EACnCJ,GAAUrG,EAAI/d,IAAI/R,EAAIm0B,EAAOn0B,GAAMu2B,IAInCL,GAAUpG,EAAI/d,IAAI/R,EAAIm0B,EAAOn0B,GAAMu2B,EACnCJ,GAAUrG,EAAI3uB,IAAInB,EAAIm0B,EAAOn0B,GAAMu2B,GAI7BP,EAAOG,GAAaD,EAAQD,EAAgB,OAE9CC,EAAQF,GAAQS,MAAOT,MAASA,EAAOE,IAEvCC,EAAQF,GAAQQ,MAAOR,MAASA,EAAOE,GAEvCK,GAAW,GAEfJ,GAAUtG,EAAI3uB,IAAImjB,EAAI6P,EAAO7P,GAAMkS,EACnCH,GAAUvG,EAAI/d,IAAIuS,EAAI6P,EAAO7P,GAAMkS,IAInCJ,GAAUtG,EAAI/d,IAAIuS,EAAI6P,EAAO7P,GAAMkS,EACnCH,GAAUvG,EAAI3uB,IAAImjB,EAAI6P,EAAO7P,GAAMkS,GAI7BR,EAAOK,GAAaD,EAAQH,EAAgB,OAE9CG,EAAQJ,GAAQA,GAASA,KAAOA,EAAOI,IAEvCC,EAAQJ,GAAQA,GAASA,KAAOA,EAAOI,GAIvCJ,EAAO,EAAW,KAEhBzyB,KAAK8wB,GAAI0B,GAAQ,EAAIA,EAAOC,EAAMruB,IAE1C,CAEAqpB,cAAenB,GAEd,OAA+C,OAAxCtsB,KAAKuyB,aAAcjG,EAAK6D,GAEhC,CAEA+C,kBAAmBzqB,EAAGiJ,EAAGC,EAAGwhB,EAAiB/uB,GAM5CmsB,GAAO5c,WAAYjC,EAAGjJ,GACtB+nB,GAAO7c,WAAYhC,EAAGlJ,GACtBgoB,GAAUhH,aAAc8G,GAAQC,IAOhC,IACI4C,EADAC,EAAMrzB,KAAK4wB,UAAUpc,IAAKic,IAG9B,GAAK4C,EAAM,EAAI,CAEd,GAAKF,EAAkB,OAAO,KAC9BC,EAAO,CAER,KAAO,MAAKC,EAAM,GAOjB,OAAO,KALPD,GAAS,EACTC,GAAQA,CAMT,CAEA/C,GAAM3c,WAAY3T,KAAK2wB,OAAQloB,GAC/B,MAAM6qB,EAASF,EAAOpzB,KAAK4wB,UAAUpc,IAAKgc,GAAO/G,aAAc6G,GAAOE,KAGtE,GAAK8C,EAAS,EAEb,OAAO,KAIR,MAAMC,EAASH,EAAOpzB,KAAK4wB,UAAUpc,IAAK+b,GAAO9b,MAAO6b,KAGxD,GAAKiD,EAAS,EAEb,OAAO,KAKR,GAAKD,EAASC,EAASF,EAEtB,OAAO,KAKR,MAAMG,GAAQJ,EAAO9C,GAAM9b,IAAKic,IAGhC,OAAK+C,EAAM,EAEH,KAKDxzB,KAAK8wB,GAAI0C,EAAMH,EAAKjvB,EAE5B,CAEA+c,aAAczH,GAKb,OAHA1Z,KAAK2wB,OAAOxP,aAAczH,GAC1B1Z,KAAK4wB,UAAUpH,mBAAoB9P,GAE5B1Z,IAER,CAEAyV,OAAQob,GAEP,OAAOA,EAAIF,OAAOlb,OAAQzV,KAAK2wB,SAAYE,EAAID,UAAUnb,OAAQzV,KAAK4wB,UAEvE,CAEAzd,QAEC,OAAO,IAAInT,KAAKuC,aAAc6Q,KAAMpT,KAErC,EAID,MAAMyzB,GAELlxB,YAAa6T,EAAKC,EAAKC,EAAKod,EAAKnd,EAAKC,EAAKC,EAAKkd,EAAKjd,EAAKC,EAAKC,EAAKgd,EAAKC,EAAKC,EAAKC,EAAKC,GAEvFP,GAAQpxB,UAAU4xB,WAAY,EAE9Bj0B,KAAKiU,SAAW,CAEf,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,QAIG9W,IAARiZ,GAEJpW,KAAKuS,IAAK6D,EAAKC,EAAKC,EAAKod,EAAKnd,EAAKC,EAAKC,EAAKkd,EAAKjd,EAAKC,EAAKC,EAAKgd,EAAKC,EAAKC,EAAKC,EAAKC,EAIvF,CAEAzhB,IAAK6D,EAAKC,EAAKC,EAAKod,EAAKnd,EAAKC,EAAKC,EAAKkd,EAAKjd,EAAKC,EAAKC,EAAKgd,EAAKC,EAAKC,EAAKC,EAAKC,GAE/E,MAAMld,EAAK9W,KAAKiU,SAOhB,OALA6C,EAAI,GAAMV,EAAKU,EAAI,GAAMT,EAAKS,EAAI,GAAMR,EAAKQ,EAAI,IAAO4c,EACxD5c,EAAI,GAAMP,EAAKO,EAAI,GAAMN,EAAKM,EAAI,GAAML,EAAKK,EAAI,IAAO6c,EACxD7c,EAAI,GAAMJ,EAAKI,EAAI,GAAMH,EAAKG,EAAI,IAAOF,EAAKE,EAAI,IAAO8c,EACzD9c,EAAI,GAAM+c,EAAK/c,EAAI,GAAMgd,EAAKhd,EAAI,IAAOid,EAAKjd,EAAI,IAAOkd,EAElDh0B,IAER,CAEA+W,WAWC,OATA/W,KAAKuS,IAEJ,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,GAIHvS,IAER,CAEAmT,QAEC,OAAO,IAAIsgB,IAAU/d,UAAW1V,KAAKiU,SAEtC,CAEAb,KAAM3E,GAEL,MAAMqI,EAAK9W,KAAKiU,SACV+C,EAAKvI,EAAEwF,SAOb,OALA6C,EAAI,GAAME,EAAI,GAAKF,EAAI,GAAME,EAAI,GAAKF,EAAI,GAAME,EAAI,GAAKF,EAAI,GAAME,EAAI,GACvEF,EAAI,GAAME,EAAI,GAAKF,EAAI,GAAME,EAAI,GAAKF,EAAI,GAAME,EAAI,GAAKF,EAAI,GAAME,EAAI,GACvEF,EAAI,GAAME,EAAI,GAAKF,EAAI,GAAME,EAAI,GAAKF,EAAI,IAAOE,EAAI,IAAMF,EAAI,IAAOE,EAAI,IAC1EF,EAAI,IAAOE,EAAI,IAAMF,EAAI,IAAOE,EAAI,IAAMF,EAAI,IAAOE,EAAI,IAAMF,EAAI,IAAOE,EAAI,IAEvEhX,IAER,CAEAk0B,aAAczlB,GAEb,MAAMqI,EAAK9W,KAAKiU,SAAU+C,EAAKvI,EAAEwF,SAMjC,OAJA6C,EAAI,IAAOE,EAAI,IACfF,EAAI,IAAOE,EAAI,IACfF,EAAI,IAAOE,EAAI,IAERhX,IAER,CAEAm0B,eAAgB1lB,GAEf,MAAMuI,EAAKvI,EAAEwF,SAWb,OATAjU,KAAKuS,IAEJyE,EAAI,GAAKA,EAAI,GAAKA,EAAI,GAAK,EAC3BA,EAAI,GAAKA,EAAI,GAAKA,EAAI,GAAK,EAC3BA,EAAI,GAAKA,EAAI,GAAKA,EAAI,GAAK,EAC3B,EAAG,EAAG,EAAG,GAIHhX,IAER,CAEAiX,aAAcC,EAAOC,EAAOC,GAM3B,OAJAF,EAAM8T,oBAAqBhrB,KAAM,GACjCmX,EAAM6T,oBAAqBhrB,KAAM,GACjCoX,EAAM4T,oBAAqBhrB,KAAM,GAE1BA,IAER,CAEAo0B,UAAWld,EAAOC,EAAOC,GASxB,OAPApX,KAAKuS,IACJ2E,EAAM5a,EAAG6a,EAAM7a,EAAG8a,EAAM9a,EAAG,EAC3B4a,EAAM1a,EAAG2a,EAAM3a,EAAG4a,EAAM5a,EAAG,EAC3B0a,EAAM4J,EAAG3J,EAAM2J,EAAG1J,EAAM0J,EAAG,EAC3B,EAAG,EAAG,EAAG,GAGH9gB,IAER,CAEAq0B,gBAAiB5lB,GAIhB,MAAMqI,EAAK9W,KAAKiU,SACV+C,EAAKvI,EAAEwF,SAEPqgB,EAAS,EAAIC,GAAMvJ,oBAAqBvc,EAAG,GAAI9N,SAC/C6zB,EAAS,EAAID,GAAMvJ,oBAAqBvc,EAAG,GAAI9N,SAC/C8zB,EAAS,EAAIF,GAAMvJ,oBAAqBvc,EAAG,GAAI9N,SAsBrD,OApBAmW,EAAI,GAAME,EAAI,GAAMsd,EACpBxd,EAAI,GAAME,EAAI,GAAMsd,EACpBxd,EAAI,GAAME,EAAI,GAAMsd,EACpBxd,EAAI,GAAM,EAEVA,EAAI,GAAME,EAAI,GAAMwd,EACpB1d,EAAI,GAAME,EAAI,GAAMwd,EACpB1d,EAAI,GAAME,EAAI,GAAMwd,EACpB1d,EAAI,GAAM,EAEVA,EAAI,GAAME,EAAI,GAAMyd,EACpB3d,EAAI,GAAME,EAAI,GAAMyd,EACpB3d,EAAI,IAAOE,EAAI,IAAOyd,EACtB3d,EAAI,IAAO,EAEXA,EAAI,IAAO,EACXA,EAAI,IAAO,EACXA,EAAI,IAAO,EACXA,EAAI,IAAO,EAEJ9W,IAER,CAEA00B,sBAAuBnP,GAEtB,MAAMzO,EAAK9W,KAAKiU,SAEV3X,EAAIipB,EAAMjpB,EAAGE,EAAI+oB,EAAM/oB,EAAGskB,EAAIyE,EAAMzE,EACpCrY,EAAIzK,KAAK6T,IAAKvV,GAAKoV,EAAI1T,KAAK8T,IAAKxV,GACjCqV,EAAI3T,KAAK6T,IAAKrV,GAAKgM,EAAIxK,KAAK8T,IAAKtV,GACjCN,EAAI8B,KAAK6T,IAAKiP,GAAKhI,EAAI9a,KAAK8T,IAAKgP,GAEvC,GAAqB,QAAhByE,EAAM3T,MAAkB,CAE5B,MAAM6F,EAAKhP,EAAIvM,EAAGy4B,EAAKlsB,EAAIqQ,EAAGpB,EAAKhG,EAAIxV,EAAG04B,EAAKljB,EAAIoH,EAEnDhC,EAAI,GAAMnF,EAAIzV,EACd4a,EAAI,IAAQnF,EAAImH,EAChBhC,EAAI,GAAMtO,EAEVsO,EAAI,GAAM6d,EAAKjd,EAAKlP,EACpBsO,EAAI,GAAMW,EAAKmd,EAAKpsB,EACpBsO,EAAI,IAAQpF,EAAIC,EAEhBmF,EAAI,GAAM8d,EAAKnd,EAAKjP,EACpBsO,EAAI,GAAMY,EAAKid,EAAKnsB,EACpBsO,EAAI,IAAOrO,EAAIkJ,CAEhB,MAAO,GAAqB,QAAhB4T,EAAM3T,MAAkB,CAEnC,MAAMijB,EAAKljB,EAAIzV,EAAG44B,EAAKnjB,EAAImH,EAAGic,EAAKvsB,EAAItM,EAAG84B,EAAKxsB,EAAIsQ,EAEnDhC,EAAI,GAAM+d,EAAKG,EAAKtjB,EACpBoF,EAAI,GAAMie,EAAKrjB,EAAIojB,EACnBhe,EAAI,GAAMrO,EAAID,EAEdsO,EAAI,GAAMrO,EAAIqQ,EACdhC,EAAI,GAAMrO,EAAIvM,EACd4a,EAAI,IAAQpF,EAEZoF,EAAI,GAAMge,EAAKpjB,EAAIqjB,EACnBje,EAAI,GAAMke,EAAKH,EAAKnjB,EACpBoF,EAAI,IAAOrO,EAAIkJ,CAEhB,MAAO,GAAqB,QAAhB4T,EAAM3T,MAAkB,CAEnC,MAAMijB,EAAKljB,EAAIzV,EAAG44B,EAAKnjB,EAAImH,EAAGic,EAAKvsB,EAAItM,EAAG84B,EAAKxsB,EAAIsQ,EAEnDhC,EAAI,GAAM+d,EAAKG,EAAKtjB,EACpBoF,EAAI,IAAQrO,EAAIqQ,EAChBhC,EAAI,GAAMie,EAAKD,EAAKpjB,EAEpBoF,EAAI,GAAMge,EAAKC,EAAKrjB,EACpBoF,EAAI,GAAMrO,EAAIvM,EACd4a,EAAI,GAAMke,EAAKH,EAAKnjB,EAEpBoF,EAAI,IAAQrO,EAAID,EAChBsO,EAAI,GAAMpF,EACVoF,EAAI,IAAOrO,EAAIkJ,CAEhB,MAAO,GAAqB,QAAhB4T,EAAM3T,MAAkB,CAEnC,MAAM6F,EAAKhP,EAAIvM,EAAGy4B,EAAKlsB,EAAIqQ,EAAGpB,EAAKhG,EAAIxV,EAAG04B,EAAKljB,EAAIoH,EAEnDhC,EAAI,GAAMnF,EAAIzV,EACd4a,EAAI,GAAMY,EAAKlP,EAAImsB,EACnB7d,EAAI,GAAMW,EAAKjP,EAAIosB,EAEnB9d,EAAI,GAAMnF,EAAImH,EACdhC,EAAI,GAAM8d,EAAKpsB,EAAIiP,EACnBX,EAAI,GAAM6d,EAAKnsB,EAAIkP,EAEnBZ,EAAI,IAAQtO,EACZsO,EAAI,GAAMpF,EAAIC,EACdmF,EAAI,IAAOrO,EAAIkJ,CAEhB,MAAO,GAAqB,QAAhB4T,EAAM3T,MAAkB,CAEnC,MAAMqjB,EAAKxsB,EAAIkJ,EAAGujB,EAAKzsB,EAAID,EAAG2sB,EAAKzjB,EAAIC,EAAGyjB,EAAK1jB,EAAIlJ,EAEnDsO,EAAI,GAAMnF,EAAIzV,EACd4a,EAAI,GAAMse,EAAKH,EAAKnc,EACpBhC,EAAI,GAAMqe,EAAKrc,EAAIoc,EAEnBpe,EAAI,GAAMgC,EACVhC,EAAI,GAAMrO,EAAIvM,EACd4a,EAAI,IAAQpF,EAAIxV,EAEhB4a,EAAI,IAAQtO,EAAItM,EAChB4a,EAAI,GAAMoe,EAAKpc,EAAIqc,EACnBre,EAAI,IAAOme,EAAKG,EAAKtc,CAEtB,MAAO,GAAqB,QAAhByM,EAAM3T,MAAkB,CAEnC,MAAMqjB,EAAKxsB,EAAIkJ,EAAGujB,EAAKzsB,EAAID,EAAG2sB,EAAKzjB,EAAIC,EAAGyjB,EAAK1jB,EAAIlJ,EAEnDsO,EAAI,GAAMnF,EAAIzV,EACd4a,EAAI,IAAQgC,EACZhC,EAAI,GAAMtO,EAAItM,EAEd4a,EAAI,GAAMme,EAAKnc,EAAIsc,EACnBte,EAAI,GAAMrO,EAAIvM,EACd4a,EAAI,GAAMoe,EAAKpc,EAAIqc,EAEnBre,EAAI,GAAMqe,EAAKrc,EAAIoc,EACnBpe,EAAI,GAAMpF,EAAIxV,EACd4a,EAAI,IAAOse,EAAKtc,EAAImc,CAErB,CAaA,OAVAne,EAAI,GAAM,EACVA,EAAI,GAAM,EACVA,EAAI,IAAO,EAGXA,EAAI,IAAO,EACXA,EAAI,IAAO,EACXA,EAAI,IAAO,EACXA,EAAI,IAAO,EAEJ9W,IAER,CAEAq1B,2BAA4B5jB,GAE3B,OAAOzR,KAAKs1B,QAASC,GAAO9jB,EAAG+jB,GAEhC,CAEAzE,OAAQ0E,EAAKrxB,EAAQsxB,GAEpB,MAAM5e,EAAK9W,KAAKiU,SAyChB,OAvCA8P,GAAGpQ,WAAY8hB,EAAKrxB,GAEG,IAAlB2f,GAAGrP,aAIPqP,GAAGjD,EAAI,GAIRiD,GAAGrU,YACHmU,GAAG4F,aAAciM,EAAI3R,IAEE,IAAlBF,GAAGnP,aAImB,IAArB1W,KAAKwS,IAAKklB,EAAG5U,GAEjBiD,GAAGznB,GAAK,KAIRynB,GAAGjD,GAAK,KAITiD,GAAGrU,YACHmU,GAAG4F,aAAciM,EAAI3R,KAItBF,GAAGnU,YACHoU,GAAG2F,aAAc1F,GAAIF,IAErB/M,EAAI,GAAM+M,GAAGvnB,EAAGwa,EAAI,GAAMgN,GAAGxnB,EAAGwa,EAAI,GAAMiN,GAAGznB,EAC7Cwa,EAAI,GAAM+M,GAAGrnB,EAAGsa,EAAI,GAAMgN,GAAGtnB,EAAGsa,EAAI,GAAMiN,GAAGvnB,EAC7Csa,EAAI,GAAM+M,GAAG/C,EAAGhK,EAAI,GAAMgN,GAAGhD,EAAGhK,EAAI,IAAOiN,GAAGjD,EAEvC9gB,IAER,CAEA4T,SAAUnF,GAET,OAAOzO,KAAKuX,iBAAkBvX,KAAMyO,EAErC,CAEA+I,YAAa/I,GAEZ,OAAOzO,KAAKuX,iBAAkB9I,EAAGzO,KAElC,CAEAuX,iBAAkB9O,EAAGiJ,GAEpB,MAAM+F,EAAKhP,EAAEwL,SACPyD,EAAKhG,EAAEuC,SACP6C,EAAK9W,KAAKiU,SAEV0D,EAAMF,EAAI,GAAKG,EAAMH,EAAI,GAAKI,EAAMJ,EAAI,GAAKke,EAAMle,EAAI,IACvDK,EAAML,EAAI,GAAKM,EAAMN,EAAI,GAAKO,EAAMP,EAAI,GAAKme,EAAMne,EAAI,IACvDQ,EAAMR,EAAI,GAAKS,EAAMT,EAAI,GAAKU,EAAMV,EAAI,IAAMoe,EAAMpe,EAAI,IACxDqe,EAAMre,EAAI,GAAKse,EAAMte,EAAI,GAAKue,EAAMve,EAAI,IAAMwe,EAAMxe,EAAI,IAExDW,EAAMV,EAAI,GAAKW,EAAMX,EAAI,GAAKY,EAAMZ,EAAI,GAAKwe,EAAMxe,EAAI,IACvDa,EAAMb,EAAI,GAAKc,EAAMd,EAAI,GAAKe,EAAMf,EAAI,GAAKye,EAAMze,EAAI,IACvDgB,EAAMhB,EAAI,GAAKiB,EAAMjB,EAAI,GAAKkB,EAAMlB,EAAI,IAAM0e,EAAM1e,EAAI,IACxD2e,EAAM3e,EAAI,GAAK4e,EAAM5e,EAAI,GAAK6e,EAAM7e,EAAI,IAAM8e,EAAM9e,EAAI,IAsB9D,OApBAZ,EAAI,GAAMa,EAAMS,EAAMR,EAAMW,EAAMV,EAAMa,EAAMid,EAAMU,EACpDvf,EAAI,GAAMa,EAAMU,EAAMT,EAAMY,EAAMX,EAAMc,EAAMgd,EAAMW,EACpDxf,EAAI,GAAMa,EAAMW,EAAMV,EAAMa,EAAMZ,EAAMe,EAAM+c,EAAMY,EACpDzf,EAAI,IAAOa,EAAMue,EAAMte,EAAMue,EAAMte,EAAMue,EAAMT,EAAMa,EAErD1f,EAAI,GAAMgB,EAAMM,EAAML,EAAMQ,EAAMP,EAAMU,EAAMkd,EAAMS,EACpDvf,EAAI,GAAMgB,EAAMO,EAAMN,EAAMS,EAAMR,EAAMW,EAAMid,EAAMU,EACpDxf,EAAI,GAAMgB,EAAMQ,EAAMP,EAAMU,EAAMT,EAAMY,EAAMgd,EAAMW,EACpDzf,EAAI,IAAOgB,EAAMoe,EAAMne,EAAMoe,EAAMne,EAAMoe,EAAMR,EAAMY,EAErD1f,EAAI,GAAMmB,EAAMG,EAAMF,EAAMK,EAAMJ,EAAMO,EAAMmd,EAAMQ,EACpDvf,EAAI,GAAMmB,EAAMI,EAAMH,EAAMM,EAAML,EAAMQ,EAAMkd,EAAMS,EACpDxf,EAAI,IAAOmB,EAAMK,EAAMJ,EAAMO,EAAMN,EAAMS,EAAMid,EAAMU,EACrDzf,EAAI,IAAOmB,EAAMie,EAAMhe,EAAMie,EAAMhe,EAAMie,EAAMP,EAAMW,EAErD1f,EAAI,GAAMgf,EAAM1d,EAAM2d,EAAMxd,EAAMyd,EAAMtd,EAAMud,EAAMI,EACpDvf,EAAI,GAAMgf,EAAMzd,EAAM0d,EAAMvd,EAAMwd,EAAMrd,EAAMsd,EAAMK,EACpDxf,EAAI,IAAOgf,EAAMxd,EAAMyd,EAAMtd,EAAMud,EAAMpd,EAAMqd,EAAMM,EACrDzf,EAAI,IAAOgf,EAAMI,EAAMH,EAAMI,EAAMH,EAAMI,EAAMH,EAAMO,EAE9Cx2B,IAER,CAEA6T,eAAgB3C,GAEf,MAAM4F,EAAK9W,KAAKiU,SAOhB,OALA6C,EAAI,IAAO5F,EAAG4F,EAAI,IAAO5F,EAAG4F,EAAI,IAAO5F,EAAG4F,EAAI,KAAQ5F,EACtD4F,EAAI,IAAO5F,EAAG4F,EAAI,IAAO5F,EAAG4F,EAAI,IAAO5F,EAAG4F,EAAI,KAAQ5F,EACtD4F,EAAI,IAAO5F,EAAG4F,EAAI,IAAO5F,EAAG4F,EAAI,KAAQ5F,EAAG4F,EAAI,KAAQ5F,EACvD4F,EAAI,IAAO5F,EAAG4F,EAAI,IAAO5F,EAAG4F,EAAI,KAAQ5F,EAAG4F,EAAI,KAAQ5F,EAEhDlR,IAER,CAEA6Y,cAEC,MAAM/B,EAAK9W,KAAKiU,SAEVmC,EAAMU,EAAI,GAAKT,EAAMS,EAAI,GAAKR,EAAMQ,EAAI,GAAK4c,EAAM5c,EAAI,IACvDP,EAAMO,EAAI,GAAKN,EAAMM,EAAI,GAAKL,EAAMK,EAAI,GAAK6c,EAAM7c,EAAI,IACvDJ,EAAMI,EAAI,GAAKH,EAAMG,EAAI,GAAKF,EAAME,EAAI,IAAM8c,EAAM9c,EAAI,IAM9D,OALYA,EAAI,KAOZ4c,EAAMjd,EAAME,EACXL,EAAMqd,EAAMhd,EACZ+c,EAAMld,EAAMI,EACZP,EAAMsd,EAAM/c,EACZN,EAAME,EAAMod,EACZvd,EAAMI,EAAMmd,GAZU9c,EAAI,KAe3BV,EAAMK,EAAMmd,EACXxd,EAAMud,EAAM/c,EACZ8c,EAAMnd,EAAMK,EACZN,EAAMC,EAAMqd,EACZtd,EAAMqd,EAAMjd,EACZgd,EAAMjd,EAAMC,GApByBI,EAAI,MAuB1CV,EAAMud,EAAMhd,EACXP,EAAMI,EAAMod,EACZF,EAAMnd,EAAMI,EACZN,EAAME,EAAMqd,EACZF,EAAMld,EAAME,EACZL,EAAMsd,EAAMjd,GA5ByCI,EAAI,MA+B1DR,EAAME,EAAME,EACXN,EAAMK,EAAME,EACZP,EAAMI,EAAMI,EACZN,EAAMC,EAAMI,EACZN,EAAME,EAAMK,EACZP,EAAMI,EAAMC,EAKlB,CAEA6C,YAEC,MAAMzC,EAAK9W,KAAKiU,SAChB,IAAIuF,EAUJ,OARAA,EAAM1C,EAAI,GAAKA,EAAI,GAAMA,EAAI,GAAKA,EAAI,GAAM0C,EAC5CA,EAAM1C,EAAI,GAAKA,EAAI,GAAMA,EAAI,GAAKA,EAAI,GAAM0C,EAC5CA,EAAM1C,EAAI,GAAKA,EAAI,GAAMA,EAAI,GAAKA,EAAI,GAAM0C,EAE5CA,EAAM1C,EAAI,GAAKA,EAAI,GAAMA,EAAI,IAAMA,EAAI,IAAO0C,EAC9CA,EAAM1C,EAAI,GAAKA,EAAI,GAAMA,EAAI,IAAMA,EAAI,IAAO0C,EAC9CA,EAAM1C,EAAI,IAAMA,EAAI,IAAOA,EAAI,IAAMA,EAAI,IAAO0C,EAEzCxZ,IAER,CAEAy2B,YAAan6B,EAAGE,EAAGskB,GAElB,MAAMhK,EAAK9W,KAAKiU,SAgBhB,OAdK3X,EAAE4rB,WAENpR,EAAI,IAAOxa,EAAEA,EACbwa,EAAI,IAAOxa,EAAEE,EACbsa,EAAI,IAAOxa,EAAEwkB,IAIbhK,EAAI,IAAOxa,EACXwa,EAAI,IAAOta,EACXsa,EAAI,IAAOgK,GAIL9gB,IAER,CAEAiZ,SAGC,MAAMnC,EAAK9W,KAAKiU,SAEfmC,EAAMU,EAAI,GAAKP,EAAMO,EAAI,GAAKJ,EAAMI,EAAI,GAAK+c,EAAM/c,EAAI,GACvDT,EAAMS,EAAI,GAAKN,EAAMM,EAAI,GAAKH,EAAMG,EAAI,GAAKgd,EAAMhd,EAAI,GACvDR,EAAMQ,EAAI,GAAKL,EAAMK,EAAI,GAAKF,EAAME,EAAI,IAAMid,EAAMjd,EAAI,IACxD4c,EAAM5c,EAAI,IAAM6c,EAAM7c,EAAI,IAAM8c,EAAM9c,EAAI,IAAMkd,EAAMld,EAAI,IAE1DoC,EAAMzC,EAAMmd,EAAME,EAAMH,EAAM/c,EAAMkd,EAAMH,EAAMhd,EAAMod,EAAMvd,EAAMod,EAAMG,EAAMtd,EAAME,EAAMqd,EAAMxd,EAAMI,EAAMod,EAC5G7a,EAAMua,EAAM9c,EAAMkd,EAAMxd,EAAMsd,EAAME,EAAMJ,EAAM/c,EAAMod,EAAM1d,EAAMud,EAAMG,EAAMzd,EAAMK,EAAMqd,EAAM3d,EAAMO,EAAMod,EAC5G5a,EAAM9C,EAAMqd,EAAMG,EAAMJ,EAAMjd,EAAMqd,EAAMJ,EAAMld,EAAMud,EAAM1d,EAAMsd,EAAMI,EAAMzd,EAAME,EAAMwd,EAAM3d,EAAMI,EAAMud,EAC5G0C,EAAMhD,EAAMjd,EAAME,EAAML,EAAMqd,EAAMhd,EAAM+c,EAAMld,EAAMI,EAAMP,EAAMsd,EAAM/c,EAAMN,EAAME,EAAMod,EAAMvd,EAAMI,EAAMmd,EAEvGva,EAAMjD,EAAM8C,EAAM3C,EAAM4C,EAAMzC,EAAM0C,EAAMya,EAAM6C,EAEtD,GAAa,IAARrd,EAAY,OAAOrZ,KAAKuS,IAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAE/E,MAAM+G,EAAS,EAAID,EAsBnB,OApBAvC,EAAI,GAAMoC,EAAMI,EAChBxC,EAAI,IAAQ6c,EAAM/c,EAAMid,EAAMpd,EAAMmd,EAAMC,EAAMF,EAAMjd,EAAMqd,EAAMxd,EAAMqd,EAAMG,EAAMtd,EAAMC,EAAMsd,EAAMzd,EAAMK,EAAMod,GAAQ1a,EAC1HxC,EAAI,IAAQN,EAAMod,EAAMC,EAAMF,EAAMhd,EAAMkd,EAAMF,EAAMjd,EAAMod,EAAMvd,EAAMqd,EAAME,EAAMtd,EAAME,EAAMsd,EAAMzd,EAAMI,EAAMqd,GAAQ1a,EAC1HxC,EAAI,IAAQL,EAAME,EAAMkd,EAAMrd,EAAMI,EAAMid,EAAMpd,EAAMC,EAAMod,EAAMvd,EAAMK,EAAMkd,EAAMtd,EAAME,EAAMqd,EAAMxd,EAAMI,EAAMod,GAAQza,EAE1HxC,EAAI,GAAMqC,EAAMG,EAChBxC,EAAI,IAAQR,EAAMsd,EAAMC,EAAMH,EAAM9c,EAAMid,EAAMH,EAAMhd,EAAMqd,EAAM3d,EAAMwd,EAAMG,EAAMzd,EAAMI,EAAMsd,EAAM5d,EAAMQ,EAAMod,GAAQ1a,EAC1HxC,EAAI,IAAQ4c,EAAM/c,EAAMkd,EAAMxd,EAAMud,EAAMC,EAAMH,EAAMhd,EAAMod,EAAM1d,EAAMwd,EAAME,EAAMzd,EAAMK,EAAMsd,EAAM5d,EAAMO,EAAMqd,GAAQ1a,EAC1HxC,EAAI,IAAQT,EAAMO,EAAMid,EAAMvd,EAAMK,EAAMkd,EAAMvd,EAAMI,EAAMod,EAAM1d,EAAMQ,EAAMkd,EAAMzd,EAAMK,EAAMqd,EAAM3d,EAAMO,EAAMod,GAAQza,EAE1HxC,EAAI,GAAMsC,EAAME,EAChBxC,EAAI,IAAQ4c,EAAMjd,EAAMod,EAAMvd,EAAMqd,EAAME,EAAMH,EAAMnd,EAAMwd,EAAM3d,EAAMud,EAAMI,EAAMzd,EAAMC,EAAMyd,EAAM5d,EAAMK,EAAMud,GAAQ1a,EAC1HxC,EAAI,KAAST,EAAMsd,EAAME,EAAMH,EAAMld,EAAMqd,EAAMH,EAAMnd,EAAMud,EAAM1d,EAAMud,EAAMG,EAAMzd,EAAME,EAAMyd,EAAM5d,EAAMI,EAAMwd,GAAQ1a,EAC3HxC,EAAI,KAASR,EAAME,EAAMqd,EAAMxd,EAAMI,EAAMod,EAAMvd,EAAMC,EAAMud,EAAM1d,EAAMK,EAAMqd,EAAMzd,EAAME,EAAMwd,EAAM3d,EAAMI,EAAMud,GAAQza,EAE3HxC,EAAI,IAAO4f,EAAMpd,EACjBxC,EAAI,KAASR,EAAMqd,EAAMjd,EAAMgd,EAAMjd,EAAMC,EAAMgd,EAAMnd,EAAMK,EAAMR,EAAMud,EAAM/c,EAAMN,EAAMC,EAAMqd,EAAMxd,EAAMK,EAAMmd,GAAQta,EAC3HxC,EAAI,KAAS4c,EAAMld,EAAME,EAAML,EAAMsd,EAAMjd,EAAMgd,EAAMnd,EAAMI,EAAMP,EAAMud,EAAMhd,EAAMN,EAAME,EAAMqd,EAAMxd,EAAMI,EAAMod,GAAQta,EAC3HxC,EAAI,KAAST,EAAMI,EAAMC,EAAMJ,EAAME,EAAME,EAAMJ,EAAMC,EAAMI,EAAMP,EAAMK,EAAME,EAAMN,EAAME,EAAMK,EAAMR,EAAMI,EAAMI,GAAQ0C,EAEpHtZ,IAER,CAEAoa,MAAO/G,GAEN,MAAMyD,EAAK9W,KAAKiU,SACV3X,EAAI+W,EAAE/W,EAAGE,EAAI6W,EAAE7W,EAAGskB,EAAIzN,EAAEyN,EAO9B,OALAhK,EAAI,IAAOxa,EAAGwa,EAAI,IAAOta,EAAGsa,EAAI,IAAOgK,EACvChK,EAAI,IAAOxa,EAAGwa,EAAI,IAAOta,EAAGsa,EAAI,IAAOgK,EACvChK,EAAI,IAAOxa,EAAGwa,EAAI,IAAOta,EAAGsa,EAAI,KAAQgK,EACxChK,EAAI,IAAOxa,EAAGwa,EAAI,IAAOta,EAAGsa,EAAI,KAAQgK,EAEjC9gB,IAER,CAEAiwB,oBAEC,MAAMnZ,EAAK9W,KAAKiU,SAEV0iB,EAAW7f,EAAI,GAAMA,EAAI,GAAMA,EAAI,GAAMA,EAAI,GAAMA,EAAI,GAAMA,EAAI,GACjE8f,EAAW9f,EAAI,GAAMA,EAAI,GAAMA,EAAI,GAAMA,EAAI,GAAMA,EAAI,GAAMA,EAAI,GACjE+f,EAAW/f,EAAI,GAAMA,EAAI,GAAMA,EAAI,GAAMA,EAAI,GAAMA,EAAI,IAAOA,EAAI,IAExE,OAAO9Y,KAAKC,KAAMD,KAAKuQ,IAAKooB,EAAUC,EAAUC,GAEjD,CAEAnc,gBAAiBpe,EAAGE,EAAGskB,GA0BtB,OAxBKxkB,EAAE4rB,UAENloB,KAAKuS,IAEJ,EAAG,EAAG,EAAGjW,EAAEA,EACX,EAAG,EAAG,EAAGA,EAAEE,EACX,EAAG,EAAG,EAAGF,EAAEwkB,EACX,EAAG,EAAG,EAAG,GAMV9gB,KAAKuS,IAEJ,EAAG,EAAG,EAAGjW,EACT,EAAG,EAAG,EAAGE,EACT,EAAG,EAAG,EAAGskB,EACT,EAAG,EAAG,EAAG,GAMJ9gB,IAER,CAEA82B,cAAe/hB,GAEd,MAAMpD,EAAI3T,KAAK6T,IAAKkD,GAAS7D,EAAIlT,KAAK8T,IAAKiD,GAW3C,OATA/U,KAAKuS,IAEJ,EAAG,EAAG,EAAG,EACT,EAAGZ,GAAKT,EAAG,EACX,EAAGA,EAAGS,EAAG,EACT,EAAG,EAAG,EAAG,GAIH3R,IAER,CAEA+2B,cAAehiB,GAEd,MAAMpD,EAAI3T,KAAK6T,IAAKkD,GAAS7D,EAAIlT,KAAK8T,IAAKiD,GAW3C,OATA/U,KAAKuS,IAEHZ,EAAG,EAAGT,EAAG,EACT,EAAG,EAAG,EAAG,GACRA,EAAG,EAAGS,EAAG,EACV,EAAG,EAAG,EAAG,GAIJ3R,IAER,CAEAg3B,cAAejiB,GAEd,MAAMpD,EAAI3T,KAAK6T,IAAKkD,GAAS7D,EAAIlT,KAAK8T,IAAKiD,GAW3C,OATA/U,KAAKuS,IAEJZ,GAAKT,EAAG,EAAG,EACXA,EAAGS,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,GAIH3R,IAER,CAEAi3B,iBAAkBnR,EAAMlR,GAIvB,MAAMjD,EAAI3T,KAAK6T,IAAK+C,GACd1D,EAAIlT,KAAK8T,IAAK8C,GACdjG,EAAI,EAAIgD,EACRrV,EAAIwpB,EAAKxpB,EAAGE,EAAIspB,EAAKtpB,EAAGskB,EAAIgF,EAAKhF,EACjCjH,EAAKlL,EAAIrS,EAAGwd,EAAKnL,EAAInS,EAW3B,OATAwD,KAAKuS,IAEJsH,EAAKvd,EAAIqV,EAAGkI,EAAKrd,EAAI0U,EAAI4P,EAAGjH,EAAKiH,EAAI5P,EAAI1U,EAAG,EAC5Cqd,EAAKrd,EAAI0U,EAAI4P,EAAGhH,EAAKtd,EAAImV,EAAGmI,EAAKgH,EAAI5P,EAAI5U,EAAG,EAC5Cud,EAAKiH,EAAI5P,EAAI1U,EAAGsd,EAAKgH,EAAI5P,EAAI5U,EAAGqS,EAAImS,EAAIA,EAAInP,EAAG,EAC/C,EAAG,EAAG,EAAG,GAIH3R,IAER,CAEAsa,UAAWhe,EAAGE,EAAGskB,GAWhB,OATA9gB,KAAKuS,IAEJjW,EAAG,EAAG,EAAG,EACT,EAAGE,EAAG,EAAG,EACT,EAAG,EAAGskB,EAAG,EACT,EAAG,EAAG,EAAG,GAIH9gB,IAER,CAEAk3B,UAAW9U,EAAIC,EAAI8U,EAAI7U,EAAI8U,EAAIC,GAW9B,OATAr3B,KAAKuS,IAEJ,EAAG4kB,EAAIC,EAAI,EACXhV,EAAI,EAAGiV,EAAI,EACXhV,EAAIC,EAAI,EAAG,EACX,EAAG,EAAG,EAAG,GAIHtiB,IAER,CAEAs1B,QAASlI,EAAU/H,EAAYjL,GAE9B,MAAMtD,EAAK9W,KAAKiU,SAEV3X,EAAI+oB,EAAWxB,GAAIrnB,EAAI6oB,EAAWvB,GAAIhD,EAAIuE,EAAWtB,GAAIhD,EAAIsE,EAAWrB,GACxEsT,EAAKh7B,EAAIA,EAAGi7B,EAAK/6B,EAAIA,EAAGg7B,EAAK1W,EAAIA,EACjCmB,EAAK3lB,EAAIg7B,EAAIlV,EAAK9lB,EAAIi7B,EAAIlV,EAAK/lB,EAAIk7B,EACnCtV,EAAK1lB,EAAI+6B,EAAIjV,EAAK9lB,EAAIg7B,EAAIrV,EAAKrB,EAAI0W,EACnCC,EAAK1W,EAAIuW,EAAII,EAAK3W,EAAIwW,EAAII,EAAK5W,EAAIyW,EAEnCzd,EAAKK,EAAM9d,EAAG0d,EAAKI,EAAM5d,EAAGyuB,EAAK7Q,EAAM0G,EAsB7C,OApBAhK,EAAI,IAAQ,GAAMoL,EAAKC,IAASpI,EAChCjD,EAAI,IAAQsL,EAAKuV,GAAO5d,EACxBjD,EAAI,IAAQuL,EAAKqV,GAAO3d,EACxBjD,EAAI,GAAM,EAEVA,EAAI,IAAQsL,EAAKuV,GAAO3d,EACxBlD,EAAI,IAAQ,GAAMmL,EAAKE,IAASnI,EAChClD,EAAI,IAAQwL,EAAKmV,GAAOzd,EACxBlD,EAAI,GAAM,EAEVA,EAAI,IAAQuL,EAAKqV,GAAOzM,EACxBnU,EAAI,IAAQwL,EAAKmV,GAAOxM,EACxBnU,EAAI,KAAS,GAAMmL,EAAKC,IAAS+I,EACjCnU,EAAI,IAAO,EAEXA,EAAI,IAAOsW,EAAS9wB,EACpBwa,EAAI,IAAOsW,EAAS5wB,EACpBsa,EAAI,IAAOsW,EAAStM,EACpBhK,EAAI,IAAO,EAEJ9W,IAER,CAEA43B,UAAWxK,EAAU/H,EAAYjL,GAEhC,MAAMtD,EAAK9W,KAAKiU,SAEhB,IAAI8F,EAAKwa,GAAMhiB,IAAKuE,EAAI,GAAKA,EAAI,GAAKA,EAAI,IAAMnW,SAChD,MAAMqZ,EAAKua,GAAMhiB,IAAKuE,EAAI,GAAKA,EAAI,GAAKA,EAAI,IAAMnW,SAC5CsqB,EAAKsJ,GAAMhiB,IAAKuE,EAAI,GAAKA,EAAI,GAAKA,EAAI,KAAOnW,SAGvCX,KAAK6Y,cACN,IAAIkB,GAAOA,GAEtBqT,EAAS9wB,EAAIwa,EAAI,IACjBsW,EAAS5wB,EAAIsa,EAAI,IACjBsW,EAAStM,EAAIhK,EAAI,IAGjB+gB,GAAMzkB,KAAMpT,MAEZ,MAAM83B,EAAQ,EAAI/d,EACZge,EAAQ,EAAI/d,EACZge,EAAQ,EAAI/M,EAoBlB,OAlBA4M,GAAM5jB,SAAU,IAAO6jB,EACvBD,GAAM5jB,SAAU,IAAO6jB,EACvBD,GAAM5jB,SAAU,IAAO6jB,EAEvBD,GAAM5jB,SAAU,IAAO8jB,EACvBF,GAAM5jB,SAAU,IAAO8jB,EACvBF,GAAM5jB,SAAU,IAAO8jB,EAEvBF,GAAM5jB,SAAU,IAAO+jB,EACvBH,GAAM5jB,SAAU,IAAO+jB,EACvBH,GAAM5jB,SAAU,KAAQ+jB,EAExB3S,EAAWW,sBAAuB6R,IAElCzd,EAAM9d,EAAIyd,EACVK,EAAM5d,EAAIwd,EACVI,EAAM0G,EAAImK,EAEHjrB,IAER,CAEAi4B,gBAAiBC,EAAMC,EAAOC,EAAKC,EAAQC,EAAMC,EAAKC,EAAmB5rB,KAExE,MAAMkK,EAAK9W,KAAKiU,SACV3X,EAAI,EAAIg8B,GAASH,EAAQD,GACzB17B,EAAI,EAAI87B,GAASF,EAAMC,GAEvB5vB,GAAM0vB,EAAQD,IAAWC,EAAQD,GACjCxmB,GAAM0mB,EAAMC,IAAaD,EAAMC,GAErC,IAAI1mB,EAAGnJ,EAEP,GAAKgwB,IAAqB5rB,GAEzB+E,IAAQ4mB,EAAMD,IAAWC,EAAMD,GAC/B9vB,GAAQ,EAAI+vB,EAAMD,GAAWC,EAAMD,OAE7B,IAAKE,IAAqB3rB,GAOhC,MAAM,IAAI5G,MAAO,+DAAiEuyB,GALlF7mB,GAAM4mB,GAAQA,EAAMD,GACpB9vB,GAAQ+vB,EAAMD,GAAWC,EAAMD,EAMhC,CAOA,OALAxhB,EAAI,GAAMxa,EAAGwa,EAAI,GAAM,EAAGA,EAAI,GAAMrO,EAAIqO,EAAI,IAAO,EACnDA,EAAI,GAAM,EAAGA,EAAI,GAAMta,EAAGsa,EAAI,GAAMpF,EAAIoF,EAAI,IAAO,EACnDA,EAAI,GAAM,EAAGA,EAAI,GAAM,EAAGA,EAAI,IAAOnF,EAAImF,EAAI,IAAOtO,EACpDsO,EAAI,GAAM,EAAGA,EAAI,GAAM,EAAGA,EAAI,KAAS,EAAGA,EAAI,IAAO,EAE9C9W,IAER,CAEAy4B,iBAAkBP,EAAMC,EAAOC,EAAKC,EAAQC,EAAMC,EAAKC,EAAmB5rB,KAEzE,MAAMkK,EAAK9W,KAAKiU,SACV8M,EAAI,GAAQoX,EAAQD,GACpBlf,EAAI,GAAQof,EAAMC,GAClBK,EAAI,GAAQH,EAAMD,GAElBh8B,GAAM67B,EAAQD,GAASnX,EACvBvkB,GAAM47B,EAAMC,GAAWrf,EAE7B,IAAI8H,EAAG6X,EAEP,GAAKH,IAAqB5rB,GAEzBkU,GAAMyX,EAAMD,GAASI,EACrBC,GAAS,EAAID,MAEP,IAAKF,IAAqB3rB,GAOhC,MAAM,IAAI5G,MAAO,gEAAkEuyB,GALnF1X,EAAIwX,EAAOI,EACXC,GAAS,EAAID,CAMd,CAOA,OALA5hB,EAAI,GAAM,EAAIiK,EAAGjK,EAAI,GAAM,EAAIA,EAAI,GAAM,EAAKA,EAAI,KAASxa,EAC3Dwa,EAAI,GAAM,EAAKA,EAAI,GAAM,EAAIkC,EAAGlC,EAAI,GAAM,EAAKA,EAAI,KAASta,EAC5Dsa,EAAI,GAAM,EAAKA,EAAI,GAAM,EAAIA,EAAI,IAAO6hB,EAAM7hB,EAAI,KAASgK,EAC3DhK,EAAI,GAAM,EAAKA,EAAI,GAAM,EAAIA,EAAI,IAAO,EAAIA,EAAI,IAAO,EAEhD9W,IAER,CAEAyV,OAAQkF,GAEP,MAAM7D,EAAK9W,KAAKiU,SACV+C,EAAK2D,EAAO1G,SAElB,IAAM,IAAI3T,EAAI,EAAGA,EAAI,GAAIA,IAExB,GAAKwW,EAAIxW,KAAQ0W,EAAI1W,GAAM,OAAO,EAInC,OAAO,CAER,CAEAoV,UAAWjI,EAAOkI,EAAS,GAE1B,IAAM,IAAIrV,EAAI,EAAGA,EAAI,GAAIA,IAExBN,KAAKiU,SAAU3T,GAAMmN,EAAOnN,EAAIqV,GAIjC,OAAO3V,IAER,CAEA4V,QAASnI,EAAQ,GAAIkI,EAAS,GAE7B,MAAMmB,EAAK9W,KAAKiU,SAsBhB,OApBAxG,EAAOkI,GAAWmB,EAAI,GACtBrJ,EAAOkI,EAAS,GAAMmB,EAAI,GAC1BrJ,EAAOkI,EAAS,GAAMmB,EAAI,GAC1BrJ,EAAOkI,EAAS,GAAMmB,EAAI,GAE1BrJ,EAAOkI,EAAS,GAAMmB,EAAI,GAC1BrJ,EAAOkI,EAAS,GAAMmB,EAAI,GAC1BrJ,EAAOkI,EAAS,GAAMmB,EAAI,GAC1BrJ,EAAOkI,EAAS,GAAMmB,EAAI,GAE1BrJ,EAAOkI,EAAS,GAAMmB,EAAI,GAC1BrJ,EAAOkI,EAAS,GAAMmB,EAAI,GAC1BrJ,EAAOkI,EAAS,IAAOmB,EAAI,IAC3BrJ,EAAOkI,EAAS,IAAOmB,EAAI,IAE3BrJ,EAAOkI,EAAS,IAAOmB,EAAI,IAC3BrJ,EAAOkI,EAAS,IAAOmB,EAAI,IAC3BrJ,EAAOkI,EAAS,IAAOmB,EAAI,IAC3BrJ,EAAOkI,EAAS,IAAOmB,EAAI,IAEpBrJ,CAER,EAID,MAAM8mB,GAAsB,IAAI,GAC1BsD,GAAsB,IAAIpE,GAC1B8B,GAAsB,IAAI,GAAS,EAAG,EAAG,GACzCC,GAAqB,IAAI,GAAS,EAAG,EAAG,GACxC3R,GAAmB,IAAI,GACvBC,GAAmB,IAAI,GACvBC,GAAmB,IAAI,GAEvB6U,GAAwB,IAAInF,GAC5BoF,GAA8B,IAAIlV,GAExC,MAAMmV,GAELv2B,YAAajG,EAAI,EAAGE,EAAI,EAAGskB,EAAI,EAAGlP,EAAQknB,GAAMC,eAE/C/4B,KAAKg5B,SAAU,EAEfh5B,KAAK6jB,GAAKvnB,EACV0D,KAAK8jB,GAAKtnB,EACVwD,KAAK+jB,GAAKjD,EACV9gB,KAAKwlB,OAAS5T,CAEf,CAEItV,QAEH,OAAO0D,KAAK6jB,EAEb,CAEIvnB,MAAGc,GAEN4C,KAAK6jB,GAAKzmB,EACV4C,KAAKolB,mBAEN,CAEI5oB,QAEH,OAAOwD,KAAK8jB,EAEb,CAEItnB,MAAGY,GAEN4C,KAAK8jB,GAAK1mB,EACV4C,KAAKolB,mBAEN,CAEItE,QAEH,OAAO9gB,KAAK+jB,EAEb,CAEIjD,MAAG1jB,GAEN4C,KAAK+jB,GAAK3mB,EACV4C,KAAKolB,mBAEN,CAEIxT,YAEH,OAAO5R,KAAKwlB,MAEb,CAEI5T,UAAOxU,GAEV4C,KAAKwlB,OAASpoB,EACd4C,KAAKolB,mBAEN,CAEA7S,IAAKjW,EAAGE,EAAGskB,EAAGlP,EAAQ5R,KAAKwlB,QAS1B,OAPAxlB,KAAK6jB,GAAKvnB,EACV0D,KAAK8jB,GAAKtnB,EACVwD,KAAK+jB,GAAKjD,EACV9gB,KAAKwlB,OAAS5T,EAEd5R,KAAKolB,oBAEEplB,IAER,CAEAmT,QAEC,OAAO,IAAInT,KAAKuC,YAAavC,KAAK6jB,GAAI7jB,KAAK8jB,GAAI9jB,KAAK+jB,GAAI/jB,KAAKwlB,OAE9D,CAEApS,KAAMmS,GASL,OAPAvlB,KAAK6jB,GAAK0B,EAAM1B,GAChB7jB,KAAK8jB,GAAKyB,EAAMzB,GAChB9jB,KAAK+jB,GAAKwB,EAAMxB,GAChB/jB,KAAKwlB,OAASD,EAAMC,OAEpBxlB,KAAKolB,oBAEEplB,IAER,CAEAgmB,sBAAuBvX,EAAGmD,EAAQ5R,KAAKwlB,OAAQne,GAAS,GAIvD,MAAMyP,EAAKrI,EAAEwF,SACPuN,EAAM1K,EAAI,GAAK2K,EAAM3K,EAAI,GAAK4K,EAAM5K,EAAI,GACxC6K,EAAM7K,EAAI,GAAK8K,EAAM9K,EAAI,GAAK+K,EAAM/K,EAAI,GACxCgL,EAAMhL,EAAI,GAAKiL,EAAMjL,EAAI,GAAKkL,EAAMlL,EAAI,IAE9C,OAASlF,GAER,IAAK,MAEJ5R,KAAK8jB,GAAK9lB,KAAKi7B,KAAM3qB,GAAOoT,GAAO,EAAG,IAEjC1jB,KAAKwS,IAAKkR,GAAQ,UAEtB1hB,KAAK6jB,GAAK7lB,KAAKG,OAAS0jB,EAAKG,GAC7BhiB,KAAK+jB,GAAK/lB,KAAKG,OAASsjB,EAAKD,KAI7BxhB,KAAK6jB,GAAK7lB,KAAKG,MAAO4jB,EAAKH,GAC3B5hB,KAAK+jB,GAAK,GAIX,MAED,IAAK,MAEJ/jB,KAAK6jB,GAAK7lB,KAAKi7B,MAAQ3qB,GAAOuT,GAAO,EAAG,IAEnC7jB,KAAKwS,IAAKqR,GAAQ,UAEtB7hB,KAAK8jB,GAAK9lB,KAAKG,MAAOujB,EAAKM,GAC3BhiB,KAAK+jB,GAAK/lB,KAAKG,MAAOwjB,EAAKC,KAI3B5hB,KAAK8jB,GAAK9lB,KAAKG,OAAS2jB,EAAKN,GAC7BxhB,KAAK+jB,GAAK,GAIX,MAED,IAAK,MAEJ/jB,KAAK6jB,GAAK7lB,KAAKi7B,KAAM3qB,GAAOyT,GAAO,EAAG,IAEjC/jB,KAAKwS,IAAKuR,GAAQ,UAEtB/hB,KAAK8jB,GAAK9lB,KAAKG,OAAS2jB,EAAKE,GAC7BhiB,KAAK+jB,GAAK/lB,KAAKG,OAASsjB,EAAKG,KAI7B5hB,KAAK8jB,GAAK,EACV9jB,KAAK+jB,GAAK/lB,KAAKG,MAAOwjB,EAAKH,IAI5B,MAED,IAAK,MAEJxhB,KAAK8jB,GAAK9lB,KAAKi7B,MAAQ3qB,GAAOwT,GAAO,EAAG,IAEnC9jB,KAAKwS,IAAKsR,GAAQ,UAEtB9hB,KAAK6jB,GAAK7lB,KAAKG,MAAO4jB,EAAKC,GAC3BhiB,KAAK+jB,GAAK/lB,KAAKG,MAAOwjB,EAAKH,KAI3BxhB,KAAK6jB,GAAK,EACV7jB,KAAK+jB,GAAK/lB,KAAKG,OAASsjB,EAAKG,IAI9B,MAED,IAAK,MAEJ5hB,KAAK+jB,GAAK/lB,KAAKi7B,KAAM3qB,GAAOqT,GAAO,EAAG,IAEjC3jB,KAAKwS,IAAKmR,GAAQ,UAEtB3hB,KAAK6jB,GAAK7lB,KAAKG,OAAS0jB,EAAKD,GAC7B5hB,KAAK8jB,GAAK9lB,KAAKG,OAAS2jB,EAAKN,KAI7BxhB,KAAK6jB,GAAK,EACV7jB,KAAK8jB,GAAK9lB,KAAKG,MAAOujB,EAAKM,IAI5B,MAED,IAAK,MAEJhiB,KAAK+jB,GAAK/lB,KAAKi7B,MAAQ3qB,GAAOmT,GAAO,EAAG,IAEnCzjB,KAAKwS,IAAKiR,GAAQ,UAEtBzhB,KAAK6jB,GAAK7lB,KAAKG,MAAO4jB,EAAKH,GAC3B5hB,KAAK8jB,GAAK9lB,KAAKG,MAAOujB,EAAKF,KAI3BxhB,KAAK6jB,GAAK7lB,KAAKG,OAAS0jB,EAAKG,GAC7BhiB,KAAK8jB,GAAK,GAIX,MAED,QAECxlB,QAAQkU,KAAM,uEAAyEZ,GAQzF,OAJA5R,KAAKwlB,OAAS5T,GAEE,IAAXvK,GAAkBrH,KAAKolB,oBAErBplB,IAER,CAEAk5B,kBAAmBznB,EAAGG,EAAOvK,GAI5B,OAFAuxB,GAAQvD,2BAA4B5jB,GAE7BzR,KAAKgmB,sBAAuB4S,GAAShnB,EAAOvK,EAEpD,CAEA8xB,eAAgB9lB,EAAGzB,EAAQ5R,KAAKwlB,QAE/B,OAAOxlB,KAAKuS,IAAKc,EAAE/W,EAAG+W,EAAE7W,EAAG6W,EAAEyN,EAAGlP,EAEjC,CAEAwnB,QAASC,GAMR,OAFAR,GAAcvT,aAActlB,MAErBA,KAAKk5B,kBAAmBL,GAAeQ,EAE/C,CAEA5jB,OAAQ8P,GAEP,OAASA,EAAM1B,KAAO7jB,KAAK6jB,IAAU0B,EAAMzB,KAAO9jB,KAAK8jB,IAAUyB,EAAMxB,KAAO/jB,KAAK+jB,IAAUwB,EAAMC,SAAWxlB,KAAKwlB,MAEpH,CAEA9P,UAAWjI,GASV,OAPAzN,KAAK6jB,GAAKpW,EAAO,GACjBzN,KAAK8jB,GAAKrW,EAAO,GACjBzN,KAAK+jB,GAAKtW,EAAO,QACGtQ,IAAfsQ,EAAO,KAAoBzN,KAAKwlB,OAAS/X,EAAO,IAErDzN,KAAKolB,oBAEEplB,IAER,CAEA4V,QAASnI,EAAQ,GAAIkI,EAAS,GAO7B,OALAlI,EAAOkI,GAAW3V,KAAK6jB,GACvBpW,EAAOkI,EAAS,GAAM3V,KAAK8jB,GAC3BrW,EAAOkI,EAAS,GAAM3V,KAAK+jB,GAC3BtW,EAAOkI,EAAS,GAAM3V,KAAKwlB,OAEpB/X,CAER,CAEAua,UAAWC,GAIV,OAFAjoB,KAAKolB,kBAAoB6C,EAElBjoB,IAER,CAEAolB,oBAAqB,CAErB,EAAG/jB,OAAOC,kBAEHtB,KAAK6jB,SACL7jB,KAAK8jB,SACL9jB,KAAK+jB,SACL/jB,KAAKwlB,MAEZ,EAIDsT,GAAMC,cAAgB,MAEtB,MAAMO,GAEL/2B,cAECvC,KAAKu5B,KAAO,CAEb,CAEAhnB,IAAKgN,GAEJvf,KAAKu5B,MAAS,GAAKha,EAAU,KAAQ,CAEtC,CAEAia,OAAQja,GAEPvf,KAAKu5B,MAAQ,GAAKha,EAAU,CAE7B,CAEAka,YAECz5B,KAAKu5B,MAAO,CAEb,CAEAG,OAAQna,GAEPvf,KAAKu5B,MAAQ,GAAKha,EAAU,CAE7B,CAEAoa,QAASpa,GAERvf,KAAKu5B,QAAY,GAAKha,EAAU,EAEjC,CAEAqa,aAEC55B,KAAKu5B,KAAO,CAEb,CAEA72B,KAAMm3B,GAEL,OAAuC,IAA9B75B,KAAKu5B,KAAOM,EAAON,KAE7B,CAEAO,UAAWva,GAEV,OAAgD,IAAvCvf,KAAKu5B,MAAS,GAAKha,EAAU,GAEvC,EAID,IAAIwa,GAAc,EAElB,MAAMC,GAAsB,IAAI,GAC1BC,GAAoB,IAAItW,GACxBuW,GAAsB,IAAIzG,GAC1B0G,GAAwB,IAAI,GAE5BC,GAA4B,IAAI,GAChCC,GAAyB,IAAI,GAC7BC,GAA8B,IAAI3W,GAElC4W,GAAuB,IAAI,GAAS,EAAG,EAAG,GAC1CC,GAAuB,IAAI,GAAS,EAAG,EAAG,GAC1CC,GAAuB,IAAI,GAAS,EAAG,EAAG,GAE1CC,GAAc,CAAE3tB,KAAM,SACtB4tB,GAAgB,CAAE5tB,KAAM,WAE9B,MAAM6tB,WAAiB9tB,GAEtBvK,cAEC6c,QAEApf,KAAK66B,YAAa,EAElBz4B,OAAOuG,eAAgB3I,KAAM,KAAM,CAAE5C,MAAO28B,OAE5C/5B,KAAK4d,KAAO7P,KAEZ/N,KAAKwC,KAAO,GACZxC,KAAK+M,KAAO,WAEZ/M,KAAK86B,OAAS,KACd96B,KAAKqtB,SAAW,GAEhBrtB,KAAK01B,GAAKkF,GAASG,WAAW5nB,QAE9B,MAAMia,EAAW,IAAI,GACfnT,EAAW,IAAI6e,GACfzT,EAAa,IAAI1B,GACjBvJ,EAAQ,IAAI,GAAS,EAAG,EAAG,GAcjCH,EAAS+N,WAZT,WAEC3C,EAAWC,aAAcrL,GAAU,EAEpC,IASAoL,EAAW2C,WAPX,WAEC/N,EAASif,kBAAmB7T,OAAYloB,GAAW,EAEpD,IAKAiF,OAAO44B,iBAAkBh7B,KAAM,CAC9BotB,SAAU,CACT6N,cAAc,EACdryB,YAAY,EACZxL,MAAOgwB,GAERnT,SAAU,CACTghB,cAAc,EACdryB,YAAY,EACZxL,MAAO6c,GAERoL,WAAY,CACX4V,cAAc,EACdryB,YAAY,EACZxL,MAAOioB,GAERjL,MAAO,CACN6gB,cAAc,EACdryB,YAAY,EACZxL,MAAOgd,GAER8gB,gBAAiB,CAChB99B,MAAO,IAAIq2B,IAEZ0H,aAAc,CACb/9B,MAAO,IAAI+Y,MAIbnW,KAAK2a,OAAS,IAAI8Y,GAClBzzB,KAAKupB,YAAc,IAAIkK,GAEvBzzB,KAAK0f,iBAAmBkb,GAASQ,2BACjCp7B,KAAKq7B,wBAAyB,EAE9Br7B,KAAKs7B,sBAAwBV,GAASW,iCAEtCv7B,KAAK65B,OAAS,IAAIP,GAClBt5B,KAAKw7B,SAAU,EAEfx7B,KAAKy7B,YAAa,EAClBz7B,KAAK07B,eAAgB,EAErB17B,KAAK27B,eAAgB,EACrB37B,KAAK47B,YAAc,EAEnB57B,KAAK67B,WAAa,GAElB77B,KAAK+f,SAAW,CAAC,CAElB,CAEA+b,iBAA4E,CAE5EC,gBAA2E,CAE3E5a,aAAcxG,GAER3a,KAAK0f,kBAAmB1f,KAAKmgB,eAElCngB,KAAK2a,OAAOnD,YAAamD,GAEzB3a,KAAK2a,OAAOid,UAAW53B,KAAKotB,SAAUptB,KAAKqlB,WAAYrlB,KAAKoa,MAE7D,CAEAiO,gBAAiB5W,GAIhB,OAFAzR,KAAKqlB,WAAW7N,YAAa/F,GAEtBzR,IAER,CAEAg8B,yBAA0BlW,EAAMlR,GAI/B5U,KAAKqlB,WAAWQ,iBAAkBC,EAAMlR,EAEzC,CAEAqnB,qBAAsB1W,GAErBvlB,KAAKqlB,WAAWC,aAAcC,GAAO,EAEtC,CAEA2W,sBAAuBztB,GAItBzO,KAAKqlB,WAAWW,sBAAuBvX,EAExC,CAEA0tB,0BAA2B1qB,GAI1BzR,KAAKqlB,WAAWjS,KAAM3B,EAEvB,CAEA2qB,aAActW,EAAMlR,GASnB,OAJAqlB,GAAIpU,iBAAkBC,EAAMlR,GAE5B5U,KAAKqlB,WAAWzR,SAAUqmB,IAEnBj6B,IAER,CAEAq8B,kBAAmBvW,EAAMlR,GAUxB,OAJAqlB,GAAIpU,iBAAkBC,EAAMlR,GAE5B5U,KAAKqlB,WAAW7N,YAAayiB,IAEtBj6B,IAER,CAEAs8B,QAAS1nB,GAER,OAAO5U,KAAKo8B,aAAc7B,GAAQ3lB,EAEnC,CAEA2nB,QAAS3nB,GAER,OAAO5U,KAAKo8B,aAAc5B,GAAQ5lB,EAEnC,CAEA4nB,QAAS5nB,GAER,OAAO5U,KAAKo8B,aAAc3B,GAAQ7lB,EAEnC,CAEA6nB,gBAAiB3W,EAAM4W,GAStB,OAJA1C,GAAM5mB,KAAM0S,GAAOuC,gBAAiBroB,KAAKqlB,YAEzCrlB,KAAKotB,SAASpwB,IAAKg9B,GAAMnmB,eAAgB6oB,IAElC18B,IAER,CAEA28B,WAAYD,GAEX,OAAO18B,KAAKy8B,gBAAiBlC,GAAQmC,EAEtC,CAEAE,WAAYF,GAEX,OAAO18B,KAAKy8B,gBAAiBjC,GAAQkC,EAEtC,CAEAG,WAAYH,GAEX,OAAO18B,KAAKy8B,gBAAiBhC,GAAQiC,EAEtC,CAEAI,aAAclQ,GAIb,OAFA5sB,KAAK8sB,mBAAmB,GAAM,GAEvBF,EAAOzL,aAAcnhB,KAAKupB,YAElC,CAEAwT,aAAcnQ,GAIb,OAFA5sB,KAAK8sB,mBAAmB,GAAM,GAEvBF,EAAOzL,aAAc+Y,GAAM9mB,KAAMpT,KAAKupB,aAActQ,SAE5D,CAEA8X,OAAQz0B,EAAGE,EAAGskB,GAIRxkB,EAAE4rB,UAENiS,GAAQ/mB,KAAM9W,GAId69B,GAAQ5nB,IAAKjW,EAAGE,EAAGskB,GAIpB,MAAMga,EAAS96B,KAAK86B,OAEpB96B,KAAK8sB,mBAAmB,GAAM,GAE9BsN,GAAYtP,sBAAuB9qB,KAAKupB,aAEnCvpB,KAAKg9B,UAAYh9B,KAAKi9B,QAE1B/C,GAAMnJ,OAAQqJ,GAAaD,GAASn6B,KAAK01B,IAIzCwE,GAAMnJ,OAAQoJ,GAASC,GAAap6B,KAAK01B,IAI1C11B,KAAKqlB,WAAWW,sBAAuBkU,IAElCY,IAEJZ,GAAM7F,gBAAiByG,EAAOvR,aAC9B0Q,GAAIjU,sBAAuBkU,IAC3Bl6B,KAAKqlB,WAAW7N,YAAayiB,GAAIhhB,UAInC,CAEAjc,IAAKmvB,GAEJ,GAAK+Q,UAAUv8B,OAAS,EAAI,CAE3B,IAAM,IAAIL,EAAI,EAAGA,EAAI48B,UAAUv8B,OAAQL,IAEtCN,KAAKhD,IAAKkgC,UAAW58B,IAItB,OAAON,IAER,CAEA,OAAKmsB,IAAWnsB,MAEf1B,QAAQ6+B,MAAO,kEAAoEhR,GAC5EnsB,OAIHmsB,GAAUA,EAAO0O,YAEE,OAAlB1O,EAAO2O,QAEX3O,EAAO2O,OAAO59B,OAAQivB,GAIvBA,EAAO2O,OAAS96B,KAChBA,KAAKqtB,SAAS5tB,KAAM0sB,GAEpBA,EAAO5e,cAAemtB,KAItBp8B,QAAQ6+B,MAAO,gEAAiEhR,GAI1EnsB,KAER,CAEA9C,OAAQivB,GAEP,GAAK+Q,UAAUv8B,OAAS,EAAI,CAE3B,IAAM,IAAIL,EAAI,EAAGA,EAAI48B,UAAUv8B,OAAQL,IAEtCN,KAAK9C,OAAQggC,UAAW58B,IAIzB,OAAON,IAER,CAEA,MAAMjC,EAAQiC,KAAKqtB,SAASlgB,QAASgf,GAWrC,OATiB,IAAZpuB,IAEJouB,EAAO2O,OAAS,KAChB96B,KAAKqtB,SAASplB,OAAQlK,EAAO,GAE7BouB,EAAO5e,cAAeotB,KAIhB36B,IAER,CAEAo9B,mBAEC,MAAMtC,EAAS96B,KAAK86B,OAQpB,OANgB,OAAXA,GAEJA,EAAO59B,OAAQ8C,MAITA,IAER,CAEAq9B,QAEC,IAAM,IAAI/8B,EAAI,EAAGA,EAAIN,KAAKqtB,SAAS1sB,OAAQL,IAAO,CAEjD,MAAM6rB,EAASnsB,KAAKqtB,SAAU/sB,GAE9B6rB,EAAO2O,OAAS,KAEhB3O,EAAO5e,cAAeotB,GAEvB,CAIA,OAFA36B,KAAKqtB,SAAS1sB,OAAS,EAEhBX,IAGR,CAEAs9B,OAAQnR,GAwBP,OAlBAnsB,KAAK8sB,mBAAmB,GAAM,GAE9BoN,GAAM9mB,KAAMpT,KAAKupB,aAActQ,SAER,OAAlBkT,EAAO2O,SAEX3O,EAAO2O,OAAOhO,mBAAmB,GAAM,GAEvCoN,GAAMtmB,SAAUuY,EAAO2O,OAAOvR,cAI/B4C,EAAOhL,aAAc+Y,IAErBl6B,KAAKhD,IAAKmvB,GAEVA,EAAOW,mBAAmB,GAAO,GAE1B9sB,IAER,CAEAu9B,cAAe59B,GAEd,OAAOK,KAAKw9B,oBAAqB,KAAM79B,EAExC,CAEA89B,gBAAiBj7B,GAEhB,OAAOxC,KAAKw9B,oBAAqB,OAAQh7B,EAE1C,CAEAg7B,oBAAqBh7B,EAAMpF,GAE1B,GAAK4C,KAAMwC,KAAWpF,EAAQ,OAAO4C,KAErC,IAAM,IAAIM,EAAI,EAAGoN,EAAI1N,KAAKqtB,SAAS1sB,OAAQL,EAAIoN,EAAGpN,IAAO,CAExD,MACM6rB,EADQnsB,KAAKqtB,SAAU/sB,GACRk9B,oBAAqBh7B,EAAMpF,GAEhD,QAAgBD,IAAXgvB,EAEJ,OAAOA,CAIT,CAID,CAEAuR,qBAAsBl7B,EAAMpF,GAE3B,IAAIwH,EAAS,GAER5E,KAAMwC,KAAWpF,GAAQwH,EAAOnF,KAAMO,MAE3C,IAAM,IAAIM,EAAI,EAAGoN,EAAI1N,KAAKqtB,SAAS1sB,OAAQL,EAAIoN,EAAGpN,IAAO,CAExD,MAAMq9B,EAAc39B,KAAKqtB,SAAU/sB,GAAIo9B,qBAAsBl7B,EAAMpF,GAE9DugC,EAAYh9B,OAAS,IAEzBiE,EAASA,EAAOxE,OAAQu9B,GAI1B,CAEA,OAAO/4B,CAER,CAEAg5B,iBAAkBx5B,GAIjB,OAFApE,KAAK8sB,mBAAmB,GAAM,GAEvB1oB,EAAO0mB,sBAAuB9qB,KAAKupB,YAE3C,CAEAsU,mBAAoBz5B,GAMnB,OAJApE,KAAK8sB,mBAAmB,GAAM,GAE9B9sB,KAAKupB,YAAYqO,UAAWwC,GAAah2B,EAAQi2B,IAE1Cj2B,CAER,CAEA05B,cAAe15B,GAMd,OAJApE,KAAK8sB,mBAAmB,GAAM,GAE9B9sB,KAAKupB,YAAYqO,UAAWwC,GAAaE,GAAel2B,GAEjDA,CAER,CAEA25B,kBAAmB35B,GAElBpE,KAAK8sB,mBAAmB,GAAM,GAE9B,MAAM5wB,EAAI8D,KAAKupB,YAAYtV,SAE3B,OAAO7P,EAAOmO,IAAKrW,EAAG,GAAKA,EAAG,GAAKA,EAAG,KAAOwT,WAE9C,CAEAsuB,UAAwC,CAExCC,SAAUhW,GAETA,EAAUjoB,MAEV,MAAMqtB,EAAWrtB,KAAKqtB,SAEtB,IAAM,IAAI/sB,EAAI,EAAGoN,EAAI2f,EAAS1sB,OAAQL,EAAIoN,EAAGpN,IAE5C+sB,EAAU/sB,GAAI29B,SAAUhW,EAI1B,CAEAiW,gBAAiBjW,GAEhB,IAAsB,IAAjBjoB,KAAKw7B,QAAoB,OAE9BvT,EAAUjoB,MAEV,MAAMqtB,EAAWrtB,KAAKqtB,SAEtB,IAAM,IAAI/sB,EAAI,EAAGoN,EAAI2f,EAAS1sB,OAAQL,EAAIoN,EAAGpN,IAE5C+sB,EAAU/sB,GAAI49B,gBAAiBjW,EAIjC,CAEAkW,kBAAmBlW,GAElB,MAAM6S,EAAS96B,KAAK86B,OAEJ,OAAXA,IAEJ7S,EAAU6S,GAEVA,EAAOqD,kBAAmBlW,GAI5B,CAEA9H,eAECngB,KAAK2a,OAAO2a,QAASt1B,KAAKotB,SAAUptB,KAAKqlB,WAAYrlB,KAAKoa,OAE1Dpa,KAAKq7B,wBAAyB,CAE/B,CAEA+C,kBAAmBC,GAEbr+B,KAAK0f,kBAAmB1f,KAAKmgB,gBAE7BngB,KAAKq7B,wBAA0BgD,KAEd,OAAhBr+B,KAAK86B,OAET96B,KAAKupB,YAAYnW,KAAMpT,KAAK2a,QAI5B3a,KAAKupB,YAAYhS,iBAAkBvX,KAAK86B,OAAOvR,YAAavpB,KAAK2a,QAIlE3a,KAAKq7B,wBAAyB,EAE9BgD,GAAQ,GAMT,MAAMhR,EAAWrtB,KAAKqtB,SAEtB,IAAM,IAAI/sB,EAAI,EAAGoN,EAAI2f,EAAS1sB,OAAQL,EAAIoN,EAAGpN,IAAO,CAEnD,MAAMg+B,EAAQjR,EAAU/sB,IAEa,IAAhCg+B,EAAMhD,wBAA4C,IAAV+C,GAE5CC,EAAMF,kBAAmBC,EAI3B,CAED,CAEAvR,kBAAmByR,EAAeC,GAEjC,MAAM1D,EAAS96B,KAAK86B,OAsBpB,IApBuB,IAAlByD,GAAqC,OAAXzD,IAAoD,IAAjCA,EAAOQ,uBAExDR,EAAOhO,mBAAmB,GAAM,GAI5B9sB,KAAK0f,kBAAmB1f,KAAKmgB,eAEb,OAAhBngB,KAAK86B,OAET96B,KAAKupB,YAAYnW,KAAMpT,KAAK2a,QAI5B3a,KAAKupB,YAAYhS,iBAAkBvX,KAAK86B,OAAOvR,YAAavpB,KAAK2a,SAM1C,IAAnB6jB,EAA0B,CAE9B,MAAMnR,EAAWrtB,KAAKqtB,SAEtB,IAAM,IAAI/sB,EAAI,EAAGoN,EAAI2f,EAAS1sB,OAAQL,EAAIoN,EAAGpN,IAAO,CAEnD,MAAMg+B,EAAQjR,EAAU/sB,IAEa,IAAhCg+B,EAAMhD,uBAEVgD,EAAMxR,mBAAmB,GAAO,EAIlC,CAED,CAED,CAEA/O,OAAQC,GAGP,MAAMC,OAA0B9gB,IAAT6gB,GAAsC,iBAATA,EAE9CG,EAAS,CAAC,EAKXF,IAGJD,EAAO,CACNygB,WAAY,CAAC,EACbC,UAAW,CAAC,EACZre,SAAU,CAAC,EACXnC,OAAQ,CAAC,EACTygB,OAAQ,CAAC,EACTC,UAAW,CAAC,EACZ/C,WAAY,CAAC,EACbgD,MAAO,CAAC,GAGT1gB,EAAOmC,SAAW,CACjBzC,QAAS,IACT9Q,KAAM,SACNwT,UAAW,oBAOb,MAAM4L,EAAS,CAAC,EAgChB,SAAS2S,EAAWC,EAASC,GAQ5B,YANiC7hC,IAA5B4hC,EAASC,EAAQphB,QAErBmhB,EAASC,EAAQphB,MAASohB,EAAQjhB,OAAQC,IAIpCghB,EAAQphB,IAEhB,CAEA,GA1CAuO,EAAOvO,KAAO5d,KAAK4d,KACnBuO,EAAOpf,KAAO/M,KAAK+M,KAEA,KAAd/M,KAAKwC,OAAc2pB,EAAO3pB,KAAOxC,KAAKwC,OAClB,IAApBxC,KAAKy7B,aAAsBtP,EAAOsP,YAAa,IACxB,IAAvBz7B,KAAK07B,gBAAyBvP,EAAOuP,eAAgB,IACpC,IAAjB17B,KAAKw7B,UAAoBrP,EAAOqP,SAAU,IACnB,IAAvBx7B,KAAK27B,gBAA0BxP,EAAOwP,eAAgB,GACjC,IAArB37B,KAAK47B,cAAoBzP,EAAOyP,YAAc57B,KAAK47B,aACnDx5B,OAAOyD,KAAM7F,KAAK+f,UAAWpf,OAAS,IAAIwrB,EAAOpM,SAAW/f,KAAK+f,UAEtEoM,EAAO0N,OAAS75B,KAAK65B,OAAON,KAC5BpN,EAAOxR,OAAS3a,KAAK2a,OAAO/E,UAC5BuW,EAAOuJ,GAAK11B,KAAK01B,GAAG9f,WAEW,IAA1B5V,KAAK0f,mBAA6ByM,EAAOzM,kBAAmB,GAI5D1f,KAAKi/B,kBAET9S,EAAOpf,KAAO,gBACdof,EAAOlnB,MAAQjF,KAAKiF,MACpBknB,EAAO+S,eAAiBl/B,KAAKk/B,eAAenhB,SAChB,OAAvB/d,KAAKm/B,gBAAyBhT,EAAOgT,cAAgBn/B,KAAKm/B,cAAcphB,WAkBzE/d,KAAKo/B,QAEJp/B,KAAKq/B,aAEJr/B,KAAKq/B,WAAWC,QAEpBnT,EAAOkT,WAAar/B,KAAKq/B,WAAWthB,SAEzB/d,KAAKq/B,WAAWhgB,YAE3B8M,EAAOkT,WAAar/B,KAAKq/B,WAAWthB,OAAQC,GAAOJ,OAMhD5d,KAAKu/B,aAAev/B,KAAKu/B,YAAYlgB,YAAwD,IAA3Crf,KAAKu/B,YAAYtf,wBAEvEkM,EAAOoT,YAAcv/B,KAAKu/B,YAAYxhB,OAAQC,GAAOJ,WAIhD,GAAK5d,KAAKw/B,QAAUx/B,KAAKy/B,QAAUz/B,KAAK0/B,SAAW,CAEzDvT,EAAOgB,SAAW2R,EAAW9gB,EAAKygB,WAAYz+B,KAAKmtB,UAEnD,MAAMwS,EAAa3/B,KAAKmtB,SAASwS,WAEjC,QAAoBxiC,IAAfwiC,QAAkDxiC,IAAtBwiC,EAAWhB,OAAuB,CAElE,MAAMA,EAASgB,EAAWhB,OAE1B,GAAK19B,MAAME,QAASw9B,GAEnB,IAAM,IAAIr+B,EAAI,EAAGoN,EAAIixB,EAAOh+B,OAAQL,EAAIoN,EAAGpN,IAAO,CAEjD,MAAMs/B,EAAQjB,EAAQr+B,GAEtBw+B,EAAW9gB,EAAK2gB,OAAQiB,EAEzB,MAIAd,EAAW9gB,EAAK2gB,OAAQA,EAI1B,CAED,CAiBA,GAfK3+B,KAAK6/B,gBAET1T,EAAO2T,SAAW9/B,KAAK8/B,SACvB3T,EAAO4T,WAAa//B,KAAK+/B,WAAWnqB,eAEbzY,IAAlB6C,KAAKggC,WAETlB,EAAW9gB,EAAK4gB,UAAW5+B,KAAKggC,UAEhC7T,EAAO6T,SAAWhgC,KAAKggC,SAASpiB,YAMXzgB,IAAlB6C,KAAKigC,SAET,GAAKh/B,MAAME,QAASnB,KAAKigC,UAAa,CAErC,MAAMC,EAAQ,GAEd,IAAM,IAAI5/B,EAAI,EAAGoN,EAAI1N,KAAKigC,SAASt/B,OAAQL,EAAIoN,EAAGpN,IAEjD4/B,EAAMzgC,KAAMq/B,EAAW9gB,EAAK0gB,UAAW1+B,KAAKigC,SAAU3/B,KAIvD6rB,EAAO8T,SAAWC,CAEnB,MAEC/T,EAAO8T,SAAWnB,EAAW9gB,EAAK0gB,UAAW1+B,KAAKigC,UAQpD,GAAKjgC,KAAKqtB,SAAS1sB,OAAS,EAAI,CAE/BwrB,EAAOkB,SAAW,GAElB,IAAM,IAAI/sB,EAAI,EAAGA,EAAIN,KAAKqtB,SAAS1sB,OAAQL,IAE1C6rB,EAAOkB,SAAS5tB,KAAMO,KAAKqtB,SAAU/sB,GAAIyd,OAAQC,GAAOmO,OAI1D,CAIA,GAAKnsB,KAAK67B,WAAWl7B,OAAS,EAAI,CAEjCwrB,EAAO0P,WAAa,GAEpB,IAAM,IAAIv7B,EAAI,EAAGA,EAAIN,KAAK67B,WAAWl7B,OAAQL,IAAO,CAEnD,MAAM6/B,EAAYngC,KAAK67B,WAAYv7B,GAEnC6rB,EAAO0P,WAAWp8B,KAAMq/B,EAAW9gB,EAAK6d,WAAYsE,GAErD,CAED,CAEA,GAAKliB,EAAe,CAEnB,MAAMwgB,EAAa2B,EAAkBpiB,EAAKygB,YACpCC,EAAY0B,EAAkBpiB,EAAK0gB,WACnCre,EAAW+f,EAAkBpiB,EAAKqC,UAClCnC,EAASkiB,EAAkBpiB,EAAKE,QAChCygB,EAASyB,EAAkBpiB,EAAK2gB,QAChCC,EAAYwB,EAAkBpiB,EAAK4gB,WACnC/C,EAAauE,EAAkBpiB,EAAK6d,YACpCgD,EAAQuB,EAAkBpiB,EAAK6gB,OAEhCJ,EAAW99B,OAAS,IAAIwd,EAAOsgB,WAAaA,GAC5CC,EAAU/9B,OAAS,IAAIwd,EAAOugB,UAAYA,GAC1Cre,EAAS1f,OAAS,IAAIwd,EAAOkC,SAAWA,GACxCnC,EAAOvd,OAAS,IAAIwd,EAAOD,OAASA,GACpCygB,EAAOh+B,OAAS,IAAIwd,EAAOwgB,OAASA,GACpCC,EAAUj+B,OAAS,IAAIwd,EAAOygB,UAAYA,GAC1C/C,EAAWl7B,OAAS,IAAIwd,EAAO0d,WAAaA,GAC5CgD,EAAMl+B,OAAS,IAAIwd,EAAO0gB,MAAQA,EAExC,CAIA,OAFA1gB,EAAOgO,OAASA,EAEThO,EAKP,SAASiiB,EAAkBC,GAE1B,MAAMC,EAAS,GACf,IAAM,MAAMv6B,KAAOs6B,EAAQ,CAE1B,MAAMh9B,EAAOg9B,EAAOt6B,UACb1C,EAAKid,SACZggB,EAAO7gC,KAAM4D,EAEd,CAEA,OAAOi9B,CAER,CAED,CAEAntB,MAAOotB,GAEN,OAAO,IAAIvgC,KAAKuC,aAAc6Q,KAAMpT,KAAMugC,EAE3C,CAEAntB,KAAM3P,EAAQ88B,GAAY,GAgCzB,GA9BAvgC,KAAKwC,KAAOiB,EAAOjB,KAEnBxC,KAAK01B,GAAGtiB,KAAM3P,EAAOiyB,IAErB11B,KAAKotB,SAASha,KAAM3P,EAAO2pB,UAC3BptB,KAAKia,SAASrI,MAAQnO,EAAOwW,SAASrI,MACtC5R,KAAKqlB,WAAWjS,KAAM3P,EAAO4hB,YAC7BrlB,KAAKoa,MAAMhH,KAAM3P,EAAO2W,OAExBpa,KAAK2a,OAAOvH,KAAM3P,EAAOkX,QACzB3a,KAAKupB,YAAYnW,KAAM3P,EAAO8lB,aAE9BvpB,KAAK0f,iBAAmBjc,EAAOic,iBAC/B1f,KAAKq7B,uBAAyB53B,EAAO43B,uBAErCr7B,KAAKs7B,sBAAwB73B,EAAO63B,sBAEpCt7B,KAAK65B,OAAON,KAAO91B,EAAOo2B,OAAON,KACjCv5B,KAAKw7B,QAAU/3B,EAAO+3B,QAEtBx7B,KAAKy7B,WAAah4B,EAAOg4B,WACzBz7B,KAAK07B,cAAgBj4B,EAAOi4B,cAE5B17B,KAAK27B,cAAgBl4B,EAAOk4B,cAC5B37B,KAAK47B,YAAcn4B,EAAOm4B,YAE1B57B,KAAK67B,WAAap4B,EAAOo4B,WAEzB77B,KAAK+f,SAAW5c,KAAKid,MAAOjd,KAAKC,UAAWK,EAAOsc,YAEhC,IAAdwgB,EAEJ,IAAM,IAAIjgC,EAAI,EAAGA,EAAImD,EAAO4pB,SAAS1sB,OAAQL,IAAO,CAEnD,MAAMg+B,EAAQ76B,EAAO4pB,SAAU/sB,GAC/BN,KAAKhD,IAAKshC,EAAMnrB,QAEjB,CAID,OAAOnT,IAER,EAID46B,GAASG,WAA2B,IAAI,GAAS,EAAG,EAAG,GACvDH,GAASQ,4BAA6B,EACtCR,GAASW,kCAAmC,EAE5C,MAAMiF,GAAsB,IAAI,GAC1BC,GAAsB,IAAI,GAC1BC,GAAsB,IAAI,GAC1BC,GAAsB,IAAI,GAE1BC,GAAqB,IAAI,GACzBC,GAAqB,IAAI,GACzBC,GAAqB,IAAI,GACzBC,GAAqB,IAAI,GACzBC,GAAqB,IAAI,GACzBC,GAAqB,IAAI,GAE/B,IAAIC,IAAc,EAElB,MAAMC,GAEL5+B,YAAakG,EAAI,IAAI,GAAWiJ,EAAI,IAAI,GAAWC,EAAI,IAAI,IAE1D3R,KAAKyI,EAAIA,EACTzI,KAAK0R,EAAIA,EACT1R,KAAK2R,EAAIA,CAEV,CAEA+K,iBAAkBjU,EAAGiJ,EAAGC,EAAGvN,GAE1BA,EAAOuP,WAAYhC,EAAGD,GACtB8uB,GAAM7sB,WAAYlL,EAAGiJ,GACrBtN,EAAOqQ,MAAO+rB,IAEd,MAAMY,EAAiBh9B,EAAOsQ,WAC9B,OAAK0sB,EAAiB,EAEdh9B,EAAOyP,eAAgB,EAAI7V,KAAKC,KAAMmjC,IAIvCh9B,EAAOmO,IAAK,EAAG,EAAG,EAE1B,CAIAmK,oBAAqBgQ,EAAOjkB,EAAGiJ,EAAGC,EAAGvN,GAEpCo8B,GAAM7sB,WAAYhC,EAAGlJ,GACrBg4B,GAAM9sB,WAAYjC,EAAGjJ,GACrBi4B,GAAM/sB,WAAY+Y,EAAOjkB,GAEzB,MAAM44B,EAAQb,GAAMhsB,IAAKgsB,IACnBc,EAAQd,GAAMhsB,IAAKisB,IACnBc,EAAQf,GAAMhsB,IAAKksB,IACnBc,EAAQf,GAAMjsB,IAAKisB,IACnBgB,EAAQhB,GAAMjsB,IAAKksB,IAEnBgB,EAAUL,EAAQG,EAAQF,EAAQA,EAGxC,GAAe,IAAVI,EAIJ,OAAOt9B,EAAOmO,KAAO,GAAK,GAAK,GAIhC,MAAMovB,EAAW,EAAID,EACftW,GAAMoW,EAAQD,EAAQD,EAAQG,GAAUE,EACxCtuB,GAAMguB,EAAQI,EAAQH,EAAQC,GAAUI,EAG9C,OAAOv9B,EAAOmO,IAAK,EAAI6Y,EAAI/X,EAAGA,EAAG+X,EAElC,CAEA1O,qBAAsBgQ,EAAOjkB,EAAGiJ,EAAGC,GAIlC,OAFA3R,KAAK4hC,aAAclV,EAAOjkB,EAAGiJ,EAAGC,EAAGgvB,IAE1BA,GAAMrkC,GAAK,GAASqkC,GAAMnkC,GAAK,GAAWmkC,GAAMrkC,EAAIqkC,GAAMnkC,GAAO,CAE3E,CAEAkgB,aAAcgQ,EAAO4C,EAAIC,EAAIsS,EAAIC,EAAKC,EAAKC,EAAK59B,GAU/C,OARqB,IAAhB88B,KAEJ5iC,QAAQkU,KAAM,iFAEd0uB,IAAc,GAIRlhC,KAAKiiC,iBAAkBvV,EAAO4C,EAAIC,EAAIsS,EAAIC,EAAKC,EAAKC,EAAK59B,EAEjE,CAEAsY,wBAAyBgQ,EAAO4C,EAAIC,EAAIsS,EAAItsB,EAAIC,EAAI0sB,EAAI99B,GASvD,OAPApE,KAAK4hC,aAAclV,EAAO4C,EAAIC,EAAIsS,EAAIlB,IAEtCv8B,EAAOyO,UAAW,GAClBzO,EAAOoP,gBAAiB+B,EAAIorB,GAAMrkC,GAClC8H,EAAOoP,gBAAiBgC,EAAImrB,GAAMnkC,GAClC4H,EAAOoP,gBAAiB0uB,EAAIvB,GAAM7f,GAE3B1c,CAER,CAEAsY,qBAAsBjU,EAAGiJ,EAAGC,EAAGif,GAM9B,OAJA4P,GAAM7sB,WAAYhC,EAAGD,GACrB+uB,GAAM9sB,WAAYlL,EAAGiJ,GAGZ8uB,GAAM/rB,MAAOgsB,IAAQjsB,IAAKoc,GAAc,CAElD,CAEAre,IAAK9J,EAAGiJ,EAAGC,GAMV,OAJA3R,KAAKyI,EAAE2K,KAAM3K,GACbzI,KAAK0R,EAAE0B,KAAM1B,GACb1R,KAAK2R,EAAEyB,KAAMzB,GAEN3R,IAER,CAEAmiC,wBAAyBrW,EAAQsW,EAAIC,EAAIC,GAMxC,OAJAtiC,KAAKyI,EAAE2K,KAAM0Y,EAAQsW,IACrBpiC,KAAK0R,EAAE0B,KAAM0Y,EAAQuW,IACrBriC,KAAK2R,EAAEyB,KAAM0Y,EAAQwW,IAEdtiC,IAER,CAEAuiC,2BAA4BzsB,EAAWssB,EAAIC,EAAIC,GAM9C,OAJAtiC,KAAKyI,EAAEoN,oBAAqBC,EAAWssB,GACvCpiC,KAAK0R,EAAEmE,oBAAqBC,EAAWusB,GACvCriC,KAAK2R,EAAEkE,oBAAqBC,EAAWwsB,GAEhCtiC,IAER,CAEAmT,QAEC,OAAO,IAAInT,KAAKuC,aAAc6Q,KAAMpT,KAErC,CAEAoT,KAAM6a,GAML,OAJAjuB,KAAKyI,EAAE2K,KAAM6a,EAASxlB,GACtBzI,KAAK0R,EAAE0B,KAAM6a,EAASvc,GACtB1R,KAAK2R,EAAEyB,KAAM6a,EAAStc,GAEf3R,IAER,CAEAwiC,UAKC,OAHAhC,GAAM7sB,WAAY3T,KAAK2R,EAAG3R,KAAK0R,GAC/B+uB,GAAM9sB,WAAY3T,KAAKyI,EAAGzI,KAAK0R,GAEQ,GAAhC8uB,GAAM/rB,MAAOgsB,IAAQ9/B,QAE7B,CAEA8hC,YAAar+B,GAEZ,OAAOA,EAAOmP,WAAYvT,KAAKyI,EAAGzI,KAAK0R,GAAI1U,IAAKgD,KAAK2R,GAAIkC,eAAgB,EAAI,EAE9E,CAEA6uB,UAAWt+B,GAEV,OAAO+8B,GAASuB,UAAW1iC,KAAKyI,EAAGzI,KAAK0R,EAAG1R,KAAK2R,EAAGvN,EAEpD,CAEAu+B,SAAUv+B,GAET,OAAOA,EAAOw+B,sBAAuB5iC,KAAKyI,EAAGzI,KAAK0R,EAAG1R,KAAK2R,EAE3D,CAEAiwB,aAAclV,EAAOtoB,GAEpB,OAAO+8B,GAASS,aAAclV,EAAO1sB,KAAKyI,EAAGzI,KAAK0R,EAAG1R,KAAK2R,EAAGvN,EAE9D,CAEAy+B,MAAOnW,EAAOoV,EAAKC,EAAKC,EAAK59B,GAU5B,OARqB,IAAhB88B,KAEJ5iC,QAAQkU,KAAM,iFAEd0uB,IAAc,GAIRC,GAASc,iBAAkBvV,EAAO1sB,KAAKyI,EAAGzI,KAAK0R,EAAG1R,KAAK2R,EAAGmwB,EAAKC,EAAKC,EAAK59B,EAEjF,CAEA69B,iBAAkBvV,EAAOnX,EAAIC,EAAI0sB,EAAI99B,GAEpC,OAAO+8B,GAASc,iBAAkBvV,EAAO1sB,KAAKyI,EAAGzI,KAAK0R,EAAG1R,KAAK2R,EAAG4D,EAAIC,EAAI0sB,EAAI99B,EAE9E,CAEAkpB,cAAeZ,GAEd,OAAOyU,GAAS7T,cAAeZ,EAAO1sB,KAAKyI,EAAGzI,KAAK0R,EAAG1R,KAAK2R,EAE5D,CAEAmxB,cAAelS,GAEd,OAAOuQ,GAAS2B,cAAe9iC,KAAKyI,EAAGzI,KAAK0R,EAAG1R,KAAK2R,EAAGif,EAExD,CAEAnD,cAAenB,GAEd,OAAOA,EAAI0B,mBAAoBhuB,KAEhC,CAEAixB,oBAAqByH,EAAGt0B,GAEvB,MAAMqE,EAAIzI,KAAKyI,EAAGiJ,EAAI1R,KAAK0R,EAAGC,EAAI3R,KAAK2R,EACvC,IAAI0B,EAAG0N,EAQP6f,GAAKjtB,WAAYjC,EAAGjJ,GACpBo4B,GAAKltB,WAAYhC,EAAGlJ,GACpBs4B,GAAKptB,WAAY+kB,EAAGjwB,GACpB,MAAMyF,EAAK0yB,GAAKpsB,IAAKusB,IACf5yB,EAAK0yB,GAAKrsB,IAAKusB,IACrB,GAAK7yB,GAAM,GAAKC,GAAM,EAGrB,OAAO/J,EAAOgP,KAAM3K,GAIrBu4B,GAAKrtB,WAAY+kB,EAAGhnB,GACpB,MAAMtD,EAAKwyB,GAAKpsB,IAAKwsB,IACf+B,EAAKlC,GAAKrsB,IAAKwsB,IACrB,GAAK5yB,GAAM,GAAK20B,GAAM30B,EAGrB,OAAOhK,EAAOgP,KAAM1B,GAIrB,MAAMsxB,EAAK90B,EAAK60B,EAAK30B,EAAKD,EAC1B,GAAK60B,GAAM,GAAK90B,GAAM,GAAKE,GAAM,EAIhC,OAFAiF,EAAInF,GAAOA,EAAKE,GAEThK,EAAOgP,KAAM3K,GAAI+K,gBAAiBotB,GAAMvtB,GAIhD4tB,GAAKttB,WAAY+kB,EAAG/mB,GACpB,MAAMsxB,EAAKrC,GAAKpsB,IAAKysB,IACfiC,EAAKrC,GAAKrsB,IAAKysB,IACrB,GAAKiC,GAAM,GAAKD,GAAMC,EAGrB,OAAO9+B,EAAOgP,KAAMzB,GAIrB,MAAMwxB,EAAKF,EAAK90B,EAAKD,EAAKg1B,EAC1B,GAAKC,GAAM,GAAKh1B,GAAM,GAAK+0B,GAAM,EAIhC,OAFAniB,EAAI5S,GAAOA,EAAK+0B,GAET9+B,EAAOgP,KAAM3K,GAAI+K,gBAAiBqtB,GAAM9f,GAIhD,MAAMqiB,EAAKh1B,EAAK80B,EAAKD,EAAKF,EAC1B,GAAKK,GAAM,GAAOL,EAAK30B,GAAQ,GAAO60B,EAAKC,GAAQ,EAKlD,OAHApC,GAAKntB,WAAYhC,EAAGD,GACpBqP,GAAMgiB,EAAK30B,IAAW20B,EAAK30B,GAAS60B,EAAKC,IAElC9+B,EAAOgP,KAAM1B,GAAI8B,gBAAiBstB,GAAM/f,GAKhD,MAAM2gB,EAAQ,GAAM0B,EAAKD,EAAKH,GAK9B,OAHA3vB,EAAI8vB,EAAKzB,EACT3gB,EAAIiiB,EAAKtB,EAEFt9B,EAAOgP,KAAM3K,GAAI+K,gBAAiBotB,GAAMvtB,GAAIG,gBAAiBqtB,GAAM9f,EAE3E,CAEAtL,OAAQwY,GAEP,OAAOA,EAASxlB,EAAEgN,OAAQzV,KAAKyI,IAAOwlB,EAASvc,EAAE+D,OAAQzV,KAAK0R,IAAOuc,EAAStc,EAAE8D,OAAQzV,KAAK2R,EAE9F,EAID,IAAI0xB,GAAa,EAEjB,MAAMC,WAAiBx2B,GAEtBvK,cAEC6c,QAEApf,KAAKujC,YAAa,EAElBnhC,OAAOuG,eAAgB3I,KAAM,KAAM,CAAE5C,MAAOimC,OAE5CrjC,KAAK4d,KAAO7P,KAEZ/N,KAAKwC,KAAO,GACZxC,KAAK+M,KAAO,WAEZ/M,KAAKwjC,SArrQgB,EAsrQrBxjC,KAAKyjC,KAAOj6B,EACZxJ,KAAK0jC,cAAe,EAEpB1jC,KAAK2jC,QAAU,EACf3jC,KAAK4jC,aAAc,EACnB5jC,KAAK6jC,WAAY,EAEjB7jC,KAAK8jC,SA/qQgB,IAgrQrB9jC,KAAK+jC,SA/qQwB,IAgrQ7B/jC,KAAKgkC,cAAgBt6B,EACrB1J,KAAKikC,cAAgB,KACrBjkC,KAAKkkC,cAAgB,KACrBlkC,KAAKmkC,mBAAqB,KAE1BnkC,KAAKokC,UA5qQgB,EA6qQrBpkC,KAAKqkC,WAAY,EACjBrkC,KAAKskC,YAAa,EAElBtkC,KAAKukC,iBAAmB,IACxBvkC,KAAKwkC,YA7iQmB,IA8iQxBxkC,KAAKykC,WAAa,EAClBzkC,KAAK0kC,gBAAkB,IACvB1kC,KAAK2kC,YAAcn4B,GACnBxM,KAAK4kC,aAAep4B,GACpBxM,KAAK6kC,aAAer4B,GACpBxM,KAAK8kC,cAAe,EAEpB9kC,KAAK+kC,eAAiB,KACtB/kC,KAAKglC,kBAAmB,EACxBhlC,KAAKilC,aAAc,EAEnBjlC,KAAKklC,WAAa,KAElBllC,KAAKmlC,YAAa,EAElBnlC,KAAKolC,UAAY,KAEjBplC,KAAKqlC,eAAgB,EACrBrlC,KAAKslC,oBAAsB,EAC3BtlC,KAAKulC,mBAAqB,EAE1BvlC,KAAKwlC,WAAY,EAEjBxlC,KAAKylC,iBAAkB,EACvBzlC,KAAK0lC,oBAAqB,EAC1B1lC,KAAK2lC,iBAAkB,EAEvB3lC,KAAKw7B,SAAU,EAEfx7B,KAAK4lC,YAAa,EAElB5lC,KAAK+f,SAAW,CAAC,EAEjB/f,KAAK6d,QAAU,EAEf7d,KAAK6lC,WAAa,CAEnB,CAEIC,gBAEH,OAAO9lC,KAAK6lC,UAEb,CAEIC,cAAW1oC,GAET4C,KAAK6lC,WAAa,GAAMzoC,EAAQ,GAEpC4C,KAAK6d,UAIN7d,KAAK6lC,WAAazoC,CAEnB,CAEA2oC,UAAyC,CAEzCjK,iBAA0E,CAE1EkK,kBAAiD,CAEjDC,wBAEC,OAAOjmC,KAAKgmC,gBAAgBjmC,UAE7B,CAEAmmC,UAAW5F,GAEV,QAAgBnjC,IAAXmjC,EAEL,IAAM,MAAMv6B,KAAOu6B,EAAS,CAE3B,MAAM6F,EAAW7F,EAAQv6B,GAEzB,QAAkB5I,IAAbgpC,EAAyB,CAE7B7nC,QAAQkU,KAAM,8BAA+BzM,8BAC7C,QAED,CAEA,MAAMqgC,EAAepmC,KAAM+F,QAEL5I,IAAjBipC,EAOAA,GAAgBA,EAAa9G,QAEjC8G,EAAa7zB,IAAK4zB,GAELC,GAAgBA,EAAale,WAAiBie,GAAYA,EAASje,UAEhFke,EAAahzB,KAAM+yB,GAInBnmC,KAAM+F,GAAQogC,EAfd7nC,QAAQkU,KAAM,oBAAqBzM,iCAAqC/F,KAAK+M,QAmB/E,CAED,CAEAgR,OAAQC,GAEP,MAAMC,OAA0B9gB,IAAT6gB,GAAsC,iBAATA,EAE/CC,IAEJD,EAAO,CACNqC,SAAU,CAAC,EACXnC,OAAQ,CAAC,IAKX,MAAM7a,EAAO,CACZid,SAAU,CACTzC,QAAS,IACT9Q,KAAM,WACNwT,UAAW,oBAgNb,SAAS6f,EAAkBC,GAE1B,MAAMC,EAAS,GAEf,IAAM,MAAMv6B,KAAOs6B,EAAQ,CAE1B,MAAMh9B,EAAOg9B,EAAOt6B,UACb1C,EAAKid,SACZggB,EAAO7gC,KAAM4D,EAEd,CAEA,OAAOi9B,CAER,CAEA,GA3NAj9B,EAAKua,KAAO5d,KAAK4d,KACjBva,EAAK0J,KAAO/M,KAAK+M,KAEE,KAAd/M,KAAKwC,OAAca,EAAKb,KAAOxC,KAAKwC,MAEpCxC,KAAKwb,OAASxb,KAAKwb,MAAM8jB,UAAUj8B,EAAKmY,MAAQxb,KAAKwb,MAAM6qB,eAExClpC,IAAnB6C,KAAKsmC,YAA0BjjC,EAAKijC,UAAYtmC,KAAKsmC,gBAClCnpC,IAAnB6C,KAAKumC,YAA0BljC,EAAKkjC,UAAYvmC,KAAKumC,gBAEtCppC,IAAf6C,KAAKwmC,QAAsBnjC,EAAKmjC,MAAQxmC,KAAKwmC,OAC7CxmC,KAAKymC,YAAczmC,KAAKymC,WAAWnH,UAAUj8B,EAAKojC,WAAazmC,KAAKymC,WAAWJ,eACvDlpC,IAAxB6C,KAAK0mC,iBAA+BrjC,EAAKqjC,eAAiB1mC,KAAK0mC,gBAC/D1mC,KAAK2mC,UAAY3mC,KAAK2mC,SAASrH,UAAUj8B,EAAKsjC,SAAW3mC,KAAK2mC,SAASN,UACvErmC,KAAK4mC,mBAAgD,IAA3B5mC,KAAK4mC,oBAA0BvjC,EAAKujC,kBAAoB5mC,KAAK4mC,mBAEvF5mC,KAAK6mC,UAAY7mC,KAAK6mC,SAASvH,UAAUj8B,EAAKwjC,SAAW7mC,KAAK6mC,SAASR,eAC5ClpC,IAA3B6C,KAAK8mC,oBAAkCzjC,EAAKyjC,kBAAoB9mC,KAAK8mC,mBACrE9mC,KAAK+mC,eAAiB/mC,KAAK+mC,cAAczH,UAAUj8B,EAAK0jC,cAAgB/mC,KAAK+mC,cAAcV,eACxElpC,IAAnB6C,KAAKgnC,YAA0B3jC,EAAK2jC,UAAYhnC,KAAKgnC,gBAClC7pC,IAAnB6C,KAAKinC,YAA0B5jC,EAAK4jC,UAAYjnC,KAAKinC,gBACzB9pC,IAA5B6C,KAAKknC,qBAAmC7jC,EAAK6jC,mBAAqBlnC,KAAKknC,oBAEvElnC,KAAKmnC,cAAgBnnC,KAAKmnC,aAAa9nB,YAE3Chc,EAAK8jC,aAAennC,KAAKmnC,aAAappB,OAAQC,GAAOJ,MAIjD5d,KAAKonC,uBAAyBpnC,KAAKonC,sBAAsB/nB,YAE7Dhc,EAAK+jC,sBAAwBpnC,KAAKonC,sBAAsBrpB,OAAQC,GAAOJ,MAInE5d,KAAKqnC,oBAAsBrnC,KAAKqnC,mBAAmBhoB,YAEvDhc,EAAKgkC,mBAAqBrnC,KAAKqnC,mBAAmBtpB,OAAQC,GAAOJ,KACjEva,EAAKikC,qBAAuBtnC,KAAKsnC,qBAAqB1xB,gBAI7BzY,IAArB6C,KAAKunC,cAA4BlkC,EAAKkkC,YAAcvnC,KAAKunC,kBACjCpqC,IAAxB6C,KAAKwnC,iBAA+BnkC,EAAKmkC,eAAiBxnC,KAAKwnC,qBAC5BrqC,IAAnC6C,KAAKynC,4BAA0CpkC,EAAKokC,0BAA4BznC,KAAKynC,2BAErFznC,KAAK0nC,gBAAkB1nC,KAAK0nC,eAAeroB,YAE/Chc,EAAKqkC,eAAiB1nC,KAAK0nC,eAAe3pB,OAAQC,GAAOJ,MAIrD5d,KAAK2nC,yBAA2B3nC,KAAK2nC,wBAAwBtoB,YAEjEhc,EAAKskC,wBAA0B3nC,KAAK2nC,wBAAwB5pB,OAAQC,GAAOJ,WAInDzgB,IAApB6C,KAAKif,aAA2B5b,EAAK4b,WAAajf,KAAKif,iBAC3B9hB,IAA5B6C,KAAK4nC,qBAAmCvkC,EAAKukC,mBAAqB5nC,KAAK4nC,oBAEvE5nC,KAAK6nC,eAAiB7nC,KAAK6nC,cAAcxoB,YAE7Chc,EAAKwkC,cAAgB7nC,KAAK6nC,cAAc9pB,OAAQC,GAAOJ,MAInD5d,KAAKC,KAAOD,KAAKC,IAAIof,YAAYhc,EAAKpD,IAAMD,KAAKC,IAAI8d,OAAQC,GAAOJ,MACpE5d,KAAK8nC,QAAU9nC,KAAK8nC,OAAOzoB,YAAYhc,EAAKykC,OAAS9nC,KAAK8nC,OAAO/pB,OAAQC,GAAOJ,MAChF5d,KAAK+nC,UAAY/nC,KAAK+nC,SAAS1oB,YAAYhc,EAAK0kC,SAAW/nC,KAAK+nC,SAAShqB,OAAQC,GAAOJ,MAExF5d,KAAKgoC,UAAYhoC,KAAKgoC,SAAS3oB,YAEnChc,EAAK2kC,SAAWhoC,KAAKgoC,SAASjqB,OAAQC,GAAOJ,KAC7Cva,EAAK4kC,kBAAoBjoC,KAAKioC,mBAI1BjoC,KAAKkoC,OAASloC,KAAKkoC,MAAM7oB,YAE7Bhc,EAAK6kC,MAAQloC,KAAKkoC,MAAMnqB,OAAQC,GAAOJ,KACvCva,EAAK8kC,eAAiBnoC,KAAKmoC,gBAIvBnoC,KAAKooC,SAAWpoC,KAAKooC,QAAQ/oB,YAEjChc,EAAK+kC,QAAUpoC,KAAKooC,QAAQrqB,OAAQC,GAAOJ,KAC3Cva,EAAKglC,UAAYroC,KAAKqoC,WAIlBroC,KAAKsoC,WAAatoC,KAAKsoC,UAAUjpB,YAErChc,EAAKilC,UAAYtoC,KAAKsoC,UAAUvqB,OAAQC,GAAOJ,KAC/Cva,EAAKklC,cAAgBvoC,KAAKuoC,cAC1BllC,EAAKmlC,YAAcxoC,KAAKwoC,YAAY5yB,WAIhC5V,KAAKyoC,iBAAmBzoC,KAAKyoC,gBAAgBppB,YAEjDhc,EAAKolC,gBAAkBzoC,KAAKyoC,gBAAgB1qB,OAAQC,GAAOJ,KAC3Dva,EAAKqlC,kBAAoB1oC,KAAK0oC,kBAC9BrlC,EAAKslC,iBAAmB3oC,KAAK2oC,kBAIzB3oC,KAAK4oC,cAAgB5oC,KAAK4oC,aAAavpB,YAAYhc,EAAKulC,aAAe5oC,KAAK4oC,aAAa7qB,OAAQC,GAAOJ,MACxG5d,KAAK6oC,cAAgB7oC,KAAK6oC,aAAaxpB,YAAYhc,EAAKwlC,aAAe7oC,KAAK6oC,aAAa9qB,OAAQC,GAAOJ,MAExG5d,KAAK8oC,aAAe9oC,KAAK8oC,YAAYzpB,YAAYhc,EAAKylC,YAAc9oC,KAAK8oC,YAAY/qB,OAAQC,GAAOJ,MACpG5d,KAAK+oC,aAAe/oC,KAAK+oC,YAAY1pB,YAAYhc,EAAK0lC,YAAc/oC,KAAK+oC,YAAYhrB,OAAQC,GAAOJ,MACpG5d,KAAKgpC,sBAAwBhpC,KAAKgpC,qBAAqB3pB,YAAYhc,EAAK2lC,qBAAuBhpC,KAAKgpC,qBAAqBjrB,OAAQC,GAAOJ,MACxI5d,KAAKipC,kBAAoBjpC,KAAKipC,iBAAiB5pB,YAAYhc,EAAK4lC,iBAAmBjpC,KAAKipC,iBAAiBlrB,OAAQC,GAAOJ,MAExH5d,KAAKkpC,QAAUlpC,KAAKkpC,OAAO7pB,YAE/Bhc,EAAK6lC,OAASlpC,KAAKkpC,OAAOnrB,OAAQC,GAAOJ,UAEnBzgB,IAAjB6C,KAAKmpC,UAAwB9lC,EAAK8lC,QAAUnpC,KAAKmpC,eAIzBhsC,IAAzB6C,KAAKopC,kBAAgC/lC,EAAK+lC,gBAAkBppC,KAAKopC,sBAC3CjsC,IAAtB6C,KAAKqpC,eAA6BhmC,EAAKgmC,aAAerpC,KAAKqpC,mBAClClsC,IAAzB6C,KAAKspC,kBAAgCjmC,EAAKimC,gBAAkBtpC,KAAKspC,iBAEjEtpC,KAAKupC,aAAevpC,KAAKupC,YAAYlqB,YAEzChc,EAAKkmC,YAAcvpC,KAAKupC,YAAYxrB,OAAQC,GAAOJ,WAIzBzgB,IAAtB6C,KAAKwpC,eAA6BnmC,EAAKmmC,aAAexpC,KAAKwpC,cAC3DxpC,KAAKypC,iBAAmBzpC,KAAKypC,gBAAgBpqB,YAAYhc,EAAKomC,gBAAkBzpC,KAAKypC,gBAAgB1rB,OAAQC,GAAOJ,WACjGzgB,IAAnB6C,KAAK0pC,YAA0BrmC,EAAKqmC,UAAY1pC,KAAK0pC,WACrD1pC,KAAK2pC,cAAgB3pC,KAAK2pC,aAAatqB,YAAYhc,EAAKsmC,aAAe3pC,KAAK2pC,aAAa5rB,OAAQC,GAAOJ,WAC3EzgB,IAA7B6C,KAAK4pC,qBAAqC5pC,KAAK4pC,sBAAwBC,MAAWxmC,EAAKumC,oBAAsB5pC,KAAK4pC,0BACxFzsC,IAA1B6C,KAAK8pC,mBAAiCzmC,EAAKymC,iBAAmB9pC,KAAK8pC,iBAAiBzD,eAEtElpC,IAAd6C,KAAKgsB,OAAqB3oB,EAAK2oB,KAAOhsB,KAAKgsB,MACvB,OAApBhsB,KAAKklC,aAAsB7hC,EAAK6hC,WAAallC,KAAKklC,iBACzB/nC,IAAzB6C,KAAK+pC,kBAAgC1mC,EAAK0mC,gBAAkB/pC,KAAK+pC,iBA99QjD,IAg+QhB/pC,KAAKwjC,WAA8BngC,EAAKmgC,SAAWxjC,KAAKwjC,UACxDxjC,KAAKyjC,OAASj6B,IAAYnG,EAAKogC,KAAOzjC,KAAKyjC,MAC3CzjC,KAAK0jC,eAAergC,EAAKqgC,cAAe,GAExC1jC,KAAK2jC,QAAU,IAAItgC,EAAKsgC,QAAU3jC,KAAK2jC,UAClB,IAArB3jC,KAAK4jC,cAAuBvgC,EAAKugC,YAAc5jC,KAAK4jC,aAEzDvgC,EAAK+gC,UAAYpkC,KAAKokC,UACtB/gC,EAAKghC,UAAYrkC,KAAKqkC,UACtBhhC,EAAKihC,WAAatkC,KAAKskC,WACvBjhC,EAAK8hC,WAAanlC,KAAKmlC,WAEvB9hC,EAAKyhC,aAAe9kC,KAAK8kC,aACzBzhC,EAAKkhC,iBAAmBvkC,KAAKukC,iBAC7BlhC,EAAKmhC,YAAcxkC,KAAKwkC,YACxBnhC,EAAKohC,WAAazkC,KAAKykC,WACvBphC,EAAKqhC,gBAAkB1kC,KAAK0kC,gBAC5BrhC,EAAKshC,YAAc3kC,KAAK2kC,YACxBthC,EAAKuhC,aAAe5kC,KAAK4kC,aACzBvhC,EAAKwhC,aAAe7kC,KAAK6kC,kBAGF1nC,IAAlB6C,KAAKia,UAA4C,IAAlBja,KAAKia,WAAiB5W,EAAK4W,SAAWja,KAAKia,WAEnD,IAAvBja,KAAKqlC,gBAAyBhiC,EAAKgiC,eAAgB,GACtB,IAA7BrlC,KAAKslC,sBAA4BjiC,EAAKiiC,oBAAsBtlC,KAAKslC,qBACrC,IAA5BtlC,KAAKulC,qBAA2BliC,EAAKkiC,mBAAqBvlC,KAAKulC,yBAE5CpoC,IAAnB6C,KAAKgqC,WAA8C,IAAnBhqC,KAAKgqC,YAAkB3mC,EAAK2mC,UAAYhqC,KAAKgqC,gBAC3D7sC,IAAlB6C,KAAKiqC,WAAyB5mC,EAAK4mC,SAAWjqC,KAAKiqC,eAClC9sC,IAAjB6C,KAAKkqC,UAAwB7mC,EAAK6mC,QAAUlqC,KAAKkqC,cAClC/sC,IAAf6C,KAAKoa,QAAsB/W,EAAK+W,MAAQpa,KAAKoa,QAE1B,IAAnBpa,KAAKwlC,YAAqBniC,EAAKmiC,WAAY,GAE3CxlC,KAAK8lC,UAAY,IAAIziC,EAAKyiC,UAAY9lC,KAAK8lC,YACxB,IAAnB9lC,KAAK6jC,YAAqBxgC,EAAKwgC,UAAY7jC,KAAK6jC,YACvB,IAAzB7jC,KAAKylC,kBAA2BpiC,EAAKoiC,gBAAkBzlC,KAAKylC,kBAChC,IAA5BzlC,KAAK0lC,qBAA8BriC,EAAKqiC,mBAAqB1lC,KAAK0lC,qBACzC,IAAzB1lC,KAAK2lC,kBAA2BtiC,EAAKsiC,gBAAkB3lC,KAAK2lC,kBAEzC,IAAnB3lC,KAAKmqC,YAAqB9mC,EAAK8mC,UAAYnqC,KAAKmqC,WAChDnqC,KAAKoqC,mBAAqB,IAAI/mC,EAAK+mC,mBAAqBpqC,KAAKoqC,oBACnC,UAA1BpqC,KAAKqqC,mBAA+BhnC,EAAKgnC,iBAAmBrqC,KAAKqqC,kBACtC,UAA3BrqC,KAAKsqC,oBAAgCjnC,EAAKinC,kBAAoBtqC,KAAKsqC,oBAE9C,IAArBtqC,KAAKuqC,cAAuBlnC,EAAKknC,YAAcvqC,KAAKuqC,cAEnC,IAAjBvqC,KAAKw7B,UAAoBn4B,EAAKm4B,SAAU,IAEpB,IAApBx7B,KAAK4lC,aAAuBviC,EAAKuiC,YAAa,IAEjC,IAAb5lC,KAAKwqC,MAAgBnnC,EAAKmnC,KAAM,GAEhCpoC,OAAOyD,KAAM7F,KAAK+f,UAAWpf,OAAS,IAAI0C,EAAK0c,SAAW/f,KAAK+f,UAoB/D9B,EAAe,CAEnB,MAAMoC,EAAW+f,EAAkBpiB,EAAKqC,UAClCnC,EAASkiB,EAAkBpiB,EAAKE,QAEjCmC,EAAS1f,OAAS,IAAI0C,EAAKgd,SAAWA,GACtCnC,EAAOvd,OAAS,IAAI0C,EAAK6a,OAASA,EAExC,CAEA,OAAO7a,CAER,CAEA8P,QAEC,OAAO,IAAInT,KAAKuC,aAAc6Q,KAAMpT,KAErC,CAEAoT,KAAM3P,GAELzD,KAAKwC,KAAOiB,EAAOjB,KAEnBxC,KAAKwjC,SAAW//B,EAAO+/B,SACvBxjC,KAAKyjC,KAAOhgC,EAAOggC,KACnBzjC,KAAK0jC,aAAejgC,EAAOigC,aAE3B1jC,KAAK2jC,QAAUlgC,EAAOkgC,QACtB3jC,KAAK4jC,YAAcngC,EAAOmgC,YAE1B5jC,KAAK8jC,SAAWrgC,EAAOqgC,SACvB9jC,KAAK+jC,SAAWtgC,EAAOsgC,SACvB/jC,KAAKgkC,cAAgBvgC,EAAOugC,cAC5BhkC,KAAKikC,cAAgBxgC,EAAOwgC,cAC5BjkC,KAAKkkC,cAAgBzgC,EAAOygC,cAC5BlkC,KAAKmkC,mBAAqB1gC,EAAO0gC,mBAEjCnkC,KAAKokC,UAAY3gC,EAAO2gC,UACxBpkC,KAAKqkC,UAAY5gC,EAAO4gC,UACxBrkC,KAAKskC,WAAa7gC,EAAO6gC,WAEzBtkC,KAAKukC,iBAAmB9gC,EAAO8gC,iBAC/BvkC,KAAKwkC,YAAc/gC,EAAO+gC,YAC1BxkC,KAAKykC,WAAahhC,EAAOghC,WACzBzkC,KAAK0kC,gBAAkBjhC,EAAOihC,gBAC9B1kC,KAAK2kC,YAAclhC,EAAOkhC,YAC1B3kC,KAAK4kC,aAAenhC,EAAOmhC,aAC3B5kC,KAAK6kC,aAAephC,EAAOohC,aAC3B7kC,KAAK8kC,aAAerhC,EAAOqhC,aAE3B,MAAM2F,EAAYhnC,EAAOshC,eACzB,IAAI2F,EAAY,KAEhB,GAAmB,OAAdD,EAAqB,CAEzB,MAAMtoC,EAAIsoC,EAAU9pC,OACpB+pC,EAAY,IAAIzpC,MAAOkB,GAEvB,IAAM,IAAI7B,EAAI,EAAGA,IAAM6B,IAAM7B,EAE5BoqC,EAAWpqC,GAAMmqC,EAAWnqC,GAAI6S,OAIlC,CA8BA,OA5BAnT,KAAK+kC,eAAiB2F,EACtB1qC,KAAKglC,iBAAmBvhC,EAAOuhC,iBAC/BhlC,KAAKilC,YAAcxhC,EAAOwhC,YAE1BjlC,KAAKklC,WAAazhC,EAAOyhC,WAEzBllC,KAAKmlC,WAAa1hC,EAAO0hC,WAEzBnlC,KAAKolC,UAAY3hC,EAAO2hC,UAExBplC,KAAKqlC,cAAgB5hC,EAAO4hC,cAC5BrlC,KAAKslC,oBAAsB7hC,EAAO6hC,oBAClCtlC,KAAKulC,mBAAqB9hC,EAAO8hC,mBAEjCvlC,KAAKwlC,UAAY/hC,EAAO+hC,UAExBxlC,KAAK8lC,UAAYriC,EAAOqiC,UACxB9lC,KAAK6jC,UAAYpgC,EAAOogC,UACxB7jC,KAAKylC,gBAAkBhiC,EAAOgiC,gBAC9BzlC,KAAK0lC,mBAAqBjiC,EAAOiiC,mBACjC1lC,KAAK2lC,gBAAkBliC,EAAOkiC,gBAE9B3lC,KAAKw7B,QAAU/3B,EAAO+3B,QAEtBx7B,KAAK4lC,WAAaniC,EAAOmiC,WAEzB5lC,KAAK+f,SAAW5c,KAAKid,MAAOjd,KAAKC,UAAWK,EAAOsc,WAE5C/f,IAER,CAEAygB,UAECzgB,KAAKuN,cAAe,CAAER,KAAM,WAE7B,CAEI+Q,gBAAa1gB,IAED,IAAVA,GAAiB4C,KAAK6d,SAE5B,EAID,MAAM8sB,GAAiB,CAAE,UAAa,SAAU,aAAgB,SAAU,KAAQ,MAAU,WAAc,QAAU,MAAS,SAC5H,MAAS,SAAU,OAAU,SAAU,MAAS,EAAU,eAAkB,SAAU,KAAQ,IAAU,WAAc,QACtH,MAAS,SAAU,UAAa,SAAU,UAAa,QAAU,WAAc,QAAU,UAAa,SAAU,MAAS,SACzH,eAAkB,QAAU,SAAY,SAAU,QAAW,SAAU,KAAQ,MAAU,SAAY,IAAU,SAAY,MAC3H,cAAiB,SAAU,SAAY,SAAU,UAAa,MAAU,SAAY,SAAU,UAAa,SAAU,YAAe,QACpI,eAAkB,QAAU,WAAc,SAAU,WAAc,SAAU,QAAW,QAAU,WAAc,SAAU,aAAgB,QACzI,cAAiB,QAAU,cAAiB,QAAU,cAAiB,QAAU,cAAiB,MAAU,WAAc,QAC1H,SAAY,SAAU,YAAe,MAAU,QAAW,QAAU,QAAW,QAAU,WAAc,QAAU,UAAa,SAC9H,YAAe,SAAU,YAAe,QAAU,QAAW,SAAU,UAAa,SAAU,WAAc,SAAU,KAAQ,SAC9H,UAAa,SAAU,KAAQ,QAAU,MAAS,MAAU,YAAe,SAAU,KAAQ,QAAU,SAAY,SAAU,QAAW,SACxI,UAAa,SAAU,OAAU,QAAU,MAAS,SAAU,MAAS,SAAU,SAAY,SAAU,cAAiB,SAAU,UAAa,QAC/I,aAAgB,SAAU,UAAa,SAAU,WAAc,SAAU,UAAa,SAAU,qBAAwB,SAAU,UAAa,SAC/I,WAAc,QAAU,UAAa,SAAU,UAAa,SAAU,YAAe,SAAU,cAAiB,QAAU,aAAgB,QAC1I,eAAkB,QAAU,eAAkB,QAAU,eAAkB,SAAU,YAAe,SAAU,KAAQ,MAAU,UAAa,QAC5I,MAAS,SAAU,QAAW,SAAU,OAAU,QAAU,iBAAoB,QAAU,WAAc,IAAU,aAAgB,SAClI,aAAgB,QAAU,eAAkB,QAAU,gBAAmB,QAAU,kBAAqB,MAAU,gBAAmB,QACrI,gBAAmB,SAAU,aAAgB,QAAU,UAAa,SAAU,UAAa,SAAU,SAAY,SAAU,YAAe,SAC1I,KAAQ,IAAU,QAAW,SAAU,MAAS,QAAU,UAAa,QAAU,OAAU,SAAU,UAAa,SAAU,OAAU,SACtI,cAAiB,SAAU,UAAa,SAAU,cAAiB,SAAU,cAAiB,SAAU,WAAc,SAAU,UAAa,SAC7I,KAAQ,SAAU,KAAQ,SAAU,KAAQ,SAAU,WAAc,SAAU,OAAU,QAAU,cAAiB,QAAU,IAAO,SAAU,UAAa,SAC3J,UAAa,QAAU,YAAe,QAAU,OAAU,SAAU,WAAc,SAAU,SAAY,QAAU,SAAY,SAC9H,OAAU,SAAU,OAAU,SAAU,QAAW,QAAU,UAAa,QAAU,UAAa,QAAU,UAAa,QAAU,KAAQ,SAC1I,YAAe,MAAU,UAAa,QAAU,IAAO,SAAU,KAAQ,MAAU,QAAW,SAAU,OAAU,SAAU,UAAa,QACzI,OAAU,SAAU,MAAS,SAAU,MAAS,SAAU,WAAc,SAAU,OAAU,SAAU,YAAe,UAEhHC,GAAQ,CAAE5xB,EAAG,EAAG9H,EAAG,EAAGxD,EAAG,GACzBm9B,GAAQ,CAAE7xB,EAAG,EAAG9H,EAAG,EAAGxD,EAAG,GAE/B,SAASo9B,GAASpS,EAAGjnB,EAAG9C,GAIvB,OAFKA,EAAI,IAAIA,GAAK,GACbA,EAAI,IAAIA,GAAK,GACbA,EAAI,EAAI,EAAW+pB,EAAgB,GAAVjnB,EAAIinB,GAAU/pB,EACvCA,EAAI,GAAe8C,EACnB9C,EAAI,EAAI,EAAW+pB,EAAgB,GAAVjnB,EAAIinB,IAAY,EAAI,EAAI/pB,GAC/C+pB,CAER,CAEA,MAAMqS,GAELxoC,YAAayG,EAAG+P,EAAGrH,GAQlB,OANA1R,KAAKs/B,SAAU,EAEft/B,KAAKgJ,EAAI,EACThJ,KAAK+Y,EAAI,EACT/Y,KAAK0R,EAAI,EAEF1R,KAAKuS,IAAKvJ,EAAG+P,EAAGrH,EAExB,CAEAa,IAAKvJ,EAAG+P,EAAGrH,GAEV,QAAWvU,IAAN4b,QAAyB5b,IAANuU,EAAkB,CAIzC,MAAMtU,EAAQ4L,EAET5L,GAASA,EAAMkiC,QAEnBt/B,KAAKoT,KAAMhW,GAEiB,iBAAVA,EAElB4C,KAAKgrC,OAAQ5tC,GAEe,iBAAVA,GAElB4C,KAAKirC,SAAU7tC,EAIjB,MAEC4C,KAAKkrC,OAAQliC,EAAG+P,EAAGrH,GAIpB,OAAO1R,IAER,CAEA6S,UAAWC,GAMV,OAJA9S,KAAKgJ,EAAI8J,EACT9S,KAAK+Y,EAAIjG,EACT9S,KAAK0R,EAAIoB,EAEF9S,IAER,CAEAgrC,OAAQG,EAAKnvB,EAAa3P,IAUzB,OARA8+B,EAAMntC,KAAKK,MAAO8sC,GAElBnrC,KAAKgJ,GAAMmiC,GAAO,GAAK,KAAQ,IAC/BnrC,KAAK+Y,GAAMoyB,GAAO,EAAI,KAAQ,IAC9BnrC,KAAK0R,GAAY,IAANy5B,GAAc,IAEzBvvB,GAAgBW,oBAAqBvc,KAAMgc,GAEpChc,IAER,CAEAkrC,OAAQliC,EAAG+P,EAAGrH,EAAGsK,EAAaJ,GAAgBG,mBAQ7C,OANA/b,KAAKgJ,EAAIA,EACThJ,KAAK+Y,EAAIA,EACT/Y,KAAK0R,EAAIA,EAETkK,GAAgBW,oBAAqBvc,KAAMgc,GAEpChc,IAER,CAEAorC,OAAQpyB,EAAG9H,EAAGxD,EAAGsO,EAAaJ,GAAgBG,mBAO7C,GAJA/C,EAAIxK,GAAiBwK,EAAG,GACxB9H,EAAI5C,GAAO4C,EAAG,EAAG,GACjBxD,EAAIY,GAAOZ,EAAG,EAAG,GAEN,IAANwD,EAEJlR,KAAKgJ,EAAIhJ,KAAK+Y,EAAI/Y,KAAK0R,EAAIhE,MAErB,CAEN,MAAMgrB,EAAIhrB,GAAK,GAAMA,GAAM,EAAIwD,GAAMxD,EAAIwD,EAAMxD,EAAIwD,EAC7CO,EAAM,EAAI/D,EAAMgrB,EAEtB14B,KAAKgJ,EAAI8hC,GAASr5B,EAAGinB,EAAG1f,EAAI,EAAI,GAChChZ,KAAK+Y,EAAI+xB,GAASr5B,EAAGinB,EAAG1f,GACxBhZ,KAAK0R,EAAIo5B,GAASr5B,EAAGinB,EAAG1f,EAAI,EAAI,EAEjC,CAIA,OAFA4C,GAAgBW,oBAAqBvc,KAAMgc,GAEpChc,IAER,CAEAirC,SAAUpuC,EAAOmf,EAAa3P,IAE7B,SAASg/B,EAAaC,QAELnuC,IAAXmuC,GAEAC,WAAYD,GAAW,GAE3BhtC,QAAQkU,KAAM,mCAAqC3V,EAAQ,oBAI7D,CAGA,IAAI4R,EAEJ,GAAKA,EAAI,qBAAqB+8B,KAAM3uC,GAAU,CAI7C,IAAI2e,EACJ,MAAMhZ,EAAOiM,EAAG,GACVg9B,EAAah9B,EAAG,GAEtB,OAASjM,GAER,IAAK,MACL,IAAK,OAEJ,GAAKgZ,EAAQ,+DAA+DgwB,KAAMC,GAMjF,OAFAJ,EAAa7vB,EAAO,IAEbxb,KAAKkrC,OACXltC,KAAKL,IAAK,IAAK+tC,SAAUlwB,EAAO,GAAK,KAAS,IAC9Cxd,KAAKL,IAAK,IAAK+tC,SAAUlwB,EAAO,GAAK,KAAS,IAC9Cxd,KAAKL,IAAK,IAAK+tC,SAAUlwB,EAAO,GAAK,KAAS,IAC9CQ,GAKF,GAAKR,EAAQ,qEAAqEgwB,KAAMC,GAMvF,OAFAJ,EAAa7vB,EAAO,IAEbxb,KAAKkrC,OACXltC,KAAKL,IAAK,IAAK+tC,SAAUlwB,EAAO,GAAK,KAAS,IAC9Cxd,KAAKL,IAAK,IAAK+tC,SAAUlwB,EAAO,GAAK,KAAS,IAC9Cxd,KAAKL,IAAK,IAAK+tC,SAAUlwB,EAAO,GAAK,KAAS,IAC9CQ,GAKF,MAED,IAAK,MACL,IAAK,OAEJ,GAAKR,EAAQ,qFAAqFgwB,KAAMC,GAMvG,OAFAJ,EAAa7vB,EAAO,IAEbxb,KAAKorC,OACXG,WAAY/vB,EAAO,IAAQ,IAC3B+vB,WAAY/vB,EAAO,IAAQ,IAC3B+vB,WAAY/vB,EAAO,IAAQ,IAC3BQ,GAKF,MAED,QAEC1d,QAAQkU,KAAM,oCAAsC3V,GAIvD,MAAO,GAAK4R,EAAI,oBAAoB+8B,KAAM3uC,GAAU,CAInD,MAAMsuC,EAAM18B,EAAG,GACTud,EAAOmf,EAAIxqC,OAEjB,GAAc,IAATqrB,EAGJ,OAAOhsB,KAAKkrC,OACXQ,SAAUP,EAAIQ,OAAQ,GAAK,IAAO,GAClCD,SAAUP,EAAIQ,OAAQ,GAAK,IAAO,GAClCD,SAAUP,EAAIQ,OAAQ,GAAK,IAAO,GAClC3vB,GAGK,GAAc,IAATgQ,EAGX,OAAOhsB,KAAKgrC,OAAQU,SAAUP,EAAK,IAAMnvB,GAIzC1d,QAAQkU,KAAM,kCAAoC3V,EAIpD,MAAO,GAAKA,GAASA,EAAM8D,OAAS,EAEnC,OAAOX,KAAK4rC,aAAc/uC,EAAOmf,GAIlC,OAAOhc,IAER,CAEA4rC,aAAc/uC,EAAOmf,EAAa3P,IAGjC,MAAM8+B,EAAMR,GAAgB9tC,EAAMwR,eAclC,YAZalR,IAARguC,EAGJnrC,KAAKgrC,OAAQG,EAAKnvB,GAKlB1d,QAAQkU,KAAM,8BAAgC3V,GAIxCmD,IAER,CAEAmT,QAEC,OAAO,IAAInT,KAAKuC,YAAavC,KAAKgJ,EAAGhJ,KAAK+Y,EAAG/Y,KAAK0R,EAEnD,CAEA0B,KAAMoI,GAML,OAJAxb,KAAKgJ,EAAIwS,EAAMxS,EACfhJ,KAAK+Y,EAAIyC,EAAMzC,EACf/Y,KAAK0R,EAAI8J,EAAM9J,EAER1R,IAER,CAEA6rC,iBAAkBrwB,GAMjB,OAJAxb,KAAKgJ,EAAImS,GAAcK,EAAMxS,GAC7BhJ,KAAK+Y,EAAIoC,GAAcK,EAAMzC,GAC7B/Y,KAAK0R,EAAIyJ,GAAcK,EAAM9J,GAEtB1R,IAER,CAEA8rC,iBAAkBtwB,GAMjB,OAJAxb,KAAKgJ,EAAIoS,GAAcI,EAAMxS,GAC7BhJ,KAAK+Y,EAAIqC,GAAcI,EAAMzC,GAC7B/Y,KAAK0R,EAAI0J,GAAcI,EAAM9J,GAEtB1R,IAER,CAEAyb,sBAIC,OAFAzb,KAAK6rC,iBAAkB7rC,MAEhBA,IAER,CAEA2b,sBAIC,OAFA3b,KAAK8rC,iBAAkB9rC,MAEhBA,IAER,CAEAqmC,OAAQrqB,EAAa3P,IAIpB,OAFAuP,GAAgBU,sBAAuByvB,GAAO34B,KAAMpT,MAAQgc,GAEL,MAAhDhe,KAAK2R,MAAOrB,GAAkB,IAAXy9B,GAAO/iC,EAAS,EAAG,MAAkE,IAAhDhL,KAAK2R,MAAOrB,GAAkB,IAAXy9B,GAAOhzB,EAAS,EAAG,MAAgB/a,KAAK2R,MAAOrB,GAAkB,IAAXy9B,GAAOr6B,EAAS,EAAG,KAE5J,CAEAs6B,aAAchwB,EAAa3P,IAE1B,OAAS,SAAWrM,KAAKqmC,OAAQrqB,GAAajc,SAAU,KAAOuC,OAAS,EAEzE,CAEA2pC,OAAQ7nC,EAAQ4X,EAAaJ,GAAgBG,mBAI5CH,GAAgBU,sBAAuByvB,GAAO34B,KAAMpT,MAAQgc,GAE5D,MAAMhT,EAAI+iC,GAAO/iC,EAAG+P,EAAIgzB,GAAOhzB,EAAGrH,EAAIq6B,GAAOr6B,EAEvCnD,EAAMvQ,KAAKuQ,IAAKvF,EAAG+P,EAAGrH,GACtB/T,EAAMK,KAAKL,IAAKqL,EAAG+P,EAAGrH,GAE5B,IAAIw6B,EAAKC,EACT,MAAMC,GAAczuC,EAAM4Q,GAAQ,EAElC,GAAK5Q,IAAQ4Q,EAEZ29B,EAAM,EACNC,EAAa,MAEP,CAEN,MAAMjc,EAAQ3hB,EAAM5Q,EAIpB,OAFAwuC,EAAaC,GAAa,GAAMlc,GAAU3hB,EAAM5Q,GAAQuyB,GAAU,EAAI3hB,EAAM5Q,GAEnE4Q,GAER,KAAKvF,EAAGkjC,GAAQnzB,EAAIrH,GAAMwe,GAAUnX,EAAIrH,EAAI,EAAI,GAAK,MACrD,KAAKqH,EAAGmzB,GAAQx6B,EAAI1I,GAAMknB,EAAQ,EAAG,MACrC,KAAKxe,EAAGw6B,GAAQljC,EAAI+P,GAAMmX,EAAQ,EAInCgc,GAAO,CAER,CAMA,OAJA9nC,EAAO4U,EAAIkzB,EACX9nC,EAAO8M,EAAIi7B,EACX/nC,EAAOsJ,EAAI0+B,EAEJhoC,CAER,CAEAioC,OAAQjoC,EAAQ4X,EAAaJ,GAAgBG,mBAQ5C,OANAH,GAAgBU,sBAAuByvB,GAAO34B,KAAMpT,MAAQgc,GAE5D5X,EAAO4E,EAAI+iC,GAAO/iC,EAClB5E,EAAO2U,EAAIgzB,GAAOhzB,EAClB3U,EAAOsN,EAAIq6B,GAAOr6B,EAEXtN,CAER,CAEAkoC,SAAUtwB,EAAa3P,IAEtBuP,GAAgBU,sBAAuByvB,GAAO34B,KAAMpT,MAAQgc,GAE5D,MAAMhT,EAAI+iC,GAAO/iC,EAAG+P,EAAIgzB,GAAOhzB,EAAGrH,EAAIq6B,GAAOr6B,EAE7C,OAAKsK,IAAe3P,GAGZ,SAAU2P,KAAgBhT,EAAEujC,QAAS,MAASxzB,EAAEwzB,QAAS,MAAS76B,EAAE66B,QAAS,MAI9E,OAAQvuC,KAAK2R,MAAW,IAAJ3G,MAAehL,KAAK2R,MAAW,IAAJoJ,MAAe/a,KAAK2R,MAAW,IAAJ+B,KAElF,CAEA86B,UAAWxzB,EAAG9H,EAAGxD,GAQhB,OANA1N,KAAKisC,OAAQrB,IAEbA,GAAM5xB,GAAKA,EAAG4xB,GAAM15B,GAAKA,EAAG05B,GAAMl9B,GAAKA,EAEvC1N,KAAKorC,OAAQR,GAAM5xB,EAAG4xB,GAAM15B,EAAG05B,GAAMl9B,GAE9B1N,IAER,CAEAhD,IAAKwe,GAMJ,OAJAxb,KAAKgJ,GAAKwS,EAAMxS,EAChBhJ,KAAK+Y,GAAKyC,EAAMzC,EAChB/Y,KAAK0R,GAAK8J,EAAM9J,EAET1R,IAER,CAEAysC,UAAWC,EAAQC,GAMlB,OAJA3sC,KAAKgJ,EAAI0jC,EAAO1jC,EAAI2jC,EAAO3jC,EAC3BhJ,KAAK+Y,EAAI2zB,EAAO3zB,EAAI4zB,EAAO5zB,EAC3B/Y,KAAK0R,EAAIg7B,EAAOh7B,EAAIi7B,EAAOj7B,EAEpB1R,IAER,CAEAsT,UAAWpC,GAMV,OAJAlR,KAAKgJ,GAAKkI,EACVlR,KAAK+Y,GAAK7H,EACVlR,KAAK0R,GAAKR,EAEHlR,IAER,CAEAyT,IAAK+H,GAMJ,OAJAxb,KAAKgJ,EAAIhL,KAAKuQ,IAAK,EAAGvO,KAAKgJ,EAAIwS,EAAMxS,GACrChJ,KAAK+Y,EAAI/a,KAAKuQ,IAAK,EAAGvO,KAAK+Y,EAAIyC,EAAMzC,GACrC/Y,KAAK0R,EAAI1T,KAAKuQ,IAAK,EAAGvO,KAAK0R,EAAI8J,EAAM9J,GAE9B1R,IAER,CAEA4T,SAAU4H,GAMT,OAJAxb,KAAKgJ,GAAKwS,EAAMxS,EAChBhJ,KAAK+Y,GAAKyC,EAAMzC,EAChB/Y,KAAK0R,GAAK8J,EAAM9J,EAET1R,IAER,CAEA6T,eAAgB3C,GAMf,OAJAlR,KAAKgJ,GAAKkI,EACVlR,KAAK+Y,GAAK7H,EACVlR,KAAK0R,GAAKR,EAEHlR,IAER,CAEA0O,KAAM8M,EAAOnG,GAMZ,OAJArV,KAAKgJ,IAAOwS,EAAMxS,EAAIhJ,KAAKgJ,GAAMqM,EACjCrV,KAAK+Y,IAAOyC,EAAMzC,EAAI/Y,KAAK+Y,GAAM1D,EACjCrV,KAAK0R,IAAO8J,EAAM9J,EAAI1R,KAAK0R,GAAM2D,EAE1BrV,IAER,CAEA4sC,WAAYF,EAAQC,EAAQt3B,GAM3B,OAJArV,KAAKgJ,EAAI0jC,EAAO1jC,GAAM2jC,EAAO3jC,EAAI0jC,EAAO1jC,GAAMqM,EAC9CrV,KAAK+Y,EAAI2zB,EAAO3zB,GAAM4zB,EAAO5zB,EAAI2zB,EAAO3zB,GAAM1D,EAC9CrV,KAAK0R,EAAIg7B,EAAOh7B,GAAMi7B,EAAOj7B,EAAIg7B,EAAOh7B,GAAM2D,EAEvCrV,IAER,CAEA6sC,QAASrxB,EAAOnG,GAEfrV,KAAKisC,OAAQrB,IACbpvB,EAAMywB,OAAQpB,IAEd,MAAM7xB,EAAItK,GAAMk8B,GAAM5xB,EAAG6xB,GAAM7xB,EAAG3D,GAC5BnE,EAAIxC,GAAMk8B,GAAM15B,EAAG25B,GAAM35B,EAAGmE,GAC5B3H,EAAIgB,GAAMk8B,GAAMl9B,EAAGm9B,GAAMn9B,EAAG2H,GAIlC,OAFArV,KAAKorC,OAAQpyB,EAAG9H,EAAGxD,GAEZ1N,IAER,CAEAm5B,eAAgB9lB,GAMf,OAJArT,KAAKgJ,EAAIqK,EAAE/W,EACX0D,KAAK+Y,EAAI1F,EAAE7W,EACXwD,KAAK0R,EAAI2B,EAAEyN,EAEJ9gB,IAER,CAEAgU,aAAcvF,GAEb,MAAMzF,EAAIhJ,KAAKgJ,EAAG+P,EAAI/Y,KAAK+Y,EAAGrH,EAAI1R,KAAK0R,EACjCxV,EAAIuS,EAAEwF,SAMZ,OAJAjU,KAAKgJ,EAAI9M,EAAG,GAAM8M,EAAI9M,EAAG,GAAM6c,EAAI7c,EAAG,GAAMwV,EAC5C1R,KAAK+Y,EAAI7c,EAAG,GAAM8M,EAAI9M,EAAG,GAAM6c,EAAI7c,EAAG,GAAMwV,EAC5C1R,KAAK0R,EAAIxV,EAAG,GAAM8M,EAAI9M,EAAG,GAAM6c,EAAI7c,EAAG,GAAMwV,EAErC1R,IAER,CAEAyV,OAAQ9D,GAEP,OAASA,EAAE3I,IAAMhJ,KAAKgJ,GAAS2I,EAAEoH,IAAM/Y,KAAK+Y,GAASpH,EAAED,IAAM1R,KAAK0R,CAEnE,CAEAgE,UAAWjI,EAAOkI,EAAS,GAM1B,OAJA3V,KAAKgJ,EAAIyE,EAAOkI,GAChB3V,KAAK+Y,EAAItL,EAAOkI,EAAS,GACzB3V,KAAK0R,EAAIjE,EAAOkI,EAAS,GAElB3V,IAER,CAEA4V,QAASnI,EAAQ,GAAIkI,EAAS,GAM7B,OAJAlI,EAAOkI,GAAW3V,KAAKgJ,EACvByE,EAAOkI,EAAS,GAAM3V,KAAK+Y,EAC3BtL,EAAOkI,EAAS,GAAM3V,KAAK0R,EAEpBjE,CAER,CAEAoI,oBAAqBC,EAAW/X,GAM/B,OAJAiC,KAAKgJ,EAAI8M,EAAUC,KAAMhY,GACzBiC,KAAK+Y,EAAIjD,EAAUE,KAAMjY,GACzBiC,KAAK0R,EAAIoE,EAAUyM,KAAMxkB,GAElBiC,IAER,CAEA+d,SAEC,OAAO/d,KAAKqmC,QAEb,CAEA,EAAGhlC,OAAOC,kBAEHtB,KAAKgJ,QACLhJ,KAAK+Y,QACL/Y,KAAK0R,CAEZ,EAID,MAAMq6B,GAAuB,IAAIhB,GAEjCA,GAAM+B,MAAQnC,GAEd,MAAMoC,WAA0BzJ,GAE/B/gC,YAAao9B,GAEZvgB,QAEApf,KAAKgtC,qBAAsB,EAE3BhtC,KAAK+M,KAAO,oBAEZ/M,KAAKwb,MAAQ,IAAIuvB,GAAO,UAExB/qC,KAAKC,IAAM,KAEXD,KAAKgoC,SAAW,KAChBhoC,KAAKioC,kBAAoB,EAEzBjoC,KAAKkoC,MAAQ,KACbloC,KAAKmoC,eAAiB,EAEtBnoC,KAAK+oC,YAAc,KAEnB/oC,KAAK+nC,SAAW,KAEhB/nC,KAAKkpC,OAAS,KACdlpC,KAAKmpC,QAAUx/B,EACf3J,KAAKqpC,aAAe,EACpBrpC,KAAKspC,gBAAkB,IAEvBtpC,KAAKmqC,WAAY,EACjBnqC,KAAKoqC,mBAAqB,EAC1BpqC,KAAKqqC,iBAAmB,QACxBrqC,KAAKsqC,kBAAoB,QAEzBtqC,KAAKwqC,KAAM,EAEXxqC,KAAKkmC,UAAWvG,EAEjB,CAEAvsB,KAAM3P,GA8BL,OA5BA2b,MAAMhM,KAAM3P,GAEZzD,KAAKwb,MAAMpI,KAAM3P,EAAO+X,OAExBxb,KAAKC,IAAMwD,EAAOxD,IAElBD,KAAKgoC,SAAWvkC,EAAOukC,SACvBhoC,KAAKioC,kBAAoBxkC,EAAOwkC,kBAEhCjoC,KAAKkoC,MAAQzkC,EAAOykC,MACpBloC,KAAKmoC,eAAiB1kC,EAAO0kC,eAE7BnoC,KAAK+oC,YAActlC,EAAOslC,YAE1B/oC,KAAK+nC,SAAWtkC,EAAOskC,SAEvB/nC,KAAKkpC,OAASzlC,EAAOylC,OACrBlpC,KAAKmpC,QAAU1lC,EAAO0lC,QACtBnpC,KAAKqpC,aAAe5lC,EAAO4lC,aAC3BrpC,KAAKspC,gBAAkB7lC,EAAO6lC,gBAE9BtpC,KAAKmqC,UAAY1mC,EAAO0mC,UACxBnqC,KAAKoqC,mBAAqB3mC,EAAO2mC,mBACjCpqC,KAAKqqC,iBAAmB5mC,EAAO4mC,iBAC/BrqC,KAAKsqC,kBAAoB7mC,EAAO6mC,kBAEhCtqC,KAAKwqC,IAAM/mC,EAAO+mC,IAEXxqC,IAER,EAwKD,MAKMitC,GAA0B,IAAI,GAC9BC,GAA2B,IAAIz6B,GAErC,MAAM,GAELlQ,YAAakL,EAAO0/B,EAAUC,GAAa,GAE1C,GAAKnsC,MAAME,QAASsM,GAEnB,MAAM,IAAI7K,UAAW,yDAItB5C,KAAKqtC,mBAAoB,EAEzBrtC,KAAKwC,KAAO,GAEZxC,KAAKyN,MAAQA,EACbzN,KAAKmtC,SAAWA,EAChBntC,KAAKiF,WAAkB9H,IAAVsQ,EAAsBA,EAAM9M,OAASwsC,EAAW,EAC7DntC,KAAKotC,WAAaA,EAElBptC,KAAKstC,MAAQ7gC,GACbzM,KAAKutC,YAAc,CAAE53B,OAAQ,EAAG1Q,OAAS,GACzCjF,KAAKwtC,QAAUriC,EAEfnL,KAAK6d,QAAU,CAEhB,CAEA4vB,mBAAoB,CAEhB3vB,gBAAa1gB,IAED,IAAVA,GAAiB4C,KAAK6d,SAE5B,CAEA6vB,SAAUtwC,GAIT,OAFA4C,KAAKstC,MAAQlwC,EAEN4C,IAER,CAEAoT,KAAM3P,GAWL,OATAzD,KAAKwC,KAAOiB,EAAOjB,KACnBxC,KAAKyN,MAAQ,IAAIhK,EAAOgK,MAAMlL,YAAakB,EAAOgK,OAClDzN,KAAKmtC,SAAW1pC,EAAO0pC,SACvBntC,KAAKiF,MAAQxB,EAAOwB,MACpBjF,KAAKotC,WAAa3pC,EAAO2pC,WAEzBptC,KAAKstC,MAAQ7pC,EAAO6pC,MACpBttC,KAAKwtC,QAAU/pC,EAAO+pC,QAEfxtC,IAER,CAEA2tC,OAAQC,EAAQ93B,EAAW+3B,GAE1BD,GAAU5tC,KAAKmtC,SACfU,GAAU/3B,EAAUq3B,SAEpB,IAAM,IAAI7sC,EAAI,EAAGoN,EAAI1N,KAAKmtC,SAAU7sC,EAAIoN,EAAGpN,IAE1CN,KAAKyN,MAAOmgC,EAASttC,GAAMwV,EAAUrI,MAAOogC,EAASvtC,GAItD,OAAON,IAER,CAEA8tC,UAAWrgC,GAIV,OAFAzN,KAAKyN,MAAM8E,IAAK9E,GAETzN,IAER,CAEAgU,aAAcvF,GAEb,GAAuB,IAAlBzO,KAAKmtC,SAET,IAAM,IAAI7sC,EAAI,EAAGoN,EAAI1N,KAAKiF,MAAO3E,EAAIoN,EAAGpN,IAEvC4sC,GAAWr3B,oBAAqB7V,KAAMM,GACtC4sC,GAAWl5B,aAAcvF,GAEzBzO,KAAK+tC,MAAOztC,EAAG4sC,GAAW5wC,EAAG4wC,GAAW1wC,QAInC,GAAuB,IAAlBwD,KAAKmtC,SAEhB,IAAM,IAAI7sC,EAAI,EAAGoN,EAAI1N,KAAKiF,MAAO3E,EAAIoN,EAAGpN,IAEvC2sC,GAAUp3B,oBAAqB7V,KAAMM,GACrC2sC,GAAUj5B,aAAcvF,GAExBzO,KAAKguC,OAAQ1tC,EAAG2sC,GAAU3wC,EAAG2wC,GAAUzwC,EAAGywC,GAAUnsB,GAMtD,OAAO9gB,IAER,CAEAmhB,aAAc1S,GAEb,IAAM,IAAInO,EAAI,EAAGoN,EAAI1N,KAAKiF,MAAO3E,EAAIoN,EAAGpN,IAEvC2sC,GAAUp3B,oBAAqB7V,KAAMM,GAErC2sC,GAAU9rB,aAAc1S,GAExBzO,KAAKguC,OAAQ1tC,EAAG2sC,GAAU3wC,EAAG2wC,GAAUzwC,EAAGywC,GAAUnsB,GAIrD,OAAO9gB,IAER,CAEAwoB,kBAAmB/Z,GAElB,IAAM,IAAInO,EAAI,EAAGoN,EAAI1N,KAAKiF,MAAO3E,EAAIoN,EAAGpN,IAEvC2sC,GAAUp3B,oBAAqB7V,KAAMM,GAErC2sC,GAAUzkB,kBAAmB/Z,GAE7BzO,KAAKguC,OAAQ1tC,EAAG2sC,GAAU3wC,EAAG2wC,GAAUzwC,EAAGywC,GAAUnsB,GAIrD,OAAO9gB,IAER,CAEAwpB,mBAAoB/a,GAEnB,IAAM,IAAInO,EAAI,EAAGoN,EAAI1N,KAAKiF,MAAO3E,EAAIoN,EAAGpN,IAEvC2sC,GAAUp3B,oBAAqB7V,KAAMM,GAErC2sC,GAAUzjB,mBAAoB/a,GAE9BzO,KAAKguC,OAAQ1tC,EAAG2sC,GAAU3wC,EAAG2wC,GAAUzwC,EAAGywC,GAAUnsB,GAIrD,OAAO9gB,IAER,CAEAuS,IAAKnV,EAAOuY,EAAS,GAKpB,OAFA3V,KAAKyN,MAAM8E,IAAKnV,EAAOuY,GAEhB3V,IAER,CAEA+V,KAAMhY,GAEL,IAAIzB,EAAI0D,KAAKyN,MAAO1P,EAAQiC,KAAKmtC,UAIjC,OAFKntC,KAAKotC,aAAa9wC,EAAI4S,GAAa5S,EAAG0D,KAAKyN,QAEzCnR,CAER,CAEAyW,KAAMhV,EAAOzB,GAMZ,OAJK0D,KAAKotC,aAAa9wC,EAAIoT,GAAWpT,EAAG0D,KAAKyN,QAE9CzN,KAAKyN,MAAO1P,EAAQiC,KAAKmtC,UAAa7wC,EAE/B0D,IAER,CAEAgW,KAAMjY,GAEL,IAAIvB,EAAIwD,KAAKyN,MAAO1P,EAAQiC,KAAKmtC,SAAW,GAI5C,OAFKntC,KAAKotC,aAAa5wC,EAAI0S,GAAa1S,EAAGwD,KAAKyN,QAEzCjR,CAER,CAEAwW,KAAMjV,EAAOvB,GAMZ,OAJKwD,KAAKotC,aAAa5wC,EAAIkT,GAAWlT,EAAGwD,KAAKyN,QAE9CzN,KAAKyN,MAAO1P,EAAQiC,KAAKmtC,SAAW,GAAM3wC,EAEnCwD,IAER,CAEAuiB,KAAMxkB,GAEL,IAAI+iB,EAAI9gB,KAAKyN,MAAO1P,EAAQiC,KAAKmtC,SAAW,GAI5C,OAFKntC,KAAKotC,aAAatsB,EAAI5R,GAAa4R,EAAG9gB,KAAKyN,QAEzCqT,CAER,CAEAG,KAAMljB,EAAO+iB,GAMZ,OAJK9gB,KAAKotC,aAAatsB,EAAIpR,GAAWoR,EAAG9gB,KAAKyN,QAE9CzN,KAAKyN,MAAO1P,EAAQiC,KAAKmtC,SAAW,GAAMrsB,EAEnC9gB,IAER,CAEAwiB,KAAMzkB,GAEL,IAAIgjB,EAAI/gB,KAAKyN,MAAO1P,EAAQiC,KAAKmtC,SAAW,GAI5C,OAFKntC,KAAKotC,aAAarsB,EAAI7R,GAAa6R,EAAG/gB,KAAKyN,QAEzCsT,CAER,CAEAG,KAAMnjB,EAAOgjB,GAMZ,OAJK/gB,KAAKotC,aAAarsB,EAAIrR,GAAWqR,EAAG/gB,KAAKyN,QAE9CzN,KAAKyN,MAAO1P,EAAQiC,KAAKmtC,SAAW,GAAMpsB,EAEnC/gB,IAER,CAEA+tC,MAAOhwC,EAAOzB,EAAGE,GAchB,OAZAuB,GAASiC,KAAKmtC,SAETntC,KAAKotC,aAET9wC,EAAIoT,GAAWpT,EAAG0D,KAAKyN,OACvBjR,EAAIkT,GAAWlT,EAAGwD,KAAKyN,QAIxBzN,KAAKyN,MAAO1P,EAAQ,GAAMzB,EAC1B0D,KAAKyN,MAAO1P,EAAQ,GAAMvB,EAEnBwD,IAER,CAEAguC,OAAQjwC,EAAOzB,EAAGE,EAAGskB,GAgBpB,OAdA/iB,GAASiC,KAAKmtC,SAETntC,KAAKotC,aAET9wC,EAAIoT,GAAWpT,EAAG0D,KAAKyN,OACvBjR,EAAIkT,GAAWlT,EAAGwD,KAAKyN,OACvBqT,EAAIpR,GAAWoR,EAAG9gB,KAAKyN,QAIxBzN,KAAKyN,MAAO1P,EAAQ,GAAMzB,EAC1B0D,KAAKyN,MAAO1P,EAAQ,GAAMvB,EAC1BwD,KAAKyN,MAAO1P,EAAQ,GAAM+iB,EAEnB9gB,IAER,CAEAiuC,QAASlwC,EAAOzB,EAAGE,EAAGskB,EAAGC,GAkBxB,OAhBAhjB,GAASiC,KAAKmtC,SAETntC,KAAKotC,aAET9wC,EAAIoT,GAAWpT,EAAG0D,KAAKyN,OACvBjR,EAAIkT,GAAWlT,EAAGwD,KAAKyN,OACvBqT,EAAIpR,GAAWoR,EAAG9gB,KAAKyN,OACvBsT,EAAIrR,GAAWqR,EAAG/gB,KAAKyN,QAIxBzN,KAAKyN,MAAO1P,EAAQ,GAAMzB,EAC1B0D,KAAKyN,MAAO1P,EAAQ,GAAMvB,EAC1BwD,KAAKyN,MAAO1P,EAAQ,GAAM+iB,EAC1B9gB,KAAKyN,MAAO1P,EAAQ,GAAMgjB,EAEnB/gB,IAER,CAEAkuC,SAAUjmB,GAIT,OAFAjoB,KAAKytC,iBAAmBxlB,EAEjBjoB,IAER,CAEAmT,QAEC,OAAO,IAAInT,KAAKuC,YAAavC,KAAKyN,MAAOzN,KAAKmtC,UAAW/5B,KAAMpT,KAEhE,CAEA+d,SAEC,MAAM1a,EAAO,CACZ8pC,SAAUntC,KAAKmtC,SACfpgC,KAAM/M,KAAKyN,MAAMlL,YAAYC,KAC7BiL,MAAOxM,MAAMwB,KAAMzC,KAAKyN,OACxB2/B,WAAYptC,KAAKotC,YAOlB,MAJmB,KAAdptC,KAAKwC,OAAca,EAAKb,KAAOxC,KAAKwC,MACpCxC,KAAKstC,QAAU7gC,KAAkBpJ,EAAKiqC,MAAQttC,KAAKstC,OACvB,IAA5BttC,KAAKutC,YAAY53B,SAA6C,IAA7B3V,KAAKutC,YAAYtoC,QAAgB5B,EAAKkqC,YAAcvtC,KAAKutC,aAExFlqC,CAER,EA8CD,MAAM8qC,WAA8B,GAEnC5rC,YAAakL,EAAO0/B,EAAUC,GAE7BhuB,MAAO,IAAI/P,YAAa5B,GAAS0/B,EAAUC,EAE5C,EAcD,MAAMgB,WAA8B,GAEnC7rC,YAAakL,EAAO0/B,EAAUC,GAE7BhuB,MAAO,IAAIhQ,YAAa3B,GAAS0/B,EAAUC,EAE5C,EA6JD,MAAM,WAA+B,GAEpC7qC,YAAakL,EAAO0/B,EAAUC,GAE7BhuB,MAAO,IAAIjQ,aAAc1B,GAAS0/B,EAAUC,EAE7C,EAcD,IAAIiB,GAAQ,EAEZ,MAAMC,GAAoB,IAAI7a,GACxB8a,GAAqB,IAAI3T,GACzB4T,GAAwB,IAAI,GAC5BC,GAAuB,IAAIpjB,GAC3BqjB,GAAiC,IAAIrjB,GACrCsjB,GAA0B,IAAI,GAEpC,MAAM,WAAuB7hC,GAE5BvK,cAEC6c,QAEApf,KAAK4uC,kBAAmB,EAExBxsC,OAAOuG,eAAgB3I,KAAM,KAAM,CAAE5C,MAAOixC,OAE5CruC,KAAK4d,KAAO7P,KAEZ/N,KAAKwC,KAAO,GACZxC,KAAK+M,KAAO,iBAEZ/M,KAAKjC,MAAQ,KACbiC,KAAK2F,WAAa,CAAC,EAEnB3F,KAAK6uC,gBAAkB,CAAC,EACxB7uC,KAAK8uC,sBAAuB,EAE5B9uC,KAAK+uC,OAAS,GAEd/uC,KAAK+sB,YAAc,KACnB/sB,KAAKgvC,eAAiB,KAEtBhvC,KAAKivC,UAAY,CAAEC,MAAO,EAAGjqC,MAAO4kC,KAEpC7pC,KAAK+f,SAAW,CAAC,CAElB,CAEAovB,WAEC,OAAOnvC,KAAKjC,KAEb,CAEAqxC,SAAUrxC,GAYT,OAVKkD,MAAME,QAASpD,GAEnBiC,KAAKjC,MAAQ,IAAM6c,GAAkB7c,GAAUqwC,GAAwBD,IAAyBpwC,EAAO,GAIvGiC,KAAKjC,MAAQA,EAIPiC,IAER,CAEAqvC,aAAc7sC,GAEb,OAAOxC,KAAK2F,WAAYnD,EAEzB,CAEAvF,aAAcuF,EAAMsT,GAInB,OAFA9V,KAAK2F,WAAYnD,GAASsT,EAEnB9V,IAER,CAEAsvC,gBAAiB9sC,GAIhB,cAFOxC,KAAK2F,WAAYnD,GAEjBxC,IAER,CAEAuvC,aAAc/sC,GAEb,YAAmCrF,IAA5B6C,KAAK2F,WAAYnD,EAEzB,CAEAgtC,SAAUN,EAAOjqC,EAAOwqC,EAAgB,GAEvCzvC,KAAK+uC,OAAOtvC,KAAM,CAEjByvC,MAAOA,EACPjqC,MAAOA,EACPwqC,cAAeA,GAIjB,CAEAC,cAEC1vC,KAAK+uC,OAAS,EAEf,CAEAY,aAAcT,EAAOjqC,GAEpBjF,KAAKivC,UAAUC,MAAQA,EACvBlvC,KAAKivC,UAAUhqC,MAAQA,CAExB,CAEAkc,aAAcxG,GAEb,MAAMyS,EAAWptB,KAAK2F,WAAWynB,cAEfjwB,IAAbiwB,IAEJA,EAASjM,aAAcxG,GAEvByS,EAAStP,aAAc,GAIxB,MAAMuM,EAASrqB,KAAK2F,WAAW0kB,OAE/B,QAAgBltB,IAAXktB,EAAuB,CAE3B,MAAM8Q,GAAe,IAAIhlB,IAAUsD,gBAAiBkB,GAEpD0P,EAAO7B,kBAAmB2S,GAE1B9Q,EAAOvM,aAAc,CAEtB,CAEA,MAAM8xB,EAAU5vC,KAAK2F,WAAWiqC,QAsBhC,YApBiBzyC,IAAZyyC,IAEJA,EAAQpmB,mBAAoB7O,GAE5Bi1B,EAAQ9xB,aAAc,GAIG,OAArB9d,KAAK+sB,aAET/sB,KAAKgtB,qBAIuB,OAAxBhtB,KAAKgvC,gBAEThvC,KAAK6vC,wBAIC7vC,IAER,CAEAqoB,gBAAiB5W,GAMhB,OAJA68B,GAAIjZ,2BAA4B5jB,GAEhCzR,KAAKmhB,aAAcmtB,IAEZtuC,IAER,CAEAs8B,QAAS1nB,GAQR,OAJA05B,GAAIxX,cAAeliB,GAEnB5U,KAAKmhB,aAAcmtB,IAEZtuC,IAER,CAEAu8B,QAAS3nB,GAQR,OAJA05B,GAAIvX,cAAeniB,GAEnB5U,KAAKmhB,aAAcmtB,IAEZtuC,IAER,CAEAw8B,QAAS5nB,GAQR,OAJA05B,GAAItX,cAAepiB,GAEnB5U,KAAKmhB,aAAcmtB,IAEZtuC,IAER,CAEAya,UAAWne,EAAGE,EAAGskB,GAQhB,OAJAwtB,GAAI5zB,gBAAiBpe,EAAGE,EAAGskB,GAE3B9gB,KAAKmhB,aAAcmtB,IAEZtuC,IAER,CAEAoa,MAAO9d,EAAGE,EAAGskB,GAQZ,OAJAwtB,GAAIh0B,UAAWhe,EAAGE,EAAGskB,GAErB9gB,KAAKmhB,aAAcmtB,IAEZtuC,IAER,CAEA+wB,OAAQnE,GAQP,OANA2hB,GAAKxd,OAAQnE,GAEb2hB,GAAKpuB,eAELngB,KAAKmhB,aAAcotB,GAAK5zB,QAEjB3a,IAER,CAEAkW,SAQC,OANAlW,KAAKgtB,qBAELhtB,KAAK+sB,YAAYP,UAAWgiB,IAAUj6B,SAEtCvU,KAAKya,UAAW+zB,GAAQlyC,EAAGkyC,GAAQhyC,EAAGgyC,GAAQ1tB,GAEvC9gB,IAER,CAEA6rB,cAAeC,GAEd,MAAMsB,EAAW,GAEjB,IAAM,IAAI9sB,EAAI,EAAGoN,EAAIoe,EAAOnrB,OAAQL,EAAIoN,EAAGpN,IAAO,CAEjD,MAAMosB,EAAQZ,EAAQxrB,GACtB8sB,EAAS3tB,KAAMitB,EAAMpwB,EAAGowB,EAAMlwB,EAAGkwB,EAAM5L,GAAK,EAE7C,CAIA,OAFA9gB,KAAK/C,aAAc,WAAY,IAAI,GAAwBmwB,EAAU,IAE9DptB,IAER,CAEAgtB,qBAE2B,OAArBhtB,KAAK+sB,cAET/sB,KAAK+sB,YAAc,IAAI1B,IAIxB,MAAM+B,EAAWptB,KAAK2F,WAAWynB,SAC3B0iB,EAA0B9vC,KAAK6uC,gBAAgBzhB,SAErD,GAAKA,GAAYA,EAAS2iB,oBASzB,OAPAzxC,QAAQ6+B,MAAO,kJAAmJn9B,WAElKA,KAAK+sB,YAAYxa,IAChB,IAAI,IAAS,KAAY,KAAY,KACrC,IAAI,GAAS,IAAY,IAAY,MAOvC,QAAkBpV,IAAbiwB,GAMJ,GAJAptB,KAAK+sB,YAAYnB,uBAAwBwB,GAIpC0iB,EAEJ,IAAM,IAAIxvC,EAAI,EAAGmrB,EAAKqkB,EAAwBnvC,OAAQL,EAAImrB,EAAInrB,IAAO,CAEpE,MAAM0vC,EAAiBF,EAAyBxvC,GAChDmuC,GAAO7iB,uBAAwBokB,GAE1BhwC,KAAK8uC,sBAETH,GAAUp7B,WAAYvT,KAAK+sB,YAAYpvB,IAAK8wC,GAAO9wC,KACnDqC,KAAK+sB,YAAYrB,cAAeijB,IAEhCA,GAAUp7B,WAAYvT,KAAK+sB,YAAYxe,IAAKkgC,GAAOlgC,KACnDvO,KAAK+sB,YAAYrB,cAAeijB,MAIhC3uC,KAAK+sB,YAAYrB,cAAe+iB,GAAO9wC,KACvCqC,KAAK+sB,YAAYrB,cAAe+iB,GAAOlgC,KAIzC,OAMDvO,KAAK+sB,YAAYvB,aAIbyH,MAAOjzB,KAAK+sB,YAAYpvB,IAAIrB,IAAO22B,MAAOjzB,KAAK+sB,YAAYpvB,IAAInB,IAAOy2B,MAAOjzB,KAAK+sB,YAAYpvB,IAAImjB,KAEtGxiB,QAAQ6+B,MAAO,sIAAuIn9B,KAIxJ,CAEA6vC,wBAE8B,OAAxB7vC,KAAKgvC,iBAEThvC,KAAKgvC,eAAiB,IAAIrf,IAI3B,MAAMvC,EAAWptB,KAAK2F,WAAWynB,SAC3B0iB,EAA0B9vC,KAAK6uC,gBAAgBzhB,SAErD,GAAKA,GAAYA,EAAS2iB,oBAMzB,OAJAzxC,QAAQ6+B,MAAO,wJAAyJn9B,WAExKA,KAAKgvC,eAAez8B,IAAK,IAAI,GAAWs3B,KAMzC,GAAKzc,EAAW,CAIf,MAAMlX,EAASlW,KAAKgvC,eAAe94B,OAMnC,GAJAu4B,GAAO7iB,uBAAwBwB,GAI1B0iB,EAEJ,IAAM,IAAIxvC,EAAI,EAAGmrB,EAAKqkB,EAAwBnvC,OAAQL,EAAImrB,EAAInrB,IAAO,CAEpE,MAAM0vC,EAAiBF,EAAyBxvC,GAChDouC,GAAiB9iB,uBAAwBokB,GAEpChwC,KAAK8uC,sBAETH,GAAUp7B,WAAYk7B,GAAO9wC,IAAK+wC,GAAiB/wC,KACnD8wC,GAAO/iB,cAAeijB,IAEtBA,GAAUp7B,WAAYk7B,GAAOlgC,IAAKmgC,GAAiBngC,KACnDkgC,GAAO/iB,cAAeijB,MAItBF,GAAO/iB,cAAegjB,GAAiB/wC,KACvC8wC,GAAO/iB,cAAegjB,GAAiBngC,KAIzC,CAIDkgC,GAAOjiB,UAAWtW,GAKlB,IAAI2Z,EAAc,EAElB,IAAM,IAAIvvB,EAAI,EAAGmrB,EAAK2B,EAASnoB,MAAO3E,EAAImrB,EAAInrB,IAE7CquC,GAAU94B,oBAAqBuX,EAAU9sB,GAEzCuvB,EAAc7xB,KAAKuQ,IAAKshB,EAAa3Z,EAAOhB,kBAAmBy5B,KAMhE,GAAKmB,EAEJ,IAAM,IAAIxvC,EAAI,EAAGmrB,EAAKqkB,EAAwBnvC,OAAQL,EAAImrB,EAAInrB,IAAO,CAEpE,MAAM0vC,EAAiBF,EAAyBxvC,GAC1CwuC,EAAuB9uC,KAAK8uC,qBAElC,IAAM,IAAI1f,EAAI,EAAG6gB,EAAKD,EAAe/qC,MAAOmqB,EAAI6gB,EAAI7gB,IAEnDuf,GAAU94B,oBAAqBm6B,EAAgB5gB,GAE1C0f,IAEJN,GAAQ34B,oBAAqBuX,EAAUgC,GACvCuf,GAAU3xC,IAAKwxC,KAIhB3e,EAAc7xB,KAAKuQ,IAAKshB,EAAa3Z,EAAOhB,kBAAmBy5B,IAIjE,CAID3uC,KAAKgvC,eAAevkB,OAASzsB,KAAKC,KAAM4xB,GAEnCoD,MAAOjzB,KAAKgvC,eAAevkB,SAE/BnsB,QAAQ6+B,MAAO,+HAAgIn9B,KAIjJ,CAED,CAEAkwC,kBAEC,MAAMnyC,EAAQiC,KAAKjC,MACb4H,EAAa3F,KAAK2F,WAKxB,GAAe,OAAV5H,QACqBZ,IAAxBwI,EAAWynB,eACWjwB,IAAtBwI,EAAW0kB,aACOltB,IAAlBwI,EAAWgb,GAGZ,YADAriB,QAAQ6+B,MAAO,gHAKhB,MAAMgT,EAAUpyC,EAAM0P,MAChB2iC,EAAYzqC,EAAWynB,SAAS3f,MAChC4iC,EAAU1qC,EAAW0kB,OAAO5c,MAC5B6iC,EAAM3qC,EAAWgb,GAAGlT,MAEpB8iC,EAAYH,EAAUzvC,OAAS,GAEG,IAAnCX,KAAKuvC,aAAc,YAEvBvvC,KAAK/C,aAAc,UAAW,IAAI,GAAiB,IAAIkS,aAAc,EAAIohC,GAAa,IAIvF,MAAMC,EAAWxwC,KAAKqvC,aAAc,WAAY5hC,MAE1CgjC,EAAO,GAAIC,EAAO,GAExB,IAAM,IAAIpwC,EAAI,EAAGA,EAAIiwC,EAAWjwC,IAE/BmwC,EAAMnwC,GAAM,IAAI,GAChBowC,EAAMpwC,GAAM,IAAI,GAIjB,MAAMqwC,EAAK,IAAI,GACdC,EAAK,IAAI,GACTC,EAAK,IAAI,GAETC,EAAM,IAAIr+B,GACVs+B,EAAM,IAAIt+B,GACVu+B,EAAM,IAAIv+B,GAEVw+B,EAAO,IAAI,GACXC,EAAO,IAAI,GAEZ,SAASC,EAAgB1oC,EAAGiJ,EAAGC,GAE9Bg/B,EAAGj7B,UAAW06B,EAAe,EAAJ3nC,GACzBmoC,EAAGl7B,UAAW06B,EAAe,EAAJ1+B,GACzBm/B,EAAGn7B,UAAW06B,EAAe,EAAJz+B,GAEzBm/B,EAAIp7B,UAAW46B,EAAS,EAAJ7nC,GACpBsoC,EAAIr7B,UAAW46B,EAAS,EAAJ5+B,GACpBs/B,EAAIt7B,UAAW46B,EAAS,EAAJ3+B,GAEpBi/B,EAAGn9B,IAAKk9B,GACRE,EAAGp9B,IAAKk9B,GAERI,EAAIt9B,IAAKq9B,GACTE,EAAIv9B,IAAKq9B,GAET,MAAM9nC,EAAI,GAAQ+nC,EAAIz0C,EAAI00C,EAAIx0C,EAAIw0C,EAAI10C,EAAIy0C,EAAIv0C,GAIvC40C,SAAUpoC,KAEjBioC,EAAK79B,KAAMw9B,GAAK/8B,eAAgBm9B,EAAIx0C,GAAIgX,gBAAiBq9B,GAAME,EAAIv0C,GAAIqX,eAAgB7K,GACvFkoC,EAAK99B,KAAMy9B,GAAKh9B,eAAgBk9B,EAAIz0C,GAAIkX,gBAAiBo9B,GAAMI,EAAI10C,GAAIuX,eAAgB7K,GAEvFynC,EAAMhoC,GAAIzL,IAAKi0C,GACfR,EAAM/+B,GAAI1U,IAAKi0C,GACfR,EAAM9+B,GAAI3U,IAAKi0C,GAEfP,EAAMjoC,GAAIzL,IAAKk0C,GACfR,EAAMh/B,GAAI1U,IAAKk0C,GACfR,EAAM/+B,GAAI3U,IAAKk0C,GAEhB,CAEA,IAAInC,EAAS/uC,KAAK+uC,OAEK,IAAlBA,EAAOpuC,SAEXouC,EAAS,CAAE,CACVG,MAAO,EACPjqC,MAAOkrC,EAAQxvC,UAKjB,IAAM,IAAIL,EAAI,EAAGmrB,EAAKsjB,EAAOpuC,OAAQL,EAAImrB,IAAOnrB,EAAI,CAEnD,MAAM+wC,EAAQtC,EAAQzuC,GAEhB4uC,EAAQmC,EAAMnC,MAGpB,IAAM,IAAI9f,EAAI8f,EAAOe,EAAKf,EAFZmC,EAAMpsC,MAEqBmqB,EAAI6gB,EAAI7gB,GAAK,EAErD+hB,EACChB,EAAS/gB,EAAI,GACb+gB,EAAS/gB,EAAI,GACb+gB,EAAS/gB,EAAI,GAKhB,CAEA,MAAM5V,EAAM,IAAI,GAAW83B,EAAO,IAAI,GAChCnvC,EAAI,IAAI,GAAWovC,EAAK,IAAI,GAElC,SAASC,EAAcn+B,GAEtBlR,EAAEuT,UAAW26B,EAAa,EAAJh9B,GACtBk+B,EAAGn+B,KAAMjR,GAET,MAAMwM,EAAI8hC,EAAMp9B,GAIhBmG,EAAIpG,KAAMzE,GACV6K,EAAI/F,IAAKtR,EAAE0R,eAAgB1R,EAAEqS,IAAK7F,KAAQe,YAI1C4hC,EAAK7nB,aAAc8nB,EAAI5iC,GACvB,MACMoS,EADOuwB,EAAK98B,IAAKk8B,EAAMr9B,IACV,GAAU,EAAM,EAEnCm9B,EAAc,EAAJn9B,GAAUmG,EAAIld,EACxBk0C,EAAc,EAAJn9B,EAAQ,GAAMmG,EAAIhd,EAC5Bg0C,EAAc,EAAJn9B,EAAQ,GAAMmG,EAAIsH,EAC5B0vB,EAAc,EAAJn9B,EAAQ,GAAM0N,CAEzB,CAEA,IAAM,IAAIzgB,EAAI,EAAGmrB,EAAKsjB,EAAOpuC,OAAQL,EAAImrB,IAAOnrB,EAAI,CAEnD,MAAM+wC,EAAQtC,EAAQzuC,GAEhB4uC,EAAQmC,EAAMnC,MAGpB,IAAM,IAAI9f,EAAI8f,EAAOe,EAAKf,EAFZmC,EAAMpsC,MAEqBmqB,EAAI6gB,EAAI7gB,GAAK,EAErDoiB,EAAcrB,EAAS/gB,EAAI,IAC3BoiB,EAAcrB,EAAS/gB,EAAI,IAC3BoiB,EAAcrB,EAAS/gB,EAAI,GAI7B,CAED,CAEAqiB,uBAEC,MAAM1zC,EAAQiC,KAAKjC,MACb2zC,EAAoB1xC,KAAKqvC,aAAc,YAE7C,QAA2BlyC,IAAtBu0C,EAAkC,CAEtC,IAAIC,EAAkB3xC,KAAKqvC,aAAc,UAEzC,QAAyBlyC,IAApBw0C,EAEJA,EAAkB,IAAI,GAAiB,IAAIxiC,aAAwC,EAA1BuiC,EAAkBzsC,OAAa,GACxFjF,KAAK/C,aAAc,SAAU00C,QAM7B,IAAM,IAAIrxC,EAAI,EAAGmrB,EAAKkmB,EAAgB1sC,MAAO3E,EAAImrB,EAAInrB,IAEpDqxC,EAAgB3D,OAAQ1tC,EAAG,EAAG,EAAG,GAMnC,MAAMsxC,EAAK,IAAI,GAAWC,EAAK,IAAI,GAAWC,EAAK,IAAI,GACjDC,EAAK,IAAI,GAAWC,EAAK,IAAI,GAAWC,EAAK,IAAI,GACjDC,EAAK,IAAI,GAAWC,EAAK,IAAI,GAInC,GAAKp0C,EAEJ,IAAM,IAAIuC,EAAI,EAAGmrB,EAAK1tB,EAAMkH,MAAO3E,EAAImrB,EAAInrB,GAAK,EAAI,CAEnD,MAAMqwC,EAAK5yC,EAAMgY,KAAMzV,EAAI,GACrBswC,EAAK7yC,EAAMgY,KAAMzV,EAAI,GACrBuwC,EAAK9yC,EAAMgY,KAAMzV,EAAI,GAE3BsxC,EAAG/7B,oBAAqB67B,EAAmBf,GAC3CkB,EAAGh8B,oBAAqB67B,EAAmBd,GAC3CkB,EAAGj8B,oBAAqB67B,EAAmBb,GAE3CqB,EAAGv+B,WAAYm+B,EAAID,GACnBM,EAAGx+B,WAAYi+B,EAAIC,GACnBK,EAAGz9B,MAAO09B,GAEVJ,EAAGl8B,oBAAqB87B,EAAiBhB,GACzCqB,EAAGn8B,oBAAqB87B,EAAiBf,GACzCqB,EAAGp8B,oBAAqB87B,EAAiBd,GAEzCkB,EAAG/0C,IAAKk1C,GACRF,EAAGh1C,IAAKk1C,GACRD,EAAGj1C,IAAKk1C,GAERP,EAAgB3D,OAAQ2C,EAAIoB,EAAGz1C,EAAGy1C,EAAGv1C,EAAGu1C,EAAGjxB,GAC3C6wB,EAAgB3D,OAAQ4C,EAAIoB,EAAG11C,EAAG01C,EAAGx1C,EAAGw1C,EAAGlxB,GAC3C6wB,EAAgB3D,OAAQ6C,EAAIoB,EAAG31C,EAAG21C,EAAGz1C,EAAGy1C,EAAGnxB,EAE5C,MAMA,IAAM,IAAIxgB,EAAI,EAAGmrB,EAAKimB,EAAkBzsC,MAAO3E,EAAImrB,EAAInrB,GAAK,EAE3DsxC,EAAG/7B,oBAAqB67B,EAAmBpxC,EAAI,GAC/CuxC,EAAGh8B,oBAAqB67B,EAAmBpxC,EAAI,GAC/CwxC,EAAGj8B,oBAAqB67B,EAAmBpxC,EAAI,GAE/C4xC,EAAGv+B,WAAYm+B,EAAID,GACnBM,EAAGx+B,WAAYi+B,EAAIC,GACnBK,EAAGz9B,MAAO09B,GAEVR,EAAgB3D,OAAQ1tC,EAAI,EAAG4xC,EAAG51C,EAAG41C,EAAG11C,EAAG01C,EAAGpxB,GAC9C6wB,EAAgB3D,OAAQ1tC,EAAI,EAAG4xC,EAAG51C,EAAG41C,EAAG11C,EAAG01C,EAAGpxB,GAC9C6wB,EAAgB3D,OAAQ1tC,EAAI,EAAG4xC,EAAG51C,EAAG41C,EAAG11C,EAAG01C,EAAGpxB,GAMhD9gB,KAAKoyC,mBAELT,EAAgB7zB,aAAc,CAE/B,CAED,CAEAs0B,mBAEC,MAAM/B,EAAUrwC,KAAK2F,WAAW0kB,OAEhC,IAAM,IAAI/pB,EAAI,EAAGmrB,EAAK4kB,EAAQprC,MAAO3E,EAAImrB,EAAInrB,IAE5CquC,GAAU94B,oBAAqBw6B,EAAS/vC,GAExCquC,GAAUj/B,YAEV2gC,EAAQrC,OAAQ1tC,EAAGquC,GAAUryC,EAAGqyC,GAAUnyC,EAAGmyC,GAAU7tB,EAIzD,CAEAuxB,eAEC,SAASC,EAAwBx8B,EAAWq6B,GAE3C,MAAM1iC,EAAQqI,EAAUrI,MAClB0/B,EAAWr3B,EAAUq3B,SACrBC,EAAat3B,EAAUs3B,WAEvBmF,EAAS,IAAI9kC,EAAMlL,YAAa4tC,EAAQxvC,OAASwsC,GAEvD,IAAIpvC,EAAQ,EAAG8vC,EAAS,EAExB,IAAM,IAAIvtC,EAAI,EAAGoN,EAAIyiC,EAAQxvC,OAAQL,EAAIoN,EAAGpN,IAAO,CAIjDvC,EAFI+X,EAAU08B,6BAENrC,EAAS7vC,GAAMwV,EAAUzS,KAAKovC,OAAS38B,EAAUH,OAIjDw6B,EAAS7vC,GAAM6sC,EAIxB,IAAM,IAAI/d,EAAI,EAAGA,EAAI+d,EAAU/d,IAE9BmjB,EAAQ1E,KAAcpgC,EAAO1P,IAI/B,CAEA,OAAO,IAAI,GAAiBw0C,EAAQpF,EAAUC,EAE/C,CAIA,GAAoB,OAAfptC,KAAKjC,MAGT,OADAO,QAAQkU,KAAM,+EACPxS,KAIR,MAAM0yC,EAAY,IAAI,GAEhBvC,EAAUnwC,KAAKjC,MAAM0P,MACrB9H,EAAa3F,KAAK2F,WAIxB,IAAM,MAAMnD,KAAQmD,EAAa,CAEhC,MAEMgtC,EAAeL,EAFH3sC,EAAYnD,GAE0B2tC,GAExDuC,EAAUz1C,aAAcuF,EAAMmwC,EAE/B,CAIA,MAAM9D,EAAkB7uC,KAAK6uC,gBAE7B,IAAM,MAAMrsC,KAAQqsC,EAAkB,CAErC,MAAM+D,EAAa,GACb5C,EAAiBnB,EAAiBrsC,GAExC,IAAM,IAAIlC,EAAI,EAAGmrB,EAAKukB,EAAervC,OAAQL,EAAImrB,EAAInrB,IAAO,CAE3D,MAEMqyC,EAAeL,EAFHtC,EAAgB1vC,GAEsB6vC,GAExDyC,EAAWnzC,KAAMkzC,EAElB,CAEAD,EAAU7D,gBAAiBrsC,GAASowC,CAErC,CAEAF,EAAU5D,qBAAuB9uC,KAAK8uC,qBAItC,MAAMC,EAAS/uC,KAAK+uC,OAEpB,IAAM,IAAIzuC,EAAI,EAAGoN,EAAIqhC,EAAOpuC,OAAQL,EAAIoN,EAAGpN,IAAO,CAEjD,MAAM+wC,EAAQtC,EAAQzuC,GACtBoyC,EAAUlD,SAAU6B,EAAMnC,MAAOmC,EAAMpsC,MAAOosC,EAAM5B,cAErD,CAEA,OAAOiD,CAER,CAEA30B,SAEC,MAAM1a,EAAO,CACZid,SAAU,CACTzC,QAAS,IACT9Q,KAAM,iBACNwT,UAAW,0BAWb,GALAld,EAAKua,KAAO5d,KAAK4d,KACjBva,EAAK0J,KAAO/M,KAAK+M,KACE,KAAd/M,KAAKwC,OAAca,EAAKb,KAAOxC,KAAKwC,MACpCJ,OAAOyD,KAAM7F,KAAK+f,UAAWpf,OAAS,IAAI0C,EAAK0c,SAAW/f,KAAK+f,eAE3C5iB,IAApB6C,KAAK2/B,WAA2B,CAEpC,MAAMA,EAAa3/B,KAAK2/B,WAExB,IAAM,MAAM55B,KAAO45B,OAESxiC,IAAtBwiC,EAAY55B,KAAsB1C,EAAM0C,GAAQ45B,EAAY55B,IAIlE,OAAO1C,CAER,CAIAA,EAAKA,KAAO,CAAEsC,WAAY,CAAC,GAE3B,MAAM5H,EAAQiC,KAAKjC,MAEJ,OAAVA,IAEJsF,EAAKA,KAAKtF,MAAQ,CACjBgP,KAAMhP,EAAM0P,MAAMlL,YAAYC,KAC9BiL,MAAOxM,MAAMoB,UAAUC,MAAMV,KAAM7D,EAAM0P,SAK3C,MAAM9H,EAAa3F,KAAK2F,WAExB,IAAM,MAAMI,KAAOJ,EAAa,CAE/B,MAAMmQ,EAAYnQ,EAAYI,GAE9B1C,EAAKA,KAAKsC,WAAYI,GAAQ+P,EAAUiI,OAAQ1a,EAAKA,KAEtD,CAEA,MAAMwrC,EAAkB,CAAC,EACzB,IAAIgE,GAAqB,EAEzB,IAAM,MAAM9sC,KAAO/F,KAAK6uC,gBAAkB,CAEzC,MAAMiE,EAAiB9yC,KAAK6uC,gBAAiB9oC,GAEvC0H,EAAQ,GAEd,IAAM,IAAInN,EAAI,EAAGmrB,EAAKqnB,EAAenyC,OAAQL,EAAImrB,EAAInrB,IAAO,CAE3D,MAAMwV,EAAYg9B,EAAgBxyC,GAElCmN,EAAMhO,KAAMqW,EAAUiI,OAAQ1a,EAAKA,MAEpC,CAEKoK,EAAM9M,OAAS,IAEnBkuC,EAAiB9oC,GAAQ0H,EAEzBolC,GAAqB,EAIvB,CAEKA,IAEJxvC,EAAKA,KAAKwrC,gBAAkBA,EAC5BxrC,EAAKA,KAAKyrC,qBAAuB9uC,KAAK8uC,sBAIvC,MAAMC,EAAS/uC,KAAK+uC,OAEfA,EAAOpuC,OAAS,IAEpB0C,EAAKA,KAAK0rC,OAAS5rC,KAAKid,MAAOjd,KAAKC,UAAW2rC,KAIhD,MAAMC,EAAiBhvC,KAAKgvC,eAW5B,OATwB,OAAnBA,IAEJ3rC,EAAKA,KAAK2rC,eAAiB,CAC1B94B,OAAQ84B,EAAe94B,OAAON,UAC9B6U,OAAQukB,EAAevkB,SAKlBpnB,CAER,CAEA8P,QAEC,OAAO,IAAInT,KAAKuC,aAAc6Q,KAAMpT,KAErC,CAEAoT,KAAM3P,GAILzD,KAAKjC,MAAQ,KACbiC,KAAK2F,WAAa,CAAC,EACnB3F,KAAK6uC,gBAAkB,CAAC,EACxB7uC,KAAK+uC,OAAS,GACd/uC,KAAK+sB,YAAc,KACnB/sB,KAAKgvC,eAAiB,KAItB,MAAM3rC,EAAO,CAAC,EAIdrD,KAAKwC,KAAOiB,EAAOjB,KAInB,MAAMzE,EAAQ0F,EAAO1F,MAEN,OAAVA,GAEJiC,KAAKovC,SAAUrxC,EAAMoV,MAAO9P,IAM7B,MAAMsC,EAAalC,EAAOkC,WAE1B,IAAM,MAAMnD,KAAQmD,EAAa,CAEhC,MAAMmQ,EAAYnQ,EAAYnD,GAC9BxC,KAAK/C,aAAcuF,EAAMsT,EAAU3C,MAAO9P,GAE3C,CAIA,MAAMwrC,EAAkBprC,EAAOorC,gBAE/B,IAAM,MAAMrsC,KAAQqsC,EAAkB,CAErC,MAAMphC,EAAQ,GACRuiC,EAAiBnB,EAAiBrsC,GAExC,IAAM,IAAIlC,EAAI,EAAGoN,EAAIsiC,EAAervC,OAAQL,EAAIoN,EAAGpN,IAElDmN,EAAMhO,KAAMuwC,EAAgB1vC,GAAI6S,MAAO9P,IAIxCrD,KAAK6uC,gBAAiBrsC,GAASiL,CAEhC,CAEAzN,KAAK8uC,qBAAuBrrC,EAAOqrC,qBAInC,MAAMC,EAAStrC,EAAOsrC,OAEtB,IAAM,IAAIzuC,EAAI,EAAGoN,EAAIqhC,EAAOpuC,OAAQL,EAAIoN,EAAGpN,IAAO,CAEjD,MAAM+wC,EAAQtC,EAAQzuC,GACtBN,KAAKwvC,SAAU6B,EAAMnC,MAAOmC,EAAMpsC,MAAOosC,EAAM5B,cAEhD,CAIA,MAAM1iB,EAActpB,EAAOspB,YAEN,OAAhBA,IAEJ/sB,KAAK+sB,YAAcA,EAAY5Z,SAMhC,MAAM67B,EAAiBvrC,EAAOurC,eAiB9B,OAfwB,OAAnBA,IAEJhvC,KAAKgvC,eAAiBA,EAAe77B,SAMtCnT,KAAKivC,UAAUC,MAAQzrC,EAAOwrC,UAAUC,MACxClvC,KAAKivC,UAAUhqC,MAAQxB,EAAOwrC,UAAUhqC,MAIxCjF,KAAK+f,SAAWtc,EAAOsc,SAEhB/f,IAER,CAEAygB,UAECzgB,KAAKuN,cAAe,CAAER,KAAM,WAE7B,EAID,MAAMgmC,GAAiC,IAAItf,GACrCuf,GAAuB,IAAItiB,GAC3BuiB,GAA0B,IAAItjB,GAC9BujB,GAA6B,IAAI,GAEjCC,GAAsB,IAAI,GAC1BC,GAAsB,IAAI,GAC1BC,GAAsB,IAAI,GAE1BC,GAAuB,IAAI,GAC3BC,GAAwB,IAAI,GAE5BC,GAAuB,IAAI/gC,GAC3BghC,GAAuB,IAAIhhC,GAC3BihC,GAAuB,IAAIjhC,GAE3BkhC,GAAyB,IAAI,GAC7BC,GAAyB,IAAI,GAC7BC,GAAyB,IAAI,GAE7BC,GAAmC,IAAI,GACvCC,GAAwC,IAAI,GAElD,MAAMC,WAAapZ,GAElBr4B,YAAa4qB,EAAW,IAAI,GAAkB8S,EAAW,IAAI8M,IAE5D3tB,QAEApf,KAAKw/B,QAAS,EAEdx/B,KAAK+M,KAAO,OAEZ/M,KAAKmtB,SAAWA,EAChBntB,KAAKigC,SAAWA,EAEhBjgC,KAAKi0C,oBAEN,CAEA7gC,KAAM3P,EAAQ88B,GAmBb,OAjBAnhB,MAAMhM,KAAM3P,EAAQ88B,QAEkBpjC,IAAjCsG,EAAOywC,wBAEXl0C,KAAKk0C,sBAAwBzwC,EAAOywC,sBAAsB5xC,cAIrBnF,IAAjCsG,EAAO0wC,wBAEXn0C,KAAKm0C,sBAAwB/xC,OAAOihB,OAAQ,CAAC,EAAG5f,EAAO0wC,wBAIxDn0C,KAAKigC,SAAWx8B,EAAOw8B,SACvBjgC,KAAKmtB,SAAW1pB,EAAO0pB,SAEhBntB,IAER,CAEAi0C,qBAEC,MAEMpF,EAFW7uC,KAAKmtB,SAEW0hB,gBAC3BhpC,EAAOzD,OAAOyD,KAAMgpC,GAE1B,GAAKhpC,EAAKlF,OAAS,EAAI,CAEtB,MAAMqvC,EAAiBnB,EAAiBhpC,EAAM,IAE9C,QAAwB1I,IAAnB6yC,EAA+B,CAEnChwC,KAAKk0C,sBAAwB,GAC7Bl0C,KAAKm0C,sBAAwB,CAAC,EAE9B,IAAM,IAAI1lC,EAAI,EAAG2lC,EAAKpE,EAAervC,OAAQ8N,EAAI2lC,EAAI3lC,IAAO,CAE3D,MAAMjM,EAAOwtC,EAAgBvhC,GAAIjM,MAAQ6xC,OAAQ5lC,GAEjDzO,KAAKk0C,sBAAsBz0C,KAAM,GACjCO,KAAKm0C,sBAAuB3xC,GAASiM,CAEtC,CAED,CAED,CAED,CAEA6lC,kBAAmBv2C,EAAOqG,GAEzB,MAAM+oB,EAAWntB,KAAKmtB,SAChBC,EAAWD,EAASxnB,WAAWynB,SAC/BmnB,EAAgBpnB,EAAS0hB,gBAAgBzhB,SACzC0hB,EAAuB3hB,EAAS2hB,qBAEtC1qC,EAAOyR,oBAAqBuX,EAAUrvB,GAEtC,MAAMy2C,EAAkBx0C,KAAKk0C,sBAE7B,GAAKK,GAAiBC,EAAkB,CAEvCjB,GAAQhhC,IAAK,EAAG,EAAG,GAEnB,IAAM,IAAIjS,EAAI,EAAGmrB,EAAK8oB,EAAc5zC,OAAQL,EAAImrB,EAAInrB,IAAO,CAE1D,MAAMm0C,EAAYD,EAAiBl0C,GAC7B0vC,EAAiBuE,EAAej0C,GAEnB,IAAdm0C,IAELnB,GAAOz9B,oBAAqBm6B,EAAgBjyC,GAEvC+wC,EAEJyE,GAAQ//B,gBAAiB8/B,GAAQmB,GAIjClB,GAAQ//B,gBAAiB8/B,GAAO7/B,IAAKrP,GAAUqwC,GAIjD,CAEArwC,EAAOpH,IAAKu2C,GAEb,CAEA,OAAOnvC,CAER,CAEA45B,QAAS0W,EAAWC,GAEnB,MAAMxnB,EAAWntB,KAAKmtB,SAChB8S,EAAWjgC,KAAKigC,SAChB1W,EAAcvpB,KAAKupB,YAEzB,QAAkBpsB,IAAb8iC,EAAL,CAaA,GATiC,OAA5B9S,EAAS6hB,gBAA0B7hB,EAAS0iB,wBAEjDoD,GAAU7/B,KAAM+Z,EAAS6hB,gBACzBiE,GAAU9xB,aAAcoI,GAIxBypB,GAAO5/B,KAAMshC,EAAU7jB,KAAMG,OAAQ0jB,EAAUpc,OAEG,IAA7C2a,GAAU3lB,cAAe0lB,GAAOriB,QAAqB,CAEzD,GAA2D,OAAtDqiB,GAAOlhB,gBAAiBmhB,GAAWC,IAA0B,OAElE,GAAKF,GAAOriB,OAAOzb,kBAAmBg+B,KAAmBwB,EAAUnc,IAAMmc,EAAUpc,OAAU,EAAI,MAElG,CAIAya,GAAiB3/B,KAAMmW,GAActQ,SACrC+5B,GAAO5/B,KAAMshC,EAAU7jB,KAAM1P,aAAc4xB,IAIb,OAAzB5lB,EAASJ,cAEyC,IAAjDimB,GAAOvlB,cAAeN,EAASJ,cAMrC/sB,KAAK40C,sBAAuBF,EAAWC,EAAY3B,GApCf,CAsCrC,CAEA4B,sBAAuBF,EAAWC,EAAYE,GAE7C,IAAIC,EAEJ,MAAM3nB,EAAWntB,KAAKmtB,SAChB8S,EAAWjgC,KAAKigC,SAEhBliC,EAAQovB,EAASpvB,MACjBqvB,EAAWD,EAASxnB,WAAWynB,SAC/BzM,EAAKwM,EAASxnB,WAAWgb,GACzBmhB,EAAM3U,EAASxnB,WAAWm8B,IAC1BzX,EAAS8C,EAASxnB,WAAW0kB,OAC7B0kB,EAAS5hB,EAAS4hB,OAClBE,EAAY9hB,EAAS8hB,UAE3B,GAAe,OAAVlxC,EAIJ,GAAKkD,MAAME,QAAS8+B,GAEnB,IAAM,IAAI3/B,EAAI,EAAGmrB,EAAKsjB,EAAOpuC,OAAQL,EAAImrB,EAAInrB,IAAO,CAEnD,MAAM+wC,EAAQtC,EAAQzuC,GAChBy0C,EAAgB9U,EAAUoR,EAAM5B,eAKtC,IAAM,IAAIrgB,EAHIpxB,KAAKuQ,IAAK8iC,EAAMnC,MAAOD,EAAUC,OAG1Be,EAFTjyC,KAAKL,IAAKI,EAAMkH,MAAOjH,KAAKL,IAAO0zC,EAAMnC,MAAQmC,EAAMpsC,MAAWgqC,EAAUC,MAAQD,EAAUhqC,QAE3EmqB,EAAI6gB,EAAI7gB,GAAK,EAM3C0lB,EAAeE,GAA2Bh1C,KAAM+0C,EAAeL,EAAWG,EAAel0B,EAAImhB,EAAKzX,EAJxFtsB,EAAMgY,KAAMqZ,GACZrxB,EAAMgY,KAAMqZ,EAAI,GAChBrxB,EAAMgY,KAAMqZ,EAAI,IAIrB0lB,IAEJA,EAAaG,UAAYj3C,KAAKK,MAAO+wB,EAAI,GACzC0lB,EAAaI,KAAKzF,cAAgB4B,EAAM5B,cACxCkF,EAAWl1C,KAAMq1C,GAMpB,MAOA,IAAM,IAAIx0C,EAHItC,KAAKuQ,IAAK,EAAG0gC,EAAUC,OAGhBzjB,EAFTztB,KAAKL,IAAKI,EAAMkH,MAASgqC,EAAUC,MAAQD,EAAUhqC,OAElC3E,EAAImrB,EAAInrB,GAAK,EAM3Cw0C,EAAeE,GAA2Bh1C,KAAMigC,EAAUyU,EAAWG,EAAel0B,EAAImhB,EAAKzX,EAJnFtsB,EAAMgY,KAAMzV,GACZvC,EAAMgY,KAAMzV,EAAI,GAChBvC,EAAMgY,KAAMzV,EAAI,IAIrBw0C,IAEJA,EAAaG,UAAYj3C,KAAKK,MAAOiC,EAAI,GACzCq0C,EAAWl1C,KAAMq1C,SAQd,QAAkB33C,IAAbiwB,EAIX,GAAKnsB,MAAME,QAAS8+B,GAEnB,IAAM,IAAI3/B,EAAI,EAAGmrB,EAAKsjB,EAAOpuC,OAAQL,EAAImrB,EAAInrB,IAAO,CAEnD,MAAM+wC,EAAQtC,EAAQzuC,GAChBy0C,EAAgB9U,EAAUoR,EAAM5B,eAKtC,IAAM,IAAIrgB,EAHIpxB,KAAKuQ,IAAK8iC,EAAMnC,MAAOD,EAAUC,OAG1Be,EAFTjyC,KAAKL,IAAKyvB,EAASnoB,MAAOjH,KAAKL,IAAO0zC,EAAMnC,MAAQmC,EAAMpsC,MAAWgqC,EAAUC,MAAQD,EAAUhqC,QAE9EmqB,EAAI6gB,EAAI7gB,GAAK,EAM3C0lB,EAAeE,GAA2Bh1C,KAAM+0C,EAAeL,EAAWG,EAAel0B,EAAImhB,EAAKzX,EAJxF+E,EACAA,EAAI,EACJA,EAAI,GAIT0lB,IAEJA,EAAaG,UAAYj3C,KAAKK,MAAO+wB,EAAI,GACzC0lB,EAAaI,KAAKzF,cAAgB4B,EAAM5B,cACxCkF,EAAWl1C,KAAMq1C,GAMpB,MAOA,IAAM,IAAIx0C,EAHItC,KAAKuQ,IAAK,EAAG0gC,EAAUC,OAGhBzjB,EAFTztB,KAAKL,IAAKyvB,EAASnoB,MAASgqC,EAAUC,MAAQD,EAAUhqC,OAErC3E,EAAImrB,EAAInrB,GAAK,EAM3Cw0C,EAAeE,GAA2Bh1C,KAAMigC,EAAUyU,EAAWG,EAAel0B,EAAImhB,EAAKzX,EAJnF/pB,EACAA,EAAI,EACJA,EAAI,GAITw0C,IAEJA,EAAaG,UAAYj3C,KAAKK,MAAOiC,EAAI,GACzCq0C,EAAWl1C,KAAMq1C,GAUtB,EAmCD,SAASE,GAA2B7oB,EAAQ8T,EAAUyU,EAAW7jB,EAAKlQ,EAAImhB,EAAKzX,EAAQ5hB,EAAGiJ,EAAGC,GAE5Fwa,EAAOmoB,kBAAmB7rC,EAAG0qC,IAC7BhnB,EAAOmoB,kBAAmB5iC,EAAG0hC,IAC7BjnB,EAAOmoB,kBAAmB3iC,EAAG0hC,IAE7B,MAAMyB,EArCP,SAA4B3oB,EAAQ8T,EAAUyU,EAAW7jB,EAAK+gB,EAAIC,EAAIC,EAAIplB,GAEzE,IAAIqC,EAYJ,GARCA,EAh8We,IA87WXkR,EAASwD,KAED5S,EAAIqC,kBAAmB4e,EAAID,EAAID,GAAI,EAAMllB,GAIzCmE,EAAIqC,kBAAmB0e,EAAIC,EAAIC,EAAM7R,EAASwD,OAASj6B,EAAakjB,GAI9D,OAAdqC,EAAqB,OAAO,KAEjCglB,GAAwB3gC,KAAMsZ,GAC9BqnB,GAAwB5yB,aAAcgL,EAAO5C,aAE7C,MAAMmT,EAAWgY,EAAU7jB,IAAIF,OAAO1b,WAAY8+B,IAElD,OAAKrX,EAAWgY,EAAUpc,MAAQoE,EAAWgY,EAAUnc,IAAa,KAE7D,CACNmE,SAAUA,EACVhQ,MAAOqnB,GAAwB5gC,QAC/BgZ,OAAQA,EAGV,CAQsBgpB,CAAmBhpB,EAAQ8T,EAAUyU,EAAW7jB,EAAKsiB,GAAOC,GAAOC,GAAOS,IAE/F,GAAKgB,EAAe,CAEdn0B,IAEJ6yB,GAAO39B,oBAAqB8K,EAAIlY,GAChCgrC,GAAO59B,oBAAqB8K,EAAIjP,GAChCgiC,GAAO79B,oBAAqB8K,EAAIhP,GAEhCmjC,EAAan0B,GAAKwgB,GAASc,iBAAkB6R,GAAoBX,GAAOC,GAAOC,GAAOG,GAAQC,GAAQC,GAAQ,IAAIjhC,KAI9GqvB,IAEJ0R,GAAO39B,oBAAqBisB,EAAKr5B,GACjCgrC,GAAO59B,oBAAqBisB,EAAKpwB,GACjCgiC,GAAO79B,oBAAqBisB,EAAKnwB,GAEjCmjC,EAAahT,IAAMX,GAASc,iBAAkB6R,GAAoBX,GAAOC,GAAOC,GAAOG,GAAQC,GAAQC,GAAQ,IAAIjhC,IACnHqiC,EAAa/S,IAAM+S,EAAahT,KAI5BzX,IAEJspB,GAAS99B,oBAAqBwU,EAAQ5hB,GACtCmrC,GAAS/9B,oBAAqBwU,EAAQ3Y,GACtCmiC,GAASh+B,oBAAqBwU,EAAQ1Y,GAEtCmjC,EAAazqB,OAAS8W,GAASc,iBAAkB6R,GAAoBX,GAAOC,GAAOC,GAAOM,GAAUC,GAAUC,GAAU,IAAI,IAEvHiB,EAAazqB,OAAO7V,IAAKqc,EAAID,WAAc,GAE/CkkB,EAAazqB,OAAOxW,gBAAkB,IAMxC,MAAMqhC,EAAO,CACZzsC,EAAGA,EACHiJ,EAAGA,EACHC,EAAGA,EACH0Y,OAAQ,IAAI,GACZolB,cAAe,GAGhBtO,GAASuB,UAAWyQ,GAAOC,GAAOC,GAAO6B,EAAK7qB,QAE9CyqB,EAAaI,KAAOA,CAErB,CAEA,OAAOJ,CAER,CAEA,MAAMM,WAAoB,GAEzB7yC,YAAaoQ,EAAQ,EAAGC,EAAS,EAAG+P,EAAQ,EAAG0yB,EAAgB,EAAGC,EAAiB,EAAGC,EAAgB,GAErGn2B,QAEApf,KAAK+M,KAAO,cAEZ/M,KAAK2/B,WAAa,CACjBhtB,MAAOA,EACPC,OAAQA,EACR+P,MAAOA,EACP0yB,cAAeA,EACfC,eAAgBA,EAChBC,cAAeA,GAGhB,MAAMC,EAAQx1C,KAIdq1C,EAAgBr3C,KAAKK,MAAOg3C,GAC5BC,EAAiBt3C,KAAKK,MAAOi3C,GAC7BC,EAAgBv3C,KAAKK,MAAOk3C,GAI5B,MAAMpF,EAAU,GACVsF,EAAW,GACXpF,EAAU,GACVC,EAAM,GAIZ,IAAIoF,EAAmB,EACnBC,EAAa,EAkBjB,SAASC,EAAYxqB,EAAG/X,EAAG0N,EAAG80B,EAAMC,EAAMnjC,EAAOC,EAAQ+P,EAAOozB,EAAOC,EAAOvG,GAE7E,MAAMwG,EAAetjC,EAAQojC,EACvBG,EAAgBtjC,EAASojC,EAEzBG,EAAYxjC,EAAQ,EACpByjC,EAAaxjC,EAAS,EACtByjC,EAAY1zB,EAAQ,EAEpB2zB,EAASP,EAAQ,EACjBQ,EAASP,EAAQ,EAEvB,IAAIQ,EAAgB,EAChBC,EAAa,EAEjB,MAAM7pB,EAAS,IAAI,GAInB,IAAM,IAAI9D,EAAK,EAAGA,EAAKytB,EAAQztB,IAAQ,CAEtC,MAAMtsB,EAAIssB,EAAKotB,EAAgBE,EAE/B,IAAM,IAAIvtB,EAAK,EAAGA,EAAKytB,EAAQztB,IAAQ,CAEtC,MAAMvsB,EAAIusB,EAAKotB,EAAeE,EAI9BvpB,EAAQxB,GAAM9uB,EAAIu5C,EAClBjpB,EAAQvZ,GAAM7W,EAAIs5C,EAClBlpB,EAAQ7L,GAAMs1B,EAIdZ,EAASh2C,KAAMmtB,EAAOtwB,EAAGswB,EAAOpwB,EAAGowB,EAAO9L,GAI1C8L,EAAQxB,GAAM,EACdwB,EAAQvZ,GAAM,EACduZ,EAAQ7L,GAAM4B,EAAQ,EAAI,GAAM,EAIhC0tB,EAAQ5wC,KAAMmtB,EAAOtwB,EAAGswB,EAAOpwB,EAAGowB,EAAO9L,GAIzCwvB,EAAI7wC,KAAMopB,EAAKktB,GACfzF,EAAI7wC,KAAM,EAAMqpB,EAAKktB,GAIrBQ,GAAiB,CAElB,CAED,CAQA,IAAM,IAAI1tB,EAAK,EAAGA,EAAKktB,EAAOltB,IAE7B,IAAM,IAAID,EAAK,EAAGA,EAAKktB,EAAOltB,IAAQ,CAErC,MAAMpgB,EAAIitC,EAAmB7sB,EAAKytB,EAASxtB,EACrCpX,EAAIgkC,EAAmB7sB,EAAKytB,GAAWxtB,EAAK,GAC5CnX,EAAI+jC,GAAqB7sB,EAAK,GAAMytB,GAAWxtB,EAAK,GACpDtgB,EAAIktC,GAAqB7sB,EAAK,GAAMytB,EAASxtB,EAInDqnB,EAAQ1wC,KAAMgJ,EAAGiJ,EAAGlJ,GACpB2nC,EAAQ1wC,KAAMiS,EAAGC,EAAGnJ,GAIpBiuC,GAAc,CAEf,CAMDjB,EAAMhG,SAAUmG,EAAYc,EAAYhH,GAIxCkG,GAAcc,EAIdf,GAAoBc,CAErB,CAlHAZ,EAAY,IAAK,IAAK,KAAO,GAAK,EAAGjzB,EAAO/P,EAAQD,EAAO4iC,EAAeD,EAAgB,GAC1FM,EAAY,IAAK,IAAK,IAAK,GAAK,EAAGjzB,EAAO/P,GAAUD,EAAO4iC,EAAeD,EAAgB,GAC1FM,EAAY,IAAK,IAAK,IAAK,EAAG,EAAGjjC,EAAOgQ,EAAO/P,EAAQyiC,EAAeE,EAAe,GACrFK,EAAY,IAAK,IAAK,IAAK,GAAK,EAAGjjC,EAAOgQ,GAAS/P,EAAQyiC,EAAeE,EAAe,GACzFK,EAAY,IAAK,IAAK,IAAK,GAAK,EAAGjjC,EAAOC,EAAQ+P,EAAO0yB,EAAeC,EAAgB,GACxFM,EAAY,IAAK,IAAK,KAAO,GAAK,EAAGjjC,EAAOC,GAAU+P,EAAO0yB,EAAeC,EAAgB,GAI5Ft1C,KAAKovC,SAAUe,GACfnwC,KAAK/C,aAAc,WAAY,IAAI,GAAwBw4C,EAAU,IACrEz1C,KAAK/C,aAAc,SAAU,IAAI,GAAwBozC,EAAS,IAClErwC,KAAK/C,aAAc,KAAM,IAAI,GAAwBqzC,EAAK,GAwG3D,CAEAl9B,KAAM3P,GAML,OAJA2b,MAAMhM,KAAM3P,GAEZzD,KAAK2/B,WAAav9B,OAAOihB,OAAQ,CAAC,EAAG5f,EAAOk8B,YAErC3/B,IAER,CAEA0c,gBAAiBrZ,GAEhB,OAAO,IAAI+xC,GAAa/xC,EAAKsP,MAAOtP,EAAKuP,OAAQvP,EAAKsf,MAAOtf,EAAKgyC,cAAehyC,EAAKiyC,eAAgBjyC,EAAKkyC,cAE5G,EAQD,SAASmB,GAAe95B,GAEvB,MAAMqH,EAAM,CAAC,EAEb,IAAM,MAAMmH,KAAKxO,EAAM,CAEtBqH,EAAKmH,GAAM,CAAC,EAEZ,IAAM,MAAMsN,KAAK9b,EAAKwO,GAAM,CAE3B,MAAMurB,EAAW/5B,EAAKwO,GAAKsN,GAEtBie,IAAcA,EAASrX,SAC3BqX,EAAS9/B,WAAa8/B,EAAS1iB,WAC/B0iB,EAASjkC,WAAaikC,EAASzuB,WAAayuB,EAAS31B,WACrD21B,EAASt3B,WAAas3B,EAAS/yB,cAE1B+yB,EAAS12B,uBAEb3hB,QAAQkU,KAAM,sGACdyR,EAAKmH,GAAKsN,GAAM,MAIhBzU,EAAKmH,GAAKsN,GAAMie,EAASxjC,QAIflS,MAAME,QAASw1C,GAE1B1yB,EAAKmH,GAAKsN,GAAMie,EAASr0C,QAIzB2hB,EAAKmH,GAAKsN,GAAMie,CAIlB,CAED,CAEA,OAAO1yB,CAER,CAEA,SAAS2yB,GAAeC,GAEvB,MAAMC,EAAS,CAAC,EAEhB,IAAM,IAAI1rB,EAAI,EAAGA,EAAIyrB,EAASl2C,OAAQyqB,IAAO,CAE5C,MAAM5R,EAAMk9B,GAAeG,EAAUzrB,IAErC,IAAM,MAAMsN,KAAKlf,EAEhBs9B,EAAQpe,GAAMlf,EAAKkf,EAIrB,CAEA,OAAOoe,CAER,CAgBA,SAASC,GAA2BC,GAEnC,OAAoC,OAA/BA,EAASC,kBAGND,EAASE,iBAIV5qC,EAER,CAIA,MAAM6qC,GAAgB,CAAEhkC,MAAOujC,GAAeU,MAAOR,IAMrD,MAAMS,WAAuB/T,GAE5B/gC,YAAao9B,GAEZvgB,QAEApf,KAAKs3C,kBAAmB,EAExBt3C,KAAK+M,KAAO,iBAEZ/M,KAAKu3C,QAAU,CAAC,EAChBv3C,KAAK62C,SAAW,CAAC,EACjB72C,KAAKw3C,eAAiB,GAEtBx3C,KAAKy3C,aAlBc,gGAmBnBz3C,KAAK03C,eAjBgB,iEAmBrB13C,KAAKgqC,UAAY,EAEjBhqC,KAAKmqC,WAAY,EACjBnqC,KAAKoqC,mBAAqB,EAE1BpqC,KAAKwqC,KAAM,EACXxqC,KAAK23C,QAAS,EACd33C,KAAK43C,UAAW,EAEhB53C,KAAK2lC,iBAAkB,EAEvB3lC,KAAK63C,WAAa,CACjBC,aAAa,EACbC,WAAW,EACXC,aAAa,EACbC,kBAAkB,GAKnBj4C,KAAKk4C,uBAAyB,CAC7B,MAAS,CAAE,EAAG,EAAG,GACjB,GAAM,CAAE,EAAG,GACX,IAAO,CAAE,EAAG,IAGbl4C,KAAKm4C,yBAAsBh7C,EAC3B6C,KAAKo4C,oBAAqB,EAE1Bp4C,KAAKq4C,YAAc,UAECl7C,IAAfwiC,GAEJ3/B,KAAKkmC,UAAWvG,EAIlB,CAEAvsB,KAAM3P,GAuBL,OArBA2b,MAAMhM,KAAM3P,GAEZzD,KAAK03C,eAAiBj0C,EAAOi0C,eAC7B13C,KAAKy3C,aAAeh0C,EAAOg0C,aAE3Bz3C,KAAK62C,SAAWH,GAAejzC,EAAOozC,UACtC72C,KAAKw3C,eAnGP,SAA8B56B,GAE7B,MAAMqH,EAAM,GAEZ,IAAM,IAAImH,EAAI,EAAGA,EAAIxO,EAAIjc,OAAQyqB,IAEhCnH,EAAIxkB,KAAMmd,EAAKwO,GAAIjY,SAIpB,OAAO8Q,CAER,CAuFwBq0B,CAAqB70C,EAAO+zC,gBAElDx3C,KAAKu3C,QAAUn1C,OAAOihB,OAAQ,CAAC,EAAG5f,EAAO8zC,SAEzCv3C,KAAKmqC,UAAY1mC,EAAO0mC,UACxBnqC,KAAKoqC,mBAAqB3mC,EAAO2mC,mBAEjCpqC,KAAKwqC,IAAM/mC,EAAO+mC,IAClBxqC,KAAK23C,OAASl0C,EAAOk0C,OACrB33C,KAAK43C,SAAWn0C,EAAOm0C,SAEvB53C,KAAK63C,WAAaz1C,OAAOihB,OAAQ,CAAC,EAAG5f,EAAOo0C,YAE5C73C,KAAKq4C,YAAc50C,EAAO40C,YAEnBr4C,IAER,CAEA+d,OAAQC,GAEP,MAAM3a,EAAO+b,MAAMrB,OAAQC,GAE3B3a,EAAKg1C,YAAcr4C,KAAKq4C,YACxBh1C,EAAKwzC,SAAW,CAAC,EAEjB,IAAM,MAAMr0C,KAAQxC,KAAK62C,SAAW,CAEnC,MACMz5C,EADU4C,KAAK62C,SAAUr0C,GACTpF,MAEjBA,GAASA,EAAMiiB,UAEnBhc,EAAKwzC,SAAUr0C,GAAS,CACvBuK,KAAM,IACN3P,MAAOA,EAAM2gB,OAAQC,GAAOJ,MAGlBxgB,GAASA,EAAMkiC,QAE1Bj8B,EAAKwzC,SAAUr0C,GAAS,CACvBuK,KAAM,IACN3P,MAAOA,EAAMipC,UAGHjpC,GAASA,EAAMsV,UAE1BrP,EAAKwzC,SAAUr0C,GAAS,CACvBuK,KAAM,KACN3P,MAAOA,EAAMwY,WAGHxY,GAASA,EAAM8qB,UAE1B7kB,EAAKwzC,SAAUr0C,GAAS,CACvBuK,KAAM,KACN3P,MAAOA,EAAMwY,WAGHxY,GAASA,EAAM4jB,UAE1B3d,EAAKwzC,SAAUr0C,GAAS,CACvBuK,KAAM,KACN3P,MAAOA,EAAMwY,WAGHxY,GAASA,EAAMyZ,UAE1BxT,EAAKwzC,SAAUr0C,GAAS,CACvBuK,KAAM,KACN3P,MAAOA,EAAMwY,WAGHxY,GAASA,EAAM62B,UAE1B5wB,EAAKwzC,SAAUr0C,GAAS,CACvBuK,KAAM,KACN3P,MAAOA,EAAMwY,WAKdvS,EAAKwzC,SAAUr0C,GAAS,CACvBpF,MAAOA,EAOV,CAEKgF,OAAOyD,KAAM7F,KAAKu3C,SAAU52C,OAAS,IAAI0C,EAAKk0C,QAAUv3C,KAAKu3C,SAElEl0C,EAAKo0C,aAAez3C,KAAKy3C,aACzBp0C,EAAKq0C,eAAiB13C,KAAK03C,eAE3Br0C,EAAKs0C,OAAS33C,KAAK23C,OACnBt0C,EAAKu0C,SAAW53C,KAAK43C,SAErB,MAAMC,EAAa,CAAC,EAEpB,IAAM,MAAM9xC,KAAO/F,KAAK63C,YAES,IAA3B73C,KAAK63C,WAAY9xC,KAAiB8xC,EAAY9xC,IAAQ,GAM5D,OAFK3D,OAAOyD,KAAMgyC,GAAal3C,OAAS,IAAI0C,EAAKw0C,WAAaA,GAEvDx0C,CAER,EAID,MAAMk1C,WAAe3d,GAEpBr4B,cAEC6c,QAEApf,KAAKg9B,UAAW,EAEhBh9B,KAAK+M,KAAO,SAEZ/M,KAAKmpB,mBAAqB,IAAIsK,GAE9BzzB,KAAKopB,iBAAmB,IAAIqK,GAC5BzzB,KAAKspB,wBAA0B,IAAImK,GAEnCzzB,KAAKw4B,iBAAmB5rB,EAEzB,CAEAwG,KAAM3P,EAAQ88B,GAWb,OATAnhB,MAAMhM,KAAM3P,EAAQ88B,GAEpBvgC,KAAKmpB,mBAAmB/V,KAAM3P,EAAO0lB,oBAErCnpB,KAAKopB,iBAAiBhW,KAAM3P,EAAO2lB,kBACnCppB,KAAKspB,wBAAwBlW,KAAM3P,EAAO6lB,yBAE1CtpB,KAAKw4B,iBAAmB/0B,EAAO+0B,iBAExBx4B,IAER,CAEA+9B,kBAAmB35B,GAElBpE,KAAK8sB,mBAAmB,GAAM,GAE9B,MAAM5wB,EAAI8D,KAAKupB,YAAYtV,SAE3B,OAAO7P,EAAOmO,KAAOrW,EAAG,IAAOA,EAAG,IAAOA,EAAG,KAAOwT,WAEpD,CAEA0uB,kBAAmBC,GAElBjf,MAAMgf,kBAAmBC,GAEzBr+B,KAAKmpB,mBAAmB/V,KAAMpT,KAAKupB,aAActQ,QAElD,CAEA6T,kBAAmByR,EAAeC,GAEjCpf,MAAM0N,kBAAmByR,EAAeC,GAExCx+B,KAAKmpB,mBAAmB/V,KAAMpT,KAAKupB,aAActQ,QAElD,CAEA9F,QAEC,OAAO,IAAInT,KAAKuC,aAAc6Q,KAAMpT,KAErC,EAID,MAAMw4C,WAA0BD,GAE/Bh2C,YAAak2C,EAAM,GAAIC,EAAS,EAAGpgB,EAAO,GAAKC,EAAM,KAEpDnZ,QAEApf,KAAK24C,qBAAsB,EAE3B34C,KAAK+M,KAAO,oBAEZ/M,KAAKy4C,IAAMA,EACXz4C,KAAK44C,KAAO,EAEZ54C,KAAKs4B,KAAOA,EACZt4B,KAAKu4B,IAAMA,EACXv4B,KAAK64C,MAAQ,GAEb74C,KAAK04C,OAASA,EACd14C,KAAK84C,KAAO,KAEZ94C,KAAK+4C,UAAY,GACjB/4C,KAAKg5C,WAAa,EAElBh5C,KAAKi5C,wBAEN,CAEA7lC,KAAM3P,EAAQ88B,GAiBb,OAfAnhB,MAAMhM,KAAM3P,EAAQ88B,GAEpBvgC,KAAKy4C,IAAMh1C,EAAOg1C,IAClBz4C,KAAK44C,KAAOn1C,EAAOm1C,KAEnB54C,KAAKs4B,KAAO70B,EAAO60B,KACnBt4B,KAAKu4B,IAAM90B,EAAO80B,IAClBv4B,KAAK64C,MAAQp1C,EAAOo1C,MAEpB74C,KAAK04C,OAASj1C,EAAOi1C,OACrB14C,KAAK84C,KAAuB,OAAhBr1C,EAAOq1C,KAAgB,KAAO12C,OAAOihB,OAAQ,CAAC,EAAG5f,EAAOq1C,MAEpE94C,KAAK+4C,UAAYt1C,EAAOs1C,UACxB/4C,KAAKg5C,WAAav1C,EAAOu1C,WAElBh5C,IAER,CAUAk5C,eAAgBC,GAGf,MAAMC,EAAe,GAAMp5C,KAAKq5C,gBAAkBF,EAElDn5C,KAAKy4C,IAAgB,EAAV3qC,GAAc9P,KAAKs7C,KAAMF,GACpCp5C,KAAKi5C,wBAEN,CAKAM,iBAEC,MAAMH,EAAep7C,KAAKw7C,IAAe,GAAV3rC,GAAgB7N,KAAKy4C,KAEpD,MAAO,GAAMz4C,KAAKq5C,gBAAkBD,CAErC,CAEAK,kBAEC,OAAiB,EAAV3rC,GAAc9P,KAAKs7C,KACzBt7C,KAAKw7C,IAAe,GAAV3rC,GAAgB7N,KAAKy4C,KAAQz4C,KAAK44C,KAE9C,CAEAc,eAGC,OAAO15C,KAAK+4C,UAAY/6C,KAAKL,IAAKqC,KAAK04C,OAAQ,EAEhD,CAEAW,gBAGC,OAAOr5C,KAAK+4C,UAAY/6C,KAAKuQ,IAAKvO,KAAK04C,OAAQ,EAEhD,CAqCAiB,cAAeC,EAAWC,EAAYv9C,EAAGE,EAAGmW,EAAOC,GAElD5S,KAAK04C,OAASkB,EAAYC,EAEP,OAAd75C,KAAK84C,OAET94C,KAAK84C,KAAO,CACXj9B,SAAS,EACT+9B,UAAW,EACXC,WAAY,EACZC,QAAS,EACTC,QAAS,EACTpnC,MAAO,EACPC,OAAQ,IAKV5S,KAAK84C,KAAKj9B,SAAU,EACpB7b,KAAK84C,KAAKc,UAAYA,EACtB55C,KAAK84C,KAAKe,WAAaA,EACvB75C,KAAK84C,KAAKgB,QAAUx9C,EACpB0D,KAAK84C,KAAKiB,QAAUv9C,EACpBwD,KAAK84C,KAAKnmC,MAAQA,EAClB3S,KAAK84C,KAAKlmC,OAASA,EAEnB5S,KAAKi5C,wBAEN,CAEAe,kBAEoB,OAAdh6C,KAAK84C,OAET94C,KAAK84C,KAAKj9B,SAAU,GAIrB7b,KAAKi5C,wBAEN,CAEAA,yBAEC,MAAM3gB,EAAOt4B,KAAKs4B,KAClB,IAAIF,EAAME,EAAOt6B,KAAKw7C,IAAe,GAAV3rC,GAAgB7N,KAAKy4C,KAAQz4C,KAAK44C,KACzDhmC,EAAS,EAAIwlB,EACbzlB,EAAQ3S,KAAK04C,OAAS9lC,EACtBslB,GAAS,GAAMvlB,EACnB,MAAMmmC,EAAO94C,KAAK84C,KAElB,GAAmB,OAAd94C,KAAK84C,MAAiB94C,KAAK84C,KAAKj9B,QAAU,CAE9C,MAAM+9B,EAAYd,EAAKc,UACtBC,EAAaf,EAAKe,WAEnB3hB,GAAQ4gB,EAAKgB,QAAUnnC,EAAQinC,EAC/BxhB,GAAO0gB,EAAKiB,QAAUnnC,EAASinC,EAC/BlnC,GAASmmC,EAAKnmC,MAAQinC,EACtBhnC,GAAUkmC,EAAKlmC,OAASinC,CAEzB,CAEA,MAAMI,EAAOj6C,KAAKg5C,WACJ,IAATiB,IAAa/hB,GAAQI,EAAO2hB,EAAOj6C,KAAK05C,gBAE7C15C,KAAKopB,iBAAiB6O,gBAAiBC,EAAMA,EAAOvlB,EAAOylB,EAAKA,EAAMxlB,EAAQ0lB,EAAMt4B,KAAKu4B,IAAKv4B,KAAKw4B,kBAEnGx4B,KAAKspB,wBAAwBlW,KAAMpT,KAAKopB,kBAAmBnQ,QAE5D,CAEA8E,OAAQC,GAEP,MAAM3a,EAAO+b,MAAMrB,OAAQC,GAgB3B,OAdA3a,EAAK8oB,OAAOssB,IAAMz4C,KAAKy4C,IACvBp1C,EAAK8oB,OAAOysB,KAAO54C,KAAK44C,KAExBv1C,EAAK8oB,OAAOmM,KAAOt4B,KAAKs4B,KACxBj1B,EAAK8oB,OAAOoM,IAAMv4B,KAAKu4B,IACvBl1B,EAAK8oB,OAAO0sB,MAAQ74C,KAAK64C,MAEzBx1C,EAAK8oB,OAAOusB,OAAS14C,KAAK04C,OAEP,OAAd14C,KAAK84C,OAAgBz1C,EAAK8oB,OAAO2sB,KAAO12C,OAAOihB,OAAQ,CAAC,EAAGrjB,KAAK84C,OAErEz1C,EAAK8oB,OAAO4sB,UAAY/4C,KAAK+4C,UAC7B11C,EAAK8oB,OAAO6sB,WAAah5C,KAAKg5C,WAEvB31C,CAER,EAID,MAAMo1C,IAAQ,GAGd,MAAMyB,WAAmBtf,GAExBr4B,YAAa+1B,EAAMC,EAAK4hB,GAEvB/6B,QAEApf,KAAK+M,KAAO,aAEZ/M,KAAKm6C,aAAeA,EACpBn6C,KAAKw4B,iBAAmB,KAExB,MAAM4hB,EAAW,IAAI5B,GAAmBC,GAb3B,EAawCngB,EAAMC,GAC3D6hB,EAASvgB,OAAS75B,KAAK65B,OACvB75B,KAAKhD,IAAKo9C,GAEV,MAAMC,EAAW,IAAI7B,GAAmBC,GAjB3B,EAiBwCngB,EAAMC,GAC3D8hB,EAASxgB,OAAS75B,KAAK65B,OACvB75B,KAAKhD,IAAKq9C,GAEV,MAAMC,EAAW,IAAI9B,GAAmBC,GArB3B,EAqBwCngB,EAAMC,GAC3D+hB,EAASzgB,OAAS75B,KAAK65B,OACvB75B,KAAKhD,IAAKs9C,GAEV,MAAMC,EAAW,IAAI/B,GAAmBC,GAzB3B,EAyBwCngB,EAAMC,GAC3DgiB,EAAS1gB,OAAS75B,KAAK65B,OACvB75B,KAAKhD,IAAKu9C,GAEV,MAAMC,EAAW,IAAIhC,GAAmBC,GA7B3B,EA6BwCngB,EAAMC,GAC3DiiB,EAAS3gB,OAAS75B,KAAK65B,OACvB75B,KAAKhD,IAAKw9C,GAEV,MAAMC,EAAW,IAAIjC,GAAmBC,GAjC3B,EAiCwCngB,EAAMC,GAC3DkiB,EAAS5gB,OAAS75B,KAAK65B,OACvB75B,KAAKhD,IAAKy9C,EAEX,CAEAC,yBAEC,MAAMliB,EAAmBx4B,KAAKw4B,iBAExBmiB,EAAU36C,KAAKqtB,SAASjtB,UAEtBg6C,EAAUC,EAAUC,EAAUC,EAAUC,EAAUC,GAAaE,EAEvE,IAAM,MAAMzxB,KAAUyxB,EAAU36C,KAAK9C,OAAQgsB,GAE7C,GAAKsP,IAAqB5rB,GAEzBwtC,EAAS1kB,GAAGnjB,IAAK,EAAG,EAAG,GACvB6nC,EAASrpB,OAAQ,EAAG,EAAG,GAEvBspB,EAAS3kB,GAAGnjB,IAAK,EAAG,EAAG,GACvB8nC,EAAStpB,QAAU,EAAG,EAAG,GAEzBupB,EAAS5kB,GAAGnjB,IAAK,EAAG,GAAK,GACzB+nC,EAASvpB,OAAQ,EAAG,EAAG,GAEvBwpB,EAAS7kB,GAAGnjB,IAAK,EAAG,EAAG,GACvBgoC,EAASxpB,OAAQ,GAAK,EAAG,GAEzBypB,EAAS9kB,GAAGnjB,IAAK,EAAG,EAAG,GACvBioC,EAASzpB,OAAQ,EAAG,EAAG,GAEvB0pB,EAAS/kB,GAAGnjB,IAAK,EAAG,EAAG,GACvBkoC,EAAS1pB,OAAQ,EAAG,GAAK,OAEnB,IAAKyH,IAAqB3rB,GAsBhC,MAAM,IAAI5G,MAAO,yEAA2EuyB,GApB5F4hB,EAAS1kB,GAAGnjB,IAAK,GAAK,EAAG,GACzB6nC,EAASrpB,QAAU,EAAG,EAAG,GAEzBspB,EAAS3kB,GAAGnjB,IAAK,GAAK,EAAG,GACzB8nC,EAAStpB,OAAQ,EAAG,EAAG,GAEvBupB,EAAS5kB,GAAGnjB,IAAK,EAAG,EAAG,GACvB+nC,EAASvpB,OAAQ,EAAG,EAAG,GAEvBwpB,EAAS7kB,GAAGnjB,IAAK,EAAG,GAAK,GACzBgoC,EAASxpB,OAAQ,GAAK,EAAG,GAEzBypB,EAAS9kB,GAAGnjB,IAAK,GAAK,EAAG,GACzBioC,EAASzpB,OAAQ,EAAG,EAAG,GAEvB0pB,EAAS/kB,GAAGnjB,IAAK,GAAK,EAAG,GACzBkoC,EAAS1pB,OAAQ,EAAG,GAAK,EAM1B,CAEA,IAAM,MAAM7H,KAAUyxB,EAErB36C,KAAKhD,IAAKksB,GAEVA,EAAOkV,mBAIT,CAEA/2B,OAAQ2vC,EAAU4D,GAEI,OAAhB56C,KAAK86B,QAAkB96B,KAAKo+B,oBAEjC,MAAM+b,EAAen6C,KAAKm6C,aAErBn6C,KAAKw4B,mBAAqBwe,EAASxe,mBAEvCx4B,KAAKw4B,iBAAmBwe,EAASxe,iBAEjCx4B,KAAK06C,0BAIN,MAAQN,EAAUC,EAAUC,EAAUC,EAAUC,EAAUC,GAAaz6C,KAAKqtB,SAEtEwtB,EAAsB7D,EAASC,kBAE/B6D,EAAqB9D,EAAS+D,YAC9BC,EAAmBhE,EAASiE,GAAGp/B,QAErCm7B,EAAS+D,YAAcjxC,EACvBktC,EAASiE,GAAGp/B,SAAU,EAEtB,MAAM8D,EAAkBw6B,EAAap3B,QAAQpD,gBAE7Cw6B,EAAap3B,QAAQpD,iBAAkB,EAEvCq3B,EAASkE,gBAAiBf,EAAc,GACxCnD,EAASmE,OAAQP,EAAOR,GAExBpD,EAASkE,gBAAiBf,EAAc,GACxCnD,EAASmE,OAAQP,EAAOP,GAExBrD,EAASkE,gBAAiBf,EAAc,GACxCnD,EAASmE,OAAQP,EAAON,GAExBtD,EAASkE,gBAAiBf,EAAc,GACxCnD,EAASmE,OAAQP,EAAOL,GAExBvD,EAASkE,gBAAiBf,EAAc,GACxCnD,EAASmE,OAAQP,EAAOJ,GAExBL,EAAap3B,QAAQpD,gBAAkBA,EAEvCq3B,EAASkE,gBAAiBf,EAAc,GACxCnD,EAASmE,OAAQP,EAAOH,GAExBzD,EAASkE,gBAAiBL,GAE1B7D,EAAS+D,YAAcD,EACvB9D,EAASiE,GAAGp/B,QAAUm/B,EAEtBb,EAAap3B,QAAQ7C,kBAAmB,CAEzC,EAID,MAAMk7B,WAAoB58B,GAEzBjc,YAAa2b,EAAQQ,EAASE,EAAOC,EAAOC,EAAWC,EAAWC,EAAQjS,EAAMkS,EAAYjD,GAK3FoD,MAHAlB,OAAoB/gB,IAAX+gB,EAAuBA,EAAS,GACzCQ,OAAsBvhB,IAAZuhB,EAAwBA,EAAUtU,EAEpBwU,EAAOC,EAAOC,EAAWC,EAAWC,EAAQjS,EAAMkS,EAAYjD,GAEtFhc,KAAKq7C,eAAgB,EAErBr7C,KAAK6f,OAAQ,CAEd,CAEI3B,aAEH,OAAOle,KAAK2c,KAEb,CAEIuB,WAAQ9gB,GAEX4C,KAAK2c,MAAQvf,CAEd,EAID,MAAMk+C,WAA8B74B,GAEnClgB,YAAaypB,EAAO,EAAGpoB,EAAU,CAAC,GAEjCwb,MAAO4M,EAAMA,EAAMpoB,GAEnB5D,KAAKu7C,yBAA0B,EAE/B,MAAM5+B,EAAQ,CAAEhK,MAAOqZ,EAAMpZ,OAAQoZ,EAAMrJ,MAAO,GAC5CzE,EAAS,CAAEvB,EAAOA,EAAOA,EAAOA,EAAOA,EAAOA,QAE1Bxf,IAArByG,EAAQgd,WAGZ3F,GAAU,wFACVrX,EAAQoY,WAAapY,EAAQgd,WAAaxU,EAAeC,GAr1YvC,IAy1YnBrM,KAAK+iB,QAAU,IAAIq4B,GAAal9B,EAAQta,EAAQ8a,QAAS9a,EAAQgb,MAAOhb,EAAQib,MAAOjb,EAAQkb,UAAWlb,EAAQmb,UAAWnb,EAAQob,OAAQpb,EAAQmJ,KAAMnJ,EAAQqb,WAAYrb,EAAQoY,YAUvLhc,KAAK+iB,QAAQ9C,uBAAwB,EAErCjgB,KAAK+iB,QAAQpD,qBAA8CxiB,IAA5ByG,EAAQ+b,iBAAgC/b,EAAQ+b,gBAC/E3f,KAAK+iB,QAAQhE,eAAkC5hB,IAAtByG,EAAQmb,UAA0Bnb,EAAQmb,UAAYlU,CAEhF,CAEA2wC,2BAA4BxE,EAAUj0B,GAErC/iB,KAAK+iB,QAAQhW,KAAOgW,EAAQhW,KAC5B/M,KAAK+iB,QAAQ/G,WAAa+G,EAAQ/G,WAElChc,KAAK+iB,QAAQpD,gBAAkBoD,EAAQpD,gBACvC3f,KAAK+iB,QAAQhE,UAAYgE,EAAQhE,UACjC/e,KAAK+iB,QAAQjE,UAAYiE,EAAQjE,UAEjC,MAAM28B,EAEK,CACTC,UAAW,CAAEt+C,MAAO,OAHhBq+C,EAMmB,qYANnBA,EA0BqB,+UAoBrBtuB,EAAW,IAAIioB,GAAa,EAAG,EAAG,GAElCnV,EAAW,IAAIoX,GAAgB,CAEpC70C,KAAM,sBAENq0C,SAAUH,GAAe+E,GACzBhE,aAAcgE,EACd/D,eAAgB+D,EAChBhY,KArjZc,EAsjZdD,SAnjZgB,IAujZjBvD,EAAS4W,SAAS6E,UAAUt+C,MAAQ2lB,EAEpC,MAAM44B,EAAO,IAAI3H,GAAM7mB,EAAU8S,GAE3B2b,EAAmB74B,EAAQhE,UAajC,OAVKgE,EAAQhE,YAAchU,IAA2BgY,EAAQhE,UAAYlU,GAE3D,IAAIqvC,GAAY,EAAG,GAAIl6C,MAC/BqH,OAAQ2vC,EAAU2E,GAEzB54B,EAAQhE,UAAY68B,EAEpBD,EAAKxuB,SAAS1M,UACdk7B,EAAK1b,SAASxf,UAEPzgB,IAER,CAEAq9B,MAAO2Z,EAAUx7B,EAAOmH,EAAOk5B,GAE9B,MAAMhB,EAAsB7D,EAASC,kBAErC,IAAM,IAAI32C,EAAI,EAAGA,EAAI,EAAGA,IAEvB02C,EAASkE,gBAAiBl7C,KAAMM,GAEhC02C,EAAS3Z,MAAO7hB,EAAOmH,EAAOk5B,GAI/B7E,EAASkE,gBAAiBL,EAE3B,EAID,MAAMiB,GAAyB,IAAI,GAC7BC,GAAyB,IAAI,GAC7BC,GAA8B,IAAI7lC,GAExC,MAAM8lC,GAEL15C,YAAa8nB,EAAS,IAAI,GAAS,EAAG,EAAG,GAAK0D,EAAW,GAExD/tB,KAAKk8C,SAAU,EAIfl8C,KAAKqqB,OAASA,EACdrqB,KAAK+tB,SAAWA,CAEjB,CAEAxb,IAAK8X,EAAQ0D,GAKZ,OAHA/tB,KAAKqqB,OAAOjX,KAAMiX,GAClBrqB,KAAK+tB,SAAWA,EAET/tB,IAER,CAEAm8C,cAAe7/C,EAAGE,EAAGskB,EAAGC,GAKvB,OAHA/gB,KAAKqqB,OAAO9X,IAAKjW,EAAGE,EAAGskB,GACvB9gB,KAAK+tB,SAAWhN,EAET/gB,IAER,CAEAo8C,8BAA+B/xB,EAAQqC,GAKtC,OAHA1sB,KAAKqqB,OAAOjX,KAAMiX,GAClBrqB,KAAK+tB,UAAarB,EAAMlY,IAAKxU,KAAKqqB,QAE3BrqB,IAER,CAEA4iC,sBAAuBn6B,EAAGiJ,EAAGC,GAE5B,MAAM0Y,EAASyxB,GAASnoC,WAAYhC,EAAGD,GAAI+C,MAAOsnC,GAASpoC,WAAYlL,EAAGiJ,IAAMhC,YAMhF,OAFA1P,KAAKo8C,8BAA+B/xB,EAAQ5hB,GAErCzI,IAER,CAEAoT,KAAM0a,GAKL,OAHA9tB,KAAKqqB,OAAOjX,KAAM0a,EAAMzD,QACxBrqB,KAAK+tB,SAAWD,EAAMC,SAEf/tB,IAER,CAEA0P,YAIC,MAAM2sC,EAAsB,EAAMr8C,KAAKqqB,OAAO1pB,SAI9C,OAHAX,KAAKqqB,OAAOxW,eAAgBwoC,GAC5Br8C,KAAK+tB,UAAYsuB,EAEVr8C,IAER,CAEAuU,SAKC,OAHAvU,KAAK+tB,WAAc,EACnB/tB,KAAKqqB,OAAO9V,SAELvU,IAER,CAEA6uB,gBAAiBnC,GAEhB,OAAO1sB,KAAKqqB,OAAO7V,IAAKkY,GAAU1sB,KAAK+tB,QAExC,CAEAuuB,iBAAkB3uB,GAEjB,OAAO3tB,KAAK6uB,gBAAiBlB,EAAOzX,QAAWyX,EAAOlD,MAEvD,CAEA8xB,aAAc7vB,EAAOtoB,GAEpB,OAAOA,EAAOgP,KAAMsZ,GAAQlZ,gBAAiBxT,KAAKqqB,QAAUrqB,KAAK6uB,gBAAiBnC,GAEnF,CAEA8vB,cAAeC,EAAMr4C,GAEpB,MAAMwsB,EAAY6rB,EAAKvsB,MAAO4rB,IAExBhnC,EAAc9U,KAAKqqB,OAAO7V,IAAKoc,GAErC,GAAqB,IAAhB9b,EAGJ,OAA4C,IAAvC9U,KAAK6uB,gBAAiB4tB,EAAKvN,OAExB9qC,EAAOgP,KAAMqpC,EAAKvN,OAKnB,KAIR,MAAMvgC,IAAQ8tC,EAAKvN,MAAM16B,IAAKxU,KAAKqqB,QAAWrqB,KAAK+tB,UAAajZ,EAEhE,OAAKnG,EAAI,GAAKA,EAAI,EAEV,KAIDvK,EAAOgP,KAAMqpC,EAAKvN,OAAQ17B,gBAAiBod,EAAWjiB,EAE9D,CAEA+tC,eAAgBD,GAIf,MAAME,EAAY38C,KAAK6uB,gBAAiB4tB,EAAKvN,OACvC0N,EAAU58C,KAAK6uB,gBAAiB4tB,EAAKI,KAE3C,OAASF,EAAY,GAAKC,EAAU,GAASA,EAAU,GAAKD,EAAY,CAEzE,CAEAlvB,cAAenB,GAEd,OAAOA,EAAIuB,gBAAiB7tB,KAE7B,CAEA0tB,iBAAkBC,GAEjB,OAAOA,EAAOE,gBAAiB7tB,KAEhC,CAEA88C,cAAe14C,GAEd,OAAOA,EAAOgP,KAAMpT,KAAKqqB,QAASxW,gBAAkB7T,KAAK+tB,SAE1D,CAEA5M,aAAcxG,EAAQoiC,GAErB,MAAM5hB,EAAe4hB,GAAwBf,GAAcviC,gBAAiBkB,GAEtEqiC,EAAiBh9C,KAAK88C,cAAehB,IAAW36B,aAAcxG,GAE9D0P,EAASrqB,KAAKqqB,OAAOrW,aAAcmnB,GAAezrB,YAIxD,OAFA1P,KAAK+tB,UAAaivB,EAAexoC,IAAK6V,GAE/BrqB,IAER,CAEAya,UAAW9E,GAIV,OAFA3V,KAAK+tB,UAAYpY,EAAOnB,IAAKxU,KAAKqqB,QAE3BrqB,IAER,CAEAyV,OAAQqY,GAEP,OAAOA,EAAMzD,OAAO5U,OAAQzV,KAAKqqB,SAAcyD,EAAMC,WAAa/tB,KAAK+tB,QAExE,CAEA5a,QAEC,OAAO,IAAInT,KAAKuC,aAAc6Q,KAAMpT,KAErC,EAID,MAAMi9C,GAA0B,IAAIttB,GAC9ButB,GAA0B,IAAI,GAEpC,MAAMC,GAEL56C,YAAa8sB,EAAK,IAAI4sB,GAAS3sB,EAAK,IAAI2sB,GAAS1sB,EAAK,IAAI0sB,GAASpa,EAAK,IAAIoa,GAASmB,EAAK,IAAInB,GAASoB,EAAK,IAAIpB,IAE/Gj8C,KAAKs9C,OAAS,CAAEjuB,EAAIC,EAAIC,EAAIsS,EAAIub,EAAIC,EAErC,CAEA9qC,IAAK8c,EAAIC,EAAIC,EAAIsS,EAAIub,EAAIC,GAExB,MAAMC,EAASt9C,KAAKs9C,OASpB,OAPAA,EAAQ,GAAIlqC,KAAMic,GAClBiuB,EAAQ,GAAIlqC,KAAMkc,GAClBguB,EAAQ,GAAIlqC,KAAMmc,GAClB+tB,EAAQ,GAAIlqC,KAAMyuB,GAClByb,EAAQ,GAAIlqC,KAAMgqC,GAClBE,EAAQ,GAAIlqC,KAAMiqC,GAEXr9C,IAER,CAEAoT,KAAMmqC,GAEL,MAAMD,EAASt9C,KAAKs9C,OAEpB,IAAM,IAAIh9C,EAAI,EAAGA,EAAI,EAAGA,IAEvBg9C,EAAQh9C,GAAI8S,KAAMmqC,EAAQD,OAAQh9C,IAInC,OAAON,IAER,CAEAw9C,wBAAyB/uC,EAAG+pB,EAAmB5rB,KAE9C,MAAM0wC,EAASt9C,KAAKs9C,OACdtmC,EAAKvI,EAAEwF,SACPwpC,EAAMzmC,EAAI,GAAK0mC,EAAM1mC,EAAI,GAAK2mC,EAAM3mC,EAAI,GAAK4mC,EAAM5mC,EAAI,GACvD6mC,EAAM7mC,EAAI,GAAK8mC,EAAM9mC,EAAI,GAAK+mC,EAAM/mC,EAAI,GAAKgnC,EAAMhnC,EAAI,GACvDinC,EAAMjnC,EAAI,GAAKknC,EAAMlnC,EAAI,GAAKmnC,EAAOnnC,EAAI,IAAMonC,EAAOpnC,EAAI,IAC1DqnC,EAAOrnC,EAAI,IAAMsnC,EAAOtnC,EAAI,IAAMunC,EAAOvnC,EAAI,IAAMwnC,EAAOxnC,EAAI,IAQpE,GANAsmC,EAAQ,GAAInB,cAAeyB,EAAMH,EAAKO,EAAMH,EAAKO,EAAOH,EAAKO,EAAOH,GAAO3uC,YAC3E4tC,EAAQ,GAAInB,cAAeyB,EAAMH,EAAKO,EAAMH,EAAKO,EAAOH,EAAKO,EAAOH,GAAO3uC,YAC3E4tC,EAAQ,GAAInB,cAAeyB,EAAMF,EAAKM,EAAMF,EAAKM,EAAOF,EAAKM,EAAOF,GAAO5uC,YAC3E4tC,EAAQ,GAAInB,cAAeyB,EAAMF,EAAKM,EAAMF,EAAKM,EAAOF,EAAKM,EAAOF,GAAO5uC,YAC3E4tC,EAAQ,GAAInB,cAAeyB,EAAMD,EAAKK,EAAMD,EAAKK,EAAOD,EAAMK,EAAOD,GAAO7uC,YAEvE8oB,IAAqB5rB,GAEzB0wC,EAAQ,GAAInB,cAAeyB,EAAMD,EAAKK,EAAMD,EAAKK,EAAOD,EAAMK,EAAOD,GAAO7uC,gBAEtE,IAAK8oB,IAAqB3rB,GAMhC,MAAM,IAAI5G,MAAO,uEAAyEuyB,GAJ1F8kB,EAAQ,GAAInB,cAAewB,EAAKI,EAAKI,EAAMI,GAAO7uC,WAMnD,CAEA,OAAO1P,IAER,CAEAy+C,iBAAkBtyB,GAEjB,QAA+BhvB,IAA1BgvB,EAAO6iB,eAEoB,OAA1B7iB,EAAO6iB,gBAA0B7iB,EAAO0jB,wBAE7CoN,GAAU7pC,KAAM+Y,EAAO6iB,gBAAiB7tB,aAAcgL,EAAO5C,iBAEvD,CAEN,MAAM4D,EAAWhB,EAAOgB,SAES,OAA5BA,EAAS6hB,gBAA0B7hB,EAAS0iB,wBAEjDoN,GAAU7pC,KAAM+Z,EAAS6hB,gBAAiB7tB,aAAcgL,EAAO5C,YAEhE,CAEA,OAAOvpB,KAAK0tB,iBAAkBuvB,GAE/B,CAEAyB,iBAAkBC,GAMjB,OAJA1B,GAAU/mC,OAAO3D,IAAK,EAAG,EAAG,GAC5B0qC,GAAUxyB,OAAS,kBACnBwyB,GAAU97B,aAAcw9B,EAAOp1B,aAExBvpB,KAAK0tB,iBAAkBuvB,GAE/B,CAEAvvB,iBAAkBC,GAEjB,MAAM2vB,EAASt9C,KAAKs9C,OACdpnC,EAASyX,EAAOzX,OAChB0oC,GAAcjxB,EAAOlD,OAE3B,IAAM,IAAInqB,EAAI,EAAGA,EAAI,EAAGA,IAIvB,GAFiBg9C,EAAQh9C,GAAIuuB,gBAAiB3Y,GAE9B0oC,EAEf,OAAO,EAMT,OAAO,CAER,CAEAnxB,cAAenB,GAEd,MAAMgxB,EAASt9C,KAAKs9C,OAEpB,IAAM,IAAIh9C,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,MAAMwtB,EAAQwvB,EAAQh9C,GAQtB,GAJA48C,GAAU5gD,EAAIwxB,EAAMzD,OAAO/tB,EAAI,EAAIgwB,EAAI/d,IAAIjS,EAAIgwB,EAAI3uB,IAAIrB,EACvD4gD,GAAU1gD,EAAIsxB,EAAMzD,OAAO7tB,EAAI,EAAI8vB,EAAI/d,IAAI/R,EAAI8vB,EAAI3uB,IAAInB,EACvD0gD,GAAUp8B,EAAIgN,EAAMzD,OAAOvJ,EAAI,EAAIwL,EAAI/d,IAAIuS,EAAIwL,EAAI3uB,IAAImjB,EAElDgN,EAAMe,gBAAiBquB,IAAc,EAEzC,OAAO,CAIT,CAEA,OAAO,CAER,CAEA5vB,cAAeZ,GAEd,MAAM4wB,EAASt9C,KAAKs9C,OAEpB,IAAM,IAAIh9C,EAAI,EAAGA,EAAI,EAAGA,IAEvB,GAAKg9C,EAAQh9C,GAAIuuB,gBAAiBnC,GAAU,EAE3C,OAAO,EAMT,OAAO,CAER,CAEAvZ,QAEC,OAAO,IAAInT,KAAKuC,aAAc6Q,KAAMpT,KAErC,EAID,SAAS6+C,KAER,IAAI9hC,EAAU,KACV+hC,GAAc,EACdC,EAAgB,KAChBC,EAAY,KAEhB,SAASC,EAAkBC,EAAMC,GAEhCJ,EAAeG,EAAMC,GAErBH,EAAYjiC,EAAQqiC,sBAAuBH,EAE5C,CAEA,MAAO,CAEN/P,MAAO,YAEe,IAAhB4P,GACkB,OAAlBC,IAELC,EAAYjiC,EAAQqiC,sBAAuBH,GAE3CH,GAAc,EAEf,EAEAO,KAAM,WAELtiC,EAAQuiC,qBAAsBN,GAE9BF,GAAc,CAEf,EAEAS,iBAAkB,SAAWt3B,GAE5B82B,EAAgB92B,CAEjB,EAEAu3B,WAAY,SAAWpiD,GAEtB2f,EAAU3f,CAEX,EAIF,CAEA,SAASqiD,GAAiBC,EAAIC,GAE7B,MAAMC,EAAWD,EAAaC,SAExBC,EAAU,IAAIC,QAmLpB,MAAO,CAENj3C,IAjED,SAAciN,GAIb,OAFKA,EAAU08B,+BAA+B18B,EAAYA,EAAUzS,MAE7Dw8C,EAAQh3C,IAAKiN,EAErB,EA4DC5Y,OA1DD,SAAiB4Y,GAEXA,EAAU08B,+BAA+B18B,EAAYA,EAAUzS,MAEpE,MAAMA,EAAOw8C,EAAQh3C,IAAKiN,GAErBzS,IAEJq8C,EAAGK,aAAc18C,EAAK28C,QAEtBH,EAAQI,OAAQnqC,GAIlB,EA6CCzO,OA3CD,SAAiByO,EAAWoqC,GAE3B,GAAKpqC,EAAUi6B,oBAAsB,CAEpC,MAAMoQ,EAASN,EAAQh3C,IAAKiN,GAa5B,cAXOqqC,GAAUA,EAAOtiC,QAAU/H,EAAU+H,UAE3CgiC,EAAQttC,IAAKuD,EAAW,CACvBkqC,OAAQlqC,EAAUkqC,OAClBjzC,KAAM+I,EAAU/I,KAChBqzC,gBAAiBtqC,EAAUuqC,YAC3BxiC,QAAS/H,EAAU+H,UAOtB,CAEK/H,EAAU08B,+BAA+B18B,EAAYA,EAAUzS,MAEpE,MAAMA,EAAOw8C,EAAQh3C,IAAKiN,QAEZ3Y,IAATkG,EAEJw8C,EAAQttC,IAAKuD,EArKf,SAAuBA,EAAWoqC,GAEjC,MAAMzyC,EAAQqI,EAAUrI,MAClB6/B,EAAQx3B,EAAUw3B,MAElB0S,EAASN,EAAGY,eAOlB,IAAIvzC,EAEJ,GAPA2yC,EAAGa,WAAYL,EAAYF,GAC3BN,EAAGc,WAAYN,EAAYzyC,EAAO6/B,GAElCx3B,EAAU23B,mBAILhgC,aAAiB0B,aAErBpC,EAAO2yC,EAAGe,WAEJ,GAAKhzC,aAAiB4B,YAE5B,GAAKyG,EAAU4qC,yBAA2B,CAEzC,IAAKd,EAMJ,MAAM,IAAI35C,MAAO,2EAJjB8G,EAAO2yC,EAAGiB,UAQZ,MAEC5zC,EAAO2yC,EAAGkB,oBAIL,GAAKnzC,aAAiB+B,WAE5BzC,EAAO2yC,EAAGmB,WAEJ,GAAKpzC,aAAiB2B,YAE5BrC,EAAO2yC,EAAGoB,kBAEJ,GAAKrzC,aAAiB8B,WAE5BxC,EAAO2yC,EAAGqB,SAEJ,GAAKtzC,aAAiBgC,UAE5B1C,EAAO2yC,EAAGsB,UAEJ,GAAKvzC,aAAiB6B,WAE5BvC,EAAO2yC,EAAGuB,kBAEJ,MAAKxzC,aAAiBqN,mBAM5B,MAAM,IAAI7U,MAAO,0DAA4DwH,GAJ7EV,EAAO2yC,EAAGuB,aAMX,CAEA,MAAO,CACNjB,OAAQA,EACRjzC,KAAMA,EACNqzC,gBAAiB3yC,EAAMyzC,kBACvBrjC,QAAS/H,EAAU+H,QAGrB,CA0F0ByiC,CAAcxqC,EAAWoqC,IAEtC78C,EAAKwa,QAAU/H,EAAU+H,UA1FtC,SAAuBmiC,EAAQlqC,EAAWoqC,GAEzC,MAAMzyC,EAAQqI,EAAUrI,MAClB8/B,EAAcz3B,EAAUy3B,YAE9BmS,EAAGa,WAAYL,EAAYF,IAEE,IAAxBzS,EAAYtoC,MAIhBy6C,EAAGyB,cAAejB,EAAY,EAAGzyC,IAI5BmyC,EAEJF,EAAGyB,cAAejB,EAAY3S,EAAY53B,OAASlI,EAAMyzC,kBACxDzzC,EAAO8/B,EAAY53B,OAAQ43B,EAAYtoC,OAIxCy6C,EAAGyB,cAAejB,EAAY3S,EAAY53B,OAASlI,EAAMyzC,kBACxDzzC,EAAM2zC,SAAU7T,EAAY53B,OAAQ43B,EAAY53B,OAAS43B,EAAYtoC,QAIvEsoC,EAAYtoC,OAAU,GAIvB6Q,EAAU23B,kBAEX,CA2DE4T,CAAch+C,EAAK28C,OAAQlqC,EAAWoqC,GAEtC78C,EAAKwa,QAAU/H,EAAU+H,QAI3B,EAUD,CAEA,MAAMyjC,WAAsB,GAE3B/+C,YAAaoQ,EAAQ,EAAGC,EAAS,EAAGyiC,EAAgB,EAAGC,EAAiB,GAEvEl2B,QAEApf,KAAK+M,KAAO,gBAEZ/M,KAAK2/B,WAAa,CACjBhtB,MAAOA,EACPC,OAAQA,EACRyiC,cAAeA,EACfC,eAAgBA,GAGjB,MAAMiM,EAAa5uC,EAAQ,EACrB6uC,EAAc5uC,EAAS,EAEvBmjC,EAAQ/3C,KAAKK,MAAOg3C,GACpBW,EAAQh4C,KAAKK,MAAOi3C,GAEpBgB,EAASP,EAAQ,EACjBQ,EAASP,EAAQ,EAEjByL,EAAgB9uC,EAAQojC,EACxB2L,EAAiB9uC,EAASojC,EAI1B7F,EAAU,GACVsF,EAAW,GACXpF,EAAU,GACVC,EAAM,GAEZ,IAAM,IAAIxnB,EAAK,EAAGA,EAAKytB,EAAQztB,IAAQ,CAEtC,MAAMtsB,EAAIssB,EAAK44B,EAAiBF,EAEhC,IAAM,IAAI34B,EAAK,EAAGA,EAAKytB,EAAQztB,IAAQ,CAEtC,MAAMvsB,EAAIusB,EAAK44B,EAAgBF,EAE/B9L,EAASh2C,KAAMnD,GAAKE,EAAG,GAEvB6zC,EAAQ5wC,KAAM,EAAG,EAAG,GAEpB6wC,EAAI7wC,KAAMopB,EAAKktB,GACfzF,EAAI7wC,KAAM,EAAMqpB,EAAKktB,EAEtB,CAED,CAEA,IAAM,IAAIltB,EAAK,EAAGA,EAAKktB,EAAOltB,IAE7B,IAAM,IAAID,EAAK,EAAGA,EAAKktB,EAAOltB,IAAQ,CAErC,MAAMpgB,EAAIogB,EAAKytB,EAASxtB,EAClBpX,EAAImX,EAAKytB,GAAWxtB,EAAK,GACzBnX,EAAMkX,EAAK,EAAMytB,GAAWxtB,EAAK,GACjCtgB,EAAMqgB,EAAK,EAAMytB,EAASxtB,EAEhCqnB,EAAQ1wC,KAAMgJ,EAAGiJ,EAAGlJ,GACpB2nC,EAAQ1wC,KAAMiS,EAAGC,EAAGnJ,EAErB,CAIDxI,KAAKovC,SAAUe,GACfnwC,KAAK/C,aAAc,WAAY,IAAI,GAAwBw4C,EAAU,IACrEz1C,KAAK/C,aAAc,SAAU,IAAI,GAAwBozC,EAAS,IAClErwC,KAAK/C,aAAc,KAAM,IAAI,GAAwBqzC,EAAK,GAE3D,CAEAl9B,KAAM3P,GAML,OAJA2b,MAAMhM,KAAM3P,GAEZzD,KAAK2/B,WAAav9B,OAAOihB,OAAQ,CAAC,EAAG5f,EAAOk8B,YAErC3/B,IAER,CAEA0c,gBAAiBrZ,GAEhB,OAAO,IAAIi+C,GAAej+C,EAAKsP,MAAOtP,EAAKuP,OAAQvP,EAAKgyC,cAAehyC,EAAKiyC,eAE7E,EAsND,MAoEMqM,GAAc,CACnBC,mBAvRwB,sGAwRxBC,wBAtR6B,kyCAuR7BC,kBArRuB,yFAsRvBC,uBApR4B,6DAqR5BC,mBAnRwB,6EAoRxBC,wBAlR6B,2DAmR7BC,eAjRoB,uaAkRpBC,oBAhRyB,wFAiRzBC,aA/QkB,sGAgRlBC,mBA9QwB,+GA+QxBC,MA7QW,urBA8QXC,qBA5Q0B,w2FA6Q1BC,sBA3Q2B,u4BA4Q3BC,yBA1Q8B,6nBA2Q9BC,8BAzQmC,4HA0QnCC,4BAxQiC,qEAyQjCC,uBAvQ4B,2EAwQ5BC,eAtQoB,+HAuQpBC,oBArQyB,qHAsQzBC,kBApQuB,wJAqQvBC,aAnQkB,iRAoQlBC,OAlQY,m3FAmQZC,4BAjQiC,iqHAkQjCC,qBAhQ0B,2jBAiQ1BC,4BA/PiC,kJAgQjCC,uBA9P4B,kLA+P5BC,qBA7P0B,kJA8P1BC,0BA5P+B,mEA6P/BC,oBA3PyB,sDA4PzBC,yBA1P8B,6QA2P9BC,gBAzPqB,+qCA0PrBC,4BAxPiC,6MAyPjCC,qBAvP0B,+UAwP1BC,mBAtPwB,sTAuPxBC,8BA/NmC,28CAgOnCC,cAtPmB,4oBAuPnBC,WArPgB,wDAsPhBC,gBApPqB,qDAqPrBC,aAnPkB,2RAoPlBC,kBAlPuB,2MAmPvBC,0BAjP+B,8cAkP/BC,kBAhPuB,uNAiPvBC,uBA/O4B,iGAgP5BC,wBA9O6B,sHA+O7BC,6BA7OkC,41BA8OlCC,kBA5OuB,qvJA6OvBC,qBAzO0B,oEA0O1BC,0BAxO+B,0xBAyO/BC,sBAvO2B,sMAwO3BC,2BAtOgC,knCAuOhCC,yBArO8B,wvHAsO9BC,8BApOmC,69cAqOnCC,sBAnO2B,qtKAoO3BC,qBAlO0B,o4BAmO1BC,oBAjOyB,2QAkOzBC,qBAhO0B,mLAiO1BC,0BA/N+B,yKAgO/BC,wBA9N6B,sLA+N7BC,mBA7NwB,+XA8NxBC,aA5NkB,sEA6NlBC,kBA3NuB,mDA4NvBC,sBA1N2B,0WA2N3BC,2BAzNgC,+QA0NhCC,sBAxN2B,mLAyN3BC,2BAvNgC,qEAwNhCC,kBAtNuB,6eAuNvBC,mBArNwB,+jBAsNxBC,wBApN6B,k1BAqN7BC,mBAnNwB,u2BAoNxBC,sBAlN2B,uyCAmN3BC,qBAjN0B,gkBAkN1BC,qBAhN0B,iJAiN1BC,mBA/MwB,iJAgNxBC,cA9MmB,mOA+MnBC,wBA7M6B,q2BA8M7BC,gCA5MqC,yEA6MrCC,+BA3MoC,8OA4MpCC,wBA1M6B,mRA2M7BC,0BAzM+B,oKA0M/BC,gBAxMqB,sLAyMrBC,QAvMa,suDAwMbC,6BAtMkC,4EAuMlCC,eArMoB,oNAsMpBC,mBApMwB,gFAqMxBC,wBAnM6B,2UAoM7BC,sBAlM2B,mLAmM3BC,2BAjMgC,qEAkMhCC,wBAhM6B,07RAiM7BC,sBA/L2B,kzCAgM3BC,iBA9LsB,i+CA+LtBC,yBA7L8B,i5CA8L9BC,gBA5LqB,kOA6LrBC,qBA3L0B,qyBA4L1BC,gBA1LqB,+XA2LrBC,kBAzLuB,qdA0LvBC,qBAxL0B,qMAyL1BC,0BAvL+B,mEAwL/BC,qBAtL0B,6FAuL1BC,0BArL+B,gzCAsL/BC,sBApL2B,8kCAqL3BC,2BAnLgC,kjKAoLhCC,iBAlLsB,snDAmLtBC,eAjLoB,igFAkLpBC,UAhLe,ytFAiLfC,gBA/KqB,+UAiLrBC,gBA/KgB,8JAgLhBC,gBA9KkB,qRA+KlBC,oBA7KgB,iOA8KhBC,oBA5KkB,8wBA6KlBC,UA3KgB,iOA4KhBC,UA1KkB,2VA2KlBC,WAzKgB,wuBA0KhBC,WAxKkB,m8BAyKlBC,kBAvKgB,ktBAwKhBC,kBAtKkB,syBAuKlBC,cArKgB,+LAsKhBC,cApKkB,0TAqKlBC,gBAnKgB,knBAoKhBC,gBAlKkB,+1BAmKlBC,eAjKgB,+3BAkKhBC,eAhKkB,oqDAiKlBC,iBA/JgB,6kCAgKhBC,iBA9JkB,89DA+JlBC,gBA7JgB,k7BA8JhBC,gBA5JkB,+iDA6JlBC,gBA3JgB,o/BA4JhBC,gBA1JkB,8qBA2JlBC,eAzJgB,2kCA0JhBC,eAxJkB,4kEAyJlBC,kBAvJgB,4pCAwJhBC,kBAtJkB,8hIAuJlBC,cArJgB,+gCAsJhBC,cApJkB,20DAqJlBC,YAnJgB,s3BAoJhBC,YAlJkB,m0BAmJlBC,YAjJgB,8lBAkJhBC,YAhJkB,6eAiJlBC,YA/IgB,snCAgJhBC,YA9IkB,0yBAqJbC,GAAc,CAEnBtH,OAAQ,CAEPuH,QAAS,CAAEptD,MAAqB,IAAI2tC,GAAO,WAC3CpH,QAAS,CAAEvmC,MAAO,GAElB6C,IAAK,CAAE7C,MAAO,MACdqtD,aAAc,CAAErtD,MAAqB,IAAI+Y,IAEzC4xB,SAAU,CAAE3qC,MAAO,MACnBstD,kBAAmB,CAAEttD,MAAqB,IAAI+Y,IAE9C2vB,UAAW,CAAE1oC,MAAO,IAIrButD,YAAa,CAEZ5hB,YAAa,CAAE3rC,MAAO,MACtBwtD,qBAAsB,CAAExtD,MAAqB,IAAI+Y,KAIlD00C,OAAQ,CAEP3hB,OAAQ,CAAE9rC,MAAO,MACjB0tD,WAAY,CAAE1tD,OAAS,GACvBisC,aAAc,CAAEjsC,MAAO,GACvB2tD,IAAK,CAAE3tD,MAAO,KACdksC,gBAAiB,CAAElsC,MAAO,MAI3B4tD,MAAO,CAEN9iB,MAAO,CAAE9qC,MAAO,MAChB+qC,eAAgB,CAAE/qC,MAAO,GACzB6tD,eAAgB,CAAE7tD,MAAqB,IAAI+Y,KAI5C+0C,SAAU,CAETljB,SAAU,CAAE5qC,MAAO,MACnB6qC,kBAAmB,CAAE7qC,MAAO,GAC5B+tD,kBAAmB,CAAE/tD,MAAqB,IAAI+Y,KAI/Ci1C,QAAS,CAERhjB,QAAS,CAAEhrC,MAAO,MAClBiuD,iBAAkB,CAAEjuD,MAAqB,IAAI+Y,IAC7CkyB,UAAW,CAAEjrC,MAAO,IAIrBkuD,UAAW,CAEVhjB,UAAW,CAAElrC,MAAO,MACpBmuD,mBAAoB,CAAEnuD,MAAqB,IAAI+Y,IAC/CqyB,YAAa,CAAEprC,MAAqB,IAAIqV,GAAS,EAAG,KAIrD+4C,gBAAiB,CAEhB/iB,gBAAiB,CAAErrC,MAAO,MAC1BquD,yBAA0B,CAAEruD,MAAqB,IAAI+Y,IACrDuyB,kBAAmB,CAAEtrC,MAAO,GAC5BurC,iBAAkB,CAAEvrC,MAAO,IAI5BsuD,YAAa,CAEZ5iB,YAAa,CAAE1rC,MAAO,MACtBuuD,qBAAsB,CAAEvuD,MAAqB,IAAI+Y,KAIlDy1C,aAAc,CAEb/iB,aAAc,CAAEzrC,MAAO,MACvByuD,sBAAuB,CAAEzuD,MAAqB,IAAI+Y,KAInD21C,aAAc,CAEbljB,aAAc,CAAExrC,MAAO,MACvB2uD,sBAAuB,CAAE3uD,MAAqB,IAAI+Y,KAInD61C,YAAa,CAEZziB,YAAa,CAAEnsC,MAAO,OAIvBotC,IAAK,CAEJyhB,WAAY,CAAE7uD,MAAO,OACrB8uD,QAAS,CAAE9uD,MAAO,GAClB+uD,OAAQ,CAAE/uD,MAAO,KACjBgvD,SAAU,CAAEhvD,MAAqB,IAAI2tC,GAAO,YAI7C4M,OAAQ,CAEP0U,kBAAmB,CAAEjvD,MAAO,IAE5BkvD,WAAY,CAAElvD,MAAO,IAErBmvD,kBAAmB,CAAEnvD,MAAO,GAAIovD,WAAY,CAC3C57B,UAAW,CAAC,EACZpV,MAAO,CAAC,IAGTixC,wBAAyB,CAAErvD,MAAO,GAAIovD,WAAY,CACjDE,WAAY,CAAC,EACbC,iBAAkB,CAAC,EACnBC,aAAc,CAAC,EACfC,cAAe,CAAC,IAGjBC,qBAAsB,CAAE1vD,MAAO,IAC/B2vD,wBAAyB,CAAE3vD,MAAO,IAElC4vD,WAAY,CAAE5vD,MAAO,GAAIovD,WAAY,CACpChxC,MAAO,CAAC,EACR4R,SAAU,CAAC,EACXwD,UAAW,CAAC,EACZ8L,SAAU,CAAC,EACXuwB,QAAS,CAAC,EACVC,YAAa,CAAC,EACdC,MAAO,CAAC,IAGTC,iBAAkB,CAAEhwD,MAAO,GAAIovD,WAAY,CAC1CE,WAAY,CAAC,EACbC,iBAAkB,CAAC,EACnBC,aAAc,CAAC,EACfC,cAAe,CAAC,IAGjBQ,aAAc,CAAEjwD,MAAO,IACvBkwD,cAAe,CAAElwD,MAAO,IACxBmwD,gBAAiB,CAAEnwD,MAAO,IAE1BowD,YAAa,CAAEpwD,MAAO,GAAIovD,WAAY,CACrChxC,MAAO,CAAC,EACR4R,SAAU,CAAC,EACX+/B,MAAO,CAAC,EACRzwB,SAAU,CAAC,IAGZ+wB,kBAAmB,CAAErwD,MAAO,GAAIovD,WAAY,CAC3CE,WAAY,CAAC,EACbC,iBAAkB,CAAC,EACnBC,aAAc,CAAC,EACfC,cAAe,CAAC,EAChBa,iBAAkB,CAAC,EACnBC,gBAAiB,CAAC,IAGnBC,eAAgB,CAAExwD,MAAO,IACzBywD,kBAAmB,CAAEzwD,MAAO,IAE5B0wD,iBAAkB,CAAE1wD,MAAO,GAAIovD,WAAY,CAC1C57B,UAAW,CAAC,EACZm9B,SAAU,CAAC,EACXC,YAAa,CAAC,IAIfC,eAAgB,CAAE7wD,MAAO,GAAIovD,WAAY,CACxChxC,MAAO,CAAC,EACR4R,SAAU,CAAC,EACXza,MAAO,CAAC,EACRC,OAAQ,CAAC,IAGVs7C,MAAO,CAAE9wD,MAAO,MAChB+wD,MAAO,CAAE/wD,MAAO,OAIjB0uB,OAAQ,CAEP0+B,QAAS,CAAEptD,MAAqB,IAAI2tC,GAAO,WAC3CpH,QAAS,CAAEvmC,MAAO,GAClB4uB,KAAM,CAAE5uB,MAAO,GACfgd,MAAO,CAAEhd,MAAO,GAChB6C,IAAK,CAAE7C,MAAO,MACd2qC,SAAU,CAAE3qC,MAAO,MACnBstD,kBAAmB,CAAEttD,MAAqB,IAAI+Y,IAC9C2vB,UAAW,CAAE1oC,MAAO,GACpBgxD,YAAa,CAAEhxD,MAAqB,IAAI+Y,KAIzCwoC,OAAQ,CAEP6L,QAAS,CAAEptD,MAAqB,IAAI2tC,GAAO,WAC3CpH,QAAS,CAAEvmC,MAAO,GAClB8Y,OAAQ,CAAE9Y,MAAqB,IAAIqV,GAAS,GAAK,KACjDwH,SAAU,CAAE7c,MAAO,GACnB6C,IAAK,CAAE7C,MAAO,MACdqtD,aAAc,CAAErtD,MAAqB,IAAI+Y,IACzC4xB,SAAU,CAAE3qC,MAAO,MACnBstD,kBAAmB,CAAEttD,MAAqB,IAAI+Y,IAC9C2vB,UAAW,CAAE1oC,MAAO,KAMhBixD,GAAY,CAEjBC,MAAO,CAENzX,SAAwBD,GAAe,CACtC2T,GAAYtH,OACZsH,GAAYI,YACZJ,GAAYM,OACZN,GAAYS,MACZT,GAAYW,SACZX,GAAY/f,MAGbiN,aAAckK,GAAYwH,eAC1BzR,eAAgBiK,GAAYyH,gBAI7BmF,QAAS,CAER1X,SAAwBD,GAAe,CACtC2T,GAAYtH,OACZsH,GAAYI,YACZJ,GAAYM,OACZN,GAAYS,MACZT,GAAYW,SACZX,GAAYmB,YACZnB,GAAYa,QACZb,GAAYe,UACZf,GAAYiB,gBACZjB,GAAY/f,IACZ+f,GAAY5S,OACZ,CACChR,SAAU,CAAEvpC,MAAqB,IAAI2tC,GAAO,OAI9C0M,aAAckK,GAAY0H,iBAC1B3R,eAAgBiK,GAAY2H,kBAI7BkF,MAAO,CAEN3X,SAAwBD,GAAe,CACtC2T,GAAYtH,OACZsH,GAAYI,YACZJ,GAAYM,OACZN,GAAYS,MACZT,GAAYW,SACZX,GAAYmB,YACZnB,GAAYa,QACZb,GAAYe,UACZf,GAAYiB,gBACZjB,GAAY/f,IACZ+f,GAAY5S,OACZ,CACChR,SAAU,CAAEvpC,MAAqB,IAAI2tC,GAAO,IAC5ClE,SAAU,CAAEzpC,MAAqB,IAAI2tC,GAAO,UAC5C/D,UAAW,CAAE5pC,MAAO,OAItBq6C,aAAckK,GAAYgI,eAC1BjS,eAAgBiK,GAAYiI,gBAI7B6E,SAAU,CAET5X,SAAwBD,GAAe,CACtC2T,GAAYtH,OACZsH,GAAYM,OACZN,GAAYS,MACZT,GAAYW,SACZX,GAAYmB,YACZnB,GAAYa,QACZb,GAAYe,UACZf,GAAYiB,gBACZjB,GAAYuB,aACZvB,GAAYqB,aACZrB,GAAY/f,IACZ+f,GAAY5S,OACZ,CACChR,SAAU,CAAEvpC,MAAqB,IAAI2tC,GAAO,IAC5CzE,UAAW,CAAElpC,MAAO,GACpBmpC,UAAW,CAAEnpC,MAAO,GACpBgsC,gBAAiB,CAAEhsC,MAAO,MAI5Bq6C,aAAckK,GAAYkI,kBAC1BnS,eAAgBiK,GAAYmI,mBAI7B4E,KAAM,CAEL7X,SAAwBD,GAAe,CACtC2T,GAAYtH,OACZsH,GAAYS,MACZT,GAAYW,SACZX,GAAYmB,YACZnB,GAAYa,QACZb,GAAYe,UACZf,GAAYiB,gBACZjB,GAAYyB,YACZzB,GAAY/f,IACZ+f,GAAY5S,OACZ,CACChR,SAAU,CAAEvpC,MAAqB,IAAI2tC,GAAO,OAI9C0M,aAAckK,GAAYoI,cAC1BrS,eAAgBiK,GAAYqI,eAI7BliB,OAAQ,CAEP+O,SAAwBD,GAAe,CACtC2T,GAAYtH,OACZsH,GAAYa,QACZb,GAAYe,UACZf,GAAYiB,gBACZjB,GAAY/f,IACZ,CACC1C,OAAQ,CAAE1qC,MAAO,SAInBq6C,aAAckK,GAAY4H,gBAC1B7R,eAAgBiK,GAAY6H,iBAI7B19B,OAAQ,CAEP+qB,SAAwBD,GAAe,CACtC2T,GAAYz+B,OACZy+B,GAAY/f,MAGbiN,aAAckK,GAAYsI,YAC1BvS,eAAgBiK,GAAYuI,aAI7ByE,OAAQ,CAEP9X,SAAwBD,GAAe,CACtC2T,GAAYtH,OACZsH,GAAY/f,IACZ,CACCpwB,MAAO,CAAEhd,MAAO,GAChB6sC,SAAU,CAAE7sC,MAAO,GACnBwxD,UAAW,CAAExxD,MAAO,MAItBq6C,aAAckK,GAAYsH,gBAC1BvR,eAAgBiK,GAAYuH,iBAI7BvmC,MAAO,CAENk0B,SAAwBD,GAAe,CACtC2T,GAAYtH,OACZsH,GAAYiB,kBAGb/T,aAAckK,GAAYgH,WAC1BjR,eAAgBiK,GAAYiH,YAI7Bv+B,OAAQ,CAEPwsB,SAAwBD,GAAe,CACtC2T,GAAYtH,OACZsH,GAAYa,QACZb,GAAYe,UACZf,GAAYiB,gBACZ,CACC7nB,QAAS,CAAEvmC,MAAO,MAIpBq6C,aAAckK,GAAY8H,gBAC1B/R,eAAgBiK,GAAY+H,iBAI7B/K,OAAQ,CAEP9H,SAAwBD,GAAe,CACtC2T,GAAY5L,OACZ4L,GAAY/f,MAGbiN,aAAckK,GAAY0I,YAC1B3S,eAAgBiK,GAAY2I,aAI7BjrB,WAAY,CAEXwX,SAAU,CACTuX,YAAa,CAAEhxD,MAAqB,IAAI+Y,IACxC04C,IAAK,CAAEzxD,MAAO,MACd0xD,oBAAqB,CAAE1xD,MAAO,IAG/Bq6C,aAAckK,GAAY0G,gBAC1B3Q,eAAgBiK,GAAY2G,iBAI7ByG,eAAgB,CAEflY,SAAU,CACT3N,OAAQ,CAAE9rC,MAAO,MACjB0tD,WAAY,CAAE1tD,OAAS,GACvB4xD,qBAAsB,CAAE5xD,MAAO,GAC/B0xD,oBAAqB,CAAE1xD,MAAO,IAG/Bq6C,aAAckK,GAAY4G,oBAC1B7Q,eAAgBiK,GAAY6G,qBAI7ByG,KAAM,CAELpY,SAAU,CACTqY,MAAO,CAAE9xD,MAAO,MAChB+xD,MAAO,CAAE/xD,OAAS,GAClBumC,QAAS,CAAEvmC,MAAO,IAGnBq6C,aAAckK,GAAY8G,UAC1B/Q,eAAgBiK,GAAY+G,WAI7B0G,SAAU,CAETvY,SAAU,CACT6E,UAAW,CAAEt+C,MAAO,OAGrBq6C,aAAckK,GAAYoH,cAC1BrR,eAAgBiK,GAAYqH,eAI7BqG,aAAc,CAEbxY,SAAwBD,GAAe,CACtC2T,GAAYtH,OACZsH,GAAYiB,gBACZ,CACC8D,kBAAmB,CAAElyD,MAAqB,IAAI,IAC9CmyD,aAAc,CAAEnyD,MAAO,GACvBoyD,YAAa,CAAEpyD,MAAO,QAIxBq6C,aAAckK,GAAYkH,kBAC1BnR,eAAgBiK,GAAYmH,mBAI7B2G,OAAQ,CAEP5Y,SAAwBD,GAAe,CACtC2T,GAAY5S,OACZ4S,GAAY/f,IACZ,CACChvB,MAAO,CAAEpe,MAAqB,IAAI2tC,GAAO,IACzCpH,QAAS,CAAEvmC,MAAO,MAIpBq6C,aAAckK,GAAYwI,YAC1BzS,eAAgBiK,GAAYyI,cAM9BiE,GAAUqB,SAAW,CAEpB7Y,SAAwBD,GAAe,CACtCyX,GAAUI,SAAS5X,SACnB,CACC5P,UAAW,CAAE7pC,MAAO,GACpB+pC,aAAc,CAAE/pC,MAAO,MACvBuyD,sBAAuB,CAAEvyD,MAAqB,IAAI+Y,IAClDkxB,mBAAoB,CAAEjqC,MAAO,MAC7BwyD,4BAA6B,CAAExyD,MAAqB,IAAI+Y,IACxDmxB,qBAAsB,CAAElqC,MAAqB,IAAIqV,GAAS,EAAG,IAC7Dy0B,mBAAoB,CAAE9pC,MAAO,GAC7BgqC,sBAAuB,CAAEhqC,MAAO,MAChCyyD,+BAAgC,CAAEzyD,MAAqB,IAAI+Y,IAC3DoxB,YAAa,CAAEnqC,MAAO,GACtBsqC,eAAgB,CAAEtqC,MAAO,MACzB0yD,wBAAyB,CAAE1yD,MAAqB,IAAI+Y,IACpDqxB,eAAgB,CAAEpqC,MAAO,KACzB2yD,4BAA6B,CAAE3yD,MAAO,KACtC4yD,4BAA6B,CAAE5yD,MAAO,KACtCuqC,wBAAyB,CAAEvqC,MAAO,MAClC6yD,iCAAkC,CAAE7yD,MAAqB,IAAI+Y,IAC7DqwB,MAAO,CAAEppC,MAAO,GAChBqpC,WAAY,CAAErpC,MAAqB,IAAI2tC,GAAO,IAC9CmlB,cAAe,CAAE9yD,MAAO,MACxB+yD,uBAAwB,CAAE/yD,MAAqB,IAAI+Y,IACnDuwB,eAAgB,CAAEtpC,MAAO,GACzBgzD,kBAAmB,CAAEhzD,MAAO,MAC5BizD,2BAA4B,CAAEjzD,MAAqB,IAAI+Y,IACvDqzB,aAAc,CAAEpsC,MAAO,GACvBqsC,gBAAiB,CAAErsC,MAAO,MAC1BkzD,yBAA0B,CAAElzD,MAAqB,IAAI+Y,IACrDo6C,wBAAyB,CAAEnzD,MAAqB,IAAIqV,IACpD+9C,uBAAwB,CAAEpzD,MAAO,MACjCssC,UAAW,CAAEtsC,MAAO,GACpBusC,aAAc,CAAEvsC,MAAO,MACvBqzD,sBAAuB,CAAErzD,MAAqB,IAAI+Y,IAClDyzB,oBAAqB,CAAExsC,MAAO,GAC9B0sC,iBAAkB,CAAE1sC,MAAqB,IAAI2tC,GAAO,IACpDhE,cAAe,CAAE3pC,MAAqB,IAAI2tC,GAAO,EAAG,EAAG,IACvD9B,iBAAkB,CAAE7rC,MAAO,MAC3BszD,0BAA2B,CAAEtzD,MAAqB,IAAI+Y,IACtD2wB,kBAAmB,CAAE1pC,MAAO,GAC5B4rC,qBAAsB,CAAE5rC,MAAO,MAC/BuzD,8BAA+B,CAAEvzD,MAAqB,IAAI+Y,IAC1Dy6C,iBAAkB,CAAExzD,MAAqB,IAAIqV,IAC7Co1B,cAAe,CAAEzqC,MAAO,MACxByzD,uBAAwB,CAAEzzD,MAAqB,IAAI+Y,OAIrDshC,aAAckK,GAAYkI,kBAC1BnS,eAAgBiK,GAAYmI,mBAI7B,MAAMgH,GAAO,CAAE9nD,EAAG,EAAG0I,EAAG,EAAGqH,EAAG,GAE9B,SAASg4C,GAAiB/Z,EAAUga,EAAUC,EAAYC,EAAOC,EAAS97C,EAAOqwB,GAEhF,MAAM0rB,EAAa,IAAIrmB,GAAO,GAC9B,IAEIsmB,EACAC,EAHAC,GAAuB,IAAVl8C,EAAiB,EAAI,EAKlCm8C,EAAoB,KACpBC,EAA2B,EAC3BC,EAAqB,KAyLzB,SAASC,EAAUn2C,EAAOnG,GAEzBmG,EAAM6wB,OAAQykB,GAAM/Z,GAA2BC,IAE/Cka,EAAMrR,QAAQrkC,MAAMm2C,SAAUb,GAAK9nD,EAAG8nD,GAAK/3C,EAAG+3C,GAAKp/C,EAAG2D,EAAOqwB,EAE9D,CAEA,MAAO,CAENksB,cAAe,WAEd,OAAOR,CAER,EACAS,cAAe,SAAWr2C,EAAOnG,EAAQ,GAExC+7C,EAAW7+C,IAAKiJ,GAChB+1C,EAAal8C,EACbs8C,EAAUP,EAAYG,EAEvB,EACAO,cAAe,WAEd,OAAOP,CAER,EACAQ,cAAe,SAAW18C,GAEzBk8C,EAAal8C,EACbs8C,EAAUP,EAAYG,EAEvB,EACApW,OAxND,SAAiB6W,EAAYpX,GAE5B,IAAIqX,GAAa,EACb5yB,GAA+B,IAAlBub,EAAMxb,QAAmBwb,EAAMvb,WAAa,KAuB7D,OArBKA,GAAcA,EAAWhgB,YAG7BggB,GADiBub,EAAMoU,qBAAuB,EACpBiC,EAAaD,GAAWnoD,IAAKw2B,IAIpC,OAAfA,EAEJsyB,EAAUP,EAAYG,GAEXlyB,GAAcA,EAAWC,UAEpCqyB,EAAUtyB,EAAY,GACtB4yB,GAAa,GAIHjb,EAASiE,GACYiX,2BAI/B,IAAK,SACJD,GAAa,EACb,MAED,IAAK,WACJf,EAAMrR,QAAQrkC,MAAMm2C,SAAU,EAAG,EAAG,EAAG,EAAGjsB,GAC1CusB,GAAa,EACb,MAED,IAAK,cACJf,EAAMrR,QAAQrkC,MAAMm2C,SAAU,EAAG,EAAG,EAAG,EAAGjsB,GAC1CusB,GAAa,GAKVjb,EAASmb,WAAaF,IAE1Bjb,EAAS3Z,MAAO2Z,EAASob,eAAgBpb,EAASqb,eAAgBrb,EAASsb,kBAIvEjzB,IAAgBA,EAAWgc,eAAiBhc,EAAW3gB,UAAYpU,SAEtDnN,IAAZm0D,IAEJA,EAAU,IAAItd,GACb,IAAIoB,GAAa,EAAG,EAAG,GACvB,IAAIiC,GAAgB,CACnB70C,KAAM,yBACNq0C,SAAUH,GAAe2X,GAAUU,eAAelY,UAClDY,aAAc4W,GAAUU,eAAetX,aACvCC,eAAgB2W,GAAUU,eAAerX,eACzCjU,KA91cW,EA+1cXY,WAAW,EACXC,YAAY,EACZkG,KAAK,KAIP8mB,EAAQnkC,SAASmiB,gBAAiB,UAClCgiB,EAAQnkC,SAASmiB,gBAAiB,MAElCgiB,EAAQx1B,eAAiB,SAAWkb,EAAU4D,EAAO1xB,GAEpDlpB,KAAKupB,YAAY2K,aAAchL,EAAOK,YAEvC,EAGAnnB,OAAOuG,eAAgB2oD,EAAQrxB,SAAU,SAAU,CAElDp3B,IAAK,WAEJ,OAAO7I,KAAK62C,SAAS3N,OAAO9rC,KAE7B,IAID+zD,EAAQ9pD,OAAQiqD,IAIjBA,EAAQrxB,SAAS4W,SAAS3N,OAAO9rC,MAAQiiC,EACzCiyB,EAAQrxB,SAAS4W,SAASiU,WAAW1tD,MAAUiiC,EAAWgc,gBAAsD,IAArChc,EAAWpf,uBAAsC,EAAI,EAChIqxC,EAAQrxB,SAAS4W,SAASmY,qBAAqB5xD,MAAQw9C,EAAMoU,qBAC7DsC,EAAQrxB,SAAS4W,SAASiY,oBAAoB1xD,MAAQw9C,EAAMkU,oBAC5DwC,EAAQrxB,SAAS2F,WAAevG,EAAWrjB,aAAe3P,GAErDmlD,IAAsBnyB,GAC1BoyB,IAA6BpyB,EAAWxhB,SACxC6zC,IAAuB1a,EAAS+D,cAEhCuW,EAAQrxB,SAASniB,aAAc,EAE/B0zC,EAAoBnyB,EACpBoyB,EAA2BpyB,EAAWxhB,QACtC6zC,EAAqB1a,EAAS+D,aAI/BuW,EAAQz3B,OAAOJ,YAGfu4B,EAAWO,QAASjB,EAASA,EAAQnkC,SAAUmkC,EAAQrxB,SAAU,EAAG,EAAG,OAE5DZ,GAAcA,EAAWhgB,iBAEjBliB,IAAdk0D,IAEJA,EAAY,IAAIrd,GACf,IAAIsN,GAAe,EAAG,GACtB,IAAIjK,GAAgB,CACnB70C,KAAM,qBACNq0C,SAAUH,GAAe2X,GAAUhvB,WAAWwX,UAC9CY,aAAc4W,GAAUhvB,WAAWoY,aACnCC,eAAgB2W,GAAUhvB,WAAWqY,eACrCjU,KAAMj6B,EACN66B,WAAW,EACXC,YAAY,EACZkG,KAAK,KAIP6mB,EAAUlkC,SAASmiB,gBAAiB,UAGpCltC,OAAOuG,eAAgB0oD,EAAUpxB,SAAU,MAAO,CAEjDp3B,IAAK,WAEJ,OAAO7I,KAAK62C,SAASgY,IAAIzxD,KAE1B,IAID+zD,EAAQ9pD,OAAQgqD,IAIjBA,EAAUpxB,SAAS4W,SAASgY,IAAIzxD,MAAQiiC,EACxCgyB,EAAUpxB,SAAS4W,SAASiY,oBAAoB1xD,MAAQw9C,EAAMkU,oBAC9DuC,EAAUpxB,SAAS2F,WAAevG,EAAWrjB,aAAe3P,IAEvB,IAAhCgzB,EAAW3f,kBAEf2f,EAAWlf,eAIZkxC,EAAUpxB,SAAS4W,SAASuX,YAAYhxD,MAAMgW,KAAMisB,EAAW1kB,QAE1D62C,IAAsBnyB,GAC1BoyB,IAA6BpyB,EAAWxhB,SACxC6zC,IAAuB1a,EAAS+D,cAEhCsW,EAAUpxB,SAASniB,aAAc,EAEjC0zC,EAAoBnyB,EACpBoyB,EAA2BpyB,EAAWxhB,QACtC6zC,EAAqB1a,EAAS+D,aAI/BsW,EAAUx3B,OAAOJ,YAGjBu4B,EAAWO,QAASlB,EAAWA,EAAUlkC,SAAUkkC,EAAUpxB,SAAU,EAAG,EAAG,MAI/E,EAuCD,CAEA,SAASuyB,GAAoB9S,EAAI7H,EAAYlyC,EAAYg6C,GAExD,MAAM8S,EAAsB/S,EAAGlyB,aAAckyB,EAAGgT,oBAE1CC,EAAYhT,EAAaC,SAAW,KAAO/H,EAAWhvC,IAAK,2BAC3D+pD,EAAejT,EAAaC,UAA0B,OAAd+S,EAExCE,EAAgB,CAAC,EAEjBC,EAAeC,EAAoB,MACzC,IAAIC,EAAeF,EACfG,GAAc,EAqElB,SAASC,EAAuBC,GAE/B,OAAKxT,EAAaC,SAAkBF,EAAG0T,gBAAiBD,GAEjDR,EAAUU,mBAAoBF,EAEtC,CAEA,SAASG,EAAyBH,GAEjC,OAAKxT,EAAaC,SAAkBF,EAAG6T,kBAAmBJ,GAEnDR,EAAUa,qBAAsBL,EAExC,CAqCA,SAASJ,EAAoBI,GAE5B,MAAMM,EAAgB,GAChBC,EAAoB,GACpBC,EAAoB,GAE1B,IAAM,IAAIrzD,EAAI,EAAGA,EAAImyD,EAAqBnyD,IAEzCmzD,EAAenzD,GAAM,EACrBozD,EAAmBpzD,GAAM,EACzBqzD,EAAmBrzD,GAAM,EAI1B,MAAO,CAGN6sB,SAAU,KACVymC,QAAS,KACTzpB,WAAW,EAEXspB,cAAeA,EACfC,kBAAmBA,EACnBC,kBAAmBA,EACnBxnC,OAAQgnC,EACRxtD,WAAY,CAAC,EACb5H,MAAO,KAIT,CA8FA,SAAS81D,IAER,MAAMJ,EAAgBT,EAAaS,cAEnC,IAAM,IAAInzD,EAAI,EAAGmrB,EAAKgoC,EAAc9yD,OAAQL,EAAImrB,EAAInrB,IAEnDmzD,EAAenzD,GAAM,CAIvB,CAEA,SAASwzD,EAAiBh+C,GAEzBi+C,EAA2Bj+C,EAAW,EAEvC,CAEA,SAASi+C,EAA2Bj+C,EAAWk+C,GAE9C,MAAMP,EAAgBT,EAAaS,cAC7BC,EAAoBV,EAAaU,kBACjCC,EAAoBX,EAAaW,kBAEvCF,EAAe39C,GAAc,EAEW,IAAnC49C,EAAmB59C,KAEvB4pC,EAAGuU,wBAAyBn+C,GAC5B49C,EAAmB59C,GAAc,GAI7B69C,EAAmB79C,KAAgBk+C,KAErBrU,EAAaC,SAAWF,EAAK7H,EAAWhvC,IAAK,2BAEpD82C,EAAaC,SAAW,sBAAwB,4BAA8B9pC,EAAWk+C,GACpGL,EAAmB79C,GAAck+C,EAInC,CAEA,SAASE,IAER,MAAMT,EAAgBT,EAAaS,cAC7BC,EAAoBV,EAAaU,kBAEvC,IAAM,IAAIpzD,EAAI,EAAGmrB,EAAKioC,EAAkB/yD,OAAQL,EAAImrB,EAAInrB,IAElDozD,EAAmBpzD,KAAQmzD,EAAenzD,KAE9Co/C,EAAGyU,yBAA0B7zD,GAC7BozD,EAAmBpzD,GAAM,EAM5B,CAEA,SAAS8zD,EAAqBr2D,EAAOiuB,EAAMjf,EAAMqgC,EAAYqF,EAAQ98B,EAAQ0+C,IAE3D,IAAZA,EAEJ3U,EAAG4U,qBAAsBv2D,EAAOiuB,EAAMjf,EAAM0lC,EAAQ98B,GAIpD+pC,EAAG0U,oBAAqBr2D,EAAOiuB,EAAMjf,EAAMqgC,EAAYqF,EAAQ98B,EAIjE,CAmQA,SAAS4+C,IAERC,IACAvB,GAAc,EAETD,IAAiBF,IAEtBE,EAAeF,EACfI,EAAuBF,EAAa7mC,QAErC,CAIA,SAASqoC,IAER1B,EAAa3lC,SAAW,KACxB2lC,EAAac,QAAU,KACvBd,EAAa3oB,WAAY,CAE1B,CAEA,MAAO,CAENsqB,MAvlBD,SAAgBtoC,EAAQ8T,EAAU2zB,EAASzmC,EAAUpvB,GAEpD,IAAI22D,GAAgB,EAEpB,GAAK9B,EAAe,CAEnB,MAAM1B,EA6ER,SAA0B/jC,EAAUymC,EAAS3zB,GAE5C,MAAMkK,GAAqC,IAAvBlK,EAASkK,UAE7B,IAAIwqB,EAAa9B,EAAe1lC,EAASxtB,SAErBxC,IAAfw3D,IAEJA,EAAa,CAAC,EACd9B,EAAe1lC,EAASxtB,IAAOg1D,GAIhC,IAAIC,EAAWD,EAAYf,EAAQj0D,SAEjBxC,IAAby3D,IAEJA,EAAW,CAAC,EACZD,EAAYf,EAAQj0D,IAAOi1D,GAI5B,IAAI1D,EAAQ0D,EAAUzqB,GAStB,YAPehtC,IAAV+zD,IAEJA,EAAQ6B,EAhDJpT,EAAaC,SAAkBF,EAAGmV,oBAEhClC,EAAUmC,wBA+ChBF,EAAUzqB,GAAc+mB,GAIlBA,CAER,CA9GgB6D,CAAiB5nC,EAAUymC,EAAS3zB,GAE7C+yB,IAAiB9B,IAErB8B,EAAe9B,EACfgC,EAAuBF,EAAa7mC,SAIrCuoC,EAuIF,SAAsBvoC,EAAQgB,EAAUymC,EAAS71D,GAEhD,MAAMi3D,EAAmBhC,EAAartD,WAChCsvD,EAAqB9nC,EAASxnB,WAEpC,IAAIuvD,EAAgB,EAEpB,MAAMC,EAAoBvB,EAAQwB,gBAElC,IAAM,MAAM5yD,KAAQ2yD,EAInB,GAFyBA,EAAmB3yD,GAEtBlF,UAAY,EAAI,CAErC,MAAM+3D,EAAkBL,EAAkBxyD,GAC1C,IAAI8yD,EAAoBL,EAAoBzyD,GAS5C,QAP2BrF,IAAtBm4D,IAEU,mBAAT9yD,GAA6B2pB,EAAO+S,iBAAiBo2B,EAAoBnpC,EAAO+S,gBACvE,kBAAT18B,GAA4B2pB,EAAOgT,gBAAgBm2B,EAAoBnpC,EAAOgT,qBAI3DhiC,IAApBk4D,EAAgC,OAAO,EAE5C,GAAKA,EAAgBv/C,YAAcw/C,EAAoB,OAAO,EAE9D,GAAKA,GAAqBD,EAAgBhyD,OAASiyD,EAAkBjyD,KAAO,OAAO,EAEnF6xD,GAED,CAID,OAAKlC,EAAakC,gBAAkBA,GAE/BlC,EAAaj1D,QAAUA,CAI7B,CAlLkB+f,CAAaqO,EAAQgB,EAAUymC,EAAS71D,GAEnD22D,GAkLP,SAAoBvoC,EAAQgB,EAAUymC,EAAS71D,GAE9C,MAAMsiC,EAAQ,CAAC,EACT16B,EAAawnB,EAASxnB,WAC5B,IAAIuvD,EAAgB,EAEpB,MAAMC,EAAoBvB,EAAQwB,gBAElC,IAAM,MAAM5yD,KAAQ2yD,EAInB,GAFyBA,EAAmB3yD,GAEtBlF,UAAY,EAAI,CAErC,IAAIwY,EAAYnQ,EAAYnD,QAETrF,IAAd2Y,IAEU,mBAATtT,GAA6B2pB,EAAO+S,iBAAiBppB,EAAYqW,EAAO+S,gBAC/D,kBAAT18B,GAA4B2pB,EAAOgT,gBAAgBrpB,EAAYqW,EAAOgT,gBAI5E,MAAM97B,EAAO,CAAC,EACdA,EAAKyS,UAAYA,EAEZA,GAAaA,EAAUzS,OAE3BA,EAAKA,KAAOyS,EAAUzS,MAIvBg9B,EAAO79B,GAASa,EAEhB6xD,GAED,CAIDlC,EAAartD,WAAa06B,EAC1B2yB,EAAakC,cAAgBA,EAE7BlC,EAAaj1D,MAAQA,CAEtB,CA/NuBw3D,CAAWppC,EAAQgB,EAAUymC,EAAS71D,EAE5D,KAAO,CAEN,MAAMosC,GAAqC,IAAvBlK,EAASkK,UAExB6oB,EAAa7lC,WAAaA,EAASxtB,IACvCqzD,EAAaY,UAAYA,EAAQj0D,IACjCqzD,EAAa7oB,YAAcA,IAE3B6oB,EAAa7lC,SAAWA,EAASxtB,GACjCqzD,EAAaY,QAAUA,EAAQj0D,GAC/BqzD,EAAa7oB,UAAYA,EAEzBuqB,GAAgB,EAIlB,CAEe,OAAV32D,GAEJ4H,EAAW0B,OAAQtJ,EAAO2hD,EAAG8V,uBAIzBd,GAAiBzB,KAErBA,GAAc,EAiRhB,SAAgC9mC,EAAQ8T,EAAU2zB,EAASzmC,GAE1D,IAA+B,IAA1BwyB,EAAaC,WAAwBzzB,EAAO8S,iBAAmB9R,EAASsoC,4BAExB,OAA/C5d,EAAWhvC,IAAK,0BAAsC,OAI5DgrD,IAEA,MAAMoB,EAAqB9nC,EAASxnB,WAE9BwvD,EAAoBvB,EAAQwB,gBAE5BM,EAAiCz1B,EAASiY,uBAEhD,IAAM,MAAM11C,KAAQ2yD,EAAoB,CAEvC,MAAMQ,EAAmBR,EAAmB3yD,GAE5C,GAAKmzD,EAAiBr4D,UAAY,EAAI,CAErC,IAAIg4D,EAAoBL,EAAoBzyD,GAS5C,QAP2BrF,IAAtBm4D,IAEU,mBAAT9yD,GAA6B2pB,EAAO+S,iBAAiBo2B,EAAoBnpC,EAAO+S,gBACvE,kBAAT18B,GAA4B2pB,EAAOgT,gBAAgBm2B,EAAoBnpC,EAAOgT,qBAIzDhiC,IAAtBm4D,EAAkC,CAEtC,MAAMloB,EAAakoB,EAAkBloB,WAC/BphB,EAAOspC,EAAkBnoB,SAEzBr3B,EAAYnQ,EAAWkD,IAAKysD,GAIlC,QAAmBn4D,IAAd2Y,EAA0B,SAE/B,MAAMkqC,EAASlqC,EAAUkqC,OACnBjzC,EAAO+I,EAAU/I,KACjBqzC,EAAkBtqC,EAAUsqC,gBAI5BiU,GAAsC,IAA1B1U,EAAaC,WAAuB7yC,IAAS2yC,EAAGqB,KAAOh0C,IAAS2yC,EAAGoB,cAxzd1E,OAwzd0FwU,EAAkB9nB,SAEvH,GAAK8nB,EAAkB9iB,6BAA+B,CAErD,MAAMnvC,EAAOiyD,EAAkBjyD,KACzBovC,EAASpvC,EAAKovC,OACd98B,EAAS2/C,EAAkB3/C,OAEjC,GAAKtS,EAAKuyD,6BAA+B,CAExC,IAAM,IAAIt1D,EAAI,EAAGA,EAAIq1D,EAAiBE,aAAcv1D,IAEnDyzD,EAA2B4B,EAAiBr4D,SAAWgD,EAAG+C,EAAK2wD,mBAIhC,IAA3B7nC,EAAO8S,sBAA2D9hC,IAA/BgwB,EAAS2oC,oBAEhD3oC,EAAS2oC,kBAAoBzyD,EAAK2wD,iBAAmB3wD,EAAK4B,MAI5D,MAEC,IAAM,IAAI3E,EAAI,EAAGA,EAAIq1D,EAAiBE,aAAcv1D,IAEnDwzD,EAAiB6B,EAAiBr4D,SAAWgD,GAM/Co/C,EAAGa,WAAYb,EAAGqW,aAAc/V,GAEhC,IAAM,IAAI1/C,EAAI,EAAGA,EAAIq1D,EAAiBE,aAAcv1D,IAEnD8zD,EACCuB,EAAiBr4D,SAAWgD,EAC5B0rB,EAAO2pC,EAAiBE,aACxB9oD,EACAqgC,EACAqF,EAAS2N,GACPzqC,EAAWqW,EAAO2pC,EAAiBE,aAAiBv1D,GAAM8/C,EAC5DiU,EAKH,KAAO,CAEN,GAAKiB,EAAkBU,2BAA6B,CAEnD,IAAM,IAAI11D,EAAI,EAAGA,EAAIq1D,EAAiBE,aAAcv1D,IAEnDyzD,EAA2B4B,EAAiBr4D,SAAWgD,EAAGg1D,EAAkBtB,mBAI7C,IAA3B7nC,EAAO8S,sBAA2D9hC,IAA/BgwB,EAAS2oC,oBAEhD3oC,EAAS2oC,kBAAoBR,EAAkBtB,iBAAmBsB,EAAkBrwD,MAItF,MAEC,IAAM,IAAI3E,EAAI,EAAGA,EAAIq1D,EAAiBE,aAAcv1D,IAEnDwzD,EAAiB6B,EAAiBr4D,SAAWgD,GAM/Co/C,EAAGa,WAAYb,EAAGqW,aAAc/V,GAEhC,IAAM,IAAI1/C,EAAI,EAAGA,EAAIq1D,EAAiBE,aAAcv1D,IAEnD8zD,EACCuB,EAAiBr4D,SAAWgD,EAC5B0rB,EAAO2pC,EAAiBE,aACxB9oD,EACAqgC,EACAphB,EAAOo0B,EACLp0B,EAAO2pC,EAAiBE,aAAiBv1D,EAAI8/C,EAC/CiU,EAKH,CAED,MAAO,QAAwCl3D,IAAnCu4D,EAA+C,CAE1D,MAAMt4D,EAAQs4D,EAAgClzD,GAE9C,QAAerF,IAAVC,EAEJ,OAASA,EAAMuD,QAEd,KAAK,EACJ++C,EAAGuW,gBAAiBN,EAAiBr4D,SAAUF,GAC/C,MAED,KAAK,EACJsiD,EAAGwW,gBAAiBP,EAAiBr4D,SAAUF,GAC/C,MAED,KAAK,EACJsiD,EAAGyW,gBAAiBR,EAAiBr4D,SAAUF,GAC/C,MAED,QACCsiD,EAAG0W,gBAAiBT,EAAiBr4D,SAAUF,GAMnD,CAED,CAED,CAEA82D,GAED,CA9bEmC,CAAuBlqC,EAAQ8T,EAAU2zB,EAASzmC,GAEnC,OAAVpvB,GAEJ2hD,EAAGa,WAAYb,EAAG8V,qBAAsB7vD,EAAWkD,IAAK9K,GAAQiiD,QAMnE,EA+hBCuU,MAAOA,EACPC,kBAAmBA,EACnB/zC,QA3GD,WAEC8zC,IAEA,IAAM,MAAM+B,KAAczD,EAAgB,CAEzC,MAAM8B,EAAa9B,EAAeyD,GAElC,IAAM,MAAMC,KAAa5B,EAAa,CAErC,MAAMC,EAAWD,EAAY4B,GAE7B,IAAM,MAAMpsB,KAAayqB,EAExBtB,EAAyBsB,EAAUzqB,GAAYhe,eAExCyoC,EAAUzqB,UAIXwqB,EAAY4B,EAEpB,QAEO1D,EAAeyD,EAEvB,CAED,EAgFCE,wBA9ED,SAAkCrpC,GAEjC,QAAsChwB,IAAjC01D,EAAe1lC,EAASxtB,IAAqB,OAElD,MAAMg1D,EAAa9B,EAAe1lC,EAASxtB,IAE3C,IAAM,MAAM42D,KAAa5B,EAAa,CAErC,MAAMC,EAAWD,EAAY4B,GAE7B,IAAM,MAAMpsB,KAAayqB,EAExBtB,EAAyBsB,EAAUzqB,GAAYhe,eAExCyoC,EAAUzqB,UAIXwqB,EAAY4B,EAEpB,QAEO1D,EAAe1lC,EAASxtB,GAEhC,EAuDC82D,uBArDD,SAAiC7C,GAEhC,IAAM,MAAM0C,KAAczD,EAAgB,CAEzC,MAAM8B,EAAa9B,EAAeyD,GAElC,QAAkCn5D,IAA7Bw3D,EAAYf,EAAQj0D,IAAqB,SAE9C,MAAMi1D,EAAWD,EAAYf,EAAQj0D,IAErC,IAAM,MAAMwqC,KAAayqB,EAExBtB,EAAyBsB,EAAUzqB,GAAYhe,eAExCyoC,EAAUzqB,UAIXwqB,EAAYf,EAAQj0D,GAE5B,CAED,EAiCCk0D,eAAgBA,EAChBC,gBAAiBA,EACjBI,wBAAyBA,EAI3B,CAEA,SAASwC,GAAqBhX,EAAI7H,EAAY8e,EAAMhX,GAEnD,MAAMC,EAAWD,EAAaC,SAE9B,IAAIgX,EAiDJ52D,KAAK62D,QA/CL,SAAkBz5D,GAEjBw5D,EAAOx5D,CAER,EA4CA4C,KAAKm7C,OA1CL,SAAiBjM,EAAOjqC,GAEvBy6C,EAAGoX,WAAYF,EAAM1nB,EAAOjqC,GAE5B0xD,EAAKtvD,OAAQpC,EAAO2xD,EAAM,EAE3B,EAqCA52D,KAAK+2D,gBAnCL,SAA0B7nB,EAAOjqC,EAAO+xD,GAEvC,GAAmB,IAAdA,EAAkB,OAEvB,IAAIrE,EAAWsE,EAEf,GAAKrX,EAEJ+S,EAAYjT,EACZuX,EAAa,2BAOb,GAHAtE,EAAY9a,EAAWhvC,IAAK,0BAC5BouD,EAAa,2BAEM,OAAdtE,EAGJ,YADAr0D,QAAQ6+B,MAAO,kIAOjBw1B,EAAWsE,GAAcL,EAAM1nB,EAAOjqC,EAAO+xD,GAE7CL,EAAKtvD,OAAQpC,EAAO2xD,EAAMI,EAE3B,CAQD,CAEA,SAASE,GAAmBxX,EAAI7H,EAAYlY,GAE3C,IAAIw3B,EAsBJ,SAASC,EAAiBhyB,GAEzB,GAAmB,UAAdA,EAAwB,CAE5B,GAAKsa,EAAG2X,yBAA0B3X,EAAG4X,cAAe5X,EAAG6X,YAAanyB,UAAY,GAC/Esa,EAAG2X,yBAA0B3X,EAAG8X,gBAAiB9X,EAAG6X,YAAanyB,UAAY,EAE7E,MAAO,QAIRA,EAAY,SAEb,CAEA,MAAmB,YAAdA,GAECsa,EAAG2X,yBAA0B3X,EAAG4X,cAAe5X,EAAG+X,cAAeryB,UAAY,GACjFsa,EAAG2X,yBAA0B3X,EAAG8X,gBAAiB9X,EAAG+X,cAAeryB,UAAY,EAExE,UAMF,MAER,CAEA,MAAMwa,EAA6C,oBAA3B8X,wBAAkE,2BAAxBhY,EAAGn9C,YAAYC,KAEjF,IAAI4iC,OAAqCjoC,IAAzBwiC,EAAWyF,UAA0BzF,EAAWyF,UAAY,QAC5E,MAAMuyB,EAAeP,EAAiBhyB,GAEjCuyB,IAAiBvyB,IAErB9mC,QAAQkU,KAAM,uBAAwB4yB,EAAW,uBAAwBuyB,EAAc,YACvFvyB,EAAYuyB,GAIb,MAAM3f,EAAc4H,GAAY/H,EAAW+f,IAAK,sBAE1CC,GAA+D,IAAtCl4B,EAAWk4B,uBAEpCC,EAAcpY,EAAGlyB,aAAckyB,EAAGqY,yBAClCC,EAAoBtY,EAAGlyB,aAAckyB,EAAGuY,gCACxCC,EAAiBxY,EAAGlyB,aAAckyB,EAAGyY,kBACrCC,EAAiB1Y,EAAGlyB,aAAckyB,EAAG2Y,2BAErCC,EAAgB5Y,EAAGlyB,aAAckyB,EAAGgT,oBACpC6F,EAAoB7Y,EAAGlyB,aAAckyB,EAAG8Y,4BACxCC,EAAc/Y,EAAGlyB,aAAckyB,EAAGgZ,qBAClCC,EAAsBjZ,EAAGlyB,aAAckyB,EAAGkZ,8BAE1CC,EAAiBb,EAAoB,EACrCc,EAAwBlZ,GAAY/H,EAAW+f,IAAK,qBAK1D,MAAO,CAENhY,SAAUA,EAEV5H,YAAaA,EAEb+gB,iBAxFD,WAEC,QAAuB57D,IAAlBg6D,EAA8B,OAAOA,EAE1C,IAA4D,IAAvDtf,EAAW+f,IAAK,kCAA8C,CAElE,MAAMjF,EAAY9a,EAAWhvC,IAAK,kCAElCsuD,EAAgBzX,EAAGlyB,aAAcmlC,EAAUqG,+BAE5C,MAEC7B,EAAgB,EAIjB,OAAOA,CAER,EAuECC,gBAAiBA,EAEjBhyB,UAAWA,EACXyyB,uBAAwBA,EAExBC,YAAaA,EACbE,kBAAmBA,EACnBE,eAAgBA,EAChBE,eAAgBA,EAEhBE,cAAeA,EACfC,kBAAmBA,EACnBE,YAAaA,EACbE,oBAAqBA,EAErBE,eAAgBA,EAChBC,sBAAuBA,EACvBG,oBA5B2BJ,GAAkBC,EA8B7CI,WA5BkBtZ,EAAWF,EAAGlyB,aAAckyB,EAAGyZ,aAAgB,EAgCnE,CAEA,SAASC,GAAe5M,GAEvB,MAAMhX,EAAQx1C,KAEd,IAAIq5D,EAAc,KACjBC,EAAkB,EAClBC,GAAuB,EACvBC,GAAmB,EAEpB,MAAM1rC,EAAQ,IAAImuB,GACjBwd,EAAmB,IAAItjD,GAEvBujD,EAAU,CAAEt8D,MAAO,KAAM0gB,aAAa,GA2GvC,SAAS67C,EAAerc,EAAQp0B,EAAQhF,EAAW01C,GAElD,MAAMC,EAAqB,OAAXvc,EAAkBA,EAAO38C,OAAS,EAClD,IAAIm5D,EAAW,KAEf,GAAiB,IAAZD,EAAgB,CAIpB,GAFAC,EAAWJ,EAAQt8D,OAEI,IAAlBw8D,GAAuC,OAAbE,EAAoB,CAElD,MAAMC,EAAW71C,EAAsB,EAAV21C,EAC5BG,EAAa9wC,EAAOC,mBAErBswC,EAAiBhgD,gBAAiBugD,IAEhB,OAAbF,GAAqBA,EAASn5D,OAASo5D,KAE3CD,EAAW,IAAI3qD,aAAc4qD,IAI9B,IAAM,IAAIz5D,EAAI,EAAG25D,EAAK/1C,EAAW5jB,IAAMu5D,IAAYv5D,EAAG25D,GAAM,EAE3DnsC,EAAM1a,KAAMkqC,EAAQh9C,IAAM6gB,aAAc64C,EAAYP,GAEpD3rC,EAAMzD,OAAOzU,QAASkkD,EAAUG,GAChCH,EAAUG,EAAK,GAAMnsC,EAAMC,QAI7B,CAEA2rC,EAAQt8D,MAAQ08D,EAChBJ,EAAQ57C,aAAc,CAEvB,CAKA,OAHA03B,EAAM0kB,UAAYL,EAClBrkB,EAAM2kB,gBAAkB,EAEjBL,CAER,CApJA95D,KAAK05D,QAAUA,EACf15D,KAAKk6D,UAAY,EACjBl6D,KAAKm6D,gBAAkB,EAEvBn6D,KAAKo6D,KAAO,SAAW9c,EAAQ+c,GAE9B,MAAMx+C,EACa,IAAlByhC,EAAO38C,QACP05D,GAGoB,IAApBf,GACAC,EAMD,OAJAA,EAAuBc,EAEvBf,EAAkBhc,EAAO38C,OAElBkb,CAER,EAEA7b,KAAKs6D,aAAe,WAEnBd,GAAmB,EACnBG,EAAe,KAEhB,EAEA35D,KAAKu6D,WAAa,WAEjBf,GAAmB,CAEpB,EAEAx5D,KAAKw6D,eAAiB,SAAWld,EAAQp0B,GAExCmwC,EAAcM,EAAerc,EAAQp0B,EAAQ,EAE9C,EAEAlpB,KAAKy6D,SAAW,SAAWx6B,EAAU/W,EAAQwxC,GAE5C,MAAMpd,EAASrd,EAAS8E,eACvBC,EAAmB/E,EAAS+E,iBAC5BC,EAAchF,EAASgF,YAElB01B,EAAqBnO,EAAW3jD,IAAKo3B,GAE3C,IAAOs5B,GAAmC,OAAXjc,GAAqC,IAAlBA,EAAO38C,QAAgB64D,IAAsBv0B,EAIzFu0B,EAIJG,EAAe,OAoCZD,EAAQt8D,QAAUi8D,IAEtBK,EAAQt8D,MAAQi8D,EAChBK,EAAQ57C,YAAcw7C,EAAkB,GAIzC9jB,EAAM0kB,UAAYZ,EAClB9jB,EAAM2kB,gBAAkB,OApCjB,CAEN,MAAMS,EAAUpB,EAAmB,EAAIF,EACtCuB,EAAoB,EAAVD,EAEX,IAAId,EAAWa,EAAmBG,eAAiB,KAEnDpB,EAAQt8D,MAAQ08D,EAEhBA,EAAWH,EAAerc,EAAQp0B,EAAQ2xC,EAASH,GAEnD,IAAM,IAAIp6D,EAAI,EAAGA,IAAMu6D,IAAYv6D,EAElCw5D,EAAUx5D,GAAM+4D,EAAa/4D,GAI9Bq6D,EAAmBG,cAAgBhB,EACnC95D,KAAKm6D,gBAAkBn1B,EAAmBhlC,KAAKk6D,UAAY,EAC3Dl6D,KAAKk6D,WAAaU,CAEnB,CAGD,CA6DD,CAEA,SAASG,GAAe/jB,GAEvB,IAAIga,EAAW,IAAIlR,QAEnB,SAASkb,EAAmBj4C,EAASrE,GAYpC,OA36euC,MAi6elCA,EAEJqE,EAAQrE,QAAUtU,EAl6eoB,MAo6e3BsU,IAEXqE,EAAQrE,QAAUrU,GAIZ0Y,CAER,CA+CA,SAASk4C,EAAkBztD,GAE1B,MAAMuV,EAAUvV,EAAMpJ,OAEtB2e,EAAQ1V,oBAAqB,UAAW4tD,GAExC,MAAMC,EAAUlK,EAASnoD,IAAKka,QAEb5lB,IAAZ+9D,IAEJlK,EAAS/Q,OAAQl9B,GACjBm4C,EAAQz6C,UAIV,CAQA,MAAO,CACN5X,IArED,SAAcka,GAEb,GAAKA,GAAWA,EAAQ1D,YAA+C,IAAlC0D,EAAQ9C,sBAAkC,CAE9E,MAAMvB,EAAUqE,EAAQrE,QAExB,GAr7esC,MAq7ejCA,GAp7eiC,MAo7eeA,EAA+C,CAEnG,GAAKsyC,EAAS4G,IAAK70C,GAGlB,OAAOi4C,EADShK,EAASnoD,IAAKka,GAAUA,QACLA,EAAQrE,SAErC,CAEN,MAAM/B,EAAQoG,EAAQpG,MAEtB,GAAKA,GAASA,EAAM/J,OAAS,EAAI,CAEhC,MAAMunC,EAAe,IAAImB,GAAuB3+B,EAAM/J,OAAS,GAM/D,OALAunC,EAAaqB,2BAA4BxE,EAAUj0B,GACnDiuC,EAASz+C,IAAKwQ,EAASo3B,GAEvBp3B,EAAQ9mB,iBAAkB,UAAWg/D,GAE9BD,EAAmB7gB,EAAap3B,QAASA,EAAQrE,QAEzD,CAIC,OAAO,IAIT,CAED,CAED,CAEA,OAAOqE,CAER,EA2BCtC,QARD,WAECuwC,EAAW,IAAIlR,OAEhB,EAOD,CAEA,MAAMqb,WAA2B5iB,GAEhCh2C,YAAa21B,GAAO,EAAKC,EAAQ,EAAGC,EAAM,EAAGC,GAAS,EAAKC,EAAO,GAAKC,EAAM,KAE5EnZ,QAEApf,KAAKo7D,sBAAuB,EAE5Bp7D,KAAK+M,KAAO,qBAEZ/M,KAAK44C,KAAO,EACZ54C,KAAK84C,KAAO,KAEZ94C,KAAKk4B,KAAOA,EACZl4B,KAAKm4B,MAAQA,EACbn4B,KAAKo4B,IAAMA,EACXp4B,KAAKq4B,OAASA,EAEdr4B,KAAKs4B,KAAOA,EACZt4B,KAAKu4B,IAAMA,EAEXv4B,KAAKi5C,wBAEN,CAEA7lC,KAAM3P,EAAQ88B,GAcb,OAZAnhB,MAAMhM,KAAM3P,EAAQ88B,GAEpBvgC,KAAKk4B,KAAOz0B,EAAOy0B,KACnBl4B,KAAKm4B,MAAQ10B,EAAO00B,MACpBn4B,KAAKo4B,IAAM30B,EAAO20B,IAClBp4B,KAAKq4B,OAAS50B,EAAO40B,OACrBr4B,KAAKs4B,KAAO70B,EAAO60B,KACnBt4B,KAAKu4B,IAAM90B,EAAO80B,IAElBv4B,KAAK44C,KAAOn1C,EAAOm1C,KACnB54C,KAAK84C,KAAuB,OAAhBr1C,EAAOq1C,KAAgB,KAAO12C,OAAOihB,OAAQ,CAAC,EAAG5f,EAAOq1C,MAE7D94C,IAER,CAEA25C,cAAeC,EAAWC,EAAYv9C,EAAGE,EAAGmW,EAAOC,GAE/B,OAAd5S,KAAK84C,OAET94C,KAAK84C,KAAO,CACXj9B,SAAS,EACT+9B,UAAW,EACXC,WAAY,EACZC,QAAS,EACTC,QAAS,EACTpnC,MAAO,EACPC,OAAQ,IAKV5S,KAAK84C,KAAKj9B,SAAU,EACpB7b,KAAK84C,KAAKc,UAAYA,EACtB55C,KAAK84C,KAAKe,WAAaA,EACvB75C,KAAK84C,KAAKgB,QAAUx9C,EACpB0D,KAAK84C,KAAKiB,QAAUv9C,EACpBwD,KAAK84C,KAAKnmC,MAAQA,EAClB3S,KAAK84C,KAAKlmC,OAASA,EAEnB5S,KAAKi5C,wBAEN,CAEAe,kBAEoB,OAAdh6C,KAAK84C,OAET94C,KAAK84C,KAAKj9B,SAAU,GAIrB7b,KAAKi5C,wBAEN,CAEAA,yBAEC,MAAMp7C,GAAOmC,KAAKm4B,MAAQn4B,KAAKk4B,OAAW,EAAIl4B,KAAK44C,MAC7C96C,GAAOkC,KAAKo4B,IAAMp4B,KAAKq4B,SAAa,EAAIr4B,KAAK44C,MAC7C1+B,GAAOla,KAAKm4B,MAAQn4B,KAAKk4B,MAAS,EAClC/d,GAAOna,KAAKo4B,IAAMp4B,KAAKq4B,QAAW,EAExC,IAAIH,EAAOhe,EAAKrc,EACZs6B,EAAQje,EAAKrc,EACbu6B,EAAMje,EAAKrc,EACXu6B,EAASle,EAAKrc,EAElB,GAAmB,OAAdkC,KAAK84C,MAAiB94C,KAAK84C,KAAKj9B,QAAU,CAE9C,MAAMw/C,GAAWr7D,KAAKm4B,MAAQn4B,KAAKk4B,MAASl4B,KAAK84C,KAAKc,UAAY55C,KAAK44C,KACjE0iB,GAAWt7D,KAAKo4B,IAAMp4B,KAAKq4B,QAAWr4B,KAAK84C,KAAKe,WAAa75C,KAAK44C,KAExE1gB,GAAQmjC,EAASr7D,KAAK84C,KAAKgB,QAC3B3hB,EAAQD,EAAOmjC,EAASr7D,KAAK84C,KAAKnmC,MAClCylB,GAAOkjC,EAASt7D,KAAK84C,KAAKiB,QAC1B1hB,EAASD,EAAMkjC,EAASt7D,KAAK84C,KAAKlmC,MAEnC,CAEA5S,KAAKopB,iBAAiBqP,iBAAkBP,EAAMC,EAAOC,EAAKC,EAAQr4B,KAAKs4B,KAAMt4B,KAAKu4B,IAAKv4B,KAAKw4B,kBAE5Fx4B,KAAKspB,wBAAwBlW,KAAMpT,KAAKopB,kBAAmBnQ,QAE5D,CAEA8E,OAAQC,GAEP,MAAM3a,EAAO+b,MAAMrB,OAAQC,GAY3B,OAVA3a,EAAK8oB,OAAOysB,KAAO54C,KAAK44C,KACxBv1C,EAAK8oB,OAAO+L,KAAOl4B,KAAKk4B,KACxB70B,EAAK8oB,OAAOgM,MAAQn4B,KAAKm4B,MACzB90B,EAAK8oB,OAAOiM,IAAMp4B,KAAKo4B,IACvB/0B,EAAK8oB,OAAOkM,OAASr4B,KAAKq4B,OAC1Bh1B,EAAK8oB,OAAOmM,KAAOt4B,KAAKs4B,KACxBj1B,EAAK8oB,OAAOoM,IAAMv4B,KAAKu4B,IAEJ,OAAdv4B,KAAK84C,OAAgBz1C,EAAK8oB,OAAO2sB,KAAO12C,OAAOihB,OAAQ,CAAC,EAAGrjB,KAAK84C,OAE9Dz1C,CAER,EAID,MAMMk4D,GAAkB,CAAE,KAAO,KAAO,IAAM,KAAO,KAAO,MAMtDC,GAA4B,IAAIL,GAChCM,GAA4B,IAAI1wB,GACtC,IAAI2wB,GAAa,KAGjB,MAAMC,IAAQ,EAAI39D,KAAKC,KAAM,IAAQ,EAC/B29D,GAAU,EAAID,GAIdE,GAAkB,CACT,IAAI,GAAS,EAAG,EAAG,GACnB,IAAI,IAAW,EAAG,EAAG,GACrB,IAAI,GAAS,EAAG,GAAK,GACrB,IAAI,IAAW,EAAG,GAAK,GACvB,IAAI,GAAS,EAAGF,GAAKC,IACrB,IAAI,GAAS,EAAGD,IAAOC,IACvB,IAAI,GAASA,GAAS,EAAGD,IACzB,IAAI,IAAWC,GAAS,EAAGD,IAC3B,IAAI,GAASA,GAAKC,GAAS,GAC3B,IAAI,IAAWD,GAAKC,GAAS,IAiB5C,MAAME,GAELv5D,YAAay0C,GAEZh3C,KAAK+7D,UAAY/kB,EACjBh3C,KAAKg8D,sBAAwB,KAE7Bh8D,KAAKi8D,QAAU,EACfj8D,KAAKk8D,UAAY,EACjBl8D,KAAKm8D,WAAa,GAClBn8D,KAAKo8D,UAAY,GACjBp8D,KAAKq8D,QAAU,GAEfr8D,KAAKs8D,cAAgB,KACrBt8D,KAAKu8D,iBAAmB,KACxBv8D,KAAKw8D,kBAAoB,KAEzBx8D,KAAKy8D,iBAAkBz8D,KAAKs8D,cAE7B,CASAI,UAAW9hB,EAAO+hB,EAAQ,EAAGrkC,EAAO,GAAKC,EAAM,KAE9CmjC,GAAa17D,KAAK+7D,UAAU9kB,kBAE5Bj3C,KAAK48D,SAAU,KAEf,MAAMC,EAAqB78D,KAAK88D,mBAchC,OAbAD,EAAmB75C,aAAc,EAEjChjB,KAAK+8D,eAAgBniB,EAAOtiB,EAAMC,EAAKskC,GAElCF,EAAQ,GAEZ38D,KAAKg9D,MAAOH,EAAoB,EAAG,EAAGF,GAIvC38D,KAAKi9D,YAAaJ,GAClB78D,KAAKk9D,SAAUL,GAERA,CAER,CAOAM,oBAAqBC,EAAiBjjB,EAAe,MAEpD,OAAOn6C,KAAKq9D,aAAcD,EAAiBjjB,EAE5C,CAOAmjB,YAAapC,EAAS/gB,EAAe,MAEpC,OAAOn6C,KAAKq9D,aAAcnC,EAAS/gB,EAEpC,CAMAojB,uBAEgC,OAA1Bv9D,KAAKu8D,mBAETv8D,KAAKu8D,iBAAmBiB,KACxBx9D,KAAKy8D,iBAAkBz8D,KAAKu8D,kBAI9B,CAMAkB,+BAEiC,OAA3Bz9D,KAAKw8D,oBAETx8D,KAAKw8D,kBAAoBkB,KACzB19D,KAAKy8D,iBAAkBz8D,KAAKw8D,mBAI9B,CAOA/7C,UAECzgB,KAAK29D,WAE0B,OAA1B39D,KAAKu8D,kBAA4Bv8D,KAAKu8D,iBAAiB97C,UAC5B,OAA3BzgB,KAAKw8D,mBAA6Bx8D,KAAKw8D,kBAAkB/7C,SAE/D,CAIAm8C,SAAUgB,GAET59D,KAAKi8D,QAAUj+D,KAAKK,MAAOL,KAAK6/D,KAAMD,IACtC59D,KAAKk8D,UAAYl+D,KAAK8Q,IAAK,EAAG9O,KAAKi8D,QAEpC,CAEA0B,WAE6B,OAAvB39D,KAAKs8D,eAAyBt8D,KAAKs8D,cAAc77C,UAElB,OAA/BzgB,KAAKg8D,uBAAiCh8D,KAAKg8D,sBAAsBv7C,UAEtE,IAAM,IAAIngB,EAAI,EAAGA,EAAIN,KAAKm8D,WAAWx7D,OAAQL,IAE5CN,KAAKm8D,WAAY77D,GAAImgB,SAIvB,CAEAy8C,SAAUY,GAET99D,KAAK+7D,UAAU7gB,gBAAiBwgB,IAChCoC,EAAaj7C,aAAc,EAC3Bk7C,GAAcD,EAAc,EAAG,EAAGA,EAAanrD,MAAOmrD,EAAalrD,OAEpE,CAEAyqD,aAAct6C,EAASo3B,GAEjBp3B,EAAQrE,UAAYtU,GAAyB2Y,EAAQrE,UAAYrU,EAErErK,KAAK48D,SAAmC,IAAzB75C,EAAQpG,MAAMhc,OAAe,GAAOoiB,EAAQpG,MAAO,GAAIhK,OAASoQ,EAAQpG,MAAO,GAAIA,MAAMhK,OAIxG3S,KAAK48D,SAAU75C,EAAQpG,MAAMhK,MAAQ,GAItC+oD,GAAa17D,KAAK+7D,UAAU9kB,kBAE5B,MAAM4lB,EAAqB1iB,GAAgBn6C,KAAK88D,mBAKhD,OAJA98D,KAAKg+D,iBAAkBj7C,EAAS85C,GAChC78D,KAAKi9D,YAAaJ,GAClB78D,KAAKk9D,SAAUL,GAERA,CAER,CAEAC,mBAEC,MAAMnqD,EAAQ,EAAI3U,KAAKuQ,IAAKvO,KAAKk8D,UAAW,KACtCtpD,EAAS,EAAI5S,KAAKk8D,UAElB+B,EAAS,CACdn/C,UAAWjU,EACXkU,UAAWlU,EACX8U,iBAAiB,EACjB5S,KAAM3B,EACN4T,OAAQ1T,EACR0Q,WAAY1P,GACZ0W,aAAa,GAGR65C,EAAqBqB,GAAqBvrD,EAAOC,EAAQqrD,GAE/D,GAAoC,OAA/Bj+D,KAAKg8D,uBAAkCh8D,KAAKg8D,sBAAsBrpD,QAAUA,GAAS3S,KAAKg8D,sBAAsBppD,SAAWA,EAAS,CAEpG,OAA/B5S,KAAKg8D,uBAETh8D,KAAK29D,WAIN39D,KAAKg8D,sBAAwBkC,GAAqBvrD,EAAOC,EAAQqrD,GAEjE,MAAM,QAAEhC,GAAYj8D,OAChBm+D,SAAUn+D,KAAKo8D,UAAWgC,UAAWp+D,KAAKm8D,WAAYkC,OAAQr+D,KAAKq8D,SAgS1E,SAAwBiC,GAEvB,MAAMF,EAAY,GACZD,EAAW,GACXE,EAAS,GAEf,IAAIE,EAAMD,EAEV,MAAME,EAAYF,EAjiBH,EAiiBsB,EAAI/C,GAAgB56D,OAEzD,IAAM,IAAIL,EAAI,EAAGA,EAAIk+D,EAAWl+D,IAAO,CAEtC,MAAMm+D,EAAUzgE,KAAK8Q,IAAK,EAAGyvD,GAC7BJ,EAAS1+D,KAAMg/D,GACf,IAAI9B,EAAQ,EAAM8B,EAEbn+D,EAAIg+D,EAziBK,EA2iBb3B,EAAQpB,GAAiBj7D,EAAIg+D,EA3iBhB,EA2iBmC,GAE/B,IAANh+D,IAEXq8D,EAAQ,GAIT0B,EAAO5+D,KAAMk9D,GAEb,MAAM+B,EAAY,GAAQD,EAAU,GAC9B9gE,GAAQ+gE,EACRnwD,EAAM,EAAImwD,EACV58B,EAAM,CAAEnkC,EAAKA,EAAK4Q,EAAK5Q,EAAK4Q,EAAKA,EAAK5Q,EAAKA,EAAK4Q,EAAKA,EAAK5Q,EAAK4Q,GAE/DowD,EAAY,EACZlpB,EAAW,EACXmpB,EAAe,EACfC,EAAS,EACTC,EAAgB,EAEhB1xC,EAAW,IAAIje,aAAcyvD,EAAenpB,EAAWkpB,GACvDh+C,EAAK,IAAIxR,aAAc0vD,EAASppB,EAAWkpB,GAC3C1pB,EAAY,IAAI9lC,aAAc2vD,EAAgBrpB,EAAWkpB,GAE/D,IAAM,IAAIzpB,EAAO,EAAGA,EAAOypB,EAAWzpB,IAAU,CAE/C,MAAM54C,EAAM44C,EAAO,EAAM,EAAI,EAAI,EAC3B14C,EAAI04C,EAAO,EAAI,GAAM,EACrB6pB,EAAc,CACnBziE,EAAGE,EAAG,EACNF,EAAI,EAAI,EAAGE,EAAG,EACdF,EAAI,EAAI,EAAGE,EAAI,EAAG,EAClBF,EAAGE,EAAG,EACNF,EAAI,EAAI,EAAGE,EAAI,EAAG,EAClBF,EAAGE,EAAI,EAAG,GAEX4wB,EAAS7a,IAAKwsD,EAAaH,EAAenpB,EAAWP,GACrDv0B,EAAGpO,IAAKuvB,EAAK+8B,EAASppB,EAAWP,GACjC,MAAM8pB,EAAO,CAAE9pB,EAAMA,EAAMA,EAAMA,EAAMA,EAAMA,GAC7CD,EAAU1iC,IAAKysD,EAAMF,EAAgBrpB,EAAWP,EAEjD,CAEA,MAAMoI,EAAS,IAAI,GACnBA,EAAOrgD,aAAc,WAAY,IAAI,GAAiBmwB,EAAUwxC,IAChEthB,EAAOrgD,aAAc,KAAM,IAAI,GAAiB0jB,EAAIk+C,IACpDvhB,EAAOrgD,aAAc,YAAa,IAAI,GAAiBg4C,EAAW6pB,IAClEV,EAAU3+D,KAAM69C,GAEXihB,EA7lBS,GA+lBbA,GAIF,CAEA,MAAO,CAAEH,YAAWD,WAAUE,SAE/B,CA9WsFY,CAAehD,IAElGj8D,KAAKs8D,cA+XR,SAAyBgC,EAAQ3rD,EAAOC,GAEvC,MAAMssD,EAAU,IAAI/vD,aAlnBD,IAmnBbgwD,EAAW,IAAI,GAAS,EAAG,EAAG,GA4FpC,OA3FuB,IAAI9nB,GAAgB,CAE1C70C,KAAM,wBAEN+0C,QAAS,CACR,EAznBiB,GA0nBjB,mBAAsB,EAAM5kC,EAC5B,oBAAuB,EAAMC,EAC7B,eAAkB,GAAG0rD,OAGtBznB,SAAU,CACT,OAAU,CAAEz5C,MAAO,MACnB,QAAW,CAAEA,MAAO,GACpB,QAAW,CAAEA,MAAO8hE,GACpB,YAAe,CAAE9hE,OAAO,GACxB,OAAU,CAAEA,MAAO,GACnB,OAAU,CAAEA,MAAO,GACnB,SAAY,CAAEA,MAAO+hE,IAGtB1nB,aA4JgB,yoCA1JhBC,eAA0B,miDA8D1BlU,SA73gBiB,EA83gBjBa,WAAW,EACXC,YAAY,GAMd,CAhewB86B,CAAgBnD,EAAStpD,EAAOC,EAEtD,CAEA,OAAOiqD,CAER,CAEAJ,iBAAkBx8B,GAEjB,MAAMo/B,EAAU,IAAIrrB,GAAMh0C,KAAKm8D,WAAY,GAAKl8B,GAChDjgC,KAAK+7D,UAAUuD,QAASD,EAAS7D,GAElC,CAEAuB,eAAgBniB,EAAOtiB,EAAMC,EAAKskC,GAEjC,MAEM0C,EAAa,IAAI/mB,GAFX,GACG,EACwClgB,EAAMC,GACvDinC,EAAS,CAAE,GAAK,EAAG,EAAG,EAAG,EAAG,GAC5BC,EAAc,CAAE,EAAG,EAAG,GAAK,GAAK,GAAK,GACrCzoB,EAAWh3C,KAAK+7D,UAEhB2D,EAAoB1oB,EAASmb,UAC7BpX,EAAc/D,EAAS+D,YAC7B/D,EAAS4a,cAAe6J,IAExBzkB,EAAS+D,YAAcjxC,EACvBktC,EAASmb,WAAY,EAErB,MAAMwN,EAAqB,IAAI5yB,GAAmB,CACjDvqC,KAAM,mBACNihC,KAz8fc,EA08fda,YAAY,EACZD,WAAW,IAGNu7B,EAAgB,IAAI5rB,GAAM,IAAIoB,GAAeuqB,GAEnD,IAAIE,GAAgB,EACpB,MAAMxgC,EAAaub,EAAMvb,WAEpBA,EAECA,EAAWC,UAEfqgC,EAAmBnkD,MAAMpI,KAAMisB,GAC/Bub,EAAMvb,WAAa,KACnBwgC,GAAgB,IAMjBF,EAAmBnkD,MAAMpI,KAAMqoD,IAC/BoE,GAAgB,GAIjB,IAAM,IAAIv/D,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,MAAMw/D,EAAMx/D,EAAI,EAEH,IAARw/D,GAEJP,EAAW7pC,GAAGnjB,IAAK,EAAGitD,EAAQl/D,GAAK,GACnCi/D,EAAWxuC,OAAQ0uC,EAAan/D,GAAK,EAAG,IAErB,IAARw/D,GAEXP,EAAW7pC,GAAGnjB,IAAK,EAAG,EAAGitD,EAAQl/D,IACjCi/D,EAAWxuC,OAAQ,EAAG0uC,EAAan/D,GAAK,KAIxCi/D,EAAW7pC,GAAGnjB,IAAK,EAAGitD,EAAQl/D,GAAK,GACnCi/D,EAAWxuC,OAAQ,EAAG,EAAG0uC,EAAan/D,KAIvC,MAAM0rB,EAAOhsB,KAAKk8D,UAElB6B,GAAclB,EAAoBiD,EAAM9zC,EAAM1rB,EAAI,EAAI0rB,EAAO,EAAGA,EAAMA,GAEtEgrB,EAASkE,gBAAiB2hB,GAErBgD,GAEJ7oB,EAASmE,OAAQykB,EAAeL,GAIjCvoB,EAASmE,OAAQP,EAAO2kB,EAEzB,CAEAK,EAAczyC,SAAS1M,UACvBm/C,EAAc3/B,SAASxf,UAEvBu2B,EAAS+D,YAAcA,EACvB/D,EAASmb,UAAYuN,EACrB9kB,EAAMvb,WAAaA,CAEpB,CAEA2+B,iBAAkBj7C,EAAS85C,GAE1B,MAAM7lB,EAAWh3C,KAAK+7D,UAEhB1gB,EAAkBt4B,EAAQrE,UAAYtU,GAAyB2Y,EAAQrE,UAAYrU,EAEpFgxC,GAE2B,OAA1Br7C,KAAKu8D,mBAETv8D,KAAKu8D,iBAAmBiB,MAIzBx9D,KAAKu8D,iBAAiB1lB,SAASiU,WAAW1tD,OAA4C,IAAlC2lB,EAAQ9C,uBAAsC,EAAI,GAItE,OAA3BjgB,KAAKw8D,oBAETx8D,KAAKw8D,kBAAoBkB,MAM3B,MAAMz9B,EAAWob,EAAgBr7C,KAAKu8D,iBAAmBv8D,KAAKw8D,kBACxD7gB,EAAO,IAAI3H,GAAMh0C,KAAKm8D,WAAY,GAAKl8B,GAE5BA,EAAS4W,SAEP,OAAEz5C,MAAQ2lB,EAE7B,MAAMiJ,EAAOhsB,KAAKk8D,UAElB6B,GAAclB,EAAoB,EAAG,EAAG,EAAI7wC,EAAM,EAAIA,GAEtDgrB,EAASkE,gBAAiB2hB,GAC1B7lB,EAASmE,OAAQQ,EAAM6f,GAExB,CAEAyB,YAAaJ,GAEZ,MAAM7lB,EAAWh3C,KAAK+7D,UAChB5J,EAAYnb,EAASmb,UAC3Bnb,EAASmb,WAAY,EAErB,IAAM,IAAI7xD,EAAI,EAAGA,EAAIN,KAAKm8D,WAAWx7D,OAAQL,IAAO,CAEnD,MAAMq8D,EAAQ3+D,KAAKC,KAAM+B,KAAKq8D,QAAS/7D,GAAMN,KAAKq8D,QAAS/7D,GAAMN,KAAKq8D,QAAS/7D,EAAI,GAAMN,KAAKq8D,QAAS/7D,EAAI,IAErG6+D,EAAWtD,IAAmBv7D,EAAI,GAAMu7D,GAAgBl7D,QAE9DX,KAAKg9D,MAAOH,EAAoBv8D,EAAI,EAAGA,EAAGq8D,EAAOwC,EAElD,CAEAnoB,EAASmb,UAAYA,CAEtB,CASA6K,MAAOH,EAAoBkD,EAAOC,EAAQrD,EAAOwC,GAEhD,MAAMc,EAAuBjgE,KAAKg8D,sBAElCh8D,KAAKkgE,UACJrD,EACAoD,EACAF,EACAC,EACArD,EACA,cACAwC,GAEDn/D,KAAKkgE,UACJD,EACApD,EACAmD,EACAA,EACArD,EACA,eACAwC,EAEF,CAEAe,UAAWC,EAAUC,EAAWL,EAAOC,EAAQK,EAAczvC,EAAWuuC,GAEvE,MAAMnoB,EAAWh3C,KAAK+7D,UAChBuE,EAAetgE,KAAKs8D,cAEP,gBAAd1rC,GAA6C,iBAAdA,GAEnCtyB,QAAQ6+B,MACP,8DAKF,MAEMojC,EAAW,IAAIvsB,GAAMh0C,KAAKm8D,WAAY6D,GAAUM,GAChDE,EAAeF,EAAazpB,SAE5B4pB,EAASzgE,KAAKo8D,UAAW2D,GAAU,EACnCW,EAAkBtvB,SAAUivB,GAAiBriE,KAAKI,IAAO,EAAIqiE,GAAW,EAAIziE,KAAKI,GAAK,GACtFuiE,EAAcN,EAAeK,EAC7Bv9C,EAAUiuB,SAAUivB,GAAiB,EAAIriE,KAAKK,MARxB,EAQqDsiE,GA7c/D,GA+cbx9C,EA/ca,IAidjB7kB,QAAQkU,KAAM,iBACb6tD,kDACAl9C,2CAIF,MAAM+7C,EAAU,GAChB,IAAI0B,EAAM,EAEV,IAAM,IAAItgE,EAAI,EAAGA,EA1dC,KA0dmBA,EAAI,CAExC,MAAMhE,EAAIgE,EAAIqgE,EACRE,EAAS7iE,KAAKsS,KAAOhU,EAAIA,EAAI,GACnC4iE,EAAQz/D,KAAMohE,GAEH,IAANvgE,EAEJsgE,GAAOC,EAEIvgE,EAAI6iB,IAEfy9C,GAAO,EAAIC,EAIb,CAEA,IAAM,IAAIvgE,EAAI,EAAGA,EAAI4+D,EAAQv+D,OAAQL,IAEpC4+D,EAAS5+D,GAAM4+D,EAAS5+D,GAAMsgE,EAI/BJ,EAAuB,OAAEpjE,MAAQ+iE,EAASp9C,QAC1Cy9C,EAAwB,QAAEpjE,MAAQ+lB,EAClCq9C,EAAwB,QAAEpjE,MAAQ8hE,EAClCsB,EAA4B,YAAEpjE,MAAsB,gBAAdwzB,EAEjCuuC,IAEJqB,EAAyB,SAAEpjE,MAAQ+hE,GAIpC,MAAM,QAAElD,GAAYj8D,KACpBwgE,EAAuB,OAAEpjE,MAAQsjE,EACjCF,EAAuB,OAAEpjE,MAAQ6+D,EAAU8D,EAE3C,MAAMe,EAAa9gE,KAAKo8D,UAAW4D,GAInCjC,GAAcqC,EAHJ,EAAIU,GAAed,EAAS/D,EA5gBxB,EA4gB4C+D,EAAS/D,EA5gBrD,EA4gByE,GAC7E,GAAMj8D,KAAKk8D,UAAY4E,GAEF,EAAIA,EAAY,EAAIA,GACnD9pB,EAASkE,gBAAiBklB,GAC1BppB,EAASmE,OAAQolB,EAAU/E,GAE5B,EAsFD,SAAS0C,GAAqBvrD,EAAOC,EAAQqrD,GAE5C,MAAMpB,EAAqB,IAAIp6C,GAAmB9P,EAAOC,EAAQqrD,GAIjE,OAHApB,EAAmB95C,QAAQrE,QAAUpU,EACrCuyD,EAAmB95C,QAAQvgB,KAAO,eAClCq6D,EAAmBh6C,aAAc,EAC1Bg6C,CAER,CAEA,SAASkB,GAAc35D,EAAQ9H,EAAGE,EAAGmW,EAAOC,GAE3CxO,EAAO0e,SAASvQ,IAAKjW,EAAGE,EAAGmW,EAAOC,GAClCxO,EAAOwe,QAAQrQ,IAAKjW,EAAGE,EAAGmW,EAAOC,EAElC,CAqGA,SAAS8qD,KAER,OAAO,IAAIrmB,GAAgB,CAE1B70C,KAAM,0BAENq0C,SAAU,CACT,OAAU,CAAEz5C,MAAO,OAGpBq6C,aAwEgB,yoCAtEhBC,eAA0B,yYAqB1BlU,SAx6gBiB,EAy6gBjBa,WAAW,EACXC,YAAY,GAId,CAEA,SAASk5B,KAER,OAAO,IAAInmB,GAAgB,CAE1B70C,KAAM,kBAENq0C,SAAU,CACT,OAAU,CAAEz5C,MAAO,MACnB,WAAc,CAAEA,OAAS,IAG1Bq6C,aA8BgB,yoCA5BhBC,eAA0B,0UAkB1BlU,SA/8gBiB,EAg9gBjBa,WAAW,EACXC,YAAY,GAId,CA+DA,SAASy8B,GAAiB/pB,GAEzB,IAAIgqB,EAAa,IAAIlhB,QAEjBmhB,EAAiB,KAqFrB,SAAShG,EAAkBztD,GAE1B,MAAMuV,EAAUvV,EAAMpJ,OAEtB2e,EAAQ1V,oBAAqB,UAAW4tD,GAExC,MAAMiG,EAAYF,EAAWn4D,IAAKka,QAEf5lB,IAAd+jE,IAEJF,EAAW/gB,OAAQl9B,GACnBm+C,EAAUzgD,UAIZ,CAeA,MAAO,CACN5X,IAlHD,SAAcka,GAEb,GAAKA,GAAWA,EAAQ1D,UAAY,CAEnC,MAAMX,EAAUqE,EAAQrE,QAElByiD,EAr/gBgC,MAq/gBdziD,GAp/gBc,MAo/gBkCA,EAClE0iD,EAAc1iD,IAAYtU,GAAyBsU,IAAYrU,EAIrE,GAAK82D,GAAiBC,EAAY,CAEjC,GAAKr+C,EAAQ9C,wBAAsD,IAA7B8C,EAAQ7C,iBAA4B,CAEzE6C,EAAQ7C,kBAAmB,EAE3B,IAAIi6B,EAAe6mB,EAAWn4D,IAAKka,GAOnC,OALwB,OAAnBk+C,IAA0BA,EAAiB,IAAInF,GAAgB9kB,IAEpEmD,EAAegnB,EAAgBF,EAAe9D,oBAAqBp6C,EAASo3B,GAAiB8mB,EAAe3D,YAAav6C,EAASo3B,GAClI6mB,EAAWzuD,IAAKwQ,EAASo3B,GAElBA,EAAap3B,OAErB,CAEC,GAAKi+C,EAAWpJ,IAAK70C,GAEpB,OAAOi+C,EAAWn4D,IAAKka,GAAUA,QAE3B,CAEN,MAAMpG,EAAQoG,EAAQpG,MAEtB,GAAOwkD,GAAiBxkD,GAASA,EAAM/J,OAAS,GAASwuD,GAAazkD,GA+B3E,SAAgCA,GAE/B,IAAI1X,EAAQ,EAGZ,IAAM,IAAI3E,EAAI,EAAGA,EAFF,EAEcA,SAERnD,IAAfwf,EAAOrc,IAAoB2E,IAIjC,OARe,IAQRA,CAGR,CA7CoFo8D,CAAuB1kD,GAAY,CAEzF,OAAnBskD,IAA0BA,EAAiB,IAAInF,GAAgB9kB,IAEpE,MAAMmD,EAAegnB,EAAgBF,EAAe9D,oBAAqBp6C,GAAYk+C,EAAe3D,YAAav6C,GAKjH,OAJAi+C,EAAWzuD,IAAKwQ,EAASo3B,GAEzBp3B,EAAQ9mB,iBAAkB,UAAWg/D,GAE9B9gB,EAAap3B,OAErB,CAIC,OAAO,IAIT,CAIF,CAED,CAEA,OAAOA,CAER,EAkDCtC,QAfD,WAECugD,EAAa,IAAIlhB,QAEO,OAAnBmhB,IAEJA,EAAexgD,UACfwgD,EAAiB,KAInB,EAOD,CAEA,SAASK,GAAiB5hB,GAEzB,MAAM7H,EAAa,CAAC,EAEpB,SAAS0pB,EAAc/+D,GAEtB,QAA4BrF,IAAvB06C,EAAYr1C,GAEhB,OAAOq1C,EAAYr1C,GAIpB,IAAImwD,EAEJ,OAASnwD,GAER,IAAK,sBACJmwD,EAAYjT,EAAG6hB,aAAc,wBAA2B7hB,EAAG6hB,aAAc,4BAA+B7hB,EAAG6hB,aAAc,8BACzH,MAED,IAAK,iCACJ5O,EAAYjT,EAAG6hB,aAAc,mCAAsC7hB,EAAG6hB,aAAc,uCAA0C7hB,EAAG6hB,aAAc,yCAC/I,MAED,IAAK,gCACJ5O,EAAYjT,EAAG6hB,aAAc,kCAAqC7hB,EAAG6hB,aAAc,sCAAyC7hB,EAAG6hB,aAAc,wCAC7I,MAED,IAAK,iCACJ5O,EAAYjT,EAAG6hB,aAAc,mCAAsC7hB,EAAG6hB,aAAc,yCACpF,MAED,QACC5O,EAAYjT,EAAG6hB,aAAc/+D,GAM/B,OAFAq1C,EAAYr1C,GAASmwD,EAEdA,CAER,CAEA,MAAO,CAENiF,IAAK,SAAWp1D,GAEf,OAAgC,OAAzB++D,EAAc/+D,EAEtB,EAEA43D,KAAM,SAAWza,GAEXA,EAAaC,SAEjB2hB,EAAc,2BAIdA,EAAc,uBACdA,EAAc,qBACdA,EAAc,0BACdA,EAAc,iCACdA,EAAc,4BACdA,EAAc,0BACdA,EAAc,2BACdA,EAAc,2BAIfA,EAAc,4BACdA,EAAc,+BACdA,EAAc,uCAEf,EAEA14D,IAAK,SAAWrG,GAEf,MAAMmwD,EAAY4O,EAAc/+D,GAQhC,OANmB,OAAdmwD,GAEJr0D,QAAQkU,KAAM,wBAA0BhQ,EAAO,6BAIzCmwD,CAER,EAIF,CAEA,SAAS6O,GAAiB9hB,EAAI/5C,EAAYgxD,EAAM9D,GAE/C,MAAMp0B,EAAa,CAAC,EACdgjC,EAAsB,IAAI3hB,QAEhC,SAAS4hB,EAAmBl0D,GAE3B,MAAM2f,EAAW3f,EAAMpJ,OAEC,OAAnB+oB,EAASpvB,OAEb4H,EAAWzI,OAAQiwB,EAASpvB,OAI7B,IAAM,MAAMyE,KAAQ2qB,EAASxnB,WAE5BA,EAAWzI,OAAQiwB,EAASxnB,WAAYnD,IAIzC,IAAM,MAAMA,KAAQ2qB,EAAS0hB,gBAAkB,CAE9C,MAAMphC,EAAQ0f,EAAS0hB,gBAAiBrsC,GAExC,IAAM,IAAIlC,EAAI,EAAGoN,EAAID,EAAM9M,OAAQL,EAAIoN,EAAGpN,IAEzCqF,EAAWzI,OAAQuQ,EAAOnN,GAI5B,CAEA6sB,EAAS9f,oBAAqB,UAAWq0D,UAElCjjC,EAAYtR,EAASxtB,IAE5B,MAAMmW,EAAY2rD,EAAoB54D,IAAKskB,GAEtCrX,IAEJnQ,EAAWzI,OAAQ4Y,GACnB2rD,EAAoBxhB,OAAQ9yB,IAI7B0lC,EAAc2D,wBAAyBrpC,IAEK,IAAvCA,EAASsoC,kCAENtoC,EAAS2oC,kBAMjBa,EAAKgL,OAAOljC,YAEb,CA8CA,SAASmjC,EAA0Bz0C,GAElC,MAAMgjB,EAAU,GAEV0xB,EAAgB10C,EAASpvB,MACzB+jE,EAAmB30C,EAASxnB,WAAWynB,SAC7C,IAAIvP,EAAU,EAEd,GAAuB,OAAlBgkD,EAAyB,CAE7B,MAAMp0D,EAAQo0D,EAAcp0D,MAC5BoQ,EAAUgkD,EAAchkD,QAExB,IAAM,IAAIvd,EAAI,EAAGoN,EAAID,EAAM9M,OAAQL,EAAIoN,EAAGpN,GAAK,EAAI,CAElD,MAAMmI,EAAIgF,EAAOnN,EAAI,GACfoR,EAAIjE,EAAOnN,EAAI,GACfqR,EAAIlE,EAAOnN,EAAI,GAErB6vC,EAAQ1wC,KAAMgJ,EAAGiJ,EAAGA,EAAGC,EAAGA,EAAGlJ,EAE9B,CAED,KAAO,CAEN,MAAMgF,EAAQq0D,EAAiBr0D,MAC/BoQ,EAAUikD,EAAiBjkD,QAE3B,IAAM,IAAIvd,EAAI,EAAGoN,EAAMD,EAAM9M,OAAS,EAAM,EAAGL,EAAIoN,EAAGpN,GAAK,EAAI,CAE9D,MAAMmI,EAAInI,EAAI,EACRoR,EAAIpR,EAAI,EACRqR,EAAIrR,EAAI,EAEd6vC,EAAQ1wC,KAAMgJ,EAAGiJ,EAAGA,EAAGC,EAAGA,EAAGlJ,EAE9B,CAED,CAEA,MAAMqN,EAAY,IAAM8E,GAAkBu1B,GAAY/B,GAAwBD,IAAyBgC,EAAS,GAChHr6B,EAAU+H,QAAUA,EAMpB,MAAMkkD,EAAoBN,EAAoB54D,IAAKskB,GAE9C40C,GAAoBp8D,EAAWzI,OAAQ6kE,GAI5CN,EAAoBlvD,IAAK4a,EAAUrX,EAEpC,CAgCA,MAAO,CAENjN,IArID,SAAcsjB,EAAQgB,GAErB,OAAmC,IAA9BsR,EAAYtR,EAASxtB,MAE1BwtB,EAASlxB,iBAAkB,UAAWylE,GAEtCjjC,EAAYtR,EAASxtB,KAAO,EAE5Bg3D,EAAKgL,OAAOljC,cANqCtR,CAUlD,EA0HC9lB,OAxHD,SAAiB8lB,GAEhB,MAAM8nC,EAAqB9nC,EAASxnB,WAIpC,IAAM,MAAMnD,KAAQyyD,EAEnBtvD,EAAW0B,OAAQ4tD,EAAoBzyD,GAAQk9C,EAAGqW,cAMnD,MAAMlnB,EAAkB1hB,EAAS0hB,gBAEjC,IAAM,MAAMrsC,KAAQqsC,EAAkB,CAErC,MAAMphC,EAAQohC,EAAiBrsC,GAE/B,IAAM,IAAIlC,EAAI,EAAGoN,EAAID,EAAM9M,OAAQL,EAAIoN,EAAGpN,IAEzCqF,EAAW0B,OAAQoG,EAAOnN,GAAKo/C,EAAGqW,aAIpC,CAED,EA8FCiM,sBAnCD,SAAgC70C,GAE/B,MAAM80C,EAAmBR,EAAoB54D,IAAKskB,GAElD,GAAK80C,EAAmB,CAEvB,MAAMJ,EAAgB10C,EAASpvB,MAER,OAAlB8jE,GAICI,EAAiBpkD,QAAUgkD,EAAchkD,SAE7C+jD,EAA0Bz0C,EAM7B,MAECy0C,EAA0Bz0C,GAI3B,OAAOs0C,EAAoB54D,IAAKskB,EAEjC,EAWD,CAEA,SAAS+0C,GAA4BxiB,EAAI7H,EAAY8e,EAAMhX,GAE1D,MAAMC,EAAWD,EAAaC,SAE9B,IAAIgX,EAQA7pD,EAAMqzC,EAkDVpgD,KAAK62D,QAxDL,SAAkBz5D,GAEjBw5D,EAAOx5D,CAER,EAqDA4C,KAAKovC,SAjDL,SAAmBhyC,GAElB2P,EAAO3P,EAAM2P,KACbqzC,EAAkBhjD,EAAMgjD,eAEzB,EA6CApgD,KAAKm7C,OA3CL,SAAiBjM,EAAOjqC,GAEvBy6C,EAAGyiB,aAAcvL,EAAM3xD,EAAO8H,EAAMmiC,EAAQkR,GAE5CuW,EAAKtvD,OAAQpC,EAAO2xD,EAAM,EAE3B,EAsCA52D,KAAK+2D,gBApCL,SAA0B7nB,EAAOjqC,EAAO+xD,GAEvC,GAAmB,IAAdA,EAAkB,OAEvB,IAAIrE,EAAWsE,EAEf,GAAKrX,EAEJ+S,EAAYjT,EACZuX,EAAa,6BAOb,GAHAtE,EAAY9a,EAAWhvC,IAAK,0BAC5BouD,EAAa,6BAEM,OAAdtE,EAGJ,YADAr0D,QAAQ6+B,MAAO,yIAOjBw1B,EAAWsE,GAAcL,EAAM3xD,EAAO8H,EAAMmiC,EAAQkR,EAAiB4W,GAErEL,EAAKtvD,OAAQpC,EAAO2xD,EAAMI,EAE3B,CASD,CAEA,SAASoL,GAAW1iB,GAEnB,MAKMvE,EAAS,CACdgE,MAAO,EACPkjB,MAAO,EACPC,UAAW,EACXx2C,OAAQ,EACRy2C,MAAO,GA8CR,MAAO,CACNZ,OAzDc,CACdljC,WAAY,EACZpe,SAAU,GAwDV86B,OAAQA,EACRqnB,SAAU,KACVC,WAAW,EACXlO,MAdD,WAECpZ,EAAOknB,MAAQ,EACflnB,EAAOmnB,UAAY,EACnBnnB,EAAOrvB,OAAS,EAChBqvB,EAAOonB,MAAQ,CAEhB,EAQCl7D,OAjDD,SAAiBpC,EAAO2xD,EAAM8L,GAI7B,OAFAvnB,EAAOknB,QAEEzL,GAER,KAAKlX,EAAGijB,UACPxnB,EAAOmnB,WAAaI,GAAkBz9D,EAAQ,GAC9C,MAED,KAAKy6C,EAAGkjB,MACPznB,EAAOonB,OAASG,GAAkBz9D,EAAQ,GAC1C,MAED,KAAKy6C,EAAGmjB,WACP1nB,EAAOonB,OAASG,GAAkBz9D,EAAQ,GAC1C,MAED,KAAKy6C,EAAGojB,UACP3nB,EAAOonB,OAASG,EAAgBz9D,EAChC,MAED,KAAKy6C,EAAGqjB,OACP5nB,EAAOrvB,QAAU42C,EAAgBz9D,EACjC,MAED,QACC3G,QAAQ6+B,MAAO,sCAAuCy5B,GAKzD,EAoBD,CAEA,SAASoM,GAAev6D,EAAGiJ,GAE1B,OAAOjJ,EAAG,GAAMiJ,EAAG,EAEpB,CAEA,SAASuxD,GAAkBx6D,EAAGiJ,GAE7B,OAAO1T,KAAKwS,IAAKkB,EAAG,IAAQ1T,KAAKwS,IAAK/H,EAAG,GAE1C,CAEA,SAASy6D,GAAmBxjB,EAAIC,EAAct/B,GAE7C,MAAM8iD,EAAiB,CAAC,EAClB3uB,EAAkB,IAAIrlC,aAAc,GACpCi0D,EAAgB,IAAItjB,QACpBujB,EAAQ,IAAIxiD,GAEZyiD,EAAiB,GAEvB,IAAM,IAAIhjE,EAAI,EAAGA,EAAI,EAAGA,IAEvBgjE,EAAgBhjE,GAAM,CAAEA,EAAG,GAsQ5B,MAAO,CAEN+G,OApQD,SAAiB8kB,EAAQgB,EAAUymC,GAElC,MAAM2P,EAAmBp3C,EAAO+nB,sBAEhC,IAA+B,IAA1ByL,EAAaC,SAAoB,CAKrC,MAAM5P,EAAiB7iB,EAAS0hB,gBAAgBzhB,UAAYD,EAAS0hB,gBAAgBxkB,QAAU8C,EAAS0hB,gBAAgBrzB,MAClHgoD,OAAyCrmE,IAAnB6yC,EAAiCA,EAAervC,OAAS,EAErF,IAAI8iE,EAAQL,EAAcv6D,IAAKskB,GAE/B,QAAehwB,IAAVsmE,GAAuBA,EAAMx+D,QAAUu+D,EAAoB,MAEhDrmE,IAAVsmE,GAAsBA,EAAM1gD,QAAQtC,UAEzC,MAAMijD,OAAyDvmE,IAAtCgwB,EAAS0hB,gBAAgBzhB,SAC5Cu2C,OAAsDxmE,IAApCgwB,EAAS0hB,gBAAgBxkB,OAC3Cu5C,OAAoDzmE,IAAnCgwB,EAAS0hB,gBAAgBrzB,MAE1CqoD,EAAe12C,EAAS0hB,gBAAgBzhB,UAAY,GACpD02C,EAAe32C,EAAS0hB,gBAAgBxkB,QAAU,GAClD05C,EAAc52C,EAAS0hB,gBAAgBrzB,OAAS,GAEtD,IAAIwoD,EAAkB,GAEI,IAArBN,IAA4BM,EAAkB,IAC1B,IAApBL,IAA2BK,EAAkB,IAC1B,IAAnBJ,IAA0BI,EAAkB,GAEjD,IAAIrxD,EAAQwa,EAASxnB,WAAWynB,SAASnoB,MAAQ++D,EAC7CpxD,EAAS,EAERD,EAAQgtC,EAAauY,iBAEzBtlD,EAAS5U,KAAK+Q,KAAM4D,EAAQgtC,EAAauY,gBACzCvlD,EAAQgtC,EAAauY,gBAItB,MAAMlY,EAAS,IAAI7wC,aAAcwD,EAAQC,EAAS,EAAI4wD,GAEhDzgD,EAAU,IAAIO,GAAkB08B,EAAQrtC,EAAOC,EAAQ4wD,GAC7DzgD,EAAQhW,KAAO5B,EACf4X,EAAQjF,aAAc,EAItB,MAAMmmD,EAAqC,EAAlBD,EAEzB,IAAM,IAAI1jE,EAAI,EAAGA,EAAIkjE,EAAmBljE,IAAO,CAE9C,MAAM4jE,EAAcL,EAAcvjE,GAC5B6jE,EAAcL,EAAcxjE,GAC5B8jE,EAAaL,EAAazjE,GAE1BqV,EAAShD,EAAQC,EAAS,EAAItS,EAEpC,IAAM,IAAI8uB,EAAI,EAAGA,EAAI80C,EAAYj/D,MAAOmqB,IAAO,CAE9C,MAAMqjB,EAASrjB,EAAI60C,GAEO,IAArBP,IAEJL,EAAMxtD,oBAAqBquD,EAAa90C,GAExC4wB,EAAQrqC,EAAS88B,EAAS,GAAM4wB,EAAM/mE,EACtC0jD,EAAQrqC,EAAS88B,EAAS,GAAM4wB,EAAM7mE,EACtCwjD,EAAQrqC,EAAS88B,EAAS,GAAM4wB,EAAMviD,EACtCk/B,EAAQrqC,EAAS88B,EAAS,GAAM,IAIR,IAApBkxB,IAEJN,EAAMxtD,oBAAqBsuD,EAAa/0C,GAExC4wB,EAAQrqC,EAAS88B,EAAS,GAAM4wB,EAAM/mE,EACtC0jD,EAAQrqC,EAAS88B,EAAS,GAAM4wB,EAAM7mE,EACtCwjD,EAAQrqC,EAAS88B,EAAS,GAAM4wB,EAAMviD,EACtCk/B,EAAQrqC,EAAS88B,EAAS,GAAM,IAIT,IAAnBmxB,IAEJP,EAAMxtD,oBAAqBuuD,EAAYh1C,GAEvC4wB,EAAQrqC,EAAS88B,EAAS,GAAM4wB,EAAM/mE,EACtC0jD,EAAQrqC,EAAS88B,EAAS,GAAM4wB,EAAM7mE,EACtCwjD,EAAQrqC,EAAS88B,EAAS,IAAO4wB,EAAMviD,EACvCk/B,EAAQrqC,EAAS88B,EAAS,IAAiC,IAAxB2xB,EAAWj3B,SAAmBk2B,EAAMtiD,EAAI,EAI7E,CAED,CAUA,SAASsjD,IAERthD,EAAQtC,UAER2iD,EAAcnjB,OAAQ9yB,GAEtBA,EAAS9f,oBAAqB,UAAWg3D,EAE1C,CAhBAZ,EAAQ,CACPx+D,MAAOu+D,EACPzgD,QAASA,EACTiJ,KAAM,IAAIvZ,GAASE,EAAOC,IAG3BwwD,EAAc7wD,IAAK4a,EAAUs2C,GAY7Bt2C,EAASlxB,iBAAkB,UAAWooE,EAEvC,CAIA,IAAIC,EAAqB,EAEzB,IAAM,IAAIhkE,EAAI,EAAGA,EAAIijE,EAAiB5iE,OAAQL,IAE7CgkE,GAAsBf,EAAkBjjE,GAIzC,MAAMikE,EAAqBp3C,EAAS2hB,qBAAuB,EAAI,EAAIw1B,EAEnE1Q,EAAQ4Q,cAAcC,SAAU/kB,EAAI,2BAA4B6kB,GAChE3Q,EAAQ4Q,cAAcC,SAAU/kB,EAAI,wBAAyB6jB,GAE7D3P,EAAQ4Q,cAAcC,SAAU/kB,EAAI,sBAAuB+jB,EAAM1gD,QAAS1C,GAC1EuzC,EAAQ4Q,cAAcC,SAAU/kB,EAAI,0BAA2B+jB,EAAMz3C,KAGtE,KAAO,CAKN,MAAMrrB,OAA8BxD,IAArBomE,EAAiC,EAAIA,EAAiB5iE,OAErE,IAAI+jE,EAAavB,EAAgBh2C,EAASxtB,IAE1C,QAAoBxC,IAAfunE,GAA4BA,EAAW/jE,SAAWA,EAAS,CAI/D+jE,EAAa,GAEb,IAAM,IAAIpkE,EAAI,EAAGA,EAAIK,EAAQL,IAE5BokE,EAAYpkE,GAAM,CAAEA,EAAG,GAIxB6iE,EAAgBh2C,EAASxtB,IAAO+kE,CAEjC,CAIA,IAAM,IAAIpkE,EAAI,EAAGA,EAAIK,EAAQL,IAAO,CAEnC,MAAMm0C,EAAYiwB,EAAYpkE,GAE9Bm0C,EAAW,GAAMn0C,EACjBm0C,EAAW,GAAM8uB,EAAkBjjE,EAEpC,CAEAokE,EAAWC,KAAM1B,IAEjB,IAAM,IAAI3iE,EAAI,EAAGA,EAAI,EAAGA,IAElBA,EAAIK,GAAU+jE,EAAYpkE,GAAK,IAEnCgjE,EAAgBhjE,GAAK,GAAMokE,EAAYpkE,GAAK,GAC5CgjE,EAAgBhjE,GAAK,GAAMokE,EAAYpkE,GAAK,KAI5CgjE,EAAgBhjE,GAAK,GAAM2kB,OAAO2/C,iBAClCtB,EAAgBhjE,GAAK,GAAM,GAM7BgjE,EAAeqB,KAAM3B,IAErB,MAAMa,EAAe12C,EAAS0hB,gBAAgBzhB,SACxC02C,EAAe32C,EAAS0hB,gBAAgBxkB,OAE9C,IAAIi6C,EAAqB,EAEzB,IAAM,IAAIhkE,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,MAAMm0C,EAAY6uB,EAAgBhjE,GAC5BvC,EAAQ02C,EAAW,GACnBr3C,EAAQq3C,EAAW,GAEpB12C,IAAUknB,OAAO2/C,kBAAoBxnE,GAEpCymE,GAAgB12C,EAASkiB,aAAc,cAAgB/uC,KAAQujE,EAAc9lE,IAEjFovB,EAASlwB,aAAc,cAAgBqD,EAAGujE,EAAc9lE,IAIpD+lE,GAAgB32C,EAASkiB,aAAc,cAAgB/uC,KAAQwjE,EAAc/lE,IAEjFovB,EAASlwB,aAAc,cAAgBqD,EAAGwjE,EAAc/lE,IAIzDy2C,EAAiBl0C,GAAMlD,EACvBknE,GAAsBlnE,IAIjBymE,IAA+D,IAA/C12C,EAASoiB,aAAc,cAAgBjvC,IAE3D6sB,EAASmiB,gBAAiB,cAAgBhvC,GAItCwjE,IAA+D,IAA/C32C,EAASoiB,aAAc,cAAgBjvC,IAE3D6sB,EAASmiB,gBAAiB,cAAgBhvC,GAI3Ck0C,EAAiBl0C,GAAM,EAIzB,CAKA,MAAMikE,EAAqBp3C,EAAS2hB,qBAAuB,EAAI,EAAIw1B,EAEnE1Q,EAAQ4Q,cAAcC,SAAU/kB,EAAI,2BAA4B6kB,GAChE3Q,EAAQ4Q,cAAcC,SAAU/kB,EAAI,wBAAyBlL,EAE9D,CAED,EAQD,CAEA,SAASqwB,GAAcnlB,EAAIjhB,EAAY94B,EAAYgxD,GAElD,IAAImO,EAAY,IAAIhlB,QAmEpB,SAASilB,EAAwBv3D,GAEhC,MAAMw3D,EAAgBx3D,EAAMpJ,OAE5B4gE,EAAc33D,oBAAqB,UAAW03D,GAE9Cp/D,EAAWzI,OAAQ8nE,EAAc9lC,gBAEI,OAAhC8lC,EAAc7lC,eAAyBx5B,EAAWzI,OAAQ8nE,EAAc7lC,cAE9E,CAEA,MAAO,CAEN93B,OA/ED,SAAiB8kB,GAEhB,MAAMgzB,EAAQwX,EAAKxb,OAAOgE,MAEpBhyB,EAAWhB,EAAOgB,SAClB83C,EAAiBxmC,EAAW51B,IAAKsjB,EAAQgB,GAoC/C,GAhCK23C,EAAUj8D,IAAKo8D,KAAqB9lB,IAExC1gB,EAAWp3B,OAAQ49D,GAEnBH,EAAUvyD,IAAK0yD,EAAgB9lB,IAI3BhzB,EAAO8S,mBAE2D,IAAjE9S,EAAO/e,iBAAkB,UAAW23D,IAExC54C,EAAOlwB,iBAAkB,UAAW8oE,GAIhCD,EAAUj8D,IAAKsjB,KAAagzB,IAEhCx5C,EAAW0B,OAAQ8kB,EAAO+S,eAAgBwgB,EAAGqW,cAEf,OAAzB5pC,EAAOgT,eAEXx5B,EAAW0B,OAAQ8kB,EAAOgT,cAAeugB,EAAGqW,cAI7C+O,EAAUvyD,IAAK4Z,EAAQgzB,KAMpBhzB,EAAO0T,cAAgB,CAE3B,MAAMG,EAAW7T,EAAO6T,SAEnB8kC,EAAUj8D,IAAKm3B,KAAemf,IAElCnf,EAAS34B,SAETy9D,EAAUvyD,IAAKytB,EAAUmf,GAI3B,CAEA,OAAO8lB,CAER,EAuBCxkD,QArBD,WAECqkD,EAAY,IAAIhlB,OAEjB,EAqBD,CA8CA,MAAMolB,GAA6B,IAAI1mD,GACjC2mD,GAAkC,IAAI7hD,GACtC8hD,GAA+B,IAAI3hD,GACnC4hD,GAAiC,IAAIjqB,GAMrCkqB,GAAgB,GAChBC,GAAgB,GAIhBC,GAAY,IAAIr2D,aAAc,IAC9Bs2D,GAAY,IAAIt2D,aAAc,GAC9Bu2D,GAAY,IAAIv2D,aAAc,GAIpC,SAASw2D,GAASl4D,EAAOm4D,EAASC,GAEjC,MAAMC,EAAYr4D,EAAO,GAEzB,GAAKq4D,GAAa,GAAKA,EAAY,EAAI,OAAOr4D,EAI9C,MAAMtL,EAAIyjE,EAAUC,EACpB,IAAI78D,EAAIs8D,GAAenjE,GASvB,QAPWhF,IAAN6L,IAEJA,EAAI,IAAImG,aAAchN,GACtBmjE,GAAenjE,GAAM6G,GAIL,IAAZ48D,EAAgB,CAEpBE,EAAUlwD,QAAS5M,EAAG,GAEtB,IAAM,IAAI1I,EAAI,EAAGqV,EAAS,EAAGrV,IAAMslE,IAAYtlE,EAE9CqV,GAAUkwD,EACVp4D,EAAOnN,GAAIsV,QAAS5M,EAAG2M,EAIzB,CAEA,OAAO3M,CAER,CAEA,SAAS+8D,GAAat9D,EAAGiJ,GAExB,GAAKjJ,EAAE9H,SAAW+Q,EAAE/Q,OAAS,OAAO,EAEpC,IAAM,IAAIL,EAAI,EAAGoN,EAAIjF,EAAE9H,OAAQL,EAAIoN,EAAGpN,IAErC,GAAKmI,EAAGnI,KAAQoR,EAAGpR,GAAM,OAAO,EAIjC,OAAO,CAER,CAEA,SAASwtC,GAAWrlC,EAAGiJ,GAEtB,IAAM,IAAIpR,EAAI,EAAGoN,EAAIgE,EAAE/Q,OAAQL,EAAIoN,EAAGpN,IAErCmI,EAAGnI,GAAMoR,EAAGpR,EAId,CAIA,SAAS0lE,GAAe3lD,EAAUle,GAEjC,IAAI6G,EAAIu8D,GAAepjE,QAEZhF,IAAN6L,IAEJA,EAAI,IAAIuG,WAAYpN,GACpBojE,GAAepjE,GAAM6G,GAItB,IAAM,IAAI1I,EAAI,EAAGA,IAAM6B,IAAM7B,EAE5B0I,EAAG1I,GAAM+f,EAAS4lD,sBAInB,OAAOj9D,CAER,CASA,SAASk9D,GAAaxmB,EAAIrsC,GAEzB,MAAMgtB,EAAQrgC,KAAKqgC,MAEdA,EAAO,KAAQhtB,IAEpBqsC,EAAGymB,UAAWnmE,KAAKomE,KAAM/yD,GAEzBgtB,EAAO,GAAMhtB,EAEd,CAIA,SAASgzD,GAAa3mB,EAAIrsC,GAEzB,MAAMgtB,EAAQrgC,KAAKqgC,MAEnB,QAAaljC,IAARkW,EAAE/W,EAED+jC,EAAO,KAAQhtB,EAAE/W,GAAK+jC,EAAO,KAAQhtB,EAAE7W,IAE3CkjD,EAAG4mB,UAAWtmE,KAAKomE,KAAM/yD,EAAE/W,EAAG+W,EAAE7W,GAEhC6jC,EAAO,GAAMhtB,EAAE/W,EACf+jC,EAAO,GAAMhtB,EAAE7W,OAIV,CAEN,GAAKupE,GAAa1lC,EAAOhtB,GAAM,OAE/BqsC,EAAG6mB,WAAYvmE,KAAKomE,KAAM/yD,GAE1By6B,GAAWzN,EAAOhtB,EAEnB,CAED,CAEA,SAASmzD,GAAa9mB,EAAIrsC,GAEzB,MAAMgtB,EAAQrgC,KAAKqgC,MAEnB,QAAaljC,IAARkW,EAAE/W,EAED+jC,EAAO,KAAQhtB,EAAE/W,GAAK+jC,EAAO,KAAQhtB,EAAE7W,GAAK6jC,EAAO,KAAQhtB,EAAEyN,IAEjE4+B,EAAG+mB,UAAWzmE,KAAKomE,KAAM/yD,EAAE/W,EAAG+W,EAAE7W,EAAG6W,EAAEyN,GAErCuf,EAAO,GAAMhtB,EAAE/W,EACf+jC,EAAO,GAAMhtB,EAAE7W,EACf6jC,EAAO,GAAMhtB,EAAEyN,QAIV,QAAa3jB,IAARkW,EAAErK,EAERq3B,EAAO,KAAQhtB,EAAErK,GAAKq3B,EAAO,KAAQhtB,EAAE0F,GAAKsnB,EAAO,KAAQhtB,EAAE3B,IAEjEguC,EAAG+mB,UAAWzmE,KAAKomE,KAAM/yD,EAAErK,EAAGqK,EAAE0F,EAAG1F,EAAE3B,GAErC2uB,EAAO,GAAMhtB,EAAErK,EACfq3B,EAAO,GAAMhtB,EAAE0F,EACfsnB,EAAO,GAAMhtB,EAAE3B,OAIV,CAEN,GAAKq0D,GAAa1lC,EAAOhtB,GAAM,OAE/BqsC,EAAGgnB,WAAY1mE,KAAKomE,KAAM/yD,GAE1By6B,GAAWzN,EAAOhtB,EAEnB,CAED,CAEA,SAASszD,GAAajnB,EAAIrsC,GAEzB,MAAMgtB,EAAQrgC,KAAKqgC,MAEnB,QAAaljC,IAARkW,EAAE/W,EAED+jC,EAAO,KAAQhtB,EAAE/W,GAAK+jC,EAAO,KAAQhtB,EAAE7W,GAAK6jC,EAAO,KAAQhtB,EAAEyN,GAAKuf,EAAO,KAAQhtB,EAAE0N,IAEvF2+B,EAAGknB,UAAW5mE,KAAKomE,KAAM/yD,EAAE/W,EAAG+W,EAAE7W,EAAG6W,EAAEyN,EAAGzN,EAAE0N,GAE1Csf,EAAO,GAAMhtB,EAAE/W,EACf+jC,EAAO,GAAMhtB,EAAE7W,EACf6jC,EAAO,GAAMhtB,EAAEyN,EACfuf,EAAO,GAAMhtB,EAAE0N,OAIV,CAEN,GAAKglD,GAAa1lC,EAAOhtB,GAAM,OAE/BqsC,EAAGmnB,WAAY7mE,KAAKomE,KAAM/yD,GAE1By6B,GAAWzN,EAAOhtB,EAEnB,CAED,CAIA,SAASyzD,GAAYpnB,EAAIrsC,GAExB,MAAMgtB,EAAQrgC,KAAKqgC,MACbpsB,EAAWZ,EAAEY,SAEnB,QAAkB9W,IAAb8W,EAAyB,CAE7B,GAAK8xD,GAAa1lC,EAAOhtB,GAAM,OAE/BqsC,EAAGqnB,iBAAkB/mE,KAAKomE,MAAM,EAAO/yD,GAEvCy6B,GAAWzN,EAAOhtB,EAEnB,KAAO,CAEN,GAAK0yD,GAAa1lC,EAAOpsB,GAAa,OAEtCyxD,GAAUnzD,IAAK0B,GAEfyrC,EAAGqnB,iBAAkB/mE,KAAKomE,MAAM,EAAOV,IAEvC53B,GAAWzN,EAAOpsB,EAEnB,CAED,CAEA,SAAS+yD,GAAYtnB,EAAIrsC,GAExB,MAAMgtB,EAAQrgC,KAAKqgC,MACbpsB,EAAWZ,EAAEY,SAEnB,QAAkB9W,IAAb8W,EAAyB,CAE7B,GAAK8xD,GAAa1lC,EAAOhtB,GAAM,OAE/BqsC,EAAGunB,iBAAkBjnE,KAAKomE,MAAM,EAAO/yD,GAEvCy6B,GAAWzN,EAAOhtB,EAEnB,KAAO,CAEN,GAAK0yD,GAAa1lC,EAAOpsB,GAAa,OAEtCwxD,GAAUlzD,IAAK0B,GAEfyrC,EAAGunB,iBAAkBjnE,KAAKomE,MAAM,EAAOX,IAEvC33B,GAAWzN,EAAOpsB,EAEnB,CAED,CAEA,SAASizD,GAAYxnB,EAAIrsC,GAExB,MAAMgtB,EAAQrgC,KAAKqgC,MACbpsB,EAAWZ,EAAEY,SAEnB,QAAkB9W,IAAb8W,EAAyB,CAE7B,GAAK8xD,GAAa1lC,EAAOhtB,GAAM,OAE/BqsC,EAAGynB,iBAAkBnnE,KAAKomE,MAAM,EAAO/yD,GAEvCy6B,GAAWzN,EAAOhtB,EAEnB,KAAO,CAEN,GAAK0yD,GAAa1lC,EAAOpsB,GAAa,OAEtCuxD,GAAUjzD,IAAK0B,GAEfyrC,EAAGynB,iBAAkBnnE,KAAKomE,MAAM,EAAOZ,IAEvC13B,GAAWzN,EAAOpsB,EAEnB,CAED,CAIA,SAASmzD,GAAa1nB,EAAIrsC,GAEzB,MAAMgtB,EAAQrgC,KAAKqgC,MAEdA,EAAO,KAAQhtB,IAEpBqsC,EAAG2nB,UAAWrnE,KAAKomE,KAAM/yD,GAEzBgtB,EAAO,GAAMhtB,EAEd,CAIA,SAASi0D,GAAa5nB,EAAIrsC,GAEzB,MAAMgtB,EAAQrgC,KAAKqgC,MAEnB,QAAaljC,IAARkW,EAAE/W,EAED+jC,EAAO,KAAQhtB,EAAE/W,GAAK+jC,EAAO,KAAQhtB,EAAE7W,IAE3CkjD,EAAG6nB,UAAWvnE,KAAKomE,KAAM/yD,EAAE/W,EAAG+W,EAAE7W,GAEhC6jC,EAAO,GAAMhtB,EAAE/W,EACf+jC,EAAO,GAAMhtB,EAAE7W,OAIV,CAEN,GAAKupE,GAAa1lC,EAAOhtB,GAAM,OAE/BqsC,EAAG8nB,WAAYxnE,KAAKomE,KAAM/yD,GAE1By6B,GAAWzN,EAAOhtB,EAEnB,CAED,CAEA,SAASo0D,GAAa/nB,EAAIrsC,GAEzB,MAAMgtB,EAAQrgC,KAAKqgC,MAEnB,QAAaljC,IAARkW,EAAE/W,EAED+jC,EAAO,KAAQhtB,EAAE/W,GAAK+jC,EAAO,KAAQhtB,EAAE7W,GAAK6jC,EAAO,KAAQhtB,EAAEyN,IAEjE4+B,EAAGgoB,UAAW1nE,KAAKomE,KAAM/yD,EAAE/W,EAAG+W,EAAE7W,EAAG6W,EAAEyN,GAErCuf,EAAO,GAAMhtB,EAAE/W,EACf+jC,EAAO,GAAMhtB,EAAE7W,EACf6jC,EAAO,GAAMhtB,EAAEyN,OAIV,CAEN,GAAKilD,GAAa1lC,EAAOhtB,GAAM,OAE/BqsC,EAAGioB,WAAY3nE,KAAKomE,KAAM/yD,GAE1By6B,GAAWzN,EAAOhtB,EAEnB,CAED,CAEA,SAASu0D,GAAaloB,EAAIrsC,GAEzB,MAAMgtB,EAAQrgC,KAAKqgC,MAEnB,QAAaljC,IAARkW,EAAE/W,EAED+jC,EAAO,KAAQhtB,EAAE/W,GAAK+jC,EAAO,KAAQhtB,EAAE7W,GAAK6jC,EAAO,KAAQhtB,EAAEyN,GAAKuf,EAAO,KAAQhtB,EAAE0N,IAEvF2+B,EAAGmoB,UAAW7nE,KAAKomE,KAAM/yD,EAAE/W,EAAG+W,EAAE7W,EAAG6W,EAAEyN,EAAGzN,EAAE0N,GAE1Csf,EAAO,GAAMhtB,EAAE/W,EACf+jC,EAAO,GAAMhtB,EAAE7W,EACf6jC,EAAO,GAAMhtB,EAAEyN,EACfuf,EAAO,GAAMhtB,EAAE0N,OAIV,CAEN,GAAKglD,GAAa1lC,EAAOhtB,GAAM,OAE/BqsC,EAAGooB,WAAY9nE,KAAKomE,KAAM/yD,GAE1By6B,GAAWzN,EAAOhtB,EAEnB,CAED,CAIA,SAAS00D,GAAcroB,EAAIrsC,GAE1B,MAAMgtB,EAAQrgC,KAAKqgC,MAEdA,EAAO,KAAQhtB,IAEpBqsC,EAAGsoB,WAAYhoE,KAAKomE,KAAM/yD,GAE1BgtB,EAAO,GAAMhtB,EAEd,CAIA,SAAS40D,GAAcvoB,EAAIrsC,GAE1B,MAAMgtB,EAAQrgC,KAAKqgC,MAEnB,QAAaljC,IAARkW,EAAE/W,EAED+jC,EAAO,KAAQhtB,EAAE/W,GAAK+jC,EAAO,KAAQhtB,EAAE7W,IAE3CkjD,EAAGwoB,WAAYloE,KAAKomE,KAAM/yD,EAAE/W,EAAG+W,EAAE7W,GAEjC6jC,EAAO,GAAMhtB,EAAE/W,EACf+jC,EAAO,GAAMhtB,EAAE7W,OAIV,CAEN,GAAKupE,GAAa1lC,EAAOhtB,GAAM,OAE/BqsC,EAAGyoB,YAAanoE,KAAKomE,KAAM/yD,GAE3By6B,GAAWzN,EAAOhtB,EAEnB,CAED,CAEA,SAAS+0D,GAAc1oB,EAAIrsC,GAE1B,MAAMgtB,EAAQrgC,KAAKqgC,MAEnB,QAAaljC,IAARkW,EAAE/W,EAED+jC,EAAO,KAAQhtB,EAAE/W,GAAK+jC,EAAO,KAAQhtB,EAAE7W,GAAK6jC,EAAO,KAAQhtB,EAAEyN,IAEjE4+B,EAAG2oB,WAAYroE,KAAKomE,KAAM/yD,EAAE/W,EAAG+W,EAAE7W,EAAG6W,EAAEyN,GAEtCuf,EAAO,GAAMhtB,EAAE/W,EACf+jC,EAAO,GAAMhtB,EAAE7W,EACf6jC,EAAO,GAAMhtB,EAAEyN,OAIV,CAEN,GAAKilD,GAAa1lC,EAAOhtB,GAAM,OAE/BqsC,EAAG4oB,YAAatoE,KAAKomE,KAAM/yD,GAE3By6B,GAAWzN,EAAOhtB,EAEnB,CAED,CAEA,SAASk1D,GAAc7oB,EAAIrsC,GAE1B,MAAMgtB,EAAQrgC,KAAKqgC,MAEnB,QAAaljC,IAARkW,EAAE/W,EAED+jC,EAAO,KAAQhtB,EAAE/W,GAAK+jC,EAAO,KAAQhtB,EAAE7W,GAAK6jC,EAAO,KAAQhtB,EAAEyN,GAAKuf,EAAO,KAAQhtB,EAAE0N,IAEvF2+B,EAAG8oB,WAAYxoE,KAAKomE,KAAM/yD,EAAE/W,EAAG+W,EAAE7W,EAAG6W,EAAEyN,EAAGzN,EAAE0N,GAE3Csf,EAAO,GAAMhtB,EAAE/W,EACf+jC,EAAO,GAAMhtB,EAAE7W,EACf6jC,EAAO,GAAMhtB,EAAEyN,EACfuf,EAAO,GAAMhtB,EAAE0N,OAIV,CAEN,GAAKglD,GAAa1lC,EAAOhtB,GAAM,OAE/BqsC,EAAG+oB,YAAazoE,KAAKomE,KAAM/yD,GAE3By6B,GAAWzN,EAAOhtB,EAEnB,CAED,CAKA,SAASq1D,GAAYhpB,EAAIrsC,EAAGgN,GAE3B,MAAMggB,EAAQrgC,KAAKqgC,MACbsoC,EAAOtoD,EAAS4lD,sBAEjB5lC,EAAO,KAAQsoC,IAEnBjpB,EAAG2nB,UAAWrnE,KAAKomE,KAAMuC,GACzBtoC,EAAO,GAAMsoC,GAIdtoD,EAASuoD,aAAcv1D,GAAK6xD,GAAcyD,EAE3C,CAEA,SAASE,GAAcnpB,EAAIrsC,EAAGgN,GAE7B,MAAMggB,EAAQrgC,KAAKqgC,MACbsoC,EAAOtoD,EAAS4lD,sBAEjB5lC,EAAO,KAAQsoC,IAEnBjpB,EAAG2nB,UAAWrnE,KAAKomE,KAAMuC,GACzBtoC,EAAO,GAAMsoC,GAIdtoD,EAASyoD,aAAcz1D,GAAK+xD,GAAgBuD,EAE7C,CAEA,SAASI,GAAYrpB,EAAIrsC,EAAGgN,GAE3B,MAAMggB,EAAQrgC,KAAKqgC,MACbsoC,EAAOtoD,EAAS4lD,sBAEjB5lC,EAAO,KAAQsoC,IAEnBjpB,EAAG2nB,UAAWrnE,KAAKomE,KAAMuC,GACzBtoC,EAAO,GAAMsoC,GAIdtoD,EAAS2oD,eAAgB31D,GAAKgyD,GAAkBsD,EAEjD,CAEA,SAASM,GAAmBvpB,EAAIrsC,EAAGgN,GAElC,MAAMggB,EAAQrgC,KAAKqgC,MACbsoC,EAAOtoD,EAAS4lD,sBAEjB5lC,EAAO,KAAQsoC,IAEnBjpB,EAAG2nB,UAAWrnE,KAAKomE,KAAMuC,GACzBtoC,EAAO,GAAMsoC,GAIdtoD,EAAS6oD,kBAAmB71D,GAAK8xD,GAAmBwD,EAErD,CA0DA,SAASQ,GAAkBzpB,EAAIrsC,GAE9BqsC,EAAG0pB,WAAYppE,KAAKomE,KAAM/yD,EAE3B,CAIA,SAASg2D,GAAkB3pB,EAAIrsC,GAE9B,MAAMhQ,EAAOsiE,GAAStyD,EAAGrT,KAAKgsB,KAAM,GAEpC0zB,EAAG6mB,WAAYvmE,KAAKomE,KAAM/iE,EAE3B,CAEA,SAASimE,GAAkB5pB,EAAIrsC,GAE9B,MAAMhQ,EAAOsiE,GAAStyD,EAAGrT,KAAKgsB,KAAM,GAEpC0zB,EAAGgnB,WAAY1mE,KAAKomE,KAAM/iE,EAE3B,CAEA,SAASkmE,GAAkB7pB,EAAIrsC,GAE9B,MAAMhQ,EAAOsiE,GAAStyD,EAAGrT,KAAKgsB,KAAM,GAEpC0zB,EAAGmnB,WAAY7mE,KAAKomE,KAAM/iE,EAE3B,CAIA,SAASmmE,GAAiB9pB,EAAIrsC,GAE7B,MAAMhQ,EAAOsiE,GAAStyD,EAAGrT,KAAKgsB,KAAM,GAEpC0zB,EAAGqnB,iBAAkB/mE,KAAKomE,MAAM,EAAO/iE,EAExC,CAEA,SAASomE,GAAiB/pB,EAAIrsC,GAE7B,MAAMhQ,EAAOsiE,GAAStyD,EAAGrT,KAAKgsB,KAAM,GAEpC0zB,EAAGunB,iBAAkBjnE,KAAKomE,MAAM,EAAO/iE,EAExC,CAEA,SAASqmE,GAAiBhqB,EAAIrsC,GAE7B,MAAMhQ,EAAOsiE,GAAStyD,EAAGrT,KAAKgsB,KAAM,IAEpC0zB,EAAGynB,iBAAkBnnE,KAAKomE,MAAM,EAAO/iE,EAExC,CAIA,SAASsmE,GAAkBjqB,EAAIrsC,GAE9BqsC,EAAGkqB,WAAY5pE,KAAKomE,KAAM/yD,EAE3B,CAIA,SAASw2D,GAAkBnqB,EAAIrsC,GAE9BqsC,EAAG8nB,WAAYxnE,KAAKomE,KAAM/yD,EAE3B,CAEA,SAASy2D,GAAkBpqB,EAAIrsC,GAE9BqsC,EAAGioB,WAAY3nE,KAAKomE,KAAM/yD,EAE3B,CAEA,SAAS02D,GAAkBrqB,EAAIrsC,GAE9BqsC,EAAGooB,WAAY9nE,KAAKomE,KAAM/yD,EAE3B,CAIA,SAAS22D,GAAmBtqB,EAAIrsC,GAE/BqsC,EAAGuqB,YAAajqE,KAAKomE,KAAM/yD,EAE5B,CAIA,SAAS62D,GAAmBxqB,EAAIrsC,GAE/BqsC,EAAGyoB,YAAanoE,KAAKomE,KAAM/yD,EAE5B,CAEA,SAAS82D,GAAmBzqB,EAAIrsC,GAE/BqsC,EAAG4oB,YAAatoE,KAAKomE,KAAM/yD,EAE5B,CAEA,SAAS+2D,GAAmB1qB,EAAIrsC,GAE/BqsC,EAAG+oB,YAAazoE,KAAKomE,KAAM/yD,EAE5B,CAKA,SAASg3D,GAAiB3qB,EAAIrsC,EAAGgN,GAEhC,MAAMggB,EAAQrgC,KAAKqgC,MAEbl+B,EAAIkR,EAAE1S,OAEN2pE,EAAQtE,GAAe3lD,EAAUle,GAEhC4jE,GAAa1lC,EAAOiqC,KAE1B5qB,EAAGkqB,WAAY5pE,KAAKomE,KAAMkE,GAE1Bx8B,GAAWzN,EAAOiqC,IAInB,IAAM,IAAIhqE,EAAI,EAAGA,IAAM6B,IAAM7B,EAE5B+f,EAASuoD,aAAcv1D,EAAG/S,IAAO4kE,GAAcoF,EAAOhqE,GAIxD,CAEA,SAASiqE,GAAkB7qB,EAAIrsC,EAAGgN,GAEjC,MAAMggB,EAAQrgC,KAAKqgC,MAEbl+B,EAAIkR,EAAE1S,OAEN2pE,EAAQtE,GAAe3lD,EAAUle,GAEhC4jE,GAAa1lC,EAAOiqC,KAE1B5qB,EAAGkqB,WAAY5pE,KAAKomE,KAAMkE,GAE1Bx8B,GAAWzN,EAAOiqC,IAInB,IAAM,IAAIhqE,EAAI,EAAGA,IAAM6B,IAAM7B,EAE5B+f,EAASyoD,aAAcz1D,EAAG/S,IAAO8kE,GAAgBkF,EAAOhqE,GAI1D,CAEA,SAASkqE,GAAiB9qB,EAAIrsC,EAAGgN,GAEhC,MAAMggB,EAAQrgC,KAAKqgC,MAEbl+B,EAAIkR,EAAE1S,OAEN2pE,EAAQtE,GAAe3lD,EAAUle,GAEhC4jE,GAAa1lC,EAAOiqC,KAE1B5qB,EAAGkqB,WAAY5pE,KAAKomE,KAAMkE,GAE1Bx8B,GAAWzN,EAAOiqC,IAInB,IAAM,IAAIhqE,EAAI,EAAGA,IAAM6B,IAAM7B,EAE5B+f,EAAS2oD,eAAgB31D,EAAG/S,IAAO+kE,GAAkBiF,EAAOhqE,GAI9D,CAEA,SAASmqE,GAAuB/qB,EAAIrsC,EAAGgN,GAEtC,MAAMggB,EAAQrgC,KAAKqgC,MAEbl+B,EAAIkR,EAAE1S,OAEN2pE,EAAQtE,GAAe3lD,EAAUle,GAEhC4jE,GAAa1lC,EAAOiqC,KAE1B5qB,EAAGkqB,WAAY5pE,KAAKomE,KAAMkE,GAE1Bx8B,GAAWzN,EAAOiqC,IAInB,IAAM,IAAIhqE,EAAI,EAAGA,IAAM6B,IAAM7B,EAE5B+f,EAAS6oD,kBAAmB71D,EAAG/S,IAAO6kE,GAAmBmF,EAAOhqE,GAIlE,CA0DA,MAAMoqE,GAELnoE,YAAa5C,EAAIgrE,EAAYvE,GAE5BpmE,KAAKL,GAAKA,EACVK,KAAKomE,KAAOA,EACZpmE,KAAKqgC,MAAQ,GACbrgC,KAAKykE,SA1UP,SAA4B13D,GAE3B,OAASA,GAER,KAAK,KAAQ,OAAOm5D,GACpB,KAAK,MAAQ,OAAOG,GACpB,KAAK,MAAQ,OAAOG,GACpB,KAAK,MAAQ,OAAOG,GAEpB,KAAK,MAAQ,OAAOG,GACpB,KAAK,MAAQ,OAAOE,GACpB,KAAK,MAAQ,OAAOE,GAEpB,KAAK,KAAQ,KAAK,MAAQ,OAAOE,GACjC,KAAK,MAAQ,KAAK,MAAQ,OAAOE,GACjC,KAAK,MAAQ,KAAK,MAAQ,OAAOG,GACjC,KAAK,MAAQ,KAAK,MAAQ,OAAOG,GAEjC,KAAK,KAAQ,OAAOG,GACpB,KAAK,MAAQ,OAAOE,GACpB,KAAK,MAAQ,OAAOG,GACpB,KAAK,MAAQ,OAAOG,GAEpB,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACJ,OAAOG,GAER,KAAK,MACL,KAAK,MACL,KAAK,MACJ,OAAOG,GAER,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACJ,OAAOE,GAER,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACJ,OAAOE,GAIV,CAyRkB2B,CAAmBD,EAAW59D,KAI/C,EAID,MAAM89D,GAELtoE,YAAa5C,EAAIgrE,EAAYvE,GAE5BpmE,KAAKL,GAAKA,EACVK,KAAKomE,KAAOA,EACZpmE,KAAKqgC,MAAQ,GACbrgC,KAAKgsB,KAAO2+C,EAAW3+C,KACvBhsB,KAAKykE,SA5EP,SAA6B13D,GAE5B,OAASA,GAER,KAAK,KAAQ,OAAOo8D,GACpB,KAAK,MAAQ,OAAOE,GACpB,KAAK,MAAQ,OAAOC,GACpB,KAAK,MAAQ,OAAOC,GAEpB,KAAK,MAAQ,OAAOC,GACpB,KAAK,MAAQ,OAAOC,GACpB,KAAK,MAAQ,OAAOC,GAEpB,KAAK,KAAQ,KAAK,MAAQ,OAAOC,GACjC,KAAK,MAAQ,KAAK,MAAQ,OAAOE,GACjC,KAAK,MAAQ,KAAK,MAAQ,OAAOC,GACjC,KAAK,MAAQ,KAAK,MAAQ,OAAOC,GAEjC,KAAK,KAAQ,OAAOC,GACpB,KAAK,MAAQ,OAAOE,GACpB,KAAK,MAAQ,OAAOC,GACpB,KAAK,MAAQ,OAAOC,GAEpB,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACJ,OAAOC,GAER,KAAK,MACL,KAAK,MACL,KAAK,MACJ,OAAOE,GAER,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACJ,OAAOC,GAER,KAAK,MACL,KAAK,MACL,KAAK,MACL,KAAK,MACJ,OAAOC,GAIV,CA2BkBK,CAAoBH,EAAW59D,KAIhD,EAID,MAAMg+D,GAELxoE,YAAa5C,GAEZK,KAAKL,GAAKA,EAEVK,KAAKgrE,IAAM,GACXhrE,KAAKC,IAAM,CAAC,CAEb,CAEAwkE,SAAU/kB,EAAItiD,EAAOijB,GAEpB,MAAM2qD,EAAMhrE,KAAKgrE,IAEjB,IAAM,IAAI1qE,EAAI,EAAG6B,EAAI6oE,EAAIrqE,OAAQL,IAAM6B,IAAM7B,EAAI,CAEhD,MAAM8qB,EAAI4/C,EAAK1qE,GACf8qB,EAAEq5C,SAAU/kB,EAAItiD,EAAOguB,EAAEzrB,IAAM0gB,EAEhC,CAED,EAQD,MAAM4qD,GAAa,sBAWnB,SAASC,GAAYC,EAAWC,GAE/BD,EAAUH,IAAIvrE,KAAM2rE,GACpBD,EAAUlrE,IAAKmrE,EAAczrE,IAAOyrE,CAErC,CAEA,SAASC,GAAcV,EAAYvE,EAAM+E,GAExC,MAAMG,EAAOX,EAAWnoE,KACvB+oE,EAAaD,EAAK3qE,OAKnB,IAFAsqE,GAAWO,UAAY,IAER,CAEd,MAAMC,EAAQR,GAAWz/B,KAAM8/B,GAC9BI,EAAWT,GAAWO,UAEvB,IAAI7rE,EAAK8rE,EAAO,GAChB,MAAME,EAA2B,MAAfF,EAAO,GACxBG,EAAYH,EAAO,GAIpB,GAFKE,IAAYhsE,GAAU,QAERxC,IAAdyuE,GAAyC,MAAdA,GAAqBF,EAAW,IAAMH,EAAa,CAIlFL,GAAYC,OAAyBhuE,IAAdyuE,EACtB,IAAIlB,GAAe/qE,EAAIgrE,EAAYvE,GACnC,IAAIyE,GAAkBlrE,EAAIgrE,EAAYvE,IAEvC,KAED,CAAO,CAKN,IAAIvkE,EADQspE,EAAUlrE,IACNN,QAEFxC,IAAT0E,IAEJA,EAAO,IAAIkpE,GAAmBprE,GAC9BurE,GAAYC,EAAWtpE,IAIxBspE,EAAYtpE,CAEb,CAED,CAED,CAIA,MAAMgqE,GAELtpE,YAAam9C,EAAIkU,GAEhB5zD,KAAKgrE,IAAM,GACXhrE,KAAKC,IAAM,CAAC,EAEZ,MAAMkC,EAAIu9C,EAAGosB,oBAAqBlY,EAASlU,EAAGqsB,iBAE9C,IAAM,IAAIzrE,EAAI,EAAGA,EAAI6B,IAAM7B,EAAI,CAE9B,MAAMq2D,EAAOjX,EAAGssB,iBAAkBpY,EAAStzD,GAG3C+qE,GAAc1U,EAFNjX,EAAGusB,mBAAoBrY,EAAS+C,EAAKn0D,MAEnBxC,KAE3B,CAED,CAEAykE,SAAU/kB,EAAIl9C,EAAMpF,EAAOijB,GAE1B,MAAM+K,EAAIprB,KAAKC,IAAKuC,QAETrF,IAANiuB,GAAkBA,EAAEq5C,SAAU/kB,EAAItiD,EAAOijB,EAE/C,CAEA6rD,YAAaxsB,EAAIvzB,EAAQ3pB,GAExB,MAAM6Q,EAAI8Y,EAAQ3pB,QAEPrF,IAANkW,GAAkBrT,KAAKykE,SAAU/kB,EAAIl9C,EAAM6Q,EAEjD,CAEAqJ,cAAegjC,EAAIsrB,EAAK1qC,EAAQjgB,GAE/B,IAAM,IAAI/f,EAAI,EAAG6B,EAAI6oE,EAAIrqE,OAAQL,IAAM6B,IAAM7B,EAAI,CAEhD,MAAM8qB,EAAI4/C,EAAK1qE,GACd+S,EAAIitB,EAAQlV,EAAEzrB,KAEQ,IAAlB0T,EAAEyK,aAGNsN,EAAEq5C,SAAU/kB,EAAIrsC,EAAEjW,MAAOijB,EAI3B,CAED,CAEA3D,oBAAqBsuD,EAAK1qC,GAEzB,MAAMt3B,EAAI,GAEV,IAAM,IAAI1I,EAAI,EAAG6B,EAAI6oE,EAAIrqE,OAAQL,IAAM6B,IAAM7B,EAAI,CAEhD,MAAM8qB,EAAI4/C,EAAK1qE,GACV8qB,EAAEzrB,MAAM2gC,GAASt3B,EAAEvJ,KAAM2rB,EAE/B,CAEA,OAAOpiB,CAER,EAID,SAASmjE,GAAazsB,EAAI3yC,EAAMu+B,GAE/B,MAAMmQ,EAASiE,EAAG0sB,aAAcr/D,GAKhC,OAHA2yC,EAAG2sB,aAAc5wB,EAAQnQ,GACzBoU,EAAG4sB,cAAe7wB,GAEXA,CAER,CAEA,IAAI8wB,GAAiB,EAqCrB,SAASC,GAAiB9sB,EAAIjE,EAAQ1uC,GAErC,MAAM0/D,EAAS/sB,EAAGgtB,mBAAoBjxB,EAAQiE,EAAGitB,gBAC3CC,EAASltB,EAAGmtB,iBAAkBpxB,GAASqxB,OAE7C,GAAKL,GAAqB,KAAXG,EAAgB,MAAO,GAEtC,MAAMG,EAAe,iBAAiBvhC,KAAMohC,GAC5C,GAAKG,EAAe,CAKnB,MAAMC,EAAYthC,SAAUqhC,EAAc,IAC1C,OAAOhgE,EAAKkgE,cAAgB,OAASL,EAAS,OAjDhD,SAAuBthC,EAAQ0hC,GAE9B,MAAMzK,EAAQj3B,EAAO4hC,MAAO,MACtBC,EAAS,GAET1qE,EAAOzE,KAAKuQ,IAAKy+D,EAAY,EAAG,GAChCI,EAAKpvE,KAAKL,IAAKqvE,EAAY,EAAGzK,EAAM5hE,QAE1C,IAAM,IAAIL,EAAImC,EAAMnC,EAAI8sE,EAAI9sE,IAAO,CAElC,MAAMm8C,EAAOn8C,EAAI,EACjB6sE,EAAO1tE,KAAM,GAAGg9C,IAASuwB,EAAY,IAAM,OAAOvwB,MAAS8lB,EAAOjiE,KAEnE,CAEA,OAAO6sE,EAAO9sE,KAAM,KAErB,CAgCyDgtE,CAAc3tB,EAAG4tB,gBAAiB7xB,GAAUuxB,EAEpG,CAEC,OAAOJ,CAIT,CAEA,SAASW,GAA0BC,EAAcxxD,GAEhD,MAAMyvB,EA1CP,SAAgCzvB,GAE/B,OAASA,GAER,KAAK1P,GACJ,MAAO,CAAE,SAAU,aACpB,KAAKD,GACJ,MAAO,CAAE,OAAQ,aAClB,QAEC,OADA/N,QAAQkU,KAAM,+CAAgDwJ,GACvD,CAAE,SAAU,aAItB,CA4BoByxD,CAAuBzxD,GAC1C,MAAO,QAAUwxD,EAAe,mCAAqC/hC,EAAY,GAAMA,EAAY,GAAM,KAE1G,CAEA,SAASiiC,GAAwBF,EAAczyB,GAE9C,IAAI4yB,EAEJ,OAAS5yB,GAER,KAAKhxC,EACJ4jE,EAAkB,SAClB,MAED,KAAK3jE,EACJ2jE,EAAkB,WAClB,MAED,KAAK1jE,EACJ0jE,EAAkB,kBAClB,MAED,KAAKzjE,EACJyjE,EAAkB,aAClB,MAED,KAAKxjE,EACJwjE,EAAkB,SAClB,MAED,QACCrvE,QAAQkU,KAAM,+CAAgDuoC,GAC9D4yB,EAAkB,SAIpB,MAAO,QAAUH,EAAe,2BAA6BG,EAAkB,yBAEhF,CA+DA,SAASC,GAAiBtiC,GAEzB,MAAkB,KAAXA,CAER,CAEA,SAASuiC,GAAkBviC,EAAQ3L,GAElC,MAAMmuC,EAAqBnuC,EAAWouC,oBAAsBpuC,EAAWquC,iBAAmBruC,EAAWsuC,4BAErG,OAAO3iC,EACLrnC,QAAS,kBAAmB07B,EAAWuuC,cACvCjqE,QAAS,mBAAoB07B,EAAWwuC,eACxClqE,QAAS,uBAAwB07B,EAAWquC,kBAC5C/pE,QAAS,yBAA0B6pE,GACnC7pE,QAAS,wBAAyB07B,EAAWyuC,mBAC7CnqE,QAAS,oBAAqB07B,EAAW0uC,gBACzCpqE,QAAS,mBAAoB07B,EAAW2uC,eACxCrqE,QAAS,yBAA0B07B,EAAW4uC,oBAC9CtqE,QAAS,oCAAqC07B,EAAWsuC,6BACzDhqE,QAAS,0BAA2B07B,EAAWouC,qBAC/C9pE,QAAS,2BAA4B07B,EAAW6uC,qBAEnD,CAEA,SAASC,GAA0BnjC,EAAQ3L,GAE1C,OAAO2L,EACLrnC,QAAS,uBAAwB07B,EAAW+uC,mBAC5CzqE,QAAS,yBAA4B07B,EAAW+uC,kBAAoB/uC,EAAWgvC,oBAElF,CAIA,MAAMC,GAAiB,mCAEvB,SAASC,GAAiBvjC,GAEzB,OAAOA,EAAOrnC,QAAS2qE,GAAgBE,GAExC,CAEA,MAAMC,GAAiB,IAAIC,IAAK,CAC/B,CAAE,qBAAsB,uBACxB,CAAE,0BAA2B,4BAC7B,CAAE,kBAAmB,qBAGtB,SAASF,GAAiBrD,EAAOwD,GAEhC,IAAI3jC,EAASqW,GAAastB,GAE1B,QAAgB9xE,IAAXmuC,EAAuB,CAE3B,MAAM4jC,EAAaH,GAAelmE,IAAKomE,GAEvC,QAAoB9xE,IAAf+xE,EAOJ,MAAM,IAAIjpE,MAAO,6BAA+BgpE,EAAU,KAL1D3jC,EAASqW,GAAautB,GACtB5wE,QAAQkU,KAAM,gFAAiFy8D,EAASC,EAQ1G,CAEA,OAAOL,GAAiBvjC,EAEzB,CAIA,MAAM6jC,GAAoB,+IAE1B,SAASC,GAAa9jC,GAErB,OAAOA,EAAOrnC,QAASkrE,GAAmBE,GAE3C,CAEA,SAASA,GAAc5D,EAAOv8B,EAAO2N,EAAKyyB,GAEzC,IAAIhkC,EAAS,GAEb,IAAM,IAAIhrC,EAAIorC,SAAUwD,GAAS5uC,EAAIorC,SAAUmR,GAAOv8C,IAErDgrC,GAAUgkC,EACRrrE,QAAS,eAAgB,KAAO3D,EAAI,MACpC2D,QAAS,uBAAwB3D,GAIpC,OAAOgrC,CAER,CAIA,SAASikC,GAAmB5vC,GAE3B,IAAI6vC,EAAkB,aAAe7vC,EAAWyF,UAAY,sBAAwBzF,EAAWyF,UAAY,QAgB3G,MAd8B,UAAzBzF,EAAWyF,UAEfoqC,GAAmB,2BAEiB,YAAzB7vC,EAAWyF,UAEtBoqC,GAAmB,6BAEiB,SAAzB7vC,EAAWyF,YAEtBoqC,GAAmB,2BAIbA,CAER,CAkHA,SAASC,GAAcz4B,EAAU04B,EAAU/vC,EAAYkzB,GAKtD,MAAMnT,EAAK1I,EAASh6B,aAEdu6B,EAAU5X,EAAW4X,QAE3B,IAAIE,EAAe9X,EAAW8X,aAC1BC,EAAiB/X,EAAW+X,eAEhC,MAAMi4B,EA5HP,SAAsChwC,GAErC,IAAIgwC,EAAsB,uBAgB1B,OAdKhwC,EAAWiwC,gBAAkBvmE,EAEjCsmE,EAAsB,qBAEXhwC,EAAWiwC,gBAAkBtmE,EAExCqmE,EAAsB,0BAEXhwC,EAAWiwC,gBAAkBrmE,IAExComE,EAAsB,sBAIhBA,CAER,CAwG6BE,CAA6BlwC,GACnDmwC,EAvGP,SAAmCnwC,GAElC,IAAImwC,EAAmB,mBAEvB,GAAKnwC,EAAWuJ,OAEf,OAASvJ,EAAWowC,YAEnB,KAAK3lE,EACL,KAAKC,EACJylE,EAAmB,mBACnB,MAED,KAAKxlE,EACJwlE,EAAmB,sBAOtB,OAAOA,CAER,CAgF0BE,CAA0BrwC,GAC7CswC,EA/EP,SAAmCtwC,GAElC,IAAIswC,EAAmB,yBAevB,OAbKtwC,EAAWuJ,QAENvJ,EAAWowC,aAEd1lE,IAEJ4lE,EAAmB,0BAOfA,CAER,CA4D0BC,CAA0BvwC,GAC7CwwC,EA3DP,SAAuCxwC,GAEtC,IAAIwwC,EAAuB,uBAE3B,GAAKxwC,EAAWuJ,OAEf,OAASvJ,EAAWwJ,SAEnB,KAAKx/B,EACJwmE,EAAuB,2BACvB,MAED,KAAKvmE,EACJumE,EAAuB,sBACvB,MAED,KAAKtmE,EACJsmE,EAAuB,sBAO1B,OAAOA,CAER,CAiC8BC,CAA8BzwC,GACrD0wC,EAhCP,SAA6B1wC,GAE5B,MAAM2wC,EAAc3wC,EAAW4wC,mBAE/B,GAAqB,OAAhBD,EAAuB,OAAO,KAEnC,MAAME,EAASxyE,KAAK6/D,KAAMyS,GAAgB,EAEpCG,EAAc,EAAMH,EAI1B,MAAO,CAAEI,WAFU,GAAQ,EAAI1yE,KAAKuQ,IAAKvQ,KAAK8Q,IAAK,EAAG0hE,GAAU,MAE3CC,cAAaD,SAEnC,CAkB0BG,CAAoBhxC,GAEvCixC,EAAmBjxC,EAAWigB,SAAW,GA3ThD,SAA6BjgB,GAS5B,MAPe,CACZA,EAAWkxC,sBAA2BlxC,EAAW4wC,oBAAsB5wC,EAAWyI,SAAWzI,EAAWmxC,uBAAyBnxC,EAAW0H,oBAAsB1H,EAAW4K,aAAuC,aAAxB5K,EAAWoxC,SAA4B,kDAAoD,IACvRpxC,EAAWqxC,oBAAsBrxC,EAAWk4B,yBAA4Bl4B,EAAWsxC,2BAA6B,wCAA0C,GAC1JtxC,EAAWuxC,sBAAwBvxC,EAAWwxC,6BAAiC,2CAA6C,IAC5HxxC,EAAWyxC,2BAA6BzxC,EAAWuJ,QAAUvJ,EAAW6J,eAAkB7J,EAAW0xC,kCAAoC,gDAAkD,IAGhL/qE,OAAQsnE,IAAkBvtE,KAAM,KAE/C,CAgTqDixE,CAAoB3xC,GAElE4xC,EAhTP,SAA0Bh6B,GAEzB,MAAMi6B,EAAS,GAEf,IAAM,MAAMhvE,KAAQ+0C,EAAU,CAE7B,MAAMn6C,EAAQm6C,EAAS/0C,IAER,IAAVpF,GAELo0E,EAAO/xE,KAAM,WAAa+C,EAAO,IAAMpF,EAExC,CAEA,OAAOo0E,EAAOnxE,KAAM,KAErB,CAgSuBoxE,CAAiBl6B,GAEjCqc,EAAUlU,EAAGgyB,gBAEnB,IAAIC,EAAcC,EACdC,EAAgBlyC,EAAW0Y,YAAc,YAAc1Y,EAAW0Y,YAAc,KAAO,GAEtF1Y,EAAWmyC,qBAEfH,EAAe,CAEd,uBAAyBhyC,EAAWoyC,WACpC,uBAAyBpyC,EAAWqyC,WAEpCT,GAECjrE,OAAQsnE,IAAkBvtE,KAAM,MAE7BsxE,EAAahxE,OAAS,IAE1BgxE,GAAgB,MAIjBC,EAAiB,CAEhBhB,EAEA,uBAAyBjxC,EAAWoyC,WACpC,uBAAyBpyC,EAAWqyC,WAEpCT,GAECjrE,OAAQsnE,IAAkBvtE,KAAM,MAE7BuxE,EAAejxE,OAAS,IAE5BixE,GAAkB,QAMnBD,EAAe,CAEdpC,GAAmB5vC,GAEnB,uBAAyBA,EAAWoyC,WACpC,uBAAyBpyC,EAAWqyC,WAEpCT,EAEA5xC,EAAWsyC,WAAa,yBAA2B,GACnDtyC,EAAWuyC,gBAAkB,+BAAiC,GAE9DvyC,EAAWwyC,QAAUxyC,EAAW6K,IAAM,kBAAoB,GAC1D7K,EAAWwyC,QAAUxyC,EAAWyyC,QAAU,mBAAqB,GAE/DzyC,EAAW1/B,IAAM,kBAAoB,GACrC0/B,EAAWuJ,OAAS,qBAAuB,GAC3CvJ,EAAWuJ,OAAS,WAAa+mC,EAAmB,GACpDtwC,EAAWqI,SAAW,uBAAyB,GAC/CrI,EAAWuI,MAAQ,oBAAsB,GACzCvI,EAAWyI,QAAU,sBAAwB,GAC7CzI,EAAW2I,UAAY,wBAA0B,GACjD3I,EAAW0yC,qBAAuB,oCAAsC,GACxE1yC,EAAWmxC,sBAAwB,qCAAuC,GAC1EnxC,EAAW8I,gBAAkB,8BAAgC,GAC7D9I,EAAWmJ,YAAc,0BAA4B,GAErDnJ,EAAWkI,cAAgB,4BAA8B,GAEzDlI,EAAWwH,aAAe,2BAA6B,GACvDxH,EAAWyH,sBAAwB,qCAAuC,GAC1EzH,EAAW0H,mBAAqB,kCAAoC,GAEpE1H,EAAW+H,eAAiB,6BAA+B,GAC3D/H,EAAWgI,wBAA0B,uCAAyC,GAE9EhI,EAAWoJ,YAAc,0BAA4B,GACrDpJ,EAAWsJ,iBAAmB,gCAAkC,GAChEtJ,EAAWqJ,qBAAuB,oCAAsC,GAExErJ,EAAWiJ,aAAe,2BAA6B,GACvDjJ,EAAWkJ,aAAe,2BAA6B,GACvDlJ,EAAWoI,SAAW,uBAAyB,GAC/CpI,EAAWkE,UAAY,wBAA0B,GAEjDlE,EAAW6J,aAAe,2BAA6B,GACvD7J,EAAW8J,gBAAkB,8BAAgC,GAC7D9J,EAAWgK,aAAe,2BAA6B,GAEvDhK,EAAWuwB,cAAgB,6BAA+B,GAC1DvwB,EAAWywB,kBAAoB,iCAAmC,GAIlEzwB,EAAW2yC,MAAQ,kBAAoB3yC,EAAW2yC,MAAQ,GAC1D3yC,EAAW4yC,WAAa,uBAAyB5yC,EAAW4yC,WAAa,GACzE5yC,EAAW6yC,WAAa,uBAAyB7yC,EAAW6yC,WAAa,GACzE7yC,EAAW8yC,QAAU,oBAAsB9yC,EAAW8yC,QAAU,GAChE9yC,EAAW+yC,cAAgB,0BAA4B/yC,EAAW+yC,cAAgB,GAClF/yC,EAAWgzC,UAAY,sBAAwBhzC,EAAWgzC,UAAY,GACtEhzC,EAAWizC,YAAc,wBAA0BjzC,EAAWizC,YAAc,GAC5EjzC,EAAWkzC,kBAAoB,8BAAgClzC,EAAWkzC,kBAAoB,GAE9FlzC,EAAWmzC,eAAiB,2BAA6BnzC,EAAWmzC,eAAiB,GACrFnzC,EAAWozC,eAAiB,2BAA6BpzC,EAAWozC,eAAiB,GAErFpzC,EAAWqzC,gBAAkB,4BAA8BrzC,EAAWqzC,gBAAkB,GAExFrzC,EAAWszC,eAAiB,2BAA6BtzC,EAAWszC,eAAiB,GACrFtzC,EAAWuzC,qBAAuB,kCAAoCvzC,EAAWuzC,qBAAuB,GACxGvzC,EAAWwzC,wBAA0B,qCAAuCxzC,EAAWwzC,wBAA0B,GAEjHxzC,EAAWyzC,iBAAmB,6BAA+BzzC,EAAWyzC,iBAAmB,GAC3FzzC,EAAW0zC,0BAA4B,uCAAyC1zC,EAAW0zC,0BAA4B,GAEvH1zC,EAAW2zC,gBAAkB,6BAA+B3zC,EAAW2zC,gBAAkB,GACzF3zC,EAAW4zC,oBAAsB,iCAAmC5zC,EAAW4zC,oBAAsB,GAErG5zC,EAAW6zC,cAAgB,0BAA4B7zC,EAAW6zC,cAAgB,GAClF7zC,EAAW8zC,mBAAqB,gCAAkC9zC,EAAW8zC,mBAAqB,GAClG9zC,EAAW+zC,uBAAyB,oCAAsC/zC,EAAW+zC,uBAAyB,GAE9G/zC,EAAWg0C,kBAAoB,8BAAgCh0C,EAAWg0C,kBAAoB,GAC9Fh0C,EAAWi0C,eAAiB,2BAA6Bj0C,EAAWi0C,eAAiB,GAIrFj0C,EAAWk0C,iBAA6C,IAA3Bl0C,EAAW4K,YAAwB,sBAAwB,GACxF5K,EAAW+D,aAAe,oBAAsB,GAChD/D,EAAWm0C,aAAe,0BAA4B,GACtDn0C,EAAWo0C,WAAa,kBAAoB,GAC5Cp0C,EAAWq0C,WAAa,kBAAoB,GAC5Cr0C,EAAWs0C,WAAa,kBAAoB,GAE5Ct0C,EAAWu0C,UAAY,wBAA0B,GAEjDv0C,EAAW4K,YAAc,sBAAwB,GAEjD5K,EAAWw0C,SAAW,uBAAyB,GAE/Cx0C,EAAWkkC,aAAe,2BAA6B,GACvDlkC,EAAWmkC,eAA2C,IAA3BnkC,EAAW4K,YAAwB,2BAA6B,GACzF5K,EAAWokC,aAAepkC,EAAWigB,SAAa,0BAA4B,GAC9EjgB,EAAW6jC,kBAAoB,GAAK7jC,EAAWigB,SAAa,+BAAiC,GAC7FjgB,EAAW6jC,kBAAoB,GAAK7jC,EAAWigB,SAAa,uCAAyCjgB,EAAWy0C,mBAAqB,GACrIz0C,EAAW6jC,kBAAoB,GAAK7jC,EAAWigB,SAAa,8BAAgCjgB,EAAW6jC,kBAAoB,GAC7H7jC,EAAW00C,YAAc,uBAAyB,GAClD10C,EAAW20C,UAAY,qBAAuB,GAE9C30C,EAAW40C,iBAAmB,wBAA0B,GACxD50C,EAAW40C,iBAAmB,WAAa5E,EAAsB,GAEjEhwC,EAAWoK,gBAAkB,8BAAgC,GAE7DpK,EAAW60C,gBAAkB,wBAA0B,GAEvD70C,EAAWk4B,uBAAyB,0BAA4B,GAC9Dl4B,EAAWk4B,wBAA0Bl4B,EAAWsxC,2BAA+B,8BAAgC,GAEjH,4BACA,gCACA,iCACA,2BACA,6BACA,+BACA,+BAEA,wBAEA,mCAEA,SAEA,8BAEA,kCAEA,SAEA,2BACA,yBACA,qBAEA,iBAEA,wBAEA,SAEA,iBAEA,wBAEA,SAEA,iBAEA,wBAEA,SAEA,qBAEA,4BAEA,SAEA,iCAEA,0BAEA,6BAEA,0BAEA,SAEA,2EAEA,iCACA,iCACA,iCACA,iCAEA,4BAEA,mCACA,mCACA,mCACA,mCAEA,UAEA,mCACA,mCACA,mCACA,mCAEA,WAEA,SAEA,sBAEA,8BACA,+BAEA,SAEA,MAEC3qE,OAAQsnE,IAAkBvtE,KAAM,MAElCuxE,EAAiB,CAEhBhB,EAEArB,GAAmB5vC,GAEnB,uBAAyBA,EAAWoyC,WACpC,uBAAyBpyC,EAAWqyC,WAEpCT,EAEA5xC,EAAWwyC,QAAUxyC,EAAW6K,IAAM,kBAAoB,GAC1D7K,EAAWwyC,QAAUxyC,EAAWyyC,QAAU,mBAAqB,GAE/DzyC,EAAW1/B,IAAM,kBAAoB,GACrC0/B,EAAWmI,OAAS,qBAAuB,GAC3CnI,EAAWuJ,OAAS,qBAAuB,GAC3CvJ,EAAWuJ,OAAS,WAAa4mC,EAAmB,GACpDnwC,EAAWuJ,OAAS,WAAa+mC,EAAmB,GACpDtwC,EAAWuJ,OAAS,WAAainC,EAAuB,GACxDE,EAAmB,8BAAgCA,EAAiBK,WAAa,GACjFL,EAAmB,+BAAiCA,EAAiBI,YAAc,GACnFJ,EAAmB,0BAA4BA,EAAiBG,OAAS,KAAO,GAChF7wC,EAAWqI,SAAW,uBAAyB,GAC/CrI,EAAWuI,MAAQ,oBAAsB,GACzCvI,EAAWyI,QAAU,sBAAwB,GAC7CzI,EAAW2I,UAAY,wBAA0B,GACjD3I,EAAW0yC,qBAAuB,oCAAsC,GACxE1yC,EAAWmxC,sBAAwB,qCAAuC,GAC1EnxC,EAAWmJ,YAAc,0BAA4B,GAErDnJ,EAAW1gB,WAAa,yBAA2B,GACnD0gB,EAAWkI,cAAgB,4BAA8B,GAEzDlI,EAAWsH,UAAY,wBAA0B,GACjDtH,EAAWwH,aAAe,2BAA6B,GACvDxH,EAAWyH,sBAAwB,qCAAuC,GAC1EzH,EAAW0H,mBAAqB,kCAAoC,GAEpE1H,EAAW4H,YAAc,0BAA4B,GACrD5H,EAAW+H,eAAiB,6BAA+B,GAC3D/H,EAAWgI,wBAA0B,uCAAyC,GAE9EhI,EAAWoJ,YAAc,0BAA4B,GACrDpJ,EAAWsJ,iBAAmB,gCAAkC,GAChEtJ,EAAWqJ,qBAAuB,oCAAsC,GAExErJ,EAAWiJ,aAAe,2BAA6B,GACvDjJ,EAAWkJ,aAAe,2BAA6B,GAEvDlJ,EAAWoI,SAAW,uBAAyB,GAC/CpI,EAAWmG,UAAY,wBAA0B,GACjDnG,EAAWkE,UAAY,wBAA0B,GAEjDlE,EAAW6G,MAAQ,oBAAsB,GACzC7G,EAAWuwB,cAAgB,6BAA+B,GAC1DvwB,EAAWywB,kBAAoB,iCAAmC,GAElEzwB,EAAW6J,aAAe,2BAA6B,GACvD7J,EAAW8J,gBAAkB,8BAAgC,GAC7D9J,EAAWgK,aAAe,2BAA6B,GAEvDhK,EAAWk0C,iBAA6C,IAA3Bl0C,EAAW4K,YAAwB,sBAAwB,GACxF5K,EAAW+D,cAAgB/D,EAAWuyC,gBAAkB,oBAAsB,GAC9EvyC,EAAWm0C,aAAe,0BAA4B,GACtDn0C,EAAWo0C,WAAa,kBAAoB,GAC5Cp0C,EAAWq0C,WAAa,kBAAoB,GAC5Cr0C,EAAWs0C,WAAa,kBAAoB,GAE5Ct0C,EAAWu0C,UAAY,wBAA0B,GAEjDv0C,EAAW4J,YAAc,0BAA4B,GAErD5J,EAAW4K,YAAc,sBAAwB,GAEjD5K,EAAW00C,YAAc,uBAAyB,GAClD10C,EAAW20C,UAAY,qBAAuB,GAE9C30C,EAAW40C,iBAAmB,wBAA0B,GACxD50C,EAAW40C,iBAAmB,WAAa5E,EAAsB,GAEjEhwC,EAAW+F,mBAAqB,8BAAgC,GAEhE/F,EAAW60C,gBAAkB,wBAA0B,GAEvD70C,EAAWk4B,uBAAyB,0BAA4B,GAC9Dl4B,EAAWk4B,wBAA0Bl4B,EAAWsxC,2BAA+B,8BAAgC,GAEjH,2BACA,+BACA,+BAEEtxC,EAAWob,cAAgBjxC,EAAkB,uBAAyB,GACtE61B,EAAWob,cAAgBjxC,EAAkB63C,GAAyC,0BAAI,GAC1FhiB,EAAWob,cAAgBjxC,EAAkB4jE,GAAwB,cAAe/tC,EAAWob,aAAgB,GAEjHpb,EAAW6F,UAAY,oBAAsB,GAC7C7F,EAAW80C,OAAS,iBAAmB,GAEvC9yB,GAAwC,yBACxC4rB,GAA0B,sBAAuB5tC,EAAWuX,kBAE5DvX,EAAW+0C,gBAAkB,yBAA2B/0C,EAAWg1C,aAAe,GAElF,MAECruE,OAAQsnE,IAAkBvtE,KAAM,OAInCo3C,EAAeo3B,GAAiBp3B,GAChCA,EAAeo2B,GAAkBp2B,EAAc9X,GAC/C8X,EAAeg3B,GAA0Bh3B,EAAc9X,GAEvD+X,EAAiBm3B,GAAiBn3B,GAClCA,EAAiBm2B,GAAkBn2B,EAAgB/X,GACnD+X,EAAiB+2B,GAA0B/2B,EAAgB/X,GAE3D8X,EAAe23B,GAAa33B,GAC5BC,EAAiB03B,GAAa13B,GAEzB/X,EAAWigB,WAA+C,IAAnCjgB,EAAWmyC,sBAItCD,EAAgB,oBAEhBF,EAAe,CACd,oCACA,uBACA,sBACA,6BACCtxE,KAAM,MAAS,KAAOsxE,EAExBC,EAAiB,CAChB,qBACEjyC,EAAW0Y,cAAgB3rC,GAAU,GAAK,oDAC1CizB,EAAW0Y,cAAgB3rC,GAAU,GAAK,oCAC5C,uCACA,4BACA,8BACA,oCACA,qCACA,6CACA,uCACA,uCACA,+CACA,0CACCrM,KAAM,MAAS,KAAOuxE,GAIzB,MAAMgD,EAAa/C,EAAgBF,EAAel6B,EAC5Co9B,EAAehD,EAAgBD,EAAiBl6B,EAKhDo9B,EAAiB3I,GAAazsB,EAAIA,EAAG4X,cAAesd,GACpDG,EAAmB5I,GAAazsB,EAAIA,EAAG8X,gBAAiBqd,GAqB9D,GAnBAn1B,EAAGs1B,aAAcphB,EAASkhB,GAC1Bp1B,EAAGs1B,aAAcphB,EAASmhB,QAIc53E,IAAnCwiC,EAAWwY,oBAEfuH,EAAGu1B,mBAAoBrhB,EAAS,EAAGj0B,EAAWwY,sBAEP,IAA5BxY,EAAWkkC,cAGtBnkB,EAAGu1B,mBAAoBrhB,EAAS,EAAG,YAIpClU,EAAGw1B,YAAathB,GAGX5c,EAASm+B,MAAMC,kBAAoB,CAEvC,MAAMC,EAAa31B,EAAG41B,kBAAmB1hB,GAAUkZ,OAC7CyI,EAAY71B,EAAGmtB,iBAAkBiI,GAAiBhI,OAClD0I,EAAc91B,EAAGmtB,iBAAkBkI,GAAmBjI,OAE5D,IAAI2I,GAAW,EACXC,GAAkB,EAEtB,IAA2D,IAAtDh2B,EAAGosB,oBAAqBlY,EAASlU,EAAGi2B,aAIxC,GAFAF,GAAW,EAEkC,mBAAjCz+B,EAASm+B,MAAMS,cAE1B5+B,EAASm+B,MAAMS,cAAel2B,EAAIkU,EAASkhB,EAAgBC,OAErD,CAIN,MAAMc,EAAerJ,GAAiB9sB,EAAIo1B,EAAgB,UACpDgB,EAAiBtJ,GAAiB9sB,EAAIq1B,EAAkB,YAE9Dz2E,QAAQ6+B,MACP,oCAAsCuiB,EAAGq2B,WAAzC,sBACqBr2B,EAAGosB,oBAAqBlY,EAASlU,EAAGs2B,iBADzD,yBAEuBX,EAAa,KACpCQ,EAAe,KACfC,EAGF,KAE0B,KAAfT,EAEX/2E,QAAQkU,KAAM,wCAAyC6iE,GAE9B,KAAdE,GAAoC,KAAhBC,IAE/BE,GAAkB,GAIdA,IAEJ11E,KAAKi2E,YAAc,CAElBR,SAAUA,EAEVJ,WAAYA,EAEZ59B,aAAc,CAEbl5C,IAAKg3E,EACLW,OAAQvE,GAITj6B,eAAgB,CAEfn5C,IAAKi3E,EACLU,OAAQtE,IAQZ,CAaA,IAAIuE,EAgBAnhB,EAoCJ,OAzDAtV,EAAG02B,aAActB,GACjBp1B,EAAG02B,aAAcrB,GAMjB/0E,KAAKwkE,YAAc,WAQlB,YANwBrnE,IAAnBg5E,IAEJA,EAAiB,IAAItK,GAAensB,EAAIkU,IAIlCuiB,CAER,EAMAn2E,KAAKo1D,cAAgB,WAQpB,YAN0Bj4D,IAArB63D,IAEJA,EA3zBH,SAAkCtV,EAAIkU,GAErC,MAAMjuD,EAAa,CAAC,EAEdxD,EAAIu9C,EAAGosB,oBAAqBlY,EAASlU,EAAG22B,mBAE9C,IAAM,IAAI/1E,EAAI,EAAGA,EAAI6B,EAAG7B,IAAO,CAE9B,MAAMq2D,EAAOjX,EAAG42B,gBAAiB1iB,EAAStzD,GACpCkC,EAAOm0D,EAAKn0D,KAElB,IAAIqzD,EAAe,EACdc,EAAK5pD,OAAS2yC,EAAG62B,aAAa1gB,EAAe,GAC7Cc,EAAK5pD,OAAS2yC,EAAG82B,aAAa3gB,EAAe,GAC7Cc,EAAK5pD,OAAS2yC,EAAG+2B,aAAa5gB,EAAe,GAIlDlwD,EAAYnD,GAAS,CACpBuK,KAAM4pD,EAAK5pD,KACXzP,SAAUoiD,EAAGg3B,kBAAmB9iB,EAASpxD,GACzCqzD,aAAcA,EAGhB,CAEA,OAAOlwD,CAER,CA+xBsBgxE,CAAyBj3B,EAAIkU,IAI1CoB,CAER,EAIAh1D,KAAK42E,QAAU,WAEd/jB,EAAc4D,uBAAwBz2D,MAEtC0/C,EAAGm3B,cAAejjB,GAClB5zD,KAAK4zD,aAAUz2D,CAEhB,EAIA6C,KAAK+M,KAAO4yB,EAAWoyC,WACvB/xE,KAAKwC,KAAOm9B,EAAWqyC,WACvBhyE,KAAKL,GAAK4sE,KACVvsE,KAAK0vE,SAAWA,EAChB1vE,KAAK82E,UAAY,EACjB92E,KAAK4zD,QAAUA,EACf5zD,KAAKy3C,aAAeq9B,EACpB90E,KAAK03C,eAAiBq9B,EAEf/0E,IAER,CAEA,IAAI+2E,GAAM,EAEV,MAAMC,GAELz0E,cAECvC,KAAKi3E,YAAc,IAAIjI,IACvBhvE,KAAKk3E,cAAgB,IAAIlI,GAE1B,CAEA3nE,OAAQ44B,GAEP,MAAMwX,EAAexX,EAASwX,aACxBC,EAAiBzX,EAASyX,eAE1By/B,EAAoBn3E,KAAKo3E,gBAAiB3/B,GAC1C4/B,EAAsBr3E,KAAKo3E,gBAAiB1/B,GAE5C4/B,EAAkBt3E,KAAKu3E,2BAA4Bt3C,GAgBzD,OAdkD,IAA7Cq3C,EAAgB1f,IAAKuf,KAEzBG,EAAgBt6E,IAAKm6E,GACrBA,EAAkBL,cAIiC,IAA/CQ,EAAgB1f,IAAKyf,KAEzBC,EAAgBt6E,IAAKq6E,GACrBA,EAAoBP,aAId92E,IAER,CAEA9C,OAAQ+iC,GAEP,MAAMq3C,EAAkBt3E,KAAKk3E,cAAcruE,IAAKo3B,GAEhD,IAAM,MAAMu3C,KAAeF,EAE1BE,EAAYV,YAEmB,IAA1BU,EAAYV,WAAkB92E,KAAKi3E,YAAYh3B,OAAQu3B,EAAYC,MAMzE,OAFAz3E,KAAKk3E,cAAcj3B,OAAQhgB,GAEpBjgC,IAER,CAEA03E,kBAAmBz3C,GAElB,OAAOjgC,KAAKo3E,gBAAiBn3C,EAASwX,cAAe93C,EAEtD,CAEAg4E,oBAAqB13C,GAEpB,OAAOjgC,KAAKo3E,gBAAiBn3C,EAASyX,gBAAiB/3C,EAExD,CAEA8gB,UAECzgB,KAAKi3E,YAAY55C,QACjBr9B,KAAKk3E,cAAc75C,OAEpB,CAEAk6C,2BAA4Bt3C,GAE3B,MAAMI,EAAQrgC,KAAKk3E,cACnB,IAAI3kE,EAAM8tB,EAAMx3B,IAAKo3B,GASrB,YAPa9iC,IAARoV,IAEJA,EAAM,IAAIqlE,IACVv3C,EAAM9tB,IAAK0tB,EAAU1tB,IAIfA,CAER,CAEA6kE,gBAAiBK,GAEhB,MAAMp3C,EAAQrgC,KAAKi3E,YACnB,IAAIY,EAAQx3C,EAAMx3B,IAAK4uE,GASvB,YAPet6E,IAAV06E,IAEJA,EAAQ,IAAIC,GAAkBL,GAC9Bp3C,EAAM9tB,IAAKklE,EAAMI,IAIXA,CAER,EAID,MAAMC,GAELv1E,YAAak1E,GAEZz3E,KAAKL,GAAKo3E,KAEV/2E,KAAKy3E,KAAOA,EACZz3E,KAAK82E,UAAY,CAElB,EAID,SAASiB,GAAe/gC,EAAUga,EAAUC,EAAYpZ,EAAY8H,EAAckT,EAAejb,GAEhG,MAAMogC,EAAiB,IAAI1+C,GACrB2+C,EAAiB,IAAIjB,GACrBxU,EAAW,GAEX0V,EAAYv4B,EAAaC,SACzBiY,EAAyBlY,EAAakY,uBACtCsgB,EAA2Bx4B,EAAakZ,eAE9C,IAAIzzB,EAAYua,EAAava,UAE7B,MAAMgzC,EAAY,CACjBC,kBAAmB,QACnBC,qBAAsB,eACtBC,mBAAoB,SACpBxrC,kBAAmB,QACnByrC,oBAAqB,UACrBC,kBAAmB,QACnBC,iBAAkB,OAClBC,qBAAsB,WACtBC,qBAAsB,WACtBC,mBAAoB,SACpBC,kBAAmB,QACnBC,mBAAoB,SACpBC,eAAgB,SAChBC,eAAgB,SAChBC,eAAgB,UAGjB,SAASC,EAAY/7E,GAEpB,OAAe,IAAVA,EAAqB,KAEnB,KAAMA,GAEd,CAujBA,MAAO,CACNg8E,cAtjBD,SAAwBn5C,EAAU0X,EAAQ0hC,EAASz+B,EAAOzuB,GAEzD,MAAMqe,EAAMoQ,EAAMpQ,IACZrd,EAAWhB,EAAOgB,SAClBoS,EAAcU,EAASq5C,uBAAyB1+B,EAAMrb,YAAc,KAEpE2J,GAAWjJ,EAASq5C,uBAAyBroB,EAAaD,GAAWnoD,IAAKo3B,EAASiJ,QAAU3J,GAC7FgxC,EAA0BrnC,GAAcA,EAAOxqB,UAAYpU,EAA4B4+B,EAAOvsB,MAAM/J,OAAS,KAE7Gm+D,EAAWqH,EAAWn4C,EAASlzB,MAKT,OAAvBkzB,EAASmF,YAEbA,EAAYua,EAAayX,gBAAiBn3B,EAASmF,WAE9CA,IAAcnF,EAASmF,WAE3B9mC,QAAQkU,KAAM,oCAAqCytB,EAASmF,UAAW,uBAAwBA,EAAW,aAQ5G,MAAM4K,EAAiB7iB,EAAS0hB,gBAAgBzhB,UAAYD,EAAS0hB,gBAAgBxkB,QAAU8C,EAAS0hB,gBAAgBrzB,MAClHgoD,OAAyCrmE,IAAnB6yC,EAAiCA,EAAervC,OAAS,EAErF,IAQI82C,EAAcC,EACd6hC,EAAsBC,EATtBpF,EAAqB,EAWzB,QAT2Cj3E,IAAtCgwB,EAAS0hB,gBAAgBzhB,WAAyBgnD,EAAqB,QACnCj3E,IAApCgwB,EAAS0hB,gBAAgBxkB,SAAuB+pD,EAAqB,QAClCj3E,IAAnCgwB,EAAS0hB,gBAAgBrzB,QAAsB44D,EAAqB,GAOpErD,EAAW,CAEf,MAAMt1B,EAAS4S,GAAW0iB,GAE1Bt5B,EAAegE,EAAOhE,aACtBC,EAAiB+D,EAAO/D,cAEzB,MAECD,EAAexX,EAASwX,aACxBC,EAAiBzX,EAASyX,eAE1BugC,EAAe5wE,OAAQ44B,GAEvBs5C,EAAuBtB,EAAeP,kBAAmBz3C,GACzDu5C,EAAyBvB,EAAeN,oBAAqB13C,GAI9D,MAAM4a,EAAsB7D,EAASC,kBAE/BwiC,GAA8C,IAA3BttD,EAAO8S,gBAE1By6C,IAAaz5C,EAAShgC,IACtB05E,IAAgB15C,EAAS6H,OACzB8xC,IAAgB1wC,EAChB2wC,IAAe55C,EAASiI,MACxB4xC,IAAkB75C,EAAS+H,SAC3B+xC,IAAiB95C,EAASmI,QAC1B4xC,IAAmB/5C,EAASqI,UAC5B2xC,IAAyBh6C,EAASwI,gBAClCyxC,IAAqBj6C,EAAS6I,YAE9BqxC,IAAsBl6C,EAAS4I,aAC/BuxC,IAAsBn6C,EAAS2I,aAE/ByxC,EAAiBp6C,EAAShhB,WAAa,EACvCq7D,EAAgBr6C,EAASgH,UAAY,EACrCszC,EAAkBt6C,EAASsH,YAAc,EACzCizC,EAAYv6C,EAASuG,MAAQ,EAC7Bi0C,EAAmBx6C,EAASuJ,aAAe,EAE3CkxC,EAAoBL,KAAqBp6C,EAAS4H,cAElD8yC,EAAmBL,KAAoBr6C,EAASkH,aAChDyzC,GAA0BN,KAAoBr6C,EAASoH,mBACvDwzC,GAA6BP,KAAoBr6C,EAASmH,sBAE1D0zC,GAAqBP,KAAsBt6C,EAASyH,eACpDqzC,GAA+BR,KAAsBt6C,EAAS0H,wBAE9DqzC,GAAqBR,KAAgBv6C,EAASiwB,cAC9C+qB,GAAyBT,KAAgBv6C,EAASmwB,kBAElD8qB,KAAqBj7C,EAAS8I,YAC9BoyC,KAA2Bl7C,EAASgJ,iBACpCmyC,KAA+Bn7C,EAAS+I,qBAExCqyC,GAAsBZ,KAAuBx6C,EAASwJ,gBACtD6xC,GAAmBb,KAAuBx6C,EAAS0J,aAEnD4xC,KAAqBt7C,EAASsJ,YAE9BiyC,KAAkBv7C,EAAS8H,SAE3B0zC,GAAgBx7C,EAAS6F,UAAY,EAErC41C,KAAmBz7C,EAAS4D,UAE5B83C,KAAoB17C,EAAS4X,WAE7B+jC,KAAuBzuD,EAASxnB,WAAWm8B,IAC3C+5C,KAAuB1uD,EAASxnB,WAAWo8B,IAC3C+5C,KAAuB3uD,EAASxnB,WAAWq8B,IA4LjD,MA1LmB,CAElB4d,SAAUs4B,EAEVnH,SAAUA,EACVgB,WAAY9xC,EAASlzB,KACrBilE,WAAY/xC,EAASz9B,KAErBi1C,aAAcA,EACdC,eAAgBA,EAChBH,QAAStX,EAASsX,QAElBgiC,qBAAsBA,EACtBC,uBAAwBA,EAExB1H,qBAAsD,IAAjC7xC,EAAS6xC,oBAC9Bz5B,YAAapY,EAASoY,YAEtBjT,UAAWA,EAEX6sC,WAAYwH,EACZvH,gBAAiBuH,GAA6C,OAAzBttD,EAAOgT,cAE5C48C,uBAAwB5D,EACxBjhC,iBAA4C,OAAxB2D,EAAiC7D,EAASE,kBAA8D,IAAzC2D,EAAoBmhC,iBAA4BnhC,EAAoB93B,QAAQ/G,WAAa1P,GAE5KrM,IAAKy5E,EACL5xC,OAAQ6xC,EACRzwC,OAAQ0wC,EACR7J,WAAY6J,GAAc1wC,EAAOxqB,QACjC6xD,mBAAoBA,EACpBroC,MAAO2xC,EACP7xC,SAAU8xC,EACV1xC,QAAS2xC,EACTzxC,UAAW0xC,EACXvxC,gBAAiB0vC,GAA4B8B,EAC7CnxC,YAAaoxC,EAEb7H,qBAAsB2H,GA9tnBI,IA8tnBa/5C,EAASsI,cAChDuoC,sBAAuBkJ,GAhunBI,IAgunBa/5C,EAASsI,cAEjDM,aAAcsxC,EACdvxC,aAAcwxC,EAEdn7D,WAAYo7D,EACZxyC,cAAe6yC,EAEfzzC,UAAWqzC,EACXnzC,aAAcwzC,EACdtzC,mBAAoBuzC,GACpBxzC,sBAAuByzC,GAEvBtzC,YAAagzC,EACb7yC,eAAgBozC,GAChBnzC,wBAAyBozC,GAEzBv0C,MAAOg0C,EACPtqB,cAAe8qB,GACf5qB,kBAAmB6qB,GAEnBlyC,YAAamyC,GACbjyC,iBAAkBkyC,GAClBnyC,qBAAsBoyC,GAEtB5xC,aAAcixC,EACdhxC,gBAAiB4xC,GACjB1xC,aAAc2xC,GAEd/xC,YAAagyC,GAEb9G,QAAiC,IAAzBx0C,EAAS2D,aAl4nBG,IAk4nBsB3D,EAASuD,SAEnDuE,SAAUyzC,GACV11C,UAAW21C,GACX53C,UAAW63C,GAEXvyC,QAASlJ,EAASkJ,QAIlBmpC,MAAOoH,GAAWP,EAAYl5C,EAAShgC,IAAIsf,SAC3CkzD,QAASoH,GAAaV,EAAYl5C,EAASiI,MAAM3oB,SACjDizD,WAAYsH,GAAgBX,EAAYl5C,EAAS+H,SAASzoB,SAC1DozD,UAAWoH,GAAeZ,EAAYl5C,EAASmI,QAAQ7oB,SACvDqzD,YAAaoH,GAAiBb,EAAYl5C,EAASqI,UAAU/oB,SAC7DszD,kBAAmBoH,GAAuBd,EAAYl5C,EAASwI,gBAAgBlpB,SAC/EmzD,cAAewH,GAAmBf,EAAYl5C,EAAS6I,YAAYvpB,SAEnEuzD,eAAgBqH,GAAoBhB,EAAYl5C,EAAS4I,aAAatpB,SACtEwzD,eAAgBqH,GAAoBjB,EAAYl5C,EAAS2I,aAAarpB,SAEtEyzD,gBAAiB0H,GAAqBvB,EAAYl5C,EAAS4H,cAActoB,SAEzE0zD,eAAgB0H,GAAoBxB,EAAYl5C,EAASkH,aAAa5nB,SACtE2zD,qBAAsB0H,IAA2BzB,EAAYl5C,EAASoH,mBAAmB9nB,SACzF4zD,wBAAyB0H,IAA8B1B,EAAYl5C,EAASmH,sBAAsB7nB,SAElG6zD,iBAAkB0H,IAAsB3B,EAAYl5C,EAASyH,eAAenoB,SAC5E8zD,0BAA2B0H,IAAgC5B,EAAYl5C,EAAS0H,wBAAwBpoB,SAExG+zD,gBAAiB0H,IAAsB7B,EAAYl5C,EAASiwB,cAAc3wC,SAC1Eg0D,oBAAqB0H,IAA0B9B,EAAYl5C,EAASmwB,kBAAkB7wC,SAEtFi0D,cAAe0H,IAAmB/B,EAAYl5C,EAAS8I,YAAYxpB,SACnEk0D,mBAAoB0H,IAAyBhC,EAAYl5C,EAASgJ,iBAAiB1pB,SACnFm0D,uBAAwB0H,IAA6BjC,EAAYl5C,EAAS+I,qBAAqBzpB,SAE/Fo0D,kBAAmB0H,IAAuBlC,EAAYl5C,EAASwJ,gBAAgBlqB,SAC/Eq0D,eAAgB0H,IAAoBnC,EAAYl5C,EAAS0J,aAAapqB,SAEtEgzD,WAAYiJ,IAAgBrC,EAAYl5C,EAAS8H,SAASxoB,SAI1Ds0D,iBAAmB1mD,EAASxnB,WAAWiqC,UAAaoqC,GAAiBK,GACrE32C,aAAczD,EAASyD,aACvBowC,cAAwC,IAA1B7zC,EAASyD,gBAA4BvW,EAASxnB,WAAW6V,OAAgD,IAAvC2R,EAASxnB,WAAW6V,MAAM2xB,SAC1G4mC,WAAY6H,GACZ5H,WAAY6H,GACZ5H,WAAY6H,GAEZ5H,WAA+B,IAApB/nD,EAAOuT,YAAwBvS,EAASxnB,WAAWgb,KAAQ+4D,GAAW8B,IAEjFhxC,MAAQA,EACR2nC,QAAyB,IAAjBlyC,EAASuK,IACjB4nC,QAAW5nC,GAAOA,EAAIyxC,UAEtB1xC,aAAsC,IAAzBtK,EAASsK,YAEtBR,iBAA8C,IAA7B9J,EAAS8J,gBAC1B8tB,uBAAwBA,EAExBsc,UAAmC,IAAzBhoD,EAAO0T,cAEjBgkC,kBAAoD1mE,IAAtCgwB,EAAS0hB,gBAAgBzhB,SACvC02C,kBAAkD3mE,IAApCgwB,EAAS0hB,gBAAgBxkB,OACvC05C,iBAAgD5mE,IAAnCgwB,EAAS0hB,gBAAgBrzB,MACtCgoD,kBAAmBA,EACnB4Q,mBAAoBA,EAEpBlG,aAAcv2B,EAAOukC,YAAYv7E,OACjC0tE,eAAgB12B,EAAOjrB,MAAM/rB,OAC7BwtE,cAAex2B,EAAOwkC,KAAKx7E,OAC3BqtE,iBAAkBr2B,EAAO0V,aAAa1sD,OACtCytE,kBAAmBz2B,EAAOykC,SAASz7E,OACnC2tE,cAAe32B,EAAO0kC,KAAK17E,OAE3B4tE,mBAAoB52B,EAAOmV,qBAAqBnsD,OAChD6tE,qBAAsB72B,EAAOiW,eAAejtD,OAC5CotE,oBAAqBp2B,EAAO2V,cAAc3sD,OAC1CstE,4BAA6Bt2B,EAAOs2B,4BAEpCS,kBAAmB92B,EAASsiB,UAC5ByU,oBAAqB/2B,EAASuiB,gBAE9B30B,UAAWvF,EAASuF,UAEpB+uC,iBAAkBv9B,EAASslC,UAAUzgE,SAAWw9D,EAAQ14E,OAAS,EACjEivE,cAAe54B,EAASslC,UAAUvvE,KAElCguC,YAAa9a,EAAS2F,WAAaoR,EAAS+D,YAAcjxC,EAC1D0qE,gBAAiBx9B,EAASw9B,gBAE1B9uC,mBAAoBzF,EAASyF,mBAE7B2uC,YAAap0C,EAASwD,OAASh6B,EAC/B6qE,UAt+nBc,IAs+nBHr0C,EAASwD,KAEpBixC,gBAAiBz0C,EAAS00C,cAAgB,EAC1CA,aAAc10C,EAAS00C,cAAgB,EAEvCx8B,oBAAqBlY,EAASkY,oBAE9B04B,qBAAsB8K,KAAsD,IAApC17C,EAAS4X,WAAWC,YAC5Dk5B,mBAAoB2K,KAAoD,IAAlC17C,EAAS4X,WAAWE,UAC1Dm5B,qBAAsByK,KAAsD,IAApC17C,EAAS4X,WAAWG,YAC5Do5B,0BAA2BuK,KAA2D,IAAzC17C,EAAS4X,WAAWI,iBAEjEg5B,2BAA4BiH,GAAargC,EAAW+f,IAAK,kBACzDuZ,6BAA8B+G,GAAargC,EAAW+f,IAAK,sBAC3DyZ,kCAAmC6G,GAAargC,EAAW+f,IAAK,0BAEhE3xB,sBAAuBhG,EAASgG,wBAMlC,EAsQCs2C,mBApQD,SAA6B58C,GAE5B,MAAMlyB,EAAQ,GAad,GAXKkyB,EAAWoxC,SAEftjE,EAAMhO,KAAMkgC,EAAWoxC,WAIvBtjE,EAAMhO,KAAMkgC,EAAW45C,sBACvB9rE,EAAMhO,KAAMkgC,EAAW65C,8BAIIr8E,IAAvBwiC,EAAW4X,QAEf,IAAM,MAAM/0C,KAAQm9B,EAAW4X,QAE9B9pC,EAAMhO,KAAM+C,GACZiL,EAAMhO,KAAMkgC,EAAW4X,QAAS/0C,IAgBlC,OAVwC,IAAnCm9B,EAAWmyC,sBAcjB,SAAuCrkE,EAAOkyB,GAE7ClyB,EAAMhO,KAAMkgC,EAAWyF,WACvB33B,EAAMhO,KAAMkgC,EAAWuX,kBACvBzpC,EAAMhO,KAAMkgC,EAAWowC,YACvBtiE,EAAMhO,KAAMkgC,EAAW4wC,oBACvB9iE,EAAMhO,KAAMkgC,EAAW2yC,OACvB7kE,EAAMhO,KAAMkgC,EAAW4yC,YACvB9kE,EAAMhO,KAAMkgC,EAAW6yC,YACvB/kE,EAAMhO,KAAMkgC,EAAW8yC,SACvBhlE,EAAMhO,KAAMkgC,EAAWgzC,WACvBllE,EAAMhO,KAAMkgC,EAAWizC,aACvBnlE,EAAMhO,KAAMkgC,EAAWkzC,mBACvBplE,EAAMhO,KAAMkgC,EAAW+yC,eACvBjlE,EAAMhO,KAAMkgC,EAAWmzC,gBACvBrlE,EAAMhO,KAAMkgC,EAAWozC,gBACvBtlE,EAAMhO,KAAMkgC,EAAWqzC,iBACvBvlE,EAAMhO,KAAMkgC,EAAWszC,gBACvBxlE,EAAMhO,KAAMkgC,EAAWuzC,sBACvBzlE,EAAMhO,KAAMkgC,EAAWwzC,yBACvB1lE,EAAMhO,KAAMkgC,EAAWyzC,kBACvB3lE,EAAMhO,KAAMkgC,EAAW0zC,2BACvB5lE,EAAMhO,KAAMkgC,EAAW2zC,iBACvB7lE,EAAMhO,KAAMkgC,EAAW4zC,qBACvB9lE,EAAMhO,KAAMkgC,EAAW6zC,eACvB/lE,EAAMhO,KAAMkgC,EAAW8zC,oBACvBhmE,EAAMhO,KAAMkgC,EAAW+zC,wBACvBjmE,EAAMhO,KAAMkgC,EAAWg0C,mBACvBlmE,EAAMhO,KAAMkgC,EAAWi0C,gBACvBnmE,EAAMhO,KAAMkgC,EAAWwJ,SACvB17B,EAAMhO,KAAMkgC,EAAWyyC,SACvB3kE,EAAMhO,KAAMkgC,EAAWoK,iBACvBt8B,EAAMhO,KAAMkgC,EAAW6jC,mBACvB/1D,EAAMhO,KAAMkgC,EAAW68C,qBACvB/uE,EAAMhO,KAAMkgC,EAAWuuC,cACvBzgE,EAAMhO,KAAMkgC,EAAW0uC,gBACvB5gE,EAAMhO,KAAMkgC,EAAWwuC,eACvB1gE,EAAMhO,KAAMkgC,EAAWquC,kBACvBvgE,EAAMhO,KAAMkgC,EAAW2uC,eACvB7gE,EAAMhO,KAAMkgC,EAAWyuC,mBACvB3gE,EAAMhO,KAAMkgC,EAAW4uC,oBACvB9gE,EAAMhO,KAAMkgC,EAAW6uC,sBACvB/gE,EAAMhO,KAAMkgC,EAAWouC,qBACvBtgE,EAAMhO,KAAMkgC,EAAWsuC,6BACvBxgE,EAAMhO,KAAMkgC,EAAWiwC,eACvBniE,EAAMhO,KAAMkgC,EAAWob,aACvBttC,EAAMhO,KAAMkgC,EAAW+uC,mBACvBjhE,EAAMhO,KAAMkgC,EAAWgvC,qBACvBlhE,EAAMhO,KAAMkgC,EAAWg1C,aAExB,CA9DE8H,CAA8BhvE,EAAOkyB,GAgEvC,SAAqClyB,EAAOkyB,GAE3Cq4C,EAAep+C,aAEV+F,EAAWigB,UACfo4B,EAAex+C,OAAQ,GACnBmG,EAAWo8C,wBACf/D,EAAex+C,OAAQ,GACnBmG,EAAWsyC,YACf+F,EAAex+C,OAAQ,GACnBmG,EAAWuyC,iBACf8F,EAAex+C,OAAQ,GACnBmG,EAAWmI,QACfkwC,EAAex+C,OAAQ,GACnBmG,EAAWuJ,QACf8uC,EAAex+C,OAAQ,GACnBmG,EAAW0yC,sBACf2F,EAAex+C,OAAQ,GACnBmG,EAAWmxC,uBACfkH,EAAex+C,OAAQ,GACnBmG,EAAWsH,WACf+wC,EAAex+C,OAAQ,GACnBmG,EAAW4H,aACfywC,EAAex+C,OAAQ,GACnBmG,EAAWmG,WACfkyC,EAAex+C,OAAQ,IACnBmG,EAAW+D,cACfs0C,EAAex+C,OAAQ,IACnBmG,EAAWm0C,cACfkE,EAAex+C,OAAQ,IACnBmG,EAAWo0C,YACfiE,EAAex+C,OAAQ,IACnBmG,EAAWq0C,YACfgE,EAAex+C,OAAQ,IACnBmG,EAAWs0C,YACf+D,EAAex+C,OAAQ,IACnBmG,EAAWk0C,gBACfmE,EAAex+C,OAAQ,IACnBmG,EAAW1gB,YACf+4D,EAAex+C,OAAQ,IAExB/rB,EAAMhO,KAAMu4E,EAAez+C,MAC3By+C,EAAep+C,aAEV+F,EAAW6K,KACfwtC,EAAex+C,OAAQ,GACnBmG,EAAWwyC,QACf6F,EAAex+C,OAAQ,GACnBmG,EAAW4K,aACfytC,EAAex+C,OAAQ,GACnBmG,EAAWk4B,wBACfmgB,EAAex+C,OAAQ,GACnBmG,EAAWw0C,UACf6D,EAAex+C,OAAQ,GACnBmG,EAAWkkC,cACfmU,EAAex+C,OAAQ,GACnBmG,EAAWmkC,cACfkU,EAAex+C,OAAQ,GACnBmG,EAAWokC,aACfiU,EAAex+C,OAAQ,GACnBmG,EAAW+F,oBACfsyC,EAAex+C,OAAQ,GACnBmG,EAAW40C,kBACfyD,EAAex+C,OAAQ,GACnBmG,EAAW60C,iBACfwD,EAAex+C,OAAQ,IACnBmG,EAAW00C,aACf2D,EAAex+C,OAAQ,IACnBmG,EAAW20C,WACf0D,EAAex+C,OAAQ,IACnBmG,EAAW+0C,iBACfsD,EAAex+C,OAAQ,IACnBmG,EAAW6F,WACfwyC,EAAex+C,OAAQ,IACnBmG,EAAW6J,cACfwuC,EAAex+C,OAAQ,IACnBmG,EAAW6G,OACfwxC,EAAex+C,OAAQ,IACnBmG,EAAW80C,QACfuD,EAAex+C,OAAQ,IACnBmG,EAAWu0C,WACf8D,EAAex+C,OAAQ,IAExB/rB,EAAMhO,KAAMu4E,EAAez+C,KAE5B,CApJEmjD,CAA4BjvE,EAAOkyB,GACnClyB,EAAMhO,KAAMu3C,EAASE,mBAItBzpC,EAAMhO,KAAMkgC,EAAWsG,uBAEhBx4B,EAAMpN,MAEd,EA+NCmkE,YAlFD,SAAsBvkC,GAErB,MAAM8wC,EAAWqH,EAAWn4C,EAASlzB,MACrC,IAAI8pC,EAEJ,GAAKk6B,EAAW,CAEf,MAAMt1B,EAAS4S,GAAW0iB,GAC1Bl6B,EAAWM,GAAchkC,MAAOsoC,EAAO5E,SAExC,MAECA,EAAW5W,EAAS4W,SAIrB,OAAOA,CAER,EAiEC8lC,eA/DD,SAAyBh9C,EAAY+vC,GAEpC,IAAI9b,EAGJ,IAAM,IAAIl7B,EAAI,EAAGkkD,EAAKpa,EAAS7hE,OAAQ+3B,EAAIkkD,EAAIlkD,IAAO,CAErD,MAAMmkD,EAAqBra,EAAU9pC,GAErC,GAAKmkD,EAAmBnN,WAAaA,EAAW,CAE/C9b,EAAUipB,IACPjpB,EAAQkjB,UAEX,KAED,CAED,CASA,YAPiB35E,IAAZy2D,IAEJA,EAAU,IAAI6b,GAAcz4B,EAAU04B,EAAU/vC,EAAYkzB,GAC5D2P,EAAS/iE,KAAMm0D,IAITA,CAER,EAmCCkpB,eAjCD,SAAyBlpB,GAExB,GAA8B,KAAtBA,EAAQkjB,UAAkB,CAGjC,MAAMx2E,EAAIkiE,EAASr1D,QAASymD,GAC5B4O,EAAUliE,GAAMkiE,EAAUA,EAAS7hE,OAAS,GAC5C6hE,EAASua,MAGTnpB,EAAQgjB,SAET,CAED,EAoBCoG,mBAlBD,SAA6B/8C,GAE5Bg4C,EAAe/6E,OAAQ+iC,EAExB,EAgBCuiC,SAAUA,EACV/hD,QAfD,WAECw3D,EAAex3D,SAEhB,EAcD,CAEA,SAASw8D,KAER,IAAIzwB,EAAa,IAAI1M,QAmCrB,MAAO,CACNj3C,IAlCD,SAAcsjB,GAEb,IAAIlsB,EAAMusD,EAAW3jD,IAAKsjB,GAS1B,YAPahvB,IAAR8C,IAEJA,EAAM,CAAC,EACPusD,EAAWj6C,IAAK4Z,EAAQlsB,IAIlBA,CAER,EAsBC/C,OApBD,SAAiBivB,GAEhBqgC,EAAWvM,OAAQ9zB,EAEpB,EAiBC9kB,OAfD,SAAiB8kB,EAAQpmB,EAAK3I,GAE7BovD,EAAW3jD,IAAKsjB,GAAUpmB,GAAQ3I,CAEnC,EAYCqjB,QAVD,WAEC+rC,EAAa,IAAI1M,OAElB,EASD,CAEA,SAASo9B,GAAmBz0E,EAAGiJ,GAE9B,OAAKjJ,EAAE00E,aAAezrE,EAAEyrE,WAEhB10E,EAAE00E,WAAazrE,EAAEyrE,WAEb10E,EAAEmzB,cAAgBlqB,EAAEkqB,YAExBnzB,EAAEmzB,YAAclqB,EAAEkqB,YAEdnzB,EAAEw3B,SAAStgC,KAAO+R,EAAEuuB,SAAStgC,GAEjC8I,EAAEw3B,SAAStgC,GAAK+R,EAAEuuB,SAAStgC,GAEvB8I,EAAEqY,IAAMpP,EAAEoP,EAEdrY,EAAEqY,EAAIpP,EAAEoP,EAIRrY,EAAE9I,GAAK+R,EAAE/R,EAIlB,CAEA,SAASy9E,GAA0B30E,EAAGiJ,GAErC,OAAKjJ,EAAE00E,aAAezrE,EAAEyrE,WAEhB10E,EAAE00E,WAAazrE,EAAEyrE,WAEb10E,EAAEmzB,cAAgBlqB,EAAEkqB,YAExBnzB,EAAEmzB,YAAclqB,EAAEkqB,YAEdnzB,EAAEqY,IAAMpP,EAAEoP,EAEdpP,EAAEoP,EAAIrY,EAAEqY,EAIRrY,EAAE9I,GAAK+R,EAAE/R,EAIlB,CAGA,SAAS09E,KAER,MAAMC,EAAc,GACpB,IAAIC,EAAmB,EAEvB,MAAM9I,EAAS,GACT+I,EAAe,GACf55C,EAAc,GAYpB,SAAS65C,EAAmBtxD,EAAQgB,EAAU8S,EAAUk9C,EAAYr8D,EAAGuwB,GAEtE,IAAIqsC,EAAaJ,EAAaC,GAgC9B,YA9BoBpgF,IAAfugF,GAEJA,EAAa,CACZ/9E,GAAIwsB,EAAOxsB,GACXwsB,OAAQA,EACRgB,SAAUA,EACV8S,SAAUA,EACVk9C,WAAYA,EACZvhD,YAAazP,EAAOyP,YACpB9a,EAAGA,EACHuwB,MAAOA,GAGRisC,EAAaC,GAAqBG,IAIlCA,EAAW/9E,GAAKwsB,EAAOxsB,GACvB+9E,EAAWvxD,OAASA,EACpBuxD,EAAWvwD,SAAWA,EACtBuwD,EAAWz9C,SAAWA,EACtBy9C,EAAWP,WAAaA,EACxBO,EAAW9hD,YAAczP,EAAOyP,YAChC8hD,EAAW58D,EAAIA,EACf48D,EAAWrsC,MAAQA,GAIpBksC,IAEOG,CAER,CAsEA,MAAO,CAENjJ,OAAQA,EACR+I,aAAcA,EACd55C,YAAaA,EAEbw2B,KA1HD,WAECmjB,EAAmB,EAEnB9I,EAAO9zE,OAAS,EAChB68E,EAAa78E,OAAS,EACtBijC,EAAYjjC,OAAS,CAEtB,EAmHClB,KA3ED,SAAe0sB,EAAQgB,EAAU8S,EAAUk9C,EAAYr8D,EAAGuwB,GAEzD,MAAMqsC,EAAaD,EAAmBtxD,EAAQgB,EAAU8S,EAAUk9C,EAAYr8D,EAAGuwB,GAE5EpR,EAASuJ,aAAe,EAE5Bg0C,EAAa/9E,KAAMi+E,IAEiB,IAAzBz9C,EAAS2D,YAEpBA,EAAYnkC,KAAMi+E,GAIlBjJ,EAAOh1E,KAAMi+E,EAIf,EA0DCnrB,QAxDD,SAAkBpmC,EAAQgB,EAAU8S,EAAUk9C,EAAYr8D,EAAGuwB,GAE5D,MAAMqsC,EAAaD,EAAmBtxD,EAAQgB,EAAU8S,EAAUk9C,EAAYr8D,EAAGuwB,GAE5EpR,EAASuJ,aAAe,EAE5Bg0C,EAAajrB,QAASmrB,IAEc,IAAzBz9C,EAAS2D,YAEpBA,EAAY2uB,QAASmrB,GAIrBjJ,EAAOliB,QAASmrB,EAIlB,EAuCCC,OA7BD,WAIC,IAAM,IAAIr9E,EAAIi9E,EAAkB9xD,EAAK6xD,EAAY38E,OAAQL,EAAImrB,EAAInrB,IAAO,CAEvE,MAAMo9E,EAAaJ,EAAah9E,GAEhC,GAAuB,OAAlBo9E,EAAW/9E,GAAc,MAE9B+9E,EAAW/9E,GAAK,KAChB+9E,EAAWvxD,OAAS,KACpBuxD,EAAWvwD,SAAW,KACtBuwD,EAAWz9C,SAAW,KACtBy9C,EAAWrsC,MAAQ,IAEpB,CAED,EAaCszB,KAvCD,SAAeiZ,EAAkBC,GAE3BpJ,EAAO9zE,OAAS,GAAI8zE,EAAO9P,KAAMiZ,GAAoBV,IACrDM,EAAa78E,OAAS,GAAI68E,EAAa7Y,KAAMkZ,GAAyBT,IACtEx5C,EAAYjjC,OAAS,GAAIijC,EAAY+gC,KAAMkZ,GAAyBT,GAE1E,EAoCD,CAEA,SAASU,KAER,IAAIC,EAAQ,IAAIj+B,QAqChB,MAAO,CACNj3C,IApCD,SAAc+xC,EAAOojC,GAEpB,MAAMC,EAAYF,EAAMl1E,IAAK+xC,GAC7B,IAAI96C,EAsBJ,YApBmB3C,IAAd8gF,GAEJn+E,EAAO,IAAIu9E,GACXU,EAAMxrE,IAAKqoC,EAAO,CAAE96C,KAIfk+E,GAAmBC,EAAUt9E,QAEjCb,EAAO,IAAIu9E,GACXY,EAAUx+E,KAAMK,IAIhBA,EAAOm+E,EAAWD,GAMbl+E,CAER,EAUC2gB,QARD,WAECs9D,EAAQ,IAAIj+B,OAEb,EAOD,CAEA,SAASo+B,KAER,MAAMvmC,EAAS,CAAC,EAEhB,MAAO,CAEN9uC,IAAK,SAAWs1E,GAEf,QAA4BhhF,IAAvBw6C,EAAQwmC,EAAMx+E,IAElB,OAAOg4C,EAAQwmC,EAAMx+E,IAItB,IAAIk3C,EAEJ,OAASsnC,EAAMpxE,MAEd,IAAK,mBACJ8pC,EAAW,CACVjmB,UAAW,IAAI,GACfpV,MAAO,IAAIuvB,IAEZ,MAED,IAAK,YACJ8L,EAAW,CACVzpB,SAAU,IAAI,GACdwD,UAAW,IAAI,GACfpV,MAAO,IAAIuvB,GACXrO,SAAU,EACVuwB,QAAS,EACTC,YAAa,EACbC,MAAO,GAER,MAED,IAAK,aACJtW,EAAW,CACVzpB,SAAU,IAAI,GACd5R,MAAO,IAAIuvB,GACXrO,SAAU,EACVywB,MAAO,GAER,MAED,IAAK,kBACJtW,EAAW,CACVjmB,UAAW,IAAI,GACfm9B,SAAU,IAAIhjB,GACdijB,YAAa,IAAIjjB,IAElB,MAED,IAAK,gBACJ8L,EAAW,CACVr7B,MAAO,IAAIuvB,GACX3d,SAAU,IAAI,GACdgxD,UAAW,IAAI,GACfC,WAAY,IAAI,IAQnB,OAFA1mC,EAAQwmC,EAAMx+E,IAAOk3C,EAEdA,CAER,EAIF,CAiEA,IAAIynC,GAAc,EAElB,SAASC,GAAsCC,EAAQC,GAEtD,OAASA,EAAOhjD,WAAa,EAAI,IAAQ+iD,EAAO/iD,WAAa,EAAI,IAAQgjD,EAAOx+E,IAAM,EAAI,IAAQu+E,EAAOv+E,IAAM,EAAI,EAEpH,CAEA,SAASy+E,GAAa7mC,EAAY8H,GAEjC,MAAMtf,EAAQ,IAAI69C,GAEZS,EA3EP,WAEC,MAAMhnC,EAAS,CAAC,EAEhB,MAAO,CAEN9uC,IAAK,SAAWs1E,GAEf,QAA4BhhF,IAAvBw6C,EAAQwmC,EAAMx+E,IAElB,OAAOg4C,EAAQwmC,EAAMx+E,IAItB,IAAIk3C,EAEJ,OAASsnC,EAAMpxE,MAEd,IAAK,mBASL,IAAK,YACJ8pC,EAAW,CACV6V,WAAY,EACZC,iBAAkB,EAClBC,aAAc,EACdC,cAAe,IAAIp6C,IAEpB,MAED,IAAK,aACJokC,EAAW,CACV6V,WAAY,EACZC,iBAAkB,EAClBC,aAAc,EACdC,cAAe,IAAIp6C,GACnBi7C,iBAAkB,EAClBC,gBAAiB,KAUpB,OAFAhW,EAAQwmC,EAAMx+E,IAAOk3C,EAEdA,CAER,EAIF,CAgBqB+nC,GAEd1tB,EAAQ,CAEbrzC,QAAS,EAET9Z,KAAM,CACL86E,mBAAqB,EACrBC,aAAe,EACfC,YAAc,EACdC,gBAAkB,EAClBC,YAAc,EAEdC,uBAAyB,EACzBC,iBAAmB,EACnBC,gBAAkB,EAClBC,aAAe,GAGhBC,QAAS,CAAE,EAAG,EAAG,GACjBC,MAAO,GACPrD,YAAa,GACbsD,kBAAmB,GACnB1yB,qBAAsB,GACtBC,wBAAyB,GACzBovB,KAAM,GACN9uB,aAAc,GACdoyB,WAAY,GACZnyB,cAAe,GACfC,gBAAiB,GACjB6uB,SAAU,GACVsD,aAAc,KACdC,aAAc,KACdjzD,MAAO,GACPkzD,YAAa,GACbhyB,eAAgB,GAChBC,kBAAmB,GACnBwuB,KAAM,GACNpO,4BAA6B,GAI9B,IAAM,IAAI3tE,EAAI,EAAGA,EAAI,EAAGA,IAAO4wD,EAAMquB,MAAM9/E,KAAM,IAAI,IAErD,MAAMogF,EAAU,IAAI,GACdnmE,EAAU,IAAI+Z,GACdqsD,EAAW,IAAIrsD,GAsWrB,MAAO,CACNghC,MArWD,SAAgB9c,EAAQ68B,GAEvB,IAAIxrE,EAAI,EAAG+P,EAAI,EAAGrH,EAAI,EAEtB,IAAM,IAAIpR,EAAI,EAAGA,EAAI,EAAGA,IAAO4wD,EAAMquB,MAAOj/E,GAAIiS,IAAK,EAAG,EAAG,GAE3D,IAAIssE,EAAoB,EACpBC,EAAc,EACdC,EAAa,EACbC,EAAiB,EACjBC,EAAa,EAEbC,EAAwB,EACxBC,EAAkB,EAClBC,EAAiB,EACjBC,EAAc,EACdU,EAAyB,EAG7BpoC,EAAOgtB,KAAM4Z,IAGb,MAAMyB,GAAoC,IAApBxL,EAA6Bx2E,KAAKI,GAAK,EAE7D,IAAM,IAAIkC,EAAI,EAAGoN,EAAIiqC,EAAOh3C,OAAQL,EAAIoN,EAAGpN,IAAO,CAEjD,MAAM69E,EAAQxmC,EAAQr3C,GAEhBkb,EAAQ2iE,EAAM3iE,MACdykE,EAAY9B,EAAM8B,UAClBvjD,EAAWyhD,EAAMzhD,SAEjB4/C,EAAc6B,EAAM1uB,QAAU0uB,EAAM1uB,OAAOxvD,IAAQk+E,EAAM1uB,OAAOxvD,IAAI8iB,QAAU,KAEpF,GAAKo7D,EAAM+B,eAEVl3E,GAAKwS,EAAMxS,EAAIi3E,EAAYD,EAC3BjnE,GAAKyC,EAAMzC,EAAIknE,EAAYD,EAC3BtuE,GAAK8J,EAAM9J,EAAIuuE,EAAYD,OAErB,GAAK7B,EAAMgC,aAEjB,IAAM,IAAI/wD,EAAI,EAAGA,EAAI,EAAGA,IAEvB8hC,EAAMquB,MAAOnwD,GAAI5b,gBAAiB2qE,EAAMiC,GAAGC,aAAcjxD,GAAK6wD,QAIzD,GAAK9B,EAAMmC,mBAAqB,CAEtC,MAAMzpC,EAAWxW,EAAMx3B,IAAKs1E,GAI5B,GAFAtnC,EAASr7B,MAAMpI,KAAM+qE,EAAM3iE,OAAQ3H,eAAgBsqE,EAAM8B,UAAYD,GAEhE7B,EAAM1iD,WAAa,CAEvB,MAAMg0B,EAAS0uB,EAAM1uB,OAEf8wB,EAAiB5B,EAAY91E,IAAKs1E,GAExCoC,EAAe7zB,WAAa+C,EAAO+wB,KACnCD,EAAe5zB,iBAAmB8C,EAAOgxB,WACzCF,EAAe3zB,aAAe6C,EAAOhlC,OACrC81D,EAAe1zB,cAAgB4C,EAAOixB,QAEtCxvB,EAAMsuB,kBAAmBX,GAAsB0B,EAC/CrvB,EAAMpE,qBAAsB+xB,GAAsBvC,EAClDprB,EAAMnE,wBAAyB8xB,GAAsBV,EAAM1uB,OAAO90C,OAElEukE,GAED,CAEAhuB,EAAMgrB,YAAa2C,GAAsBhoC,EAEzCgoC,GAED,MAAO,GAAKV,EAAMwC,YAAc,CAE/B,MAAM9pC,EAAWxW,EAAMx3B,IAAKs1E,GAE5BtnC,EAASzpB,SAAStC,sBAAuBqzD,EAAM50D,aAE/CstB,EAASr7B,MAAMpI,KAAMoI,GAAQ3H,eAAgBosE,EAAYD,GACzDnpC,EAASna,SAAWA,EAEpBma,EAASoW,QAAUjvD,KAAK6T,IAAKssE,EAAMvpE,OACnCiiC,EAASqW,YAAclvD,KAAK6T,IAAKssE,EAAMvpE,OAAU,EAAIupE,EAAMyC,WAC3D/pC,EAASsW,MAAQgxB,EAAMhxB,MAEvB+D,EAAMirB,KAAM4C,GAAeloC,EAE3B,MAAM4Y,EAAS0uB,EAAM1uB,OAiBrB,GAfK0uB,EAAMl+E,MAEVixD,EAAM7D,aAAcgyB,GAAgBlB,EAAMl+E,IAC1Co/E,IAIA5vB,EAAOoxB,eAAgB1C,GAElBA,EAAM1iD,YAAaskD,KAIzB7uB,EAAM3D,gBAAiBwxB,GAAetvB,EAAO90C,OAExCwjE,EAAM1iD,WAAa,CAEvB,MAAM8kD,EAAiB5B,EAAY91E,IAAKs1E,GAExCoC,EAAe7zB,WAAa+C,EAAO+wB,KACnCD,EAAe5zB,iBAAmB8C,EAAOgxB,WACzCF,EAAe3zB,aAAe6C,EAAOhlC,OACrC81D,EAAe1zB,cAAgB4C,EAAOixB,QAEtCxvB,EAAMuuB,WAAYV,GAAewB,EACjCrvB,EAAM5D,cAAeyxB,GAAezC,EAEpC8C,GAED,CAEAL,GAED,MAAO,GAAKZ,EAAM2C,gBAAkB,CAEnC,MAAMjqC,EAAWxW,EAAMx3B,IAAKs1E,GAE5BtnC,EAASr7B,MAAMpI,KAAMoI,GAAQ3H,eAAgBosE,GAE7CppC,EAASunC,UAAU7rE,IAAmB,GAAd4rE,EAAMxrE,MAAa,EAAK,GAChDkkC,EAASwnC,WAAW9rE,IAAK,EAAoB,GAAf4rE,EAAMvrE,OAAc,GAElDs+C,EAAMkrB,SAAU4C,GAAmBnoC,EAEnCmoC,GAED,MAAO,GAAKb,EAAM4C,aAAe,CAEhC,MAAMlqC,EAAWxW,EAAMx3B,IAAKs1E,GAM5B,GAJAtnC,EAASr7B,MAAMpI,KAAM+qE,EAAM3iE,OAAQ3H,eAAgBsqE,EAAM8B,UAAYD,GACrEnpC,EAASna,SAAWyhD,EAAMzhD,SAC1Bma,EAASsW,MAAQgxB,EAAMhxB,MAElBgxB,EAAM1iD,WAAa,CAEvB,MAAMg0B,EAAS0uB,EAAM1uB,OAEf8wB,EAAiB5B,EAAY91E,IAAKs1E,GAExCoC,EAAe7zB,WAAa+C,EAAO+wB,KACnCD,EAAe5zB,iBAAmB8C,EAAOgxB,WACzCF,EAAe3zB,aAAe6C,EAAOhlC,OACrC81D,EAAe1zB,cAAgB4C,EAAOixB,QACtCH,EAAe7yB,iBAAmB+B,EAAOvmC,OAAOoP,KAChDioD,EAAe5yB,gBAAkB8B,EAAOvmC,OAAOqP,IAE/C24B,EAAM0uB,YAAad,GAAgByB,EACnCrvB,EAAMtD,eAAgBkxB,GAAgBxC,EACtCprB,EAAMrD,kBAAmBixB,GAAgBX,EAAM1uB,OAAO90C,OAEtDwkE,GAED,CAEAjuB,EAAMxkC,MAAOoyD,GAAgBjoC,EAE7BioC,GAED,MAAO,GAAKX,EAAM6C,kBAAoB,CAErC,MAAMnqC,EAAWxW,EAAMx3B,IAAKs1E,GAE5BtnC,EAASkX,SAAS36C,KAAM+qE,EAAM3iE,OAAQ3H,eAAgBosE,EAAYD,GAClEnpC,EAASmX,YAAY56C,KAAM+qE,EAAMnwB,aAAcn6C,eAAgBosE,EAAYD,GAE3E9uB,EAAMmrB,KAAM4C,GAAepoC,EAE3BooC,GAED,CAED,CAEKD,EAAiB,IAEhBr/B,EAAaC,WAWqC,IAAjD/H,EAAW+f,IAAK,6BAPrB1G,EAAMwuB,aAAen1B,GAAY02B,YACjC/vB,EAAMyuB,aAAep1B,GAAY22B,cAWiC,IAAtDrpC,EAAW+f,IAAK,kCAE3B1G,EAAMwuB,aAAen1B,GAAY42B,WACjCjwB,EAAMyuB,aAAep1B,GAAY62B,YAIjC9iF,QAAQ6+B,MAAO,gFAQlB+zB,EAAMouB,QAAS,GAAMt2E,EACrBkoD,EAAMouB,QAAS,GAAMvmE,EACrBm4C,EAAMouB,QAAS,GAAM5tE,EAErB,MAAM3N,EAAOmtD,EAAMntD,KAEdA,EAAK86E,oBAAsBA,GAC/B96E,EAAK+6E,cAAgBA,GACrB/6E,EAAKg7E,aAAeA,GACpBh7E,EAAKi7E,iBAAmBA,GACxBj7E,EAAKk7E,aAAeA,GACpBl7E,EAAKm7E,wBAA0BA,GAC/Bn7E,EAAKo7E,kBAAoBA,GACzBp7E,EAAKq7E,iBAAmBA,GACxBr7E,EAAKs7E,cAAgBA,IAErBnuB,EAAMgrB,YAAYv7E,OAASk+E,EAC3B3tB,EAAMirB,KAAKx7E,OAASo+E,EACpB7tB,EAAMkrB,SAASz7E,OAASq+E,EACxB9tB,EAAMxkC,MAAM/rB,OAASm+E,EACrB5tB,EAAMmrB,KAAK17E,OAASs+E,EAEpB/tB,EAAMsuB,kBAAkB7+E,OAASu+E,EACjChuB,EAAMpE,qBAAqBnsD,OAASu+E,EACpChuB,EAAM0uB,YAAYj/E,OAASw+E,EAC3BjuB,EAAMtD,eAAejtD,OAASw+E,EAC9BjuB,EAAMuuB,WAAW9+E,OAASy+E,EAC1BluB,EAAM5D,cAAc3sD,OAASy+E,EAC7BluB,EAAMnE,wBAAwBpsD,OAASu+E,EACvChuB,EAAMrD,kBAAkBltD,OAASw+E,EACjCjuB,EAAM3D,gBAAgB5sD,OAASy+E,EAAiBC,EAAcU,EAC9D7uB,EAAM7D,aAAa1sD,OAAS0+E,EAC5BnuB,EAAM+c,4BAA8B8R,EAEpCh8E,EAAK86E,kBAAoBA,EACzB96E,EAAK+6E,YAAcA,EACnB/6E,EAAKg7E,WAAaA,EAClBh7E,EAAKi7E,eAAiBA,EACtBj7E,EAAKk7E,WAAaA,EAElBl7E,EAAKm7E,sBAAwBA,EAC7Bn7E,EAAKo7E,gBAAkBA,EACvBp7E,EAAKq7E,eAAiBA,EACtBr7E,EAAKs7E,YAAcA,EAEnBnuB,EAAMrzC,QAAUygE,KAIlB,EAwFC+C,UAtFD,SAAoB1pC,EAAQzuB,GAE3B,IAAI21D,EAAoB,EACpBC,EAAc,EACdC,EAAa,EACbC,EAAiB,EACjBC,EAAa,EAEjB,MAAMjlB,EAAa9wC,EAAOC,mBAE1B,IAAM,IAAI7oB,EAAI,EAAGoN,EAAIiqC,EAAOh3C,OAAQL,EAAIoN,EAAGpN,IAAO,CAEjD,MAAM69E,EAAQxmC,EAAQr3C,GAEtB,GAAK69E,EAAMmC,mBAAqB,CAE/B,MAAMzpC,EAAWqa,EAAMgrB,YAAa2C,GAEpChoC,EAASjmB,UAAU9F,sBAAuBqzD,EAAM50D,aAChDs2D,EAAQ/0D,sBAAuBqzD,EAAM/5E,OAAOmlB,aAC5CstB,EAASjmB,UAAUnd,IAAKosE,GACxBhpC,EAASjmB,UAAUpH,mBAAoBwwC,GAEvC6kB,GAED,MAAO,GAAKV,EAAMwC,YAAc,CAE/B,MAAM9pC,EAAWqa,EAAMirB,KAAM4C,GAE7BloC,EAASzpB,SAAStC,sBAAuBqzD,EAAM50D,aAC/CstB,EAASzpB,SAASjM,aAAc64C,GAEhCnjB,EAASjmB,UAAU9F,sBAAuBqzD,EAAM50D,aAChDs2D,EAAQ/0D,sBAAuBqzD,EAAM/5E,OAAOmlB,aAC5CstB,EAASjmB,UAAUnd,IAAKosE,GACxBhpC,EAASjmB,UAAUpH,mBAAoBwwC,GAEvC+kB,GAED,MAAO,GAAKZ,EAAM2C,gBAAkB,CAEnC,MAAMjqC,EAAWqa,EAAMkrB,SAAU4C,GAEjCnoC,EAASzpB,SAAStC,sBAAuBqzD,EAAM50D,aAC/CstB,EAASzpB,SAASjM,aAAc64C,GAGhC8lB,EAAS/oE,WACT2C,EAAQtG,KAAM+qE,EAAM50D,aACpB7P,EAAQlC,YAAawiD,GACrB8lB,EAASzrD,gBAAiB3a,GAE1Bm9B,EAASunC,UAAU7rE,IAAmB,GAAd4rE,EAAMxrE,MAAa,EAAK,GAChDkkC,EAASwnC,WAAW9rE,IAAK,EAAoB,GAAf4rE,EAAMvrE,OAAc,GAElDikC,EAASunC,UAAUj9D,aAAc2+D,GACjCjpC,EAASwnC,WAAWl9D,aAAc2+D,GAElCd,GAED,MAAO,GAAKb,EAAM4C,aAAe,CAEhC,MAAMlqC,EAAWqa,EAAMxkC,MAAOoyD,GAE9BjoC,EAASzpB,SAAStC,sBAAuBqzD,EAAM50D,aAC/CstB,EAASzpB,SAASjM,aAAc64C,GAEhC8kB,GAED,MAAO,GAAKX,EAAM6C,kBAAoB,CAErC,MAAMnqC,EAAWqa,EAAMmrB,KAAM4C,GAE7BpoC,EAASjmB,UAAU9F,sBAAuBqzD,EAAM50D,aAChDstB,EAASjmB,UAAUpH,mBAAoBwwC,GAEvCilB,GAED,CAED,CAED,EAKC/tB,MAAOA,EAGT,CAEA,SAASowB,GAAkBzpC,EAAY8H,GAEtC,MAAMhI,EAAS,IAAI+mC,GAAa7mC,EAAY8H,GAEtC4hC,EAAc,GACdC,EAAe,GAwCrB,MAAO,CACNpnB,KAvCD,WAECmnB,EAAY5gF,OAAS,EACrB6gF,EAAa7gF,OAAS,CAEvB,EAmCCuwD,MATa,CACbqwB,YAAaA,EACbC,aAAcA,EAEd7pC,OAAQA,GAMR8pC,YAtBD,SAAsBjN,GAErB78B,EAAO8c,MAAO8sB,EAAa/M,EAE5B,EAmBCkN,gBAjBD,SAA0Bx4D,GAEzByuB,EAAO0pC,UAAWE,EAAar4D,EAEhC,EAeCy4D,UArCD,SAAoBxD,GAEnBoD,EAAY9hF,KAAM0+E,EAEnB,EAkCCyD,WAhCD,SAAqBC,GAEpBL,EAAa/hF,KAAMoiF,EAEpB,EA+BD,CAEA,SAASC,GAAmBjqC,EAAY8H,GAEvC,IAAIoiC,EAAe,IAAIjiC,QAqCvB,MAAO,CACNj3C,IApCD,SAAc+xC,EAAOojC,EAAkB,GAEtC,MAAMgE,EAAmBD,EAAal5E,IAAK+xC,GAC3C,IAAIqnC,EAsBJ,YApB0B9kF,IAArB6kF,GAEJC,EAAc,IAAIX,GAAkBzpC,EAAY8H,GAChDoiC,EAAaxvE,IAAKqoC,EAAO,CAAEqnC,KAItBjE,GAAmBgE,EAAiBrhF,QAExCshF,EAAc,IAAIX,GAAkBzpC,EAAY8H,GAChDqiC,EAAiBviF,KAAMwiF,IAIvBA,EAAcD,EAAkBhE,GAM3BiE,CAER,EAUCxhE,QARD,WAECshE,EAAe,IAAIjiC,OAEpB,EAOD,CAEA,MAAMu4B,WAA0B/0C,GAE/B/gC,YAAao9B,GAEZvgB,QAEApf,KAAKkiF,qBAAsB,EAE3BliF,KAAK+M,KAAO,oBAEZ/M,KAAK20E,aAtkqBmB,KAwkqBxB30E,KAAKC,IAAM,KAEXD,KAAK+nC,SAAW,KAEhB/nC,KAAKyoC,gBAAkB,KACvBzoC,KAAK0oC,kBAAoB,EACzB1oC,KAAK2oC,iBAAmB,EAExB3oC,KAAKmqC,WAAY,EACjBnqC,KAAKoqC,mBAAqB,EAE1BpqC,KAAKkmC,UAAWvG,EAEjB,CAEAvsB,KAAM3P,GAiBL,OAfA2b,MAAMhM,KAAM3P,GAEZzD,KAAK20E,aAAelxE,EAAOkxE,aAE3B30E,KAAKC,IAAMwD,EAAOxD,IAElBD,KAAK+nC,SAAWtkC,EAAOskC,SAEvB/nC,KAAKyoC,gBAAkBhlC,EAAOglC,gBAC9BzoC,KAAK0oC,kBAAoBjlC,EAAOilC,kBAChC1oC,KAAK2oC,iBAAmBllC,EAAOklC,iBAE/B3oC,KAAKmqC,UAAY1mC,EAAO0mC,UACxBnqC,KAAKoqC,mBAAqB3mC,EAAO2mC,mBAE1BpqC,IAER,EAID,MAAMs4E,WAA6Bh1C,GAElC/gC,YAAao9B,GAEZvgB,QAEApf,KAAKmiF,wBAAyB,EAE9BniF,KAAK+M,KAAO,uBAEZ/M,KAAKC,IAAM,KAEXD,KAAK+nC,SAAW,KAEhB/nC,KAAKyoC,gBAAkB,KACvBzoC,KAAK0oC,kBAAoB,EACzB1oC,KAAK2oC,iBAAmB,EAExB3oC,KAAKkmC,UAAWvG,EAEjB,CAEAvsB,KAAM3P,GAYL,OAVA2b,MAAMhM,KAAM3P,GAEZzD,KAAKC,IAAMwD,EAAOxD,IAElBD,KAAK+nC,SAAWtkC,EAAOskC,SAEvB/nC,KAAKyoC,gBAAkBhlC,EAAOglC,gBAC9BzoC,KAAK0oC,kBAAoBjlC,EAAOilC,kBAChC1oC,KAAK2oC,iBAAmBllC,EAAOklC,iBAExB3oC,IAER,EAQD,SAASoiF,GAAgBrmB,EAAWsmB,EAAUC,GAE7C,IAAIC,EAAW,IAAIplC,GAEnB,MAAMqlC,EAAiB,IAAI/vE,GAC1BgwE,EAAgB,IAAIhwE,GAEpBiwE,EAAY,IAAI7hE,GAEhB8hE,EAAiB,IAAItK,GAAmB,CAAE1D,aAlqqBnB,OAmqqBvBiO,EAAoB,IAAItK,GAExBuK,EAAiB,CAAC,EAElBC,EAAkBR,EAAcpqB,eAE3BhzB,EAAa,CAAE,CAAE17B,GA/yqBP,EA+yqB8B,EAAcA,EAAW,CAAEC,GAAcA,GAEjFs5E,EAAyB,IAAI1rC,GAAgB,CAClDE,QAAS,CACRyrC,YAAa,GAEdnsC,SAAU,CACTosC,YAAa,CAAE7lF,MAAO,MACtB8lF,WAAY,CAAE9lF,MAAO,IAAIqV,IACzBgY,OAAQ,CAAErtB,MAAO,IAGlBq6C,aAhCa,2DAiCbC,eA/Be,omCAmCVyrC,EAA2BJ,EAAuB5vE,QACxDgwE,EAAyB5rC,QAAQ6rC,gBAAkB,EAEnD,MAAMC,EAAgB,IAAI,GAC1BA,EAAcpmF,aACb,WACA,IAAI,GACH,IAAIkS,aAAc,EAAI,GAAK,EAAG,GAAK,GAAK,EAAG,IAAO,EAAG,EAAG,KACxD,IAIF,MAAMm0E,EAAiB,IAAItvC,GAAMqvC,EAAeN,GAE1CvtC,EAAQx1C,KAEdA,KAAK6b,SAAU,EAEf7b,KAAKujF,YAAa,EAClBvjF,KAAK8d,aAAc,EAEnB9d,KAAK+M,KAAO1D,EACZ,IAAIm6E,EAAgBxjF,KAAK+M,KAqIzB,SAAS02E,EAASh0B,EAAQvmC,GAEzB,MAAMiE,EAAWk1D,EAASh7E,OAAQi8E,GAE7BP,EAAuBxrC,QAAQyrC,cAAgBvzB,EAAOi0B,cAE1DX,EAAuBxrC,QAAQyrC,YAAcvzB,EAAOi0B,YACpDP,EAAyB5rC,QAAQyrC,YAAcvzB,EAAOi0B,YAEtDX,EAAuBjlE,aAAc,EACrCqlE,EAAyBrlE,aAAc,GAIhB,OAAnB2xC,EAAOk0B,UAEXl0B,EAAOk0B,QAAU,IAAIlhE,GAAmB+/D,EAAelmF,EAAGkmF,EAAehmF,IAM1EumF,EAAuBlsC,SAASosC,YAAY7lF,MAAQqyD,EAAOxvD,IAAI8iB,QAC/DggE,EAAuBlsC,SAASqsC,WAAW9lF,MAAQqyD,EAAOixB,QAC1DqC,EAAuBlsC,SAASpsB,OAAOrtB,MAAQqyD,EAAOhlC,OACtDsxC,EAAU7gB,gBAAiBuU,EAAOk0B,SAClC5nB,EAAU1+B,QACV0+B,EAAU6nB,mBAAoB16D,EAAQ,KAAMiE,EAAU41D,EAAwBO,EAAgB,MAI9FH,EAAyBtsC,SAASosC,YAAY7lF,MAAQqyD,EAAOk0B,QAAQ5gE,QACrEogE,EAAyBtsC,SAASqsC,WAAW9lF,MAAQqyD,EAAOixB,QAC5DyC,EAAyBtsC,SAASpsB,OAAOrtB,MAAQqyD,EAAOhlC,OACxDsxC,EAAU7gB,gBAAiBuU,EAAOxvD,KAClC87D,EAAU1+B,QACV0+B,EAAU6nB,mBAAoB16D,EAAQ,KAAMiE,EAAUg2D,EAA0BG,EAAgB,KAEjG,CAEA,SAASO,EAAkB13D,EAAQ8T,EAAUk+C,EAAOpxE,GAEnD,IAAInI,EAAS,KAEb,MAAMk/E,GAA0C,IAAvB3F,EAAM4C,aAA0B50D,EAAO43D,uBAAyB53D,EAAO63D,oBAEhG,QAAwB7mF,IAAnB2mF,EAEJl/E,EAASk/E,OAMT,GAFAl/E,GAAkC,IAAvBu5E,EAAM4C,aAA0B6B,EAAoBD,EAExD5mB,EAAUxC,uBAAiD,IAAzBt5B,EAASgF,aAAwBhkC,MAAME,QAAS8+B,EAAS8E,iBAAuD,IAAnC9E,EAAS8E,eAAepkC,QAC3Is/B,EAASwI,iBAAkD,IAA/BxI,EAASyI,mBACrCzI,EAAS8H,UAAY9H,EAAS6F,UAAY,GAC1C7F,EAAShgC,KAAOggC,EAAS6F,UAAY,EAAM,CAK7C,MAAMm+C,EAAOr/E,EAAOgZ,KAAMsmE,EAAOjkD,EAASriB,KAE1C,IAAIumE,EAAsBtB,EAAgBoB,QAEb9mF,IAAxBgnF,IAEJA,EAAsB,CAAC,EACvBtB,EAAgBoB,GAASE,GAI1B,IAAIC,EAAiBD,EAAqBD,QAElB/mF,IAAnBinF,IAEJA,EAAiBx/E,EAAOuO,QACxBgxE,EAAqBD,GAASE,GAI/Bx/E,EAASw/E,CAEV,CAuCD,OAnCAx/E,EAAO42B,QAAUyE,EAASzE,QAC1B52B,EAAOulC,UAAYlK,EAASkK,UAI3BvlC,EAAO6+B,KAFH12B,IAASxD,EAE2B,OAAxB02B,EAASiF,WAAwBjF,EAASiF,WAAajF,EAASwD,KAIxC,OAAxBxD,EAASiF,WAAwBjF,EAASiF,WAAaA,EAAYjF,EAASwD,MAI7F7+B,EAAOmjC,SAAW9H,EAAS8H,SAC3BnjC,EAAOkhC,UAAY7F,EAAS6F,UAC5BlhC,EAAO3E,IAAMggC,EAAShgC,IAEtB2E,EAAOqgC,YAAchF,EAASgF,YAC9BrgC,EAAOmgC,eAAiB9E,EAAS8E,eACjCngC,EAAOogC,iBAAmB/E,EAAS+E,iBAEnCpgC,EAAO6jC,gBAAkBxI,EAASwI,gBAClC7jC,EAAO8jC,kBAAoBzI,EAASyI,kBACpC9jC,EAAO+jC,iBAAmB1I,EAAS0I,iBAEnC/jC,EAAOwlC,mBAAqBnK,EAASmK,mBACrCxlC,EAAOolC,UAAY/J,EAAS+J,WAEA,IAAvBm0C,EAAM4C,eAA2D,IAAlCn8E,EAAOu9E,yBAEfpmB,EAAUvP,WAAW3jD,IAAKjE,GAClCu5E,MAAQA,GAIrBv5E,CAER,CAEA,SAASy/E,EAAcl4D,EAAQjD,EAAQo7D,EAAcnG,EAAOpxE,GAE3D,IAAwB,IAAnBof,EAAOqP,QAAoB,OAIhC,GAFgBrP,EAAO0N,OAAOn3B,KAAMwmB,EAAO2Q,UAEzB1N,EAAOqT,QAAUrT,EAAOsT,QAAUtT,EAAOuT,YAEnDvT,EAAOsP,YAAgBtP,EAAOuP,eAAiB3uB,IAASxD,MAAwB4iB,EAAOwP,eAAiB4mD,EAAS9jC,iBAAkBtyB,IAAa,CAEtJA,EAAO+O,gBAAgB3jB,iBAAkB+sE,EAAan7D,mBAAoBgD,EAAO5C,aAEjF,MAAM4D,EAAWk1D,EAASh7E,OAAQ8kB,GAC5B8T,EAAW9T,EAAO8T,SAExB,GAAKh/B,MAAME,QAAS8+B,GAAa,CAEhC,MAAM8O,EAAS5hB,EAAS4hB,OAExB,IAAM,IAAIw1C,EAAI,EAAGC,EAAKz1C,EAAOpuC,OAAQ4jF,EAAIC,EAAID,IAAO,CAEnD,MAAMlzC,EAAQtC,EAAQw1C,GAChBxvC,EAAgB9U,EAAUoR,EAAM5B,eAEtC,GAAKsF,GAAiBA,EAAcvZ,QAAU,CAE7C,MAAMipD,EAAgBZ,EAAkB13D,EAAQ4oB,EAAeopC,EAAOpxE,GAEtEgvD,EAAU6nB,mBAAoBU,EAAc,KAAMn3D,EAAUs3D,EAAet4D,EAAQklB,EAEpF,CAED,CAED,MAAO,GAAKpR,EAASzE,QAAU,CAE9B,MAAMipD,EAAgBZ,EAAkB13D,EAAQ8T,EAAUk+C,EAAOpxE,GAEjEgvD,EAAU6nB,mBAAoBU,EAAc,KAAMn3D,EAAUs3D,EAAet4D,EAAQ,KAEpF,CAED,CAID,MAAMkB,EAAWlB,EAAOkB,SAExB,IAAM,IAAI/sB,EAAI,EAAGoN,EAAI2f,EAAS1sB,OAAQL,EAAIoN,EAAGpN,IAE5C+jF,EAAch3D,EAAU/sB,GAAK4oB,EAAQo7D,EAAcnG,EAAOpxE,EAI5D,CAxTA/M,KAAKm7C,OAAS,SAAWxD,EAAQiD,EAAO1xB,GAEvC,IAAuB,IAAlBssB,EAAM35B,QAAoB,OAC/B,IAA0B,IAArB25B,EAAM+tC,aAA8C,IAAtB/tC,EAAM13B,YAAwB,OAEjE,GAAuB,IAAlB65B,EAAOh3C,OAAe,OAE3B,MAAMk6C,EAAsBkhB,EAAU9kB,kBAChCytC,EAAiB3oB,EAAU4oB,oBAC3BC,EAAoB7oB,EAAU8oB,uBAE9BC,EAAS/oB,EAAU7K,MAGzB4zB,EAAOC,YAn2qBU,GAo2qBjBD,EAAOjlC,QAAQrkC,MAAMm2C,SAAU,EAAG,EAAG,EAAG,GACxCmzB,EAAOjlC,QAAQl9B,MAAMqiE,SAAS,GAC9BF,EAAOG,gBAAgB,GAIvB,MAAMC,EAAU1B,IAAkBj6E,GAAgBvJ,KAAK+M,OAASxD,EAC1D47E,EAAY3B,IAAkBj6E,GAAgBvJ,KAAK+M,OAASxD,EAIlE,IAAM,IAAIjJ,EAAI,EAAGmrB,EAAKksB,EAAOh3C,OAAQL,EAAImrB,EAAInrB,IAAO,CAEnD,MAAM69E,EAAQxmC,EAAQr3C,GAChBmvD,EAAS0uB,EAAM1uB,OAErB,QAAgBtyD,IAAXsyD,EAAuB,CAE3BnxD,QAAQkU,KAAM,wBAAyB2rE,EAAO,kBAC9C,QAED,CAEA,IAA2B,IAAtB1uB,EAAO8zB,aAA+C,IAAvB9zB,EAAO3xC,YAAwB,SAEnE0kE,EAAepvE,KAAMq8C,EAAOixB,SAE5B,MAAM0E,EAAqB31B,EAAO41B,kBA0BlC,GAxBA7C,EAAe5uE,SAAUwxE,GAEzB3C,EAAcrvE,KAAMq8C,EAAOixB,UAEtB8B,EAAelmF,EAAIwmF,GAAmBN,EAAehmF,EAAIsmF,KAExDN,EAAelmF,EAAIwmF,IAEvBL,EAAcnmF,EAAI0B,KAAKK,MAAOykF,EAAkBsC,EAAmB9oF,GACnEkmF,EAAelmF,EAAImmF,EAAcnmF,EAAI8oF,EAAmB9oF,EACxDmzD,EAAOixB,QAAQpkF,EAAImmF,EAAcnmF,GAI7BkmF,EAAehmF,EAAIsmF,IAEvBL,EAAcjmF,EAAIwB,KAAKK,MAAOykF,EAAkBsC,EAAmB5oF,GACnEgmF,EAAehmF,EAAIimF,EAAcjmF,EAAI4oF,EAAmB5oF,EACxDizD,EAAOixB,QAAQlkF,EAAIimF,EAAcjmF,IAMf,OAAfizD,EAAOxvD,MAA0B,IAAVilF,IAA8B,IAAZC,EAAmB,CAEhE,MAAMG,EAAStlF,KAAK+M,OAASxD,EAAiB,CAAEwV,UAAWrU,EAAeoU,UAAWpU,GAAkB,CAAC,EAEpF,OAAf+kD,EAAOxvD,KAEXwvD,EAAOxvD,IAAIwgB,UAIZgvC,EAAOxvD,IAAM,IAAIwiB,GAAmB+/D,EAAelmF,EAAGkmF,EAAehmF,EAAG8oF,GACxE71B,EAAOxvD,IAAI8iB,QAAQvgB,KAAO27E,EAAM37E,KAAO,aAEvCitD,EAAOvmC,OAAO+vB,wBAEf,CAEA8iB,EAAU7gB,gBAAiBuU,EAAOxvD,KAClC87D,EAAU1+B,QAEV,MAAMkoD,EAAgB91B,EAAO+1B,mBAE7B,IAAM,IAAIC,EAAK,EAAGA,EAAKF,EAAeE,IAAQ,CAE7C,MAAM3iE,EAAW2sC,EAAOi2B,YAAaD,GAErC/C,EAAUnwE,IACTkwE,EAAcnmF,EAAIwmB,EAASxmB,EAC3BmmF,EAAcjmF,EAAIsmB,EAAStmB,EAC3BimF,EAAcnmF,EAAIwmB,EAAShC,EAC3B2hE,EAAcjmF,EAAIsmB,EAAS/B,GAG5B+jE,EAAOhiE,SAAU4/D,GAEjBjzB,EAAOoxB,eAAgB1C,EAAOsH,GAE9BlD,EAAW9yB,EAAOk2B,aAElBtB,EAAczpC,EAAO1xB,EAAQumC,EAAOvmC,OAAQi1D,EAAOn+E,KAAK+M,KAEzD,EAImC,IAA9B0iD,EAAOm2B,oBAA+B5lF,KAAK+M,OAASxD,GAExDk6E,EAASh0B,EAAQvmC,GAIlBumC,EAAO3xC,aAAc,CAEtB,CAEA0lE,EAAgBxjF,KAAK+M,KAErByoC,EAAM13B,aAAc,EAEpBi+C,EAAU7gB,gBAAiBL,EAAqB6pC,EAAgBE,EAEjE,CAyLD,CAEA,SAASiB,GAAYnmC,EAAI7H,EAAY8H,GAEpC,MAAMC,EAAWD,EAAaC,SA2SxBkmC,EAAc,IAzSpB,WAEC,IAAIC,GAAS,EAEb,MAAMvqE,EAAQ,IAAIqF,GAClB,IAAImlE,EAAmB,KACvB,MAAMC,EAAoB,IAAIplE,GAAS,EAAG,EAAG,EAAG,GAEhD,MAAO,CAENqlE,QAAS,SAAWC,GAEdH,IAAqBG,GAAeJ,IAExCrmC,EAAGymC,UAAWA,EAAWA,EAAWA,EAAWA,GAC/CH,EAAmBG,EAIrB,EAEAC,UAAW,SAAWC,GAErBN,EAASM,CAEV,EAEA10B,SAAU,SAAW3oD,EAAG+P,EAAGrH,EAAGjJ,EAAGi9B,IAEJ,IAAvBA,IAEJ18B,GAAKP,EAAGsQ,GAAKtQ,EAAGiJ,GAAKjJ,GAItB+S,EAAMjJ,IAAKvJ,EAAG+P,EAAGrH,EAAGjJ,IAEuB,IAAtCw9E,EAAkBxwE,OAAQ+F,KAE9BkkC,EAAG0R,WAAYpoD,EAAG+P,EAAGrH,EAAGjJ,GACxBw9E,EAAkB7yE,KAAMoI,GAI1B,EAEA+4C,MAAO,WAENwxB,GAAS,EAETC,EAAmB,KACnBC,EAAkB1zE,KAAO,EAAG,EAAG,EAAG,EAEnC,EAIF,EAiPMyQ,EAAc,IA/OpB,WAEC,IAAI+iE,GAAS,EAETO,EAAmB,KACnBC,EAAmB,KACnBC,EAAoB,KAExB,MAAO,CAENxB,QAAS,SAAW3gD,GAEdA,EAEJ7K,EAAQkmB,EAAG+mC,YAIX9sD,EAAS+lB,EAAG+mC,WAId,EAEAP,QAAS,SAAWQ,GAEdJ,IAAqBI,GAAeX,IAExCrmC,EAAGgnC,UAAWA,GACdJ,EAAmBI,EAIrB,EAEAC,QAAS,SAAWviD,GAEnB,GAAKmiD,IAAqBniD,EAAY,CAErC,OAASA,GAER,KAnurBa,EAqurBZsb,EAAGtb,UAAWsb,EAAGknC,OACjB,MAED,KAvurBc,EAyurBblnC,EAAGtb,UAAWsb,EAAGmnC,QACjB,MAED,KA3urBY,EA6urBXnnC,EAAGtb,UAAWsb,EAAGonC,MACjB,MAED,KA/urBiB,EAwwrBjB,QAECpnC,EAAGtb,UAAWsb,EAAGqnC,cAtBlB,KAnvrBa,EAqvrBZrnC,EAAGtb,UAAWsb,EAAGsnC,OACjB,MAED,KAvvrBoB,EAyvrBnBtnC,EAAGtb,UAAWsb,EAAGunC,QACjB,MAED,KA3vrBe,EA6vrBdvnC,EAAGtb,UAAWsb,EAAGwnC,SACjB,MAED,KA/vrBgB,EAiwrBfxnC,EAAGtb,UAAWsb,EAAGynC,UASnBZ,EAAmBniD,CAEpB,CAED,EAEAgiD,UAAW,SAAWC,GAErBN,EAASM,CAEV,EAEA10B,SAAU,SAAWhvC,GAEf6jE,IAAsB7jE,IAE1B+8B,EAAG0nC,WAAYzkE,GACf6jE,EAAoB7jE,EAItB,EAEA4xC,MAAO,WAENwxB,GAAS,EAETO,EAAmB,KACnBC,EAAmB,KACnBC,EAAoB,IAErB,EAIF,EAsHMvjE,EAAgB,IApHtB,WAEC,IAAI8iE,GAAS,EAETsB,EAAqB,KACrBC,EAAqB,KACrBC,EAAoB,KACpBC,EAAyB,KACzBC,EAAqB,KACrBC,EAAsB,KACtBC,EAAsB,KACtBC,EAAsB,KAE1B,MAAO,CAEN5C,QAAS,SAAW6C,GAEZ9B,IAED8B,EAEJruD,EAAQkmB,EAAGooC,cAIXnuD,EAAS+lB,EAAGooC,cAMf,EAEA5B,QAAS,SAAW6B,GAEdV,IAAuBU,GAAiBhC,IAE5CrmC,EAAGqoC,YAAaA,GAChBV,EAAqBU,EAIvB,EAEApB,QAAS,SAAWniD,EAAaC,EAAYsjD,GAEvCT,IAAuB9iD,GACvB+iD,IAAsB9iD,GACtB+iD,IAA2BO,IAE/BroC,EAAGlb,YAAaA,EAAaC,EAAYsjD,GAEzCT,EAAqB9iD,EACrB+iD,EAAoB9iD,EACpB+iD,EAAyBO,EAI3B,EAEAC,MAAO,SAAWrjD,EAAaC,EAAcC,GAEvC4iD,IAAuB9iD,GACvB+iD,IAAwB9iD,GACxB+iD,IAAwB9iD,IAE5B6a,EAAGuoC,UAAWtjD,EAAaC,EAAcC,GAEzC4iD,EAAqB9iD,EACrB+iD,EAAsB9iD,EACtB+iD,EAAsB9iD,EAIxB,EAEAuhD,UAAW,SAAWC,GAErBN,EAASM,CAEV,EAEA10B,SAAU,SAAW9V,GAEf+rC,IAAwB/rC,IAE5B6D,EAAGwoC,aAAcrsC,GACjB+rC,EAAsB/rC,EAIxB,EAEA0Y,MAAO,WAENwxB,GAAS,EAETsB,EAAqB,KACrBC,EAAqB,KACrBC,EAAoB,KACpBC,EAAyB,KACzBC,EAAqB,KACrBC,EAAsB,KACtBC,EAAsB,KACtBC,EAAsB,IAEvB,EAIF,EAQMO,EAAc,IAAIroC,QAClBsoC,EAAgB,IAAItoC,QAE1B,IAAIuoC,EAAsB,CAAC,EAEvBC,EAA2B,CAAC,EAC5BC,EAAqB,IAAIzoC,QACzB0oC,EAAqB,GAErBC,EAAiB,KAEjBC,GAAyB,EACzBC,EAAkB,KAClBC,EAAuB,KACvBC,EAAkB,KAClBC,EAAkB,KAClBC,EAA4B,KAC5BC,EAAuB,KACvBC,EAAuB,KACvBC,GAA2B,EAE3BC,EAAmB,KACnBC,EAAkB,KAElBC,EAAmB,KAEnBC,EAA6B,KAC7BC,EAA4B,KAEhC,MAAMzxB,EAAcpY,EAAGlyB,aAAckyB,EAAG8pC,kCAExC,IAAIC,GAAqB,EACrB5rE,EAAU,EACd,MAAM6rE,EAAYhqC,EAAGlyB,aAAckyB,EAAGiqC,UAEE,IAAnCD,EAAUv8E,QAAS,UAEvB0Q,EAAU0tB,WAAY,cAAcC,KAAMk+C,GAAa,IACvDD,EAAuB5rE,GAAW,IAEgB,IAAvC6rE,EAAUv8E,QAAS,eAE9B0Q,EAAU0tB,WAAY,kBAAkBC,KAAMk+C,GAAa,IAC3DD,EAAuB5rE,GAAW,GAInC,IAAI+rE,EAAqB,KACrBC,EAAuB,CAAC,EAE5B,MAAMC,EAAepqC,EAAGlyB,aAAckyB,EAAGqqC,aACnCC,EAAgBtqC,EAAGlyB,aAAckyB,EAAGuqC,UAEpCC,GAAiB,IAAIrpE,IAAUnL,UAAWo0E,GAC1CK,GAAkB,IAAItpE,IAAUnL,UAAWs0E,GAEjD,SAASI,EAAer9E,EAAM3I,EAAQa,EAAOolF,GAE5C,MAAMhnF,EAAO,IAAIiM,WAAY,GACvByT,EAAU28B,EAAG0qC,gBAEnB1qC,EAAG4qC,YAAav9E,EAAMgW,GACtB28B,EAAG6qC,cAAex9E,EAAM2yC,EAAG8qC,mBAAoB9qC,EAAG+qC,SAClD/qC,EAAG6qC,cAAex9E,EAAM2yC,EAAGgrC,mBAAoBhrC,EAAG+qC,SAElD,IAAM,IAAInqF,EAAI,EAAGA,EAAI2E,EAAO3E,KAEtBs/C,GAAc7yC,IAAS2yC,EAAGirC,YAAc59E,IAAS2yC,EAAGkrC,iBAMxDlrC,EAAGmrC,WAAYzmF,EAAS9D,EAAG,EAAGo/C,EAAGorC,KAAM,EAAG,EAAG,EAAGprC,EAAGorC,KAAMprC,EAAGuB,cAAe59C,GAJ3Eq8C,EAAGqrC,WAAY3mF,EAAQ,EAAGs7C,EAAGorC,KAAM,EAAG,EAAGT,EAAY,EAAG3qC,EAAGorC,KAAMprC,EAAGuB,cAAe59C,GAUrF,OAAO0f,CAER,CAEA,MAAMioE,EAAgB,CAAC,EA4BvB,SAASxxD,EAAQ75B,IAEmB,IAA9B0oF,EAAqB1oF,KAEzB+/C,EAAGlmB,OAAQ75B,GACX0oF,EAAqB1oF,IAAO,EAI9B,CAEA,SAASg6B,EAASh6B,IAEkB,IAA9B0oF,EAAqB1oF,KAEzB+/C,EAAG/lB,QAASh6B,GACZ0oF,EAAqB1oF,IAAO,EAI9B,CA/CAqrF,EAAetrC,EAAGurC,YAAeb,EAAe1qC,EAAGurC,WAAYvrC,EAAGurC,WAAY,GAC9ED,EAAetrC,EAAGwrC,kBAAqBd,EAAe1qC,EAAGwrC,iBAAkBxrC,EAAGyrC,4BAA6B,GAEtGvrC,IAEJorC,EAAetrC,EAAGkrC,kBAAqBR,EAAe1qC,EAAGkrC,iBAAkBlrC,EAAGkrC,iBAAkB,EAAG,GACnGI,EAAetrC,EAAGirC,YAAeP,EAAe1qC,EAAGirC,WAAYjrC,EAAGirC,WAAY,EAAG,IAMlF7E,EAAYn0B,SAAU,EAAG,EAAG,EAAG,GAC/B3uC,EAAY2uC,SAAU,GACtB1uC,EAAc0uC,SAAU,GAExBn4B,EAAQkmB,EAAG+mC,YACXzjE,EAAY2jE,QA9gsBU,GAghsBtByE,GAAc,GACdC,EArjsBoB,GAsjsBpB7xD,EAAQkmB,EAAG4rC,WAEXvG,EA7isBkB,GAqssBlB,MAAMwG,EAAe,CACpB,CAAE7hF,GAAeg2C,EAAG8rC,SACpB,IAAsB9rC,EAAG+rC,cACzB,IAA6B/rC,EAAGgsC,uBAGjC,GAAK9rC,EAEJ2rC,EApssBkB,KAossBY7rC,EAAGisC,IACjCJ,EApssBkB,KAossBY7rC,EAAGksC,QAE3B,CAEN,MAAMj5B,EAAY9a,EAAWhvC,IAAK,oBAEf,OAAd8pD,IAEJ44B,EA7ssBiB,KA6ssBa54B,EAAUk5B,QACxCN,EA7ssBiB,KA6ssBa54B,EAAUm5B,QAI1C,CAEA,MAAMC,EAAa,CAClB,IAAgBrsC,EAAGssC,KACnB,IAAetsC,EAAGusC,IAClB,IAAoBvsC,EAAGwsC,UACvB,IAAoBxsC,EAAGysC,UACvB,IAA4BzsC,EAAG0sC,mBAC/B,IAAoB1sC,EAAG2sC,UACvB,IAAoB3sC,EAAG4sC,UACvB,IAA4B5sC,EAAG6sC,oBAC/B,IAA4B7sC,EAAG8sC,oBAC/B,IAA4B9sC,EAAG+sC,oBAC/B,IAA4B/sC,EAAGgtC,qBAGhC,SAAS3H,EAAavhD,EAAUQ,EAAeF,EAAUC,EAAUI,EAAoBF,EAAeC,EAAewB,GAEpH,GA7usBiB,IA6usBZlC,GAoBL,IAPgC,IAA3BklD,IAEJlvD,EAAQkmB,EAAGitC,OACXjE,GAAyB,GAxvsBL,IA4vsBhBllD,EAmFLW,EAAqBA,GAAsBH,EAC3CC,EAAgBA,GAAiBH,EACjCI,EAAgBA,GAAiBH,EAE5BC,IAAkB4kD,GAAwBzkD,IAAuB4kD,IAErErpC,EAAGktC,sBAAuBrB,EAAcvnD,GAAiBunD,EAAcpnD,IAEvEykD,EAAuB5kD,EACvB+kD,EAA4B5kD,GAIxBL,IAAa+kD,GAAmB9kD,IAAa+kD,GAAmB7kD,IAAkB+kD,GAAwB9kD,IAAkB+kD,IAEhIvpC,EAAGmtC,kBAAmBd,EAAYjoD,GAAYioD,EAAYhoD,GAAYgoD,EAAY9nD,GAAiB8nD,EAAY7nD,IAE/G2kD,EAAkB/kD,EAClBglD,EAAkB/kD,EAClBilD,EAAuB/kD,EACvBglD,EAAuB/kD,GAIxBykD,EAAkBnlD,EAClB0lD,GAA2B,OA1G1B,GAAK1lD,IAAamlD,GAAmBjjD,IAAuBwjD,EAA2B,CAWtF,GATKN,IAAyBl/E,GAAeq/E,IAA8Br/E,IAE1Eg2C,EAAG1b,cAAe0b,EAAG8rC,UAErB5C,EAAuBl/E,EACvBq/E,EAA4Br/E,GAIxBg8B,EAEJ,OAASlC,GAER,KAjxsBiB,EAkxsBhBkc,EAAGmtC,kBAAmBntC,EAAGusC,IAAKvsC,EAAG8sC,oBAAqB9sC,EAAGusC,IAAKvsC,EAAG8sC,qBACjE,MAED,KApxsBmB,EAqxsBlB9sC,EAAGotC,UAAWptC,EAAGusC,IAAKvsC,EAAGusC,KACzB,MAED,KAvxsBsB,EAwxsBrBvsC,EAAGmtC,kBAAmBntC,EAAGssC,KAAMtsC,EAAG6sC,oBAAqB7sC,EAAGssC,KAAMtsC,EAAGusC,KACnE,MAED,KA1xsBmB,EA2xsBlBvsC,EAAGmtC,kBAAmBntC,EAAGssC,KAAMtsC,EAAGwsC,UAAWxsC,EAAGssC,KAAMtsC,EAAGysC,WACzD,MAED,QACC7tF,QAAQ6+B,MAAO,uCAAwCqG,QAOzD,OAASA,GAER,KA3ysBiB,EA4ysBhBkc,EAAGmtC,kBAAmBntC,EAAGysC,UAAWzsC,EAAG8sC,oBAAqB9sC,EAAGusC,IAAKvsC,EAAG8sC,qBACvE,MAED,KA9ysBmB,EA+ysBlB9sC,EAAGotC,UAAWptC,EAAGysC,UAAWzsC,EAAGusC,KAC/B,MAED,KAjzsBsB,EAkzsBrBvsC,EAAGmtC,kBAAmBntC,EAAGssC,KAAMtsC,EAAG6sC,oBAAqB7sC,EAAGssC,KAAMtsC,EAAGusC,KACnE,MAED,KApzsBmB,EAqzsBlBvsC,EAAGotC,UAAWptC,EAAGssC,KAAMtsC,EAAGwsC,WAC1B,MAED,QACC5tF,QAAQ6+B,MAAO,uCAAwCqG,GAO1DqlD,EAAkB,KAClBC,EAAkB,KAClBE,EAAuB,KACvBC,EAAuB,KAEvBN,EAAkBnlD,EAClB0lD,EAA2BxjD,CAE5B,OA7FgC,IAA3BgjD,IAEJ/uD,EAAS+lB,EAAGitC,OACZjE,GAAyB,EA6H5B,CA0CA,SAAS0C,EAAc9W,GAEjB6U,IAAqB7U,IAEpBA,EAEJ50B,EAAGqtC,UAAWrtC,EAAGstC,IAIjBttC,EAAGqtC,UAAWrtC,EAAGutC,KAIlB9D,EAAmB7U,EAIrB,CAEA,SAAS+W,EAAa6B,GAz7sBF,IA27sBdA,GAEJ1zD,EAAQkmB,EAAG4rC,WAEN4B,IAAa9D,IA97sBA,IAg8sBZ8D,EAEJxtC,EAAGwtC,SAAUxtC,EAAGytC,MAj8sBC,IAm8sBND,EAEXxtC,EAAGwtC,SAAUxtC,EAAG0tC,OAIhB1tC,EAAGwtC,SAAUxtC,EAAG2tC,kBAQlB1zD,EAAS+lB,EAAG4rC,WAIblC,EAAkB8D,CAEnB,CAcA,SAASI,EAAkBjoD,EAAekoD,EAAQjjB,GAE5CjlC,GAEJ7L,EAAQkmB,EAAG8tC,qBAENlE,IAA+BiE,GAAUhE,IAA8Bjf,IAE3E5qB,EAAGra,cAAekoD,EAAQjjB,GAE1Bgf,EAA6BiE,EAC7BhE,EAA4Bjf,IAM7B3wC,EAAS+lB,EAAG8tC,oBAId,CAkYA,MAAO,CAEN3tC,QAAS,CACRrkC,MAAOsqE,EACPnjE,MAAOK,EACP64B,QAAS54B,GAGVuW,OAAQA,EACRG,QAASA,EAET8zD,gBAtzBD,SAA0BrpF,EAAQspF,GAEjC,OAAKpF,EAA0BlkF,KAAaspF,IAE3ChuC,EAAG+tC,gBAAiBrpF,EAAQspF,GAE5BpF,EAA0BlkF,GAAWspF,EAEhC9tC,IAICx7C,IAAWs7C,EAAGiuC,mBAElBrF,EAA0B5oC,EAAGkuC,aAAgBF,GAIzCtpF,IAAWs7C,EAAGkuC,cAElBtF,EAA0B5oC,EAAGiuC,kBAAqBD,KAM7C,EAMT,EAuxBC11C,YArxBD,SAAsBmC,EAAcuzC,GAEnC,IAAI11C,EAAcwwC,EAEd1qE,GAAc,EAElB,GAAKq8B,EAWJ,GATAnC,EAAcuwC,EAAmB1/E,IAAK6kF,QAEjBvwF,IAAhB66C,IAEJA,EAAc,GACduwC,EAAmBh2E,IAAKm7E,EAAa11C,IAIjCmC,EAAa0zC,6BAA+B,CAEhD,MAAMxtE,EAAW85B,EAAap3B,QAE9B,GAAKi1B,EAAYr3C,SAAW0f,EAAS1f,QAAUq3C,EAAa,KAAQ0H,EAAGouC,kBAAoB,CAE1F,IAAM,IAAIxtF,EAAI,EAAGmrB,EAAKpL,EAAS1f,OAAQL,EAAImrB,EAAInrB,IAE9C03C,EAAa13C,GAAMo/C,EAAGouC,kBAAoBxtF,EAI3C03C,EAAYr3C,OAAS0f,EAAS1f,OAE9Bmd,GAAc,CAEf,CAED,MAEMk6B,EAAa,KAAQ0H,EAAGouC,oBAE5B91C,EAAa,GAAM0H,EAAGouC,kBAEtBhwE,GAAc,QAQXk6B,EAAa,KAAQ0H,EAAGytC,OAE5Bn1C,EAAa,GAAM0H,EAAGytC,KAEtBrvE,GAAc,GAMXA,IAEC6hC,EAAaC,SAEjBF,EAAG1H,YAAaA,GAIhBH,EAAWhvC,IAAK,sBAAuBklF,iBAAkB/1C,GAO5D,EA6sBCg2C,WA3sBD,SAAqBp6B,GAEpB,OAAK60B,IAAmB70B,IAEvBlU,EAAGsuC,WAAYp6B,GAEf60B,EAAiB70B,GAEV,EAMT,EA+rBCmxB,YAAaA,EACbkJ,YAlhBD,SAAsBhuD,EAAUiuD,GAE/BjuD,EAASwD,OAASh6B,EACfkwB,EAAS+lB,EAAG4rC,WACZ9xD,EAAQkmB,EAAG4rC,WAEd,IAAIhX,EA13sBW,IA03sBGr0C,EAASwD,KACtByqD,IAAc5Z,GAAcA,GAEjC8W,EAAc9W,GAz3sBO,IA23sBnBr0C,EAASuD,WAAwD,IAAzBvD,EAAS2D,YAChDmhD,EA73sBc,GA83sBdA,EAAa9kD,EAASuD,SAAUvD,EAAS+D,cAAe/D,EAAS6D,SAAU7D,EAAS8D,SAAU9D,EAASkE,mBAAoBlE,EAASgE,cAAehE,EAASiE,cAAejE,EAASyF,oBAEvL1iB,EAAY2jE,QAAS1mD,EAASmE,WAC9BphB,EAAYgiE,QAAS/kD,EAASoE,WAC9BrhB,EAAYkjE,QAASjmD,EAASqE,YAC9BwhD,EAAYI,QAASjmD,EAASkF,YAE9B,MAAML,EAAe7E,EAAS6E,aAC9B7hB,EAAc+hE,QAASlgD,GAClBA,IAEJ7hB,EAAcijE,QAASjmD,EAASsE,kBAChCthB,EAAc0jE,QAAS1mD,EAASuE,YAAavE,EAASwE,WAAYxE,EAASyE,iBAC3EzhB,EAAc+kE,MAAO/nD,EAAS0E,YAAa1E,EAAS2E,aAAc3E,EAAS4E,eAI5EyoD,EAAkBrtD,EAASoF,cAAepF,EAASqF,oBAAqBrF,EAASsF,qBAEpD,IAA7BtF,EAASwF,gBACNjM,EAAQkmB,EAAGyuC,0BACXx0D,EAAS+lB,EAAGyuC,yBAEhB,EAgfC/C,aAAcA,EACdC,YAAaA,EAEb+C,aAzbD,SAAuBz7E,GAEjBA,IAAU02E,IAETI,GAAqB/pC,EAAG2uC,UAAW17E,GAExC02E,EAAmB12E,EAIrB,EAgbC26E,iBAAkBA,EAElBrI,eAzZD,SAAyBpiE,GAEnBA,EAEJ2W,EAAQkmB,EAAG4uC,cAIX30D,EAAS+lB,EAAG4uC,aAId,EA+YCC,cA3YD,SAAwBC,QAEJrxF,IAAdqxF,IAA0BA,EAAY9uC,EAAG+uC,SAAW32B,EAAc,GAElE8xB,IAAuB4E,IAE3B9uC,EAAG6uC,cAAeC,GAClB5E,EAAqB4E,EAIvB,EAiYClE,YA/XD,SAAsBoE,EAAWC,EAAcH,QAE3BrxF,IAAdqxF,IAIHA,EAF2B,OAAvB5E,EAEQlqC,EAAG+uC,SAAW32B,EAAc,EAI5B8xB,GAMd,IAAIgF,EAAe/E,EAAsB2E,QAEnBrxF,IAAjByxF,IAEJA,EAAe,CAAE7hF,UAAM5P,EAAW4lB,aAAS5lB,GAC3C0sF,EAAsB2E,GAAcI,GAIhCA,EAAa7hF,OAAS2hF,GAAaE,EAAa7rE,UAAY4rE,IAE3D/E,IAAuB4E,IAE3B9uC,EAAG6uC,cAAeC,GAClB5E,EAAqB4E,GAItB9uC,EAAG4qC,YAAaoE,EAAWC,GAAgB3D,EAAe0D,IAE1DE,EAAa7hF,KAAO2hF,EACpBE,EAAa7rE,QAAU4rE,EAIzB,EAuVCE,cArVD,WAEC,MAAMD,EAAe/E,EAAsBD,QAErBzsF,IAAjByxF,QAAoDzxF,IAAtByxF,EAAa7hF,OAE/C2yC,EAAG4qC,YAAasE,EAAa7hF,KAAM,MAEnC6hF,EAAa7hF,UAAO5P,EACpByxF,EAAa7rE,aAAU5lB,EAIzB,EAyUC2xF,qBAvUD,WAEC,IAECpvC,EAAGovC,qBAAqBC,MAAOrvC,EAAIxiB,UAEpC,CAAE,MAAQC,GAET7+B,QAAQ6+B,MAAO,oBAAqBA,EAErC,CAED,EA4TC6xD,qBA1TD,WAEC,IAECtvC,EAAGsvC,qBAAqBD,MAAOrvC,EAAIxiB,UAEpC,CAAE,MAAQC,GAET7+B,QAAQ6+B,MAAO,oBAAqBA,EAErC,CAED,EA+SC0tD,WAzND,WAEC,IAECnrC,EAAGmrC,WAAWkE,MAAOrvC,EAAIxiB,UAE1B,CAAE,MAAQC,GAET7+B,QAAQ6+B,MAAO,oBAAqBA,EAErC,CAED,EA8MC4tD,WA5MD,WAEC,IAECrrC,EAAGqrC,WAAWgE,MAAOrvC,EAAIxiB,UAE1B,CAAE,MAAQC,GAET7+B,QAAQ6+B,MAAO,oBAAqBA,EAErC,CAED,EAkMC8xD,iBAxKD,SAA2BC,EAAet7B,GAEzC,IAAIl1C,EAAU0pE,EAAcv/E,IAAK+qD,QAEhBz2D,IAAZuhB,IAEJA,EAAU,IAAIohC,QAEdsoC,EAAc71E,IAAKqhD,EAASl1C,IAI7B,IAAIywE,EAAazwE,EAAQ7V,IAAKqmF,QAEV/xF,IAAfgyF,IAEJA,EAAazvC,EAAG0vC,qBAAsBx7B,EAASs7B,EAAc1sF,MAE7Dkc,EAAQnM,IAAK28E,EAAeC,GAI9B,EAmJCE,oBAjJD,SAA8BH,EAAet7B,GAE5C,MACMu7B,EADU/G,EAAcv/E,IAAK+qD,GACR/qD,IAAKqmF,GAE3B/G,EAAYt/E,IAAK+qD,KAAcu7B,IAGnCzvC,EAAG2vC,oBAAqBz7B,EAASu7B,EAAYD,EAAcI,qBAE3DnH,EAAY51E,IAAKqhD,EAASu7B,GAI5B,EAqICI,aA3PD,WAEC,IAEC7vC,EAAG6vC,aAAaR,MAAOrvC,EAAIxiB,UAE5B,CAAE,MAAQC,GAET7+B,QAAQ6+B,MAAO,oBAAqBA,EAErC,CAED,EAgPCqyD,aA9OD,WAEC,IAEC9vC,EAAG8vC,aAAaT,MAAOrvC,EAAIxiB,UAE5B,CAAE,MAAQC,GAET7+B,QAAQ6+B,MAAO,oBAAqBA,EAErC,CAED,EAmOCsyD,cArTD,WAEC,IAEC/vC,EAAG+vC,cAAcV,MAAOrvC,EAAIxiB,UAE7B,CAAE,MAAQC,GAET7+B,QAAQ6+B,MAAO,oBAAqBA,EAErC,CAED,EA0SCuyD,cAxSD,WAEC,IAEChwC,EAAGgwC,cAAcX,MAAOrvC,EAAIxiB,UAE7B,CAAE,MAAQC,GAET7+B,QAAQ6+B,MAAO,oBAAqBA,EAErC,CAED,EA6RCwyD,wBA3RD,WAEC,IAECjwC,EAAGiwC,wBAAwBZ,MAAOrvC,EAAIxiB,UAEvC,CAAE,MAAQC,GAET7+B,QAAQ6+B,MAAO,oBAAqBA,EAErC,CAED,EAgRCyyD,wBA9QD,WAEC,IAEClwC,EAAGkwC,wBAAwBb,MAAOrvC,EAAIxiB,UAEvC,CAAE,MAAQC,GAET7+B,QAAQ6+B,MAAO,oBAAqBA,EAErC,CAED,EAoQCva,QAxMD,SAAkBA,IAEyB,IAArCsnE,EAAez0E,OAAQmN,KAE3B88B,EAAG98B,QAASA,EAAQtmB,EAAGsmB,EAAQpmB,EAAGomB,EAAQ9B,EAAG8B,EAAQ7B,GACrDmpE,EAAe92E,KAAMwP,GAIvB,EAgMCE,SA9LD,SAAmBA,IAE0B,IAAvCqnE,EAAgB10E,OAAQqN,KAE5B48B,EAAG58B,SAAUA,EAASxmB,EAAGwmB,EAAStmB,EAAGsmB,EAAShC,EAAGgC,EAAS/B,GAC1DopE,EAAgB/2E,KAAM0P,GAIxB,EAuLCyxC,MA3ID,WAIC7U,EAAG/lB,QAAS+lB,EAAGitC,OACfjtC,EAAG/lB,QAAS+lB,EAAG4rC,WACf5rC,EAAG/lB,QAAS+lB,EAAG+mC,YACf/mC,EAAG/lB,QAAS+lB,EAAG8tC,qBACf9tC,EAAG/lB,QAAS+lB,EAAG4uC,cACf5uC,EAAG/lB,QAAS+lB,EAAGooC,cACfpoC,EAAG/lB,QAAS+lB,EAAGyuC,0BAEfzuC,EAAG1b,cAAe0b,EAAG8rC,UACrB9rC,EAAGotC,UAAWptC,EAAGusC,IAAKvsC,EAAGssC,MACzBtsC,EAAGmtC,kBAAmBntC,EAAGusC,IAAKvsC,EAAGssC,KAAMtsC,EAAGusC,IAAKvsC,EAAGssC,MAElDtsC,EAAGymC,WAAW,GAAM,GAAM,GAAM,GAChCzmC,EAAG0R,WAAY,EAAG,EAAG,EAAG,GAExB1R,EAAGgnC,WAAW,GACdhnC,EAAGtb,UAAWsb,EAAGonC,MACjBpnC,EAAG0nC,WAAY,GAEf1nC,EAAGqoC,YAAa,YAChBroC,EAAGlb,YAAakb,EAAGmnC,OAAQ,EAAG,YAC9BnnC,EAAGuoC,UAAWvoC,EAAGmwC,KAAMnwC,EAAGmwC,KAAMnwC,EAAGmwC,MACnCnwC,EAAGwoC,aAAc,GAEjBxoC,EAAGwtC,SAAUxtC,EAAGytC,MAChBztC,EAAGqtC,UAAWrtC,EAAGutC,KAEjBvtC,EAAGra,cAAe,EAAG,GAErBqa,EAAG6uC,cAAe7uC,EAAG+uC,UAErB/uC,EAAG+tC,gBAAiB/tC,EAAGkuC,YAAa,OAElB,IAAbhuC,IAEJF,EAAG+tC,gBAAiB/tC,EAAGiuC,iBAAkB,MACzCjuC,EAAG+tC,gBAAiB/tC,EAAGowC,iBAAkB,OAI1CpwC,EAAGsuC,WAAY,MAEftuC,EAAG2uC,UAAW,GAEd3uC,EAAG98B,QAAS,EAAG,EAAG88B,EAAG5iC,OAAOnK,MAAO+sC,EAAG5iC,OAAOlK,QAC7C8sC,EAAG58B,SAAU,EAAG,EAAG48B,EAAG5iC,OAAOnK,MAAO+sC,EAAG5iC,OAAOlK,QAI9Cy1E,EAAsB,CAAC,EAEvBuB,EAAqB,KACrBC,EAAuB,CAAC,EAExBvB,EAA2B,CAAC,EAC5BC,EAAqB,IAAIzoC,QACzB0oC,EAAqB,GAErBC,EAAiB,KAEjBC,GAAyB,EACzBC,EAAkB,KAClBC,EAAuB,KACvBC,EAAkB,KAClBC,EAAkB,KAClBC,EAA4B,KAC5BC,EAAuB,KACvBC,EAAuB,KACvBC,GAA2B,EAE3BC,EAAmB,KACnBC,EAAkB,KAElBC,EAAmB,KAEnBC,EAA6B,KAC7BC,EAA4B,KAE5BW,EAAe33E,IAAK,EAAG,EAAGmtC,EAAG5iC,OAAOnK,MAAO+sC,EAAG5iC,OAAOlK,QACrDu3E,EAAgB53E,IAAK,EAAG,EAAGmtC,EAAG5iC,OAAOnK,MAAO+sC,EAAG5iC,OAAOlK,QAEtDkzE,EAAYvxB,QACZvxC,EAAYuxC,QACZtxC,EAAcsxC,OAEf,EAsDD,CAEA,SAASw7B,GAAeC,EAAKn4C,EAAYqZ,EAAO1E,EAAY7M,EAAcswC,EAAOt5B,GAEhF,MAAM/W,EAAWD,EAAaC,SACxBkY,EAAcnY,EAAamY,YAC3BM,EAAiBzY,EAAayY,eAC9BF,EAAiBvY,EAAauY,eAC9BgB,EAAavZ,EAAauZ,WAC1Bg3B,EAAqBr4C,EAAW+f,IAAK,wCAA2C/f,EAAWhvC,IAAK,wCAA2C,KAC3IsnF,EAAqD,oBAAdC,WAAoC,iBAAiB1tF,KAAM0tF,UAAUC,WAE5GC,EAAiB,IAAIxwC,QAC3B,IAAItjC,EAEJ,MAAM+zE,EAAW,IAAIzwC,QAMrB,IAAI0wC,GAAqB,EAEzB,IAECA,EAAgD,oBAApBC,iBAE+B,OAArD,IAAIA,gBAAiB,EAAG,GAAIzzE,WAAY,KAE/C,CAAE,MAAQjb,GAIV,CAEA,SAAS2uF,EAAc/9E,EAAOC,GAI7B,OAAO49E,EAEN,IAAIC,gBAAiB99E,EAAOC,GAAWiI,GAAiB,SAE1D,CAEA,SAAS81E,EAAah0E,EAAOi0E,EAAiBC,EAAgBC,GAE7D,IAAI12E,EAAQ,EAYZ,IARKuC,EAAMhK,MAAQm+E,GAAWn0E,EAAM/J,OAASk+E,KAE5C12E,EAAQ02E,EAAU9yF,KAAKuQ,IAAKoO,EAAMhK,MAAOgK,EAAM/J,SAM3CwH,EAAQ,IAAyB,IAApBw2E,EAA2B,CAI5C,GAAmC,oBAArBvzE,kBAAoCV,aAAiBU,kBACnC,oBAAtBR,mBAAqCF,aAAiBE,mBACtC,oBAAhBS,aAA+BX,aAAiBW,YAAgB,CAEzE,MAAMjf,EAAQuyF,EAAkB3hF,GAAkBjR,KAAKK,MAEjDsU,EAAQtU,EAAO+b,EAAQuC,EAAMhK,OAC7BC,EAASvU,EAAO+b,EAAQuC,EAAM/J,aAEnBzV,IAAZqf,IAAwBA,EAAUk0E,EAAc/9E,EAAOC,IAI5D,MAAMkK,EAAS+zE,EAAiBH,EAAc/9E,EAAOC,GAAW4J,EAUhE,OARAM,EAAOnK,MAAQA,EACfmK,EAAOlK,OAASA,EAEAkK,EAAOE,WAAY,MAC3BG,UAAWR,EAAO,EAAG,EAAGhK,EAAOC,GAEvCtU,QAAQkU,KAAM,uDAAyDmK,EAAMhK,MAAQ,IAAMgK,EAAM/J,OAAS,SAAWD,EAAQ,IAAMC,EAAS,MAErIkK,CAER,CAQC,MANK,SAAUH,GAEdre,QAAQkU,KAAM,yDAA2DmK,EAAMhK,MAAQ,IAAMgK,EAAM/J,OAAS,MAItG+J,CAIT,CAEA,OAAOA,CAER,CAEA,SAASo0E,EAAgBp0E,GAExB,OAAO/N,GAAc+N,EAAMhK,QAAW/D,GAAc+N,EAAM/J,OAE3D,CAWA,SAASo+E,EAA6BjuE,EAASkuE,GAE9C,OAAOluE,EAAQpD,iBAAmBsxE,GACjCluE,EAAQhE,YAAcrU,GAAiBqY,EAAQhE,YAAclU,CAE/D,CAEA,SAASqmF,EAAgB9sF,GAExB4rF,EAAIkB,eAAgB9sF,EAErB,CAEA,SAAS+sF,EAAmBC,EAAoBC,EAAUC,EAAQt1E,EAAYu1E,GAAsB,GAEnG,IAAkB,IAAb3xC,EAAqB,OAAOyxC,EAEjC,GAA4B,OAAvBD,EAA8B,CAElC,QAAmCj0F,IAA9B6yF,EAAKoB,GAAqC,OAAOpB,EAAKoB,GAE3D9yF,QAAQkU,KAAM,2EAA8E4+E,EAAqB,IAElH,CAEA,IAAI5xE,EAAiB6xE,EAoCrB,OAlCKA,IAAarB,EAAIwB,MAEhBF,IAAWtB,EAAIvvC,QAAQjhC,EAAiBwwE,EAAIyB,MAC5CH,IAAWtB,EAAIrvC,aAAanhC,EAAiBwwE,EAAI0B,MACjDJ,IAAWtB,EAAI/uC,gBAAgBzhC,EAAiBwwE,EAAI2B,KAIrDN,IAAarB,EAAI4B,KAEhBN,IAAWtB,EAAIvvC,QAAQjhC,EAAiBwwE,EAAI6B,OAC5CP,IAAWtB,EAAIrvC,aAAanhC,EAAiBwwE,EAAI8B,OACjDR,IAAWtB,EAAI/uC,gBAAgBzhC,EAAiBwwE,EAAI+B,MAIrDV,IAAarB,EAAIlF,OAEhBwG,IAAWtB,EAAIvvC,QAAQjhC,EAAiBwwE,EAAIgC,SAC5CV,IAAWtB,EAAIrvC,aAAanhC,EAAiBwwE,EAAIiC,SACjDX,IAAWtB,EAAI/uC,gBAAgBzhC,EAAmBxD,IAAe3P,KAA0C,IAAxBklF,EAAkCvB,EAAIkC,aAAelC,EAAImC,OAC5Ib,IAAWtB,EAAIoC,yBAAyB5yE,EAAiBwwE,EAAIqC,OAC7Df,IAAWtB,EAAIsC,yBAAyB9yE,EAAiBwwE,EAAIuC,UAI9D/yE,IAAmBwwE,EAAI0B,MAAQlyE,IAAmBwwE,EAAIyB,MAC1DjyE,IAAmBwwE,EAAI8B,OAAStyE,IAAmBwwE,EAAI6B,OACvDryE,IAAmBwwE,EAAIiC,SAAWzyE,IAAmBwwE,EAAIgC,SAEzDn6C,EAAWhvC,IAAK,0BAIV2W,CAER,CAEA,SAASgzE,EAAczvE,EAASpG,EAAOs0E,GAEtC,OAA8D,IAAzDD,EAA6BjuE,EAASkuE,IAA6BluE,EAAQ0vE,sBAAwB1vE,EAAQhE,YAAcrU,GAAiBqY,EAAQhE,YAAclU,EAE7J7M,KAAK6/D,KAAM7/D,KAAKuQ,IAAKoO,EAAMhK,MAAOgK,EAAM/J,SAAa,OAE7BzV,IAApB4lB,EAAQzD,SAAyByD,EAAQzD,QAAQ3e,OAAS,EAI9DoiB,EAAQzD,QAAQ3e,OAEZoiB,EAAQ2vE,qBAAuBzxF,MAAME,QAAS4hB,EAAQpG,OAE1DA,EAAM2C,QAAQ3e,OAMd,CAIT,CAIA,SAASgyF,EAAgB75E,GAExB,OAAKA,IAAMpO,GAAiBoO,IAAMnO,GAA8BmO,IAAMlO,EAE9DolF,EAAIvF,QAILuF,EAAI4C,MAEZ,CAIA,SAAS33B,EAAkBztD,GAE1B,MAAMuV,EAAUvV,EAAMpJ,OAEtB2e,EAAQ1V,oBAAqB,UAAW4tD,GAwBzC,SAA4Bl4C,GAE3B,MAAM8vE,EAAoBrmC,EAAW3jD,IAAKka,GAE1C,QAAuC5lB,IAAlC01F,EAAkBC,YAA4B,OAInD,MAAMrvF,EAASsf,EAAQtf,OACjBsvF,EAAgBxC,EAAS1nF,IAAKpF,GAEpC,GAAKsvF,EAAgB,CAEpB,MAAMpE,EAAeoE,EAAeF,EAAkBG,YACtDrE,EAAa7X,YAImB,IAA3B6X,EAAa7X,WAEjBmc,EAAelwE,GAM6B,IAAxC3gB,OAAOyD,KAAMktF,GAAgBpyF,QAEjC4vF,EAAStwC,OAAQx8C,EAInB,CAEA+oD,EAAWtvD,OAAQ6lB,EAEpB,CA1DCmwE,CAAmBnwE,GAEdA,EAAQowE,gBAEZ7C,EAAerwC,OAAQl9B,EAIzB,CAEA,SAASqwE,EAAuB5lF,GAE/B,MAAM2sC,EAAe3sC,EAAMpJ,OAE3B+1C,EAAa9sC,oBAAqB,UAAW+lF,GA2D9C,SAAiCj5C,GAEhC,MAAMp3B,EAAUo3B,EAAap3B,QAEvBswE,EAAyB7mC,EAAW3jD,IAAKsxC,GACzC04C,EAAoBrmC,EAAW3jD,IAAKka,GAgB1C,QAd0C5lB,IAArC01F,EAAkBS,iBAEtBtD,EAAIiD,cAAeJ,EAAkBS,gBAErC38B,EAAKgL,OAAOthD,YAIR85B,EAAaj3B,cAEjBi3B,EAAaj3B,aAAazC,UAItB05B,EAAaoB,wBAEjB,IAAM,IAAIj7C,EAAI,EAAGA,EAAI,EAAGA,IAEvB0vF,EAAIuD,kBAAmBF,EAAuBG,mBAAoBlzF,IAC7D+yF,EAAuBI,oBAAqBzD,EAAI0D,mBAAoBL,EAAuBI,mBAAoBnzF,QAI/G,CAMN,GAJA0vF,EAAIuD,kBAAmBF,EAAuBG,oBACzCH,EAAuBI,oBAAqBzD,EAAI0D,mBAAoBL,EAAuBI,oBAC3FJ,EAAuBM,gCAAiC3D,EAAIuD,kBAAmBF,EAAuBM,gCAEtGN,EAAuBO,yBAE3B,IAAM,IAAItzF,EAAI,EAAGA,EAAI+yF,EAAuBO,yBAAyBjzF,OAAQL,IAEvE+yF,EAAuBO,yBAA0BtzF,IAAM0vF,EAAI0D,mBAAoBL,EAAuBO,yBAA0BtzF,IAMlI+yF,EAAuBQ,0BAA2B7D,EAAI0D,mBAAoBL,EAAuBQ,yBAEvG,CAEA,GAAK15C,EAAa0zC,6BAEjB,IAAM,IAAIvtF,EAAI,EAAGmrB,EAAK1I,EAAQpiB,OAAQL,EAAImrB,EAAInrB,IAAO,CAEpD,MAAMwzF,EAAuBtnC,EAAW3jD,IAAKka,EAASziB,IAEjDwzF,EAAqBR,iBAEzBtD,EAAIiD,cAAea,EAAqBR,gBAExC38B,EAAKgL,OAAOthD,YAIbmsC,EAAWtvD,OAAQ6lB,EAASziB,GAE7B,CAIDksD,EAAWtvD,OAAQ6lB,GACnBypC,EAAWtvD,OAAQi9C,EAEpB,CAlIC45C,CAAwB55C,EAEzB,CA0CA,SAAS84C,EAAelwE,GAEvB,MAAM8vE,EAAoBrmC,EAAW3jD,IAAKka,GAC1CitE,EAAIiD,cAAeJ,EAAkBS,gBAErC,MAAM7vF,EAASsf,EAAQtf,cACD8sF,EAAS1nF,IAAKpF,GACdovF,EAAkBG,YAExCr8B,EAAKgL,OAAOthD,UAEb,CA+EA,IAAI2zE,EAAe,EAiDnB,SAASprB,EAAc7lD,EAASkxE,GAE/B,MAAMpB,EAAoBrmC,EAAW3jD,IAAKka,GAI1C,GAFKA,EAAQowE,gBA28Cd,SAA6BpwE,GAE5B,MAAMo8B,EAAQwX,EAAKxb,OAAOgE,MAIrBmxC,EAAeznF,IAAKka,KAAco8B,IAEtCmxC,EAAe/9E,IAAKwQ,EAASo8B,GAC7Bp8B,EAAQ1b,SAIV,CAx9C+B6sF,CAAoBnxE,IAEX,IAAlCA,EAAQ9C,uBAAmC8C,EAAQlF,QAAU,GAAKg1E,EAAkBsB,YAAcpxE,EAAQlF,QAAU,CAExH,MAAMlB,EAAQoG,EAAQpG,MAEtB,GAAe,OAAVA,EAEJre,QAAQkU,KAAM,+EAER,KAAwB,IAAnBmK,EAAMy3E,SAOjB,YADAC,GAAexB,EAAmB9vE,EAASkxE,GAJ3C31F,QAAQkU,KAAM,yEAOf,CAED,CAEA0+C,EAAMo5B,YAAa0F,EAAI/E,WAAY4H,EAAkBS,eAAgBtD,EAAIvB,SAAWwF,EAErF,CA+CA,MAAMK,EAAe,CACpB,CAAE/pF,GAAkBylF,EAAIuE,OACxB,CAAE/pF,GAAuBwlF,EAAIwE,cAC7B,CAAE/pF,GAA0BulF,EAAIyE,iBAG3BC,EAAa,CAClB,CAAEhqF,GAAiBslF,EAAIvF,QACvB,CAAE9/E,GAA8BqlF,EAAI2E,uBACpC,CAAE/pF,GAA6BolF,EAAI4E,sBAEnC,CAAE/pF,GAAgBmlF,EAAI4C,OACtB,CAAE9nF,GAA6BklF,EAAI6E,sBACnC,CAAE9pF,GAA4BilF,EAAI8E,sBAG7BC,EAAc,CACnB,IAAkB/E,EAAIpJ,MACtB,IAAmBoJ,EAAInJ,OACvB,IAAiBmJ,EAAIlJ,KACrB,IAAsBkJ,EAAIjJ,OAC1B,IAAkBiJ,EAAIhJ,MACtB,IAAyBgJ,EAAI/I,OAC7B,IAAoB+I,EAAI9I,QACxB,IAAqB8I,EAAI7I,UAG1B,SAAS6N,EAAsBC,EAAalyE,EAASkuE,GAmDpD,GAjDKA,GAEJjB,EAAIzF,cAAe0K,EAAajF,EAAIkF,eAAgBZ,EAAcvxE,EAAQnE,QAC1EoxE,EAAIzF,cAAe0K,EAAajF,EAAImF,eAAgBb,EAAcvxE,EAAQlE,QAErEo2E,IAAgBjF,EAAIrF,YAAcsK,IAAgBjF,EAAIpF,kBAE1DoF,EAAIzF,cAAe0K,EAAajF,EAAIoF,eAAgBd,EAAcvxE,EAAQS,QAI3EwsE,EAAIzF,cAAe0K,EAAajF,EAAItF,mBAAoBgK,EAAY3xE,EAAQjE,YAC5EkxE,EAAIzF,cAAe0K,EAAajF,EAAIxF,mBAAoBkK,EAAY3xE,EAAQhE,cAI5EixE,EAAIzF,cAAe0K,EAAajF,EAAIkF,eAAgBlF,EAAIwE,eACxDxE,EAAIzF,cAAe0K,EAAajF,EAAImF,eAAgBnF,EAAIwE,eAEnDS,IAAgBjF,EAAIrF,YAAcsK,IAAgBjF,EAAIpF,kBAE1DoF,EAAIzF,cAAe0K,EAAajF,EAAIoF,eAAgBpF,EAAIwE,eAIpDzxE,EAAQnE,QAAUpU,GAAuBuY,EAAQlE,QAAUrU,GAE/DlM,QAAQkU,KAAM,iIAIfw9E,EAAIzF,cAAe0K,EAAajF,EAAItF,mBAAoBiI,EAAgB5vE,EAAQjE,YAChFkxE,EAAIzF,cAAe0K,EAAajF,EAAIxF,mBAAoBmI,EAAgB5vE,EAAQhE,YAE3EgE,EAAQhE,YAAcrU,GAAiBqY,EAAQhE,YAAclU,GAEjEvM,QAAQkU,KAAM,oIAMXuQ,EAAQsyE,kBAEZrF,EAAIzF,cAAe0K,EAAajF,EAAIsF,qBAAsBtF,EAAIuF,wBAC9DvF,EAAIzF,cAAe0K,EAAajF,EAAIwF,qBAAsBT,EAAahyE,EAAQsyE,oBAIpB,IAAvDx9C,EAAW+f,IAAK,kCAA8C,CAElE,MAAMjF,EAAY9a,EAAWhvC,IAAK,kCAElC,GAAKka,EAAQjE,YAAcpU,EAAgB,OAC3C,GAAKqY,EAAQhE,YAAcnU,GAA6BmY,EAAQhE,YAAchU,EAA2B,OACzG,GAAKgY,EAAQhW,OAAS5B,IAA8D,IAAjD0sC,EAAW+f,IAAK,4BAAyC,OAC5F,IAAkB,IAAbhY,GAAwB78B,EAAQhW,OAAS3B,IAAuE,IAAtDysC,EAAW+f,IAAK,iCAAgD,QAE1H70C,EAAQ9D,WAAa,GAAKutC,EAAW3jD,IAAKka,GAAU0yE,uBAExDzF,EAAI0F,cAAeT,EAAatiC,EAAUgjC,2BAA4B33F,KAAKL,IAAKolB,EAAQ9D,WAAY0gC,EAAaoZ,qBACjHvM,EAAW3jD,IAAKka,GAAU0yE,oBAAsB1yE,EAAQ9D,WAI1D,CAED,CAEA,SAAS22E,EAAa/C,EAAmB9vE,GAExC,IAAI8yE,GAAc,OAEqB14F,IAAlC01F,EAAkBC,cAEtBD,EAAkBC,aAAc,EAEhC/vE,EAAQ9mB,iBAAkB,UAAWg/D,IAMtC,MAAMx3D,EAASsf,EAAQtf,OACvB,IAAIsvF,EAAgBxC,EAAS1nF,IAAKpF,QAEXtG,IAAlB41F,IAEJA,EAAgB,CAAC,EACjBxC,EAASh+E,IAAK9O,EAAQsvF,IAMvB,MAAM+C,EAjOP,SAA6B/yE,GAE5B,MAAMtV,EAAQ,GAiBd,OAfAA,EAAMhO,KAAMsjB,EAAQnE,OACpBnR,EAAMhO,KAAMsjB,EAAQlE,OACpBpR,EAAMhO,KAAMsjB,EAAQS,OAAS,GAC7B/V,EAAMhO,KAAMsjB,EAAQjE,WACpBrR,EAAMhO,KAAMsjB,EAAQhE,WACpBtR,EAAMhO,KAAMsjB,EAAQ9D,YACpBxR,EAAMhO,KAAMsjB,EAAQvD,gBACpB/R,EAAMhO,KAAMsjB,EAAQ/D,QACpBvR,EAAMhO,KAAMsjB,EAAQhW,MACpBU,EAAMhO,KAAMsjB,EAAQpD,iBACpBlS,EAAMhO,KAAMsjB,EAAQnD,kBACpBnS,EAAMhO,KAAMsjB,EAAQlD,OACpBpS,EAAMhO,KAAMsjB,EAAQjD,iBACpBrS,EAAMhO,KAAMsjB,EAAQ/G,YAEbvO,EAAMpN,MAEd,CA4MyB01F,CAAoBhzE,GAE5C,GAAK+yE,IAAoBjD,EAAkBG,WAAa,MAIb71F,IAArC41F,EAAe+C,KAInB/C,EAAe+C,GAAoB,CAClC/yE,QAASitE,EAAI5F,gBACbtT,UAAW,GAGZngB,EAAKgL,OAAOthD,WAKZw1E,GAAc,GAIf9C,EAAe+C,GAAkBhf,YAKjC,MAAM6X,EAAeoE,EAAeF,EAAkBG,iBAEhC71F,IAAjBwxF,IAEJoE,EAAeF,EAAkBG,YAAalc,YAEd,IAA3B6X,EAAa7X,WAEjBmc,EAAelwE,IAQjB8vE,EAAkBG,WAAa8C,EAC/BjD,EAAkBS,eAAiBP,EAAe+C,GAAkB/yE,OAErE,CAEA,OAAO8yE,CAER,CAEA,SAASxB,GAAexB,EAAmB9vE,EAASkxE,GAEnD,IAAIgB,EAAcjF,EAAI/E,YAEjBloE,EAAQQ,oBAAsBR,EAAQizE,4BAA2Bf,EAAcjF,EAAIpF,kBACnF7nE,EAAQW,kBAAkBuxE,EAAcjF,EAAIrF,YAEjD,MAAMkL,EAAcD,EAAa/C,EAAmB9vE,GAC9Ctf,EAASsf,EAAQtf,OAEvBytD,EAAMo5B,YAAa2K,EAAapC,EAAkBS,eAAgBtD,EAAIvB,SAAWwF,GAEjF,MAAMgC,EAAmBzpC,EAAW3jD,IAAKpF,GAEzC,GAAKA,EAAOoa,UAAYo4E,EAAiB9B,YAA6B,IAAhB0B,EAAuB,CAE5E3kC,EAAMq9B,cAAeyB,EAAIvB,SAAWwF,GAEpCjE,EAAIkG,YAAalG,EAAImG,oBAAqBpzE,EAAQlD,OAClDmwE,EAAIkG,YAAalG,EAAIoG,+BAAgCrzE,EAAQnD,kBAC7DowE,EAAIkG,YAAalG,EAAIqG,iBAAkBtzE,EAAQjD,iBAC/CkwE,EAAIkG,YAAalG,EAAIsG,mCAAoCtG,EAAIuG,MAE7D,MAAM3F,EAtlBR,SAAiC7tE,GAEhC,OAAK68B,IAEI78B,EAAQnE,QAAUpU,GAAuBuY,EAAQlE,QAAUrU,GACjEuY,EAAQhE,YAAcrU,GAAiBqY,EAAQhE,YAAclU,EAEjE,CA+kB0B2rF,CAAwBzzE,KAAiD,IAApCguE,EAAgBhuE,EAAQpG,OACrF,IAAIA,EAAQg0E,EAAa5tE,EAAQpG,MAAOi0E,GAAiB,EAAO14B,GAChEv7C,EAAQ85E,GAAkB1zE,EAASpG,GAEnC,MAAMs0E,EAAeF,EAAgBp0E,IAAWijC,EAC/CyxC,EAAWpB,EAAMh0E,QAAS8G,EAAQ/D,OAAQ+D,EAAQ/G,YAEnD,IAKI06E,EALApF,EAASrB,EAAMh0E,QAAS8G,EAAQhW,MACnC4pF,EAAmBxF,EAAmBpuE,EAAQvD,eAAgB6xE,EAAUC,EAAQvuE,EAAQ/G,YAEzFg5E,EAAsBC,EAAalyE,EAASkuE,GAG5C,MAAM3xE,EAAUyD,EAAQzD,QAElBs3E,EAAkBh3C,IAAuC,IAA3B78B,EAAQowE,eACtC0D,OAAkD15F,IAA/B84F,EAAiB9B,YAA+C,IAAhB0B,EACnEiB,EAAStE,EAAczvE,EAASpG,EAAOs0E,GAE7C,GAAKluE,EAAQg0E,eAIZJ,EAAmB3G,EAAIgH,gBAElBp3C,EAIH+2C,EAFI5zE,EAAQhW,OAAS5B,EAEF6kF,EAAIiH,mBAEZl0E,EAAQhW,OAAS7B,EAET8kF,EAAIkH,kBAEZn0E,EAAQhW,OAAS1B,EAET2kF,EAAImH,iBAIJnH,EAAIoH,kBAMnBr0E,EAAQhW,OAAS5B,GAErB7M,QAAQ6+B,MAAO,gEAQZpa,EAAQ/D,SAAWzT,GAAeorF,IAAqB3G,EAAIgH,iBAK1Dj0E,EAAQhW,OAAS9B,GAAqB8X,EAAQhW,OAAS7B,IAE3D5M,QAAQkU,KAAM,+FAEduQ,EAAQhW,KAAO7B,EACfomF,EAASrB,EAAMh0E,QAAS8G,EAAQhW,OAM7BgW,EAAQ/D,SAAWxT,GAAsBmrF,IAAqB3G,EAAIgH,kBAItEL,EAAmB3G,EAAIqH,cAKlBt0E,EAAQhW,OAAS1B,IAErB/M,QAAQkU,KAAM,oFAEduQ,EAAQhW,KAAO1B,EACfimF,EAASrB,EAAMh0E,QAAS8G,EAAQhW,QAQ7B8pF,IAECD,EAEJ1lC,EAAMq+B,aAAcS,EAAI/E,WAAY,EAAG0L,EAAkBh6E,EAAMhK,MAAOgK,EAAM/J,QAI5Es+C,EAAM25B,WAAYmF,EAAI/E,WAAY,EAAG0L,EAAkBh6E,EAAMhK,MAAOgK,EAAM/J,OAAQ,EAAGy+E,EAAUC,EAAQ,YAMnG,GAAKvuE,EAAQ3E,cAMnB,GAAKkB,EAAQ3e,OAAS,GAAKswF,EAAe,CAEpC2F,GAAiBC,GAErB3lC,EAAMq+B,aAAcS,EAAI/E,WAAY6L,EAAQH,EAAkBr3E,EAAS,GAAI3M,MAAO2M,EAAS,GAAI1M,QAIhG,IAAM,IAAItS,EAAI,EAAGmrB,EAAKnM,EAAQ3e,OAAQL,EAAImrB,EAAInrB,IAE7Co2F,EAASp3E,EAAShf,GAEbs2F,EAEJ1lC,EAAMu+B,cAAeO,EAAI/E,WAAY3qF,EAAG,EAAG,EAAGo2F,EAAO/jF,MAAO+jF,EAAO9jF,OAAQy+E,EAAUC,EAAQoF,EAAOrzF,MAIpG6tD,EAAM25B,WAAYmF,EAAI/E,WAAY3qF,EAAGq2F,EAAkBD,EAAO/jF,MAAO+jF,EAAO9jF,OAAQ,EAAGy+E,EAAUC,EAAQoF,EAAOrzF,MAMlH0f,EAAQpD,iBAAkB,CAE3B,MAEMi3E,GAECC,GAEJ3lC,EAAMq+B,aAAcS,EAAI/E,WAAY6L,EAAQH,EAAkBh6E,EAAMhK,MAAOgK,EAAM/J,QAIlFs+C,EAAMu+B,cAAeO,EAAI/E,WAAY,EAAG,EAAG,EAAGtuE,EAAMhK,MAAOgK,EAAM/J,OAAQy+E,EAAUC,EAAQ30E,EAAMtZ,OAIjG6tD,EAAM25B,WAAYmF,EAAI/E,WAAY,EAAG0L,EAAkBh6E,EAAMhK,MAAOgK,EAAM/J,OAAQ,EAAGy+E,EAAUC,EAAQ30E,EAAMtZ,WAMzG,GAAK0f,EAAQ2vE,oBAEnB,GAAK3vE,EAAQizE,yBAA2B,CAElCY,GAAiBC,GAErB3lC,EAAMs+B,aAAcQ,EAAIpF,iBAAkBkM,EAAQH,EAAkBr3E,EAAS,GAAI3M,MAAO2M,EAAS,GAAI1M,OAAQ+J,EAAMgG,OAIpH,IAAM,IAAIriB,EAAI,EAAGmrB,EAAKnM,EAAQ3e,OAAQL,EAAImrB,EAAInrB,IAE7Co2F,EAASp3E,EAAShf,GAEbyiB,EAAQ/D,SAAW1T,EAEL,OAAb+lF,EAECuF,EAEJ1lC,EAAM0+B,wBAAyBI,EAAIpF,iBAAkBtqF,EAAG,EAAG,EAAG,EAAGo2F,EAAO/jF,MAAO+jF,EAAO9jF,OAAQ+J,EAAMgG,MAAO0uE,EAAUqF,EAAOrzF,KAAM,EAAG,GAIrI6tD,EAAM89B,qBAAsBgB,EAAIpF,iBAAkBtqF,EAAGq2F,EAAkBD,EAAO/jF,MAAO+jF,EAAO9jF,OAAQ+J,EAAMgG,MAAO,EAAG+zE,EAAOrzF,KAAM,EAAG,GAMrI/E,QAAQkU,KAAM,kGAMVokF,EAEJ1lC,EAAMw+B,cAAeM,EAAIpF,iBAAkBtqF,EAAG,EAAG,EAAG,EAAGo2F,EAAO/jF,MAAO+jF,EAAO9jF,OAAQ+J,EAAMgG,MAAO0uE,EAAUC,EAAQoF,EAAOrzF,MAI1H6tD,EAAM65B,WAAYiF,EAAIpF,iBAAkBtqF,EAAGq2F,EAAkBD,EAAO/jF,MAAO+jF,EAAO9jF,OAAQ+J,EAAMgG,MAAO,EAAG0uE,EAAUC,EAAQoF,EAAOrzF,KAQvI,KAAO,CAEDuzF,GAAiBC,GAErB3lC,EAAMq+B,aAAcS,EAAI/E,WAAY6L,EAAQH,EAAkBr3E,EAAS,GAAI3M,MAAO2M,EAAS,GAAI1M,QAIhG,IAAM,IAAItS,EAAI,EAAGmrB,EAAKnM,EAAQ3e,OAAQL,EAAImrB,EAAInrB,IAE7Co2F,EAASp3E,EAAShf,GAEbyiB,EAAQ/D,SAAW1T,EAEL,OAAb+lF,EAECuF,EAEJ1lC,EAAMy+B,wBAAyBK,EAAI/E,WAAY3qF,EAAG,EAAG,EAAGo2F,EAAO/jF,MAAO+jF,EAAO9jF,OAAQy+E,EAAUqF,EAAOrzF,MAItG6tD,EAAM49B,qBAAsBkB,EAAI/E,WAAY3qF,EAAGq2F,EAAkBD,EAAO/jF,MAAO+jF,EAAO9jF,OAAQ,EAAG8jF,EAAOrzF,MAMzG/E,QAAQkU,KAAM,kGAMVokF,EAEJ1lC,EAAMu+B,cAAeO,EAAI/E,WAAY3qF,EAAG,EAAG,EAAGo2F,EAAO/jF,MAAO+jF,EAAO9jF,OAAQy+E,EAAUC,EAAQoF,EAAOrzF,MAIpG6tD,EAAM25B,WAAYmF,EAAI/E,WAAY3qF,EAAGq2F,EAAkBD,EAAO/jF,MAAO+jF,EAAO9jF,OAAQ,EAAGy+E,EAAUC,EAAQoF,EAAOrzF,KAQpH,MAEM,GAAK0f,EAAQQ,mBAEdqzE,GAECC,GAEJ3lC,EAAMs+B,aAAcQ,EAAIpF,iBAAkBkM,EAAQH,EAAkBh6E,EAAMhK,MAAOgK,EAAM/J,OAAQ+J,EAAMgG,OAItGuuC,EAAMw+B,cAAeM,EAAIpF,iBAAkB,EAAG,EAAG,EAAG,EAAGjuE,EAAMhK,MAAOgK,EAAM/J,OAAQ+J,EAAMgG,MAAO0uE,EAAUC,EAAQ30E,EAAMtZ,OAIvH6tD,EAAM65B,WAAYiF,EAAIpF,iBAAkB,EAAG+L,EAAkBh6E,EAAMhK,MAAOgK,EAAM/J,OAAQ+J,EAAMgG,MAAO,EAAG0uE,EAAUC,EAAQ30E,EAAMtZ,WAI3H,GAAK0f,EAAQW,gBAEdkzE,GAECC,GAEJ3lC,EAAMs+B,aAAcQ,EAAIrF,WAAYmM,EAAQH,EAAkBh6E,EAAMhK,MAAOgK,EAAM/J,OAAQ+J,EAAMgG,OAIhGuuC,EAAMw+B,cAAeM,EAAIrF,WAAY,EAAG,EAAG,EAAG,EAAGhuE,EAAMhK,MAAOgK,EAAM/J,OAAQ+J,EAAMgG,MAAO0uE,EAAUC,EAAQ30E,EAAMtZ,OAIjH6tD,EAAM65B,WAAYiF,EAAIrF,WAAY,EAAGgM,EAAkBh6E,EAAMhK,MAAOgK,EAAM/J,OAAQ+J,EAAMgG,MAAO,EAAG0uE,EAAUC,EAAQ30E,EAAMtZ,WAIrH,GAAK0f,EAAQ0vE,sBAEnB,GAAKoE,EAEJ,GAAKD,EAEJ1lC,EAAMq+B,aAAcS,EAAI/E,WAAY6L,EAAQH,EAAkBh6E,EAAMhK,MAAOgK,EAAM/J,YAE3E,CAEN,IAAID,EAAQgK,EAAMhK,MAAOC,EAAS+J,EAAM/J,OAExC,IAAM,IAAItS,EAAI,EAAGA,EAAIw2F,EAAQx2F,IAE5B4wD,EAAM25B,WAAYmF,EAAI/E,WAAY3qF,EAAGq2F,EAAkBhkF,EAAOC,EAAQ,EAAGy+E,EAAUC,EAAQ,MAE3F3+E,IAAU,EACVC,IAAW,CAIb,OAYD,GAAK0M,EAAQ3e,OAAS,GAAKswF,EAAe,CAEpC2F,GAAiBC,GAErB3lC,EAAMq+B,aAAcS,EAAI/E,WAAY6L,EAAQH,EAAkBr3E,EAAS,GAAI3M,MAAO2M,EAAS,GAAI1M,QAIhG,IAAM,IAAItS,EAAI,EAAGmrB,EAAKnM,EAAQ3e,OAAQL,EAAImrB,EAAInrB,IAE7Co2F,EAASp3E,EAAShf,GAEbs2F,EAEJ1lC,EAAMu+B,cAAeO,EAAI/E,WAAY3qF,EAAG,EAAG,EAAG+wF,EAAUC,EAAQoF,GAIhExlC,EAAM25B,WAAYmF,EAAI/E,WAAY3qF,EAAGq2F,EAAkBtF,EAAUC,EAAQoF,GAM3E3zE,EAAQpD,iBAAkB,CAE3B,MAEMi3E,GAECC,GAEJ3lC,EAAMq+B,aAAcS,EAAI/E,WAAY6L,EAAQH,EAAkBh6E,EAAMhK,MAAOgK,EAAM/J,QAIlFs+C,EAAMu+B,cAAeO,EAAI/E,WAAY,EAAG,EAAG,EAAGoG,EAAUC,EAAQ30E,IAIhEu0C,EAAM25B,WAAYmF,EAAI/E,WAAY,EAAG0L,EAAkBtF,EAAUC,EAAQ30E,GAQvEq0E,EAA6BjuE,EAASkuE,IAE1CC,EAAgB+D,GAIjBgB,EAAiB9B,UAAY1wF,EAAOoa,QAE/BkF,EAAQ/C,UAAW+C,EAAQ/C,SAAU+C,EAE3C,CAEA8vE,EAAkBsB,UAAYpxE,EAAQlF,OAEvC,CAoNA,SAASy5E,GAAyB5J,EAAavzC,EAAcp3B,EAASw0E,EAAYC,GAEjF,MAAMnG,EAAWpB,EAAMh0E,QAAS8G,EAAQ/D,OAAQ+D,EAAQ/G,YAClDs1E,EAASrB,EAAMh0E,QAAS8G,EAAQhW,MAChC4pF,EAAmBxF,EAAmBpuE,EAAQvD,eAAgB6xE,EAAUC,EAAQvuE,EAAQ/G,YAC/DwwC,EAAW3jD,IAAKsxC,GAEjBs9C,wBAExBD,IAAkBxH,EAAIrF,YAAc6M,IAAkBxH,EAAIpF,iBAE9D15B,EAAM65B,WAAYyM,EAAe,EAAGb,EAAkBx8C,EAAaxnC,MAAOwnC,EAAavnC,OAAQunC,EAAax3B,MAAO,EAAG0uE,EAAUC,EAAQ,MAIxIpgC,EAAM25B,WAAY2M,EAAe,EAAGb,EAAkBx8C,EAAaxnC,MAAOwnC,EAAavnC,OAAQ,EAAGy+E,EAAUC,EAAQ,OAMtHpgC,EAAMu8B,gBAAiBuC,EAAIpC,YAAaF,GAEnCgK,GAAoBv9C,GAExB+1C,EAAmByH,mCAAoC3H,EAAIpC,YAAa2J,EAAYC,EAAehrC,EAAW3jD,IAAKka,GAAUuwE,eAAgB,EAAGsE,GAAwBz9C,KAE7Jq9C,IAAkBxH,EAAI/E,YAAgBuM,GAAiBxH,EAAI7E,6BAA+BqM,GAAiBxH,EAAI6H,8BAE1H7H,EAAI8H,qBAAsB9H,EAAIpC,YAAa2J,EAAYC,EAAehrC,EAAW3jD,IAAKka,GAAUuwE,eAAgB,GAIjHpiC,EAAMu8B,gBAAiBuC,EAAIpC,YAAa,KAEzC,CAIA,SAASmK,GAA0BC,EAAc79C,EAAc89C,GAI9D,GAFAjI,EAAIkI,iBAAkBlI,EAAImI,aAAcH,GAEnC79C,EAAan3B,cAAiBm3B,EAAal3B,cAAgB,CAE/D,IAAI0zE,EAAmB3G,EAAIoH,kBAE3B,GAAKa,GAAiBP,GAAoBv9C,GAAiB,CAE1D,MAAMj3B,EAAei3B,EAAaj3B,aAE7BA,GAAgBA,EAAa6zE,iBAE5B7zE,EAAanW,OAAS5B,EAE1BwrF,EAAmB3G,EAAIiH,mBAEZ/zE,EAAanW,OAAS7B,IAEjCyrF,EAAmB3G,EAAIkH,oBAMzB,MAAM/zE,EAAUy0E,GAAwBz9C,GAEnCu9C,GAAoBv9C,GAExB+1C,EAAmBkI,kCAAmCpI,EAAImI,aAAch1E,EAASwzE,EAAkBx8C,EAAaxnC,MAAOwnC,EAAavnC,QAIpIo9E,EAAIqI,+BAAgCrI,EAAImI,aAAch1E,EAASwzE,EAAkBx8C,EAAaxnC,MAAOwnC,EAAavnC,OAIpH,MAECo9E,EAAIsI,oBAAqBtI,EAAImI,aAAcxB,EAAkBx8C,EAAaxnC,MAAOwnC,EAAavnC,QAI/Fo9E,EAAIuI,wBAAyBvI,EAAIpC,YAAaoC,EAAIwI,iBAAkBxI,EAAImI,aAAcH,EAEvF,MAAO,GAAK79C,EAAan3B,aAAem3B,EAAal3B,cAAgB,CAEpE,MAAME,EAAUy0E,GAAwBz9C,GAEnC89C,IAAwD,IAAvCP,GAAoBv9C,GAEzC61C,EAAIqI,+BAAgCrI,EAAImI,aAAch1E,EAAS6sE,EAAImH,iBAAkBh9C,EAAaxnC,MAAOwnC,EAAavnC,QAE3G8kF,GAAoBv9C,GAE/B+1C,EAAmBkI,kCAAmCpI,EAAImI,aAAch1E,EAAS6sE,EAAImH,iBAAkBh9C,EAAaxnC,MAAOwnC,EAAavnC,QAIxIo9E,EAAIsI,oBAAqBtI,EAAImI,aAAcnI,EAAIqH,cAAel9C,EAAaxnC,MAAOwnC,EAAavnC,QAKhGo9E,EAAIuI,wBAAyBvI,EAAIpC,YAAaoC,EAAIyI,yBAA0BzI,EAAImI,aAAcH,EAE/F,KAAO,CAEN,MAAM33E,GAAyD,IAA9C85B,EAAa0zC,6BAAwC1zC,EAAap3B,QAAU,CAAEo3B,EAAap3B,SAE5G,IAAM,IAAIziB,EAAI,EAAGA,EAAI+f,EAAS1f,OAAQL,IAAO,CAE5C,MAAMyiB,EAAU1C,EAAU/f,GAEpB+wF,EAAWpB,EAAMh0E,QAAS8G,EAAQ/D,OAAQ+D,EAAQ/G,YAClDs1E,EAASrB,EAAMh0E,QAAS8G,EAAQhW,MAChC4pF,EAAmBxF,EAAmBpuE,EAAQvD,eAAgB6xE,EAAUC,EAAQvuE,EAAQ/G,YACxFmH,EAAUy0E,GAAwBz9C,GAEnC89C,IAAwD,IAAvCP,GAAoBv9C,GAEzC61C,EAAIqI,+BAAgCrI,EAAImI,aAAch1E,EAASwzE,EAAkBx8C,EAAaxnC,MAAOwnC,EAAavnC,QAEvG8kF,GAAoBv9C,GAE/B+1C,EAAmBkI,kCAAmCpI,EAAImI,aAAch1E,EAASwzE,EAAkBx8C,EAAaxnC,MAAOwnC,EAAavnC,QAIpIo9E,EAAIsI,oBAAqBtI,EAAImI,aAAcxB,EAAkBx8C,EAAaxnC,MAAOwnC,EAAavnC,OAIhG,CAED,CAEAo9E,EAAIkI,iBAAkBlI,EAAImI,aAAc,KAEzC,CAiEA,SAASO,GAAwBv+C,GAEhC,MAAMk5C,EAAyB7mC,EAAW3jD,IAAKsxC,GACzCw+C,GAAoD,IAAzCx+C,EAAaoB,wBAE9B,GAAKpB,EAAaj3B,eAAkBmwE,EAAuBuF,0BAA4B,CAEtF,GAAKD,EAAS,MAAM,IAAI1yF,MAAO,6DArEjC,SAA4BynF,EAAavzC,GAGxC,GADiBA,GAAgBA,EAAaoB,wBAChC,MAAM,IAAIt1C,MAAO,2DAI/B,GAFAirD,EAAMu8B,gBAAiBuC,EAAIpC,YAAaF,IAE/BvzC,EAAaj3B,eAAgBi3B,EAAaj3B,aAAa6zE,eAE/D,MAAM,IAAI9wF,MAAO,uEAKXumD,EAAW3jD,IAAKsxC,EAAaj3B,cAAeowE,gBACjDn5C,EAAaj3B,aAAavG,MAAMhK,QAAUwnC,EAAaxnC,OACvDwnC,EAAaj3B,aAAavG,MAAM/J,SAAWunC,EAAavnC,SAEzDunC,EAAaj3B,aAAavG,MAAMhK,MAAQwnC,EAAaxnC,MACrDwnC,EAAaj3B,aAAavG,MAAM/J,OAASunC,EAAavnC,OACtDunC,EAAaj3B,aAAapF,aAAc,GAIzC8qD,EAAczuB,EAAaj3B,aAAc,GAEzC,MAAM21E,EAAoBrsC,EAAW3jD,IAAKsxC,EAAaj3B,cAAeowE,eAChEnwE,EAAUy0E,GAAwBz9C,GAExC,GAAKA,EAAaj3B,aAAalE,SAAWzT,EAEpCmsF,GAAoBv9C,GAExB+1C,EAAmByH,mCAAoC3H,EAAIpC,YAAaoC,EAAIwI,iBAAkBxI,EAAI/E,WAAY4N,EAAmB,EAAG11E,GAIpI6sE,EAAI8H,qBAAsB9H,EAAIpC,YAAaoC,EAAIwI,iBAAkBxI,EAAI/E,WAAY4N,EAAmB,OAI/F,IAAK1+C,EAAaj3B,aAAalE,SAAWxT,EAchD,MAAM,IAAIvF,MAAO,+BAZZyxF,GAAoBv9C,GAExB+1C,EAAmByH,mCAAoC3H,EAAIpC,YAAaoC,EAAIyI,yBAA0BzI,EAAI/E,WAAY4N,EAAmB,EAAG11E,GAI5I6sE,EAAI8H,qBAAsB9H,EAAIpC,YAAaoC,EAAIyI,yBAA0BzI,EAAI/E,WAAY4N,EAAmB,EAQ9G,CAED,CAYEC,CAAmBzF,EAAuBG,mBAAoBr5C,EAE/D,MAEC,GAAKw+C,EAAS,CAEbtF,EAAuBI,mBAAqB,GAE5C,IAAM,IAAInzF,EAAI,EAAGA,EAAI,EAAGA,IAEvB4wD,EAAMu8B,gBAAiBuC,EAAIpC,YAAayF,EAAuBG,mBAAoBlzF,IACnF+yF,EAAuBI,mBAAoBnzF,GAAM0vF,EAAI+I,qBACrDhB,GAA0B1E,EAAuBI,mBAAoBnzF,GAAK65C,GAAc,EAI1F,MAEC+W,EAAMu8B,gBAAiBuC,EAAIpC,YAAayF,EAAuBG,oBAC/DH,EAAuBI,mBAAqBzD,EAAI+I,qBAChDhB,GAA0B1E,EAAuBI,mBAAoBt5C,GAAc,GAMrF+W,EAAMu8B,gBAAiBuC,EAAIpC,YAAa,KAEzC,CA+VA,SAASgK,GAAwBz9C,GAEhC,OAAOn8C,KAAKL,IAAKu7D,EAAY/e,EAAah3B,QAE3C,CAEA,SAASu0E,GAAoBv9C,GAE5B,MAAMk5C,EAAyB7mC,EAAW3jD,IAAKsxC,GAE/C,OAAOyF,GAAYzF,EAAah3B,QAAU,IAAkE,IAA7D00B,EAAW+f,IAAK,0CAAqG,IAAhDy7B,EAAuB2F,oBAE5I,CAiBA,SAASvC,GAAkB1zE,EAASpG,GAEnC,MAAMX,EAAa+G,EAAQ/G,WACrBgD,EAAS+D,EAAQ/D,OACjBjS,EAAOgW,EAAQhW,KAErB,OAAqC,IAAhCgW,EAAQ2vE,qBAAgC3vE,EAAQ/D,SAAWrS,IAE3DqP,IAAe1P,IArrxBD,KAqrxByB0P,IAItCA,IAAe3P,IAED,IAAbuzC,GAIkC,IAAjC/H,EAAW+f,IAAK,aAAyB54C,IAAW1T,GAExDyX,EAAQ/D,OAASrS,GAIjBoW,EAAQhE,UAAYlU,EACpBkY,EAAQpD,iBAAkB,GAM1BhD,EAAQF,GAAWw8E,aAAct8E,GAQ7BqC,IAAW1T,GAAcyB,IAAS/B,GAEtC1M,QAAQkU,KAAM,2FAQhBlU,QAAQ6+B,MAAO,wDAAyDnhB,IA3CYW,CAmDvF,CAIA3c,KAAKimE,oBApkDL,WAEC,MAAMizB,EAAclF,EAUpB,OARKkF,GAAephC,GAEnBx5D,QAAQkU,KAAM,sCAAwC0mF,EAAc,+CAAiDphC,GAItHk8B,GAAgB,EAETkF,CAER,EAujDAl5F,KAAKm5F,kBA3kDL,WAECnF,EAAe,CAEhB,EAykDAh0F,KAAK4oE,aAAeA,EACpB5oE,KAAKkpE,kBAhgDL,SAA4BnmD,EAASkxE,GAEpC,MAAMpB,EAAoBrmC,EAAW3jD,IAAKka,GAErCA,EAAQlF,QAAU,GAAKg1E,EAAkBsB,YAAcpxE,EAAQlF,QAEnEw2E,GAAexB,EAAmB9vE,EAASkxE,GAK5C/iC,EAAMo5B,YAAa0F,EAAIpF,iBAAkBiI,EAAkBS,eAAgBtD,EAAIvB,SAAWwF,EAE3F,EAo/CAj0F,KAAK8oE,aAl/CL,SAAuB/lD,EAASkxE,GAE/B,MAAMpB,EAAoBrmC,EAAW3jD,IAAKka,GAErCA,EAAQlF,QAAU,GAAKg1E,EAAkBsB,YAAcpxE,EAAQlF,QAEnEw2E,GAAexB,EAAmB9vE,EAASkxE,GAK5C/iC,EAAMo5B,YAAa0F,EAAIrF,WAAYkI,EAAkBS,eAAgBtD,EAAIvB,SAAWwF,EAErF,EAs+CAj0F,KAAKgpE,eAp+CL,SAAyBjmD,EAASkxE,GAEjC,MAAMpB,EAAoBrmC,EAAW3jD,IAAKka,GAErCA,EAAQlF,QAAU,GAAKg1E,EAAkBsB,YAAcpxE,EAAQlF,QA8lBrE,SAA4Bg1E,EAAmB9vE,EAASkxE,GAEvD,GAA8B,IAAzBlxE,EAAQpG,MAAMhc,OAAe,OAElC,MAAMk1F,EAAcD,EAAa/C,EAAmB9vE,GAC9Ctf,EAASsf,EAAQtf,OAEvBytD,EAAMo5B,YAAa0F,EAAI9E,iBAAkB2H,EAAkBS,eAAgBtD,EAAIvB,SAAWwF,GAE1F,MAAMgC,EAAmBzpC,EAAW3jD,IAAKpF,GAEzC,GAAKA,EAAOoa,UAAYo4E,EAAiB9B,YAA6B,IAAhB0B,EAAuB,CAE5E3kC,EAAMq9B,cAAeyB,EAAIvB,SAAWwF,GAEpCjE,EAAIkG,YAAalG,EAAImG,oBAAqBpzE,EAAQlD,OAClDmwE,EAAIkG,YAAalG,EAAIoG,+BAAgCrzE,EAAQnD,kBAC7DowE,EAAIkG,YAAalG,EAAIqG,iBAAkBtzE,EAAQjD,iBAC/CkwE,EAAIkG,YAAalG,EAAIsG,mCAAoCtG,EAAIuG,MAE7D,MAAM6C,EAAiBr2E,EAAQ2vE,qBAAuB3vE,EAAQpG,MAAO,GAAI+1E,oBACnEt0E,EAAkB2E,EAAQpG,MAAO,IAAOoG,EAAQpG,MAAO,GAAIyB,cAE3Di7E,EAAY,GAElB,IAAM,IAAI/4F,EAAI,EAAGA,EAAI,EAAGA,IAQtB+4F,EAAW/4F,GANL84F,GAAkBh7E,EAMPA,EAAgB2E,EAAQpG,MAAOrc,GAAIqc,MAAQoG,EAAQpG,MAAOrc,GAJ1DqwF,EAAa5tE,EAAQpG,MAAOrc,IAAK,GAAO,EAAM83D,GAQhEihC,EAAW/4F,GAAMm2F,GAAkB1zE,EAASs2E,EAAW/4F,IAIxD,MAAMqc,EAAQ08E,EAAW,GACxBpI,EAAeF,EAAgBp0E,IAAWijC,EAC1CyxC,EAAWpB,EAAMh0E,QAAS8G,EAAQ/D,OAAQ+D,EAAQ/G,YAClDs1E,EAASrB,EAAMh0E,QAAS8G,EAAQhW,MAChC4pF,EAAmBxF,EAAmBpuE,EAAQvD,eAAgB6xE,EAAUC,EAAQvuE,EAAQ/G,YAEnF46E,EAAkBh3C,IAAuC,IAA3B78B,EAAQowE,eACtC0D,OAAkD15F,IAA/B84F,EAAiB9B,YAA+C,IAAhB0B,EACzE,IAIIv2E,EAJAw3E,EAAStE,EAAczvE,EAASpG,EAAOs0E,GAM3C,GAJA+D,EAAsBhF,EAAI9E,iBAAkBnoE,EAASkuE,GAIhDmI,EAAe,CAEdxC,GAAiBC,GAErB3lC,EAAMq+B,aAAcS,EAAI9E,iBAAkB4L,EAAQH,EAAkBh6E,EAAMhK,MAAOgK,EAAM/J,QAIxF,IAAM,IAAItS,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9Bgf,EAAU+5E,EAAW/4F,GAAIgf,QAEzB,IAAM,IAAI8P,EAAI,EAAGA,EAAI9P,EAAQ3e,OAAQyuB,IAAO,CAE3C,MAAMsnE,EAASp3E,EAAS8P,GAEnBrM,EAAQ/D,SAAW1T,EAEL,OAAb+lF,EAECuF,EAEJ1lC,EAAMy+B,wBAAyBK,EAAI7E,4BAA8B7qF,EAAG8uB,EAAG,EAAG,EAAGsnE,EAAO/jF,MAAO+jF,EAAO9jF,OAAQy+E,EAAUqF,EAAOrzF,MAI3H6tD,EAAM49B,qBAAsBkB,EAAI7E,4BAA8B7qF,EAAG8uB,EAAGunE,EAAkBD,EAAO/jF,MAAO+jF,EAAO9jF,OAAQ,EAAG8jF,EAAOrzF,MAM9H/E,QAAQkU,KAAM,mGAMVokF,EAEJ1lC,EAAMu+B,cAAeO,EAAI7E,4BAA8B7qF,EAAG8uB,EAAG,EAAG,EAAGsnE,EAAO/jF,MAAO+jF,EAAO9jF,OAAQy+E,EAAUC,EAAQoF,EAAOrzF,MAIzH6tD,EAAM25B,WAAYmF,EAAI7E,4BAA8B7qF,EAAG8uB,EAAGunE,EAAkBD,EAAO/jF,MAAO+jF,EAAO9jF,OAAQ,EAAGy+E,EAAUC,EAAQoF,EAAOrzF,KAMxI,CAED,CAED,KAAO,CAENic,EAAUyD,EAAQzD,QAEbs3E,GAAiBC,IAMhBv3E,EAAQ3e,OAAS,GAAIm2F,IAE1B5lC,EAAMq+B,aAAcS,EAAI9E,iBAAkB4L,EAAQH,EAAkB0C,EAAW,GAAI1mF,MAAO0mF,EAAW,GAAIzmF,SAI1G,IAAM,IAAItS,EAAI,EAAGA,EAAI,EAAGA,IAEvB,GAAK8d,EAAgB,CAEfw4E,EAEJ1lC,EAAMu+B,cAAeO,EAAI7E,4BAA8B7qF,EAAG,EAAG,EAAG,EAAG+4F,EAAW/4F,GAAIqS,MAAO0mF,EAAW/4F,GAAIsS,OAAQy+E,EAAUC,EAAQ+H,EAAW/4F,GAAI+C,MAIjJ6tD,EAAM25B,WAAYmF,EAAI7E,4BAA8B7qF,EAAG,EAAGq2F,EAAkB0C,EAAW/4F,GAAIqS,MAAO0mF,EAAW/4F,GAAIsS,OAAQ,EAAGy+E,EAAUC,EAAQ+H,EAAW/4F,GAAI+C,MAI9J,IAAM,IAAI+rB,EAAI,EAAGA,EAAI9P,EAAQ3e,OAAQyuB,IAAO,CAE3C,MACMkqE,EADSh6E,EAAS8P,GACGzS,MAAOrc,GAAIqc,MAEjCi6E,EAEJ1lC,EAAMu+B,cAAeO,EAAI7E,4BAA8B7qF,EAAG8uB,EAAI,EAAG,EAAG,EAAGkqE,EAAY3mF,MAAO2mF,EAAY1mF,OAAQy+E,EAAUC,EAAQgI,EAAYj2F,MAI5I6tD,EAAM25B,WAAYmF,EAAI7E,4BAA8B7qF,EAAG8uB,EAAI,EAAGunE,EAAkB2C,EAAY3mF,MAAO2mF,EAAY1mF,OAAQ,EAAGy+E,EAAUC,EAAQgI,EAAYj2F,KAI1J,CAED,KAAO,CAEDuzF,EAEJ1lC,EAAMu+B,cAAeO,EAAI7E,4BAA8B7qF,EAAG,EAAG,EAAG,EAAG+wF,EAAUC,EAAQ+H,EAAW/4F,IAIhG4wD,EAAM25B,WAAYmF,EAAI7E,4BAA8B7qF,EAAG,EAAGq2F,EAAkBtF,EAAUC,EAAQ+H,EAAW/4F,IAI1G,IAAM,IAAI8uB,EAAI,EAAGA,EAAI9P,EAAQ3e,OAAQyuB,IAAO,CAE3C,MAAMsnE,EAASp3E,EAAS8P,GAEnBwnE,EAEJ1lC,EAAMu+B,cAAeO,EAAI7E,4BAA8B7qF,EAAG8uB,EAAI,EAAG,EAAG,EAAGiiE,EAAUC,EAAQoF,EAAO/5E,MAAOrc,IAIvG4wD,EAAM25B,WAAYmF,EAAI7E,4BAA8B7qF,EAAG8uB,EAAI,EAAGunE,EAAkBtF,EAAUC,EAAQoF,EAAO/5E,MAAOrc,GAIlH,CAED,CAIF,CAEK0wF,EAA6BjuE,EAASkuE,IAG1CC,EAAgBlB,EAAI9E,kBAIrB+K,EAAiB9B,UAAY1wF,EAAOoa,QAE/BkF,EAAQ/C,UAAW+C,EAAQ/C,SAAU+C,EAE3C,CAEA8vE,EAAkBsB,UAAYpxE,EAAQlF,OAEvC,CAzyBE07E,CAAmB1G,EAAmB9vE,EAASkxE,GAKhD/iC,EAAMo5B,YAAa0F,EAAI9E,iBAAkB2H,EAAkBS,eAAgBtD,EAAIvB,SAAWwF,EAE3F,EAw9CAj0F,KAAKw5F,eA7bL,SAAyBr/C,EAAcs/C,EAAcv2E,GAEpD,MAAMmwE,EAAyB7mC,EAAW3jD,IAAKsxC,QAEzBh9C,IAAjBs8F,GAEJnC,GAAyBjE,EAAuBG,mBAAoBr5C,EAAcA,EAAap3B,QAASitE,EAAIlC,kBAAmBkC,EAAI/E,iBAI9G9tF,IAAjB+lB,GAEJw1E,GAAwBv+C,EAI1B,EA8aAn6C,KAAK05F,kBA3aL,SAA4Bv/C,GAE3B,MAAMp3B,EAAUo3B,EAAap3B,QAEvBswE,EAAyB7mC,EAAW3jD,IAAKsxC,GACzC04C,EAAoBrmC,EAAW3jD,IAAKka,GAE1Co3B,EAAal+C,iBAAkB,UAAWm3F,IAES,IAA9Cj5C,EAAa0zC,oCAEyB1wF,IAArC01F,EAAkBS,iBAEtBT,EAAkBS,eAAiBtD,EAAI5F,iBAIxCyI,EAAkBsB,UAAYpxE,EAAQlF,QACtC84C,EAAKgL,OAAOthD,YAIb,MAAMs4E,GAAoD,IAAzCx+C,EAAaoB,wBACxBo+C,GAA0E,IAA9Cx/C,EAAa0zC,6BACzCoD,EAAeF,EAAgB52C,IAAkByF,EAIvD,GAAK+4C,EAAS,CAEbtF,EAAuBG,mBAAqB,GAE5C,IAAM,IAAIlzF,EAAI,EAAGA,EAAI,EAAGA,IAEvB+yF,EAAuBG,mBAAoBlzF,GAAM0vF,EAAI4J,mBAIvD,KAAO,CAIN,GAFAvG,EAAuBG,mBAAqBxD,EAAI4J,oBAE3CD,EAEJ,GAAKh6C,EAAa3H,YAAc,CAE/B,MAAM33B,EAAW85B,EAAap3B,QAE9B,IAAM,IAAIziB,EAAI,EAAGmrB,EAAKpL,EAAS1f,OAAQL,EAAImrB,EAAInrB,IAAO,CAErD,MAAMwzF,EAAuBtnC,EAAW3jD,IAAKwX,EAAU/f,SAEVnD,IAAxC22F,EAAqBR,iBAEzBQ,EAAqBR,eAAiBtD,EAAI5F,gBAE1CzzB,EAAKgL,OAAOthD,WAId,CAED,MAEC/hB,QAAQkU,KAAM,iHAMhB,GAAOotC,GAAYzF,EAAah3B,QAAU,IAA8C,IAAvCu0E,GAAoBv9C,GAA2B,CAE/F,MAAM95B,EAAWs5E,EAA0B52E,EAAU,CAAEA,GAEvDswE,EAAuBM,+BAAiC3D,EAAI4J,oBAC5DvG,EAAuBO,yBAA2B,GAElD1iC,EAAMu8B,gBAAiBuC,EAAIpC,YAAayF,EAAuBM,gCAE/D,IAAM,IAAIrzF,EAAI,EAAGA,EAAI+f,EAAS1f,OAAQL,IAAO,CAE5C,MAAMyiB,EAAU1C,EAAU/f,GAC1B+yF,EAAuBO,yBAA0BtzF,GAAM0vF,EAAI+I,qBAE3D/I,EAAIkI,iBAAkBlI,EAAImI,aAAc9E,EAAuBO,yBAA0BtzF,IAEzF,MAAM+wF,EAAWpB,EAAMh0E,QAAS8G,EAAQ/D,OAAQ+D,EAAQ/G,YAClDs1E,EAASrB,EAAMh0E,QAAS8G,EAAQhW,MAChC4pF,EAAmBxF,EAAmBpuE,EAAQvD,eAAgB6xE,EAAUC,EAAQvuE,EAAQ/G,YAA8C,IAAlCm+B,EAAa6hC,kBACjH74D,EAAUy0E,GAAwBz9C,GACxC61C,EAAIqI,+BAAgCrI,EAAImI,aAAch1E,EAASwzE,EAAkBx8C,EAAaxnC,MAAOwnC,EAAavnC,QAElHo9E,EAAIuI,wBAAyBvI,EAAIpC,YAAaoC,EAAIlC,kBAAoBxtF,EAAG0vF,EAAImI,aAAc9E,EAAuBO,yBAA0BtzF,GAE7I,CAEA0vF,EAAIkI,iBAAkBlI,EAAImI,aAAc,MAEnCh+C,EAAan3B,cAEjBqwE,EAAuBQ,yBAA2B7D,EAAI+I,qBACtDhB,GAA0B1E,EAAuBQ,yBAA0B15C,GAAc,IAI1F+W,EAAMu8B,gBAAiBuC,EAAIpC,YAAa,KAEzC,CAED,CAIA,GAAK+K,EAAS,CAEbznC,EAAMo5B,YAAa0F,EAAI9E,iBAAkB2H,EAAkBS,gBAC3D0B,EAAsBhF,EAAI9E,iBAAkBnoE,EAASkuE,GAErD,IAAM,IAAI3wF,EAAI,EAAGA,EAAI,EAAGA,IAEvBg3F,GAAyBjE,EAAuBG,mBAAoBlzF,GAAK65C,EAAcp3B,EAASitE,EAAIlC,kBAAmBkC,EAAI7E,4BAA8B7qF,GAIrJ0wF,EAA6BjuE,EAASkuE,IAE1CC,EAAgBlB,EAAI9E,kBAIrBh6B,EAAM29B,eAEP,MAAO,GAAK8K,EAA0B,CAErC,MAAMt5E,EAAW85B,EAAap3B,QAE9B,IAAM,IAAIziB,EAAI,EAAGmrB,EAAKpL,EAAS1f,OAAQL,EAAImrB,EAAInrB,IAAO,CAErD,MAAMi3F,EAAal3E,EAAU/f,GACvBwzF,EAAuBtnC,EAAW3jD,IAAK0uF,GAE7CrmC,EAAMo5B,YAAa0F,EAAI/E,WAAY6I,EAAqBR,gBACxD0B,EAAsBhF,EAAI/E,WAAYsM,EAAYtG,GAClDqG,GAAyBjE,EAAuBG,mBAAoBr5C,EAAco9C,EAAYvH,EAAIlC,kBAAoBxtF,EAAG0vF,EAAI/E,YAExH+F,EAA6BuG,EAAYtG,IAE7CC,EAAgBlB,EAAI/E,WAItB,CAEA/5B,EAAM29B,eAEP,KAAO,CAEN,IAAIgL,EAAgB7J,EAAI/E,YAEnB9wC,EAAa2/C,uBAAyB3/C,EAAa4/C,4BAElDn6C,EAEJi6C,EAAgB1/C,EAAa2/C,sBAAwB9J,EAAIrF,WAAaqF,EAAIpF,iBAI1EtsF,QAAQ6+B,MAAO,oGAMjB+zB,EAAMo5B,YAAauP,EAAehH,EAAkBS,gBACpD0B,EAAsB6E,EAAe92E,EAASkuE,GAC9CqG,GAAyBjE,EAAuBG,mBAAoBr5C,EAAcp3B,EAASitE,EAAIlC,kBAAmB+L,GAE7G7I,EAA6BjuE,EAASkuE,IAE1CC,EAAgB2I,GAIjB3oC,EAAM29B,eAEP,CAIK10C,EAAan3B,aAEjB01E,GAAwBv+C,EAI1B,EAyOAn6C,KAAKg6F,yBAvOL,SAAmC7/C,GAElC,MAAM82C,EAAeF,EAAgB52C,IAAkByF,EAEjDv/B,GAAyD,IAA9C85B,EAAa0zC,6BAAwC1zC,EAAap3B,QAAU,CAAEo3B,EAAap3B,SAE5G,IAAM,IAAIziB,EAAI,EAAGmrB,EAAKpL,EAAS1f,OAAQL,EAAImrB,EAAInrB,IAAO,CAErD,MAAMyiB,EAAU1C,EAAU/f,GAE1B,GAAK0wF,EAA6BjuE,EAASkuE,GAAiB,CAE3D,MAAM7sF,EAAS+1C,EAAaoB,wBAA0By0C,EAAI9E,iBAAmB8E,EAAI/E,WAC3E0D,EAAeniC,EAAW3jD,IAAKka,GAAUuwE,eAE/CpiC,EAAMo5B,YAAalmF,EAAQuqF,GAC3BuC,EAAgB9sF,GAChB8sD,EAAM29B,eAEP,CAED,CAED,EAiNA7uF,KAAKi6F,8BA/ML,SAAwC9/C,GAEvC,GAAOyF,GAAYzF,EAAah3B,QAAU,IAA8C,IAAvCu0E,GAAoBv9C,GAA2B,CAE/F,MAAM95B,EAAW85B,EAAa0zC,6BAA+B1zC,EAAap3B,QAAU,CAAEo3B,EAAap3B,SAC7FpQ,EAAQwnC,EAAaxnC,MACrBC,EAASunC,EAAavnC,OAC5B,IAAI2mB,EAAOy2D,EAAIkK,iBACf,MAAMC,EAAoB,GACpBC,EAAajgD,EAAal3B,cAAgB+sE,EAAIyI,yBAA2BzI,EAAIwI,iBAC7EnF,EAAyB7mC,EAAW3jD,IAAKsxC,GACzCw/C,GAA0E,IAA9Cx/C,EAAa0zC,6BAG/C,GAAK8L,EAEJ,IAAM,IAAIr5F,EAAI,EAAGA,EAAI+f,EAAS1f,OAAQL,IAErC4wD,EAAMu8B,gBAAiBuC,EAAIpC,YAAayF,EAAuBM,gCAC/D3D,EAAIuI,wBAAyBvI,EAAIpC,YAAaoC,EAAIlC,kBAAoBxtF,EAAG0vF,EAAImI,aAAc,MAE3FjnC,EAAMu8B,gBAAiBuC,EAAIpC,YAAayF,EAAuBG,oBAC/DxD,EAAI8H,qBAAsB9H,EAAIrC,iBAAkBqC,EAAIlC,kBAAoBxtF,EAAG0vF,EAAI/E,WAAY,KAAM,GAMnG/5B,EAAMu8B,gBAAiBuC,EAAIF,iBAAkBuD,EAAuBM,gCACpEziC,EAAMu8B,gBAAiBuC,EAAIrC,iBAAkB0F,EAAuBG,oBAEpE,IAAM,IAAIlzF,EAAI,EAAGA,EAAI+f,EAAS1f,OAAQL,IAAO,CAE5C65F,EAAkB16F,KAAMuwF,EAAIlC,kBAAoBxtF,GAE3C65C,EAAan3B,aAEjBm3E,EAAkB16F,KAAM26F,GAIzB,MAAMC,OAAqEl9F,IAA/Ck2F,EAAuBiH,qBAAsCjH,EAAuBiH,oBAsBhH,IApB2B,IAAtBD,IAEClgD,EAAan3B,cAAcuW,GAAQy2D,EAAIuK,kBACvCpgD,EAAal3B,gBAAgBsW,GAAQy2D,EAAIwK,qBAI1Cb,GAEJ3J,EAAIuI,wBAAyBvI,EAAIF,iBAAkBE,EAAIlC,kBAAmBkC,EAAImI,aAAc9E,EAAuBO,yBAA0BtzF,KAInH,IAAtB+5F,IAEJrK,EAAIyK,sBAAuBzK,EAAIF,iBAAkB,CAAEsK,IACnDpK,EAAIyK,sBAAuBzK,EAAIrC,iBAAkB,CAAEyM,KAI/CT,EAA0B,CAE9B,MAAMhL,EAAeniC,EAAW3jD,IAAKwX,EAAU/f,IAAMgzF,eACrDtD,EAAI8H,qBAAsB9H,EAAIrC,iBAAkBqC,EAAIlC,kBAAmBkC,EAAI/E,WAAY0D,EAAc,EAEtG,CAEAqB,EAAI0K,gBAAiB,EAAG,EAAG/nF,EAAOC,EAAQ,EAAG,EAAGD,EAAOC,EAAQ2mB,EAAMy2D,EAAIvF,SAEpE0F,GAEJH,EAAIyK,sBAAuBzK,EAAIF,iBAAkBqK,EAKnD,CAMA,GAJAjpC,EAAMu8B,gBAAiBuC,EAAIF,iBAAkB,MAC7C5+B,EAAMu8B,gBAAiBuC,EAAIrC,iBAAkB,MAGxCgM,EAEJ,IAAM,IAAIr5F,EAAI,EAAGA,EAAI+f,EAAS1f,OAAQL,IAAO,CAE5C4wD,EAAMu8B,gBAAiBuC,EAAIpC,YAAayF,EAAuBM,gCAC/D3D,EAAIuI,wBAAyBvI,EAAIpC,YAAaoC,EAAIlC,kBAAoBxtF,EAAG0vF,EAAImI,aAAc9E,EAAuBO,yBAA0BtzF,IAE5I,MAAMquF,EAAeniC,EAAW3jD,IAAKwX,EAAU/f,IAAMgzF,eAErDpiC,EAAMu8B,gBAAiBuC,EAAIpC,YAAayF,EAAuBG,oBAC/DxD,EAAI8H,qBAAsB9H,EAAIrC,iBAAkBqC,EAAIlC,kBAAoBxtF,EAAG0vF,EAAI/E,WAAY0D,EAAc,EAE1G,CAIDz9B,EAAMu8B,gBAAiBuC,EAAIrC,iBAAkB0F,EAAuBM,+BAErE,CAED,EAuGA3zF,KAAK04F,uBAAyBA,GAC9B14F,KAAKs3F,wBAA0BA,GAC/Bt3F,KAAK03F,mBAAqBA,EAE3B,CAEA,SAASiD,GAAYj7C,EAAI7H,EAAY8H,GAEpC,MAAMC,EAAWD,EAAaC,SA4Q9B,MAAO,CAAE3jC,QA1QT,SAAkByc,EAAG1c,EAAamD,IAEjC,IAAIwzC,EAEJ,GAAKj6B,IAAM1tB,EAAmB,OAAO00C,EAAGuB,cACxC,GAz0xB4B,OAy0xBvBvoB,EAA8B,OAAOgnB,EAAG0yC,uBAC7C,GAz0xB4B,OAy0xBvB15D,EAA8B,OAAOgnB,EAAG4yC,uBAE7C,GAn1xBe,OAm1xBV55D,EAAiB,OAAOgnB,EAAGsB,KAChC,GAn1xBgB,OAm1xBXtoB,EAAkB,OAAOgnB,EAAGmB,MACjC,GAAKnoB,IAAMztB,EAAoB,OAAOy0C,EAAGkB,eACzC,GAn1xBc,OAm1xBTloB,EAAgB,OAAOgnB,EAAGqB,IAC/B,GAAKroB,IAAMxtB,EAAkB,OAAOw0C,EAAGoB,aACvC,GAAKpoB,IAAMvtB,EAAY,OAAOu0C,EAAGe,MAEjC,GAAK/nB,IAAMttB,EAEV,OAAKw0C,EAAkBF,EAAGiB,YAE1BgS,EAAY9a,EAAWhvC,IAAK,0BAET,OAAd8pD,EAEGA,EAAUioC,eAIV,MAMT,GAl2xBkB,OAk2xBbliE,EAAoB,OAAOgnB,EAAGm7C,MACnC,GAAKniE,IAAMptB,EAAa,OAAOo0C,EAAGorC,KAClC,GAl2xBsB,OAk2xBjBpyD,EAAwB,OAAOgnB,EAAGo7C,UACvC,GAl2xB2B,OAk2xBtBpiE,EAA6B,OAAOgnB,EAAGq7C,gBAC5C,GAAKriE,IAAMntB,EAAc,OAAOm0C,EAAGs3C,gBACnC,GAAKt+D,IAAMltB,EAAqB,OAAOk0C,EAAG23C,cAI1C,GAAK3+D,IAAM/rB,GAIV,OAFAgmD,EAAY9a,EAAWhvC,IAAK,YAET,OAAd8pD,EAEGA,EAAUqoC,eAIV,KAQT,GAv3xBgB,OAu3xBXtiE,EAAkB,OAAOgnB,EAAG8xC,IACjC,GAv3xBuB,OAu3xBlB94D,EAAyB,OAAOgnB,EAAGu7C,YACxC,GAv3xBe,OAu3xBVviE,EAAiB,OAAOgnB,EAAGkyC,GAChC,GAv3xBsB,OAu3xBjBl5D,EAAwB,OAAOgnB,EAAGw7C,WACvC,GAv3xBwB,OAu3xBnBxiE,EAA0B,OAAOgnB,EAAGy7C,aAIzC,GAAKziE,IAAMjtB,GAAwBitB,IAAMhtB,GAAyBgtB,IAAM/sB,GAAyB+sB,IAAM9sB,EAEtG,GAAKoQ,IAAe3P,GAAiB,CAIpC,GAFAsmD,EAAY9a,EAAWhvC,IAAK,sCAET,OAAd8pD,EASJ,OAAO,KAPP,GAAKj6B,IAAMjtB,EAAuB,OAAOknD,EAAUyoC,8BACnD,GAAK1iE,IAAMhtB,EAAwB,OAAOinD,EAAU0oC,oCACpD,GAAK3iE,IAAM/sB,EAAwB,OAAOgnD,EAAU2oC,oCACpD,GAAK5iE,IAAM9sB,EAAwB,OAAO+mD,EAAU4oC,mCAQtD,KAAO,CAIN,GAFA5oC,EAAY9a,EAAWhvC,IAAK,iCAET,OAAd8pD,EASJ,OAAO,KAPP,GAAKj6B,IAAMjtB,EAAuB,OAAOknD,EAAU6oC,6BACnD,GAAK9iE,IAAMhtB,EAAwB,OAAOinD,EAAU8oC,8BACpD,GAAK/iE,IAAM/sB,EAAwB,OAAOgnD,EAAU+oC,8BACpD,GAAKhjE,IAAM9sB,EAAwB,OAAO+mD,EAAUgpC,6BAQtD,CAMD,GA/5xB8B,QA+5xBzBjjE,GA95xByB,QA85xBQA,GA75xBP,QA65xBwCA,GA55xBxC,QA45xB0EA,EAAiC,CAIzI,GAFAi6B,EAAY9a,EAAWhvC,IAAK,kCAET,OAAd8pD,EASJ,OAAO,KAPP,GAr6xB4B,QAq6xBvBj6B,EAAgC,OAAOi6B,EAAUipC,gCACtD,GAr6xB4B,QAq6xBvBljE,EAAgC,OAAOi6B,EAAUkpC,gCACtD,GAr6xB6B,QAq6xBxBnjE,EAAiC,OAAOi6B,EAAUmpC,iCACvD,GAr6xB6B,QAq6xBxBpjE,EAAiC,OAAOi6B,EAAUopC,gCAQzD,CAIA,GAh7xBsB,QAg7xBjBrjE,EAIJ,OAFAi6B,EAAY9a,EAAWhvC,IAAK,iCAET,OAAd8pD,EAEGA,EAAUqpC,0BAIV,KAQT,GAj8xBsB,QAi8xBjBtjE,GAh8xBsB,QAg8xBGA,EAA6B,CAI1D,GAFAi6B,EAAY9a,EAAWhvC,IAAK,gCAET,OAAd8pD,EAOJ,OAAO,KALP,GAv8xBoB,QAu8xBfj6B,EAAwB,OAAS1c,IAAe3P,GAAmBsmD,EAAUspC,sBAAwBtpC,EAAUupC,qBACpH,GAv8xByB,QAu8xBpBxjE,EAA6B,OAAS1c,IAAe3P,GAAmBsmD,EAAUwpC,iCAAmCxpC,EAAUypC,yBAQtI,CAIA,GAl9xB2B,QAk9xBtB1jE,GAj9xBsB,QAi9xBQA,GAh9xBR,QAg9xBsCA,GA/8xBtC,QAg9xB1BA,GA/8xB0B,QA+8xBIA,GA98xBJ,QA88xBkCA,GA78xBlC,QA88xB1BA,GA78xB0B,QA68xBIA,GA58xBH,QA48xBiCA,GA38xBjC,QA48xB3BA,GA38xB2B,QA28xBIA,GA18xBH,QA08xBkCA,GAz8xBlC,QA08xB5BA,GAz8xB4B,QAy8xBIA,EAA+B,CAI/D,GAFAi6B,EAAY9a,EAAWhvC,IAAK,iCAET,OAAd8pD,EAmBJ,OAAO,KAjBP,GA59xByB,QA49xBpBj6B,EAA6B,OAAS1c,IAAe3P,GAAmBsmD,EAAU0pC,qCAAuC1pC,EAAU2pC,6BACxI,GA59xByB,QA49xBpB5jE,EAA6B,OAAS1c,IAAe3P,GAAmBsmD,EAAU4pC,qCAAuC5pC,EAAU6pC,6BACxI,GA59xByB,QA49xBpB9jE,EAA6B,OAAS1c,IAAe3P,GAAmBsmD,EAAU8pC,qCAAuC9pC,EAAU+pC,6BACxI,GA59xByB,QA49xBpBhkE,EAA6B,OAAS1c,IAAe3P,GAAmBsmD,EAAUgqC,qCAAuChqC,EAAUiqC,6BACxI,GA59xByB,QA49xBpBlkE,EAA6B,OAAS1c,IAAe3P,GAAmBsmD,EAAUkqC,qCAAuClqC,EAAUmqC,6BACxI,GA59xByB,QA49xBpBpkE,EAA6B,OAAS1c,IAAe3P,GAAmBsmD,EAAUoqC,qCAAuCpqC,EAAUqqC,6BACxI,GA59xByB,QA49xBpBtkE,EAA6B,OAAS1c,IAAe3P,GAAmBsmD,EAAUsqC,qCAAuCtqC,EAAUuqC,6BACxI,GA59xByB,QA49xBpBxkE,EAA6B,OAAS1c,IAAe3P,GAAmBsmD,EAAUwqC,qCAAuCxqC,EAAUyqC,6BACxI,GA59xB0B,QA49xBrB1kE,EAA8B,OAAS1c,IAAe3P,GAAmBsmD,EAAU0qC,sCAAwC1qC,EAAU2qC,8BAC1I,GA59xB0B,QA49xBrB5kE,EAA8B,OAAS1c,IAAe3P,GAAmBsmD,EAAU4qC,sCAAwC5qC,EAAU6qC,8BAC1I,GA59xB0B,QA49xBrB9kE,EAA8B,OAAS1c,IAAe3P,GAAmBsmD,EAAU8qC,sCAAwC9qC,EAAU+qC,8BAC1I,GA59xB2B,QA49xBtBhlE,EAA+B,OAAS1c,IAAe3P,GAAmBsmD,EAAUgrC,uCAAyChrC,EAAUirC,+BAC5I,GA59xB2B,QA49xBtBllE,EAA+B,OAAS1c,IAAe3P,GAAmBsmD,EAAUkrC,uCAAyClrC,EAAUmrC,+BAC5I,GA59xB2B,QA49xBtBplE,EAA+B,OAAS1c,IAAe3P,GAAmBsmD,EAAUorC,uCAAyCprC,EAAUqrC,8BAQ9I,CAIA,GAAKtlE,IAAM7sB,EAAmB,CAI7B,GAFA8mD,EAAY9a,EAAWhvC,IAAK,gCAET,OAAd8pD,EAMJ,OAAO,KAJP,GAAKj6B,IAAM7sB,EAAmB,OAASmQ,IAAe3P,GAAmBsmD,EAAUsrC,qCAAuCtrC,EAAUurC,8BAQtI,CAIA,GAx/xBuB,QAw/xBlBxlE,GAv/xByB,QAu/xBCA,GAt/xBF,QAs/xBmCA,GAr/xB5B,QAq/xB4DA,EAAsC,CAIrI,GAFAi6B,EAAY9a,EAAWhvC,IAAK,gCAET,OAAd8pD,EASJ,OAAO,KAPP,GAAKj6B,IAAM7sB,EAAmB,OAAO8mD,EAAUwrC,yBAC/C,GA9/xB4B,QA8/xBvBzlE,EAAgC,OAAOi6B,EAAUyrC,gCACtD,GA9/xB2B,QA8/xBtB1lE,EAA+B,OAAOi6B,EAAU0rC,+BACrD,GA9/xBkC,QA8/xB7B3lE,EAAsC,OAAOi6B,EAAU2rC,qCAQ9D,CAIA,OAAK5lE,IAAMrtB,EAELu0C,EAAkBF,EAAG6+C,mBAE1B5rC,EAAY9a,EAAWhvC,IAAK,uBAET,OAAd8pD,EAEGA,EAAU6rC,wBAIV,WAQYrhG,IAAZuiD,EAAIhnB,GAAsBgnB,EAAIhnB,GAAM,IAE9C,EAID,CAEA,MAAM+lE,WAAoBjmD,GAEzBj2C,YAAakL,EAAQ,IAEpB2R,QAEApf,KAAK0+F,eAAgB,EAErB1+F,KAAK26C,QAAUltC,CAEhB,EAID,MAAMkxF,WAAc/jE,GAEnBr4B,cAEC6c,QAEApf,KAAK4+F,SAAU,EAEf5+F,KAAK+M,KAAO,OAEb,EAID,MAAM8xF,GAAa,CAAE9xF,KAAM,QAE3B,MAAM+xF,GAELv8F,cAECvC,KAAK++F,WAAa,KAClB/+F,KAAKg/F,MAAQ,KACbh/F,KAAKi/F,MAAQ,IAEd,CAEAC,eAaC,OAXoB,OAAfl/F,KAAKi/F,QAETj/F,KAAKi/F,MAAQ,IAAIN,GACjB3+F,KAAKi/F,MAAMv/E,kBAAmB,EAC9B1f,KAAKi/F,MAAMzjE,SAAU,EAErBx7B,KAAKi/F,MAAME,OAAS,CAAC,EACrBn/F,KAAKi/F,MAAMG,WAAa,CAAEC,UAAU,IAI9Br/F,KAAKi/F,KAEb,CAEAK,oBAcC,OAZyB,OAApBt/F,KAAK++F,aAET/+F,KAAK++F,WAAa,IAAIJ,GACtB3+F,KAAK++F,WAAWr/E,kBAAmB,EACnC1f,KAAK++F,WAAWvjE,SAAU,EAC1Bx7B,KAAK++F,WAAWQ,mBAAoB,EACpCv/F,KAAK++F,WAAWS,eAAiB,IAAI,GACrCx/F,KAAK++F,WAAWU,oBAAqB,EACrCz/F,KAAK++F,WAAWW,gBAAkB,IAAI,IAIhC1/F,KAAK++F,UAEb,CAEAY,eAcC,OAZoB,OAAf3/F,KAAKg/F,QAETh/F,KAAKg/F,MAAQ,IAAIL,GACjB3+F,KAAKg/F,MAAMt/E,kBAAmB,EAC9B1f,KAAKg/F,MAAMxjE,SAAU,EACrBx7B,KAAKg/F,MAAMO,mBAAoB,EAC/Bv/F,KAAKg/F,MAAMQ,eAAiB,IAAI,GAChCx/F,KAAKg/F,MAAMS,oBAAqB,EAChCz/F,KAAKg/F,MAAMU,gBAAkB,IAAI,IAI3B1/F,KAAKg/F,KAEb,CAEAzxF,cAAeC,GAoBd,OAlByB,OAApBxN,KAAK++F,YAET/+F,KAAK++F,WAAWxxF,cAAeC,GAIZ,OAAfxN,KAAKg/F,OAETh/F,KAAKg/F,MAAMzxF,cAAeC,GAIP,OAAfxN,KAAKi/F,OAETj/F,KAAKi/F,MAAM1xF,cAAeC,GAIpBxN,IAER,CAEA4/F,QAASC,GAER,GAAKA,GAAeA,EAAYC,KAAO,CAEtC,MAAMA,EAAO9/F,KAAKi/F,MAElB,GAAKa,EAEJ,IAAM,MAAMC,KAAcF,EAAYC,KAAKx/D,SAG1CtgC,KAAKggG,cAAeF,EAAMC,EAM7B,CAIA,OAFA//F,KAAKuN,cAAe,CAAER,KAAM,YAAa1J,KAAMw8F,IAExC7/F,IAER,CAEAigG,WAAYJ,GAsBX,OApBA7/F,KAAKuN,cAAe,CAAER,KAAM,eAAgB1J,KAAMw8F,IAEzB,OAApB7/F,KAAK++F,aAET/+F,KAAK++F,WAAWvjE,SAAU,GAIP,OAAfx7B,KAAKg/F,QAETh/F,KAAKg/F,MAAMxjE,SAAU,GAIF,OAAfx7B,KAAKi/F,QAETj/F,KAAKi/F,MAAMzjE,SAAU,GAIfx7B,IAER,CAEAqH,OAAQw4F,EAAa1gD,EAAO+gD,GAE3B,IAAIC,EAAY,KACZC,EAAW,KACXC,EAAW,KAEf,MAAMC,EAAYtgG,KAAK++F,WACjBwB,EAAOvgG,KAAKg/F,MACZc,EAAO9/F,KAAKi/F,MAElB,GAAKY,GAAiD,oBAAlC1gD,EAAMqhD,QAAQC,gBAAwC,CAEzE,GAAKX,GAAQD,EAAYC,KAAO,CAE/BO,GAAW,EAEX,IAAM,MAAMN,KAAcF,EAAYC,KAAKx/D,SAAW,CAGrD,MAAMogE,EAAYvhD,EAAMwhD,aAAcZ,EAAYG,GAG5CU,EAAQ5gG,KAAKggG,cAAeF,EAAMC,GAErB,OAAdW,IAEJE,EAAMjmF,OAAOjF,UAAWgrF,EAAUG,UAAUlmF,QAC5CimF,EAAMjmF,OAAOid,UAAWgpE,EAAMxzE,SAAUwzE,EAAM3mF,SAAU2mF,EAAMxmF,OAC9DwmF,EAAMvlE,wBAAyB,EAC/BulE,EAAME,YAAcJ,EAAUj2E,QAI/Bm2E,EAAMplE,QAAwB,OAAdklE,CAEjB,CAKA,MAAMK,EAAWjB,EAAKX,OAAQ,oBACxB6B,EAAWlB,EAAKX,OAAQ,aACxBziE,EAAWqkE,EAAS3zE,SAASnY,WAAY+rF,EAAS5zE,UAElD6zE,EAAkB,IAClBC,EAAY,KAEbpB,EAAKV,WAAWC,UAAY3iE,EAAWukE,EAAkBC,GAE7DpB,EAAKV,WAAWC,UAAW,EAC3Br/F,KAAKuN,cAAe,CACnBR,KAAM,WACNo0F,WAAYtB,EAAYsB,WACxB/8F,OAAQpE,SAGI8/F,EAAKV,WAAWC,UAAY3iE,GAAYukE,EAAkBC,IAEvEpB,EAAKV,WAAWC,UAAW,EAC3Br/F,KAAKuN,cAAe,CACnBR,KAAM,aACNo0F,WAAYtB,EAAYsB,WACxB/8F,OAAQpE,OAKX,MAEe,OAATugG,GAAiBV,EAAYuB,YAEjChB,EAAWjhD,EAAMkiD,QAASxB,EAAYuB,UAAWlB,GAE/B,OAAbE,IAEJG,EAAK5lF,OAAOjF,UAAW0qF,EAASS,UAAUlmF,QAC1C4lF,EAAK5lF,OAAOid,UAAW2oE,EAAKnzE,SAAUmzE,EAAKtmF,SAAUsmF,EAAKnmF,OAC1DmmF,EAAKllE,wBAAyB,EAEzB+kE,EAASZ,gBAEbe,EAAKhB,mBAAoB,EACzBgB,EAAKf,eAAepsF,KAAMgtF,EAASZ,iBAInCe,EAAKhB,mBAAoB,EAIrBa,EAASV,iBAEba,EAAKd,oBAAqB,EAC1Bc,EAAKb,gBAAgBtsF,KAAMgtF,EAASV,kBAIpCa,EAAKd,oBAAqB,IAUX,OAAda,IAEJH,EAAYhhD,EAAMkiD,QAASxB,EAAYyB,eAAgBpB,GAGpC,OAAdC,GAAmC,OAAbC,IAE1BD,EAAYC,GAIM,OAAdD,IAEJG,EAAU3lF,OAAOjF,UAAWyqF,EAAUU,UAAUlmF,QAChD2lF,EAAU3lF,OAAOid,UAAW0oE,EAAUlzE,SAAUkzE,EAAUrmF,SAAUqmF,EAAUlmF,OAC9EkmF,EAAUjlE,wBAAyB,EAE9B8kE,EAAUX,gBAEdc,EAAUf,mBAAoB,EAC9Be,EAAUd,eAAepsF,KAAM+sF,EAAUX,iBAIzCc,EAAUf,mBAAoB,EAI1BY,EAAUT,iBAEdY,EAAUb,oBAAqB,EAC/Ba,EAAUZ,gBAAgBtsF,KAAM+sF,EAAUT,kBAI1CY,EAAUb,oBAAqB,EAIhCz/F,KAAKuN,cAAesxF,KAOvB,CAoBA,OAlBmB,OAAdyB,IAEJA,EAAU9kE,QAA0B,OAAd2kE,GAIT,OAATI,IAEJA,EAAK/kE,QAAyB,OAAb4kE,GAIJ,OAATN,IAEJA,EAAKtkE,QAAyB,OAAb6kE,GAIXrgG,IAER,CAIAggG,cAAeF,EAAMC,GAEpB,QAA6C5iG,IAAxC2iG,EAAKX,OAAQY,EAAWwB,WAA4B,CAExD,MAAMX,EAAQ,IAAIjC,GAClBiC,EAAMlhF,kBAAmB,EACzBkhF,EAAMplE,SAAU,EAChBskE,EAAKX,OAAQY,EAAWwB,WAAcX,EAEtCd,EAAK9iG,IAAK4jG,EAEX,CAEA,OAAOd,EAAKX,OAAQY,EAAWwB,UAEhC,EAID,MAAMC,WAAqBhjF,GAE1Bjc,YAAaoQ,EAAOC,EAAQ7F,EAAM2R,EAASE,EAAOC,EAAOC,EAAWC,EAAWE,EAAYD,GAI1F,IAFAA,OAAoB7hB,IAAX6hB,EAAuBA,EAASzT,KAEzBA,GAAeyT,IAAWxT,EAEzC,MAAM,IAAIvF,MAAO,yFAIJ9I,IAAT4P,GAAsBiS,IAAWzT,IAAcwB,EAAO7B,QAC7C/N,IAAT4P,GAAsBiS,IAAWxT,IAAqBuB,EAAO1B,GAElE+T,MAAO,KAAMV,EAASE,EAAOC,EAAOC,EAAWC,EAAWC,EAAQjS,EAAMkS,GAExEjf,KAAK+2F,gBAAiB,EAEtB/2F,KAAK2c,MAAQ,CAAEhK,MAAOA,EAAOC,OAAQA,GAErC5S,KAAK8e,eAA0B3hB,IAAd2hB,EAA0BA,EAAYpU,EACvD1K,KAAK+e,eAA0B5hB,IAAd4hB,EAA0BA,EAAYrU,EAEvD1K,KAAK6f,OAAQ,EACb7f,KAAK2f,iBAAkB,EAEvB3f,KAAKq1F,gBAAkB,IAExB,CAGAjiF,KAAM3P,GAML,OAJA2b,MAAMhM,KAAM3P,GAEZzD,KAAKq1F,gBAAkB5xF,EAAO4xF,gBAEvBr1F,IAER,CAEA+d,OAAQC,GAEP,MAAM3a,EAAO+b,MAAMrB,OAAQC,GAI3B,OAF8B,OAAzBhe,KAAKq1F,kBAA2BhyF,EAAKgyF,gBAAkBr1F,KAAKq1F,iBAE1DhyF,CAER,EAID,MAAMo+F,WAAqB30F,GAE1BvK,YAAay0C,EAAU0I,GAEtBtgC,QAEA,MAAMo2B,EAAQx1C,KAEd,IAAIwgG,EAAU,KAEVkB,EAAyB,EAEzBxB,EAAiB,KACjByB,EAAqB,cAErBC,EAAY,EACZC,EAAuB,KAEvBC,EAAO,KACPC,EAAY,KACZC,EAAc,KACdC,EAAc,KACdC,EAAU,KACd,MAAMv8F,EAAa+5C,EAAGyiD,uBACtB,IAAIC,EAAsB,KACtBC,EAAkB,KAEtB,MAAMC,EAAc,GACdC,EAAyB,GAIzBC,EAAU,IAAIhqD,GACpBgqD,EAAQ3oE,OAAOL,OAAQ,GACvBgpE,EAAQ1/E,SAAW,IAAIjC,GAEvB,MAAM4hF,EAAU,IAAIjqD,GACpBiqD,EAAQ5oE,OAAOL,OAAQ,GACvBipE,EAAQ3/E,SAAW,IAAIjC,GAEvB,MAAM85B,EAAU,CAAE6nD,EAASC,GAErBC,EAAW,IAAIjE,GACrBiE,EAAS7oE,OAAOL,OAAQ,GACxBkpE,EAAS7oE,OAAOL,OAAQ,GAExB,IAAImpE,EAAoB,KACpBC,EAAmB,KAwDvB,SAASC,EAAgBr1F,GAExB,MAAMs1F,EAAkBP,EAAuBp1F,QAASK,EAAMqyF,aAE9D,IAA2B,IAAtBiD,EAEJ,OAID,MAAMC,EAAaT,EAAaQ,QAEZ3lG,IAAf4lG,IAEJA,EAAW17F,OAAQmG,EAAMqyF,YAAaryF,EAAM2xC,MAAO0iD,GAAwB3B,GAC3E6C,EAAWx1F,cAAe,CAAER,KAAMS,EAAMT,KAAM1J,KAAMmK,EAAMqyF,cAI5D,CAEA,SAASmD,IAERxC,EAAQnzF,oBAAqB,SAAUw1F,GACvCrC,EAAQnzF,oBAAqB,cAAew1F,GAC5CrC,EAAQnzF,oBAAqB,YAAaw1F,GAC1CrC,EAAQnzF,oBAAqB,UAAWw1F,GACxCrC,EAAQnzF,oBAAqB,eAAgBw1F,GAC7CrC,EAAQnzF,oBAAqB,aAAcw1F,GAC3CrC,EAAQnzF,oBAAqB,MAAO21F,GACpCxC,EAAQnzF,oBAAqB,qBAAsB41F,GAEnD,IAAM,IAAI3iG,EAAI,EAAGA,EAAIgiG,EAAY3hG,OAAQL,IAAO,CAE/C,MAAMu/F,EAAc0C,EAAwBjiG,GAEvB,OAAhBu/F,IAEL0C,EAAwBjiG,GAAM,KAE9BgiG,EAAahiG,GAAI2/F,WAAYJ,GAE9B,CAEA8C,EAAoB,KACpBC,EAAmB,KAInB5rD,EAASkE,gBAAiBknD,GAE1BH,EAAc,KACdD,EAAc,KACdD,EAAY,KACZvB,EAAU,KACV6B,EAAkB,KAIlBliE,EAAUkf,OAEV7J,EAAM0tD,cAAe,EAErB1tD,EAAMjoC,cAAe,CAAER,KAAM,cAE9B,CAqLA,SAASk2F,EAAsBz1F,GAI9B,IAAM,IAAIlN,EAAI,EAAGA,EAAIkN,EAAM21F,QAAQxiG,OAAQL,IAAO,CAEjD,MAAMu/F,EAAcryF,EAAM21F,QAAS7iG,GAC7BvC,EAAQwkG,EAAuBp1F,QAAS0yF,GAEzC9hG,GAAS,IAEbwkG,EAAwBxkG,GAAU,KAClCukG,EAAavkG,GAAQkiG,WAAYJ,GAInC,CAIA,IAAM,IAAIv/F,EAAI,EAAGA,EAAIkN,EAAM41F,MAAMziG,OAAQL,IAAO,CAE/C,MAAMu/F,EAAcryF,EAAM41F,MAAO9iG,GAEjC,IAAIwiG,EAAkBP,EAAuBp1F,QAAS0yF,GAEtD,IAA2B,IAAtBiD,EAA0B,CAI9B,IAAM,IAAIxiG,EAAI,EAAGA,EAAIgiG,EAAY3hG,OAAQL,IAAO,CAE/C,GAAKA,GAAKiiG,EAAuB5hG,OAAS,CAEzC4hG,EAAuB9iG,KAAMogG,GAC7BiD,EAAkBxiG,EAClB,KAED,CAAO,GAAqC,OAAhCiiG,EAAwBjiG,GAAe,CAElDiiG,EAAwBjiG,GAAMu/F,EAC9BiD,EAAkBxiG,EAClB,KAED,CAED,CAIA,IAA2B,IAAtBwiG,EAA0B,KAEhC,CAEA,MAAMC,EAAaT,EAAaQ,GAE3BC,GAEJA,EAAWnD,QAASC,EAItB,CAED,CA1WA7/F,KAAKqjG,kBAAmB,EACxBrjG,KAAK6b,SAAU,EAEf7b,KAAKkjG,cAAe,EAEpBljG,KAAKsjG,cAAgB,SAAWvlG,GAE/B,IAAIglG,EAAaT,EAAavkG,GAS9B,YAPoBZ,IAAf4lG,IAEJA,EAAa,IAAIjE,GACjBwD,EAAavkG,GAAUglG,GAIjBA,EAAWzD,mBAEnB,EAEAt/F,KAAKujG,kBAAoB,SAAWxlG,GAEnC,IAAIglG,EAAaT,EAAavkG,GAS9B,YAPoBZ,IAAf4lG,IAEJA,EAAa,IAAIjE,GACjBwD,EAAavkG,GAAUglG,GAIjBA,EAAWpD,cAEnB,EAEA3/F,KAAKwjG,QAAU,SAAWzlG,GAEzB,IAAIglG,EAAaT,EAAavkG,GAS9B,YAPoBZ,IAAf4lG,IAEJA,EAAa,IAAIjE,GACjBwD,EAAavkG,GAAUglG,GAIjBA,EAAW7D,cAEnB,EAuEAl/F,KAAKyjG,0BAA4B,SAAWrmG,GAE3CskG,EAAyBtkG,GAEG,IAAvBo4C,EAAM0tD,cAEV5kG,QAAQkU,KAAM,wEAIhB,EAEAxS,KAAK0jG,sBAAwB,SAAWtmG,GAEvCukG,EAAqBvkG,GAEO,IAAvBo4C,EAAM0tD,cAEV5kG,QAAQkU,KAAM,2EAIhB,EAEAxS,KAAK2jG,kBAAoB,WAExB,OAAO9B,GAAwB3B,CAEhC,EAEAlgG,KAAK4jG,kBAAoB,SAAWC,GAEnChC,EAAuBgC,CAExB,EAEA7jG,KAAK8jG,aAAe,WAEnB,OAAuB,OAAhB9B,EAAuBA,EAAcC,CAE7C,EAEAjiG,KAAK+jG,WAAa,WAEjB,OAAOhC,CAER,EAEA/hG,KAAKgkG,SAAW,WAEf,OAAO9B,CAER,EAEAliG,KAAKikG,WAAa,WAEjB,OAAOzD,CAER,EAEAxgG,KAAKkkG,WAAaC,eAAiB/mG,GAIlC,GAFAojG,EAAUpjG,EAEO,OAAZojG,EAAmB,CAmBvB,GAjBA4B,EAAsBprD,EAASC,kBAE/BupD,EAAQvkG,iBAAkB,SAAU4mG,GACpCrC,EAAQvkG,iBAAkB,cAAe4mG,GACzCrC,EAAQvkG,iBAAkB,YAAa4mG,GACvCrC,EAAQvkG,iBAAkB,UAAW4mG,GACrCrC,EAAQvkG,iBAAkB,eAAgB4mG,GAC1CrC,EAAQvkG,iBAAkB,aAAc4mG,GACxCrC,EAAQvkG,iBAAkB,MAAO+mG,GACjCxC,EAAQvkG,iBAAkB,qBAAsBgnG,IAEf,IAA5Bt9F,EAAWy+F,oBAET1kD,EAAG2kD,wBAI4BlnG,IAA/BqjG,EAAQve,YAAYpoD,SAA+D,IAAnCmd,EAAS2I,aAAaC,SAAuB,CAEnG,MAAM0kD,EAAY,CACjBC,eAA4CpnG,IAA/BqjG,EAAQve,YAAYpoD,QAAyBl0B,EAAW4+F,UACrElvF,OAAO,EACPsN,MAAOhd,EAAWgd,MAClBk5B,QAASl2C,EAAWk2C,QACpB6lD,uBAAwBA,GAGzBO,EAAc,IAAIuC,aAAchE,EAAS9gD,EAAI4kD,GAE7C9D,EAAQiE,kBAAmB,CAAEC,UAAWzC,IAExCI,EAAkB,IAAI5/E,GACrBw/E,EAAY0C,iBACZ1C,EAAY2C,kBACZ,CACC5lF,OAAQ1T,EACRyB,KAAM/B,EACNgR,WAAYg7B,EAASE,iBACrBj0B,cAAetd,EAAWk2C,SAI7B,KAAO,CAEN,IAAIgpD,EAAc,KACdC,EAAY,KACZC,EAAgB,KAEfp/F,EAAWgd,QAEfoiF,EAAgBp/F,EAAWk2C,QAAU6D,EAAGy3C,iBAAmBz3C,EAAGw3C,kBAC9D2N,EAAcl/F,EAAWk2C,QAAUrwC,EAAqBD,EACxDu5F,EAAYn/F,EAAWk2C,QAAUxwC,EAAqBH,GAIvD,MAAM85F,EAAsB,CAC3BC,YAAavlD,EAAGyyC,MAChB0S,YAAaE,EACb/kB,YAAa0hB,GAGdK,EAAY,IAAImD,eAAgB1E,EAAS9gD,GAEzCsiD,EAAcD,EAAUoD,sBAAuBH,GAE/CxE,EAAQiE,kBAAmB,CAAE5qE,OAAQ,CAAEmoE,KAEvCK,EAAkB,IAAI5/E,GACrBu/E,EAAYoD,aACZpD,EAAYqD,cACZ,CACCrmF,OAAQ1T,EACRyB,KAAM/B,EACNkY,aAAc,IAAIs+E,GAAcQ,EAAYoD,aAAcpD,EAAYqD,cAAeP,OAAW3nG,OAAWA,OAAWA,OAAWA,OAAWA,OAAWA,EAAW0nG,GAClK5hF,cAAetd,EAAWk2C,QAC1B7/B,WAAYg7B,EAASE,iBACrB/zB,QAASxd,EAAW4+F,UAAY,EAAI,IAGPvtD,EAASwV,WAAW3jD,IAAKw5F,GACjC/H,oBAAsB0H,EAAY3H,iBAE1D,CAEAgI,EAAgBrmB,kBAAmB,EAEnCh8E,KAAKslG,aAAc1D,GAEnBC,EAAuB,KACvB3B,QAAuBM,EAAQ+E,sBAAuB5D,GAEtDxhE,EAAUqf,WAAYghD,GACtBrgE,EAAU+O,QAEVsG,EAAM0tD,cAAe,EAErB1tD,EAAMjoC,cAAe,CAAER,KAAM,gBAE9B,CAED,EAEA/M,KAAKkyD,wBAA0B,WAE9B,GAAiB,OAAZsuC,EAEJ,OAAOA,EAAQgF,oBAIjB,EAsEA,MAAMC,EAAa,IAAI,GACjBC,EAAa,IAAI,GA0DvB,SAASC,EAAcz8E,EAAQ4R,GAEd,OAAXA,EAEJ5R,EAAOK,YAAYnW,KAAM8V,EAAOvO,QAIhCuO,EAAOK,YAAYhS,iBAAkBujB,EAAOvR,YAAaL,EAAOvO,QAIjEuO,EAAOC,mBAAmB/V,KAAM8V,EAAOK,aAActQ,QAEtD,CAEAjZ,KAAK2lG,aAAe,SAAWz8E,GAE9B,GAAiB,OAAZs3E,EAAmB,OAExBkC,EAASpqE,KAAOmqE,EAAQnqE,KAAOkqE,EAAQlqE,KAAOpP,EAAOoP,KACrDoqE,EAASnqE,IAAMkqE,EAAQlqE,IAAMiqE,EAAQjqE,IAAMrP,EAAOqP,IAE7CoqE,IAAsBD,EAASpqE,MAAQsqE,IAAqBF,EAASnqE,MAIzEioE,EAAQiE,kBAAmB,CAC1BmB,UAAWlD,EAASpqE,KACpButE,SAAUnD,EAASnqE,MAGpBoqE,EAAoBD,EAASpqE,KAC7BsqE,EAAmBF,EAASnqE,KAI7B,MAAMuC,EAAS5R,EAAO4R,OAChB6f,EAAU+nD,EAAS/nD,QAEzBgrD,EAAcjD,EAAU5nE,GAExB,IAAM,IAAIx6B,EAAI,EAAGA,EAAIq6C,EAAQh6C,OAAQL,IAEpCqlG,EAAchrD,EAASr6C,GAAKw6B,GAML,IAAnB6f,EAAQh6C,OApGd,SAAiCuoB,EAAQs5E,EAASC,GAEjDgD,EAAW36E,sBAAuB03E,EAAQj5E,aAC1Cm8E,EAAW56E,sBAAuB23E,EAAQl5E,aAE1C,MAAMu8E,EAAML,EAAWxwF,WAAYywF,GAE7BK,EAAQvD,EAAQp5E,iBAAiBnV,SACjC+xF,EAAQvD,EAAQr5E,iBAAiBnV,SAKjCqkB,EAAOytE,EAAO,KAASA,EAAO,IAAO,GACrCxtE,EAAMwtE,EAAO,KAASA,EAAO,IAAO,GACpCE,GAAWF,EAAO,GAAM,GAAMA,EAAO,GACrCG,GAAcH,EAAO,GAAM,GAAMA,EAAO,GAExCI,GAAYJ,EAAO,GAAM,GAAMA,EAAO,GACtCK,GAAaJ,EAAO,GAAM,GAAMA,EAAO,GACvC9tE,EAAOI,EAAO6tE,EACdhuE,EAAQG,EAAO8tE,EAIfC,EAAUP,IAAUK,EAAUC,GAC9BE,EAAUD,GAAYF,EAG5B3D,EAAQj5E,YAAYqO,UAAW1O,EAAOkE,SAAUlE,EAAO7D,WAAY6D,EAAO9O,OAC1E8O,EAAOyT,WAAY2pE,GACnBp9E,EAAO2T,WAAYwpE,GACnBn9E,EAAOK,YAAY+L,QAASpM,EAAOkE,SAAUlE,EAAO7D,WAAY6D,EAAO9O,OACvE8O,EAAOC,mBAAmB/V,KAAM8V,EAAOK,aAActQ,SAKrD,MAAMstF,EAAQjuE,EAAO+tE,EACfG,EAAOjuE,EAAM8tE,EACbI,EAAQvuE,EAAOouE,EACfI,EAASvuE,GAAU2tE,EAAMQ,GACzBK,EAAOV,EAAS1tE,EAAMiuE,EAAOD,EAC7BK,EAAUV,EAAY3tE,EAAMiuE,EAAOD,EAEzCr9E,EAAOE,iBAAiB6O,gBAAiBwuE,EAAOC,EAAQC,EAAMC,EAASL,EAAOC,GAC9Et9E,EAAOI,wBAAwBlW,KAAM8V,EAAOE,kBAAmBnQ,QAEhE,CAsDE4tF,CAAwBnE,EAAUF,EAASC,GAM3CC,EAASt5E,iBAAiBhW,KAAMovF,EAAQp5E,kBAU1C,SAA2BF,EAAQw5E,EAAU5nE,GAE5B,OAAXA,EAEJ5R,EAAOvO,OAAOvH,KAAMsvF,EAASn5E,cAI7BL,EAAOvO,OAAOvH,KAAM0nB,EAAOvR,aAC3BL,EAAOvO,OAAO1B,SACdiQ,EAAOvO,OAAO/G,SAAU8uF,EAASn5E,cAIlCL,EAAOvO,OAAOid,UAAW1O,EAAOkE,SAAUlE,EAAO7D,WAAY6D,EAAO9O,OACpE8O,EAAOkV,mBAAmB,GAE1B,MAAM/Q,EAAWnE,EAAOmE,SAExB,IAAM,IAAI/sB,EAAI,EAAGoN,EAAI2f,EAAS1sB,OAAQL,EAAIoN,EAAGpN,IAE5C+sB,EAAU/sB,GAAI89B,mBAAmB,GAIlClV,EAAOE,iBAAiBhW,KAAMsvF,EAASt5E,kBACvCF,EAAOI,wBAAwBlW,KAAMsvF,EAASp5E,yBAEzCJ,EAAOyvB,sBAEXzvB,EAAOuvB,IAAgB,EAAV3qC,GAAc9P,KAAKs7C,KAAM,EAAIpwB,EAAOE,iBAAiBnV,SAAU,IAC5EiV,EAAO0vB,KAAO,EAIhB,CAvCCkuD,CAAkB59E,EAAQw5E,EAAU5nE,EAErC,EAuCA96B,KAAK+mG,UAAY,WAEhB,OAAOrE,CAER,EAEA1iG,KAAKgnG,aAAe,WAEnB,GAAqB,OAAhBhF,GAAwC,OAAhBC,EAM7B,OAAOL,CAER,EAEA5hG,KAAKslG,aAAe,SAAWloG,GAK9BwkG,EAAYxkG,EAES,OAAhB4kG,IAEJA,EAAYiF,eAAiB7pG,GAIT,OAAhB6kG,QAAuD9kG,IAA/B8kG,EAAYgF,iBAExChF,EAAYgF,eAAiB7pG,EAI/B,EAIA,IAAI8pG,EAA2B,KAuH/B,MAAM/mE,EAAY,IAAI0e,GAEtB1e,EAAUof,kBAvHV,SAA2BL,EAAMC,GAKhC,GAHA2iD,EAAO3iD,EAAMgoD,cAAetF,GAAwB3B,GACpDgC,EAAU/iD,EAEI,OAAT2iD,EAAgB,CAEpB,MAAMsF,EAAQtF,EAAKsF,MAEE,OAAhBnF,IAEJjrD,EAASqwD,2BAA4BhF,EAAiBJ,EAAYvU,aAClE12C,EAASkE,gBAAiBmnD,IAI3B,IAAIiF,GAAsB,EAIrBF,EAAMzmG,SAAW+hG,EAAS/nD,QAAQh6C,SAEtC+hG,EAAS/nD,QAAQh6C,OAAS,EAC1B2mG,GAAsB,GAIvB,IAAM,IAAIhnG,EAAI,EAAGA,EAAI8mG,EAAMzmG,OAAQL,IAAO,CAEzC,MAAMw4C,EAAOsuD,EAAO9mG,GAEpB,IAAIwiB,EAAW,KAEf,GAAqB,OAAhBm/E,EAEJn/E,EAAWm/E,EAAYvc,YAAa5sC,OAE9B,CAEN,MAAMyuD,EAAaxF,EAAUyF,gBAAiBxF,EAAalpD,GAC3Dh2B,EAAWykF,EAAWzkF,SAGX,IAANxiB,IAEJ02C,EAASywD,wBACRpF,EACAkF,EAAW9N,aACXuI,EAAY3H,uBAAoBl9F,EAAYoqG,EAAWG,qBAExD1wD,EAASkE,gBAAiBmnD,GAI5B,CAEA,IAAIn5E,EAASyxB,EAASr6C,QAENnD,IAAX+rB,IAEJA,EAAS,IAAIsvB,GACbtvB,EAAO2Q,OAAOL,OAAQl5B,GACtB4oB,EAAOpG,SAAW,IAAIjC,GACtB85B,EAASr6C,GAAM4oB,GAIhBA,EAAOvO,OAAOjF,UAAWojC,EAAK+nD,UAAUlmF,QACxCuO,EAAOvO,OAAOid,UAAW1O,EAAOkE,SAAUlE,EAAO7D,WAAY6D,EAAO9O,OACpE8O,EAAOE,iBAAiB1T,UAAWojC,EAAK1vB,kBACxCF,EAAOI,wBAAwBlW,KAAM8V,EAAOE,kBAAmBnQ,SAC/DiQ,EAAOpG,SAASvQ,IAAKuQ,EAASxmB,EAAGwmB,EAAStmB,EAAGsmB,EAASnQ,MAAOmQ,EAASlQ,QAE3D,IAANtS,IAEJoiG,EAAS/nF,OAAOvH,KAAM8V,EAAOvO,QAC7B+nF,EAAS/nF,OAAOid,UAAW8qE,EAASt1E,SAAUs1E,EAASr9E,WAAYq9E,EAAStoF,SAIhD,IAAxBktF,GAEJ5E,EAAS/nD,QAAQl7C,KAAMypB,EAIzB,CAED,CAIA,IAAM,IAAI5oB,EAAI,EAAGA,EAAIgiG,EAAY3hG,OAAQL,IAAO,CAE/C,MAAMu/F,EAAc0C,EAAwBjiG,GACtCyiG,EAAaT,EAAahiG,GAEX,OAAhBu/F,QAAuC1iG,IAAf4lG,GAE5BA,EAAW17F,OAAQw4F,EAAa1gD,EAAO0iD,GAAwB3B,EAIjE,CAEKgH,GAA2BA,EAA0BhoD,EAAMC,GAE3DA,EAAMwoD,gBAEVnyD,EAAMjoC,cAAe,CAAER,KAAM,iBAAkB1J,KAAM87C,IAItD+iD,EAAU,IAEX,IAMAliG,KAAKu/C,iBAAmB,SAAWt3B,GAElCi/E,EAA2Bj/E,CAE5B,EAEAjoB,KAAKygB,QAAU,WAAa,CAE7B,EAID,SAASmnF,GAAgB5wD,EAAUwV,GAElC,SAASq7C,EAAyB5nG,EAAKy5D,IAER,IAAzBz5D,EAAIyf,kBAERzf,EAAIkgB,eAILu5C,EAAQt8D,MAAMgW,KAAMnT,EAAI0a,OAEzB,CAmGA,SAASmtF,EAAuBjxD,EAAU5W,GAEzC4W,EAASlT,QAAQvmC,MAAQ6iC,EAAS0D,QAE7B1D,EAASzkB,OAEbq7B,EAAS2T,QAAQptD,MAAMgW,KAAM6sB,EAASzkB,OAIlCykB,EAAS0G,UAEbkQ,EAASlQ,SAASvpC,MAAMgW,KAAM6sB,EAAS0G,UAAW9yB,eAAgBosB,EAAS2G,mBAIvE3G,EAAShgC,MAEb42C,EAAS52C,IAAI7C,MAAQ6iC,EAAShgC,IAE9B4nG,EAAyB5nE,EAAShgC,IAAK42C,EAAS4T,eAI5CxqB,EAAS8H,WAEb8O,EAAS9O,SAAS3qC,MAAQ6iC,EAAS8H,SAEnC8/D,EAAyB5nE,EAAS8H,SAAU8O,EAAS6T,oBAIjDzqB,EAASmI,UAEbyO,EAASzO,QAAQhrC,MAAQ6iC,EAASmI,QAElCy/D,EAAyB5nE,EAASmI,QAASyO,EAASwU,kBAEpDxU,EAASxO,UAAUjrC,MAAQ6iC,EAASoI,UAt80BtB,IAw80BTpI,EAASwD,OAEboT,EAASxO,UAAUjrC,QAAW,IAM3B6iC,EAASqI,YAEbuO,EAASvO,UAAUlrC,MAAQ6iC,EAASqI,UAEpCu/D,EAAyB5nE,EAASqI,UAAWuO,EAAS0U,oBAEtD1U,EAASrO,YAAYprC,MAAMgW,KAAM6sB,EAASuI,aAt90B5B,IAw90BTvI,EAASwD,MAEboT,EAASrO,YAAYprC,MAAMmX,UAMxB0rB,EAASwI,kBAEboO,EAASpO,gBAAgBrrC,MAAQ6iC,EAASwI,gBAE1Co/D,EAAyB5nE,EAASwI,gBAAiBoO,EAAS4U,0BAE5D5U,EAASnO,kBAAkBtrC,MAAQ6iC,EAASyI,kBAC5CmO,EAASlO,iBAAiBvrC,MAAQ6iC,EAAS0I,kBAIvC1I,EAAS6I,cAEb+N,EAAS/N,YAAY1rC,MAAQ6iC,EAAS6I,YAEtC++D,EAAyB5nE,EAAS6I,YAAa+N,EAAS8U,uBAIpD1rB,EAAS8I,cAEb8N,EAAS9N,YAAY3rC,MAAQ6iC,EAAS8I,YAEtC8+D,EAAyB5nE,EAAS8I,YAAa8N,EAAS+T,uBAIpD3qB,EAAS6F,UAAY,IAEzB+Q,EAAS/Q,UAAU1oC,MAAQ6iC,EAAS6F,WAIrC,MAAMoD,EAASsjB,EAAW3jD,IAAKo3B,GAAWiJ,OAc1C,GAZKA,IAEJ2N,EAAS3N,OAAO9rC,MAAQ8rC,EAExB2N,EAASiU,WAAW1tD,MAAU8rC,EAAOmS,gBAAkD,IAAjCnS,EAAOjpB,uBAAsC,EAAI,EAEvG42B,EAASxN,aAAajsC,MAAQ6iC,EAASoJ,aACvCwN,EAASkU,IAAI3tD,MAAQ6iC,EAAS8qB,IAC9BlU,EAASvN,gBAAgBlsC,MAAQ6iC,EAASqJ,iBAItCrJ,EAAS+H,SAAW,CAExB6O,EAAS7O,SAAS5qC,MAAQ6iC,EAAS+H,SAGnC,MAAMg4C,GAA6C,IAA7BhpC,EAASw9B,gBAA6Bx2E,KAAKI,GAAK,EAEtEy4C,EAAS5O,kBAAkB7qC,MAAQ6iC,EAASgI,kBAAoB+3C,EAEhE6nB,EAAyB5nE,EAAS+H,SAAU6O,EAASsU,kBAEtD,CAEKlrB,EAASiI,QAEb2O,EAAS3O,MAAM9qC,MAAQ6iC,EAASiI,MAChC2O,EAAS1O,eAAe/qC,MAAQ6iC,EAASkI,eAEzC0/D,EAAyB5nE,EAASiI,MAAO2O,EAASoU,gBAIpD,CAwTA,MAAO,CACN88C,mBA/hBD,SAA6BlxD,EAAUrM,GAEtCA,EAAIhvB,MAAM6wB,OAAQwK,EAASuV,SAAShvD,MAAO25C,GAA2BC,IAEjExM,EAAIw9D,OAERnxD,EAASqV,QAAQ9uD,MAAQotC,EAAIlS,KAC7Bue,EAASsV,OAAO/uD,MAAQotC,EAAIjS,KAEjBiS,EAAIyxC,YAEfplC,EAASoV,WAAW7uD,MAAQotC,EAAIy9D,QAIlC,EAihBCC,wBA/gBD,SAAkCrxD,EAAU5W,EAAUkoE,EAAYv1F,EAAQw1F,GAEpEnoE,EAAS+M,qBAIF/M,EAASooE,sBAFpBP,EAAuBjxD,EAAU5W,GAMtBA,EAASqoE,oBAEpBR,EAAuBjxD,EAAU5W,GAsSnC,SAA8B4W,EAAU5W,GAElCA,EAASsJ,cAEbsN,EAAStN,YAAYnsC,MAAQ6iC,EAASsJ,YAIxC,CA7SEg/D,CAAqB1xD,EAAU5W,IAEpBA,EAASuoE,qBAEpBV,EAAuBjxD,EAAU5W,GA0RnC,SAA+B4W,EAAU5W,GAExC4W,EAAShQ,SAASzpC,MAAMgW,KAAM6sB,EAAS4G,UACvCgQ,EAAS7P,UAAU5pC,MAAQY,KAAKuQ,IAAK0xB,EAAS+G,UAAW,KAE1D,CA9REyhE,CAAsB5xD,EAAU5W,IAErBA,EAASq5C,wBAEpBwuB,EAAuBjxD,EAAU5W,GAsSnC,SAAkC4W,EAAU5W,GAE3C4W,EAAStQ,UAAUnpC,MAAQ6iC,EAASsG,UAE/BtG,EAAS4I,eAEbgO,EAAShO,aAAazrC,MAAQ6iC,EAAS4I,aAEvCg/D,EAAyB5nE,EAAS4I,aAAcgO,EAASgV,wBAI1DhV,EAASvQ,UAAUlpC,MAAQ6iC,EAASqG,UAE/BrG,EAAS2I,eAEbiO,EAASjO,aAAaxrC,MAAQ6iC,EAAS2I,aAEvCi/D,EAAyB5nE,EAAS2I,aAAciO,EAASkV,wBAI3CS,EAAW3jD,IAAKo3B,GAAWiJ,SAKzC2N,EAASzN,gBAAgBhsC,MAAQ6iC,EAASmJ,gBAI5C,CApUEs/D,CAAyB7xD,EAAU5W,GAE9BA,EAAS0oE,wBAoUhB,SAAkC9xD,EAAU5W,EAAUmoE,GAErDvxD,EAASkU,IAAI3tD,MAAQ6iC,EAAS8qB,IAEzB9qB,EAASuG,MAAQ,IAErBqQ,EAASpQ,WAAWrpC,MAAMgW,KAAM6sB,EAASwG,YAAa5yB,eAAgBosB,EAASuG,OAE/EqQ,EAASnQ,eAAetpC,MAAQ6iC,EAASyG,eAEpCzG,EAASiwB,gBAEbrZ,EAASqZ,cAAc9yD,MAAQ6iC,EAASiwB,cAExC23C,EAAyB5nE,EAASiwB,cAAerZ,EAASsZ,yBAItDlwB,EAASmwB,oBAEbvZ,EAASuZ,kBAAkBhzD,MAAQ6iC,EAASmwB,kBAE5Cy3C,EAAyB5nE,EAASmwB,kBAAmBvZ,EAASwZ,8BAM3DpwB,EAASgH,UAAY,IAEzB4P,EAAS5P,UAAU7pC,MAAQ6iC,EAASgH,UACpC4P,EAAS3P,mBAAmB9pC,MAAQ6iC,EAASiH,mBAExCjH,EAASkH,eAEb0P,EAAS1P,aAAa/pC,MAAQ6iC,EAASkH,aAEvC0gE,EAAyB5nE,EAASkH,aAAc0P,EAAS8Y,wBAIrD1vB,EAASmH,wBAEbyP,EAASzP,sBAAsBhqC,MAAQ6iC,EAASmH,sBAEhDygE,EAAyB5nE,EAASmH,sBAAuByP,EAASgZ,iCAI9D5vB,EAASoH,qBAEbwP,EAASxP,mBAAmBjqC,MAAQ6iC,EAASoH,mBAE7CwgE,EAAyB5nE,EAASoH,mBAAoBwP,EAAS+Y,6BAE/D/Y,EAASvP,qBAAqBlqC,MAAMgW,KAAM6sB,EAASqH,sBApu1BtC,IAsu1BRrH,EAASwD,MAEboT,EAASvP,qBAAqBlqC,MAAMmX,WAQlC0rB,EAASsH,YAAc,IAE3BsP,EAAStP,YAAYnqC,MAAQ6iC,EAASsH,YACtCsP,EAASrP,eAAepqC,MAAQ6iC,EAASuH,eACzCqP,EAASkZ,4BAA4B3yD,MAAQ6iC,EAASwH,0BAA2B,GACjFoP,EAASmZ,4BAA4B5yD,MAAQ6iC,EAASwH,0BAA2B,GAE5ExH,EAASyH,iBAEbmP,EAASnP,eAAetqC,MAAQ6iC,EAASyH,eAEzCmgE,EAAyB5nE,EAASyH,eAAgBmP,EAASiZ,0BAIvD7vB,EAAS0H,0BAEbkP,EAASlP,wBAAwBvqC,MAAQ6iC,EAAS0H,wBAElDkgE,EAAyB5nE,EAAS0H,wBAAyBkP,EAASoZ,oCAMjEhwB,EAASuJ,aAAe,IAE5BqN,EAASrN,aAAapsC,MAAQ6iC,EAASuJ,aACvCqN,EAAS2Z,uBAAuBpzD,MAAQgrG,EAAyBrlF,QACjE8zB,EAAS0Z,wBAAwBnzD,MAAMmV,IAAK61F,EAAyBz1F,MAAOy1F,EAAyBx1F,QAEhGqtB,EAASwJ,kBAEboN,EAASpN,gBAAgBrsC,MAAQ6iC,EAASwJ,gBAE1Co+D,EAAyB5nE,EAASwJ,gBAAiBoN,EAASyZ,2BAI7DzZ,EAASnN,UAAUtsC,MAAQ6iC,EAASyJ,UAE/BzJ,EAAS0J,eAEbkN,EAASlN,aAAavsC,MAAQ6iC,EAAS0J,aAEvCk+D,EAAyB5nE,EAAS0J,aAAckN,EAAS4Z,wBAI1D5Z,EAASjN,oBAAoBxsC,MAAQ6iC,EAAS2J,oBAC9CiN,EAAS/M,iBAAiB1sC,MAAMgW,KAAM6sB,EAAS6J,mBAI3C7J,EAAShhB,WAAa,IAE1B43B,EAAS+Z,iBAAiBxzD,MAAMmV,IAAK0tB,EAAShhB,WAAajhB,KAAK6T,IAAKouB,EAAS2H,oBAAsB3H,EAAShhB,WAAajhB,KAAK8T,IAAKmuB,EAAS2H,qBAExI3H,EAAS4H,gBAEbgP,EAAShP,cAAczqC,MAAQ6iC,EAAS4H,cAExCggE,EAAyB5nE,EAAS4H,cAAegP,EAASga,0BAM5Dha,EAAS/P,kBAAkB1pC,MAAQ6iC,EAAS6G,kBAC5C+P,EAAS9P,cAAc3pC,MAAMgW,KAAM6sB,EAAS8G,eAEvC9G,EAASgJ,mBAEb4N,EAAS5N,iBAAiB7rC,MAAQ6iC,EAASgJ,iBAE3C4+D,EAAyB5nE,EAASgJ,iBAAkB4N,EAAS6Z,4BAIzDzwB,EAAS+I,uBAEb6N,EAAS7N,qBAAqB5rC,MAAQ6iC,EAAS+I,qBAE/C6+D,EAAyB5nE,EAAS+I,qBAAsB6N,EAAS8Z,+BAInE,CA5dGi4C,CAAyB/xD,EAAU5W,EAAUmoE,IAInCnoE,EAAS4oE,sBAEpBf,EAAuBjxD,EAAU5W,GAwdnC,SAAgC4W,EAAU5W,GAEpCA,EAAS6H,SAEb+O,EAAS/O,OAAO1qC,MAAQ6iC,EAAS6H,OAInC,CA/dEghE,CAAuBjyD,EAAU5W,IAEtBA,EAASiiD,oBAEpB4lB,EAAuBjxD,EAAU5W,GAEtBA,EAASkiD,wBAEpB2lB,EAAuBjxD,EAAU5W,GAydnC,SAAkC4W,EAAU5W,GAE3C,MAAMk+C,EAAQ3xB,EAAW3jD,IAAKo3B,GAAWk+C,MAEzCtnC,EAASyY,kBAAkBlyD,MAAM0tB,sBAAuBqzD,EAAM50D,aAC9DstB,EAAS0Y,aAAanyD,MAAQ+gF,EAAM1uB,OAAOvmC,OAAOoP,KAClDue,EAAS2Y,YAAYpyD,MAAQ+gF,EAAM1uB,OAAOvmC,OAAOqP,GAElD,CAheEwwE,CAAyBlyD,EAAU5W,IAExBA,EAAS+oE,qBAEpBlB,EAAuBjxD,EAAU5W,GAEtBA,EAASgpE,qBAsKtB,SAA8BpyD,EAAU5W,GAEvC4W,EAAS2T,QAAQptD,MAAMgW,KAAM6sB,EAASzkB,OACtCq7B,EAASlT,QAAQvmC,MAAQ6iC,EAAS0D,QAE7B1D,EAAShgC,MAEb42C,EAAS52C,IAAI7C,MAAQ6iC,EAAShgC,IAE9B4nG,EAAyB5nE,EAAShgC,IAAK42C,EAAS4T,cAIlD,CAjLEy+C,CAAqBryD,EAAU5W,GAE1BA,EAASkpE,sBAiLhB,SAA8BtyD,EAAU5W,GAEvC4W,EAAS5M,SAAS7sC,MAAQ6iC,EAASgK,SACnC4M,EAAS+X,UAAUxxD,MAAQ6iC,EAASgK,SAAWhK,EAASiK,QACxD2M,EAASz8B,MAAMhd,MAAQ6iC,EAAS7lB,KAEjC,CArLGgvF,CAAqBvyD,EAAU5W,IAIrBA,EAASopE,iBAmLtB,SAAgCxyD,EAAU5W,EAAUkoE,EAAYv1F,GAE/DikC,EAAS2T,QAAQptD,MAAMgW,KAAM6sB,EAASzkB,OACtCq7B,EAASlT,QAAQvmC,MAAQ6iC,EAAS0D,QAClCkT,EAAS7qB,KAAK5uB,MAAQ6iC,EAASjU,KAAOm8E,EACtCtxD,EAASz8B,MAAMhd,MAAiB,GAATwV,EAElBqtB,EAAShgC,MAEb42C,EAAS52C,IAAI7C,MAAQ6iC,EAAShgC,IAE9B4nG,EAAyB5nE,EAAShgC,IAAK42C,EAASuX,cAI5CnuB,EAAS8H,WAEb8O,EAAS9O,SAAS3qC,MAAQ6iC,EAAS8H,SAEnC8/D,EAAyB5nE,EAAS8H,SAAU8O,EAAS6T,oBAIjDzqB,EAAS6F,UAAY,IAEzB+Q,EAAS/Q,UAAU1oC,MAAQ6iC,EAAS6F,UAItC,CA9MEwjE,CAAuBzyD,EAAU5W,EAAUkoE,EAAYv1F,GAE5CqtB,EAASspE,iBA8MtB,SAAiC1yD,EAAU5W,GAE1C4W,EAAS2T,QAAQptD,MAAMgW,KAAM6sB,EAASzkB,OACtCq7B,EAASlT,QAAQvmC,MAAQ6iC,EAAS0D,QAClCkT,EAAS58B,SAAS7c,MAAQ6iC,EAAShmB,SAE9BgmB,EAAShgC,MAEb42C,EAAS52C,IAAI7C,MAAQ6iC,EAAShgC,IAE9B4nG,EAAyB5nE,EAAShgC,IAAK42C,EAAS4T,eAI5CxqB,EAAS8H,WAEb8O,EAAS9O,SAAS3qC,MAAQ6iC,EAAS8H,SAEnC8/D,EAAyB5nE,EAAS8H,SAAU8O,EAAS6T,oBAIjDzqB,EAAS6F,UAAY,IAEzB+Q,EAAS/Q,UAAU1oC,MAAQ6iC,EAAS6F,UAItC,CAxOE0jE,CAAwB3yD,EAAU5W,GAEvBA,EAASwpE,kBAEpB5yD,EAASr7B,MAAMpe,MAAMgW,KAAM6sB,EAASzkB,OACpCq7B,EAASlT,QAAQvmC,MAAQ6iC,EAAS0D,SAEvB1D,EAASqX,mBAEpBrX,EAASmY,oBAAqB,EAIhC,EAocD,CAEA,SAASsxD,GAAqBhqD,EAAIiX,EAAMhX,EAAcuR,GAErD,IAAIrR,EAAU,CAAC,EACX8pD,EAAa,CAAC,EACdC,EAAyB,GAE7B,MAAMC,EAAqBlqD,EAAsB,SAAID,EAAGlyB,aAAckyB,EAAGoqD,6BAAgC,EAwJzG,SAASC,EAAmBrwC,EAAS37D,EAAOsiC,GAE3C,MAAMjjC,EAAQs8D,EAAQt8D,MAEtB,QAAwBD,IAAnBkjC,EAAOtiC,GAAwB,CAInC,GAAsB,iBAAVX,EAEXijC,EAAOtiC,GAAUX,MAEX,CAEN,MAAMkjC,EAASr/B,MAAME,QAAS/D,GAAUA,EAAQ,CAAEA,GAE5C4sG,EAAa,GAEnB,IAAM,IAAI1pG,EAAI,EAAGA,EAAIggC,EAAO3/B,OAAQL,IAEnC0pG,EAAWvqG,KAAM6gC,EAAQhgC,GAAI6S,SAI9BktB,EAAOtiC,GAAUisG,CAElB,CAEA,OAAO,CAER,CAIC,GAAsB,iBAAV5sG,GAEX,GAAKijC,EAAOtiC,KAAYX,EAGvB,OADAijC,EAAOtiC,GAAUX,GACV,MAIF,CAEN,MAAM6sG,EAAgBhpG,MAAME,QAASk/B,EAAOtiC,IAAYsiC,EAAOtiC,GAAU,CAAEsiC,EAAOtiC,IAC5EuiC,EAASr/B,MAAME,QAAS/D,GAAUA,EAAQ,CAAEA,GAElD,IAAM,IAAIkD,EAAI,EAAGA,EAAI2pG,EAActpG,OAAQL,IAAO,CAEjD,MAAM4pG,EAAeD,EAAe3pG,GAEpC,IAA4C,IAAvC4pG,EAAaz0F,OAAQ6qB,EAAQhgC,IAGjC,OADA4pG,EAAa92F,KAAMktB,EAAQhgC,KACpB,CAIT,CAED,CAID,OAAO,CAER,CAgFA,SAAS6pG,EAAgB/sG,GAExB,MAAMu5D,EAAO,CACZyzC,SAAU,EACVC,QAAS,GAyDV,MApDsB,iBAAVjtG,GAIXu5D,EAAKyzC,SAAW,EAChBzzC,EAAK0zC,QAAU,GAEJjtG,EAAMsV,WAIjBikD,EAAKyzC,SAAW,EAChBzzC,EAAK0zC,QAAU,GAEJjtG,EAAM8qB,WAAa9qB,EAAMkiC,SAIpCq3B,EAAKyzC,SAAW,GAChBzzC,EAAK0zC,QAAU,IAEJjtG,EAAM4jB,WAIjB21C,EAAKyzC,SAAW,GAChBzzC,EAAK0zC,QAAU,IAEJjtG,EAAMyZ,WAIjB8/C,EAAKyzC,SAAW,GAChBzzC,EAAK0zC,QAAU,IAEJjtG,EAAM62B,WAIjB0iC,EAAKyzC,SAAW,GAChBzzC,EAAK0zC,QAAU,IAEJjtG,EAAMiiB,UAEjB/gB,QAAQkU,KAAM,+EAIdlU,QAAQkU,KAAM,uDAAwDpV,GAIhEu5D,CAER,CAEA,SAAS2zC,EAAyB98F,GAEjC,MAAM0hF,EAAgB1hF,EAAMpJ,OAE5B8qF,EAAc7hF,oBAAqB,UAAWi9F,GAE9C,MAAMvsG,EAAQ6rG,EAAuBz8F,QAAS+hF,EAAcI,qBAC5Dsa,EAAuB3hG,OAAQlK,EAAO,GAEtC2hD,EAAGK,aAAcF,EAASqvC,EAAcvvF,YAEjCkgD,EAASqvC,EAAcvvF,WACvBgqG,EAAYza,EAAcvvF,GAElC,CAgBA,MAAO,CAEN4H,KA1YD,SAAe2nF,EAAet7B,GAE7B,MAAM22C,EAAe32C,EAAQA,QAC7B1C,EAAMm+B,oBAAqBH,EAAeqb,EAE3C,EAsYCljG,OApYD,SAAiB6nF,EAAet7B,GAE/B,IAAI5T,EAASH,EAASqvC,EAAcvvF,SAEpBxC,IAAX6iD,IAgNN,SAA+BkvC,GAK9B,MAAMr4C,EAAWq4C,EAAcr4C,SAE/B,IAAIlhC,EAAS,EAEb,IAAI60F,EAAc,EAElB,IAAM,IAAIlqG,EAAI,EAAGoN,EAAImpC,EAASl2C,OAAQL,EAAIoN,EAAGpN,IAAO,CAEnD,MAAMo5D,EAAU7iB,EAAUv2C,GAEpBmqG,EAAQ,CACbL,SAAU,EACVC,QAAS,GAGJ/pE,EAASr/B,MAAME,QAASu4D,EAAQt8D,OAAUs8D,EAAQt8D,MAAQ,CAAEs8D,EAAQt8D,OAE1E,IAAM,IAAIgyB,EAAI,EAAG6gB,EAAK3P,EAAO3/B,OAAQyuB,EAAI6gB,EAAI7gB,IAAO,CAEnD,MAEMunC,EAAOwzC,EAFC7pE,EAAQlR,IAItBq7E,EAAML,UAAYzzC,EAAKyzC,SACvBK,EAAMJ,SAAW1zC,EAAK0zC,OAEvB,CAIA3wC,EAAQgxC,OAAS,IAAIv7F,aAAcs7F,EAAMJ,QAAUl7F,aAAa+xC,mBAChEwY,EAAQixC,SAAWh1F,EAIdrV,EAAI,IAERkqG,EAAc70F,EAlCE,GAwCK,IAAhB60F,GAxCW,GAoCyBA,EAIUC,EAAML,SAAa,IAIrEz0F,GA5Ce,GA4CS60F,EACxB9wC,EAAQixC,SAAWh1F,IAMrBA,GAAU80F,EAAMJ,OAEjB,CAIAG,EAAc70F,EAzDI,GA2Db60F,EAAc,IAAI70F,GA3DL,GA2D6B60F,GAI/Ctb,EAAc0b,OAASj1F,EACvBu5E,EAAc2b,QAAU,CAAC,CAI1B,CA1REC,CAAsB5b,GAEtBlvC,EA0BF,SAAuBkvC,GAItB,MAAM6b,EAgBP,WAEC,IAAM,IAAIzqG,EAAI,EAAGA,EAAIupG,EAAkBvpG,IAEtC,IAA+C,IAA1CspG,EAAuBz8F,QAAS7M,GAGpC,OADAspG,EAAuBnqG,KAAMa,GACtBA,EAQT,OAFAhC,QAAQ6+B,MAAO,yFAER,CAER,CAjC2B6tE,GAC1B9b,EAAcI,oBAAsByb,EAEpC,MAAM/qD,EAASN,EAAGY,eACZt0B,EAAOkjE,EAAc0b,OACrBt9D,EAAQ4hD,EAAc5hD,MAO5B,OALAoS,EAAGa,WAAYb,EAAGurD,eAAgBjrD,GAClCN,EAAGc,WAAYd,EAAGurD,eAAgBj/E,EAAMshB,GACxCoS,EAAGa,WAAYb,EAAGurD,eAAgB,MAClCvrD,EAAGwrD,eAAgBxrD,EAAGurD,eAAgBF,EAAmB/qD,GAElDA,CAER,CA5CWM,CAAc4uC,GACvBrvC,EAASqvC,EAAcvvF,IAAOqgD,EAE9BkvC,EAAcjzF,iBAAkB,UAAWquG,IAM5C,MAAMC,EAAe32C,EAAQA,QAC7B1C,EAAM+9B,iBAAkBC,EAAeqb,GAIvC,MAAMprD,EAAQwX,EAAKxb,OAAOgE,MAErBwqD,EAAYza,EAAcvvF,MAASw/C,IAiDzC,SAA2B+vC,GAE1B,MAAMlvC,EAASH,EAASqvC,EAAcvvF,IAChCk3C,EAAWq4C,EAAcr4C,SACzBxW,EAAQ6uD,EAAc2b,QAE5BnrD,EAAGa,WAAYb,EAAGurD,eAAgBjrD,GAElC,IAAM,IAAI1/C,EAAI,EAAGmrB,EAAKorB,EAASl2C,OAAQL,EAAImrB,EAAInrB,IAAO,CAErD,MAAMo5D,EAAU7iB,EAAUv2C,GAI1B,IAAgD,IAA3CypG,EAAmBrwC,EAASp5D,EAAG+/B,GAAmB,CAEtD,MAAM1qB,EAAS+jD,EAAQixC,SAEjBrqE,EAASr/B,MAAME,QAASu4D,EAAQt8D,OAAUs8D,EAAQt8D,MAAQ,CAAEs8D,EAAQt8D,OAE1E,IAAI+tG,EAAc,EAElB,IAAM,IAAI7qG,EAAI,EAAGA,EAAIggC,EAAO3/B,OAAQL,IAAO,CAE1C,MAAMlD,EAAQkjC,EAAQhgC,GAEhBq2D,EAAOwzC,EAAgB/sG,GAEP,iBAAVA,GAEXs8D,EAAQgxC,OAAQ,GAAMttG,EACtBsiD,EAAGyB,cAAezB,EAAGurD,eAAgBt1F,EAASw1F,EAAazxC,EAAQgxC,SAExDttG,EAAMyZ,WAIjB6iD,EAAQgxC,OAAQ,GAAMttG,EAAM6W,SAAU,GACtCylD,EAAQgxC,OAAQ,GAAMttG,EAAM6W,SAAU,GACtCylD,EAAQgxC,OAAQ,GAAMttG,EAAM6W,SAAU,GACtCylD,EAAQgxC,OAAQ,GAAMttG,EAAM6W,SAAU,GACtCylD,EAAQgxC,OAAQ,GAAMttG,EAAM6W,SAAU,GACtCylD,EAAQgxC,OAAQ,GAAMttG,EAAM6W,SAAU,GACtCylD,EAAQgxC,OAAQ,GAAMttG,EAAM6W,SAAU,GACtCylD,EAAQgxC,OAAQ,GAAMttG,EAAM6W,SAAU,GACtCylD,EAAQgxC,OAAQ,GAAMttG,EAAM6W,SAAU,GACtCylD,EAAQgxC,OAAQ,GAAMttG,EAAM6W,SAAU,GACtCylD,EAAQgxC,OAAQ,IAAOttG,EAAM6W,SAAU,GACvCylD,EAAQgxC,OAAQ,IAAOttG,EAAM6W,SAAU,KAIvC7W,EAAMwY,QAAS8jD,EAAQgxC,OAAQS,GAE/BA,GAAex0C,EAAK0zC,QAAUl7F,aAAa+xC,kBAI7C,CAEAxB,EAAGyB,cAAezB,EAAGurD,eAAgBt1F,EAAQ+jD,EAAQgxC,OAEtD,CAED,CAEAhrD,EAAGa,WAAYb,EAAGurD,eAAgB,KAEnC,CAnHEG,CAAkBlc,GAElBya,EAAYza,EAAcvvF,IAAOw/C,EAInC,EAsWC1+B,QAnBD,WAEC,IAAM,MAAM9gB,KAAMkgD,EAEjBH,EAAGK,aAAcF,EAASlgD,IAI3BiqG,EAAyB,GACzB/pD,EAAU,CAAC,EACX8pD,EAAa,CAAC,CAEf,EAWD,CAEA,SAAS0B,KAER,MAAMvuF,EAASjC,GAAiB,UAEhC,OADAiC,EAAOjgB,MAAMyuG,QAAU,QAChBxuF,CAER,CAEA,MAAMyuF,GAELhpG,YAAao9B,EAAa,CAAC,GAE1B,MAAM,OACL7iB,EAASuuF,KAAqB,QAC9BtuF,EAAU,KAAI,MACd4F,GAAQ,EAAI,QACZk5B,GAAU,EAAI,MACdxmC,GAAQ,EAAK,UACbkvF,GAAY,EAAK,mBACjB7+D,GAAqB,EAAI,sBACzB8lE,GAAwB,EAAK,gBAC7BC,EAAkB,UAAS,6BAC3BC,GAA+B,GAC5B/rE,EAIJ,IAAIgsE,EAFJ3rG,KAAK4rG,iBAAkB,EAMtBD,EAFgB,OAAZ5uF,EAEKA,EAAQolF,uBAAuB9sF,MAI/BA,EAIV,MAAMw2F,EAAiB,IAAIz8F,YAAa,GAClC08F,EAAgB,IAAIv8F,WAAY,GAEtC,IAAIw8F,EAAoB,KACpBC,EAAqB,KAKzB,MAAMC,EAAkB,GAClBC,EAAmB,GAIzBlsG,KAAKmsG,WAAarvF,EAGlB9c,KAAKm1E,MAAQ,CAMZC,mBAAmB,EAKnBQ,cAAe,MAKhB51E,KAAKmyD,WAAY,EACjBnyD,KAAKoyD,gBAAiB,EACtBpyD,KAAKqyD,gBAAiB,EACtBryD,KAAKsyD,kBAAmB,EAIxBtyD,KAAKosG,aAAc,EAInBpsG,KAAK+kC,eAAiB,GACtB/kC,KAAKu5D,sBAAuB,EAI5Bv5D,KAAKk3C,iBAAmB7qC,GAIxBrM,KAAKw0E,iBAAkB,EAIvBx0E,KAAK+6C,YAAcjxC,EACnB9J,KAAKqsG,oBAAsB,EAI3B,MAAMC,EAAQtsG,KAEd,IAAIusG,GAAiB,EAIjBC,EAAyB,EACzBC,EAA4B,EAC5BC,EAAuB,KACvBC,GAAuB,EAEvBC,EAAiB,KAErB,MAAMC,EAAmB,IAAIhsF,GACvBisF,EAAkB,IAAIjsF,GAC5B,IAAIksF,EAAsB,KAE1B,MAAMC,EAAqB,IAAIjiE,GAAO,GACtC,IAAIkiE,EAAqB,EAIrBC,EAASpwF,EAAOnK,MAChBw6F,EAAUrwF,EAAOlK,OAEjBw6F,EAAc,EACdC,EAAc,KACdC,EAAmB,KAEvB,MAAM5qB,EAAY,IAAI7hE,GAAS,EAAG,EAAGqsF,EAAQC,GACvCI,EAAW,IAAI1sF,GAAS,EAAG,EAAGqsF,EAAQC,GAC5C,IAAIK,GAAe,EAInB,MAAMjrB,EAAW,IAAIplC,GAIrB,IAAIswD,GAAmB,EACnBC,GAAwB,EAIxBC,EAA4B,KAIhC,MAAMC,GAAoB,IAAIn6E,GAExBsoB,GAAW,IAAItpC,GACfo7F,GAAW,IAAI,GAEfC,GAAc,CAAEzuE,WAAY,KAAMmL,IAAK,KAAMjL,YAAa,KAAMwuE,iBAAkB,KAAM3uE,SAAS,GAEvG,SAAS4uE,KAER,OAAgC,OAAzBtB,EAAgCU,EAAc,CAEtD,CAIA,IA0FIv1D,GAAY8H,GAAcuR,GAAOyF,GACjCnK,GAAYnsC,GAAU2wC,GAAUC,GAAYtrD,GAAY84B,GAAY0yB,GACpE88C,GAAcvvE,GAAWwvE,GAAansB,GAAcnqC,GAAU0kC,GAE9Dj9C,GAAY8uE,GAAcC,GAAgBC,GAE1Cpe,GAAOp9B,GAAerb,GAhGtBw4C,GAAMjzE,EAEV,SAASC,GAAYsxF,EAAcC,GAElC,IAAM,IAAIjuG,EAAI,EAAGA,EAAIguG,EAAa3tG,OAAQL,IAAO,CAEhD,MAAMkuG,EAAcF,EAAchuG,GAC5Byc,EAAUD,EAAOE,WAAYwxF,EAAaD,GAChD,GAAiB,OAAZxxF,EAAmB,OAAOA,CAEhC,CAEA,OAAO,IAER,CAEA,IAEC,MAAMwxF,EAAoB,CACzBl5F,OAAO,EACPsN,QACAk5B,UACA0oD,YACA7+D,qBACA8lE,wBACAC,kBACAC,gCAWD,GAPK,iBAAkB5uF,GAASA,EAAO7f,aAAc,cAAe,aAAamM,KAGjF0T,EAAO7gB,iBAAkB,mBAAoBwyG,IAAe,GAC5D3xF,EAAO7gB,iBAAkB,uBAAwByyG,IAAkB,GACnE5xF,EAAO7gB,iBAAkB,4BAA6B0yG,IAAwB,GAEjE,OAAR3e,GAAe,CAEnB,MAAMse,EAAe,CAAE,SAAU,QAAS,sBAU1C,IARgC,IAA3BhC,EAAMsC,kBAEVN,EAAaO,QAId7e,GAAMhzE,GAAYsxF,EAAcC,GAEnB,OAARve,GAEJ,MAAKhzE,GAAYsxF,GAEV,IAAIroG,MAAO,+DAIX,IAAIA,MAAO,gCAMpB,CAEsC,oBAA1B6oG,uBAAyC9e,cAAe8e,uBAEnExwG,QAAQkU,KAAM,iGAMuBrV,IAAjC6yF,GAAI34B,2BAER24B,GAAI34B,yBAA2B,WAE9B,MAAO,CAAE,SAAY,EAAG,SAAY,EAAG,UAAa,EAErD,EAIF,CAAE,MAAQl6B,GAGT,MADA7+B,QAAQ6+B,MAAO,wBAA0BA,EAAMjiB,SACzCiiB,CAEP,CAUA,SAAS4xE,KAERl3D,GAAa,IAAIypB,GAAiB0uB,IAElCrwC,GAAe,IAAIuX,GAAmB84B,GAAKn4C,GAAYlY,GAEvDkY,GAAWuiB,KAAMza,IAEjBswC,GAAQ,IAAI0K,GAAY3K,GAAKn4C,GAAY8H,IAEzCuR,GAAQ,IAAI20B,GAAYmK,GAAKn4C,GAAY8H,IAEzCgX,GAAO,IAAIyL,GAAW4tB,IACtBxjC,GAAa,IAAIywB,GACjB58D,GAAW,IAAI0vE,GAAeC,GAAKn4C,GAAYqZ,GAAO1E,GAAY7M,GAAcswC,GAAOt5B,IACvF3F,GAAW,IAAI+J,GAAeuxC,GAC9Br7C,GAAa,IAAI8P,GAAiBurC,GAClC3mG,GAAa,IAAI85C,GAAiBuwC,GAAKrwC,IACvCkT,GAAgB,IAAIL,GAAoBw9B,GAAKn4C,GAAYlyC,GAAYg6C,IACrElhB,GAAa,IAAI+iC,GAAiBwuB,GAAKrqF,GAAYgxD,GAAM9D,IACzD1B,GAAU,IAAI0T,GAAcmrB,GAAKvxD,GAAY94B,GAAYgxD,IACzDw3C,GAAe,IAAIjrC,GAAmB8sB,GAAKrwC,GAAct/B,IACzDu3B,GAAW,IAAIwhB,GAAe5M,IAC9ByhD,GAAe,IAAIl2B,GAAeu0B,EAAOt7C,GAAUC,GAAYpZ,GAAY8H,GAAckT,GAAejb,IACxGlZ,GAAY,IAAIkpE,GAAgB0E,EAAO9/C,IACvC0hD,GAAc,IAAIpwB,GAClBiE,GAAe,IAAID,GAAmBjqC,GAAY8H,IAClDtgB,GAAa,IAAI0xB,GAAiBu7C,EAAOt7C,GAAUC,GAAYC,GAAOC,GAASw6C,EAAQjmE,GACvF42C,GAAY,IAAI8F,GAAgBkqB,EAAOn7C,GAASxR,IAChDnI,GAAiB,IAAIkyD,GAAqB1Z,GAAKr5B,GAAMhX,GAAcuR,IAEnEk9C,GAAiB,IAAI13C,GAAqBs5B,GAAKn4C,GAAY8e,GAAMhX,IACjE0uD,GAAwB,IAAInsC,GAA4B8tB,GAAKn4C,GAAY8e,GAAMhX,IAE/EgX,GAAK6L,SAAWyrC,GAAazrC,SAE7B8pC,EAAM3sD,aAAeA,GACrB2sD,EAAMz0D,WAAaA,GACnBy0D,EAAM9/C,WAAaA,GACnB8/C,EAAM4B,YAAcA,GACpB5B,EAAMhwB,UAAYA,GAClBgwB,EAAMp7C,MAAQA,GACdo7C,EAAM31C,KAAOA,EAEd,CAEAo4C,KAIA,MAAM9zD,GAAK,IAAIwmD,GAAc6K,EAAOtc,IAkUpC,SAASye,GAAejhG,GAEvBA,EAAMrR,iBAENmC,QAAQC,IAAK,sCAEbguG,GAAiB,CAElB,CAEA,SAASmC,KAERpwG,QAAQC,IAAK,0CAEbguG,GAAiB,EAEjB,MAAMyC,EAAgBr4C,GAAK8L,UACrB8R,EAAmB+H,GAAUzgE,QAC7BozF,EAAsB3yB,GAAUiH,WAChC2rB,EAAuB5yB,GAAUx+D,YACjC8xD,EAAgB0M,GAAUvvE,KAEhCgiG,KAEAp4C,GAAK8L,UAAYusC,EACjB1yB,GAAUzgE,QAAU04D,EACpB+H,GAAUiH,WAAa0rB,EACvB3yB,GAAUx+D,YAAcoxF,EACxB5yB,GAAUvvE,KAAO6iE,CAElB,CAEA,SAAS++B,GAAwBnhG,GAEhClP,QAAQ6+B,MAAO,sEAAuE3vB,EAAM2hG,cAE7F,CAEA,SAASC,GAAmB5hG,GAE3B,MAAMyyB,EAAWzyB,EAAMpJ,OAEvB67B,EAAS5yB,oBAAqB,UAAW+hG,IAQ1C,SAA6BnvE,IAS7B,SAA2CA,GAE1C,MAAMuiC,EAAWhW,GAAW3jD,IAAKo3B,GAAWuiC,cAE1BrlE,IAAbqlE,IAEJA,EAAS18D,SAAS,SAAW8tD,GAE5Bq6C,GAAanxB,eAAgBlpB,EAE9B,IAEK3zB,EAASqX,kBAEb22D,GAAajxB,mBAAoB/8C,GAMpC,EA3BCovE,CAAkCpvE,GAElCusB,GAAWtvD,OAAQ+iC,EAEpB,CAZCqvE,CAAoBrvE,EAErB,CA9WAjgC,KAAKi7C,GAAKA,GAIVj7C,KAAKgd,WAAa,WAEjB,OAAOgzE,EAER,EAEAhwF,KAAKmiG,qBAAuB,WAE3B,OAAOnS,GAAImS,sBAEZ,EAEAniG,KAAKuvG,iBAAmB,WAEvB,MAAM58C,EAAY9a,GAAWhvC,IAAK,sBAC7B8pD,GAAYA,EAAU68C,aAE5B,EAEAxvG,KAAKyvG,oBAAsB,WAE1B,MAAM98C,EAAY9a,GAAWhvC,IAAK,sBAC7B8pD,GAAYA,EAAU+8C,gBAE5B,EAEA1vG,KAAK2vG,cAAgB,WAEpB,OAAOvC,CAER,EAEAptG,KAAK4vG,cAAgB,SAAWxyG,QAEhBD,IAAVC,IAELgwG,EAAchwG,EAEd4C,KAAKojB,QAAS8pF,EAAQC,GAAS,GAEhC,EAEAntG,KAAKysB,QAAU,SAAWroB,GAEzB,OAAOA,EAAOmO,IAAK26F,EAAQC,EAE5B,EAEAntG,KAAKojB,QAAU,SAAWzQ,EAAOC,EAAQi9F,GAAc,GAEjD50D,GAAGioD,aAEP5kG,QAAQkU,KAAM,0EAKf06F,EAASv6F,EACTw6F,EAAUv6F,EAEVkK,EAAOnK,MAAQ3U,KAAKK,MAAOsU,EAAQy6F,GACnCtwF,EAAOlK,OAAS5U,KAAKK,MAAOuU,EAASw6F,IAEhB,IAAhByC,IAEJ/yF,EAAOjgB,MAAM8V,MAAQA,EAAQ,KAC7BmK,EAAOjgB,MAAM+V,OAASA,EAAS,MAIhC5S,KAAK8vG,YAAa,EAAG,EAAGn9F,EAAOC,GAEhC,EAEA5S,KAAK+vG,qBAAuB,SAAW3rG,GAEtC,OAAOA,EAAOmO,IAAK26F,EAASE,EAAaD,EAAUC,GAAc/uG,OAElE,EAEA2B,KAAKgwG,qBAAuB,SAAWr9F,EAAOC,EAAQu1F,GAErD+E,EAASv6F,EACTw6F,EAAUv6F,EAEVw6F,EAAcjF,EAEdrrF,EAAOnK,MAAQ3U,KAAKK,MAAOsU,EAAQw1F,GACnCrrF,EAAOlK,OAAS5U,KAAKK,MAAOuU,EAASu1F,GAErCnoG,KAAK8vG,YAAa,EAAG,EAAGn9F,EAAOC,EAEhC,EAEA5S,KAAKiwG,mBAAqB,SAAW7rG,GAEpC,OAAOA,EAAOgP,KAAMy5F,EAErB,EAEA7sG,KAAK0lF,YAAc,SAAWthF,GAE7B,OAAOA,EAAOgP,KAAMsvE,EAErB,EAEA1iF,KAAK8vG,YAAc,SAAWxzG,EAAGE,EAAGmW,EAAOC,GAErCtW,EAAE0kB,UAEN0hE,EAAUnwE,IAAKjW,EAAEA,EAAGA,EAAEE,EAAGF,EAAEwkB,EAAGxkB,EAAEykB,GAIhC2hE,EAAUnwE,IAAKjW,EAAGE,EAAGmW,EAAOC,GAI7Bs+C,GAAMpuC,SAAU+pF,EAAiBz5F,KAAMsvE,GAAY7uE,eAAgBu5F,GAAc/uG,QAElF,EAEA2B,KAAKkwG,WAAa,SAAW9rG,GAE5B,OAAOA,EAAOgP,KAAMm6F,EAErB,EAEAvtG,KAAKmwG,WAAa,SAAW7zG,EAAGE,EAAGmW,EAAOC,GAEpCtW,EAAE0kB,UAENusF,EAASh7F,IAAKjW,EAAEA,EAAGA,EAAEE,EAAGF,EAAEwkB,EAAGxkB,EAAEykB,GAI/BwsF,EAASh7F,IAAKjW,EAAGE,EAAGmW,EAAOC,GAI5Bs+C,GAAMtuC,QAASkqF,EAAgB15F,KAAMm6F,GAAW15F,eAAgBu5F,GAAc/uG,QAE/E,EAEA2B,KAAKowG,eAAiB,WAErB,OAAO5C,CAER,EAEAxtG,KAAKilF,eAAiB,SAAWorB,GAEhCn/C,GAAM+zB,eAAgBuoB,EAAe6C,EAEtC,EAEArwG,KAAKswG,cAAgB,SAAWC,GAE/BlD,EAAckD,CAEf,EAEAvwG,KAAKwwG,mBAAqB,SAAWD,GAEpCjD,EAAmBiD,CAEpB,EAIAvwG,KAAK4xD,cAAgB,SAAWxtD,GAE/B,OAAOA,EAAOgP,KAAMisB,GAAWuyB,gBAEhC,EAEA5xD,KAAK6xD,cAAgB,WAEpBxyB,GAAWwyB,cAAck9B,MAAO1vD,GAAYnC,UAE7C,EAEAl9B,KAAK8xD,cAAgB,WAEpB,OAAOzyB,GAAWyyB,eAEnB,EAEA9xD,KAAK+xD,cAAgB,WAEpB1yB,GAAW0yB,cAAcg9B,MAAO1vD,GAAYnC,UAE7C,EAEAl9B,KAAKq9B,MAAQ,SAAW7hB,GAAQ,EAAMmH,GAAQ,EAAMk5B,GAAU,GAE7D,IAAI40D,EAAO,EAEX,GAAKj1F,EAAQ,CAGZ,IAAIk1F,GAAkB,EACtB,GAA8B,OAAzBhE,EAAgC,CAEpC,MAAMiE,EAAejE,EAAqB3pF,QAAQ/D,OAClD0xF,EAvr3BqB,OAur3BHC,GAxr3BC,OAyr3BlBA,GA3r3BmB,OA4r3BnBA,CAEF,CAIA,GAAKD,EAAkB,CAEtB,MAAME,EAAalE,EAAqB3pF,QAAQhW,KAC1C8jG,EAAiBD,IAAe5lG,GACrC4lG,IAAe1lG,GACf0lG,IAAe3lG,GACf2lG,IAAevlG,GAlt3BS,OAmt3BxBulG,GAlt3BwB,OAmt3BxBA,EAEKx/C,EAAa/xB,GAAWuyB,gBACxBnpD,EAAI42B,GAAWyyB,gBACf9oD,EAAIooD,EAAWpoD,EACf+P,EAAIq4C,EAAWr4C,EACfrH,EAAI0/C,EAAW1/C,EAEhBm/F,GAEJhF,EAAgB,GAAM7iG,EACtB6iG,EAAgB,GAAM9yF,EACtB8yF,EAAgB,GAAMn6F,EACtBm6F,EAAgB,GAAMpjG,EACtBunF,GAAI8gB,eAAgB9gB,GAAI+gB,MAAO,EAAGlF,KAIlCC,EAAe,GAAM9iG,EACrB8iG,EAAe,GAAM/yF,EACrB+yF,EAAe,GAAMp6F,EACrBo6F,EAAe,GAAMrjG,EACrBunF,GAAIghB,cAAehhB,GAAI+gB,MAAO,EAAGjF,GAInC,MAEC2E,GAAQzgB,GAAIkK,gBAId,CAEKv3E,IAAQ8tF,GAAQzgB,GAAIuK,kBACpB1+C,IAAU40D,GAAQzgB,GAAIwK,oBAE3BxK,GAAI3yD,MAAOozE,EAEZ,EAEAzwG,KAAKoxD,WAAa,WAEjBpxD,KAAKq9B,OAAO,GAAM,GAAO,EAE1B,EAEAr9B,KAAKonF,WAAa,WAEjBpnF,KAAKq9B,OAAO,GAAO,GAAM,EAE1B,EAEAr9B,KAAKkoF,aAAe,WAEnBloF,KAAKq9B,OAAO,GAAO,GAAO,EAE3B,EAIAr9B,KAAKygB,QAAU,WAEd3D,EAAOzP,oBAAqB,mBAAoBohG,IAAe,GAC/D3xF,EAAOzP,oBAAqB,uBAAwBqhG,IAAkB,GACtE5xF,EAAOzP,oBAAqB,4BAA6BshG,IAAwB,GAEjFT,GAAYztF,UACZshE,GAAathE,UACb+rC,GAAW/rC,UACXuwC,GAASvwC,UACTwwC,GAAWxwC,UACX0wC,GAAQ1wC,UACRoyC,GAAcpyC,UACd+2B,GAAe/2B,UACfwtF,GAAaxtF,UAEbw6B,GAAGx6B,UAEHw6B,GAAG5tC,oBAAqB,eAAgB4jG,IACxCh2D,GAAG5tC,oBAAqB,aAAc6jG,IAEjCvD,IAEJA,EAA0BltF,UAC1BktF,EAA4B,MAI7BxtE,GAAUkf,MAEX,EAuFAr/C,KAAK4jF,mBAAqB,SAAW16D,EAAQ0xB,EAAOztB,EAAU8S,EAAU9T,EAAQklB,GAEhE,OAAVuJ,IAAiBA,EAAQkzD,IAE9B,MAAM5f,EAAgB/hE,EAAOqT,QAAUrT,EAAO5C,YAAY1Q,cAAgB,EAEpE+6C,EA+zBP,SAAqB1qC,EAAQ0xB,EAAOztB,EAAU8S,EAAU9T,IAEhC,IAAlByuB,EAAMxb,UAAmBwb,EAAQkzD,IAEtCztF,GAAS84E,oBAET,MAAM3uD,EAAMoQ,EAAMpQ,IACZjL,EAAcU,EAASq5C,uBAAyB1+B,EAAMrb,YAAc,KACpEvjB,EAAwC,OAAzB0wF,EAAkCJ,EAAMp1D,kBAA+D,IAA1Cw1D,EAAqB1wB,iBAA4B0wB,EAAqB3pF,QAAQ/G,WAAa1P,GACvK48B,GAAWjJ,EAASq5C,uBAAyBroB,GAAaD,IAAWnoD,IAAKo3B,EAASiJ,QAAU3J,GAC7Fu0C,GAAyC,IAA1B7zC,EAASyD,gBAA4BvW,EAASxnB,WAAW6V,OAAgD,IAAvC2R,EAASxnB,WAAW6V,MAAM2xB,SAC3G0mC,IAAoB1mD,EAASxnB,WAAWiqC,YAAgB3P,EAASqI,WAAarI,EAAShhB,WAAa,GACpG4kD,IAAkB12C,EAAS0hB,gBAAgBzhB,SAC3C02C,IAAkB32C,EAAS0hB,gBAAgBxkB,OAC3C05C,IAAiB52C,EAAS0hB,gBAAgBrzB,MAC1Cu/B,EAAc9a,EAAS2F,WAAa0mE,EAAMvxD,YAAcjxC,EAExDkmC,EAAiB7iB,EAAS0hB,gBAAgBzhB,UAAYD,EAAS0hB,gBAAgBxkB,QAAU8C,EAAS0hB,gBAAgBrzB,MAClHgoD,OAAyCrmE,IAAnB6yC,EAAiCA,EAAervC,OAAS,EAE/Eg6D,EAAqBnO,GAAW3jD,IAAKo3B,GACrC0X,EAASq0D,EAAmB96C,MAAMvZ,OAExC,IAA0B,IAArB81D,KAE2B,IAA1BC,GAAkCxkF,IAAW0jF,GAAiB,CAElE,MAAMlyC,EACLxxC,IAAW0jF,GACX3sE,EAAStgC,KAAOgtG,EAKjB/0D,GAAS6iB,SAAUx6B,EAAU/W,EAAQwxC,EAEtC,CAMD,IAAIy2C,GAAqB,EAEpBlxE,EAASpiB,UAAY88C,EAAmBw5B,UAEvCx5B,EAAmBy2C,aAAiBz2C,EAAmB02C,qBAAuB15D,EAAOuZ,MAAMrzC,SAIpF88C,EAAmBzjB,mBAAqBl7B,GAIxCmQ,EAAO8S,kBAAqD,IAAlC07B,EAAmBsX,WANxDk/B,GAAqB,EAURhlF,EAAO8S,kBAAqD,IAAlC07B,EAAmBsX,WAI/C9lD,EAAO0T,gBAAiD,IAAhC86B,EAAmBwZ,SAEtDg9B,GAAqB,EAERhlF,EAAO0T,gBAAiD,IAAhC86B,EAAmBwZ,SAI7CxZ,EAAmBzxB,SAAWA,IAIb,IAAjBjJ,EAASuK,KAAgBmwB,EAAmBnwB,MAAQA,EAF/D2mE,GAAqB,OAM+Bh0G,IAAzCw9D,EAAmB+T,mBAC5B/T,EAAmB+T,oBAAsB92B,GAASsiB,WACpDS,EAAmBR,kBAAoBviB,GAASuiB,iBAIrCQ,EAAmBmZ,eAAiBA,GAIpCnZ,EAAmBkZ,iBAAmBA,GAItClZ,EAAmBkJ,eAAiBA,GAIpClJ,EAAmBmJ,eAAiBA,GAIpCnJ,EAAmBoJ,cAAgBA,GAInCpJ,EAAmB5f,cAAgBA,IAIT,IAA1B4E,GAAaC,UAAqB+a,EAAmB6I,oBAAsBA,KAtBtF2tC,GAAqB,GAJrBA,GAAqB,EAdrBA,GAAqB,EARrBA,GAAqB,GAwDtBA,GAAqB,EACrBx2C,EAAmBw5B,UAAYl0D,EAASpiB,SAMzC,IAAI+1C,EAAU+G,EAAmB8tB,gBAEL,IAAvB0oB,IAEJv9C,EAAU09C,GAAYrxE,EAAU2a,EAAOzuB,IAIxC,IAAIolF,GAAiB,EACjBC,GAAkB,EAClBC,GAAgB,EAEpB,MAAMC,EAAa99C,EAAQ4Q,cAC1BmtC,EAAah3C,EAAmB9jB,SAkBjC,GAhBKqa,GAAM88B,WAAYp6B,EAAQA,WAE9B29C,GAAiB,EACjBC,GAAkB,EAClBC,GAAgB,GAIZxxE,EAAStgC,KAAOgtG,IAEpBA,EAAqB1sE,EAAStgC,GAE9B6xG,GAAkB,GAIdD,GAAkB3E,IAAmB1jF,EAAS,CA2BlD,GAzBAwoF,EAAWjtC,SAAUurB,GAAK,mBAAoB9mE,EAAOE,kBAEhDu2B,GAAakY,wBAEjB65C,EAAWjtC,SAAUurB,GAAK,gBACzB,GAAQhyF,KAAKO,IAAK2qB,EAAOqP,IAAM,GAAQv6B,KAAKgR,MAIzC49F,IAAmB1jF,IAEvB0jF,EAAiB1jF,EAMjBsoF,GAAkB,EAClBC,GAAgB,GAOZxxE,EAASqX,kBACbrX,EAASuoE,qBACTvoE,EAASqoE,oBACTroE,EAASq5C,wBACTr5C,EAASiJ,OAAS,CAElB,MAAM0oE,EAAUF,EAAWzxG,IAAI4xG,oBAEd10G,IAAZy0G,GAEJA,EAAQntC,SAAUurB,GACjB6d,GAAS/iF,sBAAuB5B,EAAOK,aAI1C,EAEK0W,EAASuoE,qBACbvoE,EAASqoE,oBACTroE,EAASooE,uBACTpoE,EAAS+M,qBACT/M,EAASq5C,wBACTr5C,EAASqX,mBAETo6D,EAAWjtC,SAAUurB,GAAK,kBAAkD,IAAhC9mE,EAAOkyC,uBAI/Cn7B,EAASuoE,qBACbvoE,EAASqoE,oBACTroE,EAASooE,uBACTpoE,EAAS+M,qBACT/M,EAASq5C,wBACTr5C,EAASqX,kBACTrX,EAASwpE,kBACTt9E,EAAO0T,gBAEP6xE,EAAWjtC,SAAUurB,GAAK,aAAc9mE,EAAOC,mBAIjD,CAMA,GAAKgD,EAAO0T,cAAgB,CAE3B6xE,EAAWxlC,YAAa8jB,GAAK7jE,EAAQ,cACrCulF,EAAWxlC,YAAa8jB,GAAK7jE,EAAQ,qBAErC,MAAM6T,EAAW7T,EAAO6T,SAEnBA,IAEC2f,GAAasZ,qBAEa,OAAzBj5B,EAAS8xE,aAAuB9xE,EAAS+xE,qBAE9CL,EAAWjtC,SAAUurB,GAAK,cAAehwD,EAAS8xE,YAAazxF,IAC/DqxF,EAAWjtC,SAAUurB,GAAK,kBAAmBhwD,EAASgyE,kBAItD1zG,QAAQkU,KAAM,2IAMjB,CAEA,MAAMq8B,EAAkB1hB,EAAS0hB,gBA4GlC,IAAwCgI,EAAUz5C,EA7BjD,SA7EkCD,IAA7B0xC,EAAgBzhB,eAAqDjwB,IAA3B0xC,EAAgBxkB,aAAoDltB,IAA1B0xC,EAAgBrzB,QAAiD,IAA1BmkC,GAAaC,WAE5IuuD,GAAa9mG,OAAQ8kB,EAAQgB,EAAUymC,IAInC49C,GAAmB72C,EAAmBj/B,gBAAkBvP,EAAOuP,iBAEnEi/B,EAAmBj/B,cAAgBvP,EAAOuP,cAC1Cg2E,EAAWjtC,SAAUurB,GAAK,gBAAiB7jE,EAAOuP,gBAM9CuE,EAASgyE,uBAA6C,OAApBhyE,EAASiJ,SAE/CyoE,EAAWzoE,OAAO9rC,MAAQ8rC,EAE1ByoE,EAAW7mD,WAAW1tD,MAAU8rC,EAAOmS,gBAAkD,IAAjCnS,EAAOjpB,uBAAsC,EAAI,GAIrGuxF,IAEJE,EAAWjtC,SAAUurB,GAAK,sBAAuBsc,EAAMD,qBAElD1xC,EAAmBy2C,cA+EwBh0G,EApEJq0G,GAoEN56D,EApEN86D,GAsExBtlD,kBAAkBvuC,YAAc1gB,EACzCy5C,EAASyV,WAAWxuC,YAAc1gB,EAElCy5C,EAAS0V,kBAAkBzuC,YAAc1gB,EACzCy5C,EAAS4V,wBAAwB3uC,YAAc1gB,EAC/Cy5C,EAAS2W,YAAY1vC,YAAc1gB,EACnCy5C,EAAS4W,kBAAkB3vC,YAAc1gB,EACzCy5C,EAASmW,WAAWlvC,YAAc1gB,EAClCy5C,EAASuW,iBAAiBtvC,YAAc1gB,EACxCy5C,EAASoX,eAAenwC,YAAc1gB,EACtCy5C,EAASiX,iBAAiBhwC,YAAc1gB,GA1ElCotC,IAAwB,IAAjBvK,EAASuK,KAEpB9L,GAAUqpE,mBAAoB4J,EAAYnnE,GAI3C9L,GAAUwpE,wBAAyByJ,EAAY1xE,EAAUmtE,EAAaD,EAASQ,GAE/E9hC,GAAcqmC,OAAQliB,GAAKr1B,EAAmBw3C,aAAcR,EAAYtxF,KAIpE4f,EAASqX,mBAAoD,IAAhCrX,EAASmY,qBAE1CyzB,GAAcqmC,OAAQliB,GAAKr1B,EAAmBw3C,aAAcR,EAAYtxF,IACxE4f,EAASmY,oBAAqB,GAI1BnY,EAASspE,kBAEbmI,EAAWjtC,SAAUurB,GAAK,SAAU7jE,EAAOjW,QAM5Cw7F,EAAWjtC,SAAUurB,GAAK,kBAAmB7jE,EAAO+O,iBACpDw2E,EAAWjtC,SAAUurB,GAAK,eAAgB7jE,EAAOgP,cACjDu2E,EAAWjtC,SAAUurB,GAAK,cAAe7jE,EAAO5C,aAI3C0W,EAASqX,kBAAoBrX,EAAS6xC,oBAAsB,CAEhE,MAAM/iC,EAAS9O,EAASuX,eAExB,IAAM,IAAIl3C,EAAI,EAAGoN,EAAIqhC,EAAOpuC,OAAQL,EAAIoN,EAAGpN,IAE1C,GAAKq/C,GAAaC,SAAW,CAE5B,MAAMvO,EAAQtC,EAAQzuC,GAEtBk3C,GAAenwC,OAAQgqC,EAAOuiB,GAC9Bpc,GAAejwC,KAAM8pC,EAAOuiB,EAE7B,MAECt1D,QAAQkU,KAAM,6EAMjB,CAEA,OAAOohD,CAER,CArqCiBw+C,CAAYlpF,EAAQ0xB,EAAOztB,EAAU8S,EAAU9T,GAE/D+kC,GAAM+8B,YAAahuD,EAAUiuD,GAI7B,IAAInwF,EAAQovB,EAASpvB,MACjBs0G,EAAc,GAEU,IAAvBpyE,EAASkK,YAEbpsC,EAAQ0gC,GAAWujC,sBAAuB70C,GAC1CklF,EAAc,GAMf,MAAMpjE,EAAY9hB,EAAS8hB,UACrB7hB,EAAWD,EAASxnB,WAAWynB,SAErC,IAAIklF,EAAYrjE,EAAUC,MAAQmjE,EAC9BE,GAAYtjE,EAAUC,MAAQD,EAAUhqC,OAAUotG,EAEvC,OAAVhhE,IAEJihE,EAAYt0G,KAAKuQ,IAAK+jG,EAAWjhE,EAAMnC,MAAQmjE,GAC/CE,EAAUv0G,KAAKL,IAAK40G,GAAWlhE,EAAMnC,MAAQmC,EAAMpsC,OAAUotG,IAI/C,OAAVt0G,GAEJu0G,EAAYt0G,KAAKuQ,IAAK+jG,EAAW,GACjCC,EAAUv0G,KAAKL,IAAK40G,EAASx0G,EAAMkH,QAExBmoB,UAEXklF,EAAYt0G,KAAKuQ,IAAK+jG,EAAW,GACjCC,EAAUv0G,KAAKL,IAAK40G,EAASnlF,EAASnoB,QAIvC,MAAMutG,EAAYD,EAAUD,EAE5B,GAAKE,EAAY,GAAKA,IAAc3oE,IAAW,OAM/C,IAAI/zB,EAFJ+8C,GAAc4B,MAAOtoC,EAAQ8T,EAAU2zB,EAASzmC,EAAUpvB,GAG1D,IAAIi5C,EAAWo3D,GAaf,GAXe,OAAVrwG,IAEJ+X,EAAYnQ,GAAWkD,IAAK9K,GAE5Bi5C,EAAWq3D,GACXr3D,EAAS5H,SAAUt5B,IAMfqW,EAAOqT,QAEiB,IAAvBS,EAASkK,WAEb+mB,GAAMk9B,aAAcnuD,EAASmK,mBAAqB4jE,MAClDh3D,EAAS6f,QAASm5B,GAAIptB,QAItB5rB,EAAS6f,QAASm5B,GAAIrtB,gBAIjB,GAAKx2C,EAAOsT,OAAS,CAE3B,IAAI4uD,EAAYpuD,EAAS+J,eAEN7sC,IAAdkxF,IAA0BA,EAAY,GAE3Cn9B,GAAMk9B,aAAcC,EAAY2f,MAE3B7hF,EAAOsmF,eAEXz7D,EAAS6f,QAASm5B,GAAIptB,OAEXz2C,EAAOumF,WAElB17D,EAAS6f,QAASm5B,GAAIltB,WAItB9rB,EAAS6f,QAASm5B,GAAIntB,WAIxB,MAAY12C,EAAOuT,SAElBsX,EAAS6f,QAASm5B,GAAIjtB,QAEX52C,EAAOwmF,UAElB37D,EAAS6f,QAASm5B,GAAIrtB,WAIvB,GAAKx2C,EAAO8S,gBAEX+X,EAAS+f,gBAAiBu7C,EAAWE,EAAWrmF,EAAOlnB,YAEjD,GAAKkoB,EAASsoC,0BAA4B,CAEhD,MAAMm9C,OAAkDz1G,IAA/BgwB,EAAS2oC,kBAAkC3oC,EAAS2oC,kBAAoBjsB,IAC3F64B,EAAgB1kE,KAAKL,IAAKwvB,EAASu1C,cAAekwC,GAExD57D,EAAS+f,gBAAiBu7C,EAAWE,EAAW9vC,EAEjD,MAEC1rB,EAASmE,OAAQm3D,EAAWE,EAI9B,EAIAxyG,KAAKs/D,QAAU,SAAW1kB,EAAO1xB,GAEhC,SAAS2pF,EAAS5yE,EAAU2a,EAAOzuB,IAEJ,IAAzB8T,EAAS2D,aAAwB3D,EAASwD,OAASh6B,IAA2C,IAA7Bw2B,EAAS0F,iBAE9E1F,EAASwD,KA3l4BG,EA4l4BZxD,EAASniB,aAAc,EACvBwzF,GAAYrxE,EAAU2a,EAAOzuB,GAE7B8T,EAASwD,KAAOj6B,EAChBy2B,EAASniB,aAAc,EACvBwzF,GAAYrxE,EAAU2a,EAAOzuB,GAE7B8T,EAASwD,KAAOh6B,GAIhB6nG,GAAYrxE,EAAU2a,EAAOzuB,EAI/B,CAEA6/E,EAAqBjqB,GAAal5E,IAAK+xC,GACvCoxD,EAAmB5xC,OAEnB8xC,EAAiBzsG,KAAMusG,GAEvBpxD,EAAM1c,iBAAiB,SAAW/R,GAE5BA,EAAO8Q,SAAW9Q,EAAO0N,OAAOn3B,KAAMwmB,EAAO2Q,UAEjDmyE,EAAmBrqB,UAAWx1D,GAEzBA,EAAOsP,YAEXuwE,EAAmBpqB,WAAYz1D,GAMlC,IAEA6/E,EAAmBvqB,YAAa6qB,EAAM93B,iBAEtC55B,EAAM3c,UAAU,SAAW9R,GAE1B,MAAM8T,EAAW9T,EAAO8T,SAExB,GAAKA,EAEJ,GAAKh/B,MAAME,QAAS8+B,GAEnB,IAAM,IAAI3/B,EAAI,EAAGA,EAAI2/B,EAASt/B,OAAQL,IAIrCuyG,EAFkB5yE,EAAU3/B,GAERs6C,EAAOzuB,QAM5B0mF,EAAS5yE,EAAU2a,EAAOzuB,EAM7B,IAEA+/E,EAAiBnvB,MACjBivB,EAAqB,IAEtB,EAIA,IAAI9E,GAA2B,KAQ/B,SAAS+J,KAER9wE,GAAUkf,MAEX,CAEA,SAAS6xD,KAER/wE,GAAU+O,OAEX,CAEA,MAAM/O,GAAY,IAAI0e,GAwKtB,SAASi0D,GAAe3mF,EAAQjD,EAAQi0D,EAAYivB,GAEnD,IAAwB,IAAnBjgF,EAAOqP,QAAoB,OAIhC,GAFgBrP,EAAO0N,OAAOn3B,KAAMwmB,EAAO2Q,QAI1C,GAAK1N,EAAOyyE,QAEXzhB,EAAahxD,EAAOyP,iBAEd,GAAKzP,EAAO4mF,OAES,IAAtB5mF,EAAOo3D,YAAsBp3D,EAAO9kB,OAAQ6hB,QAE3C,GAAKiD,EAAO8Q,QAElB+uE,EAAmBrqB,UAAWx1D,GAEzBA,EAAOsP,YAEXuwE,EAAmBpqB,WAAYz1D,QAI1B,GAAKA,EAAOwmF,UAElB,IAAOxmF,EAAOwP,eAAiB4mD,EAAS7jC,iBAAkBvyB,GAAW,CAE/DigF,GAEJyB,GAAS/iF,sBAAuBqB,EAAO5C,aACrCpI,aAAcysF,IAIjB,MAAMzgF,EAAWgkC,GAAQ9pD,OAAQ8kB,GAC3B8T,EAAW9T,EAAO8T,SAEnBA,EAASzE,SAEbuwE,EAAkBtsG,KAAM0sB,EAAQgB,EAAU8S,EAAUk9C,EAAY0wB,GAAS/sF,EAAG,KAI9E,OAEM,IAAKqL,EAAOqT,QAAUrT,EAAOsT,QAAUtT,EAAOuT,aAE7CvT,EAAOwP,eAAiB4mD,EAAS9jC,iBAAkBtyB,IAAW,CAEpE,MAAMgB,EAAWgkC,GAAQ9pD,OAAQ8kB,GAC3B8T,EAAW9T,EAAO8T,SAsBxB,GApBKmsE,SAE2BjvG,IAA1BgvB,EAAO6iB,gBAEoB,OAA1B7iB,EAAO6iB,gBAA0B7iB,EAAO0jB,wBAC7Cg+D,GAASz6F,KAAM+Y,EAAO6iB,eAAe94B,UAIJ,OAA5BiX,EAAS6hB,gBAA0B7hB,EAAS0iB,wBACjDg+D,GAASz6F,KAAM+Z,EAAS6hB,eAAe94B,SAIxC23F,GACE1sF,aAAcgL,EAAO5C,aACrBpI,aAAcysF,KAIZ3sG,MAAME,QAAS8+B,GAAa,CAEhC,MAAM8O,EAAS5hB,EAAS4hB,OAExB,IAAM,IAAIzuC,EAAI,EAAGoN,EAAIqhC,EAAOpuC,OAAQL,EAAIoN,EAAGpN,IAAO,CAEjD,MAAM+wC,EAAQtC,EAAQzuC,GAChBy0C,EAAgB9U,EAAUoR,EAAM5B,eAEjCsF,GAAiBA,EAAcvZ,SAEnCuwE,EAAkBtsG,KAAM0sB,EAAQgB,EAAU4nB,EAAeooC,EAAY0wB,GAAS/sF,EAAGuwB,EAInF,CAED,MAAYpR,EAASzE,SAEpBuwE,EAAkBtsG,KAAM0sB,EAAQgB,EAAU8S,EAAUk9C,EAAY0wB,GAAS/sF,EAAG,KAI9E,CAMF,MAAMuM,EAAWlB,EAAOkB,SAExB,IAAM,IAAI/sB,EAAI,EAAGoN,EAAI2f,EAAS1sB,OAAQL,EAAIoN,EAAGpN,IAE5CwyG,GAAezlF,EAAU/sB,GAAK4oB,EAAQi0D,EAAYivB,EAIpD,CAEA,SAAS4G,GAAajH,EAAmBnxD,EAAO1xB,EAAQpG,GAEvD,MAAMmwF,EAAgBlH,EAAkBt3B,OAClCy+B,EAAsBnH,EAAkBvuB,aACxC21B,EAAqBpH,EAAkBnoE,YAE7CooE,EAAmBtqB,gBAAiBx4D,IAEV,IAArBukF,GAA4B71D,GAAS4iB,eAAgB8xC,EAAMvnE,eAAgB7b,GAE3EgqF,EAAoBvyG,OAAS,GAkBnC,SAAiCsyG,EAAeC,EAAqBt4D,EAAO1xB,GAE3E,MAAM02B,EAAWD,GAAaC,SAEK,OAA9B+tD,IAEJA,EAA4B,IAAIlrF,GAAmB,EAAG,EAAG,CACxD9C,iBAAiB,EACjB5S,KAAM8qC,GAAW+f,IAAK,+BAAkCxsD,EAAgBJ,EACxE+T,UAAWhU,EACXoY,QAAS,EAAe,EAAI,KAe9BmpF,EAAMyD,qBAAsBh0D,IAEvB6D,EAEJ+tD,EAA0BvqF,QAAS24B,GAASz/C,EAAGy/C,GAASv/C,GAIxDmxG,EAA0BvqF,QAASnU,GAAiB8sC,GAASz/C,GAAK2S,GAAiB8sC,GAASv/C,IAM7F,MAAMq+C,EAAsByxD,EAAMr1D,kBAClCq1D,EAAMpxD,gBAAiByyD,GAEvBrB,EAAM16C,cAAeo7C,GACrBC,EAAqBX,EAAMx6C,gBACtBm7C,EAAqB,GAAIX,EAAMz6C,cAAe,SAAU,IAE7Dy6C,EAAMjvE,QAIN,MAAMyd,EAAqBwxD,EAAMvxD,YACjCuxD,EAAMvxD,YAAcjxC,EAEpBspG,GAAeH,EAAer4D,EAAO1xB,GAErC7I,GAAS45E,8BAA+B0T,GACxCttF,GAAS25E,yBAA0B2T,GAEnC,IAAI0F,GAA0B,EAE9B,IAAM,IAAI/yG,EAAI,EAAGoN,EAAIwlG,EAAoBvyG,OAAQL,EAAIoN,EAAGpN,IAAO,CAE9D,MAAMo9E,EAAaw1B,EAAqB5yG,GAElC6rB,EAASuxD,EAAWvxD,OACpBgB,EAAWuwD,EAAWvwD,SACtB8S,EAAWy9C,EAAWz9C,SACtBoR,EAAQqsC,EAAWrsC,MAEzB,GAAKpR,EAASwD,OAASh6B,GAAc0iB,EAAO0N,OAAOn3B,KAAMwmB,EAAO2Q,QAAW,CAE1E,MAAMy5E,EAAcrzE,EAASwD,KAE7BxD,EAASwD,KAxj5BG,EAyj5BZxD,EAASniB,aAAc,EAEvBumE,GAAcl4D,EAAQyuB,EAAO1xB,EAAQiE,EAAU8S,EAAUoR,GAEzDpR,EAASwD,KAAO6vE,EAChBrzE,EAASniB,aAAc,EAEvBu1F,GAA0B,CAE3B,CAED,EAEiC,IAA5BA,IAEJhzF,GAAS45E,8BAA+B0T,GACxCttF,GAAS25E,yBAA0B2T,IAIpCrB,EAAMpxD,gBAAiBL,GAEvByxD,EAAMz6C,cAAem7C,EAAoBC,GAEzCX,EAAMvxD,YAAcD,CAErB,CAtHuCy4D,CAAwBN,EAAeC,EAAqBt4D,EAAO1xB,GAEpGpG,GAAWouC,GAAMpuC,SAAU+pF,EAAiBz5F,KAAM0P,IAElDmwF,EAActyG,OAAS,GAAIyyG,GAAeH,EAAer4D,EAAO1xB,GAChEgqF,EAAoBvyG,OAAS,GAAIyyG,GAAeF,EAAqBt4D,EAAO1xB,GAC5EiqF,EAAmBxyG,OAAS,GAAIyyG,GAAeD,EAAoBv4D,EAAO1xB,GAI/EgoC,GAAMrR,QAAQl9B,MAAMqiE,SAAS,GAC7B9zB,GAAMrR,QAAQl9B,MAAMujE,SAAS,GAC7Bh1B,GAAMrR,QAAQrkC,MAAM0qE,SAAS,GAE7Bh1B,GAAMo8B,kBAAkB,EAEzB,CAwGA,SAAS8lB,GAAephD,EAAYpX,EAAO1xB,GAE1C,MAAM6kF,GAAqC,IAAlBnzD,EAAMxb,QAAmBwb,EAAMmzD,iBAAmB,KAE3E,IAAM,IAAIztG,EAAI,EAAGoN,EAAIskD,EAAWrxD,OAAQL,EAAIoN,EAAGpN,IAAO,CAErD,MAAMo9E,EAAa1rB,EAAY1xD,GAEzB6rB,EAASuxD,EAAWvxD,OACpBgB,EAAWuwD,EAAWvwD,SACtB8S,EAAgC,OAArB8tE,EAA4BrwB,EAAWz9C,SAAW8tE,EAC7D18D,EAAQqsC,EAAWrsC,MAEpBllB,EAAO0N,OAAOn3B,KAAMwmB,EAAO2Q,SAE/BwqD,GAAcl4D,EAAQyuB,EAAO1xB,EAAQiE,EAAU8S,EAAUoR,EAI3D,CAED,CAEA,SAASgzC,GAAcl4D,EAAQyuB,EAAO1xB,EAAQiE,EAAU8S,EAAUoR,GAEjEllB,EAAO2P,eAAgBwwE,EAAO1xD,EAAO1xB,EAAQiE,EAAU8S,EAAUoR,GAEjEllB,EAAO+O,gBAAgB3jB,iBAAkB2R,EAAOC,mBAAoBgD,EAAO5C,aAC3E4C,EAAOgP,aAAa1hB,gBAAiB0S,EAAO+O,iBAE5C+E,EAASnE,eAAgBwwE,EAAO1xD,EAAO1xB,EAAQiE,EAAUhB,EAAQklB,IAEnC,IAAzBpR,EAAS2D,aAAwB3D,EAASwD,OAASh6B,IAA2C,IAA7Bw2B,EAAS0F,iBAE9E1F,EAASwD,KAvn5BI,EAwn5BbxD,EAASniB,aAAc,EACvBwuF,EAAM1oB,mBAAoB16D,EAAQ0xB,EAAOztB,EAAU8S,EAAU9T,EAAQklB,GAErEpR,EAASwD,KAAOj6B,EAChBy2B,EAASniB,aAAc,EACvBwuF,EAAM1oB,mBAAoB16D,EAAQ0xB,EAAOztB,EAAU8S,EAAU9T,EAAQklB,GAErEpR,EAASwD,KAAOh6B,GAIhB6iG,EAAM1oB,mBAAoB16D,EAAQ0xB,EAAOztB,EAAU8S,EAAU9T,EAAQklB,GAItEllB,EAAO4P,cAAeuwE,EAAO1xD,EAAO1xB,EAAQiE,EAAU8S,EAAUoR,EAEjE,CAEA,SAASigE,GAAYrxE,EAAU2a,EAAOzuB,IAEd,IAAlByuB,EAAMxb,UAAmBwb,EAAQkzD,IAEtC,MAAMnzC,EAAqBnO,GAAW3jD,IAAKo3B,GAErC0X,EAASq0D,EAAmB96C,MAAMvZ,OAClC6pC,EAAewqB,EAAmB96C,MAAMswB,aAExC6vB,EAAqB15D,EAAOuZ,MAAMrzC,QAElC8hB,EAAasuE,GAAa70B,cAAen5C,EAAU0X,EAAOuZ,MAAOswB,EAAc5mC,EAAOzuB,GACtFqnF,EAAkBvF,GAAa1xB,mBAAoB58C,GAEzD,IAAI6iC,EAAW7H,EAAmB6H,SAIlC7H,EAAmBp7B,YAAcU,EAASq5C,uBAAyB1+B,EAAMrb,YAAc,KACvFo7B,EAAmBnwB,IAAMoQ,EAAMpQ,IAC/BmwB,EAAmBzxB,QAAWjJ,EAASq5C,uBAAyBroB,GAAaD,IAAWnoD,IAAKo3B,EAASiJ,QAAUyxB,EAAmBp7B,kBAEjHpiC,IAAbqlE,IAIJviC,EAAShkC,iBAAkB,UAAWmzG,IAEtC5sC,EAAW,IAAIwM,IACfrU,EAAmB6H,SAAWA,GAI/B,IAAI5O,EAAU4O,EAAS35D,IAAK2qG,GAE5B,QAAiBr2G,IAAZy2D,GAIJ,GAAK+G,EAAmB8tB,iBAAmB70B,GAAW+G,EAAmB02C,qBAAuBA,EAI/F,OAFAoC,GAAgCxzE,EAAUN,GAEnCi0B,OAMRj0B,EAAWkX,SAAWo3D,GAAazpC,YAAavkC,GAEhDA,EAAS8F,QAAS5Z,EAAQwT,EAAY2sE,GAEtCrsE,EAAS+F,gBAAiBrG,EAAY2sE,GAEtC14C,EAAUq6C,GAAatxB,eAAgBh9C,EAAY6zE,GACnDhxC,EAASjwD,IAAKihG,EAAiB5/C,GAE/B+G,EAAmB9jB,SAAWlX,EAAWkX,SAI1C,MAAMA,EAAW8jB,EAAmB9jB,UAE3B5W,EAASqX,kBAAsBrX,EAAS6xC,uBAA+C,IAAtB7xC,EAAS2X,WAElFf,EAAS9R,eAAiB6S,GAAS8hB,SAIpC+5C,GAAgCxzE,EAAUN,GAI1Cg7B,EAAmBy2C,YAsbpB,SAA8BnxE,GAE7B,OAAOA,EAASooE,uBAAyBpoE,EAASqoE,oBAAsBroE,EAASuoE,qBAChFvoE,EAASq5C,wBAA0Br5C,EAASwpE,kBAC1CxpE,EAASqX,mBAAwC,IAApBrX,EAAS0X,MAE1C,CA5bkC+7D,CAAqBzzE,GACtD06B,EAAmB02C,mBAAqBA,EAEnC12C,EAAmBy2C,cAIvBv6D,EAASwV,kBAAkBjvD,MAAQu6C,EAAOuZ,MAAMouB,QAChDzoC,EAASyV,WAAWlvD,MAAQu6C,EAAOuZ,MAAMquB,MACzC1oC,EAAS0V,kBAAkBnvD,MAAQu6C,EAAOuZ,MAAMgrB,YAChDrlC,EAAS4V,wBAAwBrvD,MAAQu6C,EAAOuZ,MAAMsuB,kBACtD3oC,EAASmW,WAAW5vD,MAAQu6C,EAAOuZ,MAAMirB,KACzCtlC,EAASuW,iBAAiBhwD,MAAQu6C,EAAOuZ,MAAMuuB,WAC/C5oC,EAASoX,eAAe7wD,MAAQu6C,EAAOuZ,MAAMkrB,SAC7CvlC,EAASqX,MAAM9wD,MAAQu6C,EAAOuZ,MAAMwuB,aACpC7oC,EAASsX,MAAM/wD,MAAQu6C,EAAOuZ,MAAMyuB,aACpC9oC,EAAS2W,YAAYpwD,MAAQu6C,EAAOuZ,MAAMxkC,MAC1CmqB,EAAS4W,kBAAkBrwD,MAAQu6C,EAAOuZ,MAAM0uB,YAChD/oC,EAASiX,iBAAiB1wD,MAAQu6C,EAAOuZ,MAAMmrB,KAE/CxlC,EAASiW,qBAAqB1vD,MAAQu6C,EAAOuZ,MAAMpE,qBACnDjW,EAASkW,wBAAwB3vD,MAAQu6C,EAAOuZ,MAAMnE,wBACtDlW,EAASyW,cAAclwD,MAAQu6C,EAAOuZ,MAAM5D,cAC5CzW,EAAS0W,gBAAgBnwD,MAAQu6C,EAAOuZ,MAAM3D,gBAC9C1W,EAASwW,aAAajwD,MAAQu6C,EAAOuZ,MAAM7D,aAC3CxW,EAAS+W,eAAexwD,MAAQu6C,EAAOuZ,MAAMtD,eAC7C/W,EAASgX,kBAAkBzwD,MAAQu6C,EAAOuZ,MAAMrD,mBAKjD,MAAM8lD,EAAe//C,EAAQ4Q,cACvB2tC,EAAetmC,GAAc+nC,aAAcD,EAAa3oC,IAAKn0B,GAKnE,OAHA8jB,EAAmB8tB,eAAiB70B,EACpC+G,EAAmBw3C,aAAeA,EAE3Bv+C,CAER,CAEA,SAAS6/C,GAAgCxzE,EAAUN,GAElD,MAAMg7B,EAAqBnO,GAAW3jD,IAAKo3B,GAE3C06B,EAAmBzjB,iBAAmBvX,EAAWuX,iBACjDyjB,EAAmBsX,WAAatyC,EAAWsyC,WAC3CtX,EAAmBwZ,SAAWx0C,EAAWw0C,SACzCxZ,EAAmBkJ,aAAelkC,EAAWkkC,aAC7ClJ,EAAmBmJ,aAAenkC,EAAWmkC,aAC7CnJ,EAAmBoJ,YAAcpkC,EAAWokC,YAC5CpJ,EAAmB6I,kBAAoB7jC,EAAW6jC,kBAClD7I,EAAmB+T,kBAAoB/uC,EAAW+uC,kBAClD/T,EAAmBR,gBAAkBx6B,EAAWgvC,oBAChDhU,EAAmBmZ,aAAen0C,EAAWm0C,aAC7CnZ,EAAmBkZ,eAAiBl0C,EAAWk0C,eAC/ClZ,EAAmB5f,YAAcpb,EAAWob,WAE7C,CArlBA5a,GAAUof,kBAnBV,SAA2BL,GAErBgoD,IAA2BA,GAA0BhoD,EAE3D,IAiBqB,oBAAT20D,MAAuB1zE,GAAUqf,WAAYq0D,MAEzD7zG,KAAKu/C,iBAAmB,SAAWt3B,GAElCi/E,GAA2Bj/E,EAC3BgzB,GAAGsE,iBAAkBt3B,GAEN,OAAbA,EAAsBkY,GAAUkf,OAASlf,GAAU+O,OAEtD,EAEA+L,GAAGh/C,iBAAkB,eAAgBg1G,IACrCh2D,GAAGh/C,iBAAkB,aAAci1G,IAInClxG,KAAKm7C,OAAS,SAAWP,EAAO1xB,GAE/B,QAAgB/rB,IAAX+rB,IAA4C,IAApBA,EAAO8T,SAGnC,YADA1+B,QAAQ6+B,MAAO,0EAKhB,IAAwB,IAAnBovE,EAA0B,QAIM,IAAhC3xD,EAAMtf,uBAAiCsf,EAAMxc,oBAI3B,OAAlBlV,EAAO4R,SAAoD,IAAjC5R,EAAOoS,uBAAiCpS,EAAOkV,qBAE1D,IAAf6c,GAAGp/B,UAAwC,IAApBo/B,GAAGioD,gBAED,IAAxBjoD,GAAGooD,kBAA4BpoD,GAAG0qD,aAAcz8E,GAErDA,EAAS+xB,GAAG8rD,cAKU,IAAlBnsD,EAAMxb,SAAmBwb,EAAM9e,eAAgBwwE,EAAO1xD,EAAO1xB,EAAQwjF,GAE1EV,EAAqBjqB,GAAal5E,IAAK+xC,EAAOsxD,EAAiBvrG,QAC/DqrG,EAAmB5xC,OAEnB8xC,EAAiBzsG,KAAMusG,GAEvB4B,GAAkBr2F,iBAAkB2R,EAAOE,iBAAkBF,EAAOC,oBACpEo5D,EAAS/kC,wBAAyBowD,IAElCF,EAAwB1tG,KAAKu5D,qBAC7Bk0C,EAAmB71D,GAASwiB,KAAMp6D,KAAK+kC,eAAgB2oE,GAEvD3B,EAAoBmC,GAAYrlG,IAAK+xC,EAAOqxD,EAAgBtrG,QAC5DorG,EAAkB3xC,OAElB6xC,EAAgBxsG,KAAMssG,GAEtB+G,GAAel4D,EAAO1xB,EAAQ,EAAGojF,EAAMF,aAEvCL,EAAkBpuB,UAES,IAAtB2uB,EAAMF,aAEVL,EAAkBpnC,KAAM0oC,EAAaC,GAMtCttG,KAAK22D,KAAKxb,OAAOgE,SAES,IAArBsuD,GAA4B71D,GAAS0iB,eAE1C,MAAMknB,EAAewqB,EAAmB96C,MAAMswB,aAmB9C,GAjBAlF,GAAUnhC,OAAQqmC,EAAc5mC,EAAO1xB,IAEb,IAArBukF,GAA4B71D,GAAS2iB,cAIb,IAAxBv6D,KAAK22D,KAAK8L,WAAqBziE,KAAK22D,KAAKpC,QAK9Cl1B,GAAW8b,OAAQ4wD,EAAmBnxD,GAItCoxD,EAAmBvqB,YAAa6qB,EAAM93B,iBAEjCtrD,EAAOw1E,cAAgB,CAE3B,MAAM/jD,EAAUzxB,EAAOyxB,QAEvB,IAAM,IAAIr6C,EAAI,EAAGoN,EAAIitC,EAAQh6C,OAAQL,EAAIoN,EAAGpN,IAAO,CAElD,MAAMwzG,EAAUn5D,EAASr6C,GAEzB0yG,GAAajH,EAAmBnxD,EAAOk5D,EAASA,EAAQhxF,SAEzD,CAED,MAECkwF,GAAajH,EAAmBnxD,EAAO1xB,GAMV,OAAzBwjF,IAIJrsF,GAAS45E,8BAA+ByS,GAIxCrsF,GAAS25E,yBAA0B0S,KAMb,IAAlB9xD,EAAMxb,SAAmBwb,EAAM7e,cAAeuwE,EAAO1xD,EAAO1xB,GAIjE2pC,GAAc2B,oBACdm4C,GAAuB,EACvBC,EAAiB,KAEjBV,EAAiBnvB,MAIhBivB,EAFIE,EAAiBvrG,OAAS,EAETurG,EAAkBA,EAAiBvrG,OAAS,GAI5C,KAItBsrG,EAAgBlvB,MAIfgvB,EAFIE,EAAgBtrG,OAAS,EAETsrG,EAAiBA,EAAgBtrG,OAAS,GAI1C,IAItB,EAozBAX,KAAK2kF,kBAAoB,WAExB,OAAO6nB,CAER,EAEAxsG,KAAK6kF,qBAAuB,WAE3B,OAAO4nB,CAER,EAEAzsG,KAAKi3C,gBAAkB,WAEtB,OAAOy1D,CAER,EAEA1sG,KAAKynG,wBAA0B,SAAWttD,EAAcs/C,EAAcv2E,GAErEspC,GAAW3jD,IAAKsxC,EAAap3B,SAAUuwE,eAAiBmG,EACxDjtC,GAAW3jD,IAAKsxC,EAAaj3B,cAAeowE,eAAiBpwE,EAE7D,MAAMmwE,EAAyB7mC,GAAW3jD,IAAKsxC,GAC/Ck5C,EAAuBoE,uBAAwB,EAE1CpE,EAAuBoE,wBAE3BpE,EAAuBuF,+BAA6Cz7F,IAAjB+lB,EAE5CmwE,EAAuBuF,4BAIqC,IAA7D/gD,GAAW+f,IAAK,0CAEpBt5D,QAAQkU,KAAM,0GACd6gF,EAAuB2F,sBAAuB,GAQlD,EAEAh5F,KAAKqnG,2BAA6B,SAAWltD,EAAc45D,GAE1D,MAAM1gB,EAAyB7mC,GAAW3jD,IAAKsxC,GAC/Ck5C,EAAuBG,mBAAqBugB,EAC5C1gB,EAAuB2gB,6BAAiD72G,IAAvB42G,CAElD,EAEA/zG,KAAKk7C,gBAAkB,SAAWf,EAAcuqC,EAAiB,EAAGE,EAAoB,GAEvF8nB,EAAuBvyD,EACvBqyD,EAAyB9nB,EACzB+nB,EAA4B7nB,EAE5B,IAAIqvB,GAAwB,EACxBvmB,EAAc,KACdiL,GAAS,EACTub,GAAmB,EAEvB,GAAK/5D,EAAe,CAEnB,MAAMk5C,EAAyB7mC,GAAW3jD,IAAKsxC,QAESh9C,IAAnDk2F,EAAuB2gB,yBAG3B9iD,GAAMu8B,gBAAiBuC,GAAIpC,YAAa,MACxCqmB,GAAwB,QAEiC92G,IAA9Ck2F,EAAuBG,mBAElCnzE,GAASq5E,kBAAmBv/C,GAEjBk5C,EAAuBoE,uBAGlCp3E,GAASm5E,eAAgBr/C,EAAcqS,GAAW3jD,IAAKsxC,EAAap3B,SAAUuwE,eAAgB9mC,GAAW3jD,IAAKsxC,EAAaj3B,cAAeowE,gBAI3I,MAAMvwE,EAAUo3B,EAAap3B,SAExBA,EAAQW,iBAAmBX,EAAQQ,oBAAsBR,EAAQizE,4BAErEke,GAAmB,GAIpB,MAAM1gB,EAAqBhnC,GAAW3jD,IAAKsxC,GAAeq5C,mBAErDr5C,EAAaoB,yBAEjBmyC,EAAc8F,EAAoB9O,GAClCiU,GAAS,GAITjL,EAFa/tC,GAAaC,UAAYzF,EAAah3B,QAAU,IAAuD,IAAhD9C,GAASq3E,mBAAoBv9C,GAEnFqS,GAAW3jD,IAAKsxC,GAAew5C,+BAI/BH,EAIfqZ,EAAiBz5F,KAAM+mC,EAAar3B,UACpCgqF,EAAgB15F,KAAM+mC,EAAav3B,SACnCmqF,EAAsB5yD,EAAat3B,WAEpC,MAECgqF,EAAiBz5F,KAAMsvE,GAAY7uE,eAAgBu5F,GAAc/uG,QACjEyuG,EAAgB15F,KAAMm6F,GAAW15F,eAAgBu5F,GAAc/uG,QAC/D0uG,EAAsBS,EAgBvB,GAZyBt8C,GAAMu8B,gBAAiBuC,GAAIpC,YAAaF,IAExC/tC,GAAa3H,aAAei8D,GAEpD/iD,GAAMlZ,YAAamC,EAAcuzC,GAIlCx8B,GAAMpuC,SAAU+pF,GAChB37C,GAAMtuC,QAASkqF,GACf57C,GAAM+zB,eAAgB8nB,GAEjBpU,EAAS,CAEb,MAAM9F,EAAoBrmC,GAAW3jD,IAAKsxC,EAAap3B,SACvDitE,GAAI8H,qBAAsB9H,GAAIpC,YAAaoC,GAAIlC,kBAAmBkC,GAAI7E,4BAA8BzG,EAAgBmO,EAAkBS,eAAgB1O,EAEvJ,MAAO,GAAKsvB,EAAmB,CAE9B,MAAMrhB,EAAoBrmC,GAAW3jD,IAAKsxC,EAAap3B,SACjDoxF,EAAQzvB,GAAkB,EAChCsL,GAAIokB,wBAAyBpkB,GAAIpC,YAAaoC,GAAIlC,kBAAmB+E,EAAkBS,eAAgB1O,GAAqB,EAAGuvB,EAEhI,CAEAxH,GAAuB,CAExB,EAEA3sG,KAAKq0G,uBAAyB,SAAWl6D,EAAc79C,EAAGE,EAAGmW,EAAOC,EAAQotC,EAAQs0D,GAEnF,IAASn6D,IAAgBA,EAAaz3B,oBAGrC,YADApkB,QAAQ6+B,MAAO,4FAKhB,IAAIuwD,EAAclhC,GAAW3jD,IAAKsxC,GAAeq5C,mBAQjD,GANKr5C,EAAaoB,8BAAmDp+C,IAAxBm3G,IAE5C5mB,EAAcA,EAAa4mB,IAIvB5mB,EAAc,CAElBx8B,GAAMu8B,gBAAiBuC,GAAIpC,YAAaF,GAExC,IAEC,MAAM3qE,EAAUo3B,EAAap3B,QACvBwxF,EAAgBxxF,EAAQ/D,OACxBi2E,EAAclyE,EAAQhW,KAE5B,GAAKwnG,IAAkBjpG,GAAc2kF,GAAMh0E,QAASs4F,KAAoBvkB,GAAIxiE,aAAcwiE,GAAIwkB,kCAG7F,YADAl2G,QAAQ6+B,MAAO,6GAKhB,MAAMs3E,EAA4Bxf,IAAgB7pF,IAAqBysC,GAAW+f,IAAK,gCAAqCjY,GAAaC,UAAY/H,GAAW+f,IAAK,2BAErK,KAAKq9B,IAAgBjqF,GAAoBilF,GAAMh0E,QAASg5E,KAAkBjF,GAAIxiE,aAAcwiE,GAAI0kB,iCAC3Fzf,IAAgB9pF,IAAew0C,GAAaC,UAAY/H,GAAW+f,IAAK,sBAAyB/f,GAAW+f,IAAK,8BACnH68C,GAGF,YADAn2G,QAAQ6+B,MAAO,uHAOT7gC,GAAK,GAAKA,GAAO69C,EAAaxnC,MAAQA,GAAenW,GAAK,GAAKA,GAAO29C,EAAavnC,OAASA,GAElGo9E,GAAI2kB,WAAYr4G,EAAGE,EAAGmW,EAAOC,EAAQq9E,GAAMh0E,QAASs4F,GAAiBtkB,GAAMh0E,QAASg5E,GAAej1C,EAIrG,CAAE,QAID,MAAM0tC,EAAyC,OAAzBgf,EAAkClgD,GAAW3jD,IAAK6jG,GAAuBlZ,mBAAqB,KACpHtiC,GAAMu8B,gBAAiBuC,GAAIpC,YAAaF,EAEzC,CAED,CAED,EAEA1tF,KAAK40G,yBAA2B,SAAWxnF,EAAUrK,EAAS8xF,EAAQ,GAErE,MAAMC,EAAa92G,KAAK8Q,IAAK,GAAK+lG,GAC5BliG,EAAQ3U,KAAKK,MAAO0kB,EAAQpG,MAAMhK,MAAQmiG,GAC1CliG,EAAS5U,KAAKK,MAAO0kB,EAAQpG,MAAM/J,OAASkiG,GAElDz0F,GAASuoD,aAAc7lD,EAAS,GAEhCitE,GAAI+kB,kBAAmB/kB,GAAI/E,WAAY4pB,EAAO,EAAG,EAAGznF,EAAS9wB,EAAG8wB,EAAS5wB,EAAGmW,EAAOC,GAEnFs+C,GAAM29B,eAEP,EAEA7uF,KAAKg1G,qBAAuB,SAAW5nF,EAAU6nF,EAAYC,EAAYL,EAAQ,GAEhF,MAAMliG,EAAQsiG,EAAWt4F,MAAMhK,MACzBC,EAASqiG,EAAWt4F,MAAM/J,OAC1By+E,EAAWpB,GAAMh0E,QAASi5F,EAAWl2F,QACrCsyE,EAASrB,GAAMh0E,QAASi5F,EAAWnoG,MAEzCsT,GAASuoD,aAAcssC,EAAY,GAInCllB,GAAIkG,YAAalG,GAAImG,oBAAqB+e,EAAWr1F,OACrDmwE,GAAIkG,YAAalG,GAAIoG,+BAAgC8e,EAAWt1F,kBAChEowE,GAAIkG,YAAalG,GAAIqG,iBAAkB6e,EAAWp1F,iBAE7Cm1F,EAAW72F,cAEf4xE,GAAIP,cAAeO,GAAI/E,WAAY4pB,EAAOznF,EAAS9wB,EAAG8wB,EAAS5wB,EAAGmW,EAAOC,EAAQy+E,EAAUC,EAAQ2jB,EAAWt4F,MAAMtZ,MAI/G4xG,EAAWviB,oBAEf1C,GAAIL,wBAAyBK,GAAI/E,WAAY4pB,EAAOznF,EAAS9wB,EAAG8wB,EAAS5wB,EAAGy4G,EAAW31F,QAAS,GAAI3M,MAAOsiG,EAAW31F,QAAS,GAAI1M,OAAQy+E,EAAU4jB,EAAW31F,QAAS,GAAIjc,MAI7K2sF,GAAIP,cAAeO,GAAI/E,WAAY4pB,EAAOznF,EAAS9wB,EAAG8wB,EAAS5wB,EAAG60F,EAAUC,EAAQ2jB,EAAWt4F,OAOlF,IAAVk4F,GAAeK,EAAWv1F,iBAAkBqwE,GAAIkB,eAAgBlB,GAAI/E,YAEzE/5B,GAAM29B,eAEP,EAEA7uF,KAAKm1G,uBAAyB,SAAWC,EAAWhoF,EAAU6nF,EAAYC,EAAYL,EAAQ,GAE7F,GAAKvI,EAAMsC,iBAGV,YADAtwG,QAAQkU,KAAM,6EAKf,MAAMG,EAAQyiG,EAAU7mG,IAAIjS,EAAI84G,EAAUz3G,IAAIrB,EAAI,EAC5CsW,EAASwiG,EAAU7mG,IAAI/R,EAAI44G,EAAUz3G,IAAInB,EAAI,EAC7CmmB,EAAQyyF,EAAU7mG,IAAIuS,EAAIs0F,EAAUz3G,IAAImjB,EAAI,EAC5CuwE,EAAWpB,GAAMh0E,QAASi5F,EAAWl2F,QACrCsyE,EAASrB,GAAMh0E,QAASi5F,EAAWnoG,MACzC,IAAIsoG,EAEJ,GAAKH,EAAWxxF,gBAEfrD,GAASyoD,aAAcosC,EAAY,GACnCG,EAAWrlB,GAAIrF,eAET,KAAKuqB,EAAW3xF,mBAQtB,YADAjlB,QAAQkU,KAAM,+GALd6N,GAAS6oD,kBAAmBgsC,EAAY,GACxCG,EAAWrlB,GAAIpF,gBAOhB,CAEAoF,GAAIkG,YAAalG,GAAImG,oBAAqB+e,EAAWr1F,OACrDmwE,GAAIkG,YAAalG,GAAIoG,+BAAgC8e,EAAWt1F,kBAChEowE,GAAIkG,YAAalG,GAAIqG,iBAAkB6e,EAAWp1F,iBAElD,MAAMw1F,EAAetlB,GAAIxiE,aAAcwiE,GAAIulB,mBACrCC,EAAoBxlB,GAAIxiE,aAAcwiE,GAAIylB,qBAC1CC,EAAmB1lB,GAAIxiE,aAAcwiE,GAAI2lB,oBACzCC,EAAiB5lB,GAAIxiE,aAAcwiE,GAAI6lB,kBACvCC,EAAmB9lB,GAAIxiE,aAAcwiE,GAAI+lB,oBAEzCp5F,EAAQs4F,EAAWviB,oBAAsBuiB,EAAW31F,QAAS,GAAM21F,EAAWt4F,MAEpFqzE,GAAIkG,YAAalG,GAAIulB,kBAAmB54F,EAAMhK,OAC9Cq9E,GAAIkG,YAAalG,GAAIylB,oBAAqB94F,EAAM/J,QAChDo9E,GAAIkG,YAAalG,GAAI2lB,mBAAoBP,EAAUz3G,IAAIrB,GACvD0zF,GAAIkG,YAAalG,GAAI6lB,iBAAkBT,EAAUz3G,IAAInB,GACrDwzF,GAAIkG,YAAalG,GAAI+lB,mBAAoBX,EAAUz3G,IAAImjB,GAElDm0F,EAAW72F,eAAiB62F,EAAWvxF,gBAE3CssE,GAAIN,cAAe2lB,EAAUR,EAAOznF,EAAS9wB,EAAG8wB,EAAS5wB,EAAG4wB,EAAStM,EAAGnO,EAAOC,EAAQ+P,EAAO0uE,EAAUC,EAAQ30E,EAAMtZ,MAIjH4xG,EAAWjf,0BAEf13F,QAAQkU,KAAM,2FACdw9E,GAAIJ,wBAAyBylB,EAAUR,EAAOznF,EAAS9wB,EAAG8wB,EAAS5wB,EAAG4wB,EAAStM,EAAGnO,EAAOC,EAAQ+P,EAAO0uE,EAAU10E,EAAMtZ,OAIxH2sF,GAAIN,cAAe2lB,EAAUR,EAAOznF,EAAS9wB,EAAG8wB,EAAS5wB,EAAG4wB,EAAStM,EAAGnO,EAAOC,EAAQ+P,EAAO0uE,EAAUC,EAAQ30E,GAMlHqzE,GAAIkG,YAAalG,GAAIulB,kBAAmBD,GACxCtlB,GAAIkG,YAAalG,GAAIylB,oBAAqBD,GAC1CxlB,GAAIkG,YAAalG,GAAI2lB,mBAAoBD,GACzC1lB,GAAIkG,YAAalG,GAAI6lB,iBAAkBD,GACvC5lB,GAAIkG,YAAalG,GAAI+lB,mBAAoBD,GAG1B,IAAVjB,GAAeK,EAAWv1F,iBAAkBqwE,GAAIkB,eAAgBmkB,GAErEnkD,GAAM29B,eAEP,EAEA7uF,KAAK41F,YAAc,SAAW7yE,GAExBA,EAAQs4B,cAEZh7B,GAAS2oD,eAAgBjmD,EAAS,GAEvBA,EAAQW,gBAEnBrD,GAASyoD,aAAc/lD,EAAS,GAErBA,EAAQQ,oBAAsBR,EAAQizE,yBAEjD31E,GAAS6oD,kBAAmBnmD,EAAS,GAIrC1C,GAASuoD,aAAc7lD,EAAS,GAIjCmuC,GAAM29B,eAEP,EAEA7uF,KAAKg2G,WAAa,WAEjBxJ,EAAyB,EACzBC,EAA4B,EAC5BC,EAAuB,KAEvBx7C,GAAMqD,QACN1B,GAAc0B,OAEf,EAEmC,oBAAvB0hD,oBAEXA,mBAAmB1oG,cAAe,IAAI2oG,YAAa,UAAW,CAAEC,OAAQn2G,OAI1E,CAEIw4B,uBAEH,OAAO5rB,EAER,CAEIwpG,8BAGH,OADA93G,QAAQkU,KAAM,uHACLxS,KAAKw0E,eAEf,CAEI4hC,4BAAyBh5G,GAE5BkB,QAAQkU,KAAM,sHACdxS,KAAKw0E,iBAAoBp3E,CAE1B,CAEIi5G,qBAGH,OADA/3G,QAAQkU,KAAM,kGACPxS,KAAKk3C,mBAAqB7qC,GAAiBD,EAv76B7B,GAy76BtB,CAEIiqG,mBAAgBz1F,GAEnBtiB,QAAQkU,KAAM,kGACdxS,KAAKk3C,iBAAmBt2B,IAAaxU,EAAeC,GAAiBC,EAEtE,GAID,cAA6Bi/F,MAEdlpG,UAAUusG,kBAAmB,EAmE5C,MAAM0H,WAAc17E,GAEnBr4B,cAEC6c,QAEApf,KAAKo/B,SAAU,EAEfp/B,KAAK+M,KAAO,QAEZ/M,KAAKq/B,WAAa,KAClBr/B,KAAKu/B,YAAc,KACnBv/B,KAAKwqC,IAAM,KAEXxqC,KAAKgvD,qBAAuB,EAC5BhvD,KAAK8uD,oBAAsB,EAE3B9uD,KAAK+tG,iBAAmB,KAEW,oBAAvBkI,oBAEXA,mBAAmB1oG,cAAe,IAAI2oG,YAAa,UAAW,CAAEC,OAAQn2G,OAI1E,CAEAoT,KAAM3P,EAAQ88B,GAeb,OAbAnhB,MAAMhM,KAAM3P,EAAQ88B,GAEO,OAAtB98B,EAAO47B,aAAsBr/B,KAAKq/B,WAAa57B,EAAO47B,WAAWlsB,SAC1C,OAAvB1P,EAAO87B,cAAuBv/B,KAAKu/B,YAAc97B,EAAO87B,YAAYpsB,SACrD,OAAf1P,EAAO+mC,MAAexqC,KAAKwqC,IAAM/mC,EAAO+mC,IAAIr3B,SAEjDnT,KAAKgvD,qBAAuBvrD,EAAOurD,qBACnChvD,KAAK8uD,oBAAsBrrD,EAAOqrD,oBAED,OAA5BrrD,EAAOsqG,mBAA4B/tG,KAAK+tG,iBAAmBtqG,EAAOsqG,iBAAiB56F,SAExFnT,KAAK0f,iBAAmBjc,EAAOic,iBAExB1f,IAER,CAEA+d,OAAQC,GAEP,MAAM3a,EAAO+b,MAAMrB,OAAQC,GAM3B,OAJkB,OAAbhe,KAAKwqC,MAAennC,EAAK8oB,OAAOqe,IAAMxqC,KAAKwqC,IAAIzsB,UAC/C/d,KAAKgvD,qBAAuB,IAAI3rD,EAAK8oB,OAAO6iC,qBAAuBhvD,KAAKgvD,sBAC3C,IAA7BhvD,KAAK8uD,sBAA4BzrD,EAAK8oB,OAAO2iC,oBAAsB9uD,KAAK8uD,qBAEtEzrD,CAER,EAID,MAAM,GAELd,YAAakL,EAAOglC,GAEnBzyC,KAAKu2G,qBAAsB,EAE3Bv2G,KAAKyN,MAAQA,EACbzN,KAAKyyC,OAASA,EACdzyC,KAAKiF,WAAkB9H,IAAVsQ,EAAsBA,EAAM9M,OAAS8xC,EAAS,EAE3DzyC,KAAKstC,MAAQ7gC,GACbzM,KAAKutC,YAAc,CAAE53B,OAAQ,EAAG1Q,OAAS,GAEzCjF,KAAK6d,QAAU,EAEf7d,KAAK4d,KAAO7P,IAEb,CAEA0/B,mBAAoB,CAEhB3vB,gBAAa1gB,IAED,IAAVA,GAAiB4C,KAAK6d,SAE5B,CAEA6vB,SAAUtwC,GAIT,OAFA4C,KAAKstC,MAAQlwC,EAEN4C,IAER,CAEAoT,KAAM3P,GAOL,OALAzD,KAAKyN,MAAQ,IAAIhK,EAAOgK,MAAMlL,YAAakB,EAAOgK,OAClDzN,KAAKiF,MAAQxB,EAAOwB,MACpBjF,KAAKyyC,OAAShvC,EAAOgvC,OACrBzyC,KAAKstC,MAAQ7pC,EAAO6pC,MAEbttC,IAER,CAEA2tC,OAAQC,EAAQ93B,EAAW+3B,GAE1BD,GAAU5tC,KAAKyyC,OACf5E,GAAU/3B,EAAU28B,OAEpB,IAAM,IAAInyC,EAAI,EAAGoN,EAAI1N,KAAKyyC,OAAQnyC,EAAIoN,EAAGpN,IAExCN,KAAKyN,MAAOmgC,EAASttC,GAAMwV,EAAUrI,MAAOogC,EAASvtC,GAItD,OAAON,IAER,CAEAuS,IAAKnV,EAAOuY,EAAS,GAIpB,OAFA3V,KAAKyN,MAAM8E,IAAKnV,EAAOuY,GAEhB3V,IAER,CAEAmT,MAAO9P,QAEqBlG,IAAtBkG,EAAKmzG,eAETnzG,EAAKmzG,aAAe,CAAC,QAIWr5G,IAA5B6C,KAAKyN,MAAMuyC,OAAOy2D,QAEtBz2G,KAAKyN,MAAMuyC,OAAOy2D,MAAQ1oG,WAI2B5Q,IAAjDkG,EAAKmzG,aAAcx2G,KAAKyN,MAAMuyC,OAAOy2D,SAEzCpzG,EAAKmzG,aAAcx2G,KAAKyN,MAAMuyC,OAAOy2D,OAAUz2G,KAAKyN,MAAMnL,MAAO,GAAI09C,QAItE,MAAMvyC,EAAQ,IAAIzN,KAAKyN,MAAMlL,YAAac,EAAKmzG,aAAcx2G,KAAKyN,MAAMuyC,OAAOy2D,QAEzEC,EAAK,IAAI12G,KAAKuC,YAAakL,EAAOzN,KAAKyyC,QAG7C,OAFAikE,EAAGhpE,SAAU1tC,KAAKstC,OAEXopE,CAER,CAEAxoE,SAAUjmB,GAIT,OAFAjoB,KAAKytC,iBAAmBxlB,EAEjBjoB,IAER,CAEA+d,OAAQ1a,GAwBP,YAtB2BlG,IAAtBkG,EAAKmzG,eAETnzG,EAAKmzG,aAAe,CAAC,QAMWr5G,IAA5B6C,KAAKyN,MAAMuyC,OAAOy2D,QAEtBz2G,KAAKyN,MAAMuyC,OAAOy2D,MAAQ1oG,WAI2B5Q,IAAjDkG,EAAKmzG,aAAcx2G,KAAKyN,MAAMuyC,OAAOy2D,SAEzCpzG,EAAKmzG,aAAcx2G,KAAKyN,MAAMuyC,OAAOy2D,OAAUx1G,MAAMwB,KAAM,IAAI2M,YAAapP,KAAKyN,MAAMuyC,UAMjF,CACNpiC,KAAM5d,KAAK4d,KACXoiC,OAAQhgD,KAAKyN,MAAMuyC,OAAOy2D,MAC1B1pG,KAAM/M,KAAKyN,MAAMlL,YAAYC,KAC7BiwC,OAAQzyC,KAAKyyC,OAGf,EAID,MAAMkkE,GAA0B,IAAI,GAEpC,MAAM,GAELp0G,YAAaq0G,EAAmBzpE,EAAUx3B,EAAQy3B,GAAa,GAE9DptC,KAAKwyC,8BAA+B,EAEpCxyC,KAAKwC,KAAO,GAEZxC,KAAKqD,KAAOuzG,EACZ52G,KAAKmtC,SAAWA,EAChBntC,KAAK2V,OAASA,EAEd3V,KAAKotC,WAAaA,CAEnB,CAEInoC,YAEH,OAAOjF,KAAKqD,KAAK4B,KAElB,CAEIwI,YAEH,OAAOzN,KAAKqD,KAAKoK,KAElB,CAEIqQ,gBAAa1gB,GAEhB4C,KAAKqD,KAAKya,YAAc1gB,CAEzB,CAEA+jB,aAAc1S,GAEb,IAAM,IAAInO,EAAI,EAAGoN,EAAI1N,KAAKqD,KAAK4B,MAAO3E,EAAIoN,EAAGpN,IAE5Cq2G,GAAU9gG,oBAAqB7V,KAAMM,GAErCq2G,GAAUx1F,aAAc1S,GAExBzO,KAAKguC,OAAQ1tC,EAAGq2G,GAAUr6G,EAAGq6G,GAAUn6G,EAAGm6G,GAAU71F,GAIrD,OAAO9gB,IAER,CAEAwoB,kBAAmB/Z,GAElB,IAAM,IAAInO,EAAI,EAAGoN,EAAI1N,KAAKiF,MAAO3E,EAAIoN,EAAGpN,IAEvCq2G,GAAU9gG,oBAAqB7V,KAAMM,GAErCq2G,GAAUnuF,kBAAmB/Z,GAE7BzO,KAAKguC,OAAQ1tC,EAAGq2G,GAAUr6G,EAAGq6G,GAAUn6G,EAAGm6G,GAAU71F,GAIrD,OAAO9gB,IAER,CAEAwpB,mBAAoB/a,GAEnB,IAAM,IAAInO,EAAI,EAAGoN,EAAI1N,KAAKiF,MAAO3E,EAAIoN,EAAGpN,IAEvCq2G,GAAU9gG,oBAAqB7V,KAAMM,GAErCq2G,GAAUntF,mBAAoB/a,GAE9BzO,KAAKguC,OAAQ1tC,EAAGq2G,GAAUr6G,EAAGq6G,GAAUn6G,EAAGm6G,GAAU71F,GAIrD,OAAO9gB,IAER,CAEA+S,KAAMhV,EAAOzB,GAMZ,OAJK0D,KAAKotC,aAAa9wC,EAAIoT,GAAWpT,EAAG0D,KAAKyN,QAE9CzN,KAAKqD,KAAKoK,MAAO1P,EAAQiC,KAAKqD,KAAKovC,OAASzyC,KAAK2V,QAAWrZ,EAErD0D,IAER,CAEAgT,KAAMjV,EAAOvB,GAMZ,OAJKwD,KAAKotC,aAAa5wC,EAAIkT,GAAWlT,EAAGwD,KAAKyN,QAE9CzN,KAAKqD,KAAKoK,MAAO1P,EAAQiC,KAAKqD,KAAKovC,OAASzyC,KAAK2V,OAAS,GAAMnZ,EAEzDwD,IAER,CAEAihB,KAAMljB,EAAO+iB,GAMZ,OAJK9gB,KAAKotC,aAAatsB,EAAIpR,GAAWoR,EAAG9gB,KAAKyN,QAE9CzN,KAAKqD,KAAKoK,MAAO1P,EAAQiC,KAAKqD,KAAKovC,OAASzyC,KAAK2V,OAAS,GAAMmL,EAEzD9gB,IAER,CAEAkhB,KAAMnjB,EAAOgjB,GAMZ,OAJK/gB,KAAKotC,aAAarsB,EAAIrR,GAAWqR,EAAG/gB,KAAKyN,QAE9CzN,KAAKqD,KAAKoK,MAAO1P,EAAQiC,KAAKqD,KAAKovC,OAASzyC,KAAK2V,OAAS,GAAMoL,EAEzD/gB,IAER,CAEA+V,KAAMhY,GAEL,IAAIzB,EAAI0D,KAAKqD,KAAKoK,MAAO1P,EAAQiC,KAAKqD,KAAKovC,OAASzyC,KAAK2V,QAIzD,OAFK3V,KAAKotC,aAAa9wC,EAAI4S,GAAa5S,EAAG0D,KAAKyN,QAEzCnR,CAER,CAEA0Z,KAAMjY,GAEL,IAAIvB,EAAIwD,KAAKqD,KAAKoK,MAAO1P,EAAQiC,KAAKqD,KAAKovC,OAASzyC,KAAK2V,OAAS,GAIlE,OAFK3V,KAAKotC,aAAa5wC,EAAI0S,GAAa1S,EAAGwD,KAAKyN,QAEzCjR,CAER,CAEA+lB,KAAMxkB,GAEL,IAAI+iB,EAAI9gB,KAAKqD,KAAKoK,MAAO1P,EAAQiC,KAAKqD,KAAKovC,OAASzyC,KAAK2V,OAAS,GAIlE,OAFK3V,KAAKotC,aAAatsB,EAAI5R,GAAa4R,EAAG9gB,KAAKyN,QAEzCqT,CAER,CAEA0B,KAAMzkB,GAEL,IAAIgjB,EAAI/gB,KAAKqD,KAAKoK,MAAO1P,EAAQiC,KAAKqD,KAAKovC,OAASzyC,KAAK2V,OAAS,GAIlE,OAFK3V,KAAKotC,aAAarsB,EAAI7R,GAAa6R,EAAG/gB,KAAKyN,QAEzCsT,CAER,CAEAgtB,MAAOhwC,EAAOzB,EAAGE,GAchB,OAZAuB,EAAQA,EAAQiC,KAAKqD,KAAKovC,OAASzyC,KAAK2V,OAEnC3V,KAAKotC,aAET9wC,EAAIoT,GAAWpT,EAAG0D,KAAKyN,OACvBjR,EAAIkT,GAAWlT,EAAGwD,KAAKyN,QAIxBzN,KAAKqD,KAAKoK,MAAO1P,EAAQ,GAAMzB,EAC/B0D,KAAKqD,KAAKoK,MAAO1P,EAAQ,GAAMvB,EAExBwD,IAER,CAEAguC,OAAQjwC,EAAOzB,EAAGE,EAAGskB,GAgBpB,OAdA/iB,EAAQA,EAAQiC,KAAKqD,KAAKovC,OAASzyC,KAAK2V,OAEnC3V,KAAKotC,aAET9wC,EAAIoT,GAAWpT,EAAG0D,KAAKyN,OACvBjR,EAAIkT,GAAWlT,EAAGwD,KAAKyN,OACvBqT,EAAIpR,GAAWoR,EAAG9gB,KAAKyN,QAIxBzN,KAAKqD,KAAKoK,MAAO1P,EAAQ,GAAMzB,EAC/B0D,KAAKqD,KAAKoK,MAAO1P,EAAQ,GAAMvB,EAC/BwD,KAAKqD,KAAKoK,MAAO1P,EAAQ,GAAM+iB,EAExB9gB,IAER,CAEAiuC,QAASlwC,EAAOzB,EAAGE,EAAGskB,EAAGC,GAkBxB,OAhBAhjB,EAAQA,EAAQiC,KAAKqD,KAAKovC,OAASzyC,KAAK2V,OAEnC3V,KAAKotC,aAET9wC,EAAIoT,GAAWpT,EAAG0D,KAAKyN,OACvBjR,EAAIkT,GAAWlT,EAAGwD,KAAKyN,OACvBqT,EAAIpR,GAAWoR,EAAG9gB,KAAKyN,OACvBsT,EAAIrR,GAAWqR,EAAG/gB,KAAKyN,QAIxBzN,KAAKqD,KAAKoK,MAAO1P,EAAQ,GAAMzB,EAC/B0D,KAAKqD,KAAKoK,MAAO1P,EAAQ,GAAMvB,EAC/BwD,KAAKqD,KAAKoK,MAAO1P,EAAQ,GAAM+iB,EAC/B9gB,KAAKqD,KAAKoK,MAAO1P,EAAQ,GAAMgjB,EAExB/gB,IAER,CAEAmT,MAAO9P,GAEN,QAAclG,IAATkG,EAAqB,CAEzB/E,QAAQC,IAAK,qHAEb,MAAMkP,EAAQ,GAEd,IAAM,IAAInN,EAAI,EAAGA,EAAIN,KAAKiF,MAAO3E,IAAO,CAEvC,MAAMvC,EAAQuC,EAAIN,KAAKqD,KAAKovC,OAASzyC,KAAK2V,OAE1C,IAAM,IAAIyZ,EAAI,EAAGA,EAAIpvB,KAAKmtC,SAAU/d,IAEnC3hB,EAAMhO,KAAMO,KAAKqD,KAAKoK,MAAO1P,EAAQqxB,GAIvC,CAEA,OAAO,IAAI,GAAiB,IAAIpvB,KAAKyN,MAAMlL,YAAakL,GAASzN,KAAKmtC,SAAUntC,KAAKotC,WAEtF,CAcC,YAZiCjwC,IAA5BkG,EAAKwzG,qBAETxzG,EAAKwzG,mBAAqB,CAAC,QAIuB15G,IAA9CkG,EAAKwzG,mBAAoB72G,KAAKqD,KAAKua,QAEvCva,EAAKwzG,mBAAoB72G,KAAKqD,KAAKua,MAAS5d,KAAKqD,KAAK8P,MAAO9P,IAIvD,IAAI,GAA4BA,EAAKwzG,mBAAoB72G,KAAKqD,KAAKua,MAAQ5d,KAAKmtC,SAAUntC,KAAK2V,OAAQ3V,KAAKotC,WAIrH,CAEArvB,OAAQ1a,GAEP,QAAclG,IAATkG,EAAqB,CAEzB/E,QAAQC,IAAK,0HAEb,MAAMkP,EAAQ,GAEd,IAAM,IAAInN,EAAI,EAAGA,EAAIN,KAAKiF,MAAO3E,IAAO,CAEvC,MAAMvC,EAAQuC,EAAIN,KAAKqD,KAAKovC,OAASzyC,KAAK2V,OAE1C,IAAM,IAAIyZ,EAAI,EAAGA,EAAIpvB,KAAKmtC,SAAU/d,IAEnC3hB,EAAMhO,KAAMO,KAAKqD,KAAKoK,MAAO1P,EAAQqxB,GAIvC,CAIA,MAAO,CACN+d,SAAUntC,KAAKmtC,SACfpgC,KAAM/M,KAAKyN,MAAMlL,YAAYC,KAC7BiL,MAAOA,EACP2/B,WAAYptC,KAAKotC,WAGnB,CAgBC,YAZiCjwC,IAA5BkG,EAAKwzG,qBAETxzG,EAAKwzG,mBAAqB,CAAC,QAIuB15G,IAA9CkG,EAAKwzG,mBAAoB72G,KAAKqD,KAAKua,QAEvCva,EAAKwzG,mBAAoB72G,KAAKqD,KAAKua,MAAS5d,KAAKqD,KAAK0a,OAAQ1a,IAIxD,CACNmvC,8BAA8B,EAC9BrF,SAAUntC,KAAKmtC,SACf9pC,KAAMrD,KAAKqD,KAAKua,KAChBjI,OAAQ3V,KAAK2V,OACby3B,WAAYptC,KAAKotC,WAKpB,EAibD,MAAM0pE,GAA8B,IAAI,GAElCC,GAA2B,IAAIl2F,GAC/Bm2F,GAA4B,IAAIn2F,GAEhCgtF,GAAyB,IAAI,GAC7BoJ,GAAyB,IAAIxjF,GAC7ByjF,GAAwB,IAAI,GAE5BC,GAA0B,IAAIxnF,GAC9BynF,GAAiC,IAAI3jF,GACrC4jF,GAAuB,IAAI3mF,GAEjC,MAAM4mF,WAAoBtjE,GAEzBzxC,YAAa4qB,EAAU8S,GAEtB7gB,MAAO+N,EAAU8S,GAEjBjgC,KAAK6/B,eAAgB,EAErB7/B,KAAK+M,KAAO,cAEZ/M,KAAK8/B,SAAW,WAChB9/B,KAAK+/B,WAAa,IAAItM,GACtBzzB,KAAKu3G,kBAAoB,IAAI9jF,GAE7BzzB,KAAK+sB,YAAc,KACnB/sB,KAAKgvC,eAAiB,IAEvB,CAEAhiB,qBAEC,MAAMG,EAAWntB,KAAKmtB,SAEI,OAArBntB,KAAK+sB,cAET/sB,KAAK+sB,YAAc,IAAI1B,IAIxBrrB,KAAK+sB,YAAYvB,YAEjB,MAAMkmB,EAAoBvkB,EAASkiB,aAAc,YAEjD,IAAM,IAAI/uC,EAAI,EAAGA,EAAIoxC,EAAkBzsC,MAAO3E,IAE7C42G,GAAQrhG,oBAAqB67B,EAAmBpxC,GAChDN,KAAKw3G,mBAAoBl3G,EAAG42G,IAC5Bl3G,KAAK+sB,YAAYrB,cAAewrF,GAIlC,CAEArnE,wBAEC,MAAM1iB,EAAWntB,KAAKmtB,SAEO,OAAxBntB,KAAKgvC,iBAEThvC,KAAKgvC,eAAiB,IAAIrf,IAI3B3vB,KAAKgvC,eAAexjB,YAEpB,MAAMkmB,EAAoBvkB,EAASkiB,aAAc,YAEjD,IAAM,IAAI/uC,EAAI,EAAGA,EAAIoxC,EAAkBzsC,MAAO3E,IAE7C42G,GAAQrhG,oBAAqB67B,EAAmBpxC,GAChDN,KAAKw3G,mBAAoBl3G,EAAG42G,IAC5Bl3G,KAAKgvC,eAAetjB,cAAewrF,GAIrC,CAEA9jG,KAAM3P,EAAQ88B,GAab,OAXAnhB,MAAMhM,KAAM3P,EAAQ88B,GAEpBvgC,KAAK8/B,SAAWr8B,EAAOq8B,SACvB9/B,KAAK+/B,WAAW3sB,KAAM3P,EAAOs8B,YAC7B//B,KAAKu3G,kBAAkBnkG,KAAM3P,EAAO8zG,mBAEpCv3G,KAAKggC,SAAWv8B,EAAOu8B,SAEK,OAAvBv8B,EAAOspB,cAAuB/sB,KAAK+sB,YAActpB,EAAOspB,YAAY5Z,SAC1C,OAA1B1P,EAAOurC,iBAA0BhvC,KAAKgvC,eAAiBvrC,EAAOurC,eAAe77B,SAE3EnT,IAER,CAEAg+B,QAAS0W,EAAWC,GAEnB,MAAM1U,EAAWjgC,KAAKigC,SAChB1W,EAAcvpB,KAAKupB,iBAEPpsB,IAAb8iC,IAIwB,OAAxBjgC,KAAKgvC,gBAA0BhvC,KAAK6vC,wBAEzCsnE,GAAU/jG,KAAMpT,KAAKgvC,gBACrBmoE,GAAUh2F,aAAcoI,IAE6B,IAAhDmrB,EAAU7jB,IAAInD,iBAAkBypF,MAIrCC,GAAiBhkG,KAAMmW,GAActQ,SACrCo+F,GAAOjkG,KAAMshC,EAAU7jB,KAAM1P,aAAci2F,IAIjB,OAArBp3G,KAAK+sB,cAEyC,IAA7CsqF,GAAO5pF,cAAeztB,KAAK+sB,cAMjC/sB,KAAK40C,sBAAuBF,EAAWC,EAAY0iE,KAEpD,CAEA/iE,kBAAmBv2C,EAAOqG,GAMzB,OAJAgb,MAAMk1B,kBAAmBv2C,EAAOqG,GAEhCpE,KAAKw3G,mBAAoBz5G,EAAOqG,GAEzBA,CAER,CAEAmD,KAAMy4B,EAAUD,GAEf//B,KAAKggC,SAAWA,OAEI7iC,IAAf4iC,IAEJ//B,KAAKo+B,mBAAmB,GAExBp+B,KAAKggC,SAASy3E,oBAEd13E,EAAa//B,KAAKupB,aAInBvpB,KAAK+/B,WAAW3sB,KAAM2sB,GACtB//B,KAAKu3G,kBAAkBnkG,KAAM2sB,GAAa9mB,QAE3C,CAEA6oF,OAEC9hG,KAAKggC,SAAS8hE,MAEf,CAEA4V,uBAEC,MAAM9qF,EAAS,IAAI/L,GAEb82F,EAAa33G,KAAKmtB,SAASxnB,WAAWgyG,WAE5C,IAAM,IAAIr3G,EAAI,EAAGoN,EAAIiqG,EAAW1yG,MAAO3E,EAAIoN,EAAGpN,IAAO,CAEpDssB,EAAO/W,oBAAqB8hG,EAAYr3G,GAExC,MAAM8Z,EAAQ,EAAMwS,EAAOjY,kBAEtByF,IAAUyvB,IAEdjd,EAAO/Y,eAAgBuG,GAIvBwS,EAAOra,IAAK,EAAG,EAAG,EAAG,GAItBolG,EAAW1pE,QAAS3tC,EAAGssB,EAAOtwB,EAAGswB,EAAOpwB,EAAGowB,EAAO9L,EAAG8L,EAAO7L,EAE7D,CAED,CAEAqd,kBAAmBC,GAElBjf,MAAMgf,kBAAmBC,GAEF,aAAlBr+B,KAAK8/B,SAET9/B,KAAKu3G,kBAAkBnkG,KAAMpT,KAAKupB,aAActQ,SAEnB,aAAlBjZ,KAAK8/B,SAEhB9/B,KAAKu3G,kBAAkBnkG,KAAMpT,KAAK+/B,YAAa9mB,SAI/C3a,QAAQkU,KAAM,6CAA+CxS,KAAK8/B,SAIpE,CAEA03E,mBAAoBz5G,EAAO6uB,GAE1B,MAAMoT,EAAWhgC,KAAKggC,SAChB7S,EAAWntB,KAAKmtB,SAEtB4pF,GAAWlhG,oBAAqBsX,EAASxnB,WAAWiyG,UAAW75G,GAC/Di5G,GAAYnhG,oBAAqBsX,EAASxnB,WAAWgyG,WAAY55G,GAEjE+4G,GAAc1jG,KAAMwZ,GAASzL,aAAcnhB,KAAK+/B,YAEhDnT,EAAOra,IAAK,EAAG,EAAG,GAElB,IAAM,IAAIjS,EAAI,EAAGA,EAAI,EAAGA,IAAO,CAE9B,MAAMugE,EAASm2C,GAAY9jG,aAAc5S,GAEzC,GAAgB,IAAXugE,EAAe,CAEnB,MAAMg3C,EAAYd,GAAW7jG,aAAc5S,GAE3C22G,GAAS1/F,iBAAkByoB,EAAS83E,MAAOD,GAAYtuF,YAAayW,EAAS+3E,aAAcF,IAE3FjrF,EAAOpZ,gBAAiBq6F,GAASz6F,KAAM0jG,IAAgB31F,aAAc81F,IAAYp2C,EAElF,CAED,CAEA,OAAOj0C,EAAOzL,aAAcnhB,KAAKu3G,kBAElC,CAEAS,cAAej6G,EAAO6uB,GAGrB,OADAtuB,QAAQkU,KAAM,qFACPxS,KAAKw3G,mBAAoBz5G,EAAO6uB,EAExC,EAKD,MAAMqrF,WAAar9E,GAElBr4B,cAEC6c,QAEApf,KAAKk4G,QAAS,EAEdl4G,KAAK+M,KAAO,MAEb,EAID,MAAMorG,WAAoB35F,GAEzBjc,YAAac,EAAO,KAAMsP,EAAQ,EAAGC,EAAS,EAAGoM,EAAQjS,EAAM2R,EAASE,EAAOC,EAAOC,EAAYpU,EAAeqU,EAAYrU,EAAeuU,EAAYjD,GAEvJoD,MAAO,KAAMV,EAASE,EAAOC,EAAOC,EAAWC,EAAWC,EAAQjS,EAAMkS,EAAYjD,GAEpFhc,KAAKoe,eAAgB,EAErBpe,KAAK2c,MAAQ,CAAEtZ,KAAMA,EAAMsP,MAAOA,EAAOC,OAAQA,GAEjD5S,KAAK2f,iBAAkB,EACvB3f,KAAK6f,OAAQ,EACb7f,KAAK8f,gBAAkB,CAExB,EAID,MAAMs4F,GAA8B,IAAI3kF,GAClC4kF,GAAgC,IAAI5kF,GAE1C,MAAM6kF,GAEL/1G,YAAau1G,EAAQ,GAAIC,EAAe,IAEvC/3G,KAAK4d,KAAO7P,KAEZ/N,KAAK83G,MAAQA,EAAMx1G,MAAO,GAC1BtC,KAAK+3G,aAAeA,EACpB/3G,KAAKu4G,aAAe,KAEpBv4G,KAAK8xG,YAAc,KACnB9xG,KAAKgyG,gBAAkB,EAEvBhyG,KAAKo6D,MAEN,CAEAA,OAEC,MAAM09C,EAAQ93G,KAAK83G,MACbC,EAAe/3G,KAAK+3G,aAM1B,GAJA/3G,KAAKu4G,aAAe,IAAIppG,aAA6B,GAAf2oG,EAAMn3G,QAIf,IAAxBo3G,EAAap3G,OAEjBX,KAAKy3G,yBAML,GAAKK,EAAMn3G,SAAWo3G,EAAap3G,OAAS,CAE3CrC,QAAQkU,KAAM,mFAEdxS,KAAK+3G,aAAe,GAEpB,IAAM,IAAIz3G,EAAI,EAAGmrB,EAAKzrB,KAAK83G,MAAMn3G,OAAQL,EAAImrB,EAAInrB,IAEhDN,KAAK+3G,aAAat4G,KAAM,IAAIg0B,GAI9B,CAIF,CAEAgkF,oBAECz3G,KAAK+3G,aAAap3G,OAAS,EAE3B,IAAM,IAAIL,EAAI,EAAGmrB,EAAKzrB,KAAK83G,MAAMn3G,OAAQL,EAAImrB,EAAInrB,IAAO,CAEvD,MAAMk4G,EAAU,IAAI/kF,GAEfzzB,KAAK83G,MAAOx3G,IAEhBk4G,EAAQplG,KAAMpT,KAAK83G,MAAOx3G,GAAIipB,aAActQ,SAI7CjZ,KAAK+3G,aAAat4G,KAAM+4G,EAEzB,CAED,CAEA1W,OAIC,IAAM,IAAIxhG,EAAI,EAAGmrB,EAAKzrB,KAAK83G,MAAMn3G,OAAQL,EAAImrB,EAAInrB,IAAO,CAEvD,MAAMm4G,EAAOz4G,KAAK83G,MAAOx3G,GAEpBm4G,GAEJA,EAAKlvF,YAAYnW,KAAMpT,KAAK+3G,aAAcz3G,IAAM2Y,QAIlD,CAIA,IAAM,IAAI3Y,EAAI,EAAGmrB,EAAKzrB,KAAK83G,MAAMn3G,OAAQL,EAAImrB,EAAInrB,IAAO,CAEvD,MAAMm4G,EAAOz4G,KAAK83G,MAAOx3G,GAEpBm4G,IAECA,EAAK39E,QAAU29E,EAAK39E,OAAOo9E,QAE/BO,EAAK99F,OAAOvH,KAAMqlG,EAAK39E,OAAOvR,aAActQ,SAC5Cw/F,EAAK99F,OAAO/G,SAAU6kG,EAAKlvF,cAI3BkvF,EAAK99F,OAAOvH,KAAMqlG,EAAKlvF,aAIxBkvF,EAAK99F,OAAOid,UAAW6gF,EAAKrrF,SAAUqrF,EAAKpzF,WAAYozF,EAAKr+F,OAI9D,CAED,CAEA/S,SAEC,MAAMywG,EAAQ93G,KAAK83G,MACbC,EAAe/3G,KAAK+3G,aACpBQ,EAAev4G,KAAKu4G,aACpBzG,EAAc9xG,KAAK8xG,YAIzB,IAAM,IAAIxxG,EAAI,EAAGmrB,EAAKqsF,EAAMn3G,OAAQL,EAAImrB,EAAInrB,IAAO,CAIlD,MAAMqa,EAASm9F,EAAOx3G,GAAMw3G,EAAOx3G,GAAIipB,YAAc8uF,GAErDD,GAAc7gG,iBAAkBoD,EAAQo9F,EAAcz3G,IACtD83G,GAAcxiG,QAAS2iG,EAAkB,GAAJj4G,EAEtC,CAEqB,OAAhBwxG,IAEJA,EAAYh0F,aAAc,EAI5B,CAEA3K,QAEC,OAAO,IAAImlG,GAAUt4G,KAAK83G,MAAO93G,KAAK+3G,aAEvC,CAEAhG,qBASC,IAAI/lF,EAAOhuB,KAAKC,KAA0B,EAApB+B,KAAK83G,MAAMn3G,QACjCqrB,EAAOnd,GAAgBmd,GACvBA,EAAOhuB,KAAKuQ,IAAKyd,EAAM,GAEvB,MAAMusF,EAAe,IAAIppG,aAAc6c,EAAOA,EAAO,GACrDusF,EAAahmG,IAAKvS,KAAKu4G,cAEvB,MAAMzG,EAAc,IAAIqG,GAAaI,EAAcvsF,EAAMA,EAAM1gB,EAAYH,GAO3E,OANA2mG,EAAYh0F,aAAc,EAE1B9d,KAAKu4G,aAAeA,EACpBv4G,KAAK8xG,YAAcA,EACnB9xG,KAAKgyG,gBAAkBhmF,EAEhBhsB,IAER,CAEA04G,cAAel2G,GAEd,IAAM,IAAIlC,EAAI,EAAGmrB,EAAKzrB,KAAK83G,MAAMn3G,OAAQL,EAAImrB,EAAInrB,IAAO,CAEvD,MAAMm4G,EAAOz4G,KAAK83G,MAAOx3G,GAEzB,GAAKm4G,EAAKj2G,OAASA,EAElB,OAAOi2G,CAIT,CAID,CAEAh4F,UAE2B,OAArBzgB,KAAK8xG,cAET9xG,KAAK8xG,YAAYrxF,UAEjBzgB,KAAK8xG,YAAc,KAIrB,CAEA6G,SAAUC,EAAMd,GAEf93G,KAAK4d,KAAOg7F,EAAKh7F,KAEjB,IAAM,IAAItd,EAAI,EAAGoN,EAAIkrG,EAAKd,MAAMn3G,OAAQL,EAAIoN,EAAGpN,IAAO,CAErD,MAAMsd,EAAOg7F,EAAKd,MAAOx3G,GACzB,IAAIm4G,EAAOX,EAAOl6F,QAEJzgB,IAATs7G,IAEJn6G,QAAQkU,KAAM,2CAA4CoL,GAC1D66F,EAAO,IAAIR,IAIZj4G,KAAK83G,MAAMr4G,KAAMg5G,GACjBz4G,KAAK+3G,aAAat4G,MAAM,IAAIg0B,IAAU/d,UAAWkjG,EAAKb,aAAcz3G,IAErE,CAIA,OAFAN,KAAKo6D,OAEEp6D,IAER,CAEA+d,SAEC,MAAM1a,EAAO,CACZid,SAAU,CACTzC,QAAS,IACT9Q,KAAM,WACNwT,UAAW,mBAEZu3F,MAAO,GACPC,aAAc,IAGf10G,EAAKua,KAAO5d,KAAK4d,KAEjB,MAAMk6F,EAAQ93G,KAAK83G,MACbC,EAAe/3G,KAAK+3G,aAE1B,IAAM,IAAIz3G,EAAI,EAAGoN,EAAIoqG,EAAMn3G,OAAQL,EAAIoN,EAAGpN,IAAO,CAEhD,MAAMm4G,EAAOX,EAAOx3G,GACpB+C,EAAKy0G,MAAMr4G,KAAMg5G,EAAK76F,MAEtB,MAAMi7F,EAAcd,EAAcz3G,GAClC+C,EAAK00G,aAAat4G,KAAMo5G,EAAYjjG,UAErC,CAEA,OAAOvS,CAER,EAID,MAAM,WAAiC,GAEtCd,YAAakL,EAAO0/B,EAAUC,EAAY4mB,EAAmB,GAE5D50C,MAAO3R,EAAO0/B,EAAUC,GAExBptC,KAAKg2D,4BAA6B,EAElCh2D,KAAKg0D,iBAAmBA,CAEzB,CAEA5gD,KAAM3P,GAML,OAJA2b,MAAMhM,KAAM3P,GAEZzD,KAAKg0D,iBAAmBvwD,EAAOuwD,iBAExBh0D,IAER,CAEA+d,SAEC,MAAM1a,EAAO+b,MAAMrB,SAMnB,OAJA1a,EAAK2wD,iBAAmBh0D,KAAKg0D,iBAE7B3wD,EAAK2yD,4BAA6B,EAE3B3yD,CAER,EAID,MAAMy1G,GAAqC,IAAIrlF,GACzCslF,GAAqC,IAAItlF,GAEzCulF,GAAsB,GAEtBC,GAAsB,IAAI5tF,GAC1B6tF,GAA0B,IAAIzlF,GAC9B0lF,GAAsB,IAAInlE,GAC1BolE,GAA0B,IAAIzpF,GAEpC,MAAM0pF,WAAsBrlE,GAE3BzxC,YAAa4qB,EAAU8S,EAAUh7B,GAEhCma,MAAO+N,EAAU8S,GAEjBjgC,KAAKi/B,iBAAkB,EAEvBj/B,KAAKk/B,eAAiB,IAAI,GAA0B,IAAI/vB,aAAsB,GAARlK,GAAc,IACpFjF,KAAKm/B,cAAgB,KAErBn/B,KAAKiF,MAAQA,EAEbjF,KAAK+sB,YAAc,KACnB/sB,KAAKgvC,eAAiB,KAEtB,IAAM,IAAI1uC,EAAI,EAAGA,EAAI2E,EAAO3E,IAE3BN,KAAKs5G,YAAah5G,EAAG44G,GAIvB,CAEAlsF,qBAEC,MAAMG,EAAWntB,KAAKmtB,SAChBloB,EAAQjF,KAAKiF,MAEO,OAArBjF,KAAK+sB,cAET/sB,KAAK+sB,YAAc,IAAI1B,IAIM,OAAzB8B,EAASJ,aAEbI,EAASH,qBAIVhtB,KAAK+sB,YAAYvB,YAEjB,IAAM,IAAIlrB,EAAI,EAAGA,EAAI2E,EAAO3E,IAE3BN,KAAKu5G,YAAaj5G,EAAGw4G,IAErBG,GAAM7lG,KAAM+Z,EAASJ,aAAc5L,aAAc23F,IAEjD94G,KAAK+sB,YAAYG,MAAO+rF,GAI1B,CAEAppE,wBAEC,MAAM1iB,EAAWntB,KAAKmtB,SAChBloB,EAAQjF,KAAKiF,MAEU,OAAxBjF,KAAKgvC,iBAEThvC,KAAKgvC,eAAiB,IAAIrf,IAIM,OAA5BxC,EAAS6hB,gBAEb7hB,EAAS0iB,wBAIV7vC,KAAKgvC,eAAexjB,YAEpB,IAAM,IAAIlrB,EAAI,EAAGA,EAAI2E,EAAO3E,IAE3BN,KAAKu5G,YAAaj5G,EAAGw4G,IAErBM,GAAUhmG,KAAM+Z,EAAS6hB,gBAAiB7tB,aAAc23F,IAExD94G,KAAKgvC,eAAe9hB,MAAOksF,GAI7B,CAEAhmG,KAAM3P,EAAQ88B,GAab,OAXAnhB,MAAMhM,KAAM3P,EAAQ88B,GAEpBvgC,KAAKk/B,eAAe9rB,KAAM3P,EAAOy7B,gBAEH,OAAzBz7B,EAAO07B,gBAAyBn/B,KAAKm/B,cAAgB17B,EAAO07B,cAAchsB,SAE/EnT,KAAKiF,MAAQxB,EAAOwB,MAEQ,OAAvBxB,EAAOspB,cAAuB/sB,KAAK+sB,YAActpB,EAAOspB,YAAY5Z,SAC1C,OAA1B1P,EAAOurC,iBAA0BhvC,KAAKgvC,eAAiBvrC,EAAOurC,eAAe77B,SAE3EnT,IAER,CAEAw5G,WAAYz7G,EAAOyd,GAElBA,EAAM9F,UAAW1V,KAAKm/B,cAAc1xB,MAAe,EAAR1P,EAE5C,CAEAw7G,YAAax7G,EAAO4c,GAEnBA,EAAOjF,UAAW1V,KAAKk/B,eAAezxB,MAAe,GAAR1P,EAE9C,CAEAigC,QAAS0W,EAAWC,GAEnB,MAAMprB,EAAcvpB,KAAKupB,YACnBkwF,EAAez5G,KAAKiF,MAK1B,GAHAk0G,GAAMhsF,SAAWntB,KAAKmtB,SACtBgsF,GAAMl5E,SAAWjgC,KAAKigC,cAEE9iC,IAAnBg8G,GAAMl5E,WAIkB,OAAxBjgC,KAAKgvC,gBAA0BhvC,KAAK6vC,wBAEzCupE,GAAUhmG,KAAMpT,KAAKgvC,gBACrBoqE,GAAUj4F,aAAcoI,IAE6B,IAAhDmrB,EAAU7jB,IAAInD,iBAAkB0rF,KAIrC,IAAM,IAAIM,EAAa,EAAGA,EAAaD,EAAcC,IAAgB,CAIpE15G,KAAKu5G,YAAaG,EAAYZ,IAE9BC,GAAqBxhG,iBAAkBgS,EAAauvF,IAIpDK,GAAM5vF,YAAcwvF,GAEpBI,GAAMn7E,QAAS0W,EAAWskE,IAI1B,IAAM,IAAI14G,EAAI,EAAGoN,EAAIsrG,GAAoBr4G,OAAQL,EAAIoN,EAAGpN,IAAO,CAE9D,MAAMyuB,EAAYiqF,GAAqB14G,GACvCyuB,EAAU2qF,WAAaA,EACvB3qF,EAAU5C,OAASnsB,KACnB20C,EAAWl1C,KAAMsvB,EAElB,CAEAiqF,GAAoBr4G,OAAS,CAE9B,CAED,CAEAg5G,WAAY57G,EAAOyd,GAEU,OAAvBxb,KAAKm/B,gBAETn/B,KAAKm/B,cAAgB,IAAI,GAA0B,IAAIhwB,aAA0C,EAA5BnP,KAAKk/B,eAAej6B,OAAa,IAIvGuW,EAAM5F,QAAS5V,KAAKm/B,cAAc1xB,MAAe,EAAR1P,EAE1C,CAEAu7G,YAAav7G,EAAO4c,GAEnBA,EAAO/E,QAAS5V,KAAKk/B,eAAezxB,MAAe,GAAR1P,EAE5C,CAEAk2C,qBAEA,CAEAxzB,UAECzgB,KAAKuN,cAAe,CAAER,KAAM,WAE7B,EAID,MAAM+rE,WAA0Bx1C,GAE/B/gC,YAAao9B,GAEZvgB,QAEApf,KAAKipG,qBAAsB,EAE3BjpG,KAAK+M,KAAO,oBAEZ/M,KAAKwb,MAAQ,IAAIuvB,GAAO,UAExB/qC,KAAKC,IAAM,KAEXD,KAAKgqC,UAAY,EACjBhqC,KAAK45G,QAAU,QACf55G,KAAK65G,SAAW,QAEhB75G,KAAKwqC,KAAM,EAEXxqC,KAAKkmC,UAAWvG,EAEjB,CAGAvsB,KAAM3P,GAcL,OAZA2b,MAAMhM,KAAM3P,GAEZzD,KAAKwb,MAAMpI,KAAM3P,EAAO+X,OAExBxb,KAAKC,IAAMwD,EAAOxD,IAElBD,KAAKgqC,UAAYvmC,EAAOumC,UACxBhqC,KAAK45G,QAAUn2G,EAAOm2G,QACtB55G,KAAK65G,SAAWp2G,EAAOo2G,SAEvB75G,KAAKwqC,IAAM/mC,EAAO+mC,IAEXxqC,IAER,EAID,MAAM85G,GAAyB,IAAI,GAC7BC,GAAuB,IAAI,GAC3BC,GAAiC,IAAIvmF,GACrCwmF,GAAuB,IAAIvpF,GAC3BwpF,GAA0B,IAAIvqF,GAEpC,MAAMwqF,WAAav/E,GAElBr4B,YAAa4qB,EAAW,IAAI,GAAkB8S,EAAW,IAAI64C,IAE5D15D,QAEApf,KAAKy/B,QAAS,EAEdz/B,KAAK+M,KAAO,OAEZ/M,KAAKmtB,SAAWA,EAChBntB,KAAKigC,SAAWA,EAEhBjgC,KAAKi0C,oBAEN,CAEA7gC,KAAM3P,EAAQ88B,GAOb,OALAnhB,MAAMhM,KAAM3P,EAAQ88B,GAEpBvgC,KAAKigC,SAAWx8B,EAAOw8B,SACvBjgC,KAAKmtB,SAAW1pB,EAAO0pB,SAEhBntB,IAER,CAEAo6G,uBAEC,MAAMjtF,EAAWntB,KAAKmtB,SAItB,GAAwB,OAAnBA,EAASpvB,MAAiB,CAE9B,MAAM2zC,EAAoBvkB,EAASxnB,WAAWynB,SACxCitF,EAAgB,CAAE,GAExB,IAAM,IAAI/5G,EAAI,EAAGoN,EAAIgkC,EAAkBzsC,MAAO3E,EAAIoN,EAAGpN,IAEpDw5G,GAASjkG,oBAAqB67B,EAAmBpxC,EAAI,GACrDy5G,GAAOlkG,oBAAqB67B,EAAmBpxC,GAE/C+5G,EAAe/5G,GAAM+5G,EAAe/5G,EAAI,GACxC+5G,EAAe/5G,IAAOw5G,GAAS7kG,WAAY8kG,IAI5C5sF,EAASlwB,aAAc,eAAgB,IAAI,GAAwBo9G,EAAe,GAEnF,MAEC/7G,QAAQkU,KAAM,iGAIf,OAAOxS,IAER,CAEAg+B,QAAS0W,EAAWC,GAEnB,MAAMxnB,EAAWntB,KAAKmtB,SAChB5D,EAAcvpB,KAAKupB,YACnB23E,EAAYxsD,EAAUupB,OAAOk8C,KAAKjZ,UAClCjyD,EAAY9hB,EAAS8hB,UAU3B,GANiC,OAA5B9hB,EAAS6hB,gBAA0B7hB,EAAS0iB,wBAEjDqqE,GAAU9mG,KAAM+Z,EAAS6hB,gBACzBkrE,GAAU/4F,aAAcoI,GACxB2wF,GAAUzvF,QAAUy2E,GAEiC,IAAhDxsD,EAAU7jB,IAAInD,iBAAkBwsF,IAAwB,OAI7DF,GAAiB5mG,KAAMmW,GAActQ,SACrCghG,GAAO7mG,KAAMshC,EAAU7jB,KAAM1P,aAAc64F,IAE3C,MAAMM,EAAiBpZ,IAAgBlhG,KAAKoa,MAAM9d,EAAI0D,KAAKoa,MAAM5d,EAAIwD,KAAKoa,MAAM0G,GAAM,GAChFy5F,EAAmBD,EAAiBA,EAEpCE,EAAS,IAAI,GACbC,EAAO,IAAI,GACXC,EAAe,IAAI,GACnBC,EAAW,IAAI,GACfr0F,EAAOtmB,KAAKyyG,eAAiB,EAAI,EAEjC10G,EAAQovB,EAASpvB,MAEjB2zC,EADavkB,EAASxnB,WACSynB,SAErC,GAAe,OAAVrvB,EAKJ,IAAM,IAAIuC,EAHItC,KAAKuQ,IAAK,EAAG0gC,EAAUC,OAGhBxhC,EAFT1P,KAAKL,IAAKI,EAAMkH,MAASgqC,EAAUC,MAAQD,EAAUhqC,OAElC,EAAG3E,EAAIoN,EAAGpN,GAAKgmB,EAAO,CAEpD,MAAM7d,EAAI1K,EAAMgY,KAAMzV,GAChBoR,EAAI3T,EAAMgY,KAAMzV,EAAI,GAO1B,GALAk6G,EAAO3kG,oBAAqB67B,EAAmBjpC,GAC/CgyG,EAAK5kG,oBAAqB67B,EAAmBhgC,GAE9BuoG,GAAO7oF,oBAAqBopF,EAAQC,EAAME,EAAUD,GAErDH,EAAmB,SAEjCI,EAASx5F,aAAcnhB,KAAKupB,aAE5B,MAAMmT,EAAWgY,EAAU7jB,IAAIF,OAAO1b,WAAY0lG,GAE7Cj+E,EAAWgY,EAAUpc,MAAQoE,EAAWgY,EAAUnc,KAEvDoc,EAAWl1C,KAAM,CAEhBi9B,SAAUA,EAGVhQ,MAAOguF,EAAavnG,QAAQgO,aAAcnhB,KAAKupB,aAC/CxrB,MAAOuC,EACP40C,KAAM,KACND,UAAW,KACX9oB,OAAQnsB,MAIV,MAOA,IAAM,IAAIM,EAHItC,KAAKuQ,IAAK,EAAG0gC,EAAUC,OAGhBxhC,EAFT1P,KAAKL,IAAK+zC,EAAkBzsC,MAASgqC,EAAUC,MAAQD,EAAUhqC,OAE9C,EAAG3E,EAAIoN,EAAGpN,GAAKgmB,EAAO,CAOpD,GALAk0F,EAAO3kG,oBAAqB67B,EAAmBpxC,GAC/Cm6G,EAAK5kG,oBAAqB67B,EAAmBpxC,EAAI,GAElC25G,GAAO7oF,oBAAqBopF,EAAQC,EAAME,EAAUD,GAErDH,EAAmB,SAEjCI,EAASx5F,aAAcnhB,KAAKupB,aAE5B,MAAMmT,EAAWgY,EAAU7jB,IAAIF,OAAO1b,WAAY0lG,GAE7Cj+E,EAAWgY,EAAUpc,MAAQoE,EAAWgY,EAAUnc,KAEvDoc,EAAWl1C,KAAM,CAEhBi9B,SAAUA,EAGVhQ,MAAOguF,EAAavnG,QAAQgO,aAAcnhB,KAAKupB,aAC/CxrB,MAAOuC,EACP40C,KAAM,KACND,UAAW,KACX9oB,OAAQnsB,MAIV,CAIF,CAEAi0C,qBAEC,MAEMpF,EAFW7uC,KAAKmtB,SAEW0hB,gBAC3BhpC,EAAOzD,OAAOyD,KAAMgpC,GAE1B,GAAKhpC,EAAKlF,OAAS,EAAI,CAEtB,MAAMqvC,EAAiBnB,EAAiBhpC,EAAM,IAE9C,QAAwB1I,IAAnB6yC,EAA+B,CAEnChwC,KAAKk0C,sBAAwB,GAC7Bl0C,KAAKm0C,sBAAwB,CAAC,EAE9B,IAAM,IAAI1lC,EAAI,EAAG2lC,EAAKpE,EAAervC,OAAQ8N,EAAI2lC,EAAI3lC,IAAO,CAE3D,MAAMjM,EAAOwtC,EAAgBvhC,GAAIjM,MAAQ6xC,OAAQ5lC,GAEjDzO,KAAKk0C,sBAAsBz0C,KAAM,GACjCO,KAAKm0C,sBAAuB3xC,GAASiM,CAEtC,CAED,CAED,CAED,EAID,MAAMmsG,GAAuB,IAAI,GAC3BC,GAAqB,IAAI,GAE/B,MAAMC,WAAqBX,GAE1B53G,YAAa4qB,EAAU8S,GAEtB7gB,MAAO+N,EAAU8S,GAEjBjgC,KAAKyyG,gBAAiB,EAEtBzyG,KAAK+M,KAAO,cAEb,CAEAqtG,uBAEC,MAAMjtF,EAAWntB,KAAKmtB,SAItB,GAAwB,OAAnBA,EAASpvB,MAAiB,CAE9B,MAAM2zC,EAAoBvkB,EAASxnB,WAAWynB,SACxCitF,EAAgB,GAEtB,IAAM,IAAI/5G,EAAI,EAAGoN,EAAIgkC,EAAkBzsC,MAAO3E,EAAIoN,EAAGpN,GAAK,EAEzDs6G,GAAO/kG,oBAAqB67B,EAAmBpxC,GAC/Cu6G,GAAKhlG,oBAAqB67B,EAAmBpxC,EAAI,GAEjD+5G,EAAe/5G,GAAc,IAANA,EAAY,EAAI+5G,EAAe/5G,EAAI,GAC1D+5G,EAAe/5G,EAAI,GAAM+5G,EAAe/5G,GAAMs6G,GAAO3lG,WAAY4lG,IAIlE1tF,EAASlwB,aAAc,eAAgB,IAAI,GAAwBo9G,EAAe,GAEnF,MAEC/7G,QAAQkU,KAAM,yGAIf,OAAOxS,IAER,EAID,MAAM+6G,WAAiBZ,GAEtB53G,YAAa4qB,EAAU8S,GAEtB7gB,MAAO+N,EAAU8S,GAEjBjgC,KAAK0yG,YAAa,EAElB1yG,KAAK+M,KAAO,UAEb,EAID,MAAMisE,WAAuB11C,GAE5B/gC,YAAao9B,GAEZvgB,QAEApf,KAAKqpG,kBAAmB,EAExBrpG,KAAK+M,KAAO,iBAEZ/M,KAAKwb,MAAQ,IAAIuvB,GAAO,UAExB/qC,KAAKC,IAAM,KAEXD,KAAK+nC,SAAW,KAEhB/nC,KAAKgsB,KAAO,EACZhsB,KAAK+pC,iBAAkB,EAEvB/pC,KAAKwqC,KAAM,EAEXxqC,KAAKkmC,UAAWvG,EAEjB,CAEAvsB,KAAM3P,GAeL,OAbA2b,MAAMhM,KAAM3P,GAEZzD,KAAKwb,MAAMpI,KAAM3P,EAAO+X,OAExBxb,KAAKC,IAAMwD,EAAOxD,IAElBD,KAAK+nC,SAAWtkC,EAAOskC,SAEvB/nC,KAAKgsB,KAAOvoB,EAAOuoB,KACnBhsB,KAAK+pC,gBAAkBtmC,EAAOsmC,gBAE9B/pC,KAAKwqC,IAAM/mC,EAAO+mC,IAEXxqC,IAER,EAID,MAAMg7G,GAA+B,IAAIvnF,GACnCwnF,GAAqB,IAAIvqF,GACzBwqF,GAAwB,IAAIvrF,GAC5BwrF,GAA4B,IAAI,GAEtC,MAAMC,WAAexgF,GAEpBr4B,YAAa4qB,EAAW,IAAI,GAAkB8S,EAAW,IAAI+4C,IAE5D55D,QAEApf,KAAK0/B,UAAW,EAEhB1/B,KAAK+M,KAAO,SAEZ/M,KAAKmtB,SAAWA,EAChBntB,KAAKigC,SAAWA,EAEhBjgC,KAAKi0C,oBAEN,CAEA7gC,KAAM3P,EAAQ88B,GAOb,OALAnhB,MAAMhM,KAAM3P,EAAQ88B,GAEpBvgC,KAAKigC,SAAWx8B,EAAOw8B,SACvBjgC,KAAKmtB,SAAW1pB,EAAO0pB,SAEhBntB,IAER,CAEAg+B,QAAS0W,EAAWC,GAEnB,MAAMxnB,EAAWntB,KAAKmtB,SAChB5D,EAAcvpB,KAAKupB,YACnB23E,EAAYxsD,EAAUupB,OAAOm9C,OAAOla,UACpCjyD,EAAY9hB,EAAS8hB,UAU3B,GANiC,OAA5B9hB,EAAS6hB,gBAA0B7hB,EAAS0iB,wBAEjDqrE,GAAQ9nG,KAAM+Z,EAAS6hB,gBACvBksE,GAAQ/5F,aAAcoI,GACtB2xF,GAAQzwF,QAAUy2E,GAEiC,IAA9CxsD,EAAU7jB,IAAInD,iBAAkBwtF,IAAsB,OAI3DF,GAAe5nG,KAAMmW,GAActQ,SACnCgiG,GAAK7nG,KAAMshC,EAAU7jB,KAAM1P,aAAc65F,IAEzC,MAAMV,EAAiBpZ,IAAgBlhG,KAAKoa,MAAM9d,EAAI0D,KAAKoa,MAAM5d,EAAIwD,KAAKoa,MAAM0G,GAAM,GAChFy5F,EAAmBD,EAAiBA,EAEpCv8G,EAAQovB,EAASpvB,MAEjB2zC,EADavkB,EAASxnB,WACSynB,SAErC,GAAe,OAAVrvB,EAKJ,IAAM,IAAIuC,EAHItC,KAAKuQ,IAAK,EAAG0gC,EAAUC,OAGhBzjB,EAFTztB,KAAKL,IAAKI,EAAMkH,MAASgqC,EAAUC,MAAQD,EAAUhqC,OAElC3E,EAAImrB,EAAInrB,IAAO,CAE7C,MAAMmI,EAAI1K,EAAMgY,KAAMzV,GAEtB66G,GAAYtlG,oBAAqB67B,EAAmBjpC,GAEpD4yG,GAAWF,GAAa1yG,EAAG8xG,EAAkBhxF,EAAamrB,EAAWC,EAAY30C,KAElF,MAOA,IAAM,IAAIM,EAHItC,KAAKuQ,IAAK,EAAG0gC,EAAUC,OAGhBxhC,EAFT1P,KAAKL,IAAK+zC,EAAkBzsC,MAASgqC,EAAUC,MAAQD,EAAUhqC,OAE/C3E,EAAIoN,EAAGpN,IAEpC66G,GAAYtlG,oBAAqB67B,EAAmBpxC,GAEpD+6G,GAAWF,GAAa76G,EAAGi6G,EAAkBhxF,EAAamrB,EAAWC,EAAY30C,KAMpF,CAEAi0C,qBAEC,MAEMpF,EAFW7uC,KAAKmtB,SAEW0hB,gBAC3BhpC,EAAOzD,OAAOyD,KAAMgpC,GAE1B,GAAKhpC,EAAKlF,OAAS,EAAI,CAEtB,MAAMqvC,EAAiBnB,EAAiBhpC,EAAM,IAE9C,QAAwB1I,IAAnB6yC,EAA+B,CAEnChwC,KAAKk0C,sBAAwB,GAC7Bl0C,KAAKm0C,sBAAwB,CAAC,EAE9B,IAAM,IAAI1lC,EAAI,EAAG2lC,EAAKpE,EAAervC,OAAQ8N,EAAI2lC,EAAI3lC,IAAO,CAE3D,MAAMjM,EAAOwtC,EAAgBvhC,GAAIjM,MAAQ6xC,OAAQ5lC,GAEjDzO,KAAKk0C,sBAAsBz0C,KAAM,GACjCO,KAAKm0C,sBAAuB3xC,GAASiM,CAEtC,CAED,CAED,CAED,EAID,SAAS4sG,GAAW3uF,EAAO3uB,EAAOw8G,EAAkBhxF,EAAamrB,EAAWC,EAAYxoB,GAEvF,MAAMmvF,EAAqBL,GAAK9pF,kBAAmBzE,GAEnD,GAAK4uF,EAAqBf,EAAmB,CAE5C,MAAMgB,EAAiB,IAAI,GAE3BN,GAAKhqF,oBAAqBvE,EAAO6uF,GACjCA,EAAep6F,aAAcoI,GAE7B,MAAMmT,EAAWgY,EAAU7jB,IAAIF,OAAO1b,WAAYsmG,GAElD,GAAK7+E,EAAWgY,EAAUpc,MAAQoE,EAAWgY,EAAUnc,IAAM,OAE7Doc,EAAWl1C,KAAM,CAEhBi9B,SAAUA,EACV8+E,cAAex9G,KAAKC,KAAMq9G,GAC1B5uF,MAAO6uF,EACPx9G,MAAOA,EACPm3C,KAAM,KACN/oB,OAAQA,GAIV,CAED,CAqhMA,MAAMwsD,WAA6Br1C,GAElC/gC,YAAao9B,GAEZvgB,QAEApf,KAAKs5E,wBAAyB,EAE9Bt5E,KAAKu3C,QAAU,CAAE,SAAY,IAE7Bv3C,KAAK+M,KAAO,uBAEZ/M,KAAKwb,MAAQ,IAAIuvB,GAAO,UACxB/qC,KAAKsmC,UAAY,EACjBtmC,KAAKumC,UAAY,EAEjBvmC,KAAKC,IAAM,KAEXD,KAAKgoC,SAAW,KAChBhoC,KAAKioC,kBAAoB,EAEzBjoC,KAAKkoC,MAAQ,KACbloC,KAAKmoC,eAAiB,EAEtBnoC,KAAK2mC,SAAW,IAAIoE,GAAO,GAC3B/qC,KAAK4mC,kBAAoB,EACzB5mC,KAAK8oC,YAAc,KAEnB9oC,KAAKooC,QAAU,KACfpoC,KAAKqoC,UAAY,EAEjBroC,KAAKsoC,UAAY,KACjBtoC,KAAKuoC,cA/xrCuB,EAgyrC5BvoC,KAAKwoC,YAAc,IAAI/1B,GAAS,EAAG,GAEnCzS,KAAKyoC,gBAAkB,KACvBzoC,KAAK0oC,kBAAoB,EACzB1oC,KAAK2oC,iBAAmB,EAExB3oC,KAAK4oC,aAAe,KAEpB5oC,KAAK6oC,aAAe,KAEpB7oC,KAAK+nC,SAAW,KAEhB/nC,KAAKkpC,OAAS,KACdlpC,KAAKopC,gBAAkB,EAEvBppC,KAAKmqC,WAAY,EACjBnqC,KAAKoqC,mBAAqB,EAC1BpqC,KAAKqqC,iBAAmB,QACxBrqC,KAAKsqC,kBAAoB,QAEzBtqC,KAAKuqC,aAAc,EAEnBvqC,KAAKwqC,KAAM,EAEXxqC,KAAKkmC,UAAWvG,EAEjB,CAEAvsB,KAAM3P,GAmDL,OAjDA2b,MAAMhM,KAAM3P,GAEZzD,KAAKu3C,QAAU,CAAE,SAAY,IAE7Bv3C,KAAKwb,MAAMpI,KAAM3P,EAAO+X,OACxBxb,KAAKsmC,UAAY7iC,EAAO6iC,UACxBtmC,KAAKumC,UAAY9iC,EAAO8iC,UAExBvmC,KAAKC,IAAMwD,EAAOxD,IAElBD,KAAKgoC,SAAWvkC,EAAOukC,SACvBhoC,KAAKioC,kBAAoBxkC,EAAOwkC,kBAEhCjoC,KAAKkoC,MAAQzkC,EAAOykC,MACpBloC,KAAKmoC,eAAiB1kC,EAAO0kC,eAE7BnoC,KAAK2mC,SAASvzB,KAAM3P,EAAOkjC,UAC3B3mC,KAAK8oC,YAAcrlC,EAAOqlC,YAC1B9oC,KAAK4mC,kBAAoBnjC,EAAOmjC,kBAEhC5mC,KAAKooC,QAAU3kC,EAAO2kC,QACtBpoC,KAAKqoC,UAAY5kC,EAAO4kC,UAExBroC,KAAKsoC,UAAY7kC,EAAO6kC,UACxBtoC,KAAKuoC,cAAgB9kC,EAAO8kC,cAC5BvoC,KAAKwoC,YAAYp1B,KAAM3P,EAAO+kC,aAE9BxoC,KAAKyoC,gBAAkBhlC,EAAOglC,gBAC9BzoC,KAAK0oC,kBAAoBjlC,EAAOilC,kBAChC1oC,KAAK2oC,iBAAmBllC,EAAOklC,iBAE/B3oC,KAAK4oC,aAAenlC,EAAOmlC,aAE3B5oC,KAAK6oC,aAAeplC,EAAOolC,aAE3B7oC,KAAK+nC,SAAWtkC,EAAOskC,SAEvB/nC,KAAKkpC,OAASzlC,EAAOylC,OACrBlpC,KAAKopC,gBAAkB3lC,EAAO2lC,gBAE9BppC,KAAKmqC,UAAY1mC,EAAO0mC,UACxBnqC,KAAKoqC,mBAAqB3mC,EAAO2mC,mBACjCpqC,KAAKqqC,iBAAmB5mC,EAAO4mC,iBAC/BrqC,KAAKsqC,kBAAoB7mC,EAAO6mC,kBAEhCtqC,KAAKuqC,YAAc9mC,EAAO8mC,YAE1BvqC,KAAKwqC,IAAM/mC,EAAO+mC,IAEXxqC,IAER,EAID,MAAM44E,WAA6BD,GAElCp2E,YAAao9B,GAEZvgB,QAEApf,KAAK2oG,wBAAyB,EAE9B3oG,KAAKu3C,QAAU,CAEd,SAAY,GACZ,SAAY,IAIbv3C,KAAK+M,KAAO,uBAEZ/M,KAAK4nC,mBAAqB,EAC1B5nC,KAAK6nC,cAAgB,KAErB7nC,KAAKmnC,aAAe,KACpBnnC,KAAKknC,mBAAqB,EAC1BlnC,KAAKonC,sBAAwB,KAC7BpnC,KAAKsnC,qBAAuB,IAAI70B,GAAS,EAAG,GAC5CzS,KAAKqnC,mBAAqB,KAE1BrnC,KAAK+qD,IAAM,IAEX3oD,OAAOuG,eAAgB3I,KAAM,eAAgB,CAC5C6I,IAAK,WAEJ,OAASyF,GAAO,KAAQtO,KAAK+qD,IAAM,IAAQ/qD,KAAK+qD,IAAM,GAAK,EAAG,EAE/D,EACAx4C,IAAK,SAAW82B,GAEfrpC,KAAK+qD,KAAQ,EAAI,GAAM1hB,IAAmB,EAAI,GAAMA,EAErD,IAGDrpC,KAAK0nC,eAAiB,KACtB1nC,KAAKwnC,eAAiB,IACtBxnC,KAAKynC,0BAA4B,CAAE,IAAK,KACxCznC,KAAK2nC,wBAA0B,KAE/B3nC,KAAKymC,WAAa,IAAIsE,GAAO,GAC7B/qC,KAAKkwD,cAAgB,KACrBlwD,KAAK0mC,eAAiB,EACtB1mC,KAAKowD,kBAAoB,KAEzBpwD,KAAKypC,gBAAkB,KAEvBzpC,KAAK0pC,UAAY,EACjB1pC,KAAK2pC,aAAe,KACpB3pC,KAAK4pC,oBAAsBC,IAC3B7pC,KAAK8pC,iBAAmB,IAAIiB,GAAO,EAAG,EAAG,GAEzC/qC,KAAK8mC,kBAAoB,EACzB9mC,KAAKgpC,qBAAuB,KAC5BhpC,KAAK+mC,cAAgB,IAAIgE,GAAO,EAAG,EAAG,GACtC/qC,KAAKipC,iBAAmB,KAExBjpC,KAAKy7G,YAAc,EACnBz7G,KAAK07G,WAAa,EAClB17G,KAAK27G,aAAe,EACpB37G,KAAK47G,OAAS,EACd57G,KAAK67G,cAAgB,EAErB77G,KAAKkmC,UAAWvG,EAEjB,CAEI1gB,iBAEH,OAAOjf,KAAKy7G,WAEb,CAEIx8F,eAAY7hB,GAEV4C,KAAKy7G,YAAc,GAAMr+G,EAAQ,GAErC4C,KAAK6d,UAIN7d,KAAKy7G,YAAcr+G,CAEpB,CAEI6pC,gBAEH,OAAOjnC,KAAK07G,UAEb,CAEIz0E,cAAW7pC,GAET4C,KAAK07G,WAAa,GAAMt+G,EAAQ,GAEpC4C,KAAK6d,UAIN7d,KAAK07G,WAAat+G,CAEnB,CAEImqC,kBAEH,OAAOvnC,KAAK27G,YAEb,CAEIp0E,gBAAanqC,GAEX4C,KAAK27G,aAAe,GAAMv+G,EAAQ,GAEtC4C,KAAK6d,UAIN7d,KAAK27G,aAAev+G,CAErB,CAEIopC,YAEH,OAAOxmC,KAAK47G,MAEb,CAEIp1E,UAAOppC,GAEL4C,KAAK47G,OAAS,GAAMx+G,EAAQ,GAEhC4C,KAAK6d,UAIN7d,KAAK47G,OAASx+G,CAEf,CAEIosC,mBAEH,OAAOxpC,KAAK67G,aAEb,CAEIryE,iBAAcpsC,GAEZ4C,KAAK67G,cAAgB,GAAMz+G,EAAQ,GAEvC4C,KAAK6d,UAIN7d,KAAK67G,cAAgBz+G,CAEtB,CAEAgW,KAAM3P,GAiDL,OA/CA2b,MAAMhM,KAAM3P,GAEZzD,KAAKu3C,QAAU,CAEd,SAAY,GACZ,SAAY,IAIbv3C,KAAKif,WAAaxb,EAAOwb,WACzBjf,KAAK4nC,mBAAqBnkC,EAAOmkC,mBACjC5nC,KAAK6nC,cAAgBpkC,EAAOokC,cAE5B7nC,KAAKinC,UAAYxjC,EAAOwjC,UACxBjnC,KAAKmnC,aAAe1jC,EAAO0jC,aAC3BnnC,KAAKknC,mBAAqBzjC,EAAOyjC,mBACjClnC,KAAKonC,sBAAwB3jC,EAAO2jC,sBACpCpnC,KAAKqnC,mBAAqB5jC,EAAO4jC,mBACjCrnC,KAAKsnC,qBAAqBl0B,KAAM3P,EAAO6jC,sBAEvCtnC,KAAK+qD,IAAMtnD,EAAOsnD,IAElB/qD,KAAKunC,YAAc9jC,EAAO8jC,YAC1BvnC,KAAK0nC,eAAiBjkC,EAAOikC,eAC7B1nC,KAAKwnC,eAAiB/jC,EAAO+jC,eAC7BxnC,KAAKynC,0BAA4B,IAAKhkC,EAAOgkC,2BAC7CznC,KAAK2nC,wBAA0BlkC,EAAOkkC,wBAEtC3nC,KAAKwmC,MAAQ/iC,EAAO+iC,MACpBxmC,KAAKymC,WAAWrzB,KAAM3P,EAAOgjC,YAC7BzmC,KAAKkwD,cAAgBzsD,EAAOysD,cAC5BlwD,KAAK0mC,eAAiBjjC,EAAOijC,eAC7B1mC,KAAKowD,kBAAoB3sD,EAAO2sD,kBAEhCpwD,KAAKwpC,aAAe/lC,EAAO+lC,aAC3BxpC,KAAKypC,gBAAkBhmC,EAAOgmC,gBAE9BzpC,KAAK0pC,UAAYjmC,EAAOimC,UACxB1pC,KAAK2pC,aAAelmC,EAAOkmC,aAC3B3pC,KAAK4pC,oBAAsBnmC,EAAOmmC,oBAClC5pC,KAAK8pC,iBAAiB12B,KAAM3P,EAAOqmC,kBAEnC9pC,KAAK8mC,kBAAoBrjC,EAAOqjC,kBAChC9mC,KAAKgpC,qBAAuBvlC,EAAOulC,qBACnChpC,KAAK+mC,cAAc3zB,KAAM3P,EAAOsjC,eAChC/mC,KAAKipC,iBAAmBxlC,EAAOwlC,iBAExBjpC,IAER,EAweD,SAAS87G,GAAYruG,EAAOhL,EAAM2qE,GAEjC,OAAK2uC,GAActuG,GAIX,IAAIA,EAAMlL,YAAakL,EAAM2zC,SAAU3+C,OAAatF,IAAPiwE,EAAmBA,EAAK3/D,EAAM9M,SAI5E8M,EAAMnL,MAAOG,EAAM2qE,EAE3B,CAGA,SAAS4uC,GAAcvuG,EAAOV,EAAMkvG,GAEnC,OAAOxuG,IACJwuG,GAAcxuG,EAAMlL,cAAgBwK,EAAcU,EAEd,iBAA3BV,EAAKm0C,kBAET,IAAIn0C,EAAMU,GAIXxM,MAAMoB,UAAUC,MAAMV,KAAM6L,EAEpC,CAEA,SAASsuG,GAAc5vF,GAEtB,OAAO+vF,YAAYC,OAAQhwF,MACtBA,aAAkBiwF,SAExB,CAGA,SAASC,GAAkBC,GAQ1B,MAAMn6G,EAAIm6G,EAAM37G,OACViE,EAAS,IAAI3D,MAAOkB,GAC1B,IAAM,IAAI7B,EAAI,EAAGA,IAAM6B,IAAM7B,EAAIsE,EAAQtE,GAAMA,EAI/C,OAFAsE,EAAO+/D,MAVP,SAAsBrkE,EAAG8uB,GAExB,OAAOktF,EAAOh8G,GAAMg8G,EAAOltF,EAE5B,IAQOxqB,CAER,CAGA,SAAS23G,GAAaj8E,EAAQmS,EAAQ7gC,GAErC,MAAM4qG,EAAUl8E,EAAO3/B,OACjBiE,EAAS,IAAI07B,EAAO/9B,YAAai6G,GAEvC,IAAM,IAAIl8G,EAAI,EAAG4jB,EAAY,EAAGA,IAAcs4F,IAAYl8G,EAAI,CAE7D,MAAMm8G,EAAY7qG,EAAOtR,GAAMmyC,EAE/B,IAAM,IAAIrjB,EAAI,EAAGA,IAAMqjB,IAAWrjB,EAEjCxqB,EAAQsf,KAAiBoc,EAAQm8E,EAAYrtF,EAI/C,CAEA,OAAOxqB,CAER,CAGA,SAAS83G,GAAaC,EAAUL,EAAOh8E,EAAQs8E,GAE9C,IAAIt8G,EAAI,EAAGyF,EAAM42G,EAAU,GAE3B,UAAgBx/G,IAAR4I,QAAkD5I,IAA7B4I,EAAK62G,IAEjC72G,EAAM42G,EAAUr8G,KAIjB,QAAanD,IAAR4I,EAAoB,OAEzB,IAAI3I,EAAQ2I,EAAK62G,GACjB,QAAez/G,IAAVC,EAEL,GAAK6D,MAAME,QAAS/D,GAEnB,GAECA,EAAQ2I,EAAK62G,QAEEz/G,IAAVC,IAEJk/G,EAAM78G,KAAMsG,EAAIm5C,MAChB5e,EAAO7gC,KAAKsvF,MAAOzuD,EAAQljC,IAI5B2I,EAAM42G,EAAUr8G,gBAECnD,IAAR4I,QAEJ,QAAuB5I,IAAlBC,EAAMwY,QAIjB,GAECxY,EAAQ2I,EAAK62G,QAEEz/G,IAAVC,IAEJk/G,EAAM78G,KAAMsG,EAAIm5C,MAChB9hD,EAAMwY,QAAS0qB,EAAQA,EAAO3/B,SAI/BoF,EAAM42G,EAAUr8G,gBAECnD,IAAR4I,QAMV,GAEC3I,EAAQ2I,EAAK62G,QAEEz/G,IAAVC,IAEJk/G,EAAM78G,KAAMsG,EAAIm5C,MAChB5e,EAAO7gC,KAAMrC,IAId2I,EAAM42G,EAAUr8G,gBAECnD,IAAR4I,EAIZ,CAoOA,MAAM82G,GAELt6G,YAAau6G,EAAoBC,EAAcC,EAAYC,GAE1Dj9G,KAAK88G,mBAAqBA,EAC1B98G,KAAKk9G,aAAe,EAEpBl9G,KAAKi9G,kBAAgC9/G,IAAjB8/G,EACnBA,EAAe,IAAIF,EAAax6G,YAAay6G,GAC9Ch9G,KAAK+8G,aAAeA,EACpB/8G,KAAKm9G,UAAYH,EAEjBh9G,KAAKo9G,SAAW,KAChBp9G,KAAKq9G,iBAAmB,CAAC,CAE1B,CAEAC,SAAU3uG,GAET,MAAM4uG,EAAKv9G,KAAK88G,mBAChB,IAAIz6E,EAAKriC,KAAKk9G,aACb/qF,EAAKorF,EAAIl7E,GACTnQ,EAAKqrF,EAAIl7E,EAAK,GAEfm7E,EAAmB,CAElBC,EAAM,CAEL,IAAItlF,EAEJulF,EAAa,CAMZC,EAAc,KAAShvG,EAAIwjB,GAAO,CAEjC,IAAM,IAAIyrF,EAAWv7E,EAAK,IAAO,CAEhC,QAAYllC,IAAPg1B,EAAmB,CAEvB,GAAKxjB,EAAIujB,EAAK,MAAMyrF,EAMpB,OAFAt7E,EAAKk7E,EAAG58G,OACRX,KAAKk9G,aAAe76E,EACbriC,KAAK69G,iBAAkBx7E,EAAK,EAEpC,CAEA,GAAKA,IAAOu7E,EAAW,MAKvB,GAHA1rF,EAAKC,EACLA,EAAKorF,IAAOl7E,GAEP1zB,EAAIwjB,EAGR,MAAMsrF,CAIR,CAGAtlF,EAAQolF,EAAG58G,OACX,MAAM+8G,CAEP,CAIA,GAAS/uG,GAAKujB,EAiDd,MAAMsrF,EAjDN,CAIC,MAAMM,EAAWP,EAAI,GAEhB5uG,EAAImvG,IAERz7E,EAAK,EACLnQ,EAAK4rF,GAMN,IAAM,IAAIF,EAAWv7E,EAAK,IAAO,CAEhC,QAAYllC,IAAP+0B,EAKJ,OADAlyB,KAAKk9G,aAAe,EACbl9G,KAAK69G,iBAAkB,GAI/B,GAAKx7E,IAAOu7E,EAAW,MAKvB,GAHAzrF,EAAKD,EACLA,EAAKqrF,IAAOl7E,EAAK,GAEZ1zB,GAAKujB,EAGT,MAAMurF,CAIR,CAGAtlF,EAAQkK,EACRA,EAAK,CAGN,CAMD,CAIA,KAAQA,EAAKlK,GAAQ,CAEpB,MAAM4lF,EAAQ17E,EAAKlK,IAAY,EAE1BxpB,EAAI4uG,EAAIQ,GAEZ5lF,EAAQ4lF,EAIR17E,EAAK07E,EAAM,CAIb,CAOA,GALA5rF,EAAKorF,EAAIl7E,GACTnQ,EAAKqrF,EAAIl7E,EAAK,QAIFllC,IAAP+0B,EAGJ,OADAlyB,KAAKk9G,aAAe,EACbl9G,KAAK69G,iBAAkB,GAI/B,QAAY1gH,IAAPg1B,EAIJ,OAFAkQ,EAAKk7E,EAAG58G,OACRX,KAAKk9G,aAAe76E,EACbriC,KAAK69G,iBAAkBx7E,EAAK,EAIrC,CAEAriC,KAAKk9G,aAAe76E,EAEpBriC,KAAKg+G,iBAAkB37E,EAAInQ,EAAIC,EAEhC,CAEA,OAAOnyB,KAAKi+G,aAAc57E,EAAInQ,EAAIvjB,EAAGwjB,EAEtC,CAEA+rF,eAEC,OAAOl+G,KAAKo9G,UAAYp9G,KAAKq9G,gBAE9B,CAEAQ,iBAAkB9/G,GAIjB,MAAM6G,EAAS5E,KAAKi9G,aACnB38E,EAAStgC,KAAK+8G,aACdtqE,EAASzyC,KAAKm9G,UACdxnG,EAAS5X,EAAQ00C,EAElB,IAAM,IAAInyC,EAAI,EAAGA,IAAMmyC,IAAWnyC,EAEjCsE,EAAQtE,GAAMggC,EAAQ3qB,EAASrV,GAIhC,OAAOsE,CAER,CAIAq5G,eAEC,MAAM,IAAIh4G,MAAO,0BAGlB,CAEA+3G,mBAIA,EAYD,MAAMG,WAAyBtB,GAE9Bt6G,YAAau6G,EAAoBC,EAAcC,EAAYC,GAE1D79F,MAAO09F,EAAoBC,EAAcC,EAAYC,GAErDj9G,KAAKo+G,aAAgB,EACrBp+G,KAAKq+G,aAAgB,EACrBr+G,KAAKs+G,aAAgB,EACrBt+G,KAAKu+G,aAAgB,EAErBv+G,KAAKq9G,iBAAmB,CAEvBmB,YA5quCyB,KA6quCzBC,UA7quCyB,KAiruC3B,CAEAT,iBAAkB37E,EAAInQ,EAAIC,GAEzB,MAAMorF,EAAKv9G,KAAK88G,mBAChB,IAAI4B,EAAQr8E,EAAK,EAChBs8E,EAAQt8E,EAAK,EAEbu8E,EAAQrB,EAAImB,GACZG,EAAQtB,EAAIoB,GAEb,QAAexhH,IAAVyhH,EAEJ,OAAS5+G,KAAKk+G,eAAeM,aAE5B,KA/ruCoB,KAksuCnBE,EAAQr8E,EACRu8E,EAAQ,EAAI1sF,EAAKC,EAEjB,MAED,KAtsuCqB,KAysuCpBusF,EAAQnB,EAAG58G,OAAS,EACpBi+G,EAAQ1sF,EAAKqrF,EAAImB,GAAUnB,EAAImB,EAAQ,GAEvC,MAED,QAGCA,EAAQr8E,EACRu8E,EAAQzsF,EAMX,QAAeh1B,IAAV0hH,EAEJ,OAAS7+G,KAAKk+G,eAAeO,WAE5B,KA7tuCoB,KAguuCnBE,EAAQt8E,EACRw8E,EAAQ,EAAI1sF,EAAKD,EAEjB,MAED,KApuuCqB,KAuuuCpBysF,EAAQ,EACRE,EAAQ1sF,EAAKorF,EAAI,GAAMA,EAAI,GAE3B,MAED,QAGCoB,EAAQt8E,EAAK,EACbw8E,EAAQ3sF,EAMX,MAAM4sF,EAAuB,IAAZ3sF,EAAKD,GACrBugB,EAASzyC,KAAKm9G,UAEfn9G,KAAKo+G,YAAcU,GAAW5sF,EAAK0sF,GACnC5+G,KAAKs+G,YAAcQ,GAAWD,EAAQ1sF,GACtCnyB,KAAKq+G,YAAcK,EAAQjsE,EAC3BzyC,KAAKu+G,YAAcI,EAAQlsE,CAE5B,CAEAwrE,aAAc57E,EAAInQ,EAAIvjB,EAAGwjB,GAExB,MAAMvtB,EAAS5E,KAAKi9G,aACnB38E,EAAStgC,KAAK+8G,aACdtqE,EAASzyC,KAAKm9G,UAEd4B,EAAK18E,EAAKoQ,EAASusE,EAAKD,EAAKtsE,EAC7BwsE,EAAKj/G,KAAKq+G,YAAca,EAAKl/G,KAAKu+G,YAClCY,EAAKn/G,KAAKo+G,YAAagB,EAAKp/G,KAAKs+G,YAEjC5lF,GAAM/pB,EAAIujB,IAASC,EAAKD,GACxBqrF,EAAK7kF,EAAIA,EACT2mF,EAAM9B,EAAK7kF,EAIN4mF,GAAOH,EAAKE,EAAM,EAAIF,EAAK5B,EAAK4B,EAAKzmF,EACrChH,GAAO,EAAIytF,GAAOE,IAAU,IAAM,EAAIF,GAAO5B,IAAS,GAAM4B,GAAOzmF,EAAI,EACvE/S,IAAS,EAAIy5F,GAAOC,GAAQ,IAAMD,GAAO7B,EAAK,GAAM7kF,EACpD6mF,EAAKH,EAAKC,EAAMD,EAAK7B,EAI3B,IAAM,IAAIj9G,EAAI,EAAGA,IAAMmyC,IAAWnyC,EAEjCsE,EAAQtE,GACNg/G,EAAKh/E,EAAQ2+E,EAAK3+G,GAClBoxB,EAAK4O,EAAQ0+E,EAAK1+G,GAClBqlB,EAAK2a,EAAQy+E,EAAKz+G,GAClBi/G,EAAKj/E,EAAQ4+E,EAAK5+G,GAIrB,OAAOsE,CAER,EAID,MAAM46G,WAA0B3C,GAE/Bt6G,YAAau6G,EAAoBC,EAAcC,EAAYC,GAE1D79F,MAAO09F,EAAoBC,EAAcC,EAAYC,EAEtD,CAEAgB,aAAc57E,EAAInQ,EAAIvjB,EAAGwjB,GAExB,MAAMvtB,EAAS5E,KAAKi9G,aACnB38E,EAAStgC,KAAK+8G,aACdtqE,EAASzyC,KAAKm9G,UAEdsC,EAAUp9E,EAAKoQ,EACfitE,EAAUD,EAAUhtE,EAEpBktE,GAAYhxG,EAAIujB,IAASC,EAAKD,GAC9B0tF,EAAU,EAAID,EAEf,IAAM,IAAIr/G,EAAI,EAAGA,IAAMmyC,IAAWnyC,EAEjCsE,EAAQtE,GACNggC,EAAQo/E,EAAUp/G,GAAMs/G,EACxBt/E,EAAQm/E,EAAUn/G,GAAMq/G,EAI3B,OAAO/6G,CAER,EAUD,MAAMi7G,WAA4BhD,GAEjCt6G,YAAau6G,EAAoBC,EAAcC,EAAYC,GAE1D79F,MAAO09F,EAAoBC,EAAcC,EAAYC,EAEtD,CAEAgB,aAAc57E,GAEb,OAAOriC,KAAK69G,iBAAkBx7E,EAAK,EAEpC,EAID,MAAMy9E,GAELv9G,YAAaC,EAAM85G,EAAOh8E,EAAQy/E,GAEjC,QAAc5iH,IAATqF,EAAqB,MAAM,IAAIyD,MAAO,gDAC3C,QAAe9I,IAAVm/G,GAAwC,IAAjBA,EAAM37G,OAAe,MAAM,IAAIsF,MAAO,oDAAsDzD,GAExHxC,KAAKwC,KAAOA,EAEZxC,KAAKs8G,MAAQN,GAAcM,EAAOt8G,KAAKggH,gBACvChgH,KAAKsgC,OAAS07E,GAAc17E,EAAQtgC,KAAKigH,iBAEzCjgH,KAAKkgH,iBAAkBH,GAAiB//G,KAAKmgH,qBAE9C,CAKAzjG,cAAe0jG,GAEd,MAAMC,EAAYD,EAAM79G,YAExB,IAAIq2G,EAGJ,GAAKyH,EAAUtiG,SAAW/d,KAAK+d,OAE9B66F,EAAOyH,EAAUtiG,OAAQqiG,OAEnB,CAGNxH,EAAO,CAEN,KAAQwH,EAAM59G,KACd,MAASw5G,GAAcoE,EAAM9D,MAAOr7G,OACpC,OAAU+6G,GAAcoE,EAAM9/E,OAAQr/B,QAIvC,MAAM8+G,EAAgBK,EAAMn+E,mBAEvB89E,IAAkBK,EAAMD,uBAE5BvH,EAAKmH,cAAgBA,EAIvB,CAIA,OAFAnH,EAAK7rG,KAAOqzG,EAAME,cAEX1H,CAER,CAEA2H,iCAAkC37G,GAEjC,OAAO,IAAIi7G,GAAqB7/G,KAAKs8G,MAAOt8G,KAAKsgC,OAAQtgC,KAAKwgH,eAAgB57G,EAE/E,CAEA67G,+BAAgC77G,GAE/B,OAAO,IAAI46G,GAAmBx/G,KAAKs8G,MAAOt8G,KAAKsgC,OAAQtgC,KAAKwgH,eAAgB57G,EAE7E,CAEA87G,+BAAgC97G,GAE/B,OAAO,IAAIu5G,GAAkBn+G,KAAKs8G,MAAOt8G,KAAKsgC,OAAQtgC,KAAKwgH,eAAgB57G,EAE5E,CAEAs7G,iBAAkBH,GAEjB,IAAIY,EAEJ,OAASZ,GAER,KAAKj0G,EAEJ60G,EAAgB3gH,KAAKugH,iCAErB,MAED,KAAKx0G,EAEJ40G,EAAgB3gH,KAAKygH,+BAErB,MAED,KAAKz0G,EAEJ20G,EAAgB3gH,KAAK0gH,+BAMvB,QAAuBvjH,IAAlBwjH,EAA8B,CAElC,MAAMzlG,EAAU,iCACflb,KAAKsgH,cAAgB,yBAA2BtgH,KAAKwC,KAEtD,QAAgCrF,IAA3B6C,KAAK4gH,kBAAkC,CAG3C,GAAKb,IAAkB//G,KAAKmgH,qBAM3B,MAAM,IAAIl6G,MAAOiV,GAJjBlb,KAAKkgH,iBAAkBlgH,KAAKmgH,qBAQ9B,CAGA,OADA7hH,QAAQkU,KAAM,uBAAwB0I,GAC/Blb,IAER,CAIA,OAFAA,KAAK4gH,kBAAoBD,EAElB3gH,IAER,CAEAiiC,mBAEC,OAASjiC,KAAK4gH,mBAEb,KAAK5gH,KAAKugH,iCAET,OAAOz0G,EAER,KAAK9L,KAAKygH,+BAET,OAAO10G,EAER,KAAK/L,KAAK0gH,+BAET,OAAO10G,EAIV,CAEAw0G,eAEC,OAAOxgH,KAAKsgC,OAAO3/B,OAASX,KAAKs8G,MAAM37G,MAExC,CAGAkuG,MAAOgS,GAEN,GAAoB,IAAfA,EAAqB,CAEzB,MAAMvE,EAAQt8G,KAAKs8G,MAEnB,IAAM,IAAIh8G,EAAI,EAAG6B,EAAIm6G,EAAM37G,OAAQL,IAAM6B,IAAM7B,EAE9Cg8G,EAAOh8G,IAAOugH,CAIhB,CAEA,OAAO7gH,IAER,CAGAoa,MAAO0mG,GAEN,GAAmB,IAAdA,EAAoB,CAExB,MAAMxE,EAAQt8G,KAAKs8G,MAEnB,IAAM,IAAIh8G,EAAI,EAAG6B,EAAIm6G,EAAM37G,OAAQL,IAAM6B,IAAM7B,EAE9Cg8G,EAAOh8G,IAAOwgH,CAIhB,CAEA,OAAO9gH,IAER,CAIA8sE,KAAMi0C,EAAWC,GAEhB,MAAM1E,EAAQt8G,KAAKs8G,MAClB2E,EAAQ3E,EAAM37G,OAEf,IAAI8B,EAAO,EACV2qE,EAAK6zC,EAAQ,EAEd,KAAQx+G,IAASw+G,GAAS3E,EAAO75G,GAASs+G,KAEtCt+G,EAIJ,MAAiB,IAAT2qE,GAAckvC,EAAOlvC,GAAO4zC,KAEhC5zC,EAMJ,KAFGA,EAEW,IAAT3qE,GAAc2qE,IAAO6zC,EAAQ,CAG5Bx+G,GAAQ2qE,IAEZA,EAAKpvE,KAAKuQ,IAAK6+D,EAAI,GACnB3qE,EAAO2qE,EAAK,GAIb,MAAM36B,EAASzyC,KAAKwgH,eACpBxgH,KAAKs8G,MAAQR,GAAYQ,EAAO75G,EAAM2qE,GACtCptE,KAAKsgC,OAASw7E,GAAY97G,KAAKsgC,OAAQ79B,EAAOgwC,EAAQ26B,EAAK36B,EAE5D,CAEA,OAAOzyC,IAER,CAGAkhH,WAEC,IAAIC,GAAQ,EAEZ,MAAMhE,EAAYn9G,KAAKwgH,eAClBrD,EAAYn/G,KAAKK,MAAO8+G,IAAgB,IAE5C7+G,QAAQ6+B,MAAO,oDAAqDn9B,MACpEmhH,GAAQ,GAIT,MAAM7E,EAAQt8G,KAAKs8G,MAClBh8E,EAAStgC,KAAKsgC,OAEd2gF,EAAQ3E,EAAM37G,OAEA,IAAVsgH,IAEJ3iH,QAAQ6+B,MAAO,uCAAwCn9B,MACvDmhH,GAAQ,GAIT,IAAIC,EAAW,KAEf,IAAM,IAAI9gH,EAAI,EAAGA,IAAM2gH,EAAO3gH,IAAO,CAEpC,MAAM+gH,EAAW/E,EAAOh8G,GAExB,GAAyB,iBAAb+gH,GAAyBpuF,MAAOouF,GAAa,CAExD/iH,QAAQ6+B,MAAO,mDAAoDn9B,KAAMM,EAAG+gH,GAC5EF,GAAQ,EACR,KAED,CAEA,GAAkB,OAAbC,GAAqBA,EAAWC,EAAW,CAE/C/iH,QAAQ6+B,MAAO,0CAA2Cn9B,KAAMM,EAAG+gH,EAAUD,GAC7ED,GAAQ,EACR,KAED,CAEAC,EAAWC,CAEZ,CAEA,QAAgBlkH,IAAXmjC,GAECy7E,GAAcz7E,GAElB,IAAM,IAAIhgC,EAAI,EAAG6B,EAAIm+B,EAAO3/B,OAAQL,IAAM6B,IAAM7B,EAAI,CAEnD,MAAMlD,EAAQkjC,EAAQhgC,GAEtB,GAAK2yB,MAAO71B,GAAU,CAErBkB,QAAQ6+B,MAAO,oDAAqDn9B,KAAMM,EAAGlD,GAC7E+jH,GAAQ,EACR,KAED,CAED,CAMF,OAAOA,CAER,CAIAG,WAGC,MAAMhF,EAAQR,GAAY97G,KAAKs8G,OAC9Bh8E,EAASw7E,GAAY97G,KAAKsgC,QAC1BmS,EAASzyC,KAAKwgH,eAEde,EAAsBvhH,KAAKiiC,qBAAuBj2B,EAElDw/D,EAAY8wC,EAAM37G,OAAS,EAE5B,IAAI6gH,EAAa,EAEjB,IAAM,IAAIlhH,EAAI,EAAGA,EAAIkrE,IAAclrE,EAAI,CAEtC,IAAImhH,GAAO,EAEX,MAAMviE,EAAOo9D,EAAOh8G,GAKpB,GAAK4+C,IAJYo9D,EAAOh8G,EAAI,KAIM,IAANA,GAAW4+C,IAASo9D,EAAO,IAEtD,GAAOiF,EAwBNE,GAAO,MAxBqB,CAI5B,MAAM9rG,EAASrV,EAAImyC,EAClBivE,EAAU/rG,EAAS88B,EACnBkvE,EAAUhsG,EAAS88B,EAEpB,IAAM,IAAIrjB,EAAI,EAAGA,IAAMqjB,IAAWrjB,EAAI,CAErC,MAAMhyB,EAAQkjC,EAAQ3qB,EAASyZ,GAE/B,GAAKhyB,IAAUkjC,EAAQohF,EAAUtyF,IAChChyB,IAAUkjC,EAAQqhF,EAAUvyF,GAAM,CAElCqyF,GAAO,EACP,KAED,CAED,CAED,CAUD,GAAKA,EAAO,CAEX,GAAKnhH,IAAMkhH,EAAa,CAEvBlF,EAAOkF,GAAelF,EAAOh8G,GAE7B,MAAMshH,EAAathH,EAAImyC,EACtBovE,EAAcL,EAAa/uE,EAE5B,IAAM,IAAIrjB,EAAI,EAAGA,IAAMqjB,IAAWrjB,EAEjCkR,EAAQuhF,EAAczyF,GAAMkR,EAAQshF,EAAaxyF,EAInD,GAEGoyF,CAEJ,CAED,CAIA,GAAKh2C,EAAY,EAAI,CAEpB8wC,EAAOkF,GAAelF,EAAO9wC,GAE7B,IAAM,IAAIo2C,EAAap2C,EAAY/4B,EAAQovE,EAAcL,EAAa/uE,EAAQrjB,EAAI,EAAGA,IAAMqjB,IAAWrjB,EAErGkR,EAAQuhF,EAAczyF,GAAMkR,EAAQshF,EAAaxyF,KAI/CoyF,CAEJ,CAcA,OAZKA,IAAelF,EAAM37G,QAEzBX,KAAKs8G,MAAQR,GAAYQ,EAAO,EAAGkF,GACnCxhH,KAAKsgC,OAASw7E,GAAYx7E,EAAQ,EAAGkhF,EAAa/uE,KAIlDzyC,KAAKs8G,MAAQA,EACbt8G,KAAKsgC,OAASA,GAIRtgC,IAER,CAEAmT,QAEC,MAAMmpG,EAAQR,GAAY97G,KAAKs8G,MAAO,GAChCh8E,EAASw7E,GAAY97G,KAAKsgC,OAAQ,GAGlC8/E,EAAQ,IAAI0B,EADS9hH,KAAKuC,aACMvC,KAAKwC,KAAM85G,EAAOh8E,GAKxD,OAFA8/E,EAAMQ,kBAAoB5gH,KAAK4gH,kBAExBR,CAER,EAIDN,GAAcz9G,UAAU29G,eAAiB7wG,aACzC2wG,GAAcz9G,UAAU49G,gBAAkB9wG,aAC1C2wG,GAAcz9G,UAAU89G,qBAAuBp0G,EAK/C,MAAMg2G,WAA6BjC,IAEnCiC,GAAqB1/G,UAAUi+G,cAAgB,OAC/CyB,GAAqB1/G,UAAU49G,gBAAkBh/G,MACjD8gH,GAAqB1/G,UAAU89G,qBAAuBr0G,EACtDi2G,GAAqB1/G,UAAUo+G,oCAAiCtjH,EAChE4kH,GAAqB1/G,UAAUq+G,oCAAiCvjH,EAKhE,MAAM6kH,WAA2BlC,IAEjCkC,GAAmB3/G,UAAUi+G,cAAgB,QAK7C,MAAM2B,WAA4BnC,IAElCmC,GAAoB5/G,UAAUi+G,cAAgB,SAM9C,MAAM4B,WAAoCrF,GAEzCt6G,YAAau6G,EAAoBC,EAAcC,EAAYC,GAE1D79F,MAAO09F,EAAoBC,EAAcC,EAAYC,EAEtD,CAEAgB,aAAc57E,EAAInQ,EAAIvjB,EAAGwjB,GAExB,MAAMvtB,EAAS5E,KAAKi9G,aACnB38E,EAAStgC,KAAK+8G,aACdtqE,EAASzyC,KAAKm9G,UAEd9nG,GAAU1G,EAAIujB,IAASC,EAAKD,GAE7B,IAAIvc,EAAS0sB,EAAKoQ,EAElB,IAAM,IAAIoK,EAAMlnC,EAAS88B,EAAQ98B,IAAWknC,EAAKlnC,GAAU,EAE1DgO,GAAWw+F,UAAWv9G,EAAQ,EAAG07B,EAAQ3qB,EAAS88B,EAAQnS,EAAQ3qB,EAAQN,GAI3E,OAAOzQ,CAER,EAOD,MAAMw9G,WAAgCtC,GAErCW,+BAAgC77G,GAE/B,OAAO,IAAIs9G,GAA6BliH,KAAKs8G,MAAOt8G,KAAKsgC,OAAQtgC,KAAKwgH,eAAgB57G,EAEvF,EAIDw9G,GAAwB//G,UAAUi+G,cAAgB,aAElD8B,GAAwB//G,UAAU89G,qBAAuBp0G,EACzDq2G,GAAwB//G,UAAUq+G,oCAAiCvjH,EAKnE,MAAMklH,WAA4BvC,IAElCuC,GAAoBhgH,UAAUi+G,cAAgB,SAC9C+B,GAAoBhgH,UAAU49G,gBAAkBh/G,MAChDohH,GAAoBhgH,UAAU89G,qBAAuBr0G,EACrDu2G,GAAoBhgH,UAAUo+G,oCAAiCtjH,EAC/DklH,GAAoBhgH,UAAUq+G,oCAAiCvjH,EAK/D,MAAMmlH,WAA4BxC,IAElCwC,GAAoBjgH,UAAUi+G,cAAgB,SAE9C,MAAMiC,GAELhgH,YAAaC,EAAMggH,GAAW,EAAKC,EAAQC,EAAYC,MAEtD3iH,KAAKwC,KAAOA,EACZxC,KAAKyiH,OAASA,EACdziH,KAAKwiH,SAAWA,EAChBxiH,KAAK0iH,UAAYA,EAEjB1iH,KAAK4d,KAAO7P,KAGP/N,KAAKwiH,SAAW,GAEpBxiH,KAAK4iH,eAIP,CAGAlmG,aAAck8F,GAEb,MAAM6J,EAAS,GACdI,EAAajK,EAAK6J,OAClBK,EAAY,GAAQlK,EAAKmK,KAAO,GAEjC,IAAM,IAAIziH,EAAI,EAAG6B,EAAI0gH,EAAWliH,OAAQL,IAAM6B,IAAM7B,EAEnDmiH,EAAOhjH,KAAMujH,GAAoBH,EAAYviH,IAAM8Z,MAAO0oG,IAI3D,MAAMG,EAAO,IAAIjjH,KAAM44G,EAAKp2G,KAAMo2G,EAAK4J,SAAUC,EAAQ7J,EAAK8J,WAG9D,OAFAO,EAAKrlG,KAAOg7F,EAAKh7F,KAEVqlG,CAER,CAEAvmG,cAAeumG,GAEd,MAAMR,EAAS,GACdS,EAAaD,EAAKR,OAEb7J,EAAO,CAEZ,KAAQqK,EAAKzgH,KACb,SAAYygH,EAAKT,SACjB,OAAUC,EACV,KAAQQ,EAAKrlG,KACb,UAAaqlG,EAAKP,WAInB,IAAM,IAAIpiH,EAAI,EAAG6B,EAAI+gH,EAAWviH,OAAQL,IAAM6B,IAAM7B,EAEnDmiH,EAAOhjH,KAAMqgH,GAAc/hG,OAAQmlG,EAAY5iH,KAIhD,OAAOs4G,CAER,CAEAl8F,qCAAsCla,EAAM2gH,EAAqBJ,EAAKK,GAErE,MAAMC,EAAkBF,EAAoBxiH,OACtC8hH,EAAS,GAEf,IAAM,IAAIniH,EAAI,EAAGA,EAAI+iH,EAAiB/iH,IAAO,CAE5C,IAAIg8G,EAAQ,GACRh8E,EAAS,GAEbg8E,EAAM78G,MACHa,EAAI+iH,EAAkB,GAAMA,EAC9B/iH,GACEA,EAAI,GAAM+iH,GAEb/iF,EAAO7gC,KAAM,EAAG,EAAG,GAEnB,MAAMmS,EAAQyqG,GAAkBC,GAChCA,EAAQC,GAAaD,EAAO,EAAG1qG,GAC/B0uB,EAASi8E,GAAaj8E,EAAQ,EAAG1uB,GAI1BwxG,GAAyB,IAAf9G,EAAO,KAEvBA,EAAM78G,KAAM4jH,GACZ/iF,EAAO7gC,KAAM6gC,EAAQ,KAItBmiF,EAAOhjH,KACN,IAAIwiH,GACH,0BAA4BkB,EAAqB7iH,GAAIkC,KAAO,IAC5D85G,EAAOh8E,GACNlmB,MAAO,EAAM2oG,GAEjB,CAEA,OAAO,IAAI/iH,KAAMwC,GAAQ,EAAGigH,EAE7B,CAEA/lG,kBAAmB4mG,EAAmB9gH,GAErC,IAAI+gH,EAAYD,EAEhB,IAAOriH,MAAME,QAASmiH,GAAsB,CAE3C,MAAMrhH,EAAIqhH,EACVC,EAAYthH,EAAEkrB,UAAYlrB,EAAEkrB,SAAS0O,YAAc55B,EAAE45B,UAEtD,CAEA,IAAM,IAAIv7B,EAAI,EAAGA,EAAIijH,EAAU5iH,OAAQL,IAEtC,GAAKijH,EAAWjjH,GAAIkC,OAASA,EAE5B,OAAO+gH,EAAWjjH,GAMpB,OAAO,IAER,CAEAoc,2CAA4CmnD,EAAck/C,EAAKK,GAE9D,MAAMI,EAA0B,CAAC,EAI3BC,EAAU,qBAIhB,IAAM,IAAInjH,EAAI,EAAGmrB,EAAKo4C,EAAaljE,OAAQL,EAAImrB,EAAInrB,IAAO,CAEzD,MAAM4jE,EAAcL,EAAcvjE,GAC5BojH,EAAQx/C,EAAY1hE,KAAKipE,MAAOg4C,GAEtC,GAAKC,GAASA,EAAM/iH,OAAS,EAAI,CAEhC,MAAM6B,EAAOkhH,EAAO,GAEpB,IAAIC,EAAwBH,EAAyBhhH,GAE9CmhH,IAENH,EAAyBhhH,GAASmhH,EAAwB,IAI3DA,EAAsBlkH,KAAMykE,EAE7B,CAED,CAEA,MAAM0/C,EAAQ,GAEd,IAAM,MAAMphH,KAAQghH,EAEnBI,EAAMnkH,KAAMO,KAAK6jH,8BAA+BrhH,EAAMghH,EAAyBhhH,GAAQugH,EAAKK,IAI7F,OAAOQ,CAER,CAGAlnG,sBAAuByjB,EAAW23E,GAEjC,IAAO33E,EAGN,OADA7hC,QAAQ6+B,MAAO,yDACR,KAIR,MAAM2mF,EAAmB,SAAWzD,EAAW0D,EAAWC,EAAeC,EAAcC,GAGtF,GAA8B,IAAzBF,EAAcrjH,OAAe,CAEjC,MAAM27G,EAAQ,GACRh8E,EAAS,GAEfo8E,GAAasH,EAAe1H,EAAOh8E,EAAQ2jF,GAGrB,IAAjB3H,EAAM37G,QAEVujH,EAAWzkH,KAAM,IAAI4gH,EAAW0D,EAAWzH,EAAOh8E,GAIpD,CAED,EAEMmiF,EAAS,GAET0B,EAAWhkF,EAAU39B,MAAQ,UAC7BugH,EAAM5iF,EAAU4iF,KAAO,GACvBL,EAAYviF,EAAUuiF,UAG5B,IAAIF,EAAWriF,EAAUx/B,SAAY,EAErC,MAAMyjH,EAAkBjkF,EAAUkkF,WAAa,GAE/C,IAAM,IAAIrrG,EAAI,EAAGA,EAAIorG,EAAgBzjH,OAAQqY,IAAO,CAEnD,MAAMgrG,EAAgBI,EAAiBprG,GAAInT,KAG3C,GAAOm+G,GAA0C,IAAzBA,EAAcrjH,OAGtC,GAAKqjH,EAAe,GAAIngD,aAAe,CAGtC,MAAMygD,EAAmB,CAAC,EAE1B,IAAI//B,EAEJ,IAAMA,EAAI,EAAGA,EAAIy/B,EAAcrjH,OAAQ4jF,IAEtC,GAAKy/B,EAAez/B,GAAI1gB,aAEvB,IAAM,IAAIp1D,EAAI,EAAGA,EAAIu1G,EAAez/B,GAAI1gB,aAAaljE,OAAQ8N,IAE5D61G,EAAkBN,EAAez/B,GAAI1gB,aAAcp1D,KAAU,EAWhE,IAAM,MAAM81G,KAAmBD,EAAmB,CAEjD,MAAMhI,EAAQ,GACRh8E,EAAS,GAEf,IAAM,IAAI7xB,EAAI,EAAGA,IAAMu1G,EAAez/B,GAAI1gB,aAAaljE,SAAW8N,EAAI,CAErE,MAAM+1G,EAAeR,EAAez/B,GAEpC+3B,EAAM78G,KAAM+kH,EAAatlE,MACzB5e,EAAO7gC,KAAQ+kH,EAAatgD,cAAgBqgD,EAAoB,EAAI,EAErE,CAEA9B,EAAOhjH,KAAM,IAAIwiH,GAAqB,yBAA2BsC,EAAkB,IAAKjI,EAAOh8E,GAEhG,CAEAkiF,EAAW8B,EAAiB3jH,OAASoiH,CAEtC,KAAO,CAIN,MAAM0B,EAAW,UAAY3M,EAAO9+F,GAAIxW,KAAO,IAE/CshH,EACCxB,GAAqBmC,EAAW,YAChCT,EAAe,MAAOvB,GAEvBqB,EACC1B,GAAyBqC,EAAW,cACpCT,EAAe,MAAOvB,GAEvBqB,EACCxB,GAAqBmC,EAAW,SAChCT,EAAe,MAAOvB,EAExB,CAED,CAEA,OAAuB,IAAlBA,EAAO9hH,OAEJ,KAIK,IAAIX,KAAMmkH,EAAU3B,EAAUC,EAAQC,EAIpD,CAEAE,gBAGC,IAAIJ,EAAW,EAEf,IAAM,IAAIliH,EAAI,EAAG6B,EAHFnC,KAAKyiH,OAGQ9hH,OAAQL,IAAM6B,IAAM7B,EAAI,CAEnD,MAAM8/G,EAAQpgH,KAAKyiH,OAAQniH,GAE3BkiH,EAAWxkH,KAAKuQ,IAAKi0G,EAAUpC,EAAM9D,MAAO8D,EAAM9D,MAAM37G,OAAS,GAElE,CAIA,OAFAX,KAAKwiH,SAAWA,EAETxiH,IAER,CAEA8sE,OAEC,IAAM,IAAIxsE,EAAI,EAAGA,EAAIN,KAAKyiH,OAAO9hH,OAAQL,IAExCN,KAAKyiH,OAAQniH,GAAIwsE,KAAM,EAAG9sE,KAAKwiH,UAIhC,OAAOxiH,IAER,CAEAkhH,WAEC,IAAIC,GAAQ,EAEZ,IAAM,IAAI7gH,EAAI,EAAGA,EAAIN,KAAKyiH,OAAO9hH,OAAQL,IAExC6gH,EAAQA,GAASnhH,KAAKyiH,OAAQniH,GAAI4gH,WAInC,OAAOC,CAER,CAEAG,WAEC,IAAM,IAAIhhH,EAAI,EAAGA,EAAIN,KAAKyiH,OAAO9hH,OAAQL,IAExCN,KAAKyiH,OAAQniH,GAAIghH,WAIlB,OAAOthH,IAER,CAEAmT,QAEC,MAAMsvG,EAAS,GAEf,IAAM,IAAIniH,EAAI,EAAGA,EAAIN,KAAKyiH,OAAO9hH,OAAQL,IAExCmiH,EAAOhjH,KAAMO,KAAKyiH,OAAQniH,GAAI6S,SAI/B,OAAO,IAAInT,KAAKuC,YAAavC,KAAKwC,KAAMxC,KAAKwiH,SAAUC,EAAQziH,KAAK0iH,UAErE,CAEA3kG,SAEC,OAAO/d,KAAKuC,YAAYwb,OAAQ/d,KAEjC,EA8CD,SAASgjH,GAAoBpK,GAE5B,QAAmBz7G,IAAdy7G,EAAK7rG,KAET,MAAM,IAAI9G,MAAO,4DAIlB,MAAMo6G,EAlDP,SAAuCqE,GAEtC,OAASA,EAASr2G,eAEjB,IAAK,SACL,IAAK,SACL,IAAK,QACL,IAAK,SACL,IAAK,UAEJ,OAAO4zG,GAER,IAAK,SACL,IAAK,UACL,IAAK,UACL,IAAK,UAEJ,OAAOK,GAER,IAAK,QAEJ,OAAON,GAER,IAAK,aAEJ,OAAOI,GAER,IAAK,OACL,IAAK,UAEJ,OAAOL,GAER,IAAK,SAEJ,OAAOM,GAIT,MAAM,IAAIp8G,MAAO,8CAAgDy+G,EAElE,CAUmBC,CAA8B/L,EAAK7rG,MAErD,QAAoB5P,IAAfy7G,EAAK0D,MAAsB,CAE/B,MAAMA,EAAQ,GAAIh8E,EAAS,GAE3Bo8E,GAAa9D,EAAK/yG,KAAMy2G,EAAOh8E,EAAQ,SAEvCs4E,EAAK0D,MAAQA,EACb1D,EAAKt4E,OAASA,CAEf,CAGA,YAAyBnjC,IAApBkjH,EAAUjgG,MAEPigG,EAAUjgG,MAAOw4F,GAKjB,IAAIyH,EAAWzH,EAAKp2G,KAAMo2G,EAAK0D,MAAO1D,EAAKt4E,OAAQs4E,EAAKmH,cAIjE,CAEA,MAAM6E,GAAQ,CAEb/oG,SAAS,EAETgpG,MAAO,CAAC,EAER7nH,IAAK,SAAW+I,EAAK++G,IAEE,IAAjB9kH,KAAK6b,UAIV7b,KAAK6kH,MAAO9+G,GAAQ++G,EAErB,EAEAj8G,IAAK,SAAW9C,GAEf,IAAsB,IAAjB/F,KAAK6b,QAIV,OAAO7b,KAAK6kH,MAAO9+G,EAEpB,EAEA7I,OAAQ,SAAW6I,UAEX/F,KAAK6kH,MAAO9+G,EAEpB,EAEAs3B,MAAO,WAENr9B,KAAK6kH,MAAQ,CAAC,CAEf,GAID,MAAME,GAELxiH,YAAayiH,EAAQC,EAAYC,GAEhC,MAAM1vE,EAAQx1C,KAEd,IAGImlH,EAHAC,GAAY,EACZC,EAAc,EACdC,EAAa,EAEjB,MAAMC,EAAW,GAKjBvlH,KAAKwlH,aAAUroH,EACf6C,KAAKglH,OAASA,EACdhlH,KAAKilH,WAAaA,EAClBjlH,KAAKklH,QAAUA,EAEfllH,KAAKylH,UAAY,SAAW9hH,GAE3B2hH,KAEmB,IAAdF,QAEmBjoH,IAAlBq4C,EAAMgwE,SAEVhwE,EAAMgwE,QAAS7hH,EAAK0hH,EAAaC,GAMnCF,GAAY,CAEb,EAEAplH,KAAK0lH,QAAU,SAAW/hH,GAEzB0hH,SAE0BloH,IAArBq4C,EAAMyvE,YAEVzvE,EAAMyvE,WAAYthH,EAAK0hH,EAAaC,GAIhCD,IAAgBC,IAEpBF,GAAY,OAEUjoH,IAAjBq4C,EAAMwvE,QAEVxvE,EAAMwvE,SAMT,EAEAhlH,KAAK2lH,UAAY,SAAWhiH,QAEJxG,IAAlBq4C,EAAM0vE,SAEV1vE,EAAM0vE,QAASvhH,EAIjB,EAEA3D,KAAK4lH,WAAa,SAAWjiH,GAE5B,OAAKwhH,EAEGA,EAAaxhH,GAIdA,CAER,EAEA3D,KAAK6lH,eAAiB,SAAWhlB,GAIhC,OAFAskB,EAActkB,EAEP7gG,IAER,EAEAA,KAAK8lH,WAAa,SAAWC,EAAOC,GAInC,OAFAT,EAAS9lH,KAAMsmH,EAAOC,GAEfhmH,IAER,EAEAA,KAAKimH,cAAgB,SAAWF,GAE/B,MAAMhoH,EAAQwnH,EAASp4G,QAAS44G,GAQhC,OANiB,IAAZhoH,GAEJwnH,EAASt9G,OAAQlK,EAAO,GAIlBiC,IAER,EAEAA,KAAKkmH,WAAa,SAAWpB,GAE5B,IAAM,IAAIxkH,EAAI,EAAGoN,EAAI63G,EAAS5kH,OAAQL,EAAIoN,EAAGpN,GAAK,EAAI,CAErD,MAAMylH,EAAQR,EAAUjlH,GAClB0lH,EAAST,EAAUjlH,EAAI,GAI7B,GAFKylH,EAAMI,SAASJ,EAAMv6C,UAAY,GAEjCu6C,EAAMrjH,KAAMoiH,GAEhB,OAAOkB,CAIT,CAEA,OAAO,IAER,CAED,EAID,MAAMI,GAAsC,IAAIrB,GAEhD,MAAMsB,GAEL9jH,YAAa+jH,GAEZtmH,KAAKsmH,aAAwBnpH,IAAZmpH,EAA0BA,EAAUF,GAErDpmH,KAAKumH,YAAc,YACnBvmH,KAAKwmH,iBAAkB,EACvBxmH,KAAKsrE,KAAO,GACZtrE,KAAKymH,aAAe,GACpBzmH,KAAK0mH,cAAgB,CAAC,CAEvB,CAEAC,OAAgD,CAEhDC,UAAWjjH,EAAKshH,GAEf,MAAMzvE,EAAQx1C,KAEd,OAAO,IAAI6mH,SAAS,SAAWC,EAASC,GAEvCvxE,EAAMmxE,KAAMhjH,EAAKmjH,EAAS7B,EAAY8B,EAEvC,GAED,CAEA3mG,QAAqB,CAErB4mG,eAAgBT,GAGf,OADAvmH,KAAKumH,YAAcA,EACZvmH,IAER,CAEAinH,mBAAoB7pH,GAGnB,OADA4C,KAAKwmH,gBAAkBppH,EAChB4C,IAER,CAEAknH,QAAS57C,GAGR,OADAtrE,KAAKsrE,KAAOA,EACLtrE,IAER,CAEAmnH,gBAAiBV,GAGhB,OADAzmH,KAAKymH,aAAeA,EACbzmH,IAER,CAEAonH,iBAAkBV,GAGjB,OADA1mH,KAAK0mH,cAAgBA,EACd1mH,IAER,EAIDqmH,GAAOgB,sBAAwB,YAE/B,MAAMC,GAAU,CAAC,EAEjB,MAAMC,WAAkBthH,MAEvB1D,YAAa2Y,EAASssG,GAErBpoG,MAAOlE,GACPlb,KAAKwnH,SAAWA,CAEjB,EAID,MAAMC,WAAmBpB,GAExB9jH,YAAa+jH,GAEZlnG,MAAOknG,EAER,CAEAK,KAAMhjH,EAAKqhH,EAAQC,EAAYC,QAEjB/nH,IAARwG,IAAoBA,EAAM,SAEZxG,IAAd6C,KAAKsrE,OAAqB3nE,EAAM3D,KAAKsrE,KAAO3nE,GAEjDA,EAAM3D,KAAKsmH,QAAQV,WAAYjiH,GAE/B,MAAMw8C,EAASykE,GAAM/7G,IAAKlF,GAE1B,QAAgBxG,IAAXgjD,EAYJ,OAVAngD,KAAKsmH,QAAQb,UAAW9hH,GAExB+jH,YAAY,KAEN1C,GAASA,EAAQ7kE,GAEtBngD,KAAKsmH,QAAQZ,QAAS/hH,EAAK,GAEzB,GAEIw8C,EAMR,QAAwBhjD,IAAnBmqH,GAAS3jH,GAUb,YARA2jH,GAAS3jH,GAAMlE,KAAM,CAEpBulH,OAAQA,EACRC,WAAYA,EACZC,QAASA,IASXoC,GAAS3jH,GAAQ,GAEjB2jH,GAAS3jH,GAAMlE,KAAM,CACpBulH,OAAQA,EACRC,WAAYA,EACZC,QAASA,IAIV,MAAMyC,EAAM,IAAIC,QAASjkH,EAAK,CAC7BkkH,QAAS,IAAIC,QAAS9nH,KAAK0mH,eAC3BqB,YAAa/nH,KAAKwmH,gBAAkB,UAAY,gBAK3CwB,EAAWhoH,KAAKgoH,SAChBC,EAAejoH,KAAKioH,aAG1BC,MAAOP,GACLQ,MAAMX,IAEN,GAAyB,MAApBA,EAAS/6C,QAAsC,IAApB+6C,EAAS/6C,OAAe,CAavD,GARyB,IAApB+6C,EAAS/6C,QAEbnuE,QAAQkU,KAAM,6CAMgB,oBAAnB41G,qBAAoDjrH,IAAlBqqH,EAASxrH,WAAkDmB,IAA5BqqH,EAASxrH,KAAKqsH,UAE1F,OAAOb,EAIR,MAAMc,EAAYhB,GAAS3jH,GACrB4kH,EAASf,EAASxrH,KAAKqsH,YAIvBG,EAAgBhB,EAASK,QAAQh/G,IAAK,mBAAsB2+G,EAASK,QAAQh/G,IAAK,eAClF4/G,EAAQD,EAAgB98E,SAAU88E,GAAkB,EACpDE,EAA6B,IAAVD,EACzB,IAAIE,EAAS,EAGb,MAAMC,EAAS,IAAIR,eAAgB,CAClCl5E,MAAO6zD,IAIN,SAAS8lB,IAERN,EAAOO,OAAOX,MAAM,EAAIrmH,OAAM1E,YAE7B,GAAK0E,EAEJihG,EAAWgmB,YAEL,CAENJ,GAAUvrH,EAAM4rH,WAEhB,MAAMx7G,EAAQ,IAAIy7G,cAAe,WAAY,CAAEP,mBAAkBC,SAAQF,UACzE,IAAM,IAAInoH,EAAI,EAAGmrB,EAAK68F,EAAU3nH,OAAQL,EAAImrB,EAAInrB,IAAO,CAEtD,MAAM2nB,EAAWqgG,EAAWhoH,GACvB2nB,EAASg9F,YAAah9F,EAASg9F,WAAYz3G,EAEjD,CAEAu1F,EAAWmmB,QAAS9rH,GACpByrH,GAED,IAIF,CA7BAA,EA+BD,IAID,OAAO,IAAIM,SAAUP,EAEtB,CAEC,MAAM,IAAIrB,GAAW,cAAcC,EAAS7jH,uBAAuB6jH,EAAS/6C,WAAW+6C,EAAS4B,aAAc5B,EAE/G,IAGAW,MAAMX,IAEN,OAASS,GAER,IAAK,cAEJ,OAAOT,EAAS6B,cAEjB,IAAK,OAEJ,OAAO7B,EAAS8B,OAEjB,IAAK,WAEJ,OAAO9B,EAAS+B,OACdpB,MAAMoB,IAES,IAAIC,WACLC,gBAAiBF,EAAMvB,KAIxC,IAAK,OAEJ,OAAOR,EAAS5O,OAEjB,QAEC,QAAkBz7G,IAAb6qH,EAEJ,OAAOR,EAAS+B,OAEV,CAGN,MACM/9E,EADK,0BACKA,KAAMw8E,GAChB0B,EAAQl+E,GAAQA,EAAM,GAAMA,EAAM,GAAIn9B,mBAAgBlR,EACtDwsH,EAAU,IAAIC,YAAaF,GACjC,OAAOlC,EAAS6B,cAAclB,MAAMh2E,GAAMw3E,EAAQE,OAAQ13E,IAE3D,EAEF,IAGAg2E,MAAM9kH,IAINuhH,GAAM5nH,IAAK2G,EAAKN,GAEhB,MAAMilH,EAAYhB,GAAS3jH,UACpB2jH,GAAS3jH,GAEhB,IAAM,IAAIrD,EAAI,EAAGmrB,EAAK68F,EAAU3nH,OAAQL,EAAImrB,EAAInrB,IAAO,CAEtD,MAAM2nB,EAAWqgG,EAAWhoH,GACvB2nB,EAAS+8F,QAAS/8F,EAAS+8F,OAAQ3hH,EAEzC,KAGAymH,OAAO/nH,IAIP,MAAMumH,EAAYhB,GAAS3jH,GAE3B,QAAmBxG,IAAdmrH,EAIJ,MADAtoH,KAAKsmH,QAAQX,UAAWhiH,GAClB5B,SAIAulH,GAAS3jH,GAEhB,IAAM,IAAIrD,EAAI,EAAGmrB,EAAK68F,EAAU3nH,OAAQL,EAAImrB,EAAInrB,IAAO,CAEtD,MAAM2nB,EAAWqgG,EAAWhoH,GACvB2nB,EAASi9F,SAAUj9F,EAASi9F,QAASnjH,EAE3C,CAEA/B,KAAKsmH,QAAQX,UAAWhiH,EAAK,IAG7BomH,SAAS,KAET/pH,KAAKsmH,QAAQZ,QAAS/hH,EAAK,IAI7B3D,KAAKsmH,QAAQb,UAAW9hH,EAEzB,CAEAqmH,gBAAiB5sH,GAGhB,OADA4C,KAAKioH,aAAe7qH,EACb4C,IAER,CAEAiqH,YAAa7sH,GAGZ,OADA4C,KAAKgoH,SAAW5qH,EACT4C,IAER,EA+LD,MAAMkqH,WAAoB7D,GAEzB9jH,YAAa+jH,GAEZlnG,MAAOknG,EAER,CAEAK,KAAMhjH,EAAKqhH,EAAQC,EAAYC,QAEX/nH,IAAd6C,KAAKsrE,OAAqB3nE,EAAM3D,KAAKsrE,KAAO3nE,GAEjDA,EAAM3D,KAAKsmH,QAAQV,WAAYjiH,GAE/B,MAAM6xC,EAAQx1C,KAERmgD,EAASykE,GAAM/7G,IAAKlF,GAE1B,QAAgBxG,IAAXgjD,EAYJ,OAVA3K,EAAM8wE,QAAQb,UAAW9hH,GAEzB+jH,YAAY,WAEN1C,GAASA,EAAQ7kE,GAEtB3K,EAAM8wE,QAAQZ,QAAS/hH,EAExB,GAAG,GAEIw8C,EAIR,MAAMxjC,EAAQ9B,GAAiB,OAE/B,SAASsvG,IAERC,IAEAxF,GAAM5nH,IAAK2G,EAAK3D,MAEXglH,GAASA,EAAQhlH,MAEtBw1C,EAAM8wE,QAAQZ,QAAS/hH,EAExB,CAEA,SAAS0mH,EAAc78G,GAEtB48G,IAEKlF,GAAUA,EAAS13G,GAExBgoC,EAAM8wE,QAAQX,UAAWhiH,GACzB6xC,EAAM8wE,QAAQZ,QAAS/hH,EAExB,CAEA,SAASymH,IAERztG,EAAMtP,oBAAqB,OAAQ88G,GAAa,GAChDxtG,EAAMtP,oBAAqB,QAASg9G,GAAc,EAEnD,CAeA,OAbA1tG,EAAM1gB,iBAAkB,OAAQkuH,GAAa,GAC7CxtG,EAAM1gB,iBAAkB,QAASouH,GAAc,GAEpB,UAAtB1mH,EAAIrB,MAAO,EAAG,SAEQnF,IAArB6C,KAAKumH,cAA4B5pG,EAAM4pG,YAAcvmH,KAAKumH,aAIhE/wE,EAAM8wE,QAAQb,UAAW9hH,GAEzBgZ,EAAMC,IAAMjZ,EAELgZ,CAER,EAsKD,MAAM2tG,WAAsBjE,GAE3B9jH,YAAa+jH,GAEZlnG,MAAOknG,EAER,CAEAK,KAAMhjH,EAAKqhH,EAAQC,EAAYC,GAE9B,MAAMniG,EAAU,IAAIvE,GAEdwnG,EAAS,IAAIkE,GAAalqH,KAAKsmH,SAiBrC,OAhBAN,EAAOgB,eAAgBhnH,KAAKumH,aAC5BP,EAAOkB,QAASlnH,KAAKsrE,MAErB06C,EAAOW,KAAMhjH,GAAK,SAAWgZ,GAE5BoG,EAAQpG,MAAQA,EAChBoG,EAAQjF,aAAc,OAEN3gB,IAAX6nH,GAEJA,EAAQjiG,EAIV,GAAGkiG,EAAYC,GAERniG,CAER,EAID,MAAMwnG,WAAc3vF,GAEnBr4B,YAAaiZ,EAAOykE,EAAY,GAE/B7gE,QAEApf,KAAKi9B,SAAU,EAEfj9B,KAAK+M,KAAO,QAEZ/M,KAAKwb,MAAQ,IAAIuvB,GAAOvvB,GACxBxb,KAAKigF,UAAYA,CAElB,CAEAx/D,UAIA,CAEArN,KAAM3P,EAAQ88B,GAOb,OALAnhB,MAAMhM,KAAM3P,EAAQ88B,GAEpBvgC,KAAKwb,MAAMpI,KAAM3P,EAAO+X,OACxBxb,KAAKigF,UAAYx8E,EAAOw8E,UAEjBjgF,IAER,CAEA+d,OAAQC,GAEP,MAAM3a,EAAO+b,MAAMrB,OAAQC,GAc3B,OAZA3a,EAAK8oB,OAAO3Q,MAAQxb,KAAKwb,MAAM6qB,SAC/BhjC,EAAK8oB,OAAO8zD,UAAYjgF,KAAKigF,eAEH9iF,IAArB6C,KAAKguD,cAA4B3qD,EAAK8oB,OAAO6hC,YAAchuD,KAAKguD,YAAY3nB,eAE1DlpC,IAAlB6C,KAAK08B,WAAyBr5B,EAAK8oB,OAAOuQ,SAAW18B,KAAK08B,eAC3Cv/B,IAAf6C,KAAK4U,QAAsBvR,EAAK8oB,OAAOvX,MAAQ5U,KAAK4U,YACrCzX,IAAf6C,KAAKmtD,QAAsB9pD,EAAK8oB,OAAOghC,MAAQntD,KAAKmtD,YAClChwD,IAAlB6C,KAAK4gF,WAAyBv9E,EAAK8oB,OAAOy0D,SAAW5gF,KAAK4gF,eAE1CzjF,IAAhB6C,KAAKyvD,SAAuBpsD,EAAK8oB,OAAOsjC,OAASzvD,KAAKyvD,OAAO1xC,UAE3D1a,CAER,EAiCD,MAAMmnH,GAAoC,IAAI/2F,GACxCg3F,GAAsC,IAAI,GAC1CC,GAA8B,IAAI,GAExC,MAAMC,GAELpoH,YAAa2mB,GAEZlpB,KAAKkpB,OAASA,EAEdlpB,KAAKwgF,KAAO,EACZxgF,KAAKygF,WAAa,EAClBzgF,KAAKyqB,OAAS,EACdzqB,KAAK0jF,YAAc,EAEnB1jF,KAAK0gF,QAAU,IAAIjuE,GAAS,IAAK,KAEjCzS,KAAKC,IAAM,KACXD,KAAK2jF,QAAU,KACf3jF,KAAK2a,OAAS,IAAI8Y,GAElBzzB,KAAKujF,YAAa,EAClBvjF,KAAK8d,aAAc,EAEnB9d,KAAKuiF,SAAW,IAAIplC,GACpBn9C,KAAK4qH,cAAgB,IAAIn4G,GAAS,EAAG,GAErCzS,KAAK6qH,eAAiB,EAEtB7qH,KAAK8qH,WAAa,CAEjB,IAAIjqG,GAAS,EAAG,EAAG,EAAG,GAIxB,CAEA2kE,mBAEC,OAAOxlF,KAAK6qH,cAEb,CAEAllC,aAEC,OAAO3lF,KAAKuiF,QAEb,CAEA1B,eAAgB1C,GAEf,MAAMmG,EAAetkF,KAAKkpB,OACpB6hG,EAAe/qH,KAAK2a,OAE1B8vG,GAAsB3/F,sBAAuBqzD,EAAM50D,aACnD+6D,EAAal3D,SAASha,KAAMq3G,IAE5BC,GAAc5/F,sBAAuBqzD,EAAM/5E,OAAOmlB,aAClD+6D,EAAavzD,OAAQ25F,IACrBpmC,EAAalmD,oBAEbosF,GAAoBjzG,iBAAkB+sE,EAAal7D,iBAAkBk7D,EAAan7D,oBAClFnpB,KAAKuiF,SAAS/kC,wBAAyBgtE,IAEvCO,EAAax4G,IACZ,GAAK,EAAK,EAAK,GACf,EAAK,GAAK,EAAK,GACf,EAAK,EAAK,GAAK,GACf,EAAK,EAAK,EAAK,GAGhBw4G,EAAan3G,SAAU42G,GAExB,CAEA9kC,YAAaslC,GAEZ,OAAOhrH,KAAK8qH,WAAYE,EAEzB,CAEA3lC,kBAEC,OAAOrlF,KAAK4qH,aAEb,CAEAnqG,UAEMzgB,KAAKC,KAETD,KAAKC,IAAIwgB,UAILzgB,KAAK2jF,SAET3jF,KAAK2jF,QAAQljE,SAIf,CAEArN,KAAM3P,GASL,OAPAzD,KAAKkpB,OAASzlB,EAAOylB,OAAO/V,QAE5BnT,KAAKwgF,KAAO/8E,EAAO+8E,KACnBxgF,KAAKyqB,OAAShnB,EAAOgnB,OAErBzqB,KAAK0gF,QAAQttE,KAAM3P,EAAOi9E,SAEnB1gF,IAER,CAEAmT,QAEC,OAAO,IAAInT,KAAKuC,aAAc6Q,KAAMpT,KAErC,CAEA+d,SAEC,MAAMoO,EAAS,CAAC,EAUhB,OARmB,IAAdnsB,KAAKwgF,OAAar0D,EAAOq0D,KAAOxgF,KAAKwgF,MACjB,IAApBxgF,KAAKygF,aAAmBt0D,EAAOs0D,WAAazgF,KAAKygF,YACjC,IAAhBzgF,KAAKyqB,SAAe0B,EAAO1B,OAASzqB,KAAKyqB,QACtB,MAAnBzqB,KAAK0gF,QAAQpkF,GAAgC,MAAnB0D,KAAK0gF,QAAQlkF,IAAY2vB,EAAOu0D,QAAU1gF,KAAK0gF,QAAQ9qE,WAEtFuW,EAAOjD,OAASlpB,KAAKkpB,OAAOnL,QAAQ,GAAQoO,cACrCA,EAAOjD,OAAOvO,OAEdwR,CAER,EAID,MAAM8+F,WAAwBN,GAE7BpoH,cAEC6c,MAAO,IAAIo5B,GAAmB,GAAI,EAAG,GAAK,MAE1Cx4C,KAAKkrH,mBAAoB,EAEzBlrH,KAAK64C,MAAQ,CAEd,CAEAgoC,eAAgB1C,GAEf,MAAMj1D,EAASlpB,KAAKkpB,OAEduvB,EAAgB,EAAV3qC,GAAcqwE,EAAMvpE,MAAQ5U,KAAK64C,MACvCH,EAAS14C,KAAK0gF,QAAQ/tE,MAAQ3S,KAAK0gF,QAAQ9tE,OAC3C2lB,EAAM4lD,EAAMzhD,UAAYxT,EAAOqP,IAEhCkgB,IAAQvvB,EAAOuvB,KAAOC,IAAWxvB,EAAOwvB,QAAUngB,IAAQrP,EAAOqP,MAErErP,EAAOuvB,IAAMA,EACbvvB,EAAOwvB,OAASA,EAChBxvB,EAAOqP,IAAMA,EACbrP,EAAO+vB,0BAIR75B,MAAMyhE,eAAgB1C,EAEvB,CAEA/qE,KAAM3P,GAML,OAJA2b,MAAMhM,KAAM3P,GAEZzD,KAAK64C,MAAQp1C,EAAOo1C,MAEb74C,IAER,EAID,MAAMmrH,WAAkBZ,GAEvBhoH,YAAaiZ,EAAOykE,EAAWvjD,EAAW,EAAG9nB,EAAQ5W,KAAKI,GAAK,EAAGwiF,EAAW,EAAGzzB,EAAQ,GAEvF/tC,MAAO5D,EAAOykE,GAEdjgF,KAAK2gF,aAAc,EAEnB3gF,KAAK+M,KAAO,YAEZ/M,KAAKotB,SAASha,KAAMwnB,GAASG,YAC7B/6B,KAAKmgB,eAELngB,KAAKoE,OAAS,IAAIw2B,GAElB56B,KAAK08B,SAAWA,EAChB18B,KAAK4U,MAAQA,EACb5U,KAAK4gF,SAAWA,EAChB5gF,KAAKmtD,MAAQA,EAEbntD,KAAKC,IAAM,KAEXD,KAAKyvD,OAAS,IAAIw7D,EAEnB,CAEIG,YAIH,OAAOprH,KAAKigF,UAAYjiF,KAAKI,EAE9B,CAEIgtH,UAAOA,GAGVprH,KAAKigF,UAAYmrC,EAAQptH,KAAKI,EAE/B,CAEAqiB,UAECzgB,KAAKyvD,OAAOhvC,SAEb,CAEArN,KAAM3P,EAAQ88B,GAab,OAXAnhB,MAAMhM,KAAM3P,EAAQ88B,GAEpBvgC,KAAK08B,SAAWj5B,EAAOi5B,SACvB18B,KAAK4U,MAAQnR,EAAOmR,MACpB5U,KAAK4gF,SAAWn9E,EAAOm9E,SACvB5gF,KAAKmtD,MAAQ1pD,EAAO0pD,MAEpBntD,KAAKoE,OAASX,EAAOW,OAAO+O,QAE5BnT,KAAKyvD,OAAShsD,EAAOgsD,OAAOt8C,QAErBnT,IAER,EAID,MAAM4tG,GAAkC,IAAIn6E,GACtC43F,GAAoC,IAAI,GACxCC,GAA4B,IAAI,GAEtC,MAAMC,WAAyBZ,GAE9BpoH,cAEC6c,MAAO,IAAIo5B,GAAmB,GAAI,EAAG,GAAK,MAE1Cx4C,KAAK4lF,oBAAqB,EAE1B5lF,KAAK4qH,cAAgB,IAAIn4G,GAAS,EAAG,GAErCzS,KAAK6qH,eAAiB,EAEtB7qH,KAAK8qH,WAAa,CAejB,IAAIjqG,GAAS,EAAG,EAAG,EAAG,GAEtB,IAAIA,GAAS,EAAG,EAAG,EAAG,GAEtB,IAAIA,GAAS,EAAG,EAAG,EAAG,GAEtB,IAAIA,GAAS,EAAG,EAAG,EAAG,GAEtB,IAAIA,GAAS,EAAG,EAAG,EAAG,GAEtB,IAAIA,GAAS,EAAG,EAAG,EAAG,IAGvB7gB,KAAKwrH,gBAAkB,CACtB,IAAI,GAAS,EAAG,EAAG,GAAK,IAAI,IAAW,EAAG,EAAG,GAAK,IAAI,GAAS,EAAG,EAAG,GACrE,IAAI,GAAS,EAAG,GAAK,GAAK,IAAI,GAAS,EAAG,EAAG,GAAK,IAAI,GAAS,GAAK,EAAG,IAGxExrH,KAAKyrH,SAAW,CACf,IAAI,GAAS,EAAG,EAAG,GAAK,IAAI,GAAS,EAAG,EAAG,GAAK,IAAI,GAAS,EAAG,EAAG,GACnE,IAAI,GAAS,EAAG,EAAG,GAAK,IAAI,GAAS,EAAG,EAAG,GAAK,IAAI,GAAS,EAAG,GAAK,GAGvE,CAEA5qC,eAAgB1C,EAAO6sC,EAAgB,GAEtC,MAAM9hG,EAASlpB,KAAKkpB,OACd6hG,EAAe/qH,KAAK2a,OAEpB4d,EAAM4lD,EAAMzhD,UAAYxT,EAAOqP,IAEhCA,IAAQrP,EAAOqP,MAEnBrP,EAAOqP,IAAMA,EACbrP,EAAO+vB,0BAIRoyE,GAAoBvgG,sBAAuBqzD,EAAM50D,aACjDL,EAAOkE,SAASha,KAAMi4G,IAEtBC,GAAYl4G,KAAM8V,EAAOkE,UACzBk+F,GAAYtuH,IAAKgD,KAAKwrH,gBAAiBR,IACvC9hG,EAAOwM,GAAGtiB,KAAMpT,KAAKyrH,SAAUT,IAC/B9hG,EAAO6H,OAAQu6F,IACfpiG,EAAOkV,oBAEP2sF,EAAarwG,iBAAmB2wG,GAAoB/uH,GAAK+uH,GAAoB7uH,GAAK6uH,GAAoBvqG,GAEtG8sF,GAAkBr2F,iBAAkB2R,EAAOE,iBAAkBF,EAAOC,oBACpEnpB,KAAKuiF,SAAS/kC,wBAAyBowD,GAExC,EAID,MAAM8d,WAAmBnB,GAExBhoH,YAAaiZ,EAAOykE,EAAWvjD,EAAW,EAAGywB,EAAQ,GAEpD/tC,MAAO5D,EAAOykE,GAEdjgF,KAAK+gF,cAAe,EAEpB/gF,KAAK+M,KAAO,aAEZ/M,KAAK08B,SAAWA,EAChB18B,KAAKmtD,MAAQA,EAEbntD,KAAKyvD,OAAS,IAAI87D,EAEnB,CAEIH,YAIH,OAAwB,EAAjBprH,KAAKigF,UAAgBjiF,KAAKI,EAElC,CAEIgtH,UAAOA,GAGVprH,KAAKigF,UAAYmrC,GAAU,EAAIptH,KAAKI,GAErC,CAEAqiB,UAECzgB,KAAKyvD,OAAOhvC,SAEb,CAEArN,KAAM3P,EAAQ88B,GASb,OAPAnhB,MAAMhM,KAAM3P,EAAQ88B,GAEpBvgC,KAAK08B,SAAWj5B,EAAOi5B,SACvB18B,KAAKmtD,MAAQ1pD,EAAO0pD,MAEpBntD,KAAKyvD,OAAShsD,EAAOgsD,OAAOt8C,QAErBnT,IAER,EAID,MAAM2rH,WAA+BhB,GAEpCpoH,cAEC6c,MAAO,IAAI+7C,IAAsB,EAAG,EAAG,GAAK,EAAG,GAAK,MAEpDn7D,KAAK4rH,0BAA2B,CAEjC,EAID,MAAMC,WAAyBtB,GAE9BhoH,YAAaiZ,EAAOykE,GAEnB7gE,MAAO5D,EAAOykE,GAEdjgF,KAAKsgF,oBAAqB,EAE1BtgF,KAAK+M,KAAO,mBAEZ/M,KAAKotB,SAASha,KAAMwnB,GAASG,YAC7B/6B,KAAKmgB,eAELngB,KAAKoE,OAAS,IAAIw2B,GAElB56B,KAAKyvD,OAAS,IAAIk8D,EAEnB,CAEAlrG,UAECzgB,KAAKyvD,OAAOhvC,SAEb,CAEArN,KAAM3P,GAOL,OALA2b,MAAMhM,KAAM3P,GAEZzD,KAAKoE,OAASX,EAAOW,OAAO+O,QAC5BnT,KAAKyvD,OAAShsD,EAAOgsD,OAAOt8C,QAErBnT,IAER,EAID,MAAM8rH,WAAqBvB,GAE1BhoH,YAAaiZ,EAAOykE,GAEnB7gE,MAAO5D,EAAOykE,GAEdjgF,KAAKkgF,gBAAiB,EAEtBlgF,KAAK+M,KAAO,cAEb,EAkqBD,MAAMg/G,GAELrvG,kBAAmBjP,GAElB,GAA4B,oBAAhBm8G,YAEX,OAAO,IAAIA,aAAcC,OAAQp8G,GAOlC,IAAIyD,EAAI,GAER,IAAM,IAAI5Q,EAAI,EAAGmrB,EAAKhe,EAAM9M,OAAQL,EAAImrB,EAAInrB,IAG3C4Q,GAAKmjC,OAAO23E,aAAcv+G,EAAOnN,IAIlC,IAIC,OAAO2rH,mBAAoBC,OAAQh7G,GAEpC,CAAE,MAAQhV,GAET,OAAOgV,CAER,CAED,CAEAwL,sBAAuB/Y,GAEtB,MAAM5F,EAAQ4F,EAAIwoH,YAAa,KAE/B,OAAiB,IAAZpuH,EAAuB,KAErB4F,EAAIrB,MAAO,EAAGvE,EAAQ,EAE9B,CAEA2e,kBAAmB/Y,EAAK2nE,GAGvB,MAAoB,iBAAR3nE,GAA4B,KAARA,EAAoB,IAG/C,gBAAgBjB,KAAM4oE,IAAU,MAAM5oE,KAAMiB,KAEhD2nE,EAAOA,EAAKrnE,QAAS,0BAA2B,OAK5C,mBAAmBvB,KAAMiB,IAGzB,gBAAgBjB,KAAMiB,IAGtB,aAAajB,KAAMiB,GANqBA,EAStC2nE,EAAO3nE,EAEf,EAkwCD,MAAMyoH,WAA0B/F,GAE/B9jH,YAAa+jH,GAEZlnG,MAAOknG,GAEPtmH,KAAKqsH,qBAAsB,EAEO,oBAAtBC,mBAEXhuH,QAAQkU,KAAM,+DAIO,oBAAV01G,OAEX5pH,QAAQkU,KAAM,mDAIfxS,KAAK4D,QAAU,CAAEgc,iBAAkB,OAEpC,CAEA2sG,WAAY3oH,GAIX,OAFA5D,KAAK4D,QAAUA,EAER5D,IAER,CAEA2mH,KAAMhjH,EAAKqhH,EAAQC,EAAYC,QAEjB/nH,IAARwG,IAAoBA,EAAM,SAEZxG,IAAd6C,KAAKsrE,OAAqB3nE,EAAM3D,KAAKsrE,KAAO3nE,GAEjDA,EAAM3D,KAAKsmH,QAAQV,WAAYjiH,GAE/B,MAAM6xC,EAAQx1C,KAERmgD,EAASykE,GAAM/7G,IAAKlF,GAE1B,QAAgBxG,IAAXgjD,EAYJ,OAVA3K,EAAM8wE,QAAQb,UAAW9hH,GAEzB+jH,YAAY,WAEN1C,GAASA,EAAQ7kE,GAEtB3K,EAAM8wE,QAAQZ,QAAS/hH,EAExB,GAAG,GAEIw8C,EAIR,MAAMqsE,EAAe,CAAC,EACtBA,EAAazE,YAAqC,cAArB/nH,KAAKumH,YAAgC,cAAgB,UAClFiG,EAAa3E,QAAU7nH,KAAK0mH,cAE5BwB,MAAOvkH,EAAK6oH,GAAerE,MAAM,SAAWsE,GAE3C,OAAOA,EAAInD,MAEZ,IAAInB,MAAM,SAAWmB,GAEpB,OAAOgD,kBAAmBhD,EAAMlnH,OAAOihB,OAAQmyB,EAAM5xC,QAAS,CAAE8oH,qBAAsB,SAEvF,IAAIvE,MAAM,SAAWwE,GAEpB/H,GAAM5nH,IAAK2G,EAAKgpH,GAEX3H,GAASA,EAAQ2H,GAEtBn3E,EAAM8wE,QAAQZ,QAAS/hH,EAExB,IAAImmH,OAAO,SAAW5tH,GAEhBgpH,GAAUA,EAAShpH,GAExBs5C,EAAM8wE,QAAQX,UAAWhiH,GACzB6xC,EAAM8wE,QAAQZ,QAAS/hH,EAExB,IAEA6xC,EAAM8wE,QAAQb,UAAW9hH,EAE1B,EAiOD,MAAMipH,GAELrqH,YAAasqH,GAAY,GAExB7sH,KAAK6sH,UAAYA,EAEjB7sH,KAAK+gH,UAAY,EACjB/gH,KAAK8sH,QAAU,EACf9sH,KAAK+sH,YAAc,EAEnB/sH,KAAKgtH,SAAU,CAEhB,CAEA99E,QAEClvC,KAAK+gH,UAAYkM,KAEjBjtH,KAAK8sH,QAAU9sH,KAAK+gH,UACpB/gH,KAAK+sH,YAAc,EACnB/sH,KAAKgtH,SAAU,CAEhB,CAEA3tE,OAECr/C,KAAKktH,iBACLltH,KAAKgtH,SAAU,EACfhtH,KAAK6sH,WAAY,CAElB,CAEAK,iBAGC,OADAltH,KAAKmtH,WACEntH,KAAK+sH,WAEb,CAEAI,WAEC,IAAIC,EAAO,EAEX,GAAKptH,KAAK6sH,YAAe7sH,KAAKgtH,QAG7B,OADAhtH,KAAKkvC,QACE,EAIR,GAAKlvC,KAAKgtH,QAAU,CAEnB,MAAMK,EAAUJ,KAEhBG,GAASC,EAAUrtH,KAAK8sH,SAAY,IACpC9sH,KAAK8sH,QAAUO,EAEfrtH,KAAK+sH,aAAeK,CAErB,CAEA,OAAOA,CAER,EAID,SAASH,KAER,OAAgC,oBAAhBK,YAA8BC,KAAOD,aAAcL,KAEpE,CA4/BA,MAAMO,GAAqB,gBACrBC,GAAc,IAAIC,OAAQ,IAAMF,GAAqB,IAAK,KAK1DG,GAAY,KAAOH,GAAqB,IACxCI,GAAiB,KAAOJ,GAAmBvpH,QAAS,MAAO,IAAO,IAiBlE4pH,GAAW,IAAIH,OAClB,IAdgC,kBAAkBjqH,OAAOQ,QAAS,KAAM0pH,IAG7C,WAAWlqH,OAAOQ,QAAS,OAAQ2pH,IAIjC,4BAA4BnqH,OAAOQ,QAAS,KAAM0pH,IAIhD,uBAAuBlqH,OAAOQ,QAAS,KAAM0pH,IAQ5E,KAGGG,GAAwB,CAAE,WAAY,YAAa,QAAS,OAoElE,MAAMC,GAELxrH,YAAayrH,EAAU1iD,EAAM2iD,GAE5BjuH,KAAKsrE,KAAOA,EACZtrE,KAAKiuH,WAAaA,GAAcF,GAAgBG,eAAgB5iD,GAEhEtrE,KAAKmuH,KAAOJ,GAAgBK,SAAUJ,EAAUhuH,KAAKiuH,WAAWI,UAEhEruH,KAAKguH,SAAWA,EAGhBhuH,KAAKsuH,SAAWtuH,KAAKuuH,kBACrBvuH,KAAKykE,SAAWzkE,KAAKwuH,iBAEtB,CAGA9xG,cAAe+xG,EAAMnjD,EAAM2iD,GAE1B,OAASQ,GAAQA,EAAKC,uBAMd,IAAIX,GAAgBY,UAAWF,EAAMnjD,EAAM2iD,GAJ3C,IAAIF,GAAiBU,EAAMnjD,EAAM2iD,EAQ1C,CASAvxG,wBAAyBla,GAExB,OAAOA,EAAKyB,QAAS,MAAO,KAAMA,QAASwpH,GAAa,GAEzD,CAEA/wG,sBAAuBqnG,GAEtB,MAAM6K,EAAUf,GAASriF,KAAMu4E,GAE/B,GAAiB,OAAZ6K,EAEJ,MAAM,IAAI3oH,MAAO,4CAA8C89G,GAIhE,MAAM8K,EAAU,CAEfR,SAAUO,EAAS,GACnBE,WAAYF,EAAS,GACrBG,YAAaH,EAAS,GACtB3K,aAAc2K,EAAS,GACvBI,cAAeJ,EAAS,IAGnBK,EAAUJ,EAAQR,UAAYQ,EAAQR,SAASlC,YAAa,KAElE,QAAiBhvH,IAAZ8xH,IAAuC,IAAdA,EAAkB,CAE/C,MAAMH,EAAaD,EAAQR,SAASa,UAAWD,EAAU,IAMF,IAAlDnB,GAAsB3gH,QAAS2hH,KAEnCD,EAAQR,SAAWQ,EAAQR,SAASa,UAAW,EAAGD,GAClDJ,EAAQC,WAAaA,EAIvB,CAEA,GAA8B,OAAzBD,EAAQ5K,cAAyD,IAAhC4K,EAAQ5K,aAAatjH,OAE1D,MAAM,IAAIsF,MAAO,+DAAiE89G,GAInF,OAAO8K,CAER,CAEAnyG,gBAAiB+xG,EAAMJ,GAEtB,QAAkBlxH,IAAbkxH,GAAuC,KAAbA,GAAgC,MAAbA,IAAmC,IAAfA,GAAoBA,IAAaI,EAAKjsH,MAAQ6rH,IAAaI,EAAK7wG,KAErI,OAAO6wG,EAKR,GAAKA,EAAKzuF,SAAW,CAEpB,MAAMy4E,EAAOgW,EAAKzuF,SAAS04E,cAAe2V,GAE1C,QAAclxH,IAATs7G,EAEJ,OAAOA,CAIT,CAGA,GAAKgW,EAAKphG,SAAW,CAEpB,MAAM8hG,EAAoB,SAAW9hG,GAEpC,IAAM,IAAI/sB,EAAI,EAAGA,EAAI+sB,EAAS1sB,OAAQL,IAAO,CAE5C,MAAM8uH,EAAY/hG,EAAU/sB,GAE5B,GAAK8uH,EAAU5sH,OAAS6rH,GAAYe,EAAUxxG,OAASywG,EAEtD,OAAOe,EAIR,MAAMxqH,EAASuqH,EAAmBC,EAAU/hG,UAE5C,GAAKzoB,EAAS,OAAOA,CAEtB,CAEA,OAAO,IAER,EAEMyqH,EAAcF,EAAmBV,EAAKphG,UAE5C,GAAKgiG,EAEJ,OAAOA,CAIT,CAEA,OAAO,IAER,CAGAC,wBAAyB,CACzBC,wBAAyB,CAIzBC,iBAAkBxvE,EAAQrqC,GAEzBqqC,EAAQrqC,GAAW3V,KAAKyvH,aAAczvH,KAAKikH,aAE5C,CAEAyL,gBAAiB1vE,EAAQrqC,GAExB,MAAMlS,EAASzD,KAAK2vH,iBAEpB,IAAM,IAAIrvH,EAAI,EAAG6B,EAAIsB,EAAO9C,OAAQL,IAAM6B,IAAM7B,EAE/C0/C,EAAQrqC,KAAclS,EAAQnD,EAIhC,CAEAsvH,uBAAwB5vE,EAAQrqC,GAE/BqqC,EAAQrqC,GAAW3V,KAAK2vH,iBAAkB3vH,KAAKgvH,cAEhD,CAEAa,kBAAmB7vE,EAAQrqC,GAE1B3V,KAAK2vH,iBAAiB/5G,QAASoqC,EAAQrqC,EAExC,CAIAm6G,iBAAkB9vE,EAAQrqC,GAEzB3V,KAAKyvH,aAAczvH,KAAKikH,cAAiBjkE,EAAQrqC,EAElD,CAEAo6G,gCAAiC/vE,EAAQrqC,GAExC3V,KAAKyvH,aAAczvH,KAAKikH,cAAiBjkE,EAAQrqC,GACjD3V,KAAKyvH,aAAa3xG,aAAc,CAEjC,CAEAkyG,2CAA4ChwE,EAAQrqC,GAEnD3V,KAAKyvH,aAAczvH,KAAKikH,cAAiBjkE,EAAQrqC,GACjD3V,KAAKyvH,aAAap0F,wBAAyB,CAE5C,CAIA40F,gBAAiBjwE,EAAQrqC,GAExB,MAAMu6G,EAAOlwH,KAAK2vH,iBAElB,IAAM,IAAIrvH,EAAI,EAAG6B,EAAI+tH,EAAKvvH,OAAQL,IAAM6B,IAAM7B,EAE7C4vH,EAAM5vH,GAAM0/C,EAAQrqC,IAItB,CAEAw6G,+BAAgCnwE,EAAQrqC,GAEvC,MAAMu6G,EAAOlwH,KAAK2vH,iBAElB,IAAM,IAAIrvH,EAAI,EAAG6B,EAAI+tH,EAAKvvH,OAAQL,IAAM6B,IAAM7B,EAE7C4vH,EAAM5vH,GAAM0/C,EAAQrqC,KAIrB3V,KAAKyvH,aAAa3xG,aAAc,CAEjC,CAEAsyG,0CAA2CpwE,EAAQrqC,GAElD,MAAMu6G,EAAOlwH,KAAK2vH,iBAElB,IAAM,IAAIrvH,EAAI,EAAG6B,EAAI+tH,EAAKvvH,OAAQL,IAAM6B,IAAM7B,EAE7C4vH,EAAM5vH,GAAM0/C,EAAQrqC,KAIrB3V,KAAKyvH,aAAap0F,wBAAyB,CAE5C,CAIAg1F,uBAAwBrwE,EAAQrqC,GAE/B3V,KAAK2vH,iBAAkB3vH,KAAKgvH,eAAkBhvE,EAAQrqC,EAEvD,CAEA26G,sCAAuCtwE,EAAQrqC,GAE9C3V,KAAK2vH,iBAAkB3vH,KAAKgvH,eAAkBhvE,EAAQrqC,GACtD3V,KAAKyvH,aAAa3xG,aAAc,CAEjC,CAEAyyG,iDAAkDvwE,EAAQrqC,GAEzD3V,KAAK2vH,iBAAkB3vH,KAAKgvH,eAAkBhvE,EAAQrqC,GACtD3V,KAAKyvH,aAAap0F,wBAAyB,CAE5C,CAIAm1F,oBAAqBxwE,EAAQrqC,GAE5B3V,KAAK2vH,iBAAiBj6G,UAAWsqC,EAAQrqC,EAE1C,CAEA86G,mCAAoCzwE,EAAQrqC,GAE3C3V,KAAK2vH,iBAAiBj6G,UAAWsqC,EAAQrqC,GACzC3V,KAAKyvH,aAAa3xG,aAAc,CAEjC,CAEA4yG,8CAA+C1wE,EAAQrqC,GAEtD3V,KAAK2vH,iBAAiBj6G,UAAWsqC,EAAQrqC,GACzC3V,KAAKyvH,aAAap0F,wBAAyB,CAE5C,CAEAkzF,kBAAmBoC,EAAah7G,GAE/B3V,KAAKuH,OACLvH,KAAKsuH,SAAUqC,EAAah7G,EAE7B,CAEA64G,kBAAmBoC,EAAaj7G,GAE/B3V,KAAKuH,OACLvH,KAAKykE,SAAUmsD,EAAaj7G,EAE7B,CAGApO,OAEC,IAAIkoH,EAAezvH,KAAKmuH,KACxB,MAAMF,EAAajuH,KAAKiuH,WAElBa,EAAab,EAAWa,WACxB7K,EAAegK,EAAWhK,aAChC,IAAI+K,EAAgBf,EAAWe,cAe/B,GAbOS,IAENA,EAAe1B,GAAgBK,SAAUpuH,KAAKguH,SAAUC,EAAWI,UAEnEruH,KAAKmuH,KAAOsB,GAKbzvH,KAAKsuH,SAAWtuH,KAAKsvH,sBACrBtvH,KAAKykE,SAAWzkE,KAAKuvH,uBAGdE,EAGN,YADAnxH,QAAQ6+B,MAAO,2DAA6Dn9B,KAAKsrE,KAAO,yBAKzF,GAAKwjD,EAAa,CAEjB,IAAIC,EAAcd,EAAWc,YAG7B,OAASD,GAER,IAAK,YAEJ,IAAOW,EAAaxvF,SAGnB,YADA3hC,QAAQ6+B,MAAO,oFAAqFn9B,MAKrG,IAAOyvH,EAAaxvF,SAASvB,UAG5B,YADApgC,QAAQ6+B,MAAO,8GAA+Gn9B,MAK/HyvH,EAAeA,EAAaxvF,SAASvB,UAErC,MAED,IAAK,QAEJ,IAAO+wF,EAAazvF,SAGnB,YADA1hC,QAAQ6+B,MAAO,iFAAkFn9B,MAQlGyvH,EAAeA,EAAazvF,SAAS83E,MAGrC,IAAM,IAAIx3G,EAAI,EAAGA,EAAImvH,EAAa9uH,OAAQL,IAEzC,GAAKmvH,EAAcnvH,GAAIkC,OAASusH,EAAc,CAE7CA,EAAczuH,EACd,KAED,CAID,MAED,IAAK,MAEJ,GAAK,QAASmvH,EAAe,CAE5BA,EAAeA,EAAaxvH,IAC5B,KAED,CAEA,IAAOwvH,EAAaxvF,SAGnB,YADA3hC,QAAQ6+B,MAAO,oFAAqFn9B,MAKrG,IAAOyvH,EAAaxvF,SAAShgC,IAG5B,YADA3B,QAAQ6+B,MAAO,4FAA6Fn9B,MAK7GyvH,EAAeA,EAAaxvF,SAAShgC,IACrC,MAED,QAEC,QAAoC9C,IAA/BsyH,EAAcX,GAGlB,YADAxwH,QAAQ6+B,MAAO,uEAAwEn9B,MAKxFyvH,EAAeA,EAAcX,GAK/B,QAAqB3xH,IAAhB4xH,EAA4B,CAEhC,QAAqC5xH,IAAhCsyH,EAAcV,GAGlB,YADAzwH,QAAQ6+B,MAAO,wFAAyFn9B,KAAMyvH,GAK/GA,EAAeA,EAAcV,EAE9B,CAED,CAGA,MAAM8B,EAAepB,EAAcxL,GAEnC,QAAsB9mH,IAAjB0zH,EAA6B,CAEjC,MAAMxC,EAAWJ,EAAWI,SAI5B,YAFA/vH,QAAQ6+B,MAAO,+DAAiEkxF,EAC/E,IAAMpK,EAAe,wBAA0BwL,EAGjD,CAGA,IAAIqB,EAAa9wH,KAAK+wH,WAAWC,KAEjChxH,KAAKyvH,aAAeA,OAEctyH,IAA7BsyH,EAAa3xG,YAEjBgzG,EAAa9wH,KAAK+wH,WAAWE,iBAEsB9zH,IAAxCsyH,EAAap0F,yBAExBy1F,EAAa9wH,KAAK+wH,WAAWG,wBAK9B,IAAIC,EAAcnxH,KAAKoxH,YAAYC,OAEnC,QAAuBl0H,IAAlB6xH,EAA8B,CAIlC,GAAsB,0BAAjB/K,EAA2C,CAK/C,IAAOwL,EAAatiG,SAGnB,YADA7uB,QAAQ6+B,MAAO,sGAAuGn9B,MAKvH,IAAOyvH,EAAatiG,SAAS0hB,gBAG5B,YADAvwC,QAAQ6+B,MAAO,sHAAuHn9B,WAK1E7C,IAAxDsyH,EAAat7E,sBAAuB66E,KAExCA,EAAgBS,EAAat7E,sBAAuB66E,GAItD,CAEAmC,EAAcnxH,KAAKoxH,YAAYE,aAE/BtxH,KAAK2vH,iBAAmBkB,EACxB7wH,KAAKgvH,cAAgBA,CAEtB,WAAuC7xH,IAA3B0zH,EAAan7G,gBAAoDvY,IAAzB0zH,EAAaj7G,SAIhEu7G,EAAcnxH,KAAKoxH,YAAYG,eAE/BvxH,KAAK2vH,iBAAmBkB,GAEb5vH,MAAME,QAAS0vH,IAE1BM,EAAcnxH,KAAKoxH,YAAYI,YAE/BxxH,KAAK2vH,iBAAmBkB,GAIxB7wH,KAAKikH,aAAeA,EAKrBjkH,KAAKsuH,SAAWtuH,KAAKyxH,oBAAqBN,GAC1CnxH,KAAKykE,SAAWzkE,KAAK0xH,iCAAkCP,GAAeL,EAEvE,CAEAa,SAEC3xH,KAAKmuH,KAAO,KAIZnuH,KAAKsuH,SAAWtuH,KAAKuuH,kBACrBvuH,KAAKykE,SAAWzkE,KAAKwuH,iBAEtB,EAIDT,GAAgBY,UA/mBhB,MAECpsH,YAAaqvH,EAAatmD,EAAMumD,GAE/B,MAAM5D,EAAa4D,GAAsB9D,GAAgBG,eAAgB5iD,GAEzEtrE,KAAK8xH,aAAeF,EACpB5xH,KAAK+xH,UAAYH,EAAYI,WAAY1mD,EAAM2iD,EAEhD,CAEAK,SAAU7gH,EAAOkI,GAEhB3V,KAAKuH,OAEL,MAAM0qH,EAAkBjyH,KAAK8xH,aAAaI,gBACzCC,EAAUnyH,KAAK+xH,UAAWE,QAGV90H,IAAZg1H,GAAwBA,EAAQ7D,SAAU7gH,EAAOkI,EAEvD,CAEA8uD,SAAUh3D,EAAOkI,GAEhB,MAAMy8G,EAAWpyH,KAAK+xH,UAEtB,IAAM,IAAIzxH,EAAIN,KAAK8xH,aAAaI,gBAAiB/vH,EAAIiwH,EAASzxH,OAAQL,IAAM6B,IAAM7B,EAEjF8xH,EAAU9xH,GAAImkE,SAAUh3D,EAAOkI,EAIjC,CAEApO,OAEC,MAAM6qH,EAAWpyH,KAAK+xH,UAEtB,IAAM,IAAIzxH,EAAIN,KAAK8xH,aAAaI,gBAAiB/vH,EAAIiwH,EAASzxH,OAAQL,IAAM6B,IAAM7B,EAEjF8xH,EAAU9xH,GAAIiH,MAIhB,CAEAoqH,SAEC,MAAMS,EAAWpyH,KAAK+xH,UAEtB,IAAM,IAAIzxH,EAAIN,KAAK8xH,aAAaI,gBAAiB/vH,EAAIiwH,EAASzxH,OAAQL,IAAM6B,IAAM7B,EAEjF8xH,EAAU9xH,GAAIqxH,QAIhB,GAwjBD5D,GAAgB1rH,UAAU+uH,YAAc,CACvCC,OAAQ,EACRG,YAAa,EACbF,aAAc,EACdC,eAAgB,GAGjBxD,GAAgB1rH,UAAU0uH,WAAa,CACtCC,KAAM,EACNC,YAAa,EACbC,uBAAwB,GAGzBnD,GAAgB1rH,UAAUovH,oBAAsB,CAE/C1D,GAAgB1rH,UAAUmtH,iBAC1BzB,GAAgB1rH,UAAUqtH,gBAC1B3B,GAAgB1rH,UAAUutH,uBAC1B7B,GAAgB1rH,UAAUwtH,mBAI3B9B,GAAgB1rH,UAAUqvH,iCAAmC,CAE5D,CAEC3D,GAAgB1rH,UAAUytH,iBAC1B/B,GAAgB1rH,UAAU0tH,gCAC1BhC,GAAgB1rH,UAAU2tH,4CAExB,CAIFjC,GAAgB1rH,UAAU4tH,gBAC1BlC,GAAgB1rH,UAAU8tH,+BAC1BpC,GAAgB1rH,UAAU+tH,2CAExB,CAGFrC,GAAgB1rH,UAAUguH,uBAC1BtC,GAAgB1rH,UAAUiuH,sCAC1BvC,GAAgB1rH,UAAUkuH,kDAExB,CAGFxC,GAAgB1rH,UAAUmuH,oBAC1BzC,GAAgB1rH,UAAUouH,mCAC1B1C,GAAgB1rH,UAAUquH,gDA4jCa,IAAIvhH,aAAc,GAw8B3D,MAAMkjH,GAEL9vH,YAAaouB,EAAQC,EAAW0H,EAAO,EAAGC,EAAMsR,KAE/C7pC,KAAK6wB,IAAM,IAAIH,GAAKC,EAAQC,GAG5B5wB,KAAKs4B,KAAOA,EACZt4B,KAAKu4B,IAAMA,EACXv4B,KAAKkpB,OAAS,KACdlpB,KAAK65B,OAAS,IAAIP,GAElBt5B,KAAKi+D,OAAS,CACbjqB,KAAM,CAAC,EACPmmE,KAAM,CAAEjZ,UAAW,GACnBoxB,IAAK,CAAC,EACNlX,OAAQ,CAAEla,UAAW,GACrBqxB,OAAQ,CAAC,EAGX,CAEAhgH,IAAKoe,EAAQC,GAIZ5wB,KAAK6wB,IAAIte,IAAKoe,EAAQC,EAEvB,CAEA4hG,cAAeC,EAAQvpG,GAEjBA,EAAOyvB,qBAEX34C,KAAK6wB,IAAIF,OAAO7F,sBAAuB5B,EAAOK,aAC9CvpB,KAAK6wB,IAAID,UAAUre,IAAKkgH,EAAOn2H,EAAGm2H,EAAOj2H,EAAG,IAAM6sB,UAAWH,GAASzV,IAAKzT,KAAK6wB,IAAIF,QAASjhB,YAC7F1P,KAAKkpB,OAASA,GAEHA,EAAOkyC,sBAElBp7D,KAAK6wB,IAAIF,OAAOpe,IAAKkgH,EAAOn2H,EAAGm2H,EAAOj2H,GAAK0sB,EAAOoP,KAAOpP,EAAOqP,MAAUrP,EAAOoP,KAAOpP,EAAOqP,MAAQlP,UAAWH,GAClHlpB,KAAK6wB,IAAID,UAAUre,IAAK,EAAG,GAAK,GAAIiX,mBAAoBN,EAAOK,aAC/DvpB,KAAKkpB,OAASA,GAId5qB,QAAQ6+B,MAAO,6CAA+CjU,EAAOnc,KAIvE,CAEA2lH,gBAAiBvmG,EAAQoU,GAAY,EAAMoU,EAAa,IAMvD,OAJA+9E,GAAiBvmG,EAAQnsB,KAAM20C,EAAYpU,GAE3CoU,EAAWgwB,KAAMguD,IAEVh+E,CAER,CAEAi+E,iBAAkBzhE,EAAS5wB,GAAY,EAAMoU,EAAa,IAEzD,IAAM,IAAIr0C,EAAI,EAAGoN,EAAIyjD,EAAQxwD,OAAQL,EAAIoN,EAAGpN,IAE3CoyH,GAAiBvhE,EAAS7wD,GAAKN,KAAM20C,EAAYpU,GAMlD,OAFAoU,EAAWgwB,KAAMguD,IAEVh+E,CAER,EAID,SAASg+E,GAASlqH,EAAGiJ,GAEpB,OAAOjJ,EAAEi0B,SAAWhrB,EAAEgrB,QAEvB,CAEA,SAASg2F,GAAiBvmG,EAAQuoB,EAAWC,EAAYpU,GAQxD,GANKpU,EAAO0N,OAAOn3B,KAAMgyC,EAAU7a,SAElC1N,EAAO6R,QAAS0W,EAAWC,IAIT,IAAdpU,EAAqB,CAEzB,MAAMlT,EAAWlB,EAAOkB,SAExB,IAAM,IAAI/sB,EAAI,EAAGoN,EAAI2f,EAAS1sB,OAAQL,EAAIoN,EAAGpN,IAE5CoyH,GAAiBrlG,EAAU/sB,GAAKo0C,EAAWC,GAAY,EAIzD,CAED,CC54+CA,SAASk+E,GAAqB1lG,EAAU2lG,GAEvC,GAAKA,IAAa7mH,EAGjB,OADA3N,QAAQkU,KAAM,2FACP2a,EAIR,GAAK2lG,IAAa3mH,GAAuB2mH,IAAa5mH,EAAwB,CAE7E,IAAInO,EAAQovB,EAASgiB,WAIrB,GAAe,OAAVpxC,EAAiB,CAErB,MAAMoyC,EAAU,GAEV/iB,EAAWD,EAASkiB,aAAc,YAExC,QAAkBlyC,IAAbiwB,EAcJ,OADA9uB,QAAQ6+B,MAAO,2GACRhQ,EAZP,IAAM,IAAI7sB,EAAI,EAAGA,EAAI8sB,EAASnoB,MAAO3E,IAEpC6vC,EAAQ1wC,KAAMa,GAIf6sB,EAASiiB,SAAUe,GACnBpyC,EAAQovB,EAASgiB,UASnB,CAIA,MAAM4jF,EAAoBh1H,EAAMkH,MAAQ,EAClC+tH,EAAa,GAEnB,GAAKF,IAAa3mH,EAIjB,IAAM,IAAI7L,EAAI,EAAGA,GAAKyyH,EAAmBzyH,IAExC0yH,EAAWvzH,KAAM1B,EAAMgY,KAAM,IAC7Bi9G,EAAWvzH,KAAM1B,EAAMgY,KAAMzV,IAC7B0yH,EAAWvzH,KAAM1B,EAAMgY,KAAMzV,EAAI,SAQlC,IAAM,IAAIA,EAAI,EAAGA,EAAIyyH,EAAmBzyH,IAElCA,EAAI,GAAM,GAEd0yH,EAAWvzH,KAAM1B,EAAMgY,KAAMzV,IAC7B0yH,EAAWvzH,KAAM1B,EAAMgY,KAAMzV,EAAI,IACjC0yH,EAAWvzH,KAAM1B,EAAMgY,KAAMzV,EAAI,MAIjC0yH,EAAWvzH,KAAM1B,EAAMgY,KAAMzV,EAAI,IACjC0yH,EAAWvzH,KAAM1B,EAAMgY,KAAMzV,EAAI,IACjC0yH,EAAWvzH,KAAM1B,EAAMgY,KAAMzV,KAQzB0yH,EAAWryH,OAAS,IAAQoyH,GAElCz0H,QAAQ6+B,MAAO,oGAMhB,MAAM81F,EAAc9lG,EAASha,QAI7B,OAHA8/G,EAAY7jF,SAAU4jF,GACtBC,EAAYvjF,cAELujF,CAER,CAGC,OADA30H,QAAQ6+B,MAAO,sEAAuE21F,GAC/E3lG,CAIT,CD6siDmC,oBAAvB8oF,oBAEXA,mBAAmB1oG,cAAe,IAAI2oG,YAAa,WAAY,CAAEC,OAAQ,CACxE+c,SAAU9pH,MAKW,oBAAX/L,SAENA,OAAO81H,UAEX70H,QAAQkU,KAAM,2DAIdnV,OAAO81H,UAAY/pH,GEz+jDrB,MAAMgqH,WAAmB/M,GAExB9jH,YAAa+jH,GAEZlnG,MAAOknG,GAEPtmH,KAAKqzH,YAAc,KACnBrzH,KAAKszH,WAAa,KAClBtzH,KAAKuzH,eAAiB,KAEtBvzH,KAAKwzH,gBAAkB,GAEvBxzH,KAAKyzH,UAAU,SAAWC,GAEzB,OAAO,IAAIC,GAAiCD,EAE7C,IAEA1zH,KAAKyzH,UAAU,SAAWC,GAEzB,OAAO,IAAIE,GAA4BF,EAExC,IAEA1zH,KAAKyzH,UAAU,SAAWC,GAEzB,OAAO,IAAIG,GAA0BH,EAEtC,IAEA1zH,KAAKyzH,UAAU,SAAWC,GAEzB,OAAO,IAAII,GAA0BJ,EAEtC,IAEA1zH,KAAKyzH,UAAU,SAAWC,GAEzB,OAAO,IAAIK,GAA6BL,EAEzC,IAEA1zH,KAAKyzH,UAAU,SAAWC,GAEzB,OAAO,IAAIM,GAAoCN,EAEhD,IAEA1zH,KAAKyzH,UAAU,SAAWC,GAEzB,OAAO,IAAIO,GAA8BP,EAE1C,IAEA1zH,KAAKyzH,UAAU,SAAWC,GAEzB,OAAO,IAAIQ,GAA2BR,EAEvC,IAEA1zH,KAAKyzH,UAAU,SAAWC,GAEzB,OAAO,IAAIS,GAAwCT,EAEpD,IAEA1zH,KAAKyzH,UAAU,SAAWC,GAEzB,OAAO,IAAIU,GAAgCV,EAE5C,IAEA1zH,KAAKyzH,UAAU,SAAWC,GAEzB,OAAO,IAAIW,GAAmCX,EAE/C,IAEA1zH,KAAKyzH,UAAU,SAAWC,GAEzB,OAAO,IAAIY,GAAkCZ,EAE9C,IAEA1zH,KAAKyzH,UAAU,SAAWC,GAEzB,OAAO,IAAIa,GAAqBb,EAEjC,IAEA1zH,KAAKyzH,UAAU,SAAWC,GAEzB,OAAO,IAAIc,GAAwBd,EAEpC,IAEA1zH,KAAKyzH,UAAU,SAAWC,GAEzB,OAAO,IAAIe,GAAuBf,EAEnC,GAED,CAEA/M,KAAMhjH,EAAKqhH,EAAQC,EAAYC,GAE9B,MAAM1vE,EAAQx1C,KAEd,IAAIymH,EAIHA,EAF0B,KAAtBzmH,KAAKymH,aAEMzmH,KAAKymH,aAEK,KAAdzmH,KAAKsrE,KAEDtrE,KAAKsrE,KAILygD,GAAY2I,eAAgB/wH,GAO5C3D,KAAKsmH,QAAQb,UAAW9hH,GAExB,MAAMgxH,EAAW,SAAWz4H,GAEtBgpH,EAEJA,EAAShpH,GAIToC,QAAQ6+B,MAAOjhC,GAIhBs5C,EAAM8wE,QAAQX,UAAWhiH,GACzB6xC,EAAM8wE,QAAQZ,QAAS/hH,EAExB,EAEMqiH,EAAS,IAAIyB,GAAYznH,KAAKsmH,SAEpCN,EAAOkB,QAASlnH,KAAKsrE,MACrB06C,EAAOgE,gBAAiB,eACxBhE,EAAOoB,iBAAkBpnH,KAAK0mH,eAC9BV,EAAOiB,mBAAoBjnH,KAAKwmH,iBAEhCR,EAAOW,KAAMhjH,GAAK,SAAWN,GAE5B,IAECmyC,EAAMp1B,MAAO/c,EAAMojH,GAAc,SAAWmO,GAE3C5P,EAAQ4P,GAERp/E,EAAM8wE,QAAQZ,QAAS/hH,EAExB,GAAGgxH,EAEJ,CAAE,MAAQz4H,GAETy4H,EAAUz4H,EAEX,CAED,GAAG+oH,EAAY0P,EAEhB,CAEAE,eAAgBxB,GAGf,OADArzH,KAAKqzH,YAAcA,EACZrzH,IAER,CAEA80H,eAEC,MAAM,IAAI7uH,MAET,mGAIF,CAEA8uH,cAAezB,GAGd,OADAtzH,KAAKszH,WAAaA,EACXtzH,IAER,CAEAg1H,kBAAmBzB,GAGlB,OADAvzH,KAAKuzH,eAAiBA,EACfvzH,IAER,CAEAyzH,SAAUxrG,GAQT,OANoD,IAA/CjoB,KAAKwzH,gBAAgBrmH,QAAS8a,IAElCjoB,KAAKwzH,gBAAgB/zH,KAAMwoB,GAIrBjoB,IAER,CAEAi1H,WAAYhtG,GAQX,OANoD,IAA/CjoB,KAAKwzH,gBAAgBrmH,QAAS8a,IAElCjoB,KAAKwzH,gBAAgBvrH,OAAQjI,KAAKwzH,gBAAgBrmH,QAAS8a,GAAY,GAIjEjoB,IAER,CAEAogB,MAAO/c,EAAMioE,EAAM05C,EAAQE,GAE1B,IAAItM,EACJ,MAAM/gE,EAAa,CAAC,EACdq9E,EAAU,CAAC,EACXC,EAAc,IAAIvL,YAExB,GAAqB,iBAATvmH,EAEXu1G,EAAOz1G,KAAKid,MAAO/c,QAEb,GAAKA,aAAgB64G,YAI3B,GAFciZ,EAAYtL,OAAQ,IAAIv6G,WAAYjM,EAAM,EAAG,MAE5C+xH,GAAgC,CAE9C,IAECv9E,EAAYw9E,GAAWC,iBAAoB,IAAIC,GAAqBlyH,EAErE,CAAE,MAAQ85B,GAGT,YADK+nF,GAAUA,EAAS/nF,GAGzB,CAEAy7E,EAAOz1G,KAAKid,MAAOy3B,EAAYw9E,GAAWC,iBAAkBn1H,QAE7D,MAECy4G,EAAOz1G,KAAKid,MAAO+0G,EAAYtL,OAAQxmH,SAMxCu1G,EAAOv1G,EAIR,QAAoBlG,IAAfy7G,EAAK4c,OAAuB5c,EAAK4c,MAAM33G,QAAS,GAAM,EAG1D,YADKqnG,GAAUA,EAAS,IAAIj/G,MAAO,6EAKpC,MAAMytH,EAAS,IAAI+B,GAAY7c,EAAM,CAEpCttC,KAAMA,GAAQtrE,KAAKymH,cAAgB,GACnCF,YAAavmH,KAAKumH,YAClBG,cAAe1mH,KAAK0mH,cACpBJ,QAAStmH,KAAKsmH,QACdgN,WAAYtzH,KAAKszH,WACjBC,eAAgBvzH,KAAKuzH,iBAItBG,EAAOgC,WAAWtO,iBAAkBpnH,KAAK0mH,eAEzC,IAAM,IAAIpmH,EAAI,EAAGA,EAAIN,KAAKwzH,gBAAgB7yH,OAAQL,IAAO,CAExD,MAAMq1H,EAAS31H,KAAKwzH,gBAAiBlzH,GAAKozH,GAC1CwB,EAASS,EAAOnzH,MAASmzH,EAMzB99E,EAAY89E,EAAOnzH,OAAS,CAE7B,CAEA,GAAKo2G,EAAKgd,eAET,IAAM,IAAIt1H,EAAI,EAAGA,EAAIs4G,EAAKgd,eAAej1H,SAAWL,EAAI,CAEvD,MAAMu1H,EAAgBjd,EAAKgd,eAAgBt1H,GACrCw1H,EAAqBld,EAAKkd,oBAAsB,GAEtD,OAASD,GAER,KAAKR,GAAWU,oBACfl+E,EAAYg+E,GAAkB,IAAIG,GAClC,MAED,KAAKX,GAAWY,2BACfp+E,EAAYg+E,GAAkB,IAAIK,GAAmCtd,EAAM54G,KAAKqzH,aAChF,MAED,KAAKgC,GAAWc,sBACft+E,EAAYg+E,GAAkB,IAAIO,GAClC,MAED,KAAKf,GAAWgB,sBACfx+E,EAAYg+E,GAAkB,IAAIS,GAClC,MAED,QAEMR,EAAmB3oH,QAAS0oH,IAAmB,QAAkC14H,IAA7B+3H,EAASW,IAEjEv3H,QAAQkU,KAAM,wCAA0CqjH,EAAgB,MAM5E,CAIDnC,EAAO6C,cAAe1+E,GACtB67E,EAAO8C,WAAYtB,GACnBxB,EAAOtzG,MAAO4kG,EAAQE,EAEvB,CAEAuR,WAAYpzH,EAAMioE,GAEjB,MAAM91B,EAAQx1C,KAEd,OAAO,IAAI6mH,SAAS,SAAWC,EAASC,GAEvCvxE,EAAMp1B,MAAO/c,EAAMioE,EAAMw7C,EAASC,EAEnC,GAED,EAMD,SAAS2P,KAER,IAAIvlE,EAAU,CAAC,EAEf,MAAO,CAENtoD,IAAK,SAAW9C,GAEf,OAAOorD,EAASprD,EAEjB,EAEA/I,IAAK,SAAW+I,EAAKomB,GAEpBglC,EAASprD,GAAQomB,CAElB,EAEAjvB,OAAQ,SAAW6I,UAEXorD,EAASprD,EAEjB,EAEA4wH,UAAW,WAEVxlE,EAAU,CAAC,CAEZ,EAIF,CAMA,MAAMkkE,GAAa,CAClBC,gBAAiB,kBACjBW,2BAA4B,6BAC5BW,oBAAqB,sBACrBC,wBAAyB,0BACzBC,kBAAmB,oBACnBC,oBAAqB,sBACrBC,uBAAwB,yBACxBC,2BAA4B,6BAC5BC,0BAA2B,4BAC3BC,yBAA0B,2BAC1BpB,oBAAqB,sBACrBqB,qBAAsB,uBACtBC,mBAAoB,qBACpBlB,sBAAuB,wBACvBE,sBAAuB,wBACvBiB,gCAAiC,kCACjCC,iBAAkB,mBAClBC,iBAAkB,mBAClBC,wBAAyB,0BACzBC,wBAAyB,2BAQ1B,MAAMnD,GAELhyH,YAAamxH,GAEZ1zH,KAAK0zH,OAASA,EACd1zH,KAAKwC,KAAO6yH,GAAWuB,oBAGvB52H,KAAKqgC,MAAQ,CAAEs3F,KAAM,CAAC,EAAGC,KAAM,CAAC,EAEjC,CAEAC,YAEC,MAAMnE,EAAS1zH,KAAK0zH,OACdoE,EAAW93H,KAAK0zH,OAAO9a,KAAK/5E,OAAS,GAE3C,IAAM,IAAIk5F,EAAY,EAAGC,EAAaF,EAASn3H,OAAQo3H,EAAYC,EAAYD,IAAe,CAE7F,MAAME,EAAUH,EAAUC,GAErBE,EAAQpgF,YACRogF,EAAQpgF,WAAY73C,KAAKwC,YACiBrF,IAA1C86H,EAAQpgF,WAAY73C,KAAKwC,MAAO27E,OAEpCu1C,EAAOwE,YAAal4H,KAAKqgC,MAAO43F,EAAQpgF,WAAY73C,KAAKwC,MAAO27E,MAIlE,CAED,CAEAg6C,WAAYC,GAEX,MAAM1E,EAAS1zH,KAAK0zH,OACdhkD,EAAW,SAAW0oD,EAC5B,IAAIC,EAAa3E,EAAOrzF,MAAMx3B,IAAK6mE,GAEnC,GAAK2oD,EAAa,OAAOA,EAEzB,MAAMzf,EAAO8a,EAAO9a,KAGd0f,IAFe1f,EAAK/gE,YAAc+gE,EAAK/gE,WAAY73C,KAAKwC,OAAY,CAAC,GAC9Cm1C,QAAU,IACXygF,GAC5B,IAAIG,EAEJ,MAAM/8G,EAAQ,IAAIuvB,GAAO,eAED5tC,IAAnBm7H,EAAS98G,OAAsBA,EAAM9F,UAAW4iH,EAAS98G,OAE9D,MAAMxK,OAA2B7T,IAAnBm7H,EAAStnH,MAAsBsnH,EAAStnH,MAAQ,EAE9D,OAASsnH,EAASvrH,MAEjB,IAAK,cACJwrH,EAAY,IAAI1M,GAAkBrwG,GAClC+8G,EAAUn0H,OAAOgpB,SAAS7a,IAAK,EAAG,GAAK,GACvCgmH,EAAUv7H,IAAKu7H,EAAUn0H,QACzB,MAED,IAAK,QACJm0H,EAAY,IAAI7M,GAAYlwG,GAC5B+8G,EAAU77F,SAAW1rB,EACrB,MAED,IAAK,OACJunH,EAAY,IAAIpN,GAAW3vG,GAC3B+8G,EAAU77F,SAAW1rB,EAErBsnH,EAASn8C,KAAOm8C,EAASn8C,MAAQ,CAAC,EAClCm8C,EAASn8C,KAAKq8C,oBAAkDr7H,IAAjCm7H,EAASn8C,KAAKq8C,eAA+BF,EAASn8C,KAAKq8C,eAAiB,EAC3GF,EAASn8C,KAAKs8C,oBAAkDt7H,IAAjCm7H,EAASn8C,KAAKs8C,eAA+BH,EAASn8C,KAAKs8C,eAAiBz6H,KAAKI,GAAK,EACrHm6H,EAAU3jH,MAAQ0jH,EAASn8C,KAAKs8C,eAChCF,EAAU33C,SAAW,EAAM03C,EAASn8C,KAAKq8C,eAAiBF,EAASn8C,KAAKs8C,eACxEF,EAAUn0H,OAAOgpB,SAAS7a,IAAK,EAAG,GAAK,GACvCgmH,EAAUv7H,IAAKu7H,EAAUn0H,QACzB,MAED,QACC,MAAM,IAAI6B,MAAO,4CAA8CqyH,EAASvrH,MAoB1E,OAdAwrH,EAAUnrG,SAAS7a,IAAK,EAAG,EAAG,GAE9BgmH,EAAUprE,MAAQ,EAElBurE,GAAwBH,EAAWD,QAEPn7H,IAAvBm7H,EAASr4C,YAA0Bs4C,EAAUt4C,UAAYq4C,EAASr4C,WAEvEs4C,EAAU/1H,KAAOkxH,EAAOiF,iBAAkBL,EAAS91H,MAAU,SAAW41H,GAExEC,EAAaxR,QAAQC,QAASyR,GAE9B7E,EAAOrzF,MAAMrjC,IAAK0yE,EAAU2oD,GAErBA,CAER,CAEAO,cAAe7rH,EAAMhP,GAEpB,GAAc,UAATgP,EAEL,OAAO/M,KAAKm4H,WAAYp6H,EAEzB,CAEA86H,qBAAsBd,GAErB,MAAMlkB,EAAO7zG,KACP0zH,EAAS1zH,KAAK0zH,OAEduE,EADOvE,EAAO9a,KACC/5E,MAAOk5F,GAEtBK,GADaH,EAAQpgF,YAAcogF,EAAQpgF,WAAY73C,KAAKwC,OAAY,CAAC,GACnD27E,MAE5B,YAAoBhhF,IAAfi7H,EAAkC,KAEhCp4H,KAAKm4H,WAAYC,GAAajQ,MAAM,SAAWhqC,GAErD,OAAOu1C,EAAOoF,YAAajlB,EAAKxzE,MAAO+3F,EAAYj6C,EAEpD,GAED,EASD,MAAM63C,GAELzzH,cAECvC,KAAKwC,KAAO6yH,GAAWU,mBAExB,CAEAgD,kBAEC,OAAOhsF,EAER,CAEAisF,aAAcC,EAAgBC,EAAaxF,GAE1C,MAAMyF,EAAU,GAEhBF,EAAez9G,MAAQ,IAAIuvB,GAAO,EAAK,EAAK,GAC5CkuF,EAAet1F,QAAU,EAEzB,MAAMy1F,EAAoBF,EAAYG,qBAEtC,GAAKD,EAAoB,CAExB,GAAKn4H,MAAME,QAASi4H,EAAkBE,iBAAoB,CAEzD,MAAM7rH,EAAQ2rH,EAAkBE,gBAEhCL,EAAez9G,MAAM9F,UAAWjI,GAChCwrH,EAAet1F,QAAUl2B,EAAO,EAEjC,MAE4CtQ,IAAvCi8H,EAAkBG,kBAEtBJ,EAAQ15H,KAAMi0H,EAAO8F,cAAeP,EAAgB,MAAOG,EAAkBG,iBAAkBltH,IAIjG,CAEA,OAAOw6G,QAAQl/G,IAAKwxH,EAErB,EASD,MAAMhF,GAEL5xH,YAAamxH,GAEZ1zH,KAAK0zH,OAASA,EACd1zH,KAAKwC,KAAO6yH,GAAWiC,+BAExB,CAEAmC,qBAAsBhqF,EAAewpF,GAEpC,MACMC,EADSl5H,KAAK0zH,OACO9a,KAAKl6E,UAAW+Q,GAE3C,IAAOypF,EAAYrhF,aAAgBqhF,EAAYrhF,WAAY73C,KAAKwC,MAE/D,OAAOqkH,QAAQC,UAIhB,MAAM4S,EAAmBR,EAAYrhF,WAAY73C,KAAKwC,MAAOk3H,iBAQ7D,YAN0Bv8H,IAArBu8H,IAEJT,EAAeryF,kBAAoB8yF,GAI7B7S,QAAQC,SAEhB,EASD,MAAM6M,GAELpxH,YAAamxH,GAEZ1zH,KAAK0zH,OAASA,EACd1zH,KAAKwC,KAAO6yH,GAAWwB,uBAExB,CAEAkC,gBAAiBtpF,GAEhB,MACMypF,EADSl5H,KAAK0zH,OACO9a,KAAKl6E,UAAW+Q,GAE3C,OAAOypF,EAAYrhF,YAAgBqhF,EAAYrhF,WAAY73C,KAAKwC,MAEzDo2E,GAFyE,IAIjF,CAEA6gD,qBAAsBhqF,EAAewpF,GAEpC,MAAMvF,EAAS1zH,KAAK0zH,OACdwF,EAAcxF,EAAO9a,KAAKl6E,UAAW+Q,GAE3C,IAAOypF,EAAYrhF,aAAgBqhF,EAAYrhF,WAAY73C,KAAKwC,MAE/D,OAAOqkH,QAAQC,UAIhB,MAAMqS,EAAU,GAEVxmE,EAAYumE,EAAYrhF,WAAY73C,KAAKwC,MA0B/C,QAxBmCrF,IAA9Bw1D,EAAUgnE,kBAEdV,EAAehyF,UAAY0rB,EAAUgnE,sBAIFx8H,IAA/Bw1D,EAAUinE,kBAEdT,EAAQ15H,KAAMi0H,EAAO8F,cAAeP,EAAgB,eAAgBtmE,EAAUinE,wBAInCz8H,IAAvCw1D,EAAUknE,2BAEdZ,EAAe/xF,mBAAqByrB,EAAUknE,+BAIF18H,IAAxCw1D,EAAUmnE,2BAEdX,EAAQ15H,KAAMi0H,EAAO8F,cAAeP,EAAgB,wBAAyBtmE,EAAUmnE,iCAI9C38H,IAArCw1D,EAAUonE,yBAEdZ,EAAQ15H,KAAMi0H,EAAO8F,cAAeP,EAAgB,qBAAsBtmE,EAAUonE,8BAEpC58H,IAA3Cw1D,EAAUonE,uBAAuB3/G,OAAsB,CAE3D,MAAMA,EAAQu4C,EAAUonE,uBAAuB3/G,MAE/C6+G,EAAe3xF,qBAAuB,IAAI70B,GAAS2H,EAAOA,EAE3D,CAID,OAAOysG,QAAQl/G,IAAKwxH,EAErB,EASD,MAAM9E,GAEL9xH,YAAamxH,GAEZ1zH,KAAK0zH,OAASA,EACd1zH,KAAKwC,KAAO6yH,GAAW6B,yBAExB,CAEA6B,gBAAiBtpF,GAEhB,MACMypF,EADSl5H,KAAK0zH,OACO9a,KAAKl6E,UAAW+Q,GAE3C,OAAOypF,EAAYrhF,YAAgBqhF,EAAYrhF,WAAY73C,KAAKwC,MAEzDo2E,GAFyE,IAIjF,CAEA6gD,qBAAsBhqF,EAAewpF,GAEpC,MAAMvF,EAAS1zH,KAAK0zH,OACdwF,EAAcxF,EAAO9a,KAAKl6E,UAAW+Q,GAE3C,IAAOypF,EAAYrhF,aAAgBqhF,EAAYrhF,WAAY73C,KAAKwC,MAE/D,OAAOqkH,QAAQC,UAIhB,MAAMqS,EAAU,GAEVxmE,EAAYumE,EAAYrhF,WAAY73C,KAAKwC,MA4C/C,YA1CqCrF,IAAhCw1D,EAAUqnE,oBAEdf,EAAe1xF,YAAcorB,EAAUqnE,wBAIF78H,IAAjCw1D,EAAUsnE,oBAEdd,EAAQ15H,KAAMi0H,EAAO8F,cAAeP,EAAgB,iBAAkBtmE,EAAUsnE,0BAI/C98H,IAA7Bw1D,EAAUunE,iBAEdjB,EAAezxF,eAAiBmrB,EAAUunE,qBAIO/8H,IAA7C87H,EAAexxF,4BAEnBwxF,EAAexxF,0BAA4B,CAAE,IAAK,WAIJtqC,IAA1Cw1D,EAAU5C,8BAEdkpE,EAAexxF,0BAA2B,GAAMkrB,EAAU5C,kCAIZ5yD,IAA1Cw1D,EAAU3C,8BAEdipE,EAAexxF,0BAA2B,GAAMkrB,EAAU3C,kCAIZ7yD,IAA1Cw1D,EAAUwnE,6BAEdhB,EAAQ15H,KAAMi0H,EAAO8F,cAAeP,EAAgB,0BAA2BtmE,EAAUwnE,8BAInFtT,QAAQl/G,IAAKwxH,EAErB,EASD,MAAMpF,GAELxxH,YAAamxH,GAEZ1zH,KAAK0zH,OAASA,EACd1zH,KAAKwC,KAAO6yH,GAAW0B,mBAExB,CAEAgC,gBAAiBtpF,GAEhB,MACMypF,EADSl5H,KAAK0zH,OACO9a,KAAKl6E,UAAW+Q,GAE3C,OAAOypF,EAAYrhF,YAAgBqhF,EAAYrhF,WAAY73C,KAAKwC,MAEzDo2E,GAFyE,IAIjF,CAEA6gD,qBAAsBhqF,EAAewpF,GAEpC,MAAMvF,EAAS1zH,KAAK0zH,OACdwF,EAAcxF,EAAO9a,KAAKl6E,UAAW+Q,GAE3C,IAAOypF,EAAYrhF,aAAgBqhF,EAAYrhF,WAAY73C,KAAKwC,MAE/D,OAAOqkH,QAAQC,UAIhB,MAAMqS,EAAU,GAEhBF,EAAexyF,WAAa,IAAIsE,GAAO,EAAG,EAAG,GAC7CkuF,EAAevyF,eAAiB,EAChCuyF,EAAezyF,MAAQ,EAEvB,MAAMmsB,EAAYumE,EAAYrhF,WAAY73C,KAAKwC,MA0B/C,YAxBoCrF,IAA/Bw1D,EAAUynE,kBAEdnB,EAAexyF,WAAW/wB,UAAWi9C,EAAUynE,uBAIRj9H,IAAnCw1D,EAAU0nE,uBAEdpB,EAAevyF,eAAiBisB,EAAU0nE,2BAINl9H,IAAhCw1D,EAAU2nE,mBAEdnB,EAAQ15H,KAAMi0H,EAAO8F,cAAeP,EAAgB,gBAAiBtmE,EAAU2nE,kBAAmBjuH,UAI1DlP,IAApCw1D,EAAU4nE,uBAEdpB,EAAQ15H,KAAMi0H,EAAO8F,cAAeP,EAAgB,oBAAqBtmE,EAAU4nE,wBAI7E1T,QAAQl/G,IAAKwxH,EAErB,EAUD,MAAMnF,GAELzxH,YAAamxH,GAEZ1zH,KAAK0zH,OAASA,EACd1zH,KAAKwC,KAAO6yH,GAAW4B,0BAExB,CAEA8B,gBAAiBtpF,GAEhB,MACMypF,EADSl5H,KAAK0zH,OACO9a,KAAKl6E,UAAW+Q,GAE3C,OAAOypF,EAAYrhF,YAAgBqhF,EAAYrhF,WAAY73C,KAAKwC,MAEzDo2E,GAFyE,IAIjF,CAEA6gD,qBAAsBhqF,EAAewpF,GAEpC,MAAMvF,EAAS1zH,KAAK0zH,OACdwF,EAAcxF,EAAO9a,KAAKl6E,UAAW+Q,GAE3C,IAAOypF,EAAYrhF,aAAgBqhF,EAAYrhF,WAAY73C,KAAKwC,MAE/D,OAAOqkH,QAAQC,UAIhB,MAAMqS,EAAU,GAEVxmE,EAAYumE,EAAYrhF,WAAY73C,KAAKwC,MAc/C,YAZsCrF,IAAjCw1D,EAAU6nE,qBAEdvB,EAAezvF,aAAempB,EAAU6nE,yBAIFr9H,IAAlCw1D,EAAU8nE,qBAEdtB,EAAQ15H,KAAMi0H,EAAO8F,cAAeP,EAAgB,kBAAmBtmE,EAAU8nE,sBAI3E5T,QAAQl/G,IAAKwxH,EAErB,EASD,MAAMlF,GAEL1xH,YAAamxH,GAEZ1zH,KAAK0zH,OAASA,EACd1zH,KAAKwC,KAAO6yH,GAAW+B,oBAExB,CAEA2B,gBAAiBtpF,GAEhB,MACMypF,EADSl5H,KAAK0zH,OACO9a,KAAKl6E,UAAW+Q,GAE3C,OAAOypF,EAAYrhF,YAAgBqhF,EAAYrhF,WAAY73C,KAAKwC,MAEzDo2E,GAFyE,IAIjF,CAEA6gD,qBAAsBhqF,EAAewpF,GAEpC,MAAMvF,EAAS1zH,KAAK0zH,OACdwF,EAAcxF,EAAO9a,KAAKl6E,UAAW+Q,GAE3C,IAAOypF,EAAYrhF,aAAgBqhF,EAAYrhF,WAAY73C,KAAKwC,MAE/D,OAAOqkH,QAAQC,UAIhB,MAAMqS,EAAU,GAEVxmE,EAAYumE,EAAYrhF,WAAY73C,KAAKwC,MAE/Cy2H,EAAevvF,eAA0CvsC,IAA9Bw1D,EAAU+nE,gBAAgC/nE,EAAU+nE,gBAAkB,OAE7Dv9H,IAA/Bw1D,EAAUgoE,kBAEdxB,EAAQ15H,KAAMi0H,EAAO8F,cAAeP,EAAgB,eAAgBtmE,EAAUgoE,mBAI/E1B,EAAervF,oBAAsB+oB,EAAU/oB,qBAAuBC,IAEtE,MAAM+wF,EAAajoE,EAAU7oB,kBAAoB,CAAE,EAAG,EAAG,GAGzD,OAFAmvF,EAAenvF,iBAAmB,IAAIiB,GAAO6vF,EAAY,GAAKA,EAAY,GAAKA,EAAY,IAEpF/T,QAAQl/G,IAAKwxH,EAErB,EASD,MAAMjF,GAEL3xH,YAAamxH,GAEZ1zH,KAAK0zH,OAASA,EACd1zH,KAAKwC,KAAO6yH,GAAWyB,iBAExB,CAEAiC,gBAAiBtpF,GAEhB,MACMypF,EADSl5H,KAAK0zH,OACO9a,KAAKl6E,UAAW+Q,GAE3C,OAAOypF,EAAYrhF,YAAgBqhF,EAAYrhF,WAAY73C,KAAKwC,MAEzDo2E,GAFyE,IAIjF,CAEA6gD,qBAAsBhqF,EAAewpF,GAEpC,MACMC,EADSl5H,KAAK0zH,OACO9a,KAAKl6E,UAAW+Q,GAE3C,IAAOypF,EAAYrhF,aAAgBqhF,EAAYrhF,WAAY73C,KAAKwC,MAE/D,OAAOqkH,QAAQC,UAIhB,MAAMn0D,EAAYumE,EAAYrhF,WAAY73C,KAAKwC,MAI/C,OAFAy2H,EAAeluE,SAAwB5tD,IAAlBw1D,EAAU5H,IAAoB4H,EAAU5H,IAAM,IAE5D87D,QAAQC,SAEhB,EASD,MAAMsN,GAEL7xH,YAAamxH,GAEZ1zH,KAAK0zH,OAASA,EACd1zH,KAAKwC,KAAO6yH,GAAW2B,sBAExB,CAEA+B,gBAAiBtpF,GAEhB,MACMypF,EADSl5H,KAAK0zH,OACO9a,KAAKl6E,UAAW+Q,GAE3C,OAAOypF,EAAYrhF,YAAgBqhF,EAAYrhF,WAAY73C,KAAKwC,MAEzDo2E,GAFyE,IAIjF,CAEA6gD,qBAAsBhqF,EAAewpF,GAEpC,MAAMvF,EAAS1zH,KAAK0zH,OACdwF,EAAcxF,EAAO9a,KAAKl6E,UAAW+Q,GAE3C,IAAOypF,EAAYrhF,aAAgBqhF,EAAYrhF,WAAY73C,KAAKwC,MAE/D,OAAOqkH,QAAQC,UAIhB,MAAMqS,EAAU,GAEVxmE,EAAYumE,EAAYrhF,WAAY73C,KAAKwC,MAE/Cy2H,EAAenyF,uBAAiD3pC,IAA7Bw1D,EAAUkoE,eAA+BloE,EAAUkoE,eAAiB,OAEpE19H,IAA9Bw1D,EAAUmoE,iBAEd3B,EAAQ15H,KAAMi0H,EAAO8F,cAAeP,EAAgB,uBAAwBtmE,EAAUmoE,kBAIvF,MAAMF,EAAajoE,EAAUooE,qBAAuB,CAAE,EAAG,EAAG,GAS5D,OARA9B,EAAelyF,cAAgB,IAAIgE,GAAO6vF,EAAY,GAAKA,EAAY,GAAKA,EAAY,SAEhDz9H,IAAnCw1D,EAAUqoE,sBAEd7B,EAAQ15H,KAAMi0H,EAAO8F,cAAeP,EAAgB,mBAAoBtmE,EAAUqoE,qBAAsB3uH,KAIlGw6G,QAAQl/G,IAAKwxH,EAErB,EASD,MAAM7E,GAEL/xH,YAAamxH,GAEZ1zH,KAAK0zH,OAASA,EACd1zH,KAAKwC,KAAO6yH,GAAW8B,wBAExB,CAEA4B,gBAAiBtpF,GAEhB,MACMypF,EADSl5H,KAAK0zH,OACO9a,KAAKl6E,UAAW+Q,GAE3C,OAAOypF,EAAYrhF,YAAgBqhF,EAAYrhF,WAAY73C,KAAKwC,MAEzDo2E,GAFyE,IAIjF,CAEA6gD,qBAAsBhqF,EAAewpF,GAEpC,MAAMvF,EAAS1zH,KAAK0zH,OACdwF,EAAcxF,EAAO9a,KAAKl6E,UAAW+Q,GAE3C,IAAOypF,EAAYrhF,aAAgBqhF,EAAYrhF,WAAY73C,KAAKwC,MAE/D,OAAOqkH,QAAQC,UAIhB,MAAMqS,EAAU,GAEVxmE,EAAYumE,EAAYrhF,WAAY73C,KAAKwC,MAoB/C,YAlBsCrF,IAAjCw1D,EAAUsoE,qBAEdhC,EAAeh6G,WAAa0zC,EAAUsoE,yBAID99H,IAAjCw1D,EAAU/qB,qBAEdqxF,EAAerxF,mBAAqB+qB,EAAU/qB,yBAIVzqC,IAAhCw1D,EAAUuoE,mBAEd/B,EAAQ15H,KAAMi0H,EAAO8F,cAAeP,EAAgB,gBAAiBtmE,EAAUuoE,oBAIzErU,QAAQl/G,IAAKwxH,EAErB,EASD,MAAMvF,GAELrxH,YAAamxH,GAEZ1zH,KAAK0zH,OAASA,EACd1zH,KAAKwC,KAAO6yH,GAAWgC,kBAExB,CAEA8D,YAAaC,GAEZ,MAAM1H,EAAS1zH,KAAK0zH,OACd9a,EAAO8a,EAAO9a,KAEdyiB,EAAaziB,EAAKv4F,SAAU+6G,GAElC,IAAOC,EAAWxjF,aAAgBwjF,EAAWxjF,WAAY73C,KAAKwC,MAE7D,OAAO,KAIR,MAAMmwD,EAAY0oE,EAAWxjF,WAAY73C,KAAKwC,MACxCwjH,EAAS0N,EAAO9vH,QAAQ0vH,WAE9B,IAAOtN,EAAS,CAEf,GAAKpN,EAAKkd,oBAAsBld,EAAKkd,mBAAmB3oH,QAASnN,KAAKwC,OAAU,EAE/E,MAAM,IAAIyD,MAAO,+EAKjB,OAAO,IAIT,CAEA,OAAOytH,EAAO4H,iBAAkBF,EAAczoE,EAAUlvD,OAAQuiH,EAEjE,EASD,MAAM6N,GAELtxH,YAAamxH,GAEZ1zH,KAAK0zH,OAASA,EACd1zH,KAAKwC,KAAO6yH,GAAWkC,iBACvBv3H,KAAKu7H,YAAc,IAEpB,CAEAJ,YAAaC,GAEZ,MAAM54H,EAAOxC,KAAKwC,KACZkxH,EAAS1zH,KAAK0zH,OACd9a,EAAO8a,EAAO9a,KAEdyiB,EAAaziB,EAAKv4F,SAAU+6G,GAElC,IAAOC,EAAWxjF,aAAgBwjF,EAAWxjF,WAAYr1C,GAExD,OAAO,KAIR,MAAMmwD,EAAY0oE,EAAWxjF,WAAYr1C,GACnCiB,EAASm1G,EAAK16F,OAAQy0C,EAAUlvD,QAEtC,IAAIuiH,EAAS0N,EAAO8H,cACpB,GAAK/3H,EAAOg4H,IAAM,CAEjB,MAAMC,EAAUhI,EAAO9vH,QAAQ0iH,QAAQJ,WAAYziH,EAAOg4H,KACzC,OAAZC,IAAmB1V,EAAS0V,EAElC,CAEA,OAAO17H,KAAK27H,gBAAgBxT,MAAM,SAAWoT,GAE5C,GAAKA,EAAc,OAAO7H,EAAO4H,iBAAkBF,EAAczoE,EAAUlvD,OAAQuiH,GAEnF,GAAKpN,EAAKkd,oBAAsBld,EAAKkd,mBAAmB3oH,QAAS3K,IAAU,EAE1E,MAAM,IAAIyD,MAAO,6DAKlB,OAAOytH,EAAOyH,YAAaC,EAE5B,GAED,CAEAO,gBAsBC,OApBO37H,KAAKu7H,cAEXv7H,KAAKu7H,YAAc,IAAI1U,SAAS,SAAWC,GAE1C,MAAMnqG,EAAQ,IAAIi/G,MAIlBj/G,EAAMC,IAAM,kFAEZD,EAAMk/G,OAASl/G,EAAMm/G,QAAU,WAE9BhV,EAA0B,IAAjBnqG,EAAM/J,OAEhB,CAED,KAIM5S,KAAKu7H,WAEb,EASD,MAAMzH,GAELvxH,YAAamxH,GAEZ1zH,KAAK0zH,OAASA,EACd1zH,KAAKwC,KAAO6yH,GAAWmC,iBACvBx3H,KAAKu7H,YAAc,IAEpB,CAEAJ,YAAaC,GAEZ,MAAM54H,EAAOxC,KAAKwC,KACZkxH,EAAS1zH,KAAK0zH,OACd9a,EAAO8a,EAAO9a,KAEdyiB,EAAaziB,EAAKv4F,SAAU+6G,GAElC,IAAOC,EAAWxjF,aAAgBwjF,EAAWxjF,WAAYr1C,GAExD,OAAO,KAIR,MAAMmwD,EAAY0oE,EAAWxjF,WAAYr1C,GACnCiB,EAASm1G,EAAK16F,OAAQy0C,EAAUlvD,QAEtC,IAAIuiH,EAAS0N,EAAO8H,cACpB,GAAK/3H,EAAOg4H,IAAM,CAEjB,MAAMC,EAAUhI,EAAO9vH,QAAQ0iH,QAAQJ,WAAYziH,EAAOg4H,KACzC,OAAZC,IAAmB1V,EAAS0V,EAElC,CAEA,OAAO17H,KAAK27H,gBAAgBxT,MAAM,SAAWoT,GAE5C,GAAKA,EAAc,OAAO7H,EAAO4H,iBAAkBF,EAAczoE,EAAUlvD,OAAQuiH,GAEnF,GAAKpN,EAAKkd,oBAAsBld,EAAKkd,mBAAmB3oH,QAAS3K,IAAU,EAE1E,MAAM,IAAIyD,MAAO,6DAKlB,OAAOytH,EAAOyH,YAAaC,EAE5B,GAED,CAEAO,gBAoBC,OAlBO37H,KAAKu7H,cAEXv7H,KAAKu7H,YAAc,IAAI1U,SAAS,SAAWC,GAE1C,MAAMnqG,EAAQ,IAAIi/G,MAGlBj/G,EAAMC,IAAM,kbACZD,EAAMk/G,OAASl/G,EAAMm/G,QAAU,WAE9BhV,EAA0B,IAAjBnqG,EAAM/J,OAEhB,CAED,KAIM5S,KAAKu7H,WAEb,EASD,MAAM/G,GAELjyH,YAAamxH,GAEZ1zH,KAAKwC,KAAO6yH,GAAWoC,wBACvBz3H,KAAK0zH,OAASA,CAEf,CAEAqI,eAAgBh+H,GAEf,MAAM66G,EAAO54G,KAAK0zH,OAAO9a,KACnBojB,EAAapjB,EAAKqjB,YAAal+H,GAErC,GAAKi+H,EAAWnkF,YAAcmkF,EAAWnkF,WAAY73C,KAAKwC,MAAS,CAElE,MAAM05H,EAAeF,EAAWnkF,WAAY73C,KAAKwC,MAE3Cw9C,EAAShgD,KAAK0zH,OAAOkF,cAAe,SAAUsD,EAAal8E,QAC3D2pE,EAAU3pH,KAAK0zH,OAAO9vH,QAAQ2vH,eAEpC,IAAO5J,IAAaA,EAAQwS,UAAY,CAEvC,GAAKvjB,EAAKkd,oBAAsBld,EAAKkd,mBAAmB3oH,QAASnN,KAAKwC,OAAU,EAE/E,MAAM,IAAIyD,MAAO,sFAKjB,OAAO,IAIT,CAEA,OAAO+5C,EAAOmoE,MAAM,SAAWsE,GAE9B,MAAM2P,EAAaF,EAAaE,YAAc,EACxCpT,EAAakT,EAAalT,YAAc,EAExC/jH,EAAQi3H,EAAaj3H,MACrBwtC,EAASypF,EAAaG,WAEtB54H,EAAS,IAAI6L,WAAYm9G,EAAK2P,EAAYpT,GAEhD,OAAKW,EAAQ2S,sBAEL3S,EAAQ2S,sBAAuBr3H,EAAOwtC,EAAQhvC,EAAQy4H,EAAatlE,KAAMslE,EAAa51H,QAAS6hH,MAAM,SAAWsE,GAEtH,OAAOA,EAAIzsE,MAEZ,IAKO2pE,EAAQ4S,MAAMpU,MAAM,WAE1B,MAAMvjH,EAAS,IAAIs3G,YAAaj3G,EAAQwtC,GAExC,OADAk3E,EAAQ6S,iBAAkB,IAAIltH,WAAY1K,GAAUK,EAAOwtC,EAAQhvC,EAAQy4H,EAAatlE,KAAMslE,EAAa51H,QACpG1B,CAER,GAIF,GAED,CAEC,OAAO,IAIT,EAUD,MAAM6vH,GAELlyH,YAAamxH,GAEZ1zH,KAAKwC,KAAO6yH,GAAWqC,wBACvB13H,KAAK0zH,OAASA,CAEf,CAEA+I,eAAgB1E,GAEf,MAAMnf,EAAO54G,KAAK0zH,OAAO9a,KACnBqf,EAAUrf,EAAK/5E,MAAOk5F,GAE5B,IAAOE,EAAQpgF,aAAgBogF,EAAQpgF,WAAY73C,KAAKwC,YACtCrF,IAAjB86H,EAAQt8E,KAER,OAAO,KAIR,MAAM+gF,EAAU9jB,EAAK+jB,OAAQ1E,EAAQt8E,MAIrC,IAAM,MAAMihF,KAAaF,EAAQG,WAEhC,GAAKD,EAAUhmE,OAASkmE,GAAgBn6D,WACtCi6D,EAAUhmE,OAASkmE,GAAgBC,gBACnCH,EAAUhmE,OAASkmE,GAAgBE,mBAChB7/H,IAAnBy/H,EAAUhmE,KAEX,OAAO,KAMT,MACMqmE,EADehF,EAAQpgF,WAAY73C,KAAKwC,MACXmD,WAI7BwzH,EAAU,GACVxzH,EAAa,CAAC,EAEpB,IAAM,MAAMI,KAAOk3H,EAElB9D,EAAQ15H,KAAMO,KAAK0zH,OAAOkF,cAAe,WAAYqE,EAAel3H,IAAQoiH,MAAM+U,IAEjFv3H,EAAYI,GAAQm3H,EACbv3H,EAAYI,OAMrB,OAAKozH,EAAQx4H,OAAS,EAEd,MAIRw4H,EAAQ15H,KAAMO,KAAK0zH,OAAO+I,eAAgB1E,IAEnClR,QAAQl/G,IAAKwxH,GAAUhR,MAAM0G,IAEnC,MAAMsO,EAAatO,EAAQ9xC,MACrB4/C,EAASQ,EAAWv+B,QAAUu+B,EAAW9vG,SAAW,CAAE8vG,GACtDl4H,EAAQ4pH,EAAS,GAAI5pH,MACrBm4H,EAAkB,GAExB,IAAM,MAAMzhF,KAAQghF,EAAS,CAG5B,MAAMluH,EAAI,IAAIglB,GACRiF,EAAI,IAAI,GACRjnB,EAAI,IAAIkS,GACRzS,EAAI,IAAI,GAAS,EAAG,EAAG,GAEvB8zD,EAAgB,IAAIq0C,GAAe19D,EAAKxuB,SAAUwuB,EAAK1b,SAAUh7B,GAEvE,IAAM,IAAI3E,EAAI,EAAGA,EAAI2E,EAAO3E,IAEtBqF,EAAW03H,aAEf3kG,EAAE7iB,oBAAqBlQ,EAAW03H,YAAa/8H,GAI3CqF,EAAW23H,UAEf7rH,EAAEoE,oBAAqBlQ,EAAW23H,SAAUh9H,GAIxCqF,EAAW43H,OAEfrsH,EAAE2E,oBAAqBlQ,EAAW43H,MAAOj9H,GAI1C0kE,EAAcs0C,YAAah5G,EAAGmO,EAAE6mB,QAASoD,EAAGjnB,EAAGP,IAKhD,IAAM,MAAMssH,KAAiB73H,EAEL,gBAAlB63H,GACe,aAAlBA,GACkB,UAAlBA,GAED7hF,EAAKxuB,SAASlwB,aAAcugI,EAAe73H,EAAY63H,IAOzD5iG,GAASv4B,UAAU+Q,KAAKxR,KAAMojE,EAAerpB,GAE7C37C,KAAK0zH,OAAO+J,oBAAqBz4D,GAEjCo4D,EAAgB39H,KAAMulE,EAEvB,CAEA,OAAKm4D,EAAWv+B,SAEfu+B,EAAW9/F,QAEX8/F,EAAWngI,OAASogI,GAEbD,GAIDC,EAAiB,EAAG,IAI7B,EAKD,MAAMhI,GAAgC,OAItC,MAAMG,GAELhzH,YAAac,GAEZrD,KAAKwC,KAAO6yH,GAAWC,gBACvBt1H,KAAKG,QAAU,KACfH,KAAKhE,KAAO,KAEZ,MAAM0hI,EAAa,IAAIthB,SAAU/4G,EAAM,EAXF,IAY/B8xH,EAAc,IAAIvL,YAQxB,GANA5pH,KAAK29H,OAAS,CACbC,MAAOzI,EAAYtL,OAAQ,IAAIv6G,WAAYjM,EAAKf,MAAO,EAAG,KAC1Dub,QAAS6/G,EAAWG,UAAW,GAAG,GAClCl9H,OAAQ+8H,EAAWG,UAAW,GAAG,IAG7B79H,KAAK29H,OAAOC,QAAUxI,GAE1B,MAAM,IAAInvH,MAAO,qDAEX,GAAKjG,KAAK29H,OAAO9/G,QAAU,EAEjC,MAAM,IAAI5X,MAAO,kDAIlB,MAAM63H,EAAsB99H,KAAK29H,OAAOh9H,OA9BH,GA+B/Bo9H,EAAY,IAAI3hB,SAAU/4G,EA/BK,IAgCrC,IAAI26H,EAAa,EAEjB,KAAQA,EAAaF,GAAsB,CAE1C,MAAMG,EAAcF,EAAUF,UAAWG,GAAY,GACrDA,GAAc,EAEd,MAAME,EAAYH,EAAUF,UAAWG,GAAY,GAGnD,GAFAA,GAAc,EAvC4B,aAyCrCE,EAAkD,CAEtD,MAAMC,EAAe,IAAI7uH,WAAYjM,EA5CF,GA4CyC26H,EAAYC,GACxFj+H,KAAKG,QAAUg1H,EAAYtL,OAAQsU,EAEpC,MAAO,GA9CoD,UA8C/CD,EAAiD,CAE5D,MAAM9B,EAjD6B,GAiDiB4B,EACpDh+H,KAAKhE,KAAOqH,EAAKf,MAAO85H,EAAYA,EAAa6B,EAElD,CAIAD,GAAcC,CAEf,CAEA,GAAsB,OAAjBj+H,KAAKG,QAET,MAAM,IAAI8F,MAAO,4CAInB,EASD,MAAMiwH,GAEL3zH,YAAaq2G,EAAMya,GAElB,IAAOA,EAEN,MAAM,IAAIptH,MAAO,uDAIlBjG,KAAKwC,KAAO6yH,GAAWY,2BACvBj2H,KAAK44G,KAAOA,EACZ54G,KAAKqzH,YAAcA,EACnBrzH,KAAKqzH,YAAY+K,SAElB,CAEAC,gBAAiBzB,EAAWlJ,GAE3B,MAAM9a,EAAO54G,KAAK44G,KACZya,EAAcrzH,KAAKqzH,YACnBiL,EAAkB1B,EAAU/kF,WAAY73C,KAAKwC,MAAOw5H,WACpDuC,EAAmB3B,EAAU/kF,WAAY73C,KAAKwC,MAAOmD,WACrD64H,EAAoB,CAAC,EACrBC,EAAyB,CAAC,EAC1BC,EAAmB,CAAC,EAE1B,IAAM,MAAMlB,KAAiBe,EAAmB,CAE/C,MAAMI,EAAqBC,GAAYpB,IAAmBA,EAAcnvH,cAExEmwH,EAAmBG,GAAuBJ,EAAkBf,EAE7D,CAEA,IAAM,MAAMA,KAAiBZ,EAAUj3H,WAAa,CAEnD,MAAMg5H,EAAqBC,GAAYpB,IAAmBA,EAAcnvH,cAExE,QAA2ClR,IAAtCohI,EAAkBf,GAAgC,CAEtD,MAAMqB,EAAcjmB,EAAKkmB,UAAWlC,EAAUj3H,WAAY63H,IACpDuB,EAAgBC,GAAuBH,EAAYE,eAEzDL,EAAkBC,GAAuBI,EAAcv8H,KACvDi8H,EAAwBE,IAAkD,IAA3BE,EAAYzxF,UAE5D,CAED,CAEA,OAAOsmF,EAAOkF,cAAe,aAAc0F,GAAkBnW,MAAM,SAAW6T,GAE7E,OAAO,IAAInV,SAAS,SAAWC,GAE9BuM,EAAY4L,gBAAiBjD,GAAY,SAAW7uG,GAEnD,IAAM,MAAMqwG,KAAiBrwG,EAASxnB,WAAa,CAElD,MAAMmQ,EAAYqX,EAASxnB,WAAY63H,GACjCpwF,EAAaqxF,EAAwBjB,QAEvBrgI,IAAfiwC,IAA2Bt3B,EAAUs3B,WAAaA,EAExD,CAEA05E,EAAS35F,EAEV,GAAGqxG,EAAmBE,EAEvB,GAED,GAED,EASD,MAAMtI,GAEL7zH,cAECvC,KAAKwC,KAAO6yH,GAAWc,qBAExB,CAEA+I,cAAen8G,EAAS89E,GAEvB,YAA8B1jG,IAAvB0jG,EAAUs+B,UAA0Bt+B,EAAUs+B,WAAap8G,EAAQxD,cACjDpiB,IAArB0jG,EAAUlrF,aACaxY,IAAvB0jG,EAAU5mF,eACU9c,IAApB0jG,EAAUzmF,OAOd2I,EAAUA,EAAQ5P,aAEUhW,IAAvB0jG,EAAUs+B,WAEdp8G,EAAQxD,QAAUshF,EAAUs+B,eAIHhiI,IAArB0jG,EAAUlrF,QAEdoN,EAAQpN,OAAOD,UAAWmrF,EAAUlrF,aAITxY,IAAvB0jG,EAAU5mF,WAEd8I,EAAQ9I,SAAW4mF,EAAU5mF,eAIL9c,IAApB0jG,EAAUzmF,OAEd2I,EAAQtD,OAAO/J,UAAWmrF,EAAUzmF,OAIrC2I,EAAQjF,aAAc,EAEfiF,GAhCCA,CAkCT,EASD,MAAMuzG,GAEL/zH,cAECvC,KAAKwC,KAAO6yH,GAAWgB,qBAExB,EAUD,MAAM+I,WAAmCviB,GAExCt6G,YAAau6G,EAAoBC,EAAcC,EAAYC,GAE1D79F,MAAO09F,EAAoBC,EAAcC,EAAYC,EAEtD,CAEAY,iBAAkB9/G,GAKjB,MAAM6G,EAAS5E,KAAKi9G,aACnB38E,EAAStgC,KAAK+8G,aACdI,EAAYn9G,KAAKm9G,UACjBxnG,EAAS5X,EAAQo/G,EAAY,EAAIA,EAElC,IAAM,IAAI78G,EAAI,EAAGA,IAAM68G,EAAW78G,IAEjCsE,EAAQtE,GAAMggC,EAAQ3qB,EAASrV,GAIhC,OAAOsE,CAER,CAEAq5G,aAAc57E,EAAInQ,EAAIvjB,EAAGwjB,GAExB,MAAMvtB,EAAS5E,KAAKi9G,aACd38E,EAAStgC,KAAK+8G,aACdtqE,EAASzyC,KAAKm9G,UAEdkiB,EAAmB,EAAT5sF,EACV6sF,EAAmB,EAAT7sF,EAEV8sF,EAAKptG,EAAKD,EAEVwG,GAAM/pB,EAAIujB,GAAOqtG,EACjBhiB,EAAK7kF,EAAIA,EACT2mF,EAAM9B,EAAK7kF,EAEX+mF,EAAUp9E,EAAKi9F,EACf5f,EAAUD,EAAU6f,EAEpBttH,GAAO,EAAIqtG,EAAM,EAAI9B,EACrB33F,EAAKy5F,EAAM9B,EACX7rF,EAAK,EAAI1f,EACT2T,EAAKC,EAAK23F,EAAK7kF,EAIrB,IAAM,IAAIp4B,EAAI,EAAGA,IAAMmyC,EAAQnyC,IAAO,CAErC,MAAM+uB,EAAKiR,EAAQo/E,EAAUp/G,EAAImyC,GAC3B+sF,EAAKl/F,EAAQo/E,EAAUp/G,EAAI++H,GAAYE,EACvCjwG,EAAKgR,EAAQm/E,EAAUn/G,EAAImyC,GAC3BgtF,EAAKn/F,EAAQm/E,EAAUn/G,GAAMi/H,EAEnC36H,EAAQtE,GAAMoxB,EAAKrC,EAAK1J,EAAK65G,EAAKxtH,EAAKsd,EAAK1J,EAAK65G,CAElD,CAEA,OAAO76H,CAER,EAID,MAAM86H,GAAK,IAAI/7G,GAEf,MAAMg8G,WAA6CP,GAElDnhB,aAAc57E,EAAInQ,EAAIvjB,EAAGwjB,GAExB,MAAMvtB,EAASwa,MAAM6+F,aAAc57E,EAAInQ,EAAIvjB,EAAGwjB,GAI9C,OAFAutG,GAAGhqH,UAAW9Q,GAAS8K,YAAYkG,QAAShR,GAErCA,CAER,EAWD,MAAMk4H,GAAkB,CACvBr8E,MAAO,KAEP+1B,WAAY,MACZC,WAAY,MACZmpD,WAAY,MACZC,WAAY,MACZC,WAAY,MACZltC,OAAQ,KACR2B,OAAQ,MACRwrC,WAAY,MACZh9D,OAAQ,EACRH,MAAO,EACPE,UAAW,EACXD,WAAY,EACZF,UAAW,EACXo6D,eAAgB,EAChBC,aAAc,EACd/7E,cAAe,KACfL,eAAgB,MAGXo+E,GAAwB,CAC7B,KAAMvvH,UACN,KAAMH,WACN,KAAME,WACN,KAAMH,YACN,KAAMD,YACN,KAAMD,cAGD6wH,GAAgB,CACrB,KAAMt1H,EACN,KAAMG,EACN,KAAMF,EACN,KAAMG,EACN,KAAMF,EACN,KAAMG,GAGDk1H,GAAkB,CACvB,MAAOz1H,EACP,MAAOC,EACP,MAAOF,GAGF21H,GAAmB,CACxB,OAAU,EACV,KAAQ,EACR,KAAQ,EACR,KAAQ,EACR,KAAQ,EACR,KAAQ,EACR,KAAQ,IAGHtB,GAAa,CAClBuB,SAAU,WACVC,OAAQ,SACRC,QAAS,UACTC,WAAY,KACZC,WAAY,MACZC,WAAY,MACZC,WAAY,MACZC,QAAS,QACTC,UAAW,aACXC,SAAU,aAGLC,GAAkB,CACvBzmH,MAAO,QACP0mH,YAAa,WACb7mH,SAAU,aACVilD,QAAS,yBAGJ6hE,GAAgB,CACrBC,iBAAa7jI,EAEby1F,OAAQ7mF,EACRk1H,KAAMn1H,GAgCP,SAASo1H,GAAgCC,EAAiBh1G,EAAQi1G,GAIjE,IAAM,MAAM5+H,KAAQ4+H,EAAUvpF,gBAEI16C,IAA5BgkI,EAAiB3+H,KAErB2pB,EAAOpM,SAASshH,eAAiBl1G,EAAOpM,SAASshH,gBAAkB,CAAC,EACpEl1G,EAAOpM,SAASshH,eAAgB7+H,GAAS4+H,EAAUvpF,WAAYr1C,GAMlE,CAMA,SAASk2H,GAAwBvsG,EAAQm1G,QAEhBnkI,IAAnBmkI,EAAQC,SAEmB,iBAAnBD,EAAQC,OAEnBn/H,OAAOihB,OAAQ8I,EAAOpM,SAAUuhH,EAAQC,QAIxCjjI,QAAQkU,KAAM,sDAAwD8uH,EAAQC,QAMjF,CA+FA,SAASttF,GAAoB0H,EAAM+gF,GAIlC,GAFA/gF,EAAK1H,0BAEoB92C,IAApBu/H,EAAQx9D,QAEZ,IAAM,IAAI5+D,EAAI,EAAGmrB,EAAKixG,EAAQx9D,QAAQv+D,OAAQL,EAAImrB,EAAInrB,IAErDq7C,EAAKzH,sBAAuB5zC,GAAMo8H,EAAQx9D,QAAS5+D,GAOrD,GAAKo8H,EAAQ6E,QAAUtgI,MAAME,QAASu7H,EAAQ6E,OAAOC,aAAgB,CAEpE,MAAMA,EAAc9E,EAAQ6E,OAAOC,YAEnC,GAAK7lF,EAAKzH,sBAAsBvzC,SAAW6gI,EAAY7gI,OAAS,CAE/Dg7C,EAAKxH,sBAAwB,CAAC,EAE9B,IAAM,IAAI7zC,EAAI,EAAGmrB,EAAK+1G,EAAY7gI,OAAQL,EAAImrB,EAAInrB,IAEjDq7C,EAAKxH,sBAAuBqtF,EAAalhI,IAAQA,CAInD,MAEChC,QAAQkU,KAAM,uEAIhB,CAED,CAEA,SAASivH,GAAoBC,GAE5B,IAAIC,EAEJ,MAAMC,EAAiBF,EAAa7pF,YAAc6pF,EAAa7pF,WAAYw9E,GAAWY,4BActF,GAVC0L,EAFIC,EAEU,SAAWA,EAAe5F,WACpC,IAAM4F,EAAezxF,QACrB,IAAM0xF,GAAqBD,EAAej8H,YAIhC+7H,EAAavxF,QAAU,IAAM0xF,GAAqBH,EAAa/7H,YAAe,IAAM+7H,EAAa9qE,UAIlFz5D,IAAzBukI,EAAaI,QAEjB,IAAM,IAAIxhI,EAAI,EAAGmrB,EAAKi2G,EAAaI,QAAQnhI,OAAQL,EAAImrB,EAAInrB,IAE1DqhI,GAAe,IAAME,GAAqBH,EAAaI,QAASxhI,IAMlE,OAAOqhI,CAER,CAEA,SAASE,GAAqBl8H,GAE7B,IAAIo8H,EAAgB,GAEpB,MAAMl8H,EAAOzD,OAAOyD,KAAMF,GAAag/D,OAEvC,IAAM,IAAIrkE,EAAI,EAAGmrB,EAAK5lB,EAAKlF,OAAQL,EAAImrB,EAAInrB,IAE1CyhI,GAAiBl8H,EAAMvF,GAAM,IAAMqF,EAAYE,EAAMvF,IAAQ,IAI9D,OAAOyhI,CAER,CAEA,SAASC,GAA6Bz/H,GAKrC,OAASA,GAER,KAAKkN,UACJ,OAAO,EAAI,IAEZ,KAAKH,WACJ,OAAO,EAAI,IAEZ,KAAKE,WACJ,OAAO,EAAI,MAEZ,KAAKH,YACJ,OAAO,EAAI,MAEZ,QACC,MAAM,IAAIpJ,MAAO,qEAIpB,CAWA,MAAM,GAAkB,IAAIwtB,GAI5B,MAAMgiG,GAELlzH,YAAaq2G,EAAO,CAAC,EAAGh1G,EAAU,CAAC,GAElC5D,KAAK44G,KAAOA,EACZ54G,KAAK63C,WAAa,CAAC,EACnB73C,KAAKk1H,QAAU,CAAC,EAChBl1H,KAAK4D,QAAUA,EAGf5D,KAAKqgC,MAAQ,IAAIq2F,GAGjB12H,KAAKiiI,aAAe,IAAIjzD,IAGxBhvE,KAAKkiI,eAAiB,CAAC,EAGvBliI,KAAKmiI,UAAY,CAAC,EAGlBniI,KAAKoiI,UAAY,CAAEzK,KAAM,CAAC,EAAGC,KAAM,CAAC,GACpC53H,KAAKqiI,YAAc,CAAE1K,KAAM,CAAC,EAAGC,KAAM,CAAC,GACtC53H,KAAKsiI,WAAa,CAAE3K,KAAM,CAAC,EAAGC,KAAM,CAAC,GAErC53H,KAAKuiI,YAAc,CAAC,EACpBviI,KAAKwiI,aAAe,CAAC,EAGrBxiI,KAAKyiI,cAAgB,CAAC,EAKtB,IAAIC,GAAW,EACXC,GAAY,EACZC,GAAmB,EAEG,oBAAdxyC,YAEXsyC,GAA4E,IAAjE,iCAAiChgI,KAAM0tF,UAAUC,WAC5DsyC,EAAYvyC,UAAUC,UAAUljF,QAAS,YAAgB,EACzDy1H,EAAiBD,EAAYvyC,UAAUC,UAAU5kB,MAAO,uBAAyB,IAAQ,GAIxD,oBAAtB6gD,mBAAqCoW,GAAcC,GAAaC,EAAiB,GAE5F5iI,KAAKw7H,cAAgB,IAAIlR,GAAetqH,KAAK4D,QAAQ0iH,SAIrDtmH,KAAKw7H,cAAgB,IAAIpP,GAAmBpsH,KAAK4D,QAAQ0iH,SAI1DtmH,KAAKw7H,cAAcxU,eAAgBhnH,KAAK4D,QAAQ2iH,aAChDvmH,KAAKw7H,cAAcpU,iBAAkBpnH,KAAK4D,QAAQ8iH,eAElD1mH,KAAK01H,WAAa,IAAIjO,GAAYznH,KAAK4D,QAAQ0iH,SAC/CtmH,KAAK01H,WAAW1L,gBAAiB,eAEC,oBAA7BhqH,KAAK4D,QAAQ2iH,aAEjBvmH,KAAK01H,WAAWzO,oBAAoB,EAItC,CAEAsP,cAAe1+E,GAEd73C,KAAK63C,WAAaA,CAEnB,CAEA2+E,WAAYtB,GAEXl1H,KAAKk1H,QAAUA,CAEhB,CAEA90G,MAAO4kG,EAAQE,GAEd,MAAMwO,EAAS1zH,KACT44G,EAAO54G,KAAK44G,KACZ/gE,EAAa73C,KAAK63C,WAGxB73C,KAAKqgC,MAAMs2F,YACX32H,KAAKmiI,UAAY,CAAC,EAGlBniI,KAAK6iI,YAAY,SAAWC,GAE3B,OAAOA,EAAIjL,WAAaiL,EAAIjL,WAE7B,IAEAhR,QAAQl/G,IAAK3H,KAAK6iI,YAAY,SAAWC,GAExC,OAAOA,EAAIC,YAAcD,EAAIC,YAE9B,KAAM5a,MAAM,WAEX,OAAOtB,QAAQl/G,IAAK,CAEnB+rH,EAAOsP,gBAAiB,SACxBtP,EAAOsP,gBAAiB,aACxBtP,EAAOsP,gBAAiB,WAI1B,IAAI7a,MAAM,SAAW8a,GAEpB,MAAMr+H,EAAS,CACdg2C,MAAOqoF,EAAc,GAAKrqB,EAAKh+D,OAAS,GACxCsoF,OAAQD,EAAc,GACtBpnG,WAAYonG,EAAc,GAC1BtoF,QAASsoF,EAAc,GACvBzN,MAAO5c,EAAK4c,MACZ9B,OAAQA,EACR3zG,SAAU,CAAC,GAGZmhH,GAAgCrpF,EAAYjzC,EAAQg0G,GAEpD8f,GAAwB9zH,EAAQg0G,GAEhCiO,QAAQl/G,IAAK+rH,EAAOmP,YAAY,SAAWC,GAE1C,OAAOA,EAAIK,WAAaL,EAAIK,UAAWv+H,EAExC,KAAMujH,MAAM,WAEXnD,EAAQpgH,EAET,GAED,IAAIklH,MAAO5E,EAEZ,CAKA2S,YAEC,MAAMC,EAAW93H,KAAK44G,KAAK/5E,OAAS,GAC9BukG,EAAWpjI,KAAK44G,KAAKyqB,OAAS,GAC9BC,EAAWtjI,KAAK44G,KAAK+jB,QAAU,GAIrC,IAAM,IAAI/kB,EAAY,EAAG2rB,EAAaH,EAASziI,OAAQi3G,EAAY2rB,EAAY3rB,IAAe,CAE7F,MAAMzY,EAASikC,EAAUxrB,GAAYzY,OAErC,IAAM,IAAI7+F,EAAI,EAAGmrB,EAAK0zE,EAAOx+F,OAAQL,EAAImrB,EAAInrB,IAE5Cw3H,EAAU34B,EAAQ7+F,IAAM43G,QAAS,CAInC,CAIA,IAAM,IAAI6f,EAAY,EAAGC,EAAaF,EAASn3H,OAAQo3H,EAAYC,EAAYD,IAAe,CAE7F,MAAME,EAAUH,EAAUC,QAEJ56H,IAAjB86H,EAAQt8E,OAEZ37C,KAAKk4H,YAAal4H,KAAKoiI,UAAWnK,EAAQt8E,WAKpBx+C,IAAjB86H,EAAQuL,OAEZF,EAAUrL,EAAQt8E,MAAO9b,eAAgB,SAMnB1iC,IAAnB86H,EAAQ/uG,QAEZlpB,KAAKk4H,YAAal4H,KAAKqiI,YAAapK,EAAQ/uG,OAI9C,CAED,CAWAgvG,YAAa73F,EAAOtiC,QAEJZ,IAAVY,SAEwBZ,IAAxBkjC,EAAMs3F,KAAM55H,KAEhBsiC,EAAMs3F,KAAM55H,GAAUsiC,EAAMu3F,KAAM75H,GAAU,GAI7CsiC,EAAMs3F,KAAM55H,KAEb,CAGA+6H,YAAaz4F,EAAOtiC,EAAOouB,GAE1B,GAAKkU,EAAMs3F,KAAM55H,IAAW,EAAI,OAAOouB,EAEvC,MAAMs3G,EAAMt3G,EAAOhZ,QAIbuwH,EAAiB,CAAEC,EAAUxwH,KAElC,MAAMywH,EAAW5jI,KAAKiiI,aAAap5H,IAAK86H,GACvB,MAAZC,GAEJ5jI,KAAKiiI,aAAa1vH,IAAKY,EAAOywH,GAI/B,IAAM,MAAQtjI,EAAGg+B,KAAWqlG,EAASt2G,SAASw2G,UAE7CH,EAAgBplG,EAAOnrB,EAAMka,SAAU/sB,GAExC,EAQD,OAJAojI,EAAgBv3G,EAAQs3G,GAExBA,EAAIjhI,MAAQ,aAAiB69B,EAAMu3F,KAAM75H,KAElC0lI,CAER,CAEAK,WAAYC,GAEX,MAAMlsF,EAAaz1C,OAAOk+B,OAAQtgC,KAAKk1H,SACvCr9E,EAAWp4C,KAAMO,MAEjB,IAAM,IAAIM,EAAI,EAAGA,EAAIu3C,EAAWl3C,OAAQL,IAAO,CAE9C,MAAMsE,EAASm/H,EAAMlsF,EAAYv3C,IAEjC,GAAKsE,EAAS,OAAOA,CAEtB,CAEA,OAAO,IAER,CAEAi+H,WAAYkB,GAEX,MAAMlsF,EAAaz1C,OAAOk+B,OAAQtgC,KAAKk1H,SACvCr9E,EAAW0a,QAASvyD,MAEpB,MAAMm5H,EAAU,GAEhB,IAAM,IAAI74H,EAAI,EAAGA,EAAIu3C,EAAWl3C,OAAQL,IAAO,CAE9C,MAAMsE,EAASm/H,EAAMlsF,EAAYv3C,IAE5BsE,GAASu0H,EAAQ15H,KAAMmF,EAE7B,CAEA,OAAOu0H,CAER,CAQAP,cAAe7rH,EAAMhP,GAEpB,MAAM2xE,EAAW3iE,EAAO,IAAMhP,EAC9B,IAAIs6H,EAAar4H,KAAKqgC,MAAMx3B,IAAK6mE,GAEjC,IAAO2oD,EAAa,CAEnB,OAAStrH,GAER,IAAK,QACJsrH,EAAar4H,KAAKgkI,UAAWjmI,GAC7B,MAED,IAAK,OACJs6H,EAAar4H,KAAK8jI,YAAY,SAAWhB,GAExC,OAAOA,EAAImB,UAAYnB,EAAImB,SAAUlmI,EAEtC,IACA,MAED,IAAK,OACJs6H,EAAar4H,KAAK8jI,YAAY,SAAWhB,GAExC,OAAOA,EAAIoB,UAAYpB,EAAIoB,SAAUnmI,EAEtC,IACA,MAED,IAAK,WACJs6H,EAAar4H,KAAKmkI,aAAcpmI,GAChC,MAED,IAAK,aACJs6H,EAAar4H,KAAK8jI,YAAY,SAAWhB,GAExC,OAAOA,EAAI/G,gBAAkB+G,EAAI/G,eAAgBh+H,EAElD,IACA,MAED,IAAK,SACJs6H,EAAar4H,KAAKokI,WAAYrmI,GAC9B,MAED,IAAK,WACJs6H,EAAar4H,KAAK8jI,YAAY,SAAWhB,GAExC,OAAOA,EAAIuB,cAAgBvB,EAAIuB,aAActmI,EAE9C,IACA,MAED,IAAK,UACJs6H,EAAar4H,KAAK8jI,YAAY,SAAWhB,GAExC,OAAOA,EAAI3H,aAAe2H,EAAI3H,YAAap9H,EAE5C,IACA,MAED,IAAK,OACJs6H,EAAar4H,KAAKskI,SAAUvmI,GAC5B,MAED,IAAK,YACJs6H,EAAar4H,KAAK8jI,YAAY,SAAWhB,GAExC,OAAOA,EAAIyB,eAAiBzB,EAAIyB,cAAexmI,EAEhD,IACA,MAED,IAAK,SACJs6H,EAAar4H,KAAKwkI,WAAYzmI,GAC9B,MAED,QAOC,GANAs6H,EAAar4H,KAAK8jI,YAAY,SAAWhB,GAExC,OAAOA,GAAO9iI,MAAQ8iI,EAAIlK,eAAiBkK,EAAIlK,cAAe7rH,EAAMhP,EAErE,KAEOs6H,EAEN,MAAM,IAAIpyH,MAAO,iBAAmB8G,GAQvC/M,KAAKqgC,MAAMrjC,IAAK0yE,EAAU2oD,EAE3B,CAEA,OAAOA,CAER,CAOA2K,gBAAiBj2H,GAEhB,IAAIk2H,EAAejjI,KAAKqgC,MAAMx3B,IAAKkE,GAEnC,IAAOk2H,EAAe,CAErB,MAAMvP,EAAS1zH,KACTykI,EAAOzkI,KAAK44G,KAAM7rG,GAAkB,SAATA,EAAkB,KAAO,OAAW,GAErEk2H,EAAepc,QAAQl/G,IAAK88H,EAAKxkI,KAAK,SAAWykI,EAAK3mI,GAErD,OAAO21H,EAAOkF,cAAe7rH,EAAMhP,EAEpC,KAEAiC,KAAKqgC,MAAMrjC,IAAK+P,EAAMk2H,EAEvB,CAEA,OAAOA,CAER,CAOAmB,WAAYO,GAEX,MAAMC,EAAY5kI,KAAK44G,KAAK/4D,QAAS8kF,GAC/B3e,EAAShmH,KAAK01H,WAEpB,GAAKkP,EAAU73H,MAA2B,gBAAnB63H,EAAU73H,KAEhC,MAAM,IAAI9G,MAAO,qBAAuB2+H,EAAU73H,KAAO,kCAK1D,QAAuB5P,IAAlBynI,EAAUnJ,KAAqC,IAAhBkJ,EAEnC,OAAO9d,QAAQC,QAAS9mH,KAAK63C,WAAYw9E,GAAWC,iBAAkBt5H,MAIvE,MAAM4H,EAAU5D,KAAK4D,QAErB,OAAO,IAAIijH,SAAS,SAAWC,EAASC,GAEvCf,EAAOW,KAAMoF,GAAYnG,WAAYgf,EAAUnJ,IAAK73H,EAAQ0nE,MAAQw7C,OAAS3pH,GAAW,WAEvF4pH,EAAQ,IAAI9gH,MAAO,4CAA8C2+H,EAAUnJ,IAAM,MAElF,GAED,GAED,CAOAM,eAAgBuC,GAEf,MAAMuG,EAAgB7kI,KAAK44G,KAAKqjB,YAAaqC,GAE7C,OAAOt+H,KAAK44H,cAAe,SAAUiM,EAAc7kF,QAASmoE,MAAM,SAAWnoE,GAE5E,MAAMgpE,EAAa6b,EAAc7b,YAAc,EACzCoT,EAAayI,EAAczI,YAAc,EAC/C,OAAOp8E,EAAO19C,MAAO85H,EAAYA,EAAapT,EAE/C,GAED,CAOAmb,aAAcW,GAEb,MAAMpR,EAAS1zH,KACT44G,EAAO54G,KAAK44G,KAEZimB,EAAc7+H,KAAK44G,KAAKkmB,UAAWgG,GAEzC,QAAgC3nI,IAA3B0hI,EAAY7C,iBAAmD7+H,IAAvB0hI,EAAYkG,OAAuB,CAE/E,MAAM53F,EAAW+yF,GAAkBrB,EAAY9xH,MACzCi4H,EAAahG,GAAuBH,EAAYE,eAChD3xF,GAAwC,IAA3ByxF,EAAYzxF,WAEzB3/B,EAAQ,IAAIu3H,EAAYnG,EAAY55H,MAAQkoC,GAClD,OAAO05E,QAAQC,QAAS,IAAI,GAAiBr5G,EAAO0/B,EAAUC,GAE/D,CAEA,MAAM63F,EAAqB,GAmB3B,YAjBgC9nI,IAA3B0hI,EAAY7C,WAEhBiJ,EAAmBxlI,KAAMO,KAAK44H,cAAe,aAAciG,EAAY7C,aAIvEiJ,EAAmBxlI,KAAM,WAIEtC,IAAvB0hI,EAAYkG,SAEhBE,EAAmBxlI,KAAMO,KAAK44H,cAAe,aAAciG,EAAYkG,OAAO50F,QAAQ6rF,aACtFiJ,EAAmBxlI,KAAMO,KAAK44H,cAAe,aAAciG,EAAYkG,OAAOzkG,OAAO07F,cAI/EnV,QAAQl/G,IAAKs9H,GAAqB9c,MAAM,SAAW8T,GAEzD,MAAMD,EAAaC,EAAa,GAE1B9uF,EAAW+yF,GAAkBrB,EAAY9xH,MACzCi4H,EAAahG,GAAuBH,EAAYE,eAGhDmG,EAAeF,EAAW9jF,kBAC1BikF,EAAYD,EAAe/3F,EAC3BivF,EAAayC,EAAYzC,YAAc,EACvCC,OAAwCl/H,IAA3B0hI,EAAY7C,WAA2BpjB,EAAKqjB,YAAa4C,EAAY7C,YAAaK,gBAAal/H,EAC5GiwC,GAAwC,IAA3ByxF,EAAYzxF,WAC/B,IAAI3/B,EAAO23H,EAGX,GAAK/I,GAAcA,IAAe8I,EAAY,CAI7C,MAAME,EAAUrnI,KAAKK,MAAO+9H,EAAaC,GACnCiJ,EAAa,qBAAuBzG,EAAY7C,WAAa,IAAM6C,EAAYE,cAAgB,IAAMsG,EAAU,IAAMxG,EAAY55H,MACvI,IAAIyxG,EAAKgd,EAAOrzF,MAAMx3B,IAAKy8H,GAEpB5uB,IAENjpG,EAAQ,IAAIu3H,EAAYhJ,EAAYqJ,EAAUhJ,EAAYwC,EAAY55H,MAAQo3H,EAAa6I,GAG3FxuB,EAAK,IAAI,GAAmBjpG,EAAO4uH,EAAa6I,GAEhDxR,EAAOrzF,MAAMrjC,IAAKsoI,EAAY5uB,IAI/B0uB,EAAkB,IAAI,GAA4B1uB,EAAIvpE,EAAYivF,EAAaC,EAAe6I,EAAc93F,EAE7G,MAIE3/B,EAFmB,OAAfuuH,EAEI,IAAIgJ,EAAYnG,EAAY55H,MAAQkoC,GAIpC,IAAI63F,EAAYhJ,EAAYI,EAAYyC,EAAY55H,MAAQkoC,GAIrEi4F,EAAkB,IAAI,GAAiB33H,EAAO0/B,EAAUC,GAKzD,QAA4BjwC,IAAvB0hI,EAAYkG,OAAuB,CAEvC,MAAMQ,EAAkBrF,GAAiBsF,OACnCC,EAAoBzG,GAAuBH,EAAYkG,OAAO50F,QAAQ4uF,eAEtE2G,EAAoB7G,EAAYkG,OAAO50F,QAAQisF,YAAc,EAC7DuJ,EAAmB9G,EAAYkG,OAAOzkG,OAAO87F,YAAc,EAE3DwJ,EAAgB,IAAIH,EAAmBxJ,EAAa,GAAKyJ,EAAmB7G,EAAYkG,OAAO9/H,MAAQsgI,GACvGM,EAAe,IAAIb,EAAY/I,EAAa,GAAK0J,EAAkB9G,EAAYkG,OAAO9/H,MAAQkoC,GAEhF,OAAf6uF,IAGJoJ,EAAkB,IAAI,GAAiBA,EAAgB33H,MAAMnL,QAAS8iI,EAAgBj4F,SAAUi4F,EAAgBh4F,aAIjH,IAAM,IAAI9sC,EAAI,EAAGmrB,EAAKm6G,EAAcjlI,OAAQL,EAAImrB,EAAInrB,IAAO,CAE1D,MAAMvC,EAAQ6nI,EAAetlI,GAM7B,GAJA8kI,EAAgBryH,KAAMhV,EAAO8nI,EAAcvlI,EAAI6sC,IAC1CA,GAAY,GAAIi4F,EAAgBpyH,KAAMjV,EAAO8nI,EAAcvlI,EAAI6sC,EAAW,IAC1EA,GAAY,GAAIi4F,EAAgBnkH,KAAMljB,EAAO8nI,EAAcvlI,EAAI6sC,EAAW,IAC1EA,GAAY,GAAIi4F,EAAgBlkH,KAAMnjB,EAAO8nI,EAAcvlI,EAAI6sC,EAAW,IAC1EA,GAAY,EAAI,MAAM,IAAIlnC,MAAO,oEAEvC,CAED,CAEA,OAAOm/H,CAER,GAED,CAOAjK,YAAaC,GAEZ,MAAMxiB,EAAO54G,KAAK44G,KACZh1G,EAAU5D,KAAK4D,QAEfkiI,EADaltB,EAAKv4F,SAAU+6G,GACH33H,OACzBsiI,EAAYntB,EAAK16F,OAAQ4nH,GAE/B,IAAI9f,EAAShmH,KAAKw7H,cAElB,GAAKuK,EAAUtK,IAAM,CAEpB,MAAMC,EAAU93H,EAAQ0iH,QAAQJ,WAAY6f,EAAUtK,KACrC,OAAZC,IAAmB1V,EAAS0V,EAElC,CAEA,OAAO17H,KAAKs7H,iBAAkBF,EAAc0K,EAAa9f,EAE1D,CAEAsV,iBAAkBF,EAAc0K,EAAa9f,GAE5C,MAAM0N,EAAS1zH,KACT44G,EAAO54G,KAAK44G,KAEZyiB,EAAaziB,EAAKv4F,SAAU+6G,GAC5B2K,EAAYntB,EAAK16F,OAAQ4nH,GAEzBp2D,GAAaq2D,EAAUtK,KAAOsK,EAAU/J,YAAe,IAAMX,EAAW2K,QAE9E,GAAKhmI,KAAKwiI,aAAc9yD,GAGvB,OAAO1vE,KAAKwiI,aAAc9yD,GAI3B,MAAMu2D,EAAUjmI,KAAKkmI,gBAAiBJ,EAAa9f,GAASmC,MAAM,SAAWplG,GAE5EA,EAAQlD,OAAQ,EAEhBkD,EAAQvgB,KAAO64H,EAAW74H,MAAQujI,EAAUvjI,MAAQ,GAE9B,KAAjBugB,EAAQvgB,MAAwC,iBAAlBujI,EAAUtK,MAAkE,IAA9CsK,EAAUtK,IAAI0K,WAAY,iBAE1FpjH,EAAQvgB,KAAOujI,EAAUtK,KAI1B,MACMuK,GADWptB,EAAKwtB,UAAY,CAAC,GACT/K,EAAW2K,UAAa,CAAC,EASnD,OAPAjjH,EAAQjE,UAAYkhH,GAAegG,EAAQlnH,YAAejU,EAC1DkY,EAAQhE,UAAYihH,GAAegG,EAAQjnH,YAAehU,EAC1DgY,EAAQnE,MAAQqhH,GAAiB+F,EAAQpnH,QAAWrU,EACpDwY,EAAQlE,MAAQohH,GAAiB+F,EAAQnnH,QAAWtU,EAEpDmpH,EAAOuO,aAAa1vH,IAAKwQ,EAAS,CAAE1C,SAAU+6G,IAEvCr4G,CAER,IAAI+mG,OAAO,WAEV,OAAO,IAER,IAIA,OAFA9pH,KAAKwiI,aAAc9yD,GAAau2D,EAEzBA,CAER,CAEAC,gBAAiBJ,EAAa9f,GAE7B,MACMpN,EAAO54G,KAAK44G,KACZh1G,EAAU5D,KAAK4D,QAErB,QAAyCzG,IAApC6C,KAAKuiI,YAAauD,GAEtB,OAAO9lI,KAAKuiI,YAAauD,GAAc3d,MAAQplG,GAAaA,EAAQ5P,UAIrE,MAAM4yH,EAAYntB,EAAK16F,OAAQ4nH,GAEzBO,EAAMxyB,KAAKwyB,KAAOxyB,KAAKyyB,UAE7B,IAAIC,EAAYR,EAAUtK,KAAO,GAC7B+K,GAAc,EAElB,QAA8BrpI,IAAzB4oI,EAAU/J,WAIduK,EArBcvmI,KAqBK44H,cAAe,aAAcmN,EAAU/J,YAAa7T,MAAM,SAAW6T,GAEvFwK,GAAc,EACd,MAAMld,EAAO,IAAImd,KAAM,CAAEzK,GAAc,CAAEjvH,KAAMg5H,EAAU/d,WAEzD,OADAue,EAAYF,EAAIK,gBAAiBpd,GAC1Bid,CAER,SAEM,QAAuBppI,IAAlB4oI,EAAUtK,IAErB,MAAM,IAAIx1H,MAAO,2BAA6B6/H,EAAc,kCAI7D,MAAMG,EAAUpf,QAAQC,QAASyf,GAAYpe,MAAM,SAAWoe,GAE7D,OAAO,IAAI1f,SAAS,SAAWC,EAASC,GAEvC,IAAI/B,EAAS8B,GAEuB,IAA/Bd,EAAOqG,sBAEXrH,EAAS,SAAW2H,GAEnB,MAAM5pG,EAAU,IAAIvE,GAASmuG,GAC7B5pG,EAAQjF,aAAc,EAEtBgpG,EAAS/jG,EAEV,GAIDijG,EAAOW,KAAMoF,GAAYnG,WAAY2gB,EAAW3iI,EAAQ0nE,MAAQ05C,OAAQ7nH,EAAW4pH,EAEpF,GAED,IAAIoB,MAAM,SAAWplG,GAlwBvB,IAA8B04G,EA8wB3B,OARqB,IAAhB+K,GAEJH,EAAIM,gBAAiBJ,GAItBxjH,EAAQhD,SAASioG,SAAW+d,EAAU/d,YA5wBXyT,EA4wB4CsK,EAAUtK,KA1wB1EmL,OAAQ,kBAAqB,GAA4C,IAAvCnL,EAAImL,OAAQ,sBAAsC,aACxFnL,EAAImL,OAAQ,iBAAoB,GAA4C,IAAvCnL,EAAImL,OAAQ,sBAAsC,aAErF,aAywBE7jH,CAER,IAAI+mG,OAAO,SAAW3sF,GAGrB,MADA7+B,QAAQ6+B,MAAO,0CAA4CopG,GACrDppG,CAEP,IAGA,OADAn9B,KAAKuiI,YAAauD,GAAgBG,EAC3BA,CAER,CASAzM,cAAeP,EAAgB4N,EAASC,EAAQ9qH,GAE/C,MAAM03G,EAAS1zH,KAEf,OAAOA,KAAK44H,cAAe,UAAWkO,EAAO/oI,OAAQoqH,MAAM,SAAWplG,GAErE,IAAOA,EAAU,OAAO,KASxB,QAPyB5lB,IAApB2pI,EAAO3H,UAA0B2H,EAAO3H,SAAW,KAEvDp8G,EAAUA,EAAQ5P,SACVoM,QAAUunH,EAAO3H,UAIrBzL,EAAO77E,WAAYw9E,GAAWc,uBAA0B,CAE5D,MAAMt1B,OAAkC1jG,IAAtB2pI,EAAOjvF,WAA2BivF,EAAOjvF,WAAYw9E,GAAWc,4BAA0Bh5H,EAE5G,GAAK0jG,EAAY,CAEhB,MAAMkmC,EAAgBrT,EAAOuO,aAAap5H,IAAKka,GAC/CA,EAAU2wG,EAAO77E,WAAYw9E,GAAWc,uBAAwB+I,cAAen8G,EAAS89E,GACxF6yB,EAAOuO,aAAa1vH,IAAKwQ,EAASgkH,EAEnC,CAED,CAUA,YARoB5pI,IAAf6e,IAEJ+G,EAAQ/G,WAAaA,GAItBi9G,EAAgB4N,GAAY9jH,EAErBA,CAER,GAED,CAUA06G,oBAAqB9hF,GAEpB,MAAMxuB,EAAWwuB,EAAKxuB,SACtB,IAAI8S,EAAW0b,EAAK1b,SAEpB,MAAM+mG,OAAwD7pI,IAAhCgwB,EAASxnB,WAAWiqC,QAC5Cq3F,OAAgD9pI,IAA9BgwB,EAASxnB,WAAW6V,MACtC0rH,OAAgD/pI,IAA/BgwB,EAASxnB,WAAW0kB,OAE3C,GAAKsxB,EAAKjc,SAAW,CAEpB,MAAMgwC,EAAW,kBAAoBzvC,EAASriB,KAE9C,IAAIupH,EAAiBnnI,KAAKqgC,MAAMx3B,IAAK6mE,GAE9By3D,IAENA,EAAiB,IAAInuD,GACrB11C,GAASjhC,UAAU+Q,KAAKxR,KAAMulI,EAAgBlnG,GAC9CknG,EAAe3rH,MAAMpI,KAAM6sB,EAASzkB,OACpC2rH,EAAelnI,IAAMggC,EAAShgC,IAC9BknI,EAAep9F,iBAAkB,EAEjC/pC,KAAKqgC,MAAMrjC,IAAK0yE,EAAUy3D,IAI3BlnG,EAAWknG,CAEZ,MAAO,GAAKxrF,EAAKlc,OAAS,CAEzB,MAAMiwC,EAAW,qBAAuBzvC,EAASriB,KAEjD,IAAIwpH,EAAepnI,KAAKqgC,MAAMx3B,IAAK6mE,GAE5B03D,IAENA,EAAe,IAAItuD,GACnBx1C,GAASjhC,UAAU+Q,KAAKxR,KAAMwlI,EAAcnnG,GAC5CmnG,EAAa5rH,MAAMpI,KAAM6sB,EAASzkB,OAClC4rH,EAAannI,IAAMggC,EAAShgC,IAE5BD,KAAKqgC,MAAMrjC,IAAK0yE,EAAU03D,IAI3BnnG,EAAWmnG,CAEZ,CAGA,GAAKJ,GAAyBC,GAAmBC,EAAiB,CAEjE,IAAIx3D,EAAW,kBAAoBzvC,EAASriB,KAAO,IAE9CopH,IAAwBt3D,GAAY,wBACpCu3D,IAAkBv3D,GAAY,kBAC9Bw3D,IAAiBx3D,GAAY,iBAElC,IAAI0U,EAAiBpkF,KAAKqgC,MAAMx3B,IAAK6mE,GAE9B0U,IAENA,EAAiBnkD,EAAS9sB,QAErB8zH,IAAkB7iD,EAAe1gD,cAAe,GAChDwjG,IAAiB9iD,EAAe75C,aAAc,GAE9Cy8F,IAGC5iD,EAAe57C,cAAc47C,EAAe57C,YAAYhsC,IAAO,GAC/D4nF,EAAe98C,uBAAuB88C,EAAe98C,qBAAqB9qC,IAAO,IAIvFwD,KAAKqgC,MAAMrjC,IAAK0yE,EAAU0U,GAE1BpkF,KAAKiiI,aAAa1vH,IAAK6xE,EAAgBpkF,KAAKiiI,aAAap5H,IAAKo3B,KAI/DA,EAAWmkD,CAEZ,CAEAzoC,EAAK1b,SAAWA,CAEjB,CAEA84F,kBAEC,OAAOpgD,EAER,CAOA0rD,aAAc50F,GAEb,MAAMikF,EAAS1zH,KACT44G,EAAO54G,KAAK44G,KACZ/gE,EAAa73C,KAAK63C,WAClBqhF,EAActgB,EAAKl6E,UAAW+Q,GAEpC,IAAI43F,EACJ,MAAMpO,EAAiB,CAAC,EAGlBE,EAAU,GAEhB,IAJ2BD,EAAYrhF,YAAc,CAAC,GAI7Bw9E,GAAWU,qBAAwB,CAE3D,MAAMuR,EAAezvF,EAAYw9E,GAAWU,qBAC5CsR,EAAeC,EAAavO,kBAC5BI,EAAQ15H,KAAM6nI,EAAatO,aAAcC,EAAgBC,EAAaxF,GAEvE,KAAO,CAKN,MAAM0F,EAAoBF,EAAYG,sBAAwB,CAAC,EAK/D,GAHAJ,EAAez9G,MAAQ,IAAIuvB,GAAO,EAAK,EAAK,GAC5CkuF,EAAet1F,QAAU,EAEpB1iC,MAAME,QAASi4H,EAAkBE,iBAAoB,CAEzD,MAAM7rH,EAAQ2rH,EAAkBE,gBAEhCL,EAAez9G,MAAM9F,UAAWjI,GAChCwrH,EAAet1F,QAAUl2B,EAAO,EAEjC,MAE4CtQ,IAAvCi8H,EAAkBG,kBAEtBJ,EAAQ15H,KAAMi0H,EAAO8F,cAAeP,EAAgB,MAAOG,EAAkBG,iBAAkBltH,KAIhG4sH,EAAe1yF,eAAiDppC,IAArCi8H,EAAkBmO,eAA+BnO,EAAkBmO,eAAiB,EAC/GtO,EAAe3yF,eAAkDnpC,IAAtCi8H,EAAkBoO,gBAAgCpO,EAAkBoO,gBAAkB,OAE7DrqI,IAA/Ci8H,EAAkBqO,2BAEtBtO,EAAQ15H,KAAMi0H,EAAO8F,cAAeP,EAAgB,eAAgBG,EAAkBqO,2BACtFtO,EAAQ15H,KAAMi0H,EAAO8F,cAAeP,EAAgB,eAAgBG,EAAkBqO,4BAIvFJ,EAAernI,KAAK8jI,YAAY,SAAWhB,GAE1C,OAAOA,EAAI/J,iBAAmB+J,EAAI/J,gBAAiBtpF,EAEpD,IAEA0pF,EAAQ15H,KAAMonH,QAAQl/G,IAAK3H,KAAK6iI,YAAY,SAAWC,GAEtD,OAAOA,EAAIrJ,sBAAwBqJ,EAAIrJ,qBAAsBhqF,EAAewpF,EAE7E,KAED,EAEiC,IAA5BC,EAAY7kD,cAEhB4kD,EAAex1F,KAAOh6B,GAIvB,MAAMi+H,EAAYxO,EAAYwO,WAtxCvB,SA2yCP,GAzyCM,UAsxCDA,GAEJzO,EAAer1F,aAAc,EAG7Bq1F,EAAe30F,YAAa,IAI5B20F,EAAer1F,aAAc,EAhyCzB,SAkyCC8jG,IAEJzO,EAAenzF,eAAwC3oC,IAA5B+7H,EAAYyO,YAA4BzO,EAAYyO,YAAc,UAM5DxqI,IAA9B+7H,EAAY0O,eAA+BP,IAAiBt6F,KAEhEosF,EAAQ15H,KAAMi0H,EAAO8F,cAAeP,EAAgB,YAAaC,EAAY0O,gBAE7E3O,EAAezwF,YAAc,IAAI/1B,GAAS,EAAG,QAEJtV,IAApC+7H,EAAY0O,cAAcxtH,OAAsB,CAEpD,MAAMA,EAAQ8+G,EAAY0O,cAAcxtH,MAExC6+G,EAAezwF,YAAYj2B,IAAK6H,EAAOA,EAExC,CA4BD,YAxBsCjd,IAAjC+7H,EAAY2O,kBAAkCR,IAAiBt6F,KAEnEosF,EAAQ15H,KAAMi0H,EAAO8F,cAAeP,EAAgB,QAASC,EAAY2O,wBAE1B1qI,IAA1C+7H,EAAY2O,iBAAiBC,WAEjC7O,EAAe9wF,eAAiB+wF,EAAY2O,iBAAiBC,gBAM3B3qI,IAA/B+7H,EAAY6O,gBAAgCV,IAAiBt6F,KAEjEksF,EAAetyF,UAAW,IAAIoE,IAAQr1B,UAAWwjH,EAAY6O,sBAIzB5qI,IAAhC+7H,EAAY8O,iBAAiCX,IAAiBt6F,IAElEosF,EAAQ15H,KAAMi0H,EAAO8F,cAAeP,EAAgB,cAAeC,EAAY8O,gBAAiB37H,KAI1Fw6G,QAAQl/G,IAAKwxH,GAAUhR,MAAM,WAEnC,MAAMloF,EAAW,IAAIonG,EAAcpO,GAUnC,OARKC,EAAY12H,OAAOy9B,EAASz9B,KAAO02H,EAAY12H,MAEpDk2H,GAAwBz4F,EAAUi5F,GAElCxF,EAAOuO,aAAa1vH,IAAK0tB,EAAU,CAAEvB,UAAW+Q,IAE3CypF,EAAYrhF,YAAaqpF,GAAgCrpF,EAAY5X,EAAUi5F,GAE7Ej5F,CAER,GAED,CAGA04F,iBAAkBsP,GAEjB,MAAMC,EAAgBna,GAAgBoa,iBAAkBF,GAAgB,IAExE,OAAKC,KAAiBloI,KAAKyiI,cAEnByF,EAAgB,OAAWloI,KAAKyiI,cAAeyF,IAItDloI,KAAKyiI,cAAeyF,GAAkB,EAE/BA,EAIT,CAUAE,eAAgBvL,GAEf,MAAMnJ,EAAS1zH,KACT63C,EAAa73C,KAAK63C,WAClBxX,EAAQrgC,KAAKkiI,eAEnB,SAASmG,EAAsBzL,GAE9B,OAAO/kF,EAAYw9E,GAAWY,4BAC5BoI,gBAAiBzB,EAAWlJ,GAC5BvL,MAAM,SAAWh7F,GAEjB,OAAOm7G,GAAwBn7G,EAAUyvG,EAAWlJ,EAErD,GAEF,CAEA,MAAMyF,EAAU,GAEhB,IAAM,IAAI74H,EAAI,EAAGmrB,EAAKoxG,EAAWl8H,OAAQL,EAAImrB,EAAInrB,IAAO,CAEvD,MAAMs8H,EAAYC,EAAYv8H,GACxBovE,EAAW+xD,GAAoB7E,GAG/Bz8E,EAAS9f,EAAOqvC,GAEtB,GAAKvvB,EAGJg5E,EAAQ15H,KAAM0gD,EAAO8lF,aAEf,CAEN,IAAIsC,EAKHA,EAHI3L,EAAU/kF,YAAc+kF,EAAU/kF,WAAYw9E,GAAWY,4BAG3CoS,EAAsBzL,GAKtB0L,GAAwB,IAAI,GAAkB1L,EAAWlJ,GAK5ErzF,EAAOqvC,GAAa,CAAEktD,UAAWA,EAAWqJ,QAASsC,GAErDpP,EAAQ15H,KAAM8oI,EAEf,CAED,CAEA,OAAO1hB,QAAQl/G,IAAKwxH,EAErB,CAOA+K,SAAUsE,GAET,MAAM9U,EAAS1zH,KACT44G,EAAO54G,KAAK44G,KACZ/gE,EAAa73C,KAAK63C,WAElB6kF,EAAU9jB,EAAK+jB,OAAQ6L,GACvB3L,EAAaH,EAAQG,WAErB1D,EAAU,GAEhB,IAAM,IAAI74H,EAAI,EAAGmrB,EAAKoxG,EAAWl8H,OAAQL,EAAImrB,EAAInrB,IAAO,CAEvD,MAAM2/B,OAAwC9iC,IAA7B0/H,EAAYv8H,GAAI2/B,eAt8CC9iC,KAFLkjC,EAy8CHrgC,KAAKqgC,OAv8CH,kBAE7BA,EAAyB,gBAAI,IAAIs4C,GAAsB,CACtDn9D,MAAO,SACPmrB,SAAU,EACVJ,UAAW,EACXD,UAAW,EACX1C,aAAa,EACbS,WAAW,EACXZ,KAAMj6B,KAKD62B,EAAyB,iBA07C3BrgC,KAAK44H,cAAe,WAAYiE,EAAYv8H,GAAI2/B,UAEnDk5F,EAAQ15H,KAAMwgC,EAEf,CA98CF,IAAgCI,EAk9C9B,OAFA84F,EAAQ15H,KAAMi0H,EAAO0U,eAAgBvL,IAE9BhW,QAAQl/G,IAAKwxH,GAAUhR,MAAM,SAAW0G,GAE9C,MAAMnwF,EAAYmwF,EAAQvsH,MAAO,EAAGusH,EAAQluH,OAAS,GAC/C89B,EAAaowF,EAASA,EAAQluH,OAAS,GAEvCg8H,EAAS,GAEf,IAAM,IAAIr8H,EAAI,EAAGmrB,EAAKgT,EAAW99B,OAAQL,EAAImrB,EAAInrB,IAAO,CAEvD,MAAM6sB,EAAWsR,EAAYn+B,GACvBs8H,EAAYC,EAAYv8H,GAI9B,IAAIq7C,EAEJ,MAAM1b,EAAWvB,EAAWp+B,GAE5B,GAAKs8H,EAAUhmE,OAASkmE,GAAgBn6D,WACtCi6D,EAAUhmE,OAASkmE,GAAgBC,gBACnCH,EAAUhmE,OAASkmE,GAAgBE,mBAChB7/H,IAAnBy/H,EAAUhmE,KAGXjb,GAAiC,IAA1B+gF,EAAQ78F,cACZ,IAAIy3E,GAAanqF,EAAU8S,GAC3B,IAAI+T,GAAM7mB,EAAU8S,IAEK,IAAvB0b,EAAK9b,eAGT8b,EAAK+7D,uBAIDklB,EAAUhmE,OAASkmE,GAAgBC,eAEvCphF,EAAKxuB,SAAW0lG,GAAqBl3E,EAAKxuB,SAAUjhB,GAEzC0wH,EAAUhmE,OAASkmE,GAAgBE,eAE9CrhF,EAAKxuB,SAAW0lG,GAAqBl3E,EAAKxuB,SAAUhhB,SAI/C,GAAKywH,EAAUhmE,OAASkmE,GAAgBl6D,MAE9CjnB,EAAO,IAAIm/D,GAAc3tF,EAAU8S,QAE7B,GAAK28F,EAAUhmE,OAASkmE,GAAgBj6D,WAE9ClnB,EAAO,IAAIw+D,GAAMhtF,EAAU8S,QAErB,GAAK28F,EAAUhmE,OAASkmE,GAAgBh6D,UAE9CnnB,EAAO,IAAIo/D,GAAU5tF,EAAU8S,OAEzB,IAAK28F,EAAUhmE,OAASkmE,GAAgB/5D,OAM9C,MAAM,IAAI98D,MAAO,iDAAmD22H,EAAUhmE,MAJ9Ejb,EAAO,IAAIy/D,GAAQjuF,EAAU8S,EAM9B,CAEK79B,OAAOyD,KAAM81C,EAAKxuB,SAAS0hB,iBAAkBluC,OAAS,GAE1DszC,GAAoB0H,EAAM+gF,GAI3B/gF,EAAKn5C,KAAOkxH,EAAOiF,iBAAkB+D,EAAQl6H,MAAU,QAAUgmI,GAEjE9P,GAAwB/8E,EAAM+gF,GAEzBE,EAAU/kF,YAAaqpF,GAAgCrpF,EAAY8D,EAAMihF,GAE9ElJ,EAAO+J,oBAAqB9hF,GAE5BghF,EAAOl9H,KAAMk8C,EAEd,CAEA,IAAM,IAAIr7C,EAAI,EAAGmrB,EAAKkxG,EAAOh8H,OAAQL,EAAImrB,EAAInrB,IAE5CozH,EAAOuO,aAAa1vH,IAAKoqH,EAAQr8H,GAAK,CACrCq8H,OAAQ6L,EACR3L,WAAYv8H,IAKd,GAAuB,IAAlBq8H,EAAOh8H,OAIX,OAFK+7H,EAAQ7kF,YAAaqpF,GAAgCrpF,EAAY8kF,EAAQ,GAAKD,GAE5EC,EAAQ,GAIhB,MAAMtrF,EAAQ,IAAIstD,GAEb+9B,EAAQ7kF,YAAaqpF,GAAgCrpF,EAAYxG,EAAOqrF,GAE7EhJ,EAAOuO,aAAa1vH,IAAK8+B,EAAO,CAAEsrF,OAAQ6L,IAE1C,IAAM,IAAIloI,EAAI,EAAGmrB,EAAKkxG,EAAOh8H,OAAQL,EAAImrB,EAAInrB,IAE5C+wC,EAAMr0C,IAAK2/H,EAAQr8H,IAIpB,OAAO+wC,CAER,GAED,CAOAmzF,WAAYiE,GAEX,IAAIv/G,EACJ,MAAMw/G,EAAY1oI,KAAK44G,KAAKj+D,QAAS8tF,GAC/BxqE,EAASyqE,EAAWA,EAAU37H,MAEpC,GAAOkxD,EAqBP,MAdwB,gBAAnByqE,EAAU37H,KAEdmc,EAAS,IAAIsvB,GAAmB5oC,GAAU0B,SAAU2sD,EAAO0qE,MAAQ1qE,EAAO2qE,aAAe,EAAG3qE,EAAO4qE,OAAS,EAAG5qE,EAAO6qE,MAAQ,KAEhG,iBAAnBJ,EAAU37H,OAErBmc,EAAS,IAAIiyC,IAAsB8C,EAAO8qE,KAAM9qE,EAAO8qE,KAAM9qE,EAAO+qE,MAAQ/qE,EAAO+qE,KAAM/qE,EAAO4qE,MAAO5qE,EAAO6qE,OAI1GJ,EAAUlmI,OAAO0mB,EAAO1mB,KAAOxC,KAAK24H,iBAAkB+P,EAAUlmI,OAErEk2H,GAAwBxvG,EAAQw/G,GAEzB7hB,QAAQC,QAAS59F,GAnBvB5qB,QAAQkU,KAAM,+CAqBhB,CAOA8xH,SAAU1sB,GAET,MAAMqxB,EAAUjpI,KAAK44G,KAAKyqB,MAAOzrB,GAE3BuhB,EAAU,GAEhB,IAAM,IAAI74H,EAAI,EAAGmrB,EAAKw9G,EAAQ9pC,OAAOx+F,OAAQL,EAAImrB,EAAInrB,IAEpD64H,EAAQ15H,KAAMO,KAAKkpI,iBAAkBD,EAAQ9pC,OAAQ7+F,KActD,YAVqCnD,IAAhC8rI,EAAQE,oBAEZhQ,EAAQ15H,KAAMO,KAAK44H,cAAe,WAAYqQ,EAAQE,sBAItDhQ,EAAQ15H,KAAM,MAIRonH,QAAQl/G,IAAKwxH,GAAUhR,MAAM,SAAW0G,GAE9C,MAAMsa,EAAsBta,EAAQ9xC,MAC9BqsD,EAAava,EAKb/W,EAAQ,GACRC,EAAe,GAErB,IAAM,IAAIz3G,EAAI,EAAGmrB,EAAK29G,EAAWzoI,OAAQL,EAAImrB,EAAInrB,IAAO,CAEvD,MAAM+oI,EAAYD,EAAY9oI,GAE9B,GAAK+oI,EAAY,CAEhBvxB,EAAMr4G,KAAM4pI,GAEZ,MAAMC,EAAM,IAAI71G,GAEa,OAAxB01G,GAEJG,EAAI5zH,UAAWyzH,EAAoB17H,MAAW,GAAJnN,GAI3Cy3G,EAAat4G,KAAM6pI,EAEpB,MAEChrI,QAAQkU,KAAM,mDAAoDy2H,EAAQ9pC,OAAQ7+F,GAIpF,CAEA,OAAO,IAAIg4G,GAAUR,EAAOC,EAE7B,GAED,CAOAwsB,cAAegF,GAEd,MAAM3wB,EAAO54G,KAAK44G,KACZ8a,EAAS1zH,KAETwpI,EAAe5wB,EAAK/8E,WAAY0tG,GAChCE,EAAgBD,EAAahnI,KAAOgnI,EAAahnI,KAAO,aAAe+mI,EAEvEG,EAAe,GACfC,EAAwB,GACxBC,EAAyB,GACzBC,EAAkB,GAClBC,EAAiB,GAEvB,IAAM,IAAIxpI,EAAI,EAAGmrB,EAAK+9G,EAAaO,SAASppI,OAAQL,EAAImrB,EAAInrB,IAAO,CAElE,MAAMif,EAAUiqH,EAAaO,SAAUzpI,GACjC0lI,EAAUwD,EAAapD,SAAU7mH,EAAQymH,SACzC5hI,EAASmb,EAAQnb,OACjB5B,EAAO4B,EAAO+pH,KACd6b,OAAoC7sI,IAA5BqsI,EAAa7pG,WAA2B6pG,EAAa7pG,WAAYqmG,EAAQgE,OAAUhE,EAAQgE,MACnG7rH,OAAqChhB,IAA5BqsI,EAAa7pG,WAA2B6pG,EAAa7pG,WAAYqmG,EAAQ7nH,QAAW6nH,EAAQ7nH,YAEtFhhB,IAAhBiH,EAAO+pH,OAEZub,EAAajqI,KAAMO,KAAK44H,cAAe,OAAQp2H,IAC/CmnI,EAAsBlqI,KAAMO,KAAK44H,cAAe,WAAYoR,IAC5DJ,EAAuBnqI,KAAMO,KAAK44H,cAAe,WAAYz6G,IAC7D0rH,EAAgBpqI,KAAMumI,GACtB8D,EAAerqI,KAAM2E,GAEtB,CAEA,OAAOyiH,QAAQl/G,IAAK,CAEnBk/G,QAAQl/G,IAAK+hI,GACb7iB,QAAQl/G,IAAKgiI,GACb9iB,QAAQl/G,IAAKiiI,GACb/iB,QAAQl/G,IAAKkiI,GACbhjB,QAAQl/G,IAAKmiI,KAEV3hB,MAAM,SAAW8a,GAEpB,MAAMpkG,EAAQokG,EAAc,GACtBgH,EAAiBhH,EAAc,GAC/BiH,EAAkBjH,EAAc,GAChCmD,EAAWnD,EAAc,GACzBnB,EAAUmB,EAAc,GAExBxgB,EAAS,GAEf,IAAM,IAAIniH,EAAI,EAAGmrB,EAAKoT,EAAMl+B,OAAQL,EAAImrB,EAAInrB,IAAO,CAElD,MAAM6tH,EAAOtvF,EAAOv+B,GACd6pI,EAAgBF,EAAgB3pI,GAChC8pI,EAAiBF,EAAiB5pI,GAClC0lI,EAAUI,EAAU9lI,GACpB8D,EAAS09H,EAASxhI,GAExB,QAAcnD,IAATgxH,EAAqB,SAErBA,EAAKhuG,eAETguG,EAAKhuG,eACLguG,EAAKzuG,kBAAmB,GAIzB,MAAM2qH,EAAgB3W,EAAO4W,uBAAwBnc,EAAMgc,EAAeC,EAAgBpE,EAAS5hI,GAEnG,GAAKimI,EAEJ,IAAM,IAAI9lD,EAAI,EAAGA,EAAI8lD,EAAc1pI,OAAQ4jF,IAE1Ck+B,EAAOhjH,KAAM4qI,EAAe9lD,GAM/B,CAEA,OAAO,IAAIg+B,GAAeknB,OAAetsI,EAAWslH,EAErD,GAED,CAEAga,eAAgB1E,GAEf,MAAMnf,EAAO54G,KAAK44G,KACZ8a,EAAS1zH,KACTi4H,EAAUrf,EAAK/5E,MAAOk5F,GAE5B,YAAsB56H,IAAjB86H,EAAQt8E,KAA4B,KAElC+3E,EAAOkF,cAAe,OAAQX,EAAQt8E,MAAOwsE,MAAM,SAAWxsE,GAEpE,MAAMwyE,EAAOuF,EAAOoF,YAAapF,EAAO0O,UAAWnK,EAAQt8E,KAAMA,GAmBjE,YAhByBx+C,IAApB86H,EAAQ/4D,SAEZivD,EAAKlwF,UAAU,SAAWh8B,GAEzB,GAAOA,EAAEu9B,OAET,IAAM,IAAIl/B,EAAI,EAAGmrB,EAAKwsG,EAAQ/4D,QAAQv+D,OAAQL,EAAImrB,EAAInrB,IAErD2B,EAAEiyC,sBAAuB5zC,GAAM23H,EAAQ/4D,QAAS5+D,EAIlD,IAIM6tH,CAER,GAED,CAOA8V,SAAUlM,GAET,MACMrE,EAAS1zH,KAETi4H,EAHOj4H,KAAK44G,KAGG/5E,MAAOk5F,GAEtBwS,EAAc7W,EAAOwV,iBAAkBnR,GAEvCyS,EAAe,GACfC,EAAcxS,EAAQ5qG,UAAY,GAExC,IAAM,IAAI/sB,EAAI,EAAGmrB,EAAKg/G,EAAY9pI,OAAQL,EAAImrB,EAAInrB,IAEjDkqI,EAAa/qI,KAAMi0H,EAAOkF,cAAe,OAAQ6R,EAAanqI,KAI/D,MAAMoqI,OAAmCvtI,IAAjB86H,EAAQuL,KAC7B3c,QAAQC,QAAS,MACjB4M,EAAOkF,cAAe,OAAQX,EAAQuL,MAEzC,OAAO3c,QAAQl/G,IAAK,CACnB4iI,EACA1jB,QAAQl/G,IAAK6iI,GACbE,IACGviB,MAAM,SAAW0G,GAEpB,MAAMV,EAAOU,EAAS,GAChBxhG,EAAWwhG,EAAS,GACpB7uF,EAAW6uF,EAAS,GAER,OAAb7uF,GAIJmuF,EAAKlwF,UAAU,SAAW0d,GAElBA,EAAK9b,eAEZ8b,EAAKp0C,KAAMy4B,EAAU,GAEtB,IAID,IAAM,IAAI1/B,EAAI,EAAGmrB,EAAK4B,EAAS1sB,OAAQL,EAAImrB,EAAInrB,IAE9C6tH,EAAKnxH,IAAKqwB,EAAU/sB,IAIrB,OAAO6tH,CAER,GAED,CAIA+a,iBAAkBnR,GAEjB,MAAMnf,EAAO54G,KAAK44G,KACZ/gE,EAAa73C,KAAK63C,WAClB67E,EAAS1zH,KAKf,QAAqC7C,IAAhC6C,KAAKmiI,UAAWpK,GAEpB,OAAO/3H,KAAKmiI,UAAWpK,GAIxB,MAAME,EAAUrf,EAAK/5E,MAAOk5F,GAGtB1J,EAAW4J,EAAQz1H,KAAOkxH,EAAOiF,iBAAkBV,EAAQz1H,MAAS,GAEpE22H,EAAU,GAEVwR,EAAcjX,EAAOoQ,YAAY,SAAWhB,GAEjD,OAAOA,EAAIrG,gBAAkBqG,EAAIrG,eAAgB1E,EAElD,IAgHA,OA9GK4S,GAEJxR,EAAQ15H,KAAMkrI,QAISxtI,IAAnB86H,EAAQ/uG,QAEZiwG,EAAQ15H,KAAMi0H,EAAOkF,cAAe,SAAUX,EAAQ/uG,QAASi/F,MAAM,SAAWj/F,GAE/E,OAAOwqG,EAAOoF,YAAapF,EAAO2O,YAAapK,EAAQ/uG,OAAQA,EAEhE,KAIDwqG,EAAOmP,YAAY,SAAWC,GAE7B,OAAOA,EAAIjK,sBAAwBiK,EAAIjK,qBAAsBd,EAE9D,IAAIjyH,SAAS,SAAWmgI,GAEvB9M,EAAQ15H,KAAMwmI,EAEf,IAEAjmI,KAAKmiI,UAAWpK,GAAclR,QAAQl/G,IAAKwxH,GAAUhR,MAAM,SAAWh3D,GAErE,IAAIg9D,EAqBJ,GAhBCA,GAFuB,IAAnB8J,EAAQ/f,OAEL,IAAID,GAEA9mD,EAAQxwD,OAAS,EAErB,IAAIg+F,GAEmB,IAAnBxtC,EAAQxwD,OAEZwwD,EAAS,GAIT,IAAIv2B,GAIPuzF,IAASh9D,EAAS,GAEtB,IAAM,IAAI7wD,EAAI,EAAGmrB,EAAK0lC,EAAQxwD,OAAQL,EAAImrB,EAAInrB,IAE7C6tH,EAAKnxH,IAAKm0D,EAAS7wD,IAiBrB,GAXK23H,EAAQz1H,OAEZ2rH,EAAKpuG,SAASvd,KAAOy1H,EAAQz1H,KAC7B2rH,EAAK3rH,KAAO6rH,GAIbqK,GAAwBvK,EAAM8J,GAEzBA,EAAQpgF,YAAaqpF,GAAgCrpF,EAAYs2E,EAAM8J,QAEpD96H,IAAnB86H,EAAQt9G,OAAuB,CAEnC,MAAMA,EAAS,IAAI8Y,GACnB9Y,EAAOjF,UAAWuiH,EAAQt9G,QAC1BwzG,EAAKhtG,aAAcxG,EAEpB,WAE8Bxd,IAAxB86H,EAAQ6I,aAEZ3S,EAAK/gG,SAAS1X,UAAWuiH,EAAQ6I,kBAIR3jI,IAArB86H,EAAQh+G,UAEZk0G,EAAK9oG,WAAW3P,UAAWuiH,EAAQh+G,eAIb9c,IAAlB86H,EAAQ79G,OAEZ+zG,EAAK/zG,MAAM1E,UAAWuiH,EAAQ79G,OAchC,OAROs5G,EAAOuO,aAAarqE,IAAKu2D,IAE/BuF,EAAOuO,aAAa1vH,IAAK47G,EAAM,CAAC,GAIjCuF,EAAOuO,aAAap5H,IAAKslH,GAAOtvF,MAAQk5F,EAEjC5J,CAER,IAEOnuH,KAAKmiI,UAAWpK,EAExB,CAOAiM,UAAW4G,GAEV,MAAM/yF,EAAa73C,KAAK63C,WAClBgzF,EAAW7qI,KAAK44G,KAAKsqB,OAAQ0H,GAC7BlX,EAAS1zH,KAIT46C,EAAQ,IAAI+jD,GACbksC,EAASroI,OAAOo4C,EAAMp4C,KAAOkxH,EAAOiF,iBAAkBkS,EAASroI,OAEpEk2H,GAAwB99E,EAAOiwF,GAE1BA,EAAShzF,YAAaqpF,GAAgCrpF,EAAY+C,EAAOiwF,GAE9E,MAAMC,EAAUD,EAAShsG,OAAS,GAE5Bs6F,EAAU,GAEhB,IAAM,IAAI74H,EAAI,EAAGmrB,EAAKq/G,EAAQnqI,OAAQL,EAAImrB,EAAInrB,IAE7C64H,EAAQ15H,KAAMi0H,EAAOkF,cAAe,OAAQkS,EAASxqI,KAItD,OAAOumH,QAAQl/G,IAAKwxH,GAAUhR,MAAM,SAAWtpF,GAE9C,IAAM,IAAIv+B,EAAI,EAAGmrB,EAAKoT,EAAMl+B,OAAQL,EAAImrB,EAAInrB,IAE3Cs6C,EAAM59C,IAAK6hC,EAAOv+B,IAsCnB,OAFAozH,EAAOuO,aA9BoB,CAAE9T,IAE5B,MAAM4c,EAAsB,IAAI/7D,IAEhC,IAAM,MAAQjpE,EAAK3I,KAAWs2H,EAAOuO,cAE/Bl8H,aAAeu9B,IAAYv9B,aAAeyY,KAE9CusH,EAAoBx4H,IAAKxM,EAAK3I,GAkBhC,OAZA+wH,EAAKlwF,UAAYkwF,IAEhB,MAAMyV,EAAWlQ,EAAOuO,aAAap5H,IAAKslH,GAEzB,MAAZyV,GAEJmH,EAAoBx4H,IAAK47G,EAAMyV,EAEhC,IAIMmH,CAAmB,EAILC,CAAoBpwF,GAEnCA,CAER,GAED,CAEA0vF,uBAAwBnc,EAAMgc,EAAeC,EAAgBpE,EAAS5hI,GAErE,MAAMq+G,EAAS,GAETwoB,EAAa9c,EAAK3rH,KAAO2rH,EAAK3rH,KAAO2rH,EAAKvwG,KAE1C4jH,EAAc,GAoBpB,IAAI1f,EAEJ,OApBK+e,GAAiBz8H,EAAOknE,QAAWu1D,GAAgB3hE,QAEvDivD,EAAKlwF,UAAU,SAAW9R,GAEpBA,EAAO+nB,uBAEXstF,EAAY/hI,KAAM0sB,EAAO3pB,KAAO2pB,EAAO3pB,KAAO2pB,EAAOvO,KAIvD,IAIA4jH,EAAY/hI,KAAMwrI,GAMVpK,GAAiBz8H,EAAOknE,OAEhC,KAAKu1D,GAAgB3hE,QAEpB4iD,EAAqBG,GACrB,MAED,KAAK4e,GAAgB5mH,SAEpB6nG,EAAqBM,GACrB,MAID,QACC,OAASgoB,EAAej9F,UAEvB,KAAK,EACJ20E,EAAqBG,GACrB,MACD,KAAK,EACL,KAAK,EACJH,EAAqBQ,IASzB,MAAMvC,OAA0C5iH,IAA1B6oI,EAAQjmB,cAA8BghB,GAAeiF,EAAQjmB,eAAkBh0G,EAE/Fm/H,EAAclrI,KAAKmrI,sBAAuBf,GAEhD,IAAM,IAAIh7G,EAAI,EAAG6gB,EAAKuxF,EAAY7gI,OAAQyuB,EAAI6gB,EAAI7gB,IAAO,CAExD,MAAMgxF,EAAQ,IAAI0B,EACjB0f,EAAapyG,GAAM,IAAMyxG,GAAiBz8H,EAAOknE,MACjD6+D,EAAc18H,MACdy9H,EACAnrB,GAIsB,gBAAlBA,GAEJ//G,KAAKorI,mCAAoChrB,GAI1CqC,EAAOhjH,KAAM2gH,EAEd,CAEA,OAAOqC,CAER,CAEA0oB,sBAAuBjO,GAEtB,IAAIgO,EAAchO,EAASzvH,MAE3B,GAAKyvH,EAAS9vF,WAAa,CAE1B,MAAMhzB,EAAQ4nH,GAA6BkJ,EAAY3oI,aACjD8oI,EAAS,IAAIl8H,aAAc+7H,EAAYvqI,QAE7C,IAAM,IAAIyuB,EAAI,EAAG6gB,EAAKi7F,EAAYvqI,OAAQyuB,EAAI6gB,EAAI7gB,IAEjDi8G,EAAQj8G,GAAM87G,EAAa97G,GAAMhV,EAIlC8wH,EAAcG,CAEf,CAEA,OAAOH,CAER,CAEAE,mCAAoChrB,GAEnCA,EAAMQ,kBAAoB,SAAkDh8G,GAQ3E,OAAO,IAFmB5E,gBAAgBoiH,GAA4Bud,GAAuCP,IAEjFp/H,KAAKs8G,MAAOt8G,KAAKsgC,OAAQtgC,KAAKwgH,eAAiB,EAAG57G,EAE/E,EAGAw7G,EAAMQ,kBAAkB0qB,2CAA4C,CAErE,EA6HD,SAAShD,GAAwBn7G,EAAUu0G,EAAchO,GAExD,MAAM/tH,EAAa+7H,EAAa/7H,WAE1BwzH,EAAU,GAEhB,SAASoS,EAAyBzG,EAAetH,GAEhD,OAAO9J,EAAOkF,cAAe,WAAYkM,GACvC3c,MAAM,SAAW+U,GAEjB/vG,EAASlwB,aAAcugI,EAAeN,EAEvC,GAEF,CAEA,IAAM,MAAMsO,KAAqB7lI,EAAa,CAE7C,MAAMg5H,EAAqBC,GAAY4M,IAAuBA,EAAkBn9H,cAG3EswH,KAAsBxxG,EAASxnB,YAEpCwzH,EAAQ15H,KAAM8rI,EAAyB5lI,EAAY6lI,GAAqB7M,GAEzE,CAEA,QAA8BxhI,IAAzBukI,EAAavxF,UAA2BhjB,EAASpvB,MAAQ,CAE7D,MAAMm/H,EAAWxJ,EAAOkF,cAAe,WAAY8I,EAAavxF,SAAUg4E,MAAM,SAAW+U,GAE1F/vG,EAASiiB,SAAU8tF,EAEpB,IAEA/D,EAAQ15H,KAAMy9H,EAEf,CAMA,OAJAxE,GAAwBvrG,EAAUu0G,GA5JnC,SAAwBv0G,EAAUu0G,EAAchO,GAE/C,MAAM/tH,EAAa+7H,EAAa/7H,WAE1B2mB,EAAM,IAAIjB,GAEhB,QAA6BluB,IAAxBwI,EAAWw6H,SAkCf,OAlCwC,CAExC,MAAMjD,EAAWxJ,EAAO9a,KAAKkmB,UAAWn5H,EAAWw6H,UAE7CxiI,EAAMu/H,EAASv/H,IACf4Q,EAAM2uH,EAAS3uH,IAIrB,QAAapR,IAARQ,QAA6BR,IAARoR,EAmBzB,YAFAjQ,QAAQkU,KAAM,uEAVd,GALA8Z,EAAI/Z,IACH,IAAI,GAAS5U,EAAK,GAAKA,EAAK,GAAKA,EAAK,IACtC,IAAI,GAAS4Q,EAAK,GAAKA,EAAK,GAAKA,EAAK,KAGlC2uH,EAAS9vF,WAAa,CAE1B,MAAMq+F,EAAWzJ,GAA6BhD,GAAuB9B,EAAS6B,gBAC9EzyG,EAAI3uB,IAAIkW,eAAgB43H,GACxBn/G,EAAI/d,IAAIsF,eAAgB43H,EAEzB,CAUF,CAMA,MAAM3J,EAAUJ,EAAaI,QAE7B,QAAiB3kI,IAAZ2kI,EAAwB,CAE5B,MAAM4J,EAAkB,IAAI,GACtB9+G,EAAS,IAAI,GAEnB,IAAM,IAAItsB,EAAI,EAAGmrB,EAAKq2G,EAAQnhI,OAAQL,EAAImrB,EAAInrB,IAAO,CAEpD,MAAM8D,EAAS09H,EAASxhI,GAExB,QAAyBnD,IAApBiH,EAAO+7H,SAAyB,CAEpC,MAAMjD,EAAWxJ,EAAO9a,KAAKkmB,UAAW16H,EAAO+7H,UACzCxiI,EAAMu/H,EAASv/H,IACf4Q,EAAM2uH,EAAS3uH,IAIrB,QAAapR,IAARQ,QAA6BR,IAARoR,EAAoB,CAQ7C,GALAqe,EAAO7Z,KAAM/U,KAAKuQ,IAAKvQ,KAAKwS,IAAK7S,EAAK,IAAOK,KAAKwS,IAAKjC,EAAK,MAC5Dqe,EAAO5Z,KAAMhV,KAAKuQ,IAAKvQ,KAAKwS,IAAK7S,EAAK,IAAOK,KAAKwS,IAAKjC,EAAK,MAC5Dqe,EAAO3L,KAAMjjB,KAAKuQ,IAAKvQ,KAAKwS,IAAK7S,EAAK,IAAOK,KAAKwS,IAAKjC,EAAK,MAGvD2uH,EAAS9vF,WAAa,CAE1B,MAAMq+F,EAAWzJ,GAA6BhD,GAAuB9B,EAAS6B,gBAC9EnyG,EAAO/Y,eAAgB43H,EAExB,CAMAC,EAAgBn9H,IAAKqe,EAEtB,MAECtuB,QAAQkU,KAAM,sEAIhB,CAED,CAGA8Z,EAAIK,eAAgB++G,EAErB,CAEAv+G,EAASJ,YAAcT,EAEvB,MAAMqB,EAAS,IAAIgC,GAEnBrD,EAAIE,UAAWmB,EAAOzX,QACtByX,EAAOlD,OAAS6B,EAAI3uB,IAAIsX,WAAYqX,EAAI/d,KAAQ,EAEhD4e,EAAS6hB,eAAiBrhB,CAE3B,CAkDCg+G,CAAex+G,EAAUu0G,EAAchO,GAEhC7M,QAAQl/G,IAAKwxH,GAAUhR,MAAM,WAEnC,YAAgChrH,IAAzBukI,EAAaI,QAxzEtB,SAA0B30G,EAAU20G,EAASpO,GAE5C,IAAIhwD,GAAmB,EACnBkoE,GAAiB,EACjBC,GAAgB,EAEpB,IAAM,IAAIvrI,EAAI,EAAGmrB,EAAKq2G,EAAQnhI,OAAQL,EAAImrB,EAAInrB,IAAO,CAEpD,MAAM8D,EAAS09H,EAASxhI,GAMxB,QAJyBnD,IAApBiH,EAAO+7H,WAAyBz8D,GAAmB,QACjCvmE,IAAlBiH,EAAOg8H,SAAuBwL,GAAiB,QAC5BzuI,IAAnBiH,EAAOs8H,UAAwBmL,GAAgB,GAE/CnoE,GAAoBkoE,GAAkBC,EAAgB,KAE5D,CAEA,IAAOnoE,IAAsBkoE,IAAoBC,EAAgB,OAAOhlB,QAAQC,QAAS35F,GAEzF,MAAM2+G,EAA2B,GAC3BC,EAAyB,GACzBC,EAAwB,GAE9B,IAAM,IAAI1rI,EAAI,EAAGmrB,EAAKq2G,EAAQnhI,OAAQL,EAAImrB,EAAInrB,IAAO,CAEpD,MAAM8D,EAAS09H,EAASxhI,GAExB,GAAKojE,EAAmB,CAEvB,MAAMuoE,OAAsC9uI,IAApBiH,EAAO+7H,SAC5BzM,EAAOkF,cAAe,WAAYx0H,EAAO+7H,UACzChzG,EAASxnB,WAAWynB,SAEvB0+G,EAAyBrsI,KAAMwsI,EAEhC,CAEA,GAAKL,EAAiB,CAErB,MAAMK,OAAoC9uI,IAAlBiH,EAAOg8H,OAC5B1M,EAAOkF,cAAe,WAAYx0H,EAAOg8H,QACzCjzG,EAASxnB,WAAW0kB,OAEvB0hH,EAAuBtsI,KAAMwsI,EAE9B,CAEA,GAAKJ,EAAgB,CAEpB,MAAMI,OAAqC9uI,IAAnBiH,EAAOs8H,QAC5BhN,EAAOkF,cAAe,WAAYx0H,EAAOs8H,SACzCvzG,EAASxnB,WAAW6V,MAEvBwwH,EAAsBvsI,KAAMwsI,EAE7B,CAED,CAEA,OAAOplB,QAAQl/G,IAAK,CACnBk/G,QAAQl/G,IAAKmkI,GACbjlB,QAAQl/G,IAAKokI,GACbllB,QAAQl/G,IAAKqkI,KACV7jB,MAAM,SAAW2W,GAEpB,MAAMoN,EAAiBpN,EAAW,GAC5Bh7D,EAAeg7D,EAAW,GAC1B/6D,EAAc+6D,EAAW,GAO/B,OALKp7D,IAAmBv2C,EAAS0hB,gBAAgBzhB,SAAW8+G,GACvDN,IAAiBz+G,EAAS0hB,gBAAgBxkB,OAASy5C,GACnD+nE,IAAgB1+G,EAAS0hB,gBAAgBrzB,MAAQuoD,GACtD52C,EAAS2hB,sBAAuB,EAEzB3hB,CAER,GAED,CA0uEKg/G,CAAiBh/G,EAAUu0G,EAAaI,QAASpO,GACjDvmG,CAEJ,GAED,CC/8IA,MAAMi/G,GAAiB,IAAIC,IACvB,KAEItwI,SAAS0C,eAAe,YAAYxC,iBAAiB,gBAAgB,WACjEF,SAAS0C,eAAe,QAAQ5B,MAAMyvI,OAAS,OAC/CvwI,SAAS0C,eAAe,QAAQ1B,UAAUG,OAAO,YACjDnB,SAAS0C,eAAe,QAAQ1B,UAAUC,IAAI,cAClD,IAAG,GAEHjB,SAAS0C,eAAe,QAAQxC,iBAAiB,gBAAgB,WAC7DF,SAAS0C,eAAe,QAAQ1B,UAAUC,IAAI,SAClD,IAAG,EAAM,IAIjB,SAASuvI,GAAa5oI,GAClB,MAAMgvD,EAAYhvD,EAAIupE,MAAM,KAAK6P,MACjC,IAAIipC,EAEJ,OAAQrzD,GACJ,IAAK,MACL,IAAK,MACDqzD,EAAS,IAAIqmB,GAAoBD,IACjC,MACJ,IAAK,MACL,IAAK,OACDpmB,EAAS,IAAIoN,GAAWgZ,IACxB,MACJ,IAAK,OACDpmB,EAAS,IAAIqmB,EAAAA,WAAiBD,IAC9B,MACJ,IAAK,MACDpmB,EAAS,IAAIqmB,GAAiBD,IAC9B,MACJ,QACI,OAAOvlB,QAAQE,OAAO,IAAI9gH,MAAO,0BAAyB0sD,OAGlE,OAAO,IAAIk0D,SAAQ,CAACC,EAASC,KAQzBf,EAAOW,KAAKhjH,GAPI6oI,GAAa1lB,EAAQ0lB,KAClBvnB,SACF/oH,IACboC,QAAQ6+B,MAAM,4BAA8BjhC,EAAEkI,OAAOwY,KACrDmqG,EAAO7qH,EAAE,GAGgC,GAErD,CCvDO,MAAMuwI,GAAe,CACxBryE,KAKJ,SAA0BlxC,EAAQ9kB,EAAQsoI,EAAiBC,GAEvDF,GAAaG,OAAS,CAACC,EAAQC,KAC3B,OAAQH,KACJ,KAAK,EACDruI,QAAQq4D,KAAK,eACbztC,EAAOkE,SAAS7a,KAAK,GAAI,KAAM,IAC/B2W,EAAOuvB,IAAM,GACbg0F,GAAaplI,OAAS,KAElB6hB,EAAO6H,OAAO3sB,EAAOgpB,UACrBlE,EAAOkE,SAAS7a,IAAInO,EAAOgpB,SAAS9wB,EAAI,GAAI8H,EAAOgpB,SAAS5wB,EAAI,GAAI4H,EAAOgpB,SAAStM,EAAI,GAAG,EAM/F,MACJ,KAAK,EACDxiB,QAAQq4D,KAAK,aACb,MACJ,KAAK,EACDr4D,QAAQq4D,KAAK,kBACbvyD,EAAOpH,IAAIksB,GACXA,EAAOkE,SAAS7a,IAAI,EAAG,KAAM,IAC7B2W,EAAOjP,SAAS1H,IAAI,EAAG,IAAK,GAC5B2W,EAAOuvB,IAAM,GACbg0F,GAAaplI,OAAS,OACtB,MACJ,KAAK,EACD/I,QAAQC,IAAI,iBACZ6F,EAAOlH,OAAOgsB,GACd2jH,EAAO1gH,OAAOnvB,IAAIksB,GAClBA,EAAOkE,SAAS7a,KAAK,GAAI,GAAI,KAC7B2W,EAAOjP,SAAS1H,IAAI,EAAG,EAAG,GAC1B2W,EAAOuvB,IAAM,GACbg0F,GAAaplI,OAAS,OACtB,MACJ,KAAK,EACD/I,QAAQC,IAAI,2BACZ6F,EAAOpH,IAAIksB,GACXA,EAAOkE,SAAS7a,KAAK,GAAI,KAAM,IAC/B2W,EAAOjP,SAAS1H,IAAI,EAAG,KAAM,GAC7B2W,EAAOuvB,IAAM,GACbg0F,GAAaplI,OAAS,OACtB,MACJ,KAAK,EACD/I,QAAQC,IAAI,cACZ2qB,EAAOkE,SAAS7a,KAAK,GAAI,KAAM,IAC/B2W,EAAOuvB,IAAM,GACbg0F,GAAaplI,OAAS,KAElB6hB,EAAO6H,OAAO3sB,EAAOgpB,UACrBlE,EAAOkE,SAAS7a,IAAInO,EAAOgpB,SAAS9wB,EAAG8H,EAAOgpB,SAAS5wB,EAAI,GAAI4H,EAAOgpB,SAAStM,EAAI,GAAG,EAE1F,MACJ,QACI6rH,EAAW,EACXF,GAAaG,SACrB,EAGJH,GAAaG,QACjB,EAnEIA,OAASC,MACTxlI,OAAQA,QCLZ,SAAS0lI,GAAuBl5B,GAAQ,QAAa,IAATA,EAAmB,MAAM,IAAIm5B,eAAe,6DAAgE,OAAOn5B,CAAM,CAErK,SAASo5B,GAAeC,EAAUC,GAAcD,EAAS7qI,UAAYD,OAAOgrI,OAAOD,EAAW9qI,WAAY6qI,EAAS7qI,UAAUE,YAAc2qI,EAAUA,EAASG,UAAYF,CAAY,CAatL,IAaIG,GACAC,GACA,GA+CAC,GACAC,GACAC,GACAC,GAGAC,GA+BAC,GAs3BAC,GAgRJC,GA4SW5rI,GAAGwP,GACRq8H,GAGAC,GAzhDFC,GAAU,CACZC,UAAW,IACXC,QAAS,OACTC,eAAgB,EAChB/jE,MAAO,CACLgkE,WAAY,KAGZC,GAAY,CACd/rB,SAAU,GACVgsB,WAAW,EACXC,MAAO,GAKLC,GAAU,IACVC,GAAW,KACXC,GAAiB,EAAV5wI,KAAKI,GACZywI,GAAWD,GAAO,EAClBE,GAAQ,EACRC,GAAQ/wI,KAAKC,KACb+wI,GAAOhxI,KAAK6T,IACZo9H,GAAOjxI,KAAK8T,IACZo9H,GAAY,SAAmB9xI,GACjC,MAAwB,iBAAVA,CAChB,EACI+xI,GAAc,SAAqB/xI,GACrC,MAAwB,mBAAVA,CAChB,EACIgyI,GAAY,SAAmBhyI,GACjC,MAAwB,iBAAVA,CAChB,EACIiyI,GAAe,SAAsBjyI,GACvC,YAAwB,IAAVA,CAChB,EACIkyI,GAAY,SAAmBlyI,GACjC,MAAwB,iBAAVA,CAChB,EACImyI,GAAc,SAAqBnyI,GACrC,OAAiB,IAAVA,CACT,EACIoyI,GAAgB,WAClB,MAAyB,oBAAXnyI,MAChB,EACIoyI,GAAkB,SAAyBryI,GAC7C,OAAO+xI,GAAY/xI,IAAU8xI,GAAU9xI,EACzC,EACIsyI,GAAuC,mBAAhBxzB,aAA8BA,YAAYC,QAAU,WAAa,EAE5FwzB,GAAW1uI,MAAME,QACbyuI,GAAgB,oBAEpBC,GAAU,mCAEVC,GAAkB,8BACdC,GAAuB,mCAE3BC,GAAU,gBACNC,GAAqB,kBAEzBC,GAAW,wCAKPC,GAAW,CAAC,EACZC,GAAgB,CAAC,EAEjBC,GAAW,SAAkB76F,GAC/B,OAAQ46F,GAAgBE,GAAO96F,EAAO26F,MAAcI,EACtD,EACIC,GAAiB,SAAwB75F,EAAUv5C,GACrD,OAAOkB,QAAQkU,KAAK,mBAAoBmkC,EAAU,SAAUv5C,EAAO,wCACrE,EACIqzI,GAAQ,SAAev1H,EAASw1H,GAClC,OAAQA,GAAYpyI,QAAQkU,KAAK0I,EACnC,EACIy1H,GAAa,SAAoBnuI,EAAM0C,GACzC,OAAO1C,IAAS2tI,GAAS3tI,GAAQ0C,IAAQkrI,KAAkBA,GAAc5tI,GAAQ0C,IAAQirI,EAC3F,EACIS,GAAa,WACf,OAAO,CACT,EACIC,GAAuB,CACzBC,gBAAgB,EAChBC,SAAS,EACTC,MAAM,GAEJC,GAAsB,CACxBH,gBAAgB,EAChBE,MAAM,GAEJE,GAAgB,CAClBJ,gBAAgB,GAEdK,GAAiB,CAAC,EAClBC,GAAc,GACdC,GAAc,CAAC,EAEfC,GAAW,CAAC,EACZC,GAAW,CAAC,EACZC,GAAe,GACfC,GAAkB,GAClBC,GAAiB,GACjBC,GAAW,SAAkB7P,GAC/B,IACI8P,EACAtxI,EAFA8D,EAAS09H,EAAQ,GAKrB,GAFAwN,GAAUlrI,IAAW+qI,GAAY/qI,KAAY09H,EAAU,CAACA,MAElD8P,GAAiBxtI,EAAOytI,OAAS,CAAC,GAAGC,SAAU,CAInD,IAFAxxI,EAAImxI,GAAgB9wI,OAEbL,MAAQmxI,GAAgBnxI,GAAGyxI,WAAW3tI,KAE7CwtI,EAAgBH,GAAgBnxI,EAClC,CAIA,IAFAA,EAAIwhI,EAAQnhI,OAELL,KACLwhI,EAAQxhI,KAAOwhI,EAAQxhI,GAAGuxI,QAAU/P,EAAQxhI,GAAGuxI,MAAQ,IAAIG,GAAQlQ,EAAQxhI,GAAIsxI,MAAoB9P,EAAQ75H,OAAO3H,EAAG,GAGvH,OAAOwhI,CACT,EACImQ,GAAY,SAAmB7tI,GACjC,OAAOA,EAAOytI,OAASF,GAAS/7H,GAAQxR,IAAS,GAAGytI,KACtD,EACIK,GAAe,SAAsB9tI,EAAQuyC,EAAUtjC,GACzD,OAAQA,EAAIjP,EAAOuyC,KAAcw4F,GAAY97H,GAAKjP,EAAOuyC,KAAc04F,GAAah8H,IAAMjP,EAAOirC,cAAgBjrC,EAAOirC,aAAasH,IAAatjC,CACpJ,EACI8+H,GAAe,SAAsBC,EAAOrO,GAC9C,OAAQqO,EAAQA,EAAMllE,MAAM,MAAMpnE,QAAQi+H,IAASqO,CACrD,EAEAC,GAAS,SAAgBj1I,GACvB,OAAOY,KAAK2R,MAAc,IAARvS,GAAkB,KAAU,CAChD,EACIk1I,GAAgB,SAAuBl1I,GACzC,OAAOY,KAAK2R,MAAc,IAARvS,GAAoB,KAAY,CACpD,EAEAm1I,GAAiB,SAAwBrjG,EAAO9xC,GAC9C,IAAIo1I,EAAWp1I,EAAMuuC,OAAO,GACxBkR,EAAMtR,WAAWnuC,EAAMq1I,OAAO,IAElC,OADAvjG,EAAQ3D,WAAW2D,GACC,MAAbsjG,EAAmBtjG,EAAQ2N,EAAmB,MAAb21F,EAAmBtjG,EAAQ2N,EAAmB,MAAb21F,EAAmBtjG,EAAQ2N,EAAM3N,EAAQ2N,CACpH,EACI61F,GAAoB,SAA2BC,EAAUC,GAK3D,IAHA,IAAIllI,EAAIklI,EAAOjyI,OACXL,EAAI,EAEDqyI,EAASxlI,QAAQylI,EAAOtyI,IAAM,KAAOA,EAAIoN,IAEhD,OAAOpN,EAAIoN,CACb,EACImlI,GAAc,WAChB,IAEIvyI,EACAwyI,EAHAplI,EAAI0jI,GAAYzwI,OAChB8H,EAAI2oI,GAAY9uI,MAAM,GAO1B,IAHA+uI,GAAc,CAAC,EACfD,GAAYzwI,OAAS,EAEhBL,EAAI,EAAGA,EAAIoN,EAAGpN,KACjBwyI,EAAQrqI,EAAEnI,KACDwyI,EAAMC,QAAUD,EAAM33F,OAAO23F,EAAMC,MAAM,GAAID,EAAMC,MAAM,IAAI,GAAMA,MAAQ,EAExF,EACIC,GAAkB,SAAyB7yG,EAAW+e,EAAM4xF,EAAgBzyG,GAC9E+yG,GAAYzwI,SAAW4sI,IAAcsF,KACrC1yG,EAAUgb,OAAO+D,EAAM4xF,EAAgBzyG,GAASkvG,IAAcruF,EAAO,IAAM/e,EAAU8yG,UAAY9yG,EAAU+yG,WAC3G9B,GAAYzwI,SAAW4sI,IAAcsF,IACvC,EACIM,GAAqB,SAA4B/1I,GACnD,IAAI+E,EAAIopC,WAAWnuC,GACnB,OAAQ+E,GAAW,IAANA,KAAa/E,EAAQ,IAAIquE,MAAMwkE,IAAoBtvI,OAAS,EAAIwB,EAAI+sI,GAAU9xI,GAASA,EAAM0vE,OAAS1vE,CACrH,EACIg2I,GAAe,SAAsB16G,GACvC,OAAOA,CACT,EACI26G,GAAe,SAAsBnuI,EAAKouI,GAC5C,IAAK,IAAI56G,KAAK46G,EACZ56G,KAAKxzB,IAAQA,EAAIwzB,GAAK46G,EAAS56G,IAGjC,OAAOxzB,CACT,EAQIorI,GAAS,SAAgBtrI,EAAMuuI,GACjC,IAAK,IAAI76G,KAAK66G,EACZvuI,EAAK0zB,GAAK66G,EAAQ76G,GAGpB,OAAO1zB,CACT,EACIwuI,GAAa,SAASA,EAAWxuI,EAAMuuI,GACzC,IAAK,IAAI76G,KAAK66G,EACN,cAAN76G,GAA2B,gBAANA,GAA6B,cAANA,IAAsB1zB,EAAK0zB,GAAK42G,GAAUiE,EAAQ76G,IAAM86G,EAAWxuI,EAAK0zB,KAAO1zB,EAAK0zB,GAAK,CAAC,GAAI66G,EAAQ76G,IAAM66G,EAAQ76G,IAGlK,OAAO1zB,CACT,EACIyuI,GAAiB,SAAwBvuI,EAAKwuI,GAChD,IACIh7G,EADAtlB,EAAO,CAAC,EAGZ,IAAKslB,KAAKxzB,EACRwzB,KAAKg7G,IAActgI,EAAKslB,GAAKxzB,EAAIwzB,IAGnC,OAAOtlB,CACT,EACIugI,GAAmB,SAA0BC,GAC/C,IAhCuDC,EAgCnD/4G,EAAS84G,EAAK94G,QAAU0yG,GACxBzJ,EAAO6P,EAAKE,WAjCuCD,EAiCNlE,GAASiE,EAAKE,WAhCxD,SAAU5uI,EAAKouI,GACpB,IAAK,IAAI56G,KAAK46G,EACZ56G,KAAKxzB,GAAa,aAANwzB,GAAoBm7G,GAAyB,SAANn7G,IAAiBxzB,EAAIwzB,GAAK46G,EAAS56G,GAE1F,GA4B6E26G,GAE7E,GAAI9D,GAAYqE,EAAKG,SACnB,KAAOj5G,GACLipG,EAAK6P,EAAM94G,EAAO84G,KAAKN,UACvBx4G,EAASA,EAAOA,QAAUA,EAAOk5G,IAIrC,OAAOJ,CACT,EASIK,GAAqB,SAA4Bn5G,EAAQwD,EAAO41G,EAAWC,EAAUC,QACrE,IAAdF,IACFA,EAAY,eAGG,IAAbC,IACFA,EAAW,SAGb,IACIxlI,EADA0lI,EAAOv5G,EAAOq5G,GAGlB,GAAIC,EAGF,IAFAzlI,EAAI2vB,EAAM81G,GAEHC,GAAQA,EAAKD,GAAUzlI,GAC5B0lI,EAAOA,EAAKC,MAoBhB,OAhBID,GACF/1G,EAAMi2G,MAAQF,EAAKE,MACnBF,EAAKE,MAAQj2G,IAEbA,EAAMi2G,MAAQz5G,EAAOo5G,GACrBp5G,EAAOo5G,GAAa51G,GAGlBA,EAAMi2G,MACRj2G,EAAMi2G,MAAMD,MAAQh2G,EAEpBxD,EAAOq5G,GAAY71G,EAGrBA,EAAMg2G,MAAQD,EACd/1G,EAAMxD,OAASwD,EAAM01G,IAAMl5G,EACpBwD,CACT,EACIk2G,GAAwB,SAA+B15G,EAAQwD,EAAO41G,EAAWC,QACjE,IAAdD,IACFA,EAAY,eAGG,IAAbC,IACFA,EAAW,SAGb,IAAIE,EAAO/1G,EAAMg2G,MACbzyI,EAAOy8B,EAAMi2G,MAEbF,EACFA,EAAKE,MAAQ1yI,EACJi5B,EAAOo5G,KAAe51G,IAC/BxD,EAAOo5G,GAAaryI,GAGlBA,EACFA,EAAKyyI,MAAQD,EACJv5G,EAAOq5G,KAAc71G,IAC9BxD,EAAOq5G,GAAYE,GAGrB/1G,EAAMi2G,MAAQj2G,EAAMg2G,MAAQh2G,EAAMxD,OAAS,IAC7C,EACI25G,GAAoB,SAA2Bn2G,EAAOo2G,GACxDp2G,EAAMxD,UAAY45G,GAA6Bp2G,EAAMxD,OAAO65G,qBAAuBr2G,EAAMxD,OAAO59B,QAAUohC,EAAMxD,OAAO59B,OAAOohC,GAC9HA,EAAMs2G,KAAO,CACf,EACIC,GAAW,SAAkB10G,EAAW7B,GAC1C,GAAI6B,KAAe7B,GAASA,EAAMu8E,KAAO16E,EAAU20G,MAAQx2G,EAAMs8E,OAAS,GAIxE,IAFA,IAAInyG,EAAI03B,EAED13B,GACLA,EAAEssI,OAAS,EACXtsI,EAAIA,EAAEqyB,OAIV,OAAOqF,CACT,EAaI60G,GAAiB,SAAwBlC,EAAOmC,EAAWnE,EAAgBzyG,GAC7E,OAAOy0G,EAAMI,WAAa3F,GAAauF,EAAMI,SAASgC,OAAOjE,IAAuB6B,EAAMc,KAAKuB,kBAAoBrC,EAAMc,KAAKwB,YAActC,EAAMI,SAAS/3F,OAAO85F,GAAW,EAAM52G,GACrL,EACIg3G,GAAwB,SAASA,EAAsBl1G,GACzD,OAAQA,GAAaA,EAAUm1G,KAAOD,EAAsBl1G,EAAUrF,OACxE,EACIy6G,GAAwB,SAA+Bp1G,GACzD,OAAOA,EAAUq1G,QAAUC,GAAgBt1G,EAAUu1G,OAAQv1G,EAAYA,EAAUqiF,WAAariF,EAAUw1G,SAAWx1G,EAAY,CACnI,EAEAs1G,GAAkB,SAAyBG,EAAOC,GAChD,IAAIC,EAAQ93I,KAAKK,MAAMu3I,GAASC,GAChC,OAAOD,GAASE,IAAUF,EAAQE,EAAQ,EAAIA,CAChD,EACIC,GAA0B,SAAiCC,EAAY13G,GACzE,OAAQ03G,EAAa13G,EAAMs8E,QAAUt8E,EAAMg3G,KAAOh3G,EAAMg3G,KAAO,EAAI,EAAIh3G,EAAMy2G,OAASz2G,EAAM23G,gBAAkB33G,EAAM43G,MACtH,EACIC,GAAU,SAAiBh2G,GAC7B,OAAOA,EAAU06E,KAAOy3B,GAAcnyG,EAAUy6E,QAAUz6E,EAAU+1G,MAAQl4I,KAAKwS,IAAI2vB,EAAUm1G,KAAOn1G,EAAUi2G,MAAQzH,KAAa,GACvI,EACI0H,GAAiB,SAAwBl2G,EAAW80G,GAEtD,IAAIn6G,EAASqF,EAAU6zG,IAUvB,OARIl5G,GAAUA,EAAOw7G,mBAAqBn2G,EAAUm1G,MAClDn1G,EAAUy6E,OAAS03B,GAAcx3G,EAAOy7G,OAASp2G,EAAUm1G,IAAM,EAAIL,EAAY90G,EAAUm1G,MAAQn1G,EAAU40G,OAAS50G,EAAU81G,gBAAkB91G,EAAU+1G,OAASjB,IAAc90G,EAAUm1G,MAE7La,GAAQh2G,GAERrF,EAAOi6G,QAAUF,GAAS/5G,EAAQqF,IAG7BA,CACT,EAYAq2G,GAAiB,SAAwBC,EAAUn4G,GACjD,IAAI3vB,EAYJ,IAVI2vB,EAAMi4G,QAAUj4G,EAAMw2G,MAAQx2G,EAAM20G,UAAY30G,EAAMs8E,OAAS67B,EAASF,QAAUj4G,EAAMw2G,OAASx2G,EAAMthC,QAEzG2R,EAAIonI,GAAwBU,EAASC,UAAWp4G,KAE3CA,EAAMw2G,MAAQ6B,GAAO,EAAGr4G,EAAM23G,gBAAiBtnI,GAAK2vB,EAAMo3G,OAAS/G,KACtErwG,EAAM6c,OAAOxsC,GAAG,IAKhBkmI,GAAS4B,EAAUn4G,GAAO01G,KAAOyC,EAASxD,UAAYwD,EAASF,OAASE,EAAS3B,MAAQ2B,EAASnB,IAAK,CAEzG,GAAImB,EAAS3B,KAAO2B,EAASj0B,WAG3B,IAFA7zG,EAAI8nI,EAEG9nI,EAAEqlI,KACPrlI,EAAE+nI,WAAa,GAAK/nI,EAAEsmI,UAAUtmI,EAAE+mI,QAElC/mI,EAAIA,EAAEqlI,IAIVyC,EAASG,QAAS,IACpB,CACF,EACIC,GAAiB,SAAwBJ,EAAUn4G,EAAOlR,EAAU0pH,GAWtE,OAVAx4G,EAAMxD,QAAU25G,GAAkBn2G,GAClCA,EAAMs8E,OAAS03B,IAAelD,GAAUhiH,GAAYA,EAAWA,GAAYqpH,IAAajJ,GAAkBuJ,GAAeN,EAAUrpH,EAAUkR,GAASm4G,EAASF,OAASj4G,EAAM04G,QAC9K14G,EAAMu8E,KAAOy3B,GAAch0G,EAAMs8E,QAAUt8E,EAAM23G,gBAAkBj4I,KAAKwS,IAAI8tB,EAAMwiF,cAAgB,IAElGmzB,GAAmBwC,EAAUn4G,EAAO,SAAU,QAASm4G,EAASQ,MAAQ,SAAW,GAEnFC,GAAmB54G,KAAWm4G,EAASU,QAAU74G,GACjDw4G,GAAcN,GAAeC,EAAUn4G,GACvCm4G,EAASnB,IAAM,GAAKe,GAAeI,EAAUA,EAASf,QAE/Ce,CACT,EACIW,GAAiB,SAAwBj3G,EAAWk3G,GACtD,OAAQlH,GAASmH,eAAiB9G,GAAe,gBAAiB6G,KAAalH,GAASmH,cAAclK,OAAOiK,EAASl3G,EACxH,EACIo3G,GAAoB,SAA2BzE,EAAO5zF,EAAM7gB,EAAOyyG,EAAgB8E,GAGrF,OAFA4B,GAAW1E,EAAO5zF,EAAM02F,GAEnB9C,EAAMG,UAIN50G,GAASy0G,EAAM2E,MAAQlK,KAAeuF,EAAMgC,OAA4B,IAApBhC,EAAMc,KAAK8D,OAAmB5E,EAAMgC,MAAQhC,EAAMc,KAAK8D,OAAS7J,KAAuB8J,GAAQx4F,OACtJiyF,GAAY3xI,KAAKqzI,GAEjBA,EAAMC,MAAQ,CAAC6C,EAAO9E,GACf,QAJT,EAHS,CASX,EACI8G,GAA+B,SAASA,EAA6BC,GACvE,IAAI/8G,EAAS+8G,EAAK/8G,OAClB,OAAOA,GAAUA,EAAOw6G,KAAOx6G,EAAOm4G,WAAan4G,EAAOg9G,QAAUh9G,EAAO47G,UAAY,GAAKkB,EAA6B98G,GAC3H,EAEAo8G,GAAqB,SAA4Ba,GAC/C,IAAI10I,EAAO00I,EAAM10I,KACjB,MAAgB,gBAATA,GAAmC,YAATA,CACnC,EAwFI20I,GAAe,SAAsB73G,EAAWqiF,EAAUy1B,EAAaC,GACzE,IAAIz4H,EAAS0gB,EAAUq1G,QACnB2C,EAAM7F,GAAc9vB,IAAa,EACjC41B,EAAgBj4G,EAAUu1G,OAASv1G,EAAU+1G,MAOjD,OANAkC,IAAkBF,IAAkB/3G,EAAUo2G,OAAS4B,EAAMh4G,EAAU20G,MACvE30G,EAAU20G,KAAOqD,EACjBh4G,EAAU+1G,MAASz2H,EAAeA,EAAS,EAAI,KAAO6yH,GAAc6F,GAAO14H,EAAS,GAAK0gB,EAAUw1G,QAAUl2H,GAAjF04H,EAC5BC,EAAgB,IAAMF,GAAiB7B,GAAel2G,EAAWA,EAAUu1G,OAASv1G,EAAU+1G,MAAQkC,GACtGj4G,EAAUrF,QAAUq7G,GAAQh2G,GAC5B83G,GAAepD,GAAS10G,EAAUrF,OAAQqF,GACnCA,CACT,EACIk4G,GAAyB,SAAgCl4G,GAC3D,OAAOA,aAAqBm4G,GAAWzD,GAAS10G,GAAa63G,GAAa73G,EAAWA,EAAU20G,KACjG,EACIyD,GAAgB,CAClB39B,OAAQ,EACRoG,QAAS4vB,GACTqF,cAAerF,IAEbmG,GAAiB,SAASA,EAAe52G,EAAW/S,EAAUorH,GAChE,IAIAl4I,EACIqV,EACA8iI,EANAC,EAASv4G,EAAUu4G,OACnBC,EAASx4G,EAAUg3G,SAAWoB,GAC9BK,EAAkBz4G,EAAUqiF,YAAcksB,GAAUiK,EAAO33B,SAAQ,GAAS7gF,EAAU20G,KAM1F,OAAI5F,GAAU9hH,KAAc6F,MAAM7F,IAAaA,KAAYsrH,IAEzD/iI,EAASyX,EAASue,OAAO,GACzB8sG,EAAoC,MAAxBrrH,EAASqlH,QAAQ,GAC7BnyI,EAAI8sB,EAASjgB,QAAQ,KAEN,MAAXwI,GAA6B,MAAXA,GACpBrV,GAAK,IAAM8sB,EAAWA,EAASnpB,QAAQ,IAAK,MACzB,MAAX0R,EAAiBgjI,EAAO/9B,OAAS+9B,EAAO33B,QAAQ23B,EAAOnD,SAAW,KAAOjqG,WAAWne,EAASqlH,OAAO,KAAO,IAAMgG,GAAan4I,EAAI,EAAIq4I,EAASH,GAAkBvC,gBAAkB,IAAM,IAG/L31I,EAAI,GACN8sB,KAAYsrH,IAAWA,EAAOtrH,GAAYwrH,GACnCF,EAAOtrH,KAGhBzX,EAAS41B,WAAWne,EAASue,OAAOrrC,EAAI,GAAK8sB,EAASqlH,OAAOnyI,EAAI,IAE7Dm4I,GAAaD,IACf7iI,EAASA,EAAS,KAAOg6H,GAAS6I,GAAoBA,EAAiB,GAAKA,GAAkBvC,iBAGzF31I,EAAI,EAAIy2I,EAAe52G,EAAW/S,EAASqlH,OAAO,EAAGnyI,EAAI,GAAIk4I,GAAoB7iI,EAASijI,EAAkBjjI,IAGlG,MAAZyX,EAAmBwrH,GAAmBxrH,CAC/C,EACIyrH,GAAmB,SAA0B9rI,EAAMkxD,EAAQw4E,GAC7D,IAGIqC,EACAh+G,EAJAi+G,EAAW3J,GAAUnxE,EAAO,IAC5B+6E,GAAaD,EAAW,EAAI,IAAMhsI,EAAO,EAAI,EAAI,GACjD6mI,EAAO31E,EAAO+6E,GAOlB,GAHAD,IAAanF,EAAKpxB,SAAWvkD,EAAO,IACpC21E,EAAK94G,OAAS27G,EAEV1pI,EAAM,CAIR,IAHA+rI,EAASlF,EACT94G,EAAS27G,EAEF37G,KAAY,oBAAqBg+G,IAEtCA,EAASh+G,EAAO84G,KAAKN,UAAY,CAAC,EAClCx4G,EAASy0G,GAAYz0G,EAAO84G,KAAKG,UAAYj5G,EAAOA,OAGtD84G,EAAKuB,gBAAkB5F,GAAYuJ,EAAO3D,iBAC1CpoI,EAAO,EAAI6mI,EAAKqF,aAAe,EAAIrF,EAAKsF,QAAUj7E,EAAO+6E,EAAY,EACvE,CAEA,OAAO,IAAIG,GAAMl7E,EAAO,GAAI21E,EAAM31E,EAAO+6E,EAAY,GACvD,EACII,GAAqB,SAA4Bh8I,EAAO2mI,GAC1D,OAAO3mI,GAAmB,IAAVA,EAAc2mI,EAAK3mI,GAAS2mI,CAC9C,EACI4S,GAAS,SAAgBh5I,EAAK4Q,EAAKnR,GACrC,OAAOA,EAAQO,EAAMA,EAAMP,EAAQmR,EAAMA,EAAMnR,CACjD,EACIi8I,GAAU,SAAiBj8I,EAAOiW,GACpC,OAAQ67H,GAAU9xI,KAAYiW,EAAI68H,GAAS1kG,KAAKpuC,IAAeiW,EAAE,GAAP,EAC5D,EAOIimI,GAAS,GAAGh3I,MACZi3I,GAAe,SAAsBn8I,EAAOo8I,GAC9C,OAAOp8I,GAASkyI,GAAUlyI,IAAU,WAAYA,KAAWo8I,IAAap8I,EAAMuD,QAAUvD,EAAMuD,OAAS,KAAKvD,GAASkyI,GAAUlyI,EAAM,OAASA,EAAMq8I,UAAYr8I,IAAUqwI,EAC5K,EAaA73H,GAAU,SAAiBxY,EAAOo4C,EAAOkkG,GACvC,OAAO,KAAalkG,GAAS,GAASmkG,SAAW,GAASA,SAASv8I,IAAS8xI,GAAU9xI,IAAWs8I,IAAiBhM,IAAiBkM,KAAqEjK,GAASvyI,GAbpM,SAAkBy8I,EAAIH,EAAcI,GAKjD,YAJoB,IAAhBA,IACFA,EAAc,IAGTD,EAAG/zI,SAAQ,SAAU1I,GAC1B,IAAI28I,EAEJ,OAAO7K,GAAU9xI,KAAWs8I,GAAgBH,GAAan8I,EAAO,IAAM28I,EAAeD,GAAar6I,KAAKsvF,MAAMgrD,EAAcnkI,GAAQxY,IAAU08I,EAAYr6I,KAAKrC,EAChK,KAAM08I,CACR,CAG4NE,CAAS58I,EAAOs8I,GAAgBH,GAAan8I,GAASk8I,GAAO13I,KAAKxE,EAAO,GAAKA,EAAQ,CAACA,GAAS,GAA5Kk8I,GAAO13I,MAAM4zC,GAASm4F,IAAMsM,iBAAiB78I,GAAQ,EACrM,EACIu8I,GAAW,SAAkBv8I,GAE/B,OADAA,EAAQwY,GAAQxY,GAAO,IAAMqzI,GAAM,kBAAoB,CAAC,EACjD,SAAUp9H,GACf,IAAI6mI,EAAK98I,EAAM+8I,SAAW/8I,EAAMg9I,eAAiBh9I,EACjD,OAAOwY,GAAQvC,EAAG6mI,EAAGD,iBAAmBC,EAAKA,IAAO98I,EAAQqzI,GAAM,kBAAoB9C,GAAKjoI,cAAc,OAAStI,EACpH,CACF,EACIi9I,GAAU,SAAiB5xI,GAC7B,OAAOA,EAAEk8D,MAAK,WACZ,MAAO,GAAK3mE,KAAKiQ,QACnB,GACF,EAGAqsI,GAAa,SAAoBjnI,GAC/B,GAAI87H,GAAY97H,GACd,OAAOA,EAGT,IAAIugI,EAAOtE,GAAUj8H,GAAKA,EAAI,CAC5BknI,KAAMlnI,GAGRmnI,EAAOC,GAAW7G,EAAK4G,MACnB/3I,EAAOmxI,EAAKnxI,MAAQ,EACpBuC,EAAOumC,WAAWqoG,EAAK5uI,OAAS,EAChCq7B,EAAQ,CAAC,EACTq6G,EAAYj4I,EAAO,GAAKA,EAAO,EAC/Bk4I,EAAS1nH,MAAMxwB,IAASi4I,EACxB50H,EAAO8tH,EAAK9tH,KACZ80H,EAASn4I,EACTo4I,EAASp4I,EAab,OAXIysI,GAAUzsI,GACZm4I,EAASC,EAAS,CAChB3kI,OAAQ,GACR4kI,MAAO,GACPj+F,IAAK,GACLp6C,IAAS,GACDi4I,GAAaC,IACvBC,EAASn4I,EAAK,GACdo4I,EAASp4I,EAAK,IAGT,SAAUnC,EAAG8D,EAAQqE,GAC1B,IAEIsyI,EACAC,EACA1+I,EACAE,EACAgM,EACA4mB,EACA7gB,EACA5Q,EACAs9I,EAVAvtI,GAAKjF,GAAKmrI,GAAMjzI,OAChBu6I,EAAY76G,EAAM3yB,GAWtB,IAAKwtI,EAAW,CAGd,KAFAD,EAAuB,SAAdrH,EAAKuH,KAAkB,GAAKvH,EAAKuH,MAAQ,CAAC,EAAGzM,KAAU,IAEnD,CAGX,IAFAngI,GAAOmgI,GAEAngI,GAAOA,EAAM9F,EAAEwyI,KAAUG,wBAAwBljH,OAAS+iH,EAASvtI,IAE1EutI,GACF,CAQA,IANAC,EAAY76G,EAAM3yB,GAAK,GACvBqtI,EAAUJ,EAAS38I,KAAKL,IAAIs9I,EAAQvtI,GAAKktI,EAAS,GAAKn4I,EAAOw4I,EAC9DD,EAAUC,IAAWvM,GAAU,EAAIiM,EAASjtI,EAAImtI,EAASI,EAAS,GAAKx4I,EAAOw4I,EAAS,EACvF1sI,EAAM,EACN5Q,EAAM+wI,GAEDt/G,EAAI,EAAGA,EAAI1hB,EAAG0hB,IACjB9yB,EAAI8yB,EAAI6rH,EAASF,EACjBv+I,EAAIw+I,GAAW5rH,EAAI6rH,EAAS,GAC5BC,EAAU9rH,GAAK5mB,EAAKsd,EAA8B9nB,KAAKwS,IAAa,MAATsV,EAAetpB,EAAIF,GAAnDyyI,GAAMzyI,EAAIA,EAAIE,EAAIA,GAC7CgM,EAAI+F,IAAQA,EAAM/F,GAClBA,EAAI7K,IAAQA,EAAM6K,GAGX,WAAT/F,GAAqB43I,GAAQa,GAC7BA,EAAU3sI,IAAMA,EAAM5Q,EACtBu9I,EAAUv9I,IAAMA,EAChBu9I,EAAU7nI,EAAI3F,GAAK69B,WAAWqoG,EAAKyH,SAAW9vG,WAAWqoG,EAAK2G,OAASU,EAASvtI,EAAIA,EAAI,EAAKoY,EAA+C,MAATA,EAAepY,EAAIutI,EAASA,EAA3Dj9I,KAAKuQ,IAAI0sI,EAAQvtI,EAAIutI,KAAiD,IAAe,UAATx4I,GAAoB,EAAI,GACxMy4I,EAAUxpI,EAAIhE,EAAI,EAAI1I,EAAO0I,EAAI1I,EACjCk2I,EAAU9vH,EAAIiuH,GAAQzF,EAAKyH,QAAUzH,EAAK2G,OAAS,EAEnDC,EAAOA,GAAQ9sI,EAAI,EAAI4tI,GAAYd,GAAQA,CAC7C,CAGA,OADA9sI,GAAKwtI,EAAU56I,GAAK46I,EAAUv9I,KAAOu9I,EAAU3sI,KAAO,EAC/C+jI,GAAc4I,EAAUxpI,GAAK8oI,EAAOA,EAAK9sI,GAAKA,GAAKwtI,EAAU7nI,GAAK6nI,EAAU9vH,CACrF,CACF,EACImwH,GAAiB,SAAwBloI,GAE3C,IAAIqlB,EAAI16B,KAAK8Q,IAAI,KAAMuE,EAAI,IAAI65D,MAAM,KAAK,IAAM,IAAIvsE,QAEpD,OAAO,SAAU66I,GACf,IAAIr5I,EAAImwI,GAAct0I,KAAK2R,MAAM47B,WAAWiwG,GAAOnoI,GAAKA,EAAIqlB,GAE5D,OAAQv2B,EAAIA,EAAI,GAAKu2B,GAAK02G,GAAUoM,GAAO,EAAInC,GAAQmC,GACzD,CACF,EACIC,GAAO,SAAcC,EAAQt+I,GAC/B,IACIqtB,EACAkxH,EAFAx6I,EAAUwuI,GAAS+L,GAkBvB,OAdKv6I,GAAWmuI,GAAUoM,KACxBjxH,EAAStpB,EAAUu6I,EAAOjxH,QAAUikH,GAEhCgN,EAAOp7G,QACTo7G,EAAS9lI,GAAQ8lI,EAAOp7G,SAEpBq7G,GAAQvM,GAAUsM,EAAO,OAC3BjxH,GAAUA,IAGZixH,EAASH,GAAeG,EAAOE,YAI5BxC,GAAmBh8I,EAAQ+D,EAAmCguI,GAAYuM,GAAU,SAAUF,GAEnG,OADAG,EAAOD,EAAOF,GACPx9I,KAAKwS,IAAImrI,EAAOH,IAAQ/wH,EAASkxH,EAAOH,CACjD,EAAI,SAAUA,GASZ,IARA,IAKI39I,EACAC,EANAxB,EAAIivC,WAAWowG,EAAOH,EAAIl/I,EAAIk/I,GAC9Bh/I,EAAI+uC,WAAWowG,EAAOH,EAAIh/I,EAAI,GAC9BmB,EAAM+wI,GACNmN,EAAU,EACVv7I,EAAIo7I,EAAO/6I,OAIRL,MAIHzC,EAHE89I,GACF99I,EAAK69I,EAAOp7I,GAAGhE,EAAIA,GAETuB,GADVC,EAAK49I,EAAOp7I,GAAG9D,EAAIA,GACCsB,EAEfE,KAAKwS,IAAIkrI,EAAOp7I,GAAKhE,IAGnBqB,IACPA,EAAME,EACNg+I,EAAUv7I,GAKd,OADAu7I,GAAWpxH,GAAU9sB,GAAO8sB,EAASixH,EAAOG,GAAWL,EAChDG,GAAQE,IAAYL,GAAOpM,GAAUoM,GAAOK,EAAUA,EAAUxC,GAAQmC,EACjF,EA7B4CD,GAAeG,GA8B7D,EACIztI,GAAS,SAAgBtQ,EAAK4Q,EAAKutI,EAAmBC,GACxD,OAAO3C,GAAmBzJ,GAAShyI,IAAQ4Q,GAA4B,IAAtButI,KAAgCA,EAAoB,IAAMC,GAAgB,WACzH,OAAOpM,GAAShyI,GAAOA,KAAOK,KAAKiQ,SAAWtQ,EAAIgD,UAAYm7I,EAAoBA,GAAqB,QAAUC,EAAiBD,EAAoB,EAAI99I,KAAK8Q,IAAI,IAAKgtI,EAAoB,IAAIn7I,OAAS,GAAK,IAAM3C,KAAKK,MAAML,KAAK2R,OAAOhS,EAAMm+I,EAAoB,EAAI99I,KAAKiQ,UAAYM,EAAM5Q,EAA0B,IAApBm+I,IAA4BA,GAAqBA,EAAoBC,GAAkBA,CAC/X,GACF,EAoBIC,GAAa,SAAoBvzI,EAAGwzI,EAAS7+I,GAC/C,OAAOg8I,GAAmBh8I,GAAO,SAAUW,GACzC,OAAO0K,IAAIwzI,EAAQl+I,GACrB,GACF,EAgBIm+I,GAAiB,SAAwB9+I,GAS3C,IAPA,IAEIkD,EACA67I,EACAt/F,EACA17C,EALAkzI,EAAO,EACPnjI,EAAI,KAMC5Q,EAAIlD,EAAM+P,QAAQ,UAAWknI,KACpCx3F,EAAMz/C,EAAM+P,QAAQ,IAAK7M,GACzBa,EAAkC,MAAxB/D,EAAMuuC,OAAOrrC,EAAI,GAC3B67I,EAAO/+I,EAAMq1I,OAAOnyI,EAAI,EAAGu8C,EAAMv8C,EAAI,GAAGmrE,MAAMtqE,EAAU8uI,GAAqBL,IAC7E1+H,GAAK9T,EAAMq1I,OAAO4B,EAAM/zI,EAAI+zI,GAAQpmI,GAAO9M,EAAUg7I,GAAQA,EAAK,GAAIh7I,EAAU,GAAKg7I,EAAK,IAAKA,EAAK,IAAM,MAC1G9H,EAAOx3F,EAAM,EAGf,OAAO3rC,EAAI9T,EAAMq1I,OAAO4B,EAAMj3I,EAAMuD,OAAS0zI,EAC/C,EACI+H,GAAW,SAAkBC,EAAOC,EAAOC,EAAQC,EAAQp/I,GAC7D,IAAIq/I,EAAUH,EAAQD,EAClBK,EAAWF,EAASD,EACxB,OAAOnD,GAAmBh8I,GAAO,SAAUA,GACzC,OAAOm/I,IAAWn/I,EAAQi/I,GAASI,EAAUC,GAAY,EAC3D,GACF,EA2DIC,GAAuB,SAA8BlG,EAAUmG,EAAUC,GAE3E,IAEInkH,EACAgE,EACAgtF,EAJAgvB,EAASjC,EAASiC,OAClB/6I,EAAM+wI,GAKV,IAAKh2G,KAAKggH,GACRh8G,EAAWg8G,EAAOhgH,GAAKkkH,GAER,KAAQC,GAAYngH,GAAY/+B,GAAO++B,EAAW1+B,KAAKwS,IAAIksB,MACxEgtF,EAAQhxF,EACR/6B,EAAM++B,GAIV,OAAOgtF,CACT,EACIozB,GAAY,SAAmB38G,EAAWpzB,EAAMgwI,GAClD,IAII9+E,EACAzoB,EACA5wC,EANAyO,EAAI8sB,EAAUyzG,KACd3rH,EAAW5U,EAAEtG,GACbiwI,EAAc,GACdjgI,EAAUojB,EAAU88G,KAKxB,GAAKh1H,EAWL,OAPAg2C,EAAS5qD,EAAEtG,EAAO,UAClByoC,EAAQniC,EAAE6pI,eAAiB/8G,EAC3B48G,GAAoB3L,GAAYzwI,QAAUkyI,KAE1C91H,IAAY,GAAWA,GACvBnY,EAASq5D,EAASh2C,EAAS8mE,MAAMv5C,EAAOyoB,GAAUh2C,EAASrmB,KAAK4zC,GAChE,GAAWwnG,EACJp4I,CACT,EACIu4I,GAAa,SAAoBh9G,GAKnC,OAJAs0G,GAAkBt0G,GAElBA,EAAUi9G,eAAiBj9G,EAAUi9G,cAAcpM,OAAOzD,IAC1DptG,EAAUk9G,WAAa,GAAKP,GAAU38G,EAAW,eAC1CA,CACT,EAEIm9G,GAAuB,GACvBC,GAAgB,SAAuBC,GACzC,GAAIhO,MAAmBgO,EAAQ,CAI7B,IAAIh7I,GAFJg7I,GAAUA,EAAOh7I,MAAQg7I,EAAgB,SAAKA,GAE5Bh7I,KACdi7I,EAAStO,GAAYqO,GACrBE,EAASl7I,IAASi7I,GAAUD,EAAOpjF,KAAO,WAC5Cp6D,KAAK29I,OAAS,EAChB,EAAIH,EAEJI,EAAmB,CACjBxjF,KAAMw2E,GACNz1F,OAAQ0iG,GACR7gJ,IAAK8gJ,GACL9M,KAAM+M,GACNC,SAAUC,GACVC,QAAS,GAEPC,EAAU,CACZpM,WAAY,EACZlpI,IAAK,EACLu1I,UAAWC,GACXC,QAAS,CAAC,EACV7qB,SAAU,GAKZ,GAFAmmB,KAEI4D,IAAWE,EAAQ,CACrB,GAAIpM,GAAS9uI,GACX,OAGF6wI,GAAaqK,EAAQrK,GAAaI,GAAe+J,EAAQI,GAAmBO,IAG5E7N,GAAOoN,EAAOr7I,UAAWiuI,GAAOsN,EAAkBnK,GAAe+J,EAAQW,KAGzE7M,GAASoM,EAAO50I,KAAOtG,GAAQk7I,EAE3BF,EAAOzL,aACTN,GAAgBhyI,KAAKi+I,GAErBvM,GAAe3uI,GAAQ,GAGzBA,GAAiB,QAATA,EAAiB,MAAQA,EAAKmpC,OAAO,GAAGshC,cAAgBzqE,EAAKiwI,OAAO,IAAM,QACpF,CAEA9B,GAAWnuI,EAAMk7I,GAEjBF,EAAO/pB,UAAY+pB,EAAO/pB,SAAS8c,GAAMmN,EAAQa,GACnD,MACEf,GAAUF,GAAqB79I,KAAK+9I,EAExC,EAOAgB,GAAO,IACHC,GAAe,CACjBC,KAAM,CAAC,EAAGF,GAAMA,IAChBG,KAAM,CAAC,EAAGH,GAAM,GAChBI,OAAQ,CAAC,IAAK,IAAK,KACnBC,MAAO,CAAC,EAAG,EAAG,GACdC,OAAQ,CAAC,IAAK,EAAG,GACjBC,KAAM,CAAC,EAAG,IAAK,KACfC,KAAM,CAAC,EAAG,EAAGR,IACbS,KAAM,CAAC,EAAG,EAAG,KACbC,MAAO,CAACV,GAAMA,GAAMA,IACpBW,MAAO,CAAC,IAAK,IAAK,GAClBC,OAAQ,CAACZ,GAAMA,GAAM,GACrBa,OAAQ,CAACb,GAAM,IAAK,GACpBc,KAAM,CAAC,IAAK,IAAK,KACjBC,OAAQ,CAAC,IAAK,EAAG,KACjBC,MAAO,CAAC,EAAG,IAAK,GAChBC,IAAK,CAACjB,GAAM,EAAG,GACfkB,KAAM,CAAClB,GAAM,IAAK,KAClBmB,KAAM,CAAC,EAAGnB,GAAMA,IAChB56G,YAAa,CAAC46G,GAAMA,GAAMA,GAAM,IAKlCoB,GAAO,SAAc5mI,EAAGymH,EAAIogB,GAE1B,OAAY,GADZ7mI,GAAKA,EAAI,EAAI,EAAIA,EAAI,GAAK,EAAI,GACd,EAAIymH,GAAMogB,EAAKpgB,GAAMzmH,EAAI,EAAIA,EAAI,GAAK6mI,EAAS,EAAJ7mI,EAAQ,EAAIymH,GAAMogB,EAAKpgB,IAAO,EAAI,EAAIzmH,GAAK,EAAIymH,GAAM+e,GAAO,GAAK,CAC9H,EACIsB,GAAa,SAAoBzsI,EAAG0sI,EAAOC,GAC7C,IACIh3I,EACA+P,EACArH,EACAsH,EACA9H,EACAxD,EACAa,EACA5Q,EACA6K,EACAy3I,EAVAx3I,EAAK4K,EAAyB+7H,GAAU/7H,GAAK,CAACA,GAAK,GAAIA,GAAK,EAAImrI,GAAMnrI,EAAImrI,IAAQ,EAAzEC,GAAaI,MAY1B,IAAKp2I,EAAG,CAMN,GALqB,MAAjB4K,EAAEo/H,QAAQ,KAEZp/H,EAAIA,EAAEo/H,OAAO,EAAGp/H,EAAE1S,OAAS,IAGzB89I,GAAaprI,GACf5K,EAAIg2I,GAAaprI,QACZ,GAAoB,MAAhBA,EAAEs4B,OAAO,GAAY,CAS9B,GARIt4B,EAAE1S,OAAS,IAEbqI,EAAIqK,EAAEs4B,OAAO,GACb5yB,EAAI1F,EAAEs4B,OAAO,GACbj6B,EAAI2B,EAAEs4B,OAAO,GACbt4B,EAAI,IAAMrK,EAAIA,EAAI+P,EAAIA,EAAIrH,EAAIA,GAAkB,IAAb2B,EAAE1S,OAAe0S,EAAEs4B,OAAO,GAAKt4B,EAAEs4B,OAAO,GAAK,KAGjE,IAAbt4B,EAAE1S,OAGJ,MAAO,EADP8H,EAAIijC,SAASr4B,EAAEo/H,OAAO,EAAG,GAAI,MAChB,GAAIhqI,GAAK,EAAI+1I,GAAM/1I,EAAI+1I,GAAM9yG,SAASr4B,EAAEo/H,OAAO,GAAI,IAAM,KAIxEhqI,EAAI,EADJ4K,EAAIq4B,SAASr4B,EAAEo/H,OAAO,GAAI,MAChB,GAAIp/H,GAAK,EAAImrI,GAAMnrI,EAAImrI,GACnC,MAAO,GAAuB,QAAnBnrI,EAAEo/H,OAAO,EAAG,GAGrB,GAFAhqI,EAAIw3I,EAAS5sI,EAAEo4D,MAAMmkE,IAEhBmQ,GAWE,IAAK1sI,EAAElG,QAAQ,KAIpB,OAFA1E,EAAI4K,EAAEo4D,MAAMokE,IACZmQ,GAAcv3I,EAAE9H,OAAS,IAAM8H,EAAE,GAAK,GAC/BA,OAdPuQ,GAAKvQ,EAAE,GAAK,IAAM,IAClByI,GAAKzI,EAAE,GAAK,IAGZO,EAAQ,GAFR0E,GAAKjF,EAAE,GAAK,MACZsQ,EAAIrL,GAAK,GAAKA,GAAKwD,EAAI,GAAKxD,EAAIwD,EAAIxD,EAAIwD,GAExCzI,EAAE9H,OAAS,IAAM8H,EAAE,IAAM,GAEzBA,EAAE,GAAKm3I,GAAK5mI,EAAI,EAAI,EAAGhQ,EAAG+P,GAC1BtQ,EAAE,GAAKm3I,GAAK5mI,EAAGhQ,EAAG+P,GAClBtQ,EAAE,GAAKm3I,GAAK5mI,EAAI,EAAI,EAAGhQ,EAAG+P,QAQ5BtQ,EAAI4K,EAAEo4D,MAAMmkE,KAAkB6O,GAAa76G,YAG7Cn7B,EAAIA,EAAExI,IAAIglB,OACZ,CAyBA,OAvBI86H,IAAUE,IACZj3I,EAAIP,EAAE,GAAK+1I,GACXzlI,EAAItQ,EAAE,GAAK+1I,GACX9sI,EAAIjJ,EAAE,GAAK+1I,GAGX9wI,IAFAa,EAAMvQ,KAAKuQ,IAAIvF,EAAG+P,EAAGrH,KACrB/T,EAAMK,KAAKL,IAAIqL,EAAG+P,EAAGrH,KACH,EAEdnD,IAAQ5Q,EACVqb,EAAI9H,EAAI,GAER1I,EAAI+F,EAAM5Q,EACVuT,EAAIxD,EAAI,GAAMlF,GAAK,EAAI+F,EAAM5Q,GAAO6K,GAAK+F,EAAM5Q,GAC/Cqb,EAAIzK,IAAQvF,GAAK+P,EAAIrH,GAAKlJ,GAAKuQ,EAAIrH,EAAI,EAAI,GAAKnD,IAAQwK,GAAKrH,EAAI1I,GAAKR,EAAI,GAAKQ,EAAI+P,GAAKvQ,EAAI,EAC5FwQ,GAAK,IAGPvQ,EAAE,MAAQuQ,EAAI,IACdvQ,EAAE,MAAY,IAAJyI,EAAU,IACpBzI,EAAE,MAAY,IAAJiF,EAAU,KAGtBsyI,GAAcv3I,EAAE9H,OAAS,IAAM8H,EAAE,GAAK,GAC/BA,CACT,EACIy3I,GAAkB,SAAyB7sI,GAE7C,IAAIitB,EAAS,GACT3uB,EAAI,GACJrR,GAAK,EAOT,OANA+S,EAAE65D,MAAMizE,IAAWr6I,SAAQ,SAAUuN,GACnC,IAAI5K,EAAI4K,EAAEo4D,MAAMqkE,KAAoB,GACpCxvG,EAAO7gC,KAAKsvF,MAAMzuD,EAAQ73B,GAC1BkJ,EAAElS,KAAKa,GAAKmI,EAAE9H,OAAS,EACzB,IACA2/B,EAAO3uB,EAAIA,EACJ2uB,CACT,EACI8/G,GAAgB,SAAuBlvI,EAAG6uI,EAAOM,GACnD,IAII1uI,EACA2uI,EACA93I,EACAkF,EAPA9I,EAAS,GACT27I,GAAUrvI,EAAItM,GAAQ6mE,MAAM00E,IAC5BpzI,EAAOgzI,EAAQ,QAAU,QACzBz/I,EAAI,EAMR,IAAKigJ,EACH,OAAOrvI,EAOT,GAJAqvI,EAASA,EAAOtgJ,KAAI,SAAUub,GAC5B,OAAQA,EAAQskI,GAAWtkI,EAAOukI,EAAO,KAAOhzI,GAAQgzI,EAAQvkI,EAAM,GAAK,IAAMA,EAAM,GAAK,KAAOA,EAAM,GAAK,KAAOA,EAAM,GAAKA,EAAMnb,KAAK,MAAQ,GACrJ,IAEIggJ,IACF73I,EAAI03I,GAAgBhvI,IACpBS,EAAI0uI,EAAe1uI,GAEbtR,KAAKuE,KAAY4D,EAAEmJ,EAAEtR,KAAKuE,IAI9B,IAFA8I,GADA4yI,EAAQpvI,EAAEjN,QAAQk8I,GAAW,KAAKjzE,MAAM4iE,KAC9BnvI,OAAS,EAEZL,EAAIoN,EAAGpN,IACZsE,GAAU07I,EAAMhgJ,KAAOqR,EAAExE,QAAQ7M,GAAKigJ,EAAO1xC,SAAW9hG,EAAO,YAAcvE,EAAE7H,OAAS6H,EAAI+3I,EAAO5/I,OAAS4/I,EAASF,GAAgBxxC,SAK3I,IAAKyxC,EAIH,IAFA5yI,GADA4yI,EAAQpvI,EAAEg8D,MAAMizE,KACNx/I,OAAS,EAEZL,EAAIoN,EAAGpN,IACZsE,GAAU07I,EAAMhgJ,GAAKigJ,EAAOjgJ,GAIhC,OAAOsE,EAAS07I,EAAM5yI,EACxB,EACIyyI,GAAY,WACd,IAEAznH,EAFIxnB,EAAI,yEAIR,IAAKwnB,KAAK+lH,GACRvtI,GAAK,IAAMwnB,EAAI,MAGjB,OAAO,IAAIg1F,OAAOx8G,EAAI,IAAK,KAC7B,CAVgB,GAWZsvI,GAAU,YACVC,GAAqB,SAA4Bh4I,GACnD,IACIs3I,EADAW,EAAWj4I,EAAEpI,KAAK,KAItB,GAFA8/I,GAAU30E,UAAY,EAElB20E,GAAUz9I,KAAKg+I,GAKjB,OAJAX,EAAQS,GAAQ99I,KAAKg+I,GACrBj4I,EAAE,GAAK23I,GAAc33I,EAAE,GAAIs3I,GAC3Bt3I,EAAE,GAAK23I,GAAc33I,EAAE,GAAIs3I,EAAOG,GAAgBz3I,EAAE,MAE7C,CAEX,EAQIkvI,GAAU,WACZ,IAQI5gE,EACA4pE,EACAC,EACAC,EACAC,EACAlgJ,EAbAmgJ,EAAWxzB,KAAKN,IAChB+zB,EAAgB,IAChBC,EAAe,GACfC,EAAaH,IACbI,EAAcD,EACdE,EAAO,IAAO,IACdC,EAAYD,EACZn0I,EAAa,GAObq0I,EAAQ,SAASA,EAAMjuI,GACzB,IAEIkuI,EACAC,EACAtiG,EACAC,EALAsiG,EAAUV,IAAaI,EACvBO,GAAe,IAANruI,EAqBb,GAfAouI,EAAUT,IAAkBE,GAAcO,EAAUR,KAGpDM,GADAriG,GADAiiG,GAAeM,GACMP,GACJG,GAEH,GAAKK,KACjBviG,IAAU0hG,EAAM1hG,MAChB2hG,EAAS5hG,EAAoB,IAAb2hG,EAAM3hG,KACtB2hG,EAAM3hG,KAAOA,GAAc,IAC3BmiG,GAAaE,GAAWA,GAAWH,EAAO,EAAIA,EAAOG,GACrDC,EAAW,GAGbE,IAAW3qE,EAAM4pE,EAAKW,IAElBE,EACF,IAAK5gJ,EAAK,EAAGA,EAAKqM,EAAWtM,OAAQC,IAEnCqM,EAAWrM,GAAIs+C,EAAM4hG,EAAQ3hG,EAAO9rC,EAG1C,EAuEA,OArEAwtI,EAAQ,CACN3hG,KAAM,EACNC,MAAO,EACPwiG,KAAM,WACJL,GAAM,EACR,EACAM,WAAY,SAAoB7+B,GAC9B,OAAO+9B,GAAU,KAAQ/9B,GAAO,IAClC,EACA8+B,KAAM,WACAjU,MACGF,IAAgB8B,OACnB/B,GAAOC,GAAerwI,OACtBswI,GAAOF,GAAK1xI,UAAY,CAAC,EACzBo0I,GAASI,KAAOA,IACf9C,GAAKqU,eAAiBrU,GAAKqU,aAAe,KAAKriJ,KAAK8wI,GAAK1yH,SAE1DwyH,GAASD,IAAiB3C,GAAKsU,mBAAqBtU,GAAK8C,MAAQ9C,IAAQ,CAAC,GAE1EmT,EAAOnT,GAAKruF,sBAEZk+F,GAAqBx3I,QAAQy3I,KAG/BxmE,GAAO8pE,EAAMmB,QAEbrB,EAAOC,GAAQ,SAAU9nI,GACvB,OAAO4uG,WAAW5uG,EAAGuoI,EAAyB,IAAbR,EAAM3hG,KAAc,EAAI,EAC3D,EAEA6uF,GAAgB,EAEhBuT,EAAM,GAEV,EACAU,MAAO,YACJpB,EAAOnT,GAAKnuF,qBAAuB2iG,cAAclrE,GAClDg3D,GAAgB,EAChB4S,EAAO/P,EACT,EACAsR,aAAc,SAAsBhhD,EAAWihD,GAC7CnB,EAAgB9/C,GAAar3D,IAE7Bo3G,EAAejjJ,KAAKL,IAAIwkJ,GAAe,GAAInB,EAC7C,EACAj+B,IAAK,SAAaq/B,GAChBhB,EAAO,KAAQgB,GAAQ,KACvBf,EAAyB,IAAbR,EAAM3hG,KAAckiG,CAClC,EACApkJ,IAAK,SAAairB,EAAUo6H,EAAMC,GAChC,IAAIve,EAAOse,EAAO,SAAU1zI,EAAGnG,EAAGsQ,EAAGzF,GACnC4U,EAAStZ,EAAGnG,EAAGsQ,EAAGzF,GAElBwtI,EAAM3jJ,OAAO6mI,EACf,EAAI97G,EAQJ,OANA44H,EAAM3jJ,OAAO+qB,GAEbhb,EAAWq1I,EAAa,UAAY,QAAQve,GAE5C6V,KAEO7V,CACT,EACA7mI,OAAQ,SAAgB+qB,EAAU3nB,KAC9BA,EAAI2M,EAAWE,QAAQ8a,KAAchb,EAAWhF,OAAO3H,EAAG,IAAMM,GAAMN,GAAKM,GAC/E,EACAqM,WAAYA,GAEP4zI,CACT,CApHc,GAqHVjH,GAAQ,WACV,OAAQ7L,IAAiB4J,GAAQkK,MACnC,EAQAU,GAAW,CAAC,EACRC,GAAiB,sBACjBC,GAAa,QACbC,GAAuB,SAA8BtlJ,GAWvD,IATA,IAKIW,EACA4kJ,EACAC,EAPA19I,EAAM,CAAC,EACPgoE,EAAQ9vE,EAAMq1I,OAAO,EAAGr1I,EAAMuD,OAAS,GAAGusE,MAAM,KAChDnnE,EAAMmnE,EAAM,GACZ5sE,EAAI,EACJoN,EAAIw/D,EAAMvsE,OAKPL,EAAIoN,EAAGpN,IACZqiJ,EAAMz1E,EAAM5sE,GACZvC,EAAQuC,IAAMoN,EAAI,EAAIi1I,EAAIx2B,YAAY,KAAOw2B,EAAIhiJ,OACjDiiJ,EAAYD,EAAIlQ,OAAO,EAAG10I,GAC1BmH,EAAIa,GAAOktB,MAAM2vH,GAAaA,EAAU3+I,QAAQw+I,GAAY,IAAI31E,QAAU81E,EAC1E78I,EAAM48I,EAAIlQ,OAAO10I,EAAQ,GAAG+uE,OAG9B,OAAO5nE,CACT,EAaIo2I,GAAc,SAAqBd,GACrC,OAAO,SAAU9hH,GACf,OAAO,EAAI8hH,EAAK,EAAI9hH,EACtB,CACF,EAEAmqH,GAAqB,SAASA,EAAmBpM,EAAUqM,GAIzD,IAHA,IACItI,EADAl8G,EAAQm4G,EAASsM,OAGdzkH,GACDA,aAAiBg6G,GACnBuK,EAAmBvkH,EAAOwkH,IACjBxkH,EAAMs1G,KAAKoP,UAAc1kH,EAAM2kH,OAAU3kH,EAAMk3G,SAAYl3G,EAAM2kH,QAAUH,IAChFxkH,EAAMm4G,SACRoM,EAAmBvkH,EAAMm4G,SAAUqM,IAEnCtI,EAAOl8G,EAAM4kH,MACb5kH,EAAM4kH,MAAQ5kH,EAAM6kH,OACpB7kH,EAAM6kH,OAAS3I,EACfl8G,EAAM2kH,MAAQH,IAIlBxkH,EAAQA,EAAMi2G,KAElB,EACIkG,GAAa,SAAoBD,EAAM4I,GACzC,OAAQ5I,IAAsBrL,GAAYqL,GAAQA,EAAO+H,GAAS/H,IAlCxC,SAA+Bh4I,GAEzD,IARqDpF,EACjDimJ,EACAt6B,EACAu6B,EAKAp2E,GAAS1qE,EAAO,IAAI0qE,MAAM,KAC1BstE,EAAO+H,GAASr1E,EAAM,IAC1B,OAAOstE,GAAQttE,EAAMvsE,OAAS,GAAK65I,EAAKgD,OAAShD,EAAKgD,OAAOzuD,MAAM,MAAOvsF,EAAK2K,QAAQ,KAAO,CAACu1I,GAAqBx1E,EAAM,MAVrE9vE,EAUgGoF,EATjJ6gJ,EAAOjmJ,EAAM+P,QAAQ,KAAO,EAC5B47G,EAAQ3rH,EAAM+P,QAAQ,KACtBm2I,EAASlmJ,EAAM+P,QAAQ,IAAKk2I,GACzBjmJ,EAAM8xH,UAAUm0B,GAAOC,GAAUA,EAASv6B,EAAQ3rH,EAAM+P,QAAQ,IAAK47G,EAAQ,GAAKA,IAMkE77C,MAAM,KAAKjtE,IAAIkzI,KAAuBoP,GAASgB,KAAOf,GAAe9/I,KAAKF,GAAQ+/I,GAASgB,IAAI,GAAI/gJ,GAAQg4I,CACxQ,CA6B6EgJ,CAAsBhJ,KAAlF4I,CACjB,EACIK,GAAc,SAAqBrR,EAAOsR,EAAQzV,EAAS0V,QAC7C,IAAZ1V,IACFA,EAAU,SAAiBv1G,GACzB,OAAO,EAAIgrH,EAAO,EAAIhrH,EACxB,QAGgB,IAAdirH,IACFA,EAAY,SAAmBjrH,GAC7B,OAAOA,EAAI,GAAKgrH,EAAW,EAAJhrH,GAAS,EAAI,EAAIgrH,EAAiB,GAAT,EAAIhrH,IAAU,CAChE,GAGF,IAKIkrH,EALApJ,EAAO,CACTkJ,OAAQA,EACRzV,QAASA,EACT0V,UAAWA,GAab,OATAxR,GAAaC,GAAO,SAAU5vI,GAI5B,IAAK,IAAIk2B,KAHT6pH,GAAS//I,GAAQ2tI,GAAS3tI,GAAQg4I,EAClC+H,GAASqB,EAAgBphJ,EAAK6L,eAAiB4/H,EAEjCuM,EACZ+H,GAASqB,GAAuB,WAANlrH,EAAiB,MAAc,YAANA,EAAkB,OAAS,WAAa6pH,GAAS//I,EAAO,IAAMk2B,GAAK8hH,EAAK9hH,EAE/H,IAEO8hH,CACT,EACIqJ,GAAoB,SAA2B5V,GACjD,OAAO,SAAUv1G,GACf,OAAOA,EAAI,IAAM,EAAIu1G,EAAQ,EAAQ,EAAJv1G,IAAU,EAAI,GAAKu1G,EAAmB,GAAVv1G,EAAI,KAAW,CAC9E,CACF,EACIorH,GAAiB,SAASA,EAAe/2I,EAAMg3I,EAAWC,GAC5D,IAAI10H,EAAKy0H,GAAa,EAAIA,EAAY,EAEtCx0H,GAAMy0H,IAAWj3I,EAAO,GAAK,OAASg3I,EAAY,EAAIA,EAAY,GAC9DliH,EAAKtS,EAAKq/G,IAAQ5wI,KAAKi7B,KAAK,EAAI3J,IAAO,GACvC2+G,EAAU,SAAiBv1G,GAC7B,OAAa,IAANA,EAAU,EAAIpJ,EAAKtxB,KAAK8Q,IAAI,GAAI,GAAK4pB,GAAKu2G,IAAMv2G,EAAImJ,GAAMtS,GAAM,CACzE,EACIirH,EAAgB,QAATztI,EAAiBkhI,EAAmB,OAATlhI,EAAgB,SAAU2rB,GAC9D,OAAO,EAAIu1G,EAAQ,EAAIv1G,EACzB,EAAImrH,GAAkB5V,GAQtB,OANA1+G,EAAKq/G,GAAOr/G,EAEZirH,EAAKgD,OAAS,SAAUuG,EAAWC,GACjC,OAAOF,EAAe/2I,EAAMg3I,EAAWC,EACzC,EAEOxJ,CACT,EACIyJ,GAAc,SAASA,EAAYl3I,EAAMm3I,QACzB,IAAdA,IACFA,EAAY,SAGd,IAAIjW,EAAU,SAAiBv1G,GAC7B,OAAOA,IAAMA,EAAIA,IAAMwrH,EAAY,GAAKxrH,EAAIwrH,GAAa,EAAI,CAC/D,EACI1J,EAAgB,QAATztI,EAAiBkhI,EAAmB,OAATlhI,EAAgB,SAAU2rB,GAC9D,OAAO,EAAIu1G,EAAQ,EAAIv1G,EACzB,EAAImrH,GAAkB5V,GAMtB,OAJAuM,EAAKgD,OAAS,SAAU0G,GACtB,OAAOD,EAAYl3I,EAAMm3I,EAC3B,EAEO1J,CACT,EAeArI,GAAa,wCAAwC,SAAU3vI,EAAMlC,GACnE,IAAI8qH,EAAQ9qH,EAAI,EAAIA,EAAI,EAAIA,EAE5BmjJ,GAAYjhJ,EAAO,UAAY4oH,EAAQ,GAAI9qH,EAAI,SAAUo4B,GACvD,OAAO16B,KAAK8Q,IAAI4pB,EAAG0yF,EACrB,EAAI,SAAU1yF,GACZ,OAAOA,CACT,GAAG,SAAUA,GACX,OAAO,EAAI16B,KAAK8Q,IAAI,EAAI4pB,EAAG0yF,EAC7B,IAAG,SAAU1yF,GACX,OAAOA,EAAI,GAAK16B,KAAK8Q,IAAQ,EAAJ4pB,EAAO0yF,GAAS,EAAI,EAAIptH,KAAK8Q,IAAc,GAAT,EAAI4pB,GAAQ0yF,GAAS,CAClF,GACF,IAEAm3B,GAAS4B,OAAOC,SAAW7B,GAAS8B,KAAO9B,GAAS4B,OAAOT,OAE3DD,GAAY,UAAWK,GAAe,MAAOA,GAAe,OAAQA,MAEzD3hJ,GAWR,OAVG6rI,GAAK,GADGr8H,GAWH,MAHT8xI,GAAY,UAAU,SAAU/qH,GAC9B,OAAO,EAAIu1G,GAAQ,EAAIv1G,EACzB,GANIu1G,GAAU,SAAiBv1G,GAC7B,OAAOA,EAAIs1G,GAAK7rI,GAAIu2B,EAAIA,EAAIA,EAHrB,kBAG8Bv2B,GAAInE,KAAK8Q,IAAI4pB,EAAI,IAAM/mB,GAAG,GAAK,IAAM+mB,EAFnE,kBAE4Ev2B,IAAKu2B,GAAK,KAAO/mB,IAAK+mB,EAAI,MAAQv2B,GAAInE,KAAK8Q,IAAI4pB,EAAI,MAAQ/mB,GAAG,GAAK,OACxJ,GAOF8xI,GAAY,QAAQ,SAAU/qH,GAC5B,OAAOA,EAAI16B,KAAK8Q,IAAI,EAAG,IAAM4pB,EAAI,IAAM,CACzC,IAEA+qH,GAAY,QAAQ,SAAU/qH,GAC5B,QAASq2G,GAAM,EAAIr2G,EAAIA,GAAK,EAC9B,IAEA+qH,GAAY,QAAQ,SAAU/qH,GAC5B,OAAa,IAANA,EAAU,EAA0B,EAArBs2G,GAAKt2G,EAAIm2G,GACjC,IAEA4U,GAAY,OAAQQ,GAAY,MAAOA,GAAY,OAAQA,MAE3D1B,GAAS+B,YAAc/B,GAASgC,MAAQpU,GAASmU,YAAc,CAC7D9G,OAAQ,SAAgB+G,EAAOC,QACf,IAAVD,IACFA,EAAQ,GAGV,IAAIj1H,EAAK,EAAIi1H,EACTh1H,EAAKg1H,GAASC,EAAiB,EAAI,GACnC3iH,EAAK2iH,EAAiB,EAAI,EAE9B,OAAO,SAAU9rH,GACf,QAASnJ,EAAKonH,GAAO,EAFb,UAEqBj+G,GAAK,GAAKmJ,GAAMvS,CAC/C,CACF,GAEFi/G,GAAUiM,KAAO+H,GAAS,YAE1BpQ,GAAa,sEAAsE,SAAU3vI,GAC3F,OAAOkvI,IAAkBlvI,EAAO,IAAMA,EAAO,SAC/C,IAQO,IAAIwvI,GAAU,SAAiB5tI,EAAQ0tI,GAC5C9xI,KAAKL,GAAKmvI,KACV1qI,EAAOytI,MAAQ7xI,KACfA,KAAKoE,OAASA,EACdpE,KAAK8xI,QAAUA,EACf9xI,KAAK6I,IAAMipI,EAAUA,EAAQjpI,IAAMqpI,GACnClyI,KAAKuS,IAAMu/H,EAAUA,EAAQsM,UAAYC,EAC3C,EAOWoG,GAAyB,WAClC,SAASA,EAAU7Q,GACjB5zI,KAAK4zI,KAAOA,EACZ5zI,KAAKg3I,QAAUpD,EAAKnF,OAAS,GAEzBzuI,KAAKw1I,QAAU5B,EAAKn0H,SAAWoqB,KAAY,EAAI+pG,EAAKn0H,QAAU,KAEhEzf,KAAK21I,QAAU/B,EAAK8Q,aAAe,EACnC1kJ,KAAKijJ,QAAUrP,EAAK+Q,QAAU/Q,EAAKoP,UAGrChjJ,KAAKs1I,IAAM,EAEX0C,GAAah4I,MAAO4zI,EAAKpxB,SAAU,EAAG,GAEtCxiH,KAAKqD,KAAOuwI,EAAKvwI,KAEb,KACFrD,KAAKi9I,KAAO,GAEZ,GAAS55I,KAAK5D,KAAKO,OAGrB+tI,IAAiB4J,GAAQkK,MAC3B,CAEA,IAAI+C,EAASH,EAAUpiJ,UAgUvB,OA9TAuiJ,EAAOnW,MAAQ,SAAerxI,GAC5B,OAAIA,GAAmB,IAAVA,GACX4C,KAAK86B,QAAU96B,KAAK86B,OAAOw7G,mBAAqBt2I,KAAK+gH,UAAU/gH,KAAK46G,OAASx9G,EAAQ4C,KAAKg3I,QAC1Fh3I,KAAKg3I,OAAS55I,EACP4C,MAGFA,KAAKg3I,MACd,EAEA4N,EAAOpiC,SAAW,SAAkBplH,GAClC,OAAO8/B,UAAUv8B,OAASX,KAAKi2I,cAAcj2I,KAAKw1I,QAAU,EAAIp4I,GAASA,EAAQ4C,KAAK21I,SAAW31I,KAAKw1I,QAAUp4I,GAAS4C,KAAKi2I,iBAAmBj2I,KAAK80I,IACxJ,EAEA8P,EAAO3O,cAAgB,SAAuB74I,GAC5C,OAAK8/B,UAAUv8B,QAIfX,KAAK+0I,OAAS,EACPiD,GAAah4I,KAAMA,KAAKw1I,QAAU,EAAIp4I,GAASA,EAAQ4C,KAAKw1I,QAAUx1I,KAAK21I,UAAY31I,KAAKw1I,QAAU,KAJpGx1I,KAAKk2I,KAKhB,EAEA0O,EAAO3P,UAAY,SAAmB4P,EAAY/T,GAGhD,GAFA8I,MAEK18G,UAAUv8B,OACb,OAAOX,KAAK01I,OAGd,IAAI56G,EAAS96B,KAAKg0I,IAElB,GAAIl5G,GAAUA,EAAOw7G,mBAAqBt2I,KAAKs1I,IAAK,CAMlD,IALAe,GAAer2I,KAAM6kJ,IAEpB/pH,EAAOk5G,KAAOl5G,EAAOA,QAAU07G,GAAe17G,EAAQ96B,MAGhD86B,GAAUA,EAAOA,QAClBA,EAAOA,OAAOy7G,QAAUz7G,EAAO8/E,QAAU9/E,EAAOw6G,KAAO,EAAIx6G,EAAO46G,OAAS56G,EAAOw6G,KAAOx6G,EAAOm7G,gBAAkBn7G,EAAO46G,SAAW56G,EAAOw6G,MAC7Ix6G,EAAOm6G,UAAUn6G,EAAO46G,QAAQ,GAGlC56G,EAASA,EAAOA,QAGb96B,KAAK86B,QAAU96B,KAAKg0I,IAAIW,qBAAuB30I,KAAKs1I,IAAM,GAAKuP,EAAa7kJ,KAAKk2I,OAASl2I,KAAKs1I,IAAM,GAAKuP,EAAa,IAAM7kJ,KAAKk2I,QAAU2O,IAE/IhO,GAAe72I,KAAKg0I,IAAKh0I,KAAMA,KAAK46G,OAAS56G,KAAKg3I,OAEtD,CAaA,OAXIh3I,KAAK01I,SAAWmP,IAAe7kJ,KAAK80I,OAAShE,GAAkB9wI,KAAKizI,UAAYj1I,KAAKwS,IAAIxQ,KAAK42I,UAAYjI,KAAakW,IAAe7kJ,KAAKizI,WAAajzI,KAAKhD,KAAOgD,KAAK8kJ,cAE3K9kJ,KAAKs1I,MAAQt1I,KAAK+kJ,OAASF,GAI3B7R,GAAgBhzI,KAAM6kJ,EAAY/T,IAK7B9wI,IACT,EAEA4kJ,EAAO1lG,KAAO,SAAc9hD,EAAO0zI,GACjC,OAAO5zG,UAAUv8B,OAASX,KAAKi1I,UAAUj3I,KAAKL,IAAIqC,KAAKi2I,gBAAiB74I,EAAQm4I,GAAsBv1I,QAAUA,KAAK80I,KAAO90I,KAAK21I,WAAav4I,EAAQ4C,KAAK80I,KAAO,GAAIhE,GAAkB9wI,KAAKu2I,KAC/L,EAEAqO,EAAOxM,cAAgB,SAAuBh7I,EAAO0zI,GACnD,OAAO5zG,UAAUv8B,OAASX,KAAKi1I,UAAUj1I,KAAKi2I,gBAAkB74I,EAAO0zI,GAAkB9wI,KAAKi2I,gBAAkBj4I,KAAKL,IAAI,EAAGqC,KAAK01I,OAAS11I,KAAKk2I,OAASl2I,KAAKglJ,KAC/J,EAEAJ,EAAOvH,SAAW,SAAkBjgJ,EAAO0zI,GACzC,OAAO5zG,UAAUv8B,OAASX,KAAKi1I,UAAUj1I,KAAKwiH,aAAcxiH,KAAKijJ,OAA8B,EAAnBjjJ,KAAKilJ,YAA+B7nJ,EAAZ,EAAIA,GAAiBm4I,GAAsBv1I,MAAO8wI,GAAkB9wI,KAAKwiH,WAAaxkH,KAAKL,IAAI,EAAGqC,KAAKu2I,MAAQv2I,KAAK80I,MAAQ90I,KAAKglJ,KACvO,EAEAJ,EAAOK,UAAY,SAAmB7nJ,EAAO0zI,GAC3C,IAAI+E,EAAgB71I,KAAKwiH,WAAaxiH,KAAK21I,QAE3C,OAAOz4G,UAAUv8B,OAASX,KAAKi1I,UAAUj1I,KAAKu2I,OAASn5I,EAAQ,GAAKy4I,EAAe/E,GAAkB9wI,KAAKw1I,QAAUC,GAAgBz1I,KAAK01I,OAAQG,GAAiB,EAAI,CACxK,EAYA+O,EAAO9jC,UAAY,SAAmB1jH,GACpC,IAAK8/B,UAAUv8B,OACb,OAAqB,OAAdX,KAAKo2I,KAAqB,EAAIp2I,KAAKo2I,KAG5C,GAAIp2I,KAAKo2I,OAASh5I,EAChB,OAAO4C,KAGT,IAAI41I,EAAQ51I,KAAK86B,QAAU96B,KAAKs1I,IAAMS,GAAwB/1I,KAAK86B,OAAOy7G,MAAOv2I,MAAQA,KAAK01I,OAa9F,OARA11I,KAAKo2I,MAAQh5I,GAAS,EACtB4C,KAAKs1I,IAAMt1I,KAAKklJ,MAAiB,OAAV9nJ,EAAsB,EAAI4C,KAAKo2I,KAEtDp2I,KAAKi1I,UAAU0B,IAAQ34I,KAAKwS,IAAIxQ,KAAKg3I,QAASh3I,KAAKk2I,MAAON,IAAQ,GAElEO,GAAQn2I,MAh6CY,SAA2BmgC,GAGjD,IAFA,IAAIrF,EAASqF,EAAUrF,OAEhBA,GAAUA,EAAOA,QAEtBA,EAAOi6G,OAAS,EAChBj6G,EAAOm7G,gBACPn7G,EAASA,EAAOA,OAGlB,OAAOqF,CACT,CAw5CWglH,CAAkBnlJ,KAC3B,EAEA4kJ,EAAOQ,OAAS,SAAgBhoJ,GAC9B,OAAK8/B,UAAUv8B,QAIXX,KAAKklJ,MAAQ9nJ,IACf4C,KAAKklJ,IAAM9nJ,EAEPA,GACF4C,KAAK+kJ,OAAS/kJ,KAAK01I,QAAU13I,KAAKuQ,KAAKvO,KAAKg3I,OAAQh3I,KAAK02I,WAEzD12I,KAAKs1I,IAAMt1I,KAAK40I,KAAO,IAEvBgF,KAEA55I,KAAKs1I,IAAMt1I,KAAKo2I,KAEhBp2I,KAAKi1I,UAAUj1I,KAAK86B,SAAW96B,KAAK86B,OAAOw7G,kBAAoBt2I,KAAK02I,UAAY12I,KAAK01I,QAAU11I,KAAK+kJ,OAA4B,IAApB/kJ,KAAKq9I,YAAoBr/I,KAAKwS,IAAIxQ,KAAK42I,UAAYjI,KAAa3uI,KAAK01I,QAAU/G,OAIxL3uI,MAnBEA,KAAKklJ,GAoBhB,EAEAN,EAAO7jC,UAAY,SAAmB3jH,GACpC,GAAI8/B,UAAUv8B,OAAQ,CACpBX,KAAK46G,OAASx9G,EACd,IAAI09B,EAAS96B,KAAK86B,QAAU96B,KAAKg0I,IAEjC,OADAl5G,IAAWA,EAAOm8G,QAAUj3I,KAAK86B,SAAW+7G,GAAe/7G,EAAQ96B,KAAM5C,EAAQ4C,KAAKg3I,QAC/Eh3I,IACT,CAEA,OAAOA,KAAK46G,MACd,EAEAgqC,EAAO5jC,QAAU,SAAiBqkC,GAChC,OAAOrlJ,KAAK46G,QAAU20B,GAAY8V,GAAkBrlJ,KAAKi2I,gBAAkBj2I,KAAKwiH,YAAcxkH,KAAKwS,IAAIxQ,KAAKs1I,KAAO,EACrH,EAEAsP,EAAOlO,QAAU,SAAiB4O,GAChC,IAAIxqH,EAAS96B,KAAK86B,QAAU96B,KAAKg0I,IAEjC,OAAQl5G,EAAuBwqH,KAAiBtlJ,KAAKs1I,KAAOt1I,KAAKw1I,SAAWx1I,KAAKu2I,OAASv2I,KAAKo4I,gBAAkB,GAAKp4I,KAAK01I,QAAU11I,KAAK80I,KAAO90I,KAAK21I,SAAY31I,KAAKs1I,IAAoBS,GAAwBj7G,EAAO47G,QAAQ4O,GAActlJ,MAAnEA,KAAK01I,OAAjK11I,KAAK01I,MACxB,EAEAkP,EAAO1P,OAAS,SAAgBsI,QACf,IAAXA,IACFA,EAAStM,IAGX,IAAIqU,EAAkBhY,GAUtB,OATAA,GAAaiQ,GAETx9I,KAAKizI,UAAYjzI,KAAKkzI,YACxBlzI,KAAKy2I,UAAYz2I,KAAKy2I,SAASvB,OAAOsI,GACtCx9I,KAAKi1I,WAAW,IAAMuI,EAAO1M,iBAGjB,WAAd9wI,KAAKqD,OAAqC,IAAhBm6I,EAAOxM,MAAkBhxI,KAAKgxI,OACxDzD,GAAagY,EACNvlJ,IACT,EAEA4kJ,EAAOY,WAAa,SAAoB9O,GAItC,IAHA,IAAIv2G,EAAYngC,KACZk/C,EAAOhiB,UAAUv8B,OAAS+1I,EAAUv2G,EAAUu2G,UAE3Cv2G,GACL+e,EAAO/e,EAAUy6E,OAAS17D,GAAQ/e,EAAUm1G,KAAO,GACnDn1G,EAAYA,EAAU6zG,IAGxB,OAAQh0I,KAAK86B,QAAU96B,KAAKylJ,KAAOzlJ,KAAKylJ,KAAK7R,KAAKuB,iBAAkB,IAAYn1I,KAAKylJ,KAAKD,WAAW9O,GAAWx3F,CAClH,EAEA0lG,EAAOnlI,OAAS,SAAgBriB,GAC9B,OAAI8/B,UAAUv8B,QACZX,KAAKw1I,QAAUp4I,IAAUysC,KAAY,EAAIzsC,EAClCi7I,GAAuBr4I,QAGP,IAAlBA,KAAKw1I,QAAiB3rG,IAAW7pC,KAAKw1I,OAC/C,EAEAoP,EAAOF,YAAc,SAAqBtnJ,GACxC,GAAI8/B,UAAUv8B,OAAQ,CACpB,IAAIu+C,EAAOl/C,KAAKu2I,MAKhB,OAJAv2I,KAAK21I,QAAUv4I,EAEfi7I,GAAuBr4I,MAEhBk/C,EAAOl/C,KAAKk/C,KAAKA,GAAQl/C,IAClC,CAEA,OAAOA,KAAK21I,OACd,EAEAiP,EAAOD,KAAO,SAAcvnJ,GAC1B,OAAI8/B,UAAUv8B,QACZX,KAAKijJ,MAAQ7lJ,EACN4C,MAGFA,KAAKijJ,KACd,EAEA2B,EAAOnnC,KAAO,SAAcrwF,EAAU0jH,GACpC,OAAO9wI,KAAKi1I,UAAU8B,GAAe/2I,KAAMotB,GAAWmiH,GAAYuB,GACpE,EAEA8T,EAAOc,QAAU,SAAiBC,EAAc7U,GAC9C,OAAO9wI,KAAK4lJ,OAAO3Q,UAAU0Q,GAAgB3lJ,KAAKg3I,OAAS,EAAGzH,GAAYuB,GAC5E,EAEA8T,EAAOgB,KAAO,SAAcnjJ,EAAMquI,GAEhC,OADQ,MAARruI,GAAgBzC,KAAKy9G,KAAKh7G,EAAMquI,GACzB9wI,KAAK6lJ,UAAS,GAAOT,QAAO,EACrC,EAEAR,EAAOkB,QAAU,SAAiBrjJ,EAAMquI,GAEtC,OADQ,MAARruI,GAAgBzC,KAAKy9G,KAAKh7G,GAAQzC,KAAKi2I,gBAAiBnF,GACjD9wI,KAAK6lJ,UAAS,GAAMT,QAAO,EACpC,EAEAR,EAAOmB,MAAQ,SAAeC,EAAQlV,GAEpC,OADU,MAAVkV,GAAkBhmJ,KAAKy9G,KAAKuoC,EAAQlV,GAC7B9wI,KAAKolJ,QAAO,EACrB,EAEAR,EAAOqB,OAAS,WACd,OAAOjmJ,KAAKolJ,QAAO,EACrB,EAEAR,EAAOiB,SAAW,SAAkBzoJ,GAClC,OAAI8/B,UAAUv8B,UACVvD,IAAU4C,KAAK6lJ,YAAc7lJ,KAAK8gH,WAAW9gH,KAAKo2I,OAASh5I,GAAQ,KAAY,IAE1E4C,MAGFA,KAAKo2I,KAAO,CACrB,EAEAwO,EAAOsB,WAAa,WAGlB,OAFAlmJ,KAAKizI,SAAWjzI,KAAK40I,KAAO,EAC5B50I,KAAK42I,QAAS,KACP52I,IACT,EAEA4kJ,EAAOuB,SAAW,WAChB,IAEIzP,EAFA57G,EAAS96B,KAAK86B,QAAU96B,KAAKg0I,IAC7B9kG,EAAQlvC,KAAK46G,OAEjB,QAAW9/E,KAAU96B,KAAKs1I,KAAOt1I,KAAKizI,UAAYn4G,EAAOqrH,aAAezP,EAAU57G,EAAO47G,SAAQ,KAAUxnG,GAASwnG,EAAU12I,KAAKghH,SAAQ,GAAQ2tB,IACrJ,EAEAiW,EAAOwB,cAAgB,SAAuBr5I,EAAMkb,EAAUg2C,GAC5D,IAAI21E,EAAO5zI,KAAK4zI,KAEhB,OAAI12G,UAAUv8B,OAAS,GAChBsnB,GAGH2rH,EAAK7mI,GAAQkb,EACbg2C,IAAW21E,EAAK7mI,EAAO,UAAYkxD,GAC1B,aAATlxD,IAAwB/M,KAAKqmJ,UAAYp+H,WAJlC2rH,EAAK7mI,GAOP/M,MAGF4zI,EAAK7mI,EACd,EAEA63I,EAAOz8B,KAAO,SAAcm+B,GAC1B,IAAIzyC,EAAO7zG,KACX,OAAO,IAAI6mH,SAAQ,SAAUC,GAC3B,IAAIhuG,EAAIq2H,GAAYmX,GAAeA,EAAclT,GAC7CmT,EAAW,WACb,IAAIC,EAAQ3yC,EAAKsU,KACjBtU,EAAKsU,KAAO,KAEZgnB,GAAYr2H,KAAOA,EAAIA,EAAE+6F,MAAW/6F,EAAEqvG,MAAQrvG,IAAM+6F,KAAUA,EAAKsU,KAAOq+B,GAC1E1/B,EAAQhuG,GACR+6F,EAAKsU,KAAOq+B,CACd,EAEI3yC,EAAKo/B,UAAqC,IAAzBp/B,EAAKukC,iBAAyBvkC,EAAKyhC,KAAO,IAAMzhC,EAAK6hC,QAAU7hC,EAAKyhC,IAAM,EAC7FiR,IAEA1yC,EAAK4yC,MAAQF,CAEjB,GACF,EAEA3B,EAAO5T,KAAO,WACZmM,GAAWn9I,KACb,EAEOykJ,CACT,CA3VoC,GA6VpCpR,GAAaoR,GAAUpiJ,UAAW,CAChCk0I,MAAO,EACP37B,OAAQ,EACRC,KAAM,EACN66B,OAAQ,EACRQ,MAAO,EACPnB,OAAQ,EACRS,QAAS,EACTyN,OAAO,EACPnoH,OAAQ,KACRm4G,UAAU,EACV0C,QAAS,EACTL,IAAK,EACLtB,IAAK,EACLgR,MAAO,EACPpO,QAAQ,KACR6P,MAAO,EACPvB,KAAK,EACL9O,KAAM,IASD,IAAIkC,GAAwB,SAAUoO,GAG3C,SAASpO,EAAS1E,EAAMxmH,GACtB,IAAIk/E,EAeJ,YAba,IAATsnC,IACFA,EAAO,CAAC,IAGVtnC,EAAQo6C,EAAW9kJ,KAAK5B,KAAM4zI,IAAS5zI,MACjC04I,OAAS,CAAC,EAChBpsC,EAAMgqC,oBAAsB1C,EAAK0C,kBACjChqC,EAAMqoC,qBAAuBf,EAAKe,mBAClCroC,EAAM2qC,MAAQ1H,GAAYqE,EAAK+S,cAC/BnZ,IAAmBqJ,GAAejD,EAAK94G,QAAU0yG,GAAiBT,GAAuBzgC,GAAQl/E,GACjGwmH,EAAKiS,UAAYv5C,EAAMw5C,UACvBlS,EAAKwR,QAAU94C,EAAM84C,QAAO,GAC5BxR,EAAKwJ,eAAiBhG,GAAerK,GAAuBzgC,GAAQsnC,EAAKwJ,eAClE9wC,CACT,CAnBA2gC,GAAeqL,EAAUoO,GAqBzB,IAAIE,EAAUtO,EAASj2I,UAkqBvB,OAhqBAukJ,EAAQx5E,GAAK,SAAY00D,EAAS8R,EAAMxmH,GAGtC,OAFAyrH,GAAiB,EAAG37G,UAAWl9B,MAExBA,IACT,EAEA4mJ,EAAQnkJ,KAAO,SAAcq/H,EAAS8R,EAAMxmH,GAG1C,OAFAyrH,GAAiB,EAAG37G,UAAWl9B,MAExBA,IACT,EAEA4mJ,EAAQC,OAAS,SAAgB/kB,EAASglB,EAAUC,EAAQ35H,GAG1D,OAFAyrH,GAAiB,EAAG37G,UAAWl9B,MAExBA,IACT,EAEA4mJ,EAAQr0I,IAAM,SAAauvH,EAAS8R,EAAMxmH,GAMxC,OALAwmH,EAAKpxB,SAAW,EAChBoxB,EAAK94G,OAAS96B,KACd2zI,GAAiBC,GAAM8Q,cAAgB9Q,EAAKn0H,OAAS,GACrDm0H,EAAKuB,kBAAoBvB,EAAKuB,gBAC9B,IAAIgE,GAAMrX,EAAS8R,EAAMmD,GAAe/2I,KAAMotB,GAAW,GAClDptB,IACT,EAEA4mJ,EAAQhlJ,KAAO,SAAcqmB,EAAUg2C,EAAQ7wC,GAC7C,OAAOypH,GAAe72I,KAAMm5I,GAAM6N,YAAY,EAAG/+H,EAAUg2C,GAAS7wC,EACtE,EAGAw5H,EAAQK,UAAY,SAAmBnlB,EAAStf,EAAUoxB,EAAMsT,EAAS95H,EAAU+5H,EAAeC,GAOhG,OANAxT,EAAKpxB,SAAWA,EAChBoxB,EAAKsT,QAAUtT,EAAKsT,SAAWA,EAC/BtT,EAAKyT,WAAaF,EAClBvT,EAAK0T,iBAAmBF,EACxBxT,EAAK94G,OAAS96B,KACd,IAAIm5I,GAAMrX,EAAS8R,EAAMmD,GAAe/2I,KAAMotB,IACvCptB,IACT,EAEA4mJ,EAAQW,YAAc,SAAqBzlB,EAAStf,EAAUoxB,EAAMsT,EAAS95H,EAAU+5H,EAAeC,GAGpG,OAFAxT,EAAKqF,aAAe,EACpBtF,GAAiBC,GAAMuB,gBAAkB5F,GAAYqE,EAAKuB,iBACnDn1I,KAAKinJ,UAAUnlB,EAAStf,EAAUoxB,EAAMsT,EAAS95H,EAAU+5H,EAAeC,EACnF,EAEAR,EAAQY,cAAgB,SAAuB1lB,EAAStf,EAAUskC,EAAUC,EAAQG,EAAS95H,EAAU+5H,EAAeC,GAGpH,OAFAL,EAAO7N,QAAU4N,EACjBnT,GAAiBoT,GAAQ5R,gBAAkB5F,GAAYwX,EAAO5R,iBACvDn1I,KAAKinJ,UAAUnlB,EAAStf,EAAUukC,EAAQG,EAAS95H,EAAU+5H,EAAeC,EACrF,EAEAR,EAAQzrG,OAAS,SAAgB85F,EAAWnE,EAAgBzyG,GAC1D,IAMI6gB,EACA5gB,EACAz8B,EACAojJ,EACApP,EACA4R,EACAC,EACA5mC,EACA6mC,EACAC,EACAjD,EACA7B,EAjBA1hC,EAAWphH,KAAKu2I,MAChBsR,EAAO7nJ,KAAK+0I,OAAS/0I,KAAKi2I,gBAAkBj2I,KAAKk2I,MACjDiC,EAAMn4I,KAAK80I,KACXc,EAAQX,GAAa,EAAI,EAAI3C,GAAc2C,GAE/C6S,EAAgB9nJ,KAAK42I,OAAS,GAAM3B,EAAY,IAAMj1I,KAAKizI,WAAakF,GAexE,GAFAn4I,OAASwtI,IAAmBoI,EAAQiS,GAAQ5S,GAAa,IAAMW,EAAQiS,GAEnEjS,IAAU51I,KAAK01I,QAAUr3G,GAASypH,EAAe,CAkBnD,GAjBI1mC,IAAaphH,KAAKu2I,OAAS4B,IAE7BvC,GAAS51I,KAAKu2I,MAAQn1B,EACtB6zB,GAAaj1I,KAAKu2I,MAAQn1B,GAG5BliE,EAAO02F,EACP+R,EAAY3nJ,KAAK46G,OAEjB6sC,IADA3mC,EAAY9gH,KAAKs1I,KAGbwS,IACF3P,IAAQ/2B,EAAWphH,KAAK42I,SAEvB3B,IAAcnE,KAAoB9wI,KAAK42I,OAAS3B,IAG/Cj1I,KAAKw1I,QAAS,CAKhB,GAHAmP,EAAO3kJ,KAAKijJ,MACZpN,EAAgBsC,EAAMn4I,KAAK21I,QAEvB31I,KAAKw1I,SAAW,GAAKP,EAAY,EACnC,OAAOj1I,KAAKi1I,UAA0B,IAAhBY,EAAsBZ,EAAWnE,EAAgBzyG,GAqCzE,GAlCA6gB,EAAOozF,GAAcsD,EAAQC,GAEzBD,IAAUiS,GAEZ5C,EAAYjlJ,KAAKw1I,QACjBt2F,EAAOi5F,KAEP8M,KAAerP,EAAQC,KAENoP,IAAcrP,EAAQC,IACrC32F,EAAOi5F,EACP8M,KAGF/lG,EAAOi5F,IAAQj5F,EAAOi5F,IAGxByP,EAAgBnS,GAAgBz1I,KAAK01I,OAAQG,IAC5Cz0B,GAAYphH,KAAK01I,QAAUkS,IAAkB3C,GAAajlJ,KAAK01I,OAASkS,EAAgB/R,EAAgB71I,KAAK80I,MAAQ,IAAM8S,EAAgB3C,GAExIN,GAAoB,EAAZM,IACV/lG,EAAOi5F,EAAMj5F,EACb4jG,EAAS,GAYPmC,IAAc2C,IAAkB5nJ,KAAK83I,MAAO,CAC9C,IAAIiQ,EAAYpD,GAAwB,EAAhBiD,EACpBI,EAAWD,KAAepD,GAAoB,EAAZM,GAWtC,GAVAA,EAAY2C,IAAkBG,GAAaA,GAC3C3mC,EAAW2mC,EAAY,EAAInS,EAAQuC,EAAMA,EAAMvC,EAE/C51I,KAAK83I,MAAQ,EACb93I,KAAKm7C,OAAOimE,IAAa0hC,EAAS,EAAIxQ,GAAc2S,EAAYpP,IAAiB/E,GAAiBqH,GAAKL,MAAQ,EAC/G93I,KAAK01I,OAASE,GAEb9E,GAAkB9wI,KAAK86B,QAAUgiH,GAAU98I,KAAM,YAClDA,KAAK4zI,KAAKqU,gBAAkBnF,IAAW9iJ,KAAKkmJ,aAAapO,MAAQ,GAE7D12B,GAAYA,IAAaphH,KAAKu2I,OAASkR,KAAgBznJ,KAAKs1I,KAAOt1I,KAAK4zI,KAAKsU,WAAaloJ,KAAK86B,SAAW96B,KAAK40I,KAEjH,OAAO50I,KAgBT,GAbAm4I,EAAMn4I,KAAK80I,KAEX+S,EAAO7nJ,KAAKk2I,MAER8R,IACFhoJ,KAAK83I,MAAQ,EACb12B,EAAW2mC,EAAY5P,GAAO,KAC9Bn4I,KAAKm7C,OAAOimE,GAAU,GACtBphH,KAAK4zI,KAAKqU,gBAAkBnF,GAAU9iJ,KAAKkmJ,cAG7ClmJ,KAAK83I,MAAQ,GAER93I,KAAKs1I,MAAQmS,EAChB,OAAOznJ,KAIT6iJ,GAAmB7iJ,KAAM8iJ,EAC3B,CACF,CAqBA,GAnBI9iJ,KAAKmoJ,YAAcnoJ,KAAKooJ,UAAYpoJ,KAAK83I,MAAQ,IACnD4P,EA1pDkB,SAA6BvnH,EAAWihF,EAAUliE,GAC1E,IAAI5gB,EAEJ,GAAI4gB,EAAOkiE,EAGT,IAFA9iF,EAAQ6B,EAAU4iH,OAEXzkH,GAASA,EAAMs8E,QAAU17D,GAAM,CACpC,GAAmB,YAAf5gB,EAAMj7B,MAAsBi7B,EAAMs8E,OAASwG,EAC7C,OAAO9iF,EAGTA,EAAQA,EAAMi2G,KAChB,MAIA,IAFAj2G,EAAQ6B,EAAUkoH,MAEX/pH,GAASA,EAAMs8E,QAAU17D,GAAM,CACpC,GAAmB,YAAf5gB,EAAMj7B,MAAsBi7B,EAAMs8E,OAASwG,EAC7C,OAAO9iF,EAGTA,EAAQA,EAAMg2G,KAChB,CAEJ,CAkoDqBgU,CAAoBtoJ,KAAMsyI,GAAclxB,GAAWkxB,GAAcpzF,IAE1EwoG,IACF9R,GAAS12F,GAAQA,EAAOwoG,EAAW9sC,UAIvC56G,KAAK01I,OAASE,EACd51I,KAAKu2I,MAAQr3F,EACbl/C,KAAK40I,MAAQ9zB,EAER9gH,KAAKizI,WACRjzI,KAAKqmJ,UAAYrmJ,KAAK4zI,KAAK5zH,SAC3BhgB,KAAKizI,SAAW,EAChBjzI,KAAK42I,OAAS3B,EACd7zB,EAAW,IAGRA,GAAYliE,IAAS4xF,IAAmBmU,IAC3CnI,GAAU98I,KAAM,WAEZA,KAAK01I,SAAWE,GAElB,OAAO51I,KAIX,GAAIk/C,GAAQkiE,GAAY6zB,GAAa,EAGnC,IAFA32G,EAAQt+B,KAAK+iJ,OAENzkH,GAAO,CAGZ,GAFAz8B,EAAOy8B,EAAMi2G,OAERj2G,EAAMs2G,MAAQ11F,GAAQ5gB,EAAMs8E,SAAWt8E,EAAMg3G,KAAOoS,IAAeppH,EAAO,CAC7E,GAAIA,EAAMxD,SAAW96B,KAEnB,OAAOA,KAAKm7C,OAAO85F,EAAWnE,EAAgBzyG,GAKhD,GAFAC,EAAM6c,OAAO7c,EAAMg3G,IAAM,GAAKp2F,EAAO5gB,EAAMs8E,QAAUt8E,EAAMg3G,KAAOh3G,EAAMy2G,OAASz2G,EAAM23G,gBAAkB33G,EAAM43G,QAAUh3F,EAAO5gB,EAAMs8E,QAAUt8E,EAAMg3G,IAAKxE,EAAgBzyG,GAEvK6gB,IAASl/C,KAAKu2I,QAAUv2I,KAAKs1I,MAAQmS,EAAY,CAEnDC,EAAa,EACb7lJ,IAAS+zI,GAAS51I,KAAK42I,QAAS,MAEhC,KACF,CACF,CAEAt4G,EAAQz8B,CACV,KACK,CACLy8B,EAAQt+B,KAAKqoJ,MAGb,IAFA,IAAIE,EAAetT,EAAY,EAAIA,EAAY/1F,EAExC5gB,GAAO,CAGZ,GAFAz8B,EAAOy8B,EAAMg2G,OAERh2G,EAAMs2G,MAAQ2T,GAAgBjqH,EAAMu8E,OAASv8E,EAAMg3G,KAAOoS,IAAeppH,EAAO,CACnF,GAAIA,EAAMxD,SAAW96B,KAEnB,OAAOA,KAAKm7C,OAAO85F,EAAWnE,EAAgBzyG,GAKhD,GAFAC,EAAM6c,OAAO7c,EAAMg3G,IAAM,GAAKiT,EAAejqH,EAAMs8E,QAAUt8E,EAAMg3G,KAAOh3G,EAAMy2G,OAASz2G,EAAM23G,gBAAkB33G,EAAM43G,QAAUqS,EAAejqH,EAAMs8E,QAAUt8E,EAAMg3G,IAAKxE,EAAgBzyG,GAASkvG,KAAejvG,EAAM20G,UAAY30G,EAAM40G,WAEvOh0F,IAASl/C,KAAKu2I,QAAUv2I,KAAKs1I,MAAQmS,EAAY,CAEnDC,EAAa,EACb7lJ,IAAS+zI,GAAS51I,KAAK42I,OAAS2R,GAAe,KAAY5Z,IAE3D,KACF,CACF,CAEArwG,EAAQz8B,CACV,CACF,CAEA,GAAI6lJ,IAAe5W,IACjB9wI,KAAK+lJ,QACL2B,EAAWvsG,OAAO+D,GAAQkiE,EAAW,GAAI,MAAWw1B,OAAS13F,GAAQkiE,EAAW,GAAK,EAEjFphH,KAAKs1I,KAMP,OAJAt1I,KAAK46G,OAAS+sC,EAEdxR,GAAQn2I,MAEDA,KAAKm7C,OAAO85F,EAAWnE,EAAgBzyG,GAIlDr+B,KAAKqmJ,YAAcvV,GAAkBgM,GAAU98I,KAAM,YAAY,IAC7D41I,IAAUiS,GAAQ7nJ,KAAK01I,QAAU11I,KAAKi2I,kBAAoBL,GAASx0B,KAAcumC,IAAc3nJ,KAAK46G,QAAU58G,KAAKwS,IAAIswG,KAAe9iH,KAAKwS,IAAIxQ,KAAKs1I,MAAWt1I,KAAK83I,SAErK7C,IAAckD,KAASvC,IAAUiS,GAAQ7nJ,KAAKs1I,IAAM,IAAMM,GAAS51I,KAAKs1I,IAAM,IAAMb,GAAkBz0I,KAAM,GAExG8wI,GAAoBmE,EAAY,IAAM7zB,IAAcw0B,IAASx0B,GAAaymC,IAC7E/K,GAAU98I,KAAM41I,IAAUiS,GAAQ5S,GAAa,EAAI,aAAe,qBAAqB,GAEvFj1I,KAAKymJ,SAAW7Q,EAAQiS,GAAQ7nJ,KAAK8gH,YAAc,IAAM9gH,KAAKymJ,UAGpE,CAEA,OAAOzmJ,IACT,EAEA4mJ,EAAQ5pJ,IAAM,SAAashC,EAAOlR,GAChC,IAAIo7H,EAASxoJ,KAIb,GAFAovI,GAAUhiH,KAAcA,EAAW2pH,GAAe/2I,KAAMotB,EAAUkR,MAE5DA,aAAiBmmH,IAAY,CACjC,GAAI9U,GAASrxG,GAIX,OAHAA,EAAMx4B,SAAQ,SAAUZ,GACtB,OAAOsjJ,EAAOxrJ,IAAIkI,EAAKkoB,EACzB,IACOptB,KAGT,GAAIkvI,GAAU5wG,GACZ,OAAOt+B,KAAKyoJ,SAASnqH,EAAOlR,GAG9B,IAAI+hH,GAAY7wG,GAGd,OAAOt+B,KAFPs+B,EAAQ66G,GAAM6N,YAAY,EAAG1oH,EAIjC,CAEA,OAAOt+B,OAASs+B,EAAQu4G,GAAe72I,KAAMs+B,EAAOlR,GAAYptB,IAClE,EAEA4mJ,EAAQ8B,YAAc,SAAqBpF,EAAQqF,EAAQC,EAAWC,QACrD,IAAXvF,IACFA,GAAS,QAGI,IAAXqF,IACFA,GAAS,QAGO,IAAdC,IACFA,GAAY,QAGW,IAArBC,IACFA,GAAoBna,IAMtB,IAHA,IAAIjmI,EAAI,GACJ61B,EAAQt+B,KAAK+iJ,OAEVzkH,GACDA,EAAMs8E,QAAUiuC,IACdvqH,aAAiB66G,GACnBwP,GAAUlgJ,EAAEhJ,KAAK6+B,IAEjBsqH,GAAangJ,EAAEhJ,KAAK6+B,GACpBglH,GAAU76I,EAAEhJ,KAAKsvF,MAAMtmF,EAAG61B,EAAMoqH,aAAY,EAAMC,EAAQC,MAI9DtqH,EAAQA,EAAMi2G,MAGhB,OAAO9rI,CACT,EAEAm+I,EAAQkC,QAAU,SAAiBnpJ,GAIjC,IAHA,IAAIk8B,EAAa77B,KAAK0oJ,YAAY,EAAG,EAAG,GACpCpoJ,EAAIu7B,EAAWl7B,OAEZL,KACL,GAAIu7B,EAAWv7B,GAAGszI,KAAKj0I,KAAOA,EAC5B,OAAOk8B,EAAWv7B,EAGxB,EAEAsmJ,EAAQ1pJ,OAAS,SAAgBohC,GAC/B,OAAI4wG,GAAU5wG,GACLt+B,KAAK+oJ,YAAYzqH,GAGtB6wG,GAAY7wG,GACPt+B,KAAKgpJ,aAAa1qH,IAG3Bk2G,GAAsBx0I,KAAMs+B,GAExBA,IAAUt+B,KAAKm3I,UACjBn3I,KAAKm3I,QAAUn3I,KAAKqoJ,OAGfxT,GAAS70I,MAClB,EAEA4mJ,EAAQ3R,UAAY,SAAmBgU,EAAanY,GAClD,OAAK5zG,UAAUv8B,QAIfX,KAAKooJ,SAAW,GAEXpoJ,KAAKg0I,KAAOh0I,KAAKs1I,MAEpBt1I,KAAK46G,OAAS03B,GAAcqF,GAAQz4F,MAAQl/C,KAAKs1I,IAAM,EAAI2T,EAAcjpJ,KAAKs1I,KAAOt1I,KAAKi2I,gBAAkBgT,IAAgBjpJ,KAAKs1I,OAGnIoR,EAAWrkJ,UAAU4yI,UAAUrzI,KAAK5B,KAAMipJ,EAAanY,GAEvD9wI,KAAKooJ,SAAW,EACTpoJ,MAbEA,KAAK01I,MAchB,EAEAkR,EAAQ6B,SAAW,SAAkB/+B,EAAOt8F,GAE1C,OADAptB,KAAK04I,OAAOhvB,GAASqtB,GAAe/2I,KAAMotB,GACnCptB,IACT,EAEA4mJ,EAAQmC,YAAc,SAAqBr/B,GAEzC,cADO1pH,KAAK04I,OAAOhvB,GACZ1pH,IACT,EAEA4mJ,EAAQsC,SAAW,SAAkB97H,EAAUnF,EAAUg2C,GACvD,IAAItvD,EAAIwqI,GAAM6N,YAAY,EAAG/+H,GAAY2oH,GAAY3yE,GAGrD,OAFAtvD,EAAEtL,KAAO,UACTrD,KAAKmoJ,UAAY,EACVtR,GAAe72I,KAAM2O,EAAGooI,GAAe/2I,KAAMotB,GACtD,EAEAw5H,EAAQuC,YAAc,SAAqB/7H,GACzC,IAAIkR,EAAQt+B,KAAK+iJ,OAGjB,IAFA31H,EAAW2pH,GAAe/2I,KAAMotB,GAEzBkR,GACDA,EAAMs8E,SAAWxtF,GAA2B,YAAfkR,EAAMj7B,MACrCoxI,GAAkBn2G,GAGpBA,EAAQA,EAAMi2G,KAElB,EAEAqS,EAAQoC,aAAe,SAAsBlnB,EAASsnB,EAAOC,GAI3D,IAHA,IAAIV,EAAS3oJ,KAAKspJ,YAAYxnB,EAASunB,GACnC/oJ,EAAIqoJ,EAAOhoJ,OAERL,KACLipJ,KAAsBZ,EAAOroJ,IAAMqoJ,EAAOroJ,GAAG0wI,KAAKlP,EAASsnB,GAG7D,OAAOppJ,IACT,EAEA4mJ,EAAQ0C,YAAc,SAAqBxnB,EAASunB,GAQlD,IAPA,IAKAh8H,EALI5kB,EAAI,GACJ+gJ,EAAgB5zI,GAAQksH,GACxBxjG,EAAQt+B,KAAK+iJ,OACb0G,EAAera,GAAUia,GAItB/qH,GACDA,aAAiB66G,GACfzG,GAAkBp0G,EAAMorH,SAAUF,KAAmBC,IAAiBF,IAAqBjrH,EAAM20G,UAAY30G,EAAMg3G,MAAQh3G,EAAMknH,WAAW,IAAM6D,GAAc/qH,EAAMknH,WAAWlnH,EAAM23G,iBAAmBoT,GAAcA,GAAc/qH,EAAM6nH,aAE9O19I,EAAEhJ,KAAK6+B,IAECjR,EAAWiR,EAAMgrH,YAAYE,EAAeH,IAAa1oJ,QACnE8H,EAAEhJ,KAAKsvF,MAAMtmF,EAAG4kB,GAGlBiR,EAAQA,EAAMi2G,MAGhB,OAAO9rI,CACT,EAQAm+I,EAAQ+C,QAAU,SAAiBv8H,EAAUwmH,GAC3CA,EAAOA,GAAQ,CAAC,EAEhB,IAOIgW,EAPAC,EAAK7pJ,KACLghH,EAAU+1B,GAAe8S,EAAIz8H,GAC7B08H,EAAQlW,EACRsF,EAAU4Q,EAAM5Q,QAChB6Q,EAAWD,EAAMtkC,QACjBwkC,EAAgBF,EAAME,cACtB7U,EAAkB2U,EAAM3U,gBAExBrC,EAAQqG,GAAM/rE,GAAGy8E,EAAIxW,GAAa,CACpCmH,KAAM5G,EAAK4G,MAAQ,OACnB9C,MAAM,EACNvC,iBAAiB,EACjBj2F,KAAM8hE,EACNwtB,UAAW,OACXhsB,SAAUoxB,EAAKpxB,UAAYxkH,KAAKwS,KAAKwwG,GAAWk4B,GAAW,SAAUA,EAAUA,EAAQh6F,KAAO2qG,EAAGtT,QAAUsT,EAAG/oC,cAAgB6tB,GAC9HnpB,QAAS,WAGP,GAFAqkC,EAAG9D,SAEE6D,EAAS,CACZ,IAAIpnC,EAAWoxB,EAAKpxB,UAAYxkH,KAAKwS,KAAKwwG,GAAWk4B,GAAW,SAAUA,EAAUA,EAAQh6F,KAAO2qG,EAAGtT,QAAUsT,EAAG/oC,aACnHgyB,EAAMgC,OAAStyB,GAAYw1B,GAAalF,EAAOtwB,EAAU,EAAG,GAAGrnE,OAAO23F,EAAMyD,OAAO,GAAM,GACzFqT,EAAU,CACZ,CAEAG,GAAYA,EAASh7D,MAAM+jD,EAAOkX,GAAiB,GACrD,GACCpW,IAEH,OAAOuB,EAAkBrC,EAAM33F,OAAO,GAAK23F,CAC7C,EAEA8T,EAAQqD,YAAc,SAAqBC,EAAcC,EAAYvW,GACnE,OAAO5zI,KAAK2pJ,QAAQQ,EAAY9W,GAAa,CAC3C6F,QAAS,CACPh6F,KAAM63F,GAAe/2I,KAAMkqJ,KAE5BtW,GACL,EAEAgT,EAAQjO,OAAS,WACf,OAAO34I,KAAKm3I,OACd,EAEAyP,EAAQwD,UAAY,SAAmBC,GAKrC,YAJkB,IAAdA,IACFA,EAAYrqJ,KAAKu2I,OAGZoG,GAAqB38I,KAAM+2I,GAAe/2I,KAAMqqJ,GACzD,EAEAzD,EAAQ0D,cAAgB,SAAuBC,GAK7C,YAJmB,IAAfA,IACFA,EAAavqJ,KAAKu2I,OAGboG,GAAqB38I,KAAM+2I,GAAe/2I,KAAMuqJ,GAAa,EACtE,EAEA3D,EAAQ4D,aAAe,SAAsBptJ,GAC3C,OAAO8/B,UAAUv8B,OAASX,KAAKy9G,KAAKrgH,GAAO,GAAQ4C,KAAKsqJ,cAActqJ,KAAKu2I,MAAQ5H,GACrF,EAEAiY,EAAQ6D,cAAgB,SAAuBpP,EAAQqP,EAAc7B,QAC1C,IAArBA,IACFA,EAAmB,GAOrB,IAJA,IAEInwH,EAFA4F,EAAQt+B,KAAK+iJ,OACbrK,EAAS14I,KAAK04I,OAGXp6G,GACDA,EAAMs8E,QAAUiuC,IAClBvqH,EAAMs8E,QAAUygC,EAChB/8G,EAAMu8E,MAAQwgC,GAGhB/8G,EAAQA,EAAMi2G,MAGhB,GAAImW,EACF,IAAKhyH,KAAKggH,EACJA,EAAOhgH,IAAMmwH,IACfnQ,EAAOhgH,IAAM2iH,GAKnB,OAAOxG,GAAS70I,KAClB,EAEA4mJ,EAAQV,WAAa,SAAoByE,GACvC,IAAIrsH,EAAQt+B,KAAK+iJ,OAGjB,IAFA/iJ,KAAK83I,MAAQ,EAENx5G,GACLA,EAAM4nH,WAAWyE,GACjBrsH,EAAQA,EAAMi2G,MAGhB,OAAOmS,EAAWrkJ,UAAU6jJ,WAAWtkJ,KAAK5B,KAAM2qJ,EACpD,EAEA/D,EAAQvpH,MAAQ,SAAeutH,QACP,IAAlBA,IACFA,GAAgB,GAMlB,IAHA,IACI/oJ,EADAy8B,EAAQt+B,KAAK+iJ,OAGVzkH,GACLz8B,EAAOy8B,EAAMi2G,MACbv0I,KAAK9C,OAAOohC,GACZA,EAAQz8B,EAKV,OAFA7B,KAAKg0I,MAAQh0I,KAAKu2I,MAAQv2I,KAAK01I,OAAS11I,KAAK+kJ,OAAS,GACtD6F,IAAkB5qJ,KAAK04I,OAAS,CAAC,GAC1B7D,GAAS70I,KAClB,EAEA4mJ,EAAQ3Q,cAAgB,SAAuB74I,GAC7C,IAIIi3I,EACAnlG,EACApU,EANAvsB,EAAM,EACNslG,EAAO7zG,KACPs+B,EAAQu1E,EAAKw0C,MACbV,EAAYjZ,GAKhB,GAAIxxG,UAAUv8B,OACZ,OAAOkzG,EAAKiN,WAAWjN,EAAK2hC,QAAU,EAAI3hC,EAAK2O,WAAa3O,EAAKoiC,kBAAoBpiC,EAAKgyC,YAAczoJ,EAAQA,IAGlH,GAAIy2G,EAAKkhC,OAAQ,CAGf,IAFAj6G,EAAS+4E,EAAK/4E,OAEPwD,GACL+1G,EAAO/1G,EAAMg2G,MAEbh2G,EAAMy2G,QAAUz2G,EAAM23G,iBAEtB/mG,EAAQ5Q,EAAMs8E,QAEF+sC,GAAa9zC,EAAKojC,OAAS34G,EAAMg3G,MAAQzhC,EAAKikC,OAExDjkC,EAAKikC,MAAQ,EAEbjB,GAAehjC,EAAMv1E,EAAO4Q,EAAQ5Q,EAAM04G,OAAQ,GAAGc,MAAQ,GAE7D6P,EAAYz4G,EAGVA,EAAQ,GAAK5Q,EAAMg3G,MAErB/mI,GAAO2gC,IAEFpU,IAAW+4E,EAAKmgC,KAAOl5G,GAAUA,EAAOw7G,qBAC3CziC,EAAK+G,QAAU1rE,EAAQ2kE,EAAKyhC,IAC5BzhC,EAAK0iC,OAASrnG,EACd2kE,EAAK6hC,QAAUxmG,GAGjB2kE,EAAK42C,eAAev7G,GAAO,GAAQ,UACnCy4G,EAAY,GAGdrpH,EAAMu8E,KAAOtsG,GAAO+vB,EAAMg3G,MAAQ/mI,EAAM+vB,EAAMu8E,MAC9Cv8E,EAAQ+1G,EAGV2D,GAAankC,EAAMA,IAAS25B,IAAmB35B,EAAK0iC,MAAQhoI,EAAMslG,EAAK0iC,MAAQhoI,EAAK,EAAG,GAEvFslG,EAAKkhC,OAAS,CAChB,CAEA,OAAOlhC,EAAKqiC,KACd,EAEAoC,EAASuS,WAAa,SAAoB3rG,GAOxC,GANIsuF,GAAgB8H,MAClBtC,GAAgBxF,GAAiBuI,GAAwB72F,EAAMsuF,KAE/DK,GAAqB8J,GAAQx4F,OAG3Bw4F,GAAQx4F,OAASqyF,GAAc,CACjCA,IAAgBtD,GAAQC,WAAa,IACrC,IAAI7vG,EAAQkvG,GAAgBuV,OAC5B,KAAKzkH,IAAUA,EAAMg3G,MAASpH,GAAQC,WAAawJ,GAAQ1qI,WAAWtM,OAAS,EAAG,CAChF,KAAO29B,IAAUA,EAAMg3G,KACrBh3G,EAAQA,EAAMi2G,MAGhBj2G,GAASq5G,GAAQqK,OACnB,CACF,CACF,EAEO1J,CACT,CAzrBmC,CAyrBjCmM,IAEFpR,GAAaiF,GAASj2I,UAAW,CAC/By1I,MAAO,EACPqQ,UAAW,EACXC,SAAU,IAGZ,IA6IImB,GAEJuB,GA/IIC,GAA6B,SAAoC3mJ,EAAQ0E,EAAMomC,EAAO2N,EAAKmuG,EAAQC,EAAcC,GAEnH,IAGItmJ,EACAumJ,EACA3vI,EACA4vI,EACAC,EACAC,EACAC,EACA9iJ,EAVA+iJ,EAAK,IAAIjN,GAAUv+I,KAAKy3I,IAAKrzI,EAAQ0E,EAAM,EAAG,EAAG2iJ,GAAsB,KAAMT,GAC7EjtJ,EAAQ,EACR2tJ,EAAa,EA6BjB,IApBAF,EAAG95I,EAAIw9B,EACPs8G,EAAGtvJ,EAAI2gD,EACP3N,GAAS,IAILq8G,IAFJ1uG,GAAO,IAEc1vC,QAAQ,cAC3B0vC,EAAMq/F,GAAer/F,IAGnBouG,IAEFA,EADAxiJ,EAAI,CAACymC,EAAO2N,GACIz4C,EAAQ0E,GAExBomC,EAAQzmC,EAAE,GACVo0C,EAAMp0C,EAAE,IAGV0iJ,EAAYj8G,EAAMu8B,MAAMskE,KAAyB,GAE1CnrI,EAASmrI,GAAqBvkG,KAAKqR,IACxCuuG,EAASxmJ,EAAO,GAChBymJ,EAAQxuG,EAAIqyE,UAAUnxH,EAAO6G,EAAO7G,OAEhCyd,EACFA,GAASA,EAAQ,GAAK,EACQ,UAArB6vI,EAAM5Y,QAAQ,KACvBj3H,EAAQ,GAGN4vI,IAAWD,EAAUO,OACvBJ,EAAW//G,WAAW4/G,EAAUO,EAAa,KAAO,EAEpDF,EAAG/T,IAAM,CACPlD,MAAOiX,EAAG/T,IACV/+G,EAAG2yH,GAAwB,IAAfK,EAAmBL,EAAQ,IAEvCn6I,EAAGo6I,EACH35I,EAAwB,MAArBy5I,EAAOz/G,OAAO,GAAa4mG,GAAe+Y,EAAUF,GAAUE,EAAW//G,WAAW6/G,GAAUE,EACjG78I,EAAG+M,GAASA,EAAQ,EAAIxd,KAAK2R,MAAQ,GAEvC5R,EAAQgyI,GAAqBvkE,WAcjC,OAVAggF,EAAG75I,EAAI5T,EAAQ8+C,EAAIl8C,OAASk8C,EAAIqyE,UAAUnxH,EAAO8+C,EAAIl8C,QAAU,GAE/D6qJ,EAAGG,GAAKT,GAEJlb,GAAQttI,KAAKm6C,IAAQ0uG,KACvBC,EAAGtvJ,EAAI,GAGT8D,KAAKy3I,IAAM+T,EAEJA,CACT,EACI1N,GAAgB,SAAuB15I,EAAQ0E,EAAMomC,EAAO2N,EAAK9+C,EAAO+jI,EAASkc,EAAUiN,EAAcC,EAAWU,GACtHzc,GAAYtyF,KAASA,EAAMA,EAAI9+C,GAAS,EAAGqG,EAAQ09H,IACnD,IAGI0pB,EAHAplH,EAAehiC,EAAO0E,GACtB+iJ,EAAwB,QAAV38G,EAAkBA,EAASigG,GAAY/oG,GAA+B8kH,EAAY9mJ,EAAO0E,EAAKqE,QAAQ,SAAWgiI,GAAY/qI,EAAO,MAAQ0E,EAAK2pI,OAAO,KAAO3pI,EAAO,MAAQA,EAAK2pI,OAAO,IAAIyY,GAAa9mJ,EAAO0E,KAA3Js9B,EACrE4kH,EAAU7b,GAAY/oG,GAA+B8kH,EAAYY,GAAuBC,GAAlDC,GAkB1C,GAfI9c,GAAUryF,MACPA,EAAI1vC,QAAQ,aACf0vC,EAAMq/F,GAAer/F,IAGD,MAAlBA,EAAIlR,OAAO,MACb6/G,EAAKjZ,GAAesZ,EAAahvG,IAAQw8F,GAAQwS,IAAgB,KAEhD,IAAPL,KAER3uG,EAAM2uG,KAKPI,GAAYC,IAAgBhvG,GAAOiuG,GACtC,OAAK73H,MAAM44H,EAAchvG,IAAgB,KAARA,IAQhCzW,KAAkBt9B,KAAQ1E,IAAWosI,GAAe1nI,EAAM+zC,GACpDkuG,GAA2BnpJ,KAAK5B,KAAMoE,EAAQ0E,EAAM+iJ,EAAahvG,EAAKmuG,EAAQC,GAAgB/c,GAAQ+c,aAAcC,KAPzHM,EAAK,IAAIjN,GAAUv+I,KAAKy3I,IAAKrzI,EAAQ0E,GAAO+iJ,GAAe,EAAGhvG,GAAOgvG,GAAe,GAA4B,kBAAjBzlH,EAA6B6lH,GAAiBC,GAAc,EAAGlB,GAC9JE,IAAcM,EAAGG,GAAKT,GACtBlN,GAAYwN,EAAGxN,SAASA,EAAUh+I,KAAMoE,GACjCpE,KAAKy3I,IAAM+T,EAMxB,EAkBIW,GAAe,SAAsBx1G,EAAUi9F,EAAMd,EAAO/0I,EAAOqG,EAAQ09H,GAC7E,IAAInM,EAAQ61B,EAAIY,EAAU9rJ,EAE1B,GAAIgxI,GAAS36F,KAAwL,KAA1Kg/E,EAAS,IAAI2b,GAAS36F,IAAayjB,KAAKh2D,EAAQuxH,EAAOuoB,QAAUtK,EAAKj9F,GAnBpF,SAAsBi9F,EAAM71I,EAAOqG,EAAQ09H,EAASgR,GAGjE,GAFA3D,GAAYyE,KAAUA,EAAOyY,GAAmBzY,EAAMd,EAAO/0I,EAAOqG,EAAQ09H,KAEvEwN,GAAUsE,IAASA,EAAK/2I,OAAS+2I,EAAK6F,UAAY9J,GAASiE,IAASlE,GAAckE,GACrF,OAAO1E,GAAU0E,GAAQyY,GAAmBzY,EAAMd,EAAO/0I,EAAOqG,EAAQ09H,GAAW8R,EAGrF,IACIl7G,EADAtlB,EAAO,CAAC,EAGZ,IAAKslB,KAAKk7G,EACRxgI,EAAKslB,GAAK2zH,GAAmBzY,EAAKl7G,GAAIo6G,EAAO/0I,EAAOqG,EAAQ09H,GAG9D,OAAO1uH,CACT,CAI+Gk5I,CAAa1Y,EAAKj9F,GAAW54C,EAAOqG,EAAQ09H,EAASgR,GAAQA,EAAO/0I,EAAO+jI,KACtLgR,EAAM2E,IAAM+T,EAAK,IAAIjN,GAAUzL,EAAM2E,IAAKrzI,EAAQuyC,EAAU,EAAG,EAAGg/E,EAAOx6E,OAAQw6E,EAAQ,EAAGA,EAAO42B,UAE/FzZ,IAAUhF,IAKZ,IAJAse,EAAWtZ,EAAMgS,UAAUhS,EAAM4W,SAASv8I,QAAQ/I,IAElD9D,EAAIq1H,EAAOgoB,OAAOh9I,OAEXL,KACL8rJ,EAASz2B,EAAOgoB,OAAOr9I,IAAMkrJ,EAKnC,OAAO71B,CACT,EAII6hB,GAAa,SAASA,EAAW1E,EAAO5zF,EAAM02F,GAChD,IAmBI4W,EACAlsJ,EACAo4B,EACA8yH,EACApnJ,EACAqoJ,EACAC,EACA5a,EACAnc,EACAy2B,EACAruJ,EACA4uJ,EACAC,EA/BAhZ,EAAOd,EAAMc,KACb4G,EAAO5G,EAAK4G,KACZtB,EAAUtF,EAAKsF,QACf/D,EAAkBvB,EAAKuB,gBACvBuC,EAAO9D,EAAK8D,KACZ13H,EAAW4zH,EAAK5zH,SAChB6sI,EAAiBjZ,EAAKiZ,eACtB3P,EAAgBtJ,EAAKsJ,cACrBjE,EAAerF,EAAKqF,aACpB+J,EAAWpP,EAAKoP,SAChBlP,EAAYF,EAAKE,UACjBsB,EAAaxB,EAAKwB,WAClB+C,EAAMrF,EAAMgC,KACZgY,EAAcha,EAAMI,SACpBpR,EAAUgR,EAAM4W,SAChB5uH,EAASg4G,EAAMh4G,OACfiyH,EAAcjyH,GAA0B,WAAhBA,EAAOz3B,KAAoBy3B,EAAO84G,KAAK9R,QAAUA,EACzEkrB,EAAqC,SAArBla,EAAMma,aAA0B3f,GAChDuc,EAAK/W,EAAM2D,SA2Bf,GAbAoT,KAAQ/V,IAAc0G,KAAUA,EAAO,QACvC1H,EAAMoQ,MAAQzI,GAAWD,EAAMjM,GAAUiM,MACzC1H,EAAMqQ,OAASH,EAAW1H,GAAYb,IAAwB,IAAbuI,EAAoBxI,EAAOwI,EAAUzU,GAAUiM,OAAS,EAErGwI,GAAYlQ,EAAMmQ,QAAUnQ,EAAM0C,UAEpCwN,EAAWlQ,EAAMqQ,OACjBrQ,EAAMqQ,OAASrQ,EAAMoQ,MACrBpQ,EAAMoQ,MAAQF,GAGhBlQ,EAAMoa,OAASrD,KAAQjW,EAAKqF,cAEvB4Q,GAAM/V,IAAcF,EAAKsT,QAAS,CAgBrC,GAbAyF,GADA7a,EAAUhQ,EAAQ,GAAKmQ,GAAUnQ,EAAQ,IAAIgQ,QAAU,IAC9B8B,EAAK9B,EAAQhpI,MAEtC0jJ,EAAY/Y,GAAeG,EAAMzC,IAE7B2b,IACFA,EAAYlW,OAAS,GAAKkW,EAAYzP,SAAS,GAE/Cn+F,EAAO,GAAK+5F,GAAgB9D,IAAoBC,EAAa0X,EAAY3xG,QAAQ,GAAG,GAAQ2xG,EAAY5X,OAAO+D,GAAgBd,EAAMlH,GAAsBJ,IAG3Jic,EAAY/Z,MAAQ,GAGlBmG,GAsBF,GArBAzE,GAAkB3B,EAAMI,SAAWiG,GAAM5mI,IAAIuvH,EAASuR,GAAa,CACjEhwI,KAAM,UACNmrI,WAAW,EACX1zG,OAAQA,EACRq6G,iBAAiB,EACjBuC,MAAOoV,GAAevd,GAAYmI,GAClCwB,QAAS,KACTzK,MAAO,EACPzuH,SAAUA,EACV6sI,eAAgBA,EAChB3P,cAAeA,EACfgK,QAAS,GACRhO,KAGHpG,EAAMI,SAASc,IAAM,EAErBlB,EAAMI,SAASuS,KAAO3S,EAEtB5zF,EAAO,IAAMquF,KAAe4H,IAAoBC,IAAetC,EAAMI,SAASgC,OAAOjE,IAEjFkE,GACEgD,GAAOj5F,GAAQ,GAAK02F,GAAS,EAG/B,YADA12F,IAAS4zF,EAAM8D,OAAS13F,SAIvB,GAAI+5F,GAAgBd,IAEpB2U,EAyBH,GAxBA5tG,IAASi2F,GAAkB,GAE3Bz8G,EAAI26G,GAAa,CACf7E,WAAW,EACXnrI,KAAM,cAENq0I,KAAMvC,IAAoB2X,GAAevd,GAAYmI,GACrDvC,gBAAiBA,EAEjB+R,QAAS,EACTpsH,OAAQA,GAEP0xH,GACHG,IAAgBj0H,EAAEo5G,EAAQhpI,MAAQ6jJ,GAElClY,GAAkB3B,EAAMI,SAAWiG,GAAM5mI,IAAIuvH,EAASppG,IAEtDo6G,EAAMI,SAASc,IAAM,EAErBlB,EAAMI,SAASuS,KAAO3S,EAEtB5zF,EAAO,IAAMquF,GAAauF,EAAMI,SAASgC,OAAOjE,IAAuB6B,EAAMI,SAAS/3F,QAAQ,GAAG,IACjG23F,EAAM8D,OAAS13F,EAEVi2F,GAGE,IAAKj2F,EACV,YAHAs4F,EAAW1E,EAAMI,SAAUvE,GAAUA,IAW3C,IAHAmE,EAAM2E,IAAM3E,EAAMqa,SAAW,EAC7BzV,EAAOS,GAAO5I,GAAYmI,IAASA,IAASS,EAEvC73I,EAAI,EAAGA,EAAIwhI,EAAQnhI,OAAQL,IAAK,CAkBnC,GAhBAosJ,GADAtoJ,EAAS09H,EAAQxhI,IACDuxI,OAASF,GAAS7P,GAASxhI,GAAGuxI,MAC9CiB,EAAMgS,UAAUxkJ,GAAK8rJ,EAAW,CAAC,EACjC/a,GAAYqb,EAAO/sJ,KAAOyxI,GAAYzwI,QAAUkyI,KAEhD90I,EAAQgvJ,IAAgBjrB,EAAUxhI,EAAIysJ,EAAY5/I,QAAQ/I,GAEtD0tI,IAA0G,KAA9Fnc,EAAS,IAAImc,GAAW13E,KAAKh2D,EAAQuoJ,GAAeH,EAAW1Z,EAAO/0I,EAAOgvJ,KAC3Fja,EAAM2E,IAAM+T,EAAK,IAAIjN,GAAUzL,EAAM2E,IAAKrzI,EAAQuxH,EAAOnzH,KAAM,EAAG,EAAGmzH,EAAOx6E,OAAQw6E,EAAQ,EAAGA,EAAO42B,UAEtG52B,EAAOgoB,OAAO73I,SAAQ,SAAUtD,GAC9B4pJ,EAAS5pJ,GAAQgpJ,CACnB,IAEA71B,EAAO42B,WAAaE,EAAc,KAG/B3a,GAAW6a,EACd,IAAKj0H,KAAK8zH,EACJlb,GAAS54G,KAAOi9F,EAASw2B,GAAazzH,EAAG8zH,EAAW1Z,EAAO/0I,EAAOqG,EAAQ2oJ,IAC5Ep3B,EAAO42B,WAAaE,EAAc,GAElCL,EAAS1zH,GAAK8yH,EAAK1N,GAAcl8I,KAAKkxI,EAAO1uI,EAAQs0B,EAAG,MAAO8zH,EAAU9zH,GAAI36B,EAAOgvJ,EAAa,EAAGnZ,EAAKqX,cAK/GnY,EAAMsa,KAAOta,EAAMsa,IAAI9sJ,IAAMwyI,EAAM9B,KAAK5sI,EAAQ0uI,EAAMsa,IAAI9sJ,IAEtD0sJ,GAAiBla,EAAM2E,MACzB8R,GAAoBzW,EAEpBtF,GAAgBwb,aAAa5kJ,EAAQgoJ,EAAUtZ,EAAM0S,WAAWtmG,IAGhE0tG,GAAe9Z,EAAMh4G,OACrByuH,GAAoB,GAGtBzW,EAAM2E,KAAOC,IAASrG,GAAYqb,EAAO/sJ,IAAM,EACjD,CAEA8sJ,GAAeY,GAA0Bva,GACzCA,EAAMwa,SAAWxa,EAAMwa,QAAQxa,EACjC,CAEAA,EAAMuT,UAAYrmI,EAClB8yH,EAAMG,WAAaH,EAAMsa,KAAOta,EAAM2E,OAASmV,EAE/C9Y,GAAa50F,GAAQ,GAAK2qG,EAAG1uG,OAAOuzF,IAAS,GAAM,EACrD,EAoFA6e,GAAiB,SAAwBzkJ,EAAM5D,EAAKsoJ,EAAUC,GAC5D,IACI/0H,EACAjwB,EAFA+xI,EAAOt1I,EAAIs1I,MAAQiT,GAAY,eAInC,GAAI9d,GAASzqI,GACXuD,EAAI+kJ,EAAS1kJ,KAAU0kJ,EAAS1kJ,GAAQ,IAExC5D,EAAIY,SAAQ,SAAU1I,EAAOkD,GAC3B,OAAOmI,EAAEhJ,KAAK,CACZkP,EAAGrO,GAAK4E,EAAIvE,OAAS,GAAK,IAC1B0S,EAAGjW,EACHlB,EAAGs+I,GAEP,SAEA,IAAK9hH,KAAKxzB,EACRuD,EAAI+kJ,EAAS90H,KAAO80H,EAAS90H,GAAK,IAC5B,SAANA,GAAgBjwB,EAAEhJ,KAAK,CACrBkP,EAAG48B,WAAWziC,GACduK,EAAGnO,EAAIwzB,GACPx8B,EAAGs+I,GAIX,EACI6R,GAAqB,SAA4BjvJ,EAAO01I,EAAOxyI,EAAG8D,EAAQ09H,GAC5E,OAAOqN,GAAY/xI,GAASA,EAAMwE,KAAKkxI,EAAOxyI,EAAG8D,EAAQ09H,GAAWoN,GAAU9xI,KAAWA,EAAM+P,QAAQ,WAAa+uI,GAAe9+I,GAASA,CAC9I,EACIswJ,GAAqBhc,GAAiB,4DACtCic,GAAsB,CAAC,EAE3Bxb,GAAaub,GAAqB,mDAAmD,SAAUlrJ,GAC7F,OAAOmrJ,GAAoBnrJ,GAAQ,CACrC,IAQO,IAAI22I,GAAqB,SAAUyU,GAGxC,SAASzU,EAAMrX,EAAS8R,EAAMxmH,EAAUygI,GACtC,IAAIC,EAEgB,iBAATla,IACTxmH,EAASo1F,SAAWoxB,EACpBA,EAAOxmH,EACPA,EAAW,MAIb,IAYIy8H,EACAvpJ,EACA8S,EACA1F,EACAgrB,EACAq1H,EACAC,EACAC,EAnBAC,GADJJ,EAASF,EAAYhsJ,KAAK5B,KAAM6tJ,EAAcja,EAAOD,GAAiBC,KAAU5zI,MACvD4zI,KACrBpxB,EAAW0rC,EAAY1rC,SACvBisB,EAAQyf,EAAYzf,MACpB0G,EAAkB+Y,EAAY/Y,gBAC9B+R,EAAUgH,EAAYhH,QACtB1Y,EAAY0f,EAAY1f,UACxBsF,EAAYoa,EAAYpa,UACxBR,EAAW4a,EAAY5a,SACvB8J,EAAgB8Q,EAAY9Q,cAC5B4F,EAAWkL,EAAYlL,SACvBloH,EAAS84G,EAAK94G,QAAU0yG,GACxBgc,GAAiB7Z,GAAS7N,IAAY4N,GAAc5N,GAAWsN,GAAUtN,EAAQ,IAAM,WAAY8R,GAAQ,CAAC9R,GAAWlsH,GAAQksH,GAcnI,GALAgsB,EAAOpE,SAAWF,EAAc7oJ,OAASgxI,GAAS6X,GAAiB/Y,GAAM,eAAiB3O,EAAU,qCAAsCoM,GAAQG,iBAAmB,GACrKyf,EAAOhJ,UAAY,GAEnBgJ,EAAOb,WAAaze,EAEhBsF,GAAaoT,GAAWzX,GAAgBjtB,IAAaitB,GAAgBhB,GAAQ,CAY/E,GAXAmF,EAAOka,EAAOla,MACdiW,EAAKiE,EAAOrX,SAAW,IAAI6B,GAAS,CAClCj1I,KAAM,SACNiwI,SAAUA,GAAY,CAAC,EACvBxR,QAAShnG,GAA0B,WAAhBA,EAAOz3B,KAAoBy3B,EAAO84G,KAAK9R,QAAU0nB,KAGnExY,OACH6Y,EAAG/uH,OAAS+uH,EAAG7V,IAAMjH,GAAuB+gB,GAC5CjE,EAAGjvC,OAAS,EAERssC,GAAWzX,GAAgBjtB,IAAaitB,GAAgBhB,GAAQ,CAIlE,GAHA/gI,EAAI87I,EAAc7oJ,OAClBqtJ,EAAc9G,GAAW5M,GAAW4M,GAEhC5X,GAAU4X,GAEZ,IAAKxuH,KAAKwuH,GACHwG,GAAmBvgJ,QAAQurB,KAC9Bu1H,IAAuBA,EAAqB,CAAC,GAC7CA,EAAmBv1H,GAAKwuH,EAAQxuH,IAKtC,IAAKp4B,EAAI,EAAGA,EAAIoN,EAAGpN,KACjB8S,EAAOqgI,GAAeG,EAAM+Z,KACvBzG,QAAU,EACflE,IAAa5vI,EAAK4vI,SAAWA,GAC7BiL,GAAsB3d,GAAOl9H,EAAM66I,GACnCF,EAAYvE,EAAclpJ,GAE1B8S,EAAKovG,UAAY6pC,GAAmB7pC,EAAUuqB,GAAuB+gB,GAASxtJ,EAAGytJ,EAAWvE,GAC5Fp2I,EAAKq7H,QAAU4d,GAAmB5d,EAAO1B,GAAuB+gB,GAASxtJ,EAAGytJ,EAAWvE,IAAkB,GAAKsE,EAAO9W,QAEhHkQ,GAAiB,IAANx5I,GAAW0F,EAAKq7H,QAE9Bqf,EAAO9W,OAASvI,EAAQr7H,EAAKq7H,MAC7Bqf,EAAOlzC,QAAU6zB,EACjBr7H,EAAKq7H,MAAQ,GAGfob,EAAGz8E,GAAG2gF,EAAW36I,EAAM46I,EAAcA,EAAY1tJ,EAAGytJ,EAAWvE,GAAiB,GAChFK,EAAG3G,MAAQX,GAAS8B,KAGtBwF,EAAGrnC,WAAaA,EAAWisB,EAAQ,EAAIqf,EAAOrX,SAAW,CAC3D,MAAO,GAAI3C,EAAW,CACpBH,GAAiBN,GAAawW,EAAGjW,KAAKN,SAAU,CAC9CkH,KAAM,UAGRqP,EAAG3G,MAAQzI,GAAW3G,EAAU0G,MAAQ5G,EAAK4G,MAAQ,QACrD,IACI/xI,EACA0lJ,EACA96I,EAHA6rC,EAAO,EAKX,GAAIywF,GAASmE,GACXA,EAAUhuI,SAAQ,SAAUq5C,GAC1B,OAAO0qG,EAAGz8E,GAAGo8E,EAAerqG,EAAO,IACrC,IACA0qG,EAAGrnC,eACE,CAGL,IAAK9pF,KAFLtlB,EAAO,CAAC,EAEE0gI,EACF,SAANp7G,GAAsB,aAANA,GAAoB60H,GAAe70H,EAAGo7G,EAAUp7G,GAAItlB,EAAM0gI,EAAU2Z,UAGtF,IAAK/0H,KAAKtlB,EAMR,IALA3K,EAAI2K,EAAKslB,GAAGisC,MAAK,SAAUl8D,EAAGiJ,GAC5B,OAAOjJ,EAAEkG,EAAI+C,EAAE/C,CACjB,IACAuwC,EAAO,EAEF5+C,EAAI,EAAGA,EAAImI,EAAE9H,OAAQL,KAExB+S,EAAI,CACFmnI,MAFF2T,EAAK1lJ,EAAEnI,IAEIpE,EACTsmH,UAAW2rC,EAAGx/I,GAAKrO,EAAImI,EAAEnI,EAAI,GAAGqO,EAAI,IAAM,IAAM6zG,IAEhD9pF,GAAKy1H,EAAG96I,EACVw2I,EAAGz8E,GAAGo8E,EAAen2I,EAAG6rC,GACxBA,GAAQ7rC,EAAEmvG,SAIdqnC,EAAGrnC,WAAaA,GAAYqnC,EAAGz8E,GAAG,CAAC,EAAG,CACpCo1C,SAAUA,EAAWqnC,EAAGrnC,YAE5B,CACF,CAEAA,GAAYsrC,EAAOtrC,SAASA,EAAWqnC,EAAGrnC,WAC5C,MACEsrC,EAAOrX,SAAW,EAwBpB,OArBkB,IAAdjI,GAAuBlB,KACzBic,GAAoBxc,GAAuB+gB,GAE3CtgB,GAAgBwb,aAAaQ,GAE7BD,GAAoB,GAGtB1S,GAAe/7G,EAAQiyG,GAAuB+gB,GAAS1gI,GAEvDwmH,EAAKiS,UAAYiI,EAAOhI,UACxBlS,EAAKwR,QAAU0I,EAAO1I,QAAO,IAEzBjQ,IAAoB3yB,IAAasxB,GAAaga,EAAOlzC,SAAW03B,GAAcx3G,EAAOy7G,QAAUhH,GAAY4F,IAAoBE,GAAsBtI,GAAuB+gB,KAA4B,WAAhBhzH,EAAOz3B,QACjMyqJ,EAAOpY,QAAS,KAEhBoY,EAAO3yG,OAAOn9C,KAAKuQ,IAAI,GAAIkgI,IAAU,IAIvC2O,GAAiBhG,GAAerK,GAAuB+gB,GAAS1Q,GACzD0Q,CACT,CA/JA7gB,GAAekM,EAAOyU,GAiKtB,IAAIQ,EAAUjV,EAAM92I,UA8TpB,OA5TA+rJ,EAAQjzG,OAAS,SAAgB85F,EAAWnE,EAAgBzyG,GAC1D,IAKI6gB,EACAssG,EACAvG,EACApP,EACA+R,EACA9E,EACAkC,EACAvO,EACAuM,EAbA5hC,EAAWphH,KAAKu2I,MAChBsR,EAAO7nJ,KAAKk2I,MACZiC,EAAMn4I,KAAK80I,KACXuZ,EAAapZ,EAAY,EACzBW,EAAQX,EAAY4S,EAAOlZ,KAAa0f,EAAaxG,EAAO5S,EAAYtG,GAAW,EAAIsG,EAW3F,GAAKkD,GAEE,GAAIvC,IAAU51I,KAAK01I,SAAWT,GAAa52G,IAAUr+B,KAAKizI,UAAYjzI,KAAK01I,QAAU11I,KAAKkzI,UAAYlzI,KAAK42I,OAAS,IAAMyX,EAAY,CAK3I,GAHAnvG,EAAO02F,EACPa,EAAWz2I,KAAKy2I,SAEZz2I,KAAKw1I,QAAS,CAIhB,GAFAK,EAAgBsC,EAAMn4I,KAAK21I,QAEvB31I,KAAKw1I,SAAW,GAAK6Y,EACvB,OAAOruJ,KAAKi1I,UAA0B,IAAhBY,EAAsBZ,EAAWnE,EAAgBzyG,GA6BzE,GA1BA6gB,EAAOozF,GAAcsD,EAAQC,GAEzBD,IAAUiS,GAEZ5C,EAAYjlJ,KAAKw1I,QACjBt2F,EAAOi5F,KAEP8M,KAAerP,EAAQC,KAENoP,IAAcrP,EAAQC,IACrC32F,EAAOi5F,EACP8M,KAGF/lG,EAAOi5F,IAAQj5F,EAAOi5F,KAGxB2K,EAAS9iJ,KAAKijJ,OAAqB,EAAZgC,KAGrBjC,EAAWhjJ,KAAKmjJ,OAChBjkG,EAAOi5F,EAAMj5F,GAGf0oG,EAAgBnS,GAAgBz1I,KAAK01I,OAAQG,GAEzC32F,IAASkiE,IAAa/iF,GAASr+B,KAAKizI,SAGtC,OADAjzI,KAAK01I,OAASE,EACP51I,KAGLilJ,IAAc2C,IAChBnR,GAAYz2I,KAAKmjJ,QAAUN,GAAmBpM,EAAUqM,IAEpD9iJ,KAAK4zI,KAAKqU,eAAkBnF,GAAW9iJ,KAAK83I,QAC9C93I,KAAK83I,MAAQz5G,EAAQ,EAErBr+B,KAAKm7C,OAAOm3F,GAAcuD,EAAgBoP,IAAY,GAAMiB,aAAapO,MAAQ,GAGvF,CAEA,IAAK93I,KAAKizI,SAAU,CAClB,GAAIsE,GAAkBv3I,KAAMquJ,EAAapZ,EAAY/1F,EAAM7gB,EAAOyyG,EAAgB8E,GAGhF,OAFA51I,KAAK01I,OAAS,EAEP11I,KAGT,GAAIohH,IAAaphH,KAAKu2I,MAEpB,OAAOv2I,KAGT,GAAIm4I,IAAQn4I,KAAK80I,KAEf,OAAO90I,KAAKm7C,OAAO85F,EAAWnE,EAAgBzyG,EAElD,CAiBA,GAfAr+B,KAAK01I,OAASE,EACd51I,KAAKu2I,MAAQr3F,GAERl/C,KAAK40I,MAAQ50I,KAAKs1I,MACrBt1I,KAAK40I,KAAO,EAEZ50I,KAAK+yI,MAAQ,GAGf/yI,KAAKglJ,MAAQA,GAAShC,GAAYhjJ,KAAKkjJ,OAAOhkG,EAAOi5F,GAEjDn4I,KAAKktJ,QACPltJ,KAAKglJ,MAAQA,EAAQ,EAAIA,GAGvB9lG,IAASkiE,IAAa0vB,IAAmBmU,IAC3CnI,GAAU98I,KAAM,WAEZA,KAAK01I,SAAWE,GAElB,OAAO51I,KAMX,IAFAwrJ,EAAKxrJ,KAAKy3I,IAEH+T,GACLA,EAAGxiJ,EAAEg8I,EAAOwG,EAAGhjJ,GACfgjJ,EAAKA,EAAGjX,MAGVkC,GAAYA,EAASt7F,OAAO85F,EAAY,EAAIA,GAAa/1F,GAAQ4jG,GAAS,KAAYrM,EAAS3B,KAAO2B,EAASyM,MAAMhkG,EAAOl/C,KAAK80I,MAAOhE,EAAgBzyG,IAAUr+B,KAAKkzI,WAAalzI,KAAK42I,OAAS3B,GAE9Lj1I,KAAKqmJ,YAAcvV,IACrBud,GAAcrZ,GAAeh1I,KAAMi1I,EAAWnE,EAAgBzyG,GAE9Dy+G,GAAU98I,KAAM,aAGlBA,KAAKw1I,SAAWyP,IAAc2C,GAAiB5nJ,KAAK4zI,KAAKsU,WAAapX,GAAkB9wI,KAAK86B,QAAUgiH,GAAU98I,KAAM,YAElH41I,IAAU51I,KAAKk2I,OAAUN,GAAU51I,KAAK01I,SAAWE,IACtDyY,IAAeruJ,KAAKqmJ,WAAarR,GAAeh1I,KAAMi1I,EAAW,GAAM,IACtEA,IAAckD,KAASvC,IAAU51I,KAAKk2I,OAASl2I,KAAKs1I,IAAM,IAAMM,GAAS51I,KAAKs1I,IAAM,IAAMb,GAAkBz0I,KAAM,GAE9G8wI,GAAoBud,IAAejtC,KAAcw0B,GAASx0B,GAAY0hC,KAEzEhG,GAAU98I,KAAM41I,IAAUiS,EAAO,aAAe,qBAAqB,GAErE7nJ,KAAKymJ,SAAW7Q,EAAQiS,GAAQ7nJ,KAAK8gH,YAAc,IAAM9gH,KAAKymJ,SAGpE,OAv8F2B,SAAkC3T,EAAOmC,EAAWnE,EAAgBzyG,GACjG,IAKImtH,EACAvG,EACA2C,EAPA0G,EAAYxb,EAAMkS,MAClBA,EAAQ/P,EAAY,IAAMA,KAAenC,EAAMl4B,QAAUg9B,GAA6B9E,KAAaA,EAAMG,WAAYiE,GAAmBpE,MAAYA,EAAMwC,IAAM,GAAKxC,EAAMkB,IAAIsB,IAAM,KAAO4B,GAAmBpE,IAAU,EAAI,EAEjO4R,EAAc5R,EAAM6C,QAChBC,EAAQ,EAkBZ,GAbI8O,GAAe5R,EAAM0C,UAEvBI,EAAQe,GAAO,EAAG7D,EAAMoD,MAAOjB,GAC/BgQ,EAAYxP,GAAgBG,EAAO8O,GACnC5R,EAAMmQ,OAAqB,EAAZgC,IAAkBD,EAAQ,EAAIA,GAEzCC,IAAcxP,GAAgB3C,EAAM4C,OAAQgP,KAE9C4J,EAAY,EAAItJ,EAChBlS,EAAMc,KAAKqU,eAAiBnV,EAAMG,UAAYH,EAAMoT,eAIpDlB,IAAUsJ,GAAa/gB,IAAclvG,GAASy0G,EAAM8D,SAAWjI,KAAasG,GAAanC,EAAM8D,OAAQ,CACzG,IAAK9D,EAAMG,UAAYsE,GAAkBzE,EAAOmC,EAAW52G,EAAOyyG,EAAgB8E,GAEhF,OAcF,IAXAgS,EAAgB9U,EAAM8D,OACtB9D,EAAM8D,OAAS3B,IAAcnE,EAAiBnC,GAAW,GAEzDmC,IAAmBA,EAAiBmE,IAAc2S,GAElD9U,EAAMkS,MAAQA,EACdlS,EAAMoa,QAAUlI,EAAQ,EAAIA,GAC5BlS,EAAMyD,MAAQ,EACdzD,EAAM4C,OAASE,EACf4V,EAAK1Y,EAAM2E,IAEJ+T,GACLA,EAAGxiJ,EAAEg8I,EAAOwG,EAAGhjJ,GACfgjJ,EAAKA,EAAGjX,MAGVU,EAAY,GAAKD,GAAelC,EAAOmC,EAAWnE,GAAgB,GAClEgC,EAAMuT,YAAcvV,GAAkBgM,GAAUhK,EAAO,YACvD8C,GAAS9C,EAAM0C,UAAY1E,GAAkBgC,EAAMh4G,QAAUgiH,GAAUhK,EAAO,aAEzEmC,GAAanC,EAAMoD,OAASjB,EAAY,IAAMnC,EAAMkS,QAAUA,IACjEA,GAASvQ,GAAkB3B,EAAO,GAE7BhC,GAAmBvD,KACtBuP,GAAUhK,EAAOkS,EAAQ,aAAe,qBAAqB,GAE7DlS,EAAM2T,OAAS3T,EAAM2T,SAG3B,MAAY3T,EAAM8D,SAChB9D,EAAM8D,OAAS3B,EAEnB,CA2wFMsZ,CAAyBvuJ,KAAMi1I,EAAWnE,EAAgBzyG,GAiI5D,OAAOr+B,IACT,EAEAouJ,EAAQtsB,QAAU,WAChB,OAAO9hI,KAAK0pJ,QACd,EAEA0E,EAAQlI,WAAa,SAAoByE,GAMvC,QAJEA,IAAS3qJ,KAAK4zI,KAAKqF,gBAAkBj5I,KAAKkzI,SAAW,GACvDlzI,KAAKy3I,IAAMz3I,KAAKotJ,IAAMptJ,KAAKqmJ,UAAYrmJ,KAAK+yI,MAAQ/yI,KAAKglJ,MAAQ,EACjEhlJ,KAAK8kJ,UAAY,GACjB9kJ,KAAKy2I,UAAYz2I,KAAKy2I,SAASyP,WAAWyE,GACnCiD,EAAYvrJ,UAAU6jJ,WAAWtkJ,KAAK5B,KAAM2qJ,EACrD,EAEAyD,EAAQI,QAAU,SAAiB73G,EAAUv5C,EAAO8xC,EAAOu/G,GACzD1gB,IAAiB4J,GAAQkK,OACzB7hJ,KAAKs1I,KAAOt1I,KAAK4lJ,OACjB,IAAI1mG,EAAOlhD,KAAKL,IAAIqC,KAAK80I,MAAO90I,KAAKg0I,IAAIuC,MAAQv2I,KAAK46G,QAAU56G,KAAKs1I,KAarE,OAXAt1I,KAAKizI,UAAYuE,GAAWx3I,KAAMk/C,GAxcd,SAA2B4zF,EAAOn8F,EAAUv5C,EAAO8xC,EAAOu/G,EAAiBzJ,EAAO9lG,GACxG,IACIssG,EACAkD,EACAC,EACAruJ,EAJAsuJ,GAAW9b,EAAM2E,KAAO3E,EAAMqa,WAAara,EAAMqa,SAAW,CAAC,IAAIx2G,GAMrE,IAAKi4G,EAKH,IAJAA,EAAU9b,EAAMqa,SAASx2G,GAAY,GACrCg4G,EAAS7b,EAAMgS,UACfxkJ,EAAIwyI,EAAM4W,SAAS/oJ,OAEZL,KAAK,CAGV,IAFAkrJ,EAAKmD,EAAOruJ,GAAGq2C,KAEL60G,EAAGhjJ,GAAKgjJ,EAAGhjJ,EAAEivI,IAIrB,IAFA+T,EAAKA,EAAGhjJ,EAAEivI,IAEH+T,GAAMA,EAAG9yH,IAAMie,GAAY60G,EAAGG,KAAOh1G,GAE1C60G,EAAKA,EAAGjX,MAIZ,IAAKiX,EAUH,OAPAV,GAAsB,EAEtBhY,EAAMc,KAAKj9F,GAAY,MAEvB6gG,GAAW1E,EAAO5zF,GAElB4rG,GAAsB,EACf,EAGT8D,EAAQnvJ,KAAK+rJ,EACf,CAKF,IAFAlrJ,EAAIsuJ,EAAQjuJ,OAELL,MAELkrJ,GADAkD,EAASE,EAAQtuJ,IACLm3I,KAAOiX,GAEhBx9I,GAAKg+B,GAAmB,IAAVA,GAAiBu/G,EAA0BjD,EAAGt6I,GAAKg+B,GAAS,GAAK81G,EAAQwG,EAAG75I,EAAzCu9B,EACpDs8G,EAAG75I,EAAIvU,EAAQouJ,EAAGt6I,EAClBw9I,EAAOxyJ,IAAMwyJ,EAAOxyJ,EAAIm2I,GAAOj1I,GAASi8I,GAAQqV,EAAOxyJ,IAEvDwyJ,EAAOh9I,IAAMg9I,EAAOh9I,EAAI85I,EAAGt6I,EAAImoI,GAAQqV,EAAOh9I,GAElD,CA6ZQm9I,CAAkB7uJ,KAAM22C,EAAUv5C,EAAO8xC,EAAOu/G,EAV5CzuJ,KAAKkjJ,MAAMhkG,EAAOl/C,KAAK80I,MAU6C51F,GACnEl/C,KAAKwuJ,QAAQ73G,EAAUv5C,EAAO8xC,EAAOu/G,IAI9CpY,GAAer2I,KAAM,GAErBA,KAAK86B,QAAUm5G,GAAmBj0I,KAAKg0I,IAAKh0I,KAAM,SAAU,QAASA,KAAKg0I,IAAIiD,MAAQ,SAAW,GAC1Fj3I,KAAKm7C,OAAO,GACrB,EAEAizG,EAAQpd,KAAO,SAAclP,EAAS8R,GAKpC,QAJa,IAATA,IACFA,EAAO,SAGJ9R,GAAa8R,GAAiB,QAATA,GAExB,OADA5zI,KAAK+yI,MAAQ/yI,KAAKy3I,IAAM,EACjBz3I,KAAK86B,OAASqiH,GAAWn9I,MAAQA,KAG1C,GAAIA,KAAKy2I,SAAU,CACjB,IAAIoR,EAAO7nJ,KAAKy2I,SAASR,gBAKzB,OAJAj2I,KAAKy2I,SAASuS,aAAalnB,EAAS8R,EAAM2V,KAA0D,IAArCA,GAAkB3V,KAAKpF,WAAoBuU,QAAU5F,GAAWn9I,MAE/HA,KAAK86B,QAAU+sH,IAAS7nJ,KAAKy2I,SAASR,iBAAmB+B,GAAah4I,KAAMA,KAAK80I,KAAO90I,KAAKy2I,SAASP,MAAQ2R,EAAM,EAAG,GAEhH7nJ,IACT,CAEA,IAII8uJ,EACAC,EACAC,EACA5F,EACA1wH,EACA8yH,EACAlrJ,EAVAkpJ,EAAgBxpJ,KAAK0pJ,SACrBuF,EAAiBntB,EAAUlsH,GAAQksH,GAAW0nB,EAC9C0F,EAAkBlvJ,KAAK8kJ,UACvBqK,EAAUnvJ,KAAKy3I,IASnB,KAAM7D,GAAiB,QAATA,IAxuGC,SAAsB9jI,EAAIC,GAI3C,IAHA,IAAIzP,EAAIwP,EAAGnP,OACP8qE,EAAQnrE,IAAMyP,EAAGpP,OAEd8qE,GAASnrE,KAAOwP,EAAGxP,KAAOyP,EAAGzP,KAEpC,OAAOA,EAAI,CACb,CAiuGqC8uJ,CAAa5F,EAAeyF,GAE3D,MADS,QAATrb,IAAmB5zI,KAAKy3I,IAAM,GACvB0F,GAAWn9I,MAsBpB,IAnBA8uJ,EAAmB9uJ,KAAKotJ,IAAMptJ,KAAKotJ,KAAO,GAE7B,QAATxZ,IAEE1E,GAAU0E,KACZl7G,EAAI,CAAC,EAELy5G,GAAayB,GAAM,SAAUpxI,GAC3B,OAAOk2B,EAAEl2B,GAAQ,CACnB,IAEAoxI,EAAOl7G,GAGTk7G,EAzdkB,SAA2B9R,EAAS8R,GAC1D,IAEIxgI,EACAslB,EACAp4B,EACAg+I,EALAxM,EAAUhQ,EAAQ,GAAKmQ,GAAUnQ,EAAQ,IAAIgQ,QAAU,EACvDud,EAAkBvd,GAAWA,EAAQwM,QAMzC,IAAK+Q,EACH,OAAOzb,EAKT,IAAKl7G,KAFLtlB,EAAOk9H,GAAO,CAAC,EAAGsD,GAERyb,EACR,GAAI32H,KAAKtlB,EAIP,IAFA9S,GADAg+I,EAAU+Q,EAAgB32H,GAAGw0C,MAAM,MACvBvsE,OAELL,KACL8S,EAAKkrI,EAAQh+I,IAAM8S,EAAKslB,GAK9B,OAAOtlB,CACT,CA+bak8I,CAAkB9F,EAAe5V,IAG1CtzI,EAAIkpJ,EAAc7oJ,OAEXL,KACL,IAAK2uJ,EAAe9hJ,QAAQq8I,EAAclpJ,IAYxC,IAAKo4B,KAXLq2H,EAAYG,EAAgB5uJ,GAEf,QAATszI,GACFkb,EAAiBxuJ,GAAKszI,EACtBwV,EAAQ2F,EACRC,EAAoB,CAAC,IAErBA,EAAoBF,EAAiBxuJ,GAAKwuJ,EAAiBxuJ,IAAM,CAAC,EAClE8oJ,EAAQxV,GAGAwV,GACRoC,EAAKuD,GAAaA,EAAUr2H,MAGpB,SAAU8yH,EAAGhjJ,IAAuB,IAAjBgjJ,EAAGhjJ,EAAEwoI,KAAKt4G,IACjC87G,GAAsBx0I,KAAMwrJ,EAAI,cAG3BuD,EAAUr2H,IAGO,QAAtBs2H,IACFA,EAAkBt2H,GAAK,GAQ/B,OAFA14B,KAAKizI,WAAajzI,KAAKy3I,KAAO0X,GAAWhS,GAAWn9I,MAE7CA,IACT,EAEAm5I,EAAM/rE,GAAK,SAAY00D,EAAS8R,GAC9B,OAAO,IAAIuF,EAAMrX,EAAS8R,EAAM12G,UAAU,GAC5C,EAEAi8G,EAAM12I,KAAO,SAAcq/H,EAAS8R,GAClC,OAAOiF,GAAiB,EAAG37G,UAC7B,EAEAi8G,EAAM6N,YAAc,SAAqBvY,EAAOxmH,EAAUg2C,EAAQzoB,GAChE,OAAO,IAAI2jG,EAAMlxH,EAAU,EAAG,CAC5BktH,iBAAiB,EACjBuC,MAAM,EACNlJ,WAAW,EACXC,MAAOA,EACP4Y,WAAYp/H,EACZsnI,kBAAmBtnI,EACnBq/H,iBAAkBrpF,EAClBuxF,wBAAyBvxF,EACzBi/E,cAAe1nG,GAEnB,EAEA2jG,EAAM0N,OAAS,SAAgB/kB,EAASglB,EAAUC,GAChD,OAAOlO,GAAiB,EAAG37G,UAC7B,EAEAi8G,EAAM5mI,IAAM,SAAauvH,EAAS8R,GAGhC,OAFAA,EAAKpxB,SAAW,EAChBoxB,EAAK8Q,cAAgB9Q,EAAKn0H,OAAS,GAC5B,IAAI05H,EAAMrX,EAAS8R,EAC5B,EAEAuF,EAAM6P,aAAe,SAAsBlnB,EAASsnB,EAAOC,GACzD,OAAO7b,GAAgBwb,aAAalnB,EAASsnB,EAAOC,EACtD,EAEOlQ,CACT,CAjegC,CAie9BsL,IAEFpR,GAAa8F,GAAM92I,UAAW,CAC5BqnJ,SAAU,GACV3W,MAAO,EACPG,SAAU,EACVka,IAAK,EACLE,QAAS,IAWXnb,GAAa,uCAAuC,SAAU3vI,GAC5D22I,GAAM32I,GAAQ,WACZ,IAAIqnJ,EAAK,IAAIvR,GACTr6E,EAASq7E,GAAO13I,KAAKs7B,UAAW,GAGpC,OADA+gC,EAAOh2D,OAAgB,kBAATzF,EAA2B,EAAI,EAAG,EAAG,GAC5CqnJ,EAAGrnJ,GAAMusF,MAAM86D,EAAI5rF,EAC5B,CACF,IAQA,IAAI+tF,GAAe,SAAsB5nJ,EAAQuyC,EAAUv5C,GACzD,OAAOgH,EAAOuyC,GAAYv5C,CAC5B,EACI2uJ,GAAc,SAAqB3nJ,EAAQuyC,EAAUv5C,GACvD,OAAOgH,EAAOuyC,GAAUv5C,EAC1B,EACI0uJ,GAAuB,SAA8B1nJ,EAAQuyC,EAAUv5C,EAAOiG,GAChF,OAAOe,EAAOuyC,GAAUtzC,EAAKsoJ,GAAIvuJ,EACnC,EACIqyJ,GAAmB,SAA0BrrJ,EAAQuyC,EAAUv5C,GACjE,OAAOgH,EAAOnH,aAAa05C,EAAUv5C,EACvC,EACIihJ,GAAa,SAAoBj6I,EAAQuyC,GAC3C,OAAOw4F,GAAY/qI,EAAOuyC,IAAao1G,GAAc1c,GAAajrI,EAAOuyC,KAAcvyC,EAAOnH,aAAewyJ,GAAmBzD,EAClI,EACIE,GAAe,SAAsBlH,EAAO3hJ,GAC9C,OAAOA,EAAKkP,IAAIlP,EAAKsL,EAAGtL,EAAKq1B,EAAG16B,KAAK2R,MAAkC,KAA3BtM,EAAK6N,EAAI7N,EAAKsO,EAAIqzI,IAAoB,IAAS3hJ,EAC7F,EACI4oJ,GAAiB,SAAwBjH,EAAO3hJ,GAClD,OAAOA,EAAKkP,IAAIlP,EAAKsL,EAAGtL,EAAKq1B,KAAMr1B,EAAK6N,EAAI7N,EAAKsO,EAAIqzI,GAAQ3hJ,EAC/D,EACIooJ,GAAuB,SAA8BzG,EAAO3hJ,GAC9D,IAAImoJ,EAAKnoJ,EAAKo0I,IACVvmI,EAAI,GAER,IAAK8zI,GAAS3hJ,EAAKqO,EAEjBR,EAAI7N,EAAKqO,OACJ,GAAc,IAAVszI,GAAe3hJ,EAAKnH,EAE7BgV,EAAI7N,EAAKnH,MACJ,CACL,KAAOsvJ,GACLt6I,EAAIs6I,EAAG9yH,GAAK8yH,EAAG/8I,EAAI+8I,EAAG/8I,EAAE+8I,EAAGt6I,EAAIs6I,EAAG75I,EAAIqzI,GAAShnJ,KAAK2R,MAA8B,KAAvB67I,EAAGt6I,EAAIs6I,EAAG75I,EAAIqzI,IAAkB,KAAS9zI,EAEpGs6I,EAAKA,EAAGjX,MAGVrjI,GAAK7N,EAAKsO,CACZ,CAEAtO,EAAKkP,IAAIlP,EAAKsL,EAAGtL,EAAKq1B,EAAGxnB,EAAG7N,EAC9B,EACIw6I,GAAoB,SAA2BmH,EAAO3hJ,GAGxD,IAFA,IAAImoJ,EAAKnoJ,EAAKo0I,IAEP+T,GACLA,EAAGxiJ,EAAEg8I,EAAOwG,EAAGhjJ,GACfgjJ,EAAKA,EAAGjX,KAEZ,EACI0J,GAAqB,SAA4BD,EAAUlL,EAAO1uI,EAAQuyC,GAI5E,IAHA,IACI90C,EADA2pJ,EAAKxrJ,KAAKy3I,IAGP+T,GACL3pJ,EAAO2pJ,EAAGjX,MACViX,EAAG9yH,IAAMie,GAAY60G,EAAGxN,SAASA,EAAUlL,EAAO1uI,GAClDonJ,EAAK3pJ,CAET,EACIk8I,GAAoB,SAA2BpnG,GAKjD,IAJA,IACI+4G,EACA7tJ,EAFA2pJ,EAAKxrJ,KAAKy3I,IAIP+T,GACL3pJ,EAAO2pJ,EAAGjX,MAENiX,EAAG9yH,IAAMie,IAAa60G,EAAGmE,IAAMnE,EAAGmE,KAAOh5G,EAC3C69F,GAAsBx0I,KAAMwrJ,EAAI,OACtBA,EAAGoE,MACbF,EAA2B,GAG7BlE,EAAK3pJ,EAGP,OAAQ6tJ,CACV,EACIG,GAAsB,SAA6BzrJ,EAAQuyC,EAAUv5C,EAAOiG,GAC9EA,EAAKysJ,KAAK1rJ,EAAQuyC,EAAUtzC,EAAKoL,EAAE7M,KAAKyB,EAAKyvI,MAAO11I,EAAOiG,EAAK0sJ,IAAK1sJ,EACvE,EACIgqJ,GAA4B,SAAmCvyH,GAOjE,IANA,IACIj5B,EACAmuJ,EACAC,EACAC,EAJA1E,EAAK1wH,EAAO28G,IAMT+T,GAAI,CAIT,IAHA3pJ,EAAO2pJ,EAAGjX,MACVyb,EAAMC,EAECD,GAAOA,EAAIG,GAAK3E,EAAG2E,IACxBH,EAAMA,EAAIzb,OAGRiX,EAAGlX,MAAQ0b,EAAMA,EAAI1b,MAAQ4b,GAC/B1E,EAAGlX,MAAMC,MAAQiX,EAEjByE,EAAQzE,GAGNA,EAAGjX,MAAQyb,GACbA,EAAI1b,MAAQkX,EAEZ0E,EAAO1E,EAGTA,EAAK3pJ,CACP,CAEAi5B,EAAO28G,IAAMwY,CACf,EAGW1R,GAAyB,WAClC,SAASA,EAAU18I,EAAMuC,EAAQ0E,EAAMomC,EAAOkhH,EAAQp5G,EAAU3zC,EAAM2nJ,EAAQuB,GAC5EvsJ,KAAK2O,EAAIvK,EACTpE,KAAKkR,EAAIg+B,EACTlvC,KAAK2R,EAAIy+I,EACTpwJ,KAAK04B,EAAI5vB,EACT9I,KAAKgJ,EAAIguC,GAAYk1G,GACrBlsJ,KAAKwI,EAAInF,GAAQrD,KACjBA,KAAKuS,IAAMy4I,GAAUgB,GACrBhsJ,KAAKmwJ,GAAK5D,GAAY,EACtBvsJ,KAAKu0I,MAAQ1yI,EAETA,IACFA,EAAKyyI,MAAQt0I,KAEjB,CAcA,OAZcu+I,EAAUl8I,UAEhB27I,SAAW,SAAkBja,EAAM+O,EAAO1uI,GAChDpE,KAAK8vJ,KAAO9vJ,KAAK8vJ,MAAQ9vJ,KAAKuS,IAE9BvS,KAAKuS,IAAMs9I,GACX7vJ,KAAKyO,EAAIs1H,EACT/jI,KAAK+vJ,GAAK3rJ,EAEVpE,KAAK8yI,MAAQA,CACf,EAEOyL,CACT,CA9BoC,GAgCpCpM,GAAaT,GAAiB,uOAAuO,SAAUlvI,GAC7Q,OAAO2uI,GAAe3uI,GAAQ,CAChC,IAEA2tI,GAASkgB,SAAWlgB,GAASmgB,UAAYnX,GACzChJ,GAASogB,aAAepgB,GAASqgB,YAAclY,GAC/C9K,GAAkB,IAAI8K,GAAS,CAC7BqO,cAAc,EACdrT,SAAU/E,GACVoG,oBAAoB,EACpBh1I,GAAI,OACJ22I,mBAAmB,IAErBpI,GAAQ+c,aAAexK,GAEvB,IAAIgQ,GAAS,GACTxjJ,GAAa,CAAC,EACdyjJ,GAAc,GACdC,GAAiB,EACjBC,GAAa,EACbC,GAAY,SAAmB9jJ,GACjC,OAAQE,GAAWF,IAAS2jJ,IAAazwJ,KAAI,SAAU6Y,GACrD,OAAOA,GACT,GACF,EACIg4I,GAAiB,WACnB,IAAI5xG,EAAOquE,KAAKN,MACZ2B,EAAU,GAEV1vE,EAAOyxG,GAAiB,IAC1BE,GAAU,kBAEVJ,GAAO3qJ,SAAQ,SAAU6L,GACvB,IAEI85D,EACA/yC,EACAq4H,EACAC,EALAC,EAAUt/I,EAAEs/I,QACZC,EAAav/I,EAAEu/I,WAMnB,IAAKx4H,KAAKu4H,GACRxlF,EAAQgiE,GAAK0jB,WAAWF,EAAQv4H,IAAIk2F,WAE1BmiC,EAAW,GAEjBtlF,IAAUylF,EAAWx4H,KACvBw4H,EAAWx4H,GAAK+yC,EAChBulF,EAAU,GAIVA,IACFr/I,EAAEujI,SACF6b,GAAYniC,EAAQnvH,KAAKkS,GAE7B,IAEAk/I,GAAU,oBAEVjiC,EAAQ9oH,SAAQ,SAAU6L,GACxB,OAAOA,EAAEy/I,QAAQz/I,EACnB,IACAg/I,GAAiBzxG,EAEjB2xG,GAAU,cAEd,EAEIQ,GAAuB,WACzB,SAASA,EAAQttB,EAAMvuF,GACrBx1C,KAAK25I,SAAWnkG,GAASmkG,GAASnkG,GAClCx1C,KAAKqD,KAAO,GACZrD,KAAKsxJ,GAAK,GAEVtxJ,KAAKuxJ,YAAa,EAClBvxJ,KAAKL,GAAKixJ,KAEV7sB,GAAQ/jI,KAAKhD,IAAI+mI,EACnB,CAEA,IAAIytB,EAAUH,EAAQhvJ,UA8GtB,OA5GAmvJ,EAAQx0J,IAAM,SAAawF,EAAMuhI,EAAMvuF,GAMjC25F,GAAY3sI,KACdgzC,EAAQuuF,EACRA,EAAOvhI,EACPA,EAAO2sI,IAGT,IAAIt7B,EAAO7zG,KACP8Y,EAAI,WACN,IAEIlU,EAFAyvI,EAAO,GACPod,EAAe59C,EAAK8lC,SAUxB,OARAtF,GAAQA,IAASxgC,GAAQwgC,EAAKhxI,KAAK5D,KAAKo0G,GACxCr+D,IAAUq+D,EAAK8lC,SAAWA,GAASnkG,IACnC,GAAWq+D,EACXjvG,EAASm/H,EAAKh1C,MAAM8kB,EAAM32E,WAC1BiyG,GAAYvqI,IAAWivG,EAAKy9C,GAAG7xJ,KAAKmF,GACpC,GAAWyvI,EACXxgC,EAAK8lC,SAAW8X,EAChB59C,EAAK09C,YAAa,EACX3sJ,CACT,EAGA,OADAivG,EAAKq8C,KAAOp3I,EACLtW,IAAS2sI,GAAcr2H,EAAE+6F,GAAQrxG,EAAOqxG,EAAKrxG,GAAQsW,EAAIA,CAClE,EAEA04I,EAAQE,OAAS,SAAgB3tB,GAC/B,IAAIsQ,EAAO,GACX,GAAW,KACXtQ,EAAK/jI,MACL,GAAWq0I,CACb,EAEAmd,EAAQG,UAAY,WAClB,IAAIlpJ,EAAI,GAIR,OAHAzI,KAAKqD,KAAKyC,SAAQ,SAAU5J,GAC1B,OAAOA,aAAam1J,EAAU5oJ,EAAEhJ,KAAKsvF,MAAMtmF,EAAGvM,EAAEy1J,aAAez1J,aAAai9I,MAAWj9I,EAAE4+B,QAA4B,WAAlB5+B,EAAE4+B,OAAOz3B,OAAsBoF,EAAEhJ,KAAKvD,EAC3I,IACOuM,CACT,EAEA+oJ,EAAQn0H,MAAQ,WACdr9B,KAAKsxJ,GAAG3wJ,OAASX,KAAKqD,KAAK1C,OAAS,CACtC,EAEA6wJ,EAAQxgB,KAAO,SAAckE,EAAQic,GACnC,IAAIS,EAAS5xJ,KAEb,GAAIk1I,EAAQ,CACV,IAAIyT,EAAS3oJ,KAAK2xJ,YAClB3xJ,KAAKqD,KAAKyC,SAAQ,SAAU6I,GAEX,WAAXA,EAAEtL,OACJsL,EAAEumI,SACFvmI,EAAE+5I,aAAY,GAAM,GAAM,GAAO5iJ,SAAQ,SAAUgtI,GACjD,OAAO6V,EAAO1gJ,OAAO0gJ,EAAOx7I,QAAQ2lI,GAAQ,EAC9C,IAEJ,IAEA6V,EAAO1oJ,KAAI,SAAU0O,GACnB,MAAO,CACLoK,EAAGpK,EAAE62I,WAAW,GAChB72I,EAAGA,EAEP,IAAGg2D,MAAK,SAAUl8D,EAAGiJ,GACnB,OAAOA,EAAEqH,EAAItQ,EAAEsQ,IAAK,GACtB,IAAGjT,SAAQ,SAAU7D,GACnB,OAAOA,EAAE0M,EAAEumI,OAAOA,EACpB,IAEAl1I,KAAKqD,KAAKyC,SAAQ,SAAU5J,GAC1B,QAASA,aAAai9I,KAAUj9I,EAAEg5I,QAAUh5I,EAAEg5I,OAAOA,EACvD,IAEAl1I,KAAKsxJ,GAAGxrJ,SAAQ,SAAUgT,GACxB,OAAOA,EAAEo8H,EAAQ0c,EACnB,IAEA5xJ,KAAKuxJ,YAAa,CACpB,MACEvxJ,KAAKqD,KAAKyC,SAAQ,SAAU5J,GAC1B,OAAOA,EAAE80I,MAAQ90I,EAAE80I,MACrB,IAKF,GAFAhxI,KAAKq9B,QAED8zH,EAGF,IAFA,IAAI7wJ,EAAImwJ,GAAO9vJ,OAERL,KAELmwJ,GAAOnwJ,GAAGX,KAAOK,KAAKL,IAAM8wJ,GAAOxoJ,OAAO3H,EAAG,EAGnD,EAEAkxJ,EAAQtc,OAAS,SAAgBsI,GAC/Bx9I,KAAKgxI,KAAKwM,GAAU,CAAC,EACvB,EAEO6T,CACT,CA3H2B,GA6HvBQ,GAA0B,WAC5B,SAASA,EAAWr8G,GAClBx1C,KAAK8xJ,SAAW,GAChB9xJ,KAAKw1C,MAAQA,CACf,CAEA,IAAIu8G,EAAUF,EAAWxvJ,UAsDzB,OApDA0vJ,EAAQ/0J,IAAM,SAAak0J,EAAYntB,EAAMvuF,GAC3C85F,GAAU4hB,KAAgBA,EAAa,CACrCtiC,QAASsiC,IAEX,IAEIc,EACAt5H,EACAu5H,EAJAl1I,EAAU,IAAIs0I,GAAQ,EAAG77G,GAASx1C,KAAKw1C,OACvC08G,EAAOn1I,EAAQm0I,WAAa,CAAC,EAUjC,IAAKx4H,KANL,KAAa3b,EAAQ48H,WAAa58H,EAAQ48H,SAAW,GAASA,UAE9D35I,KAAK8xJ,SAASryJ,KAAKsd,GACnBgnH,EAAOhnH,EAAQ/f,IAAI,UAAW+mI,GAC9BhnH,EAAQk0I,QAAUC,EAERA,EACE,QAANx4H,EACFu5H,EAAS,GAETD,EAAKvkB,GAAK0jB,WAAWD,EAAWx4H,OAG9B+3H,GAAOtjJ,QAAQ4P,GAAW,GAAK0zI,GAAOhxJ,KAAKsd,IAC1Cm1I,EAAKx5H,GAAKs5H,EAAGpjC,WAAaqjC,EAAS,GACpCD,EAAGG,YAAcH,EAAGG,YAAYrB,IAAkBkB,EAAG/1J,iBAAiB,SAAU60J,KAMtF,OADAmB,GAAUluB,EAAKhnH,GACR/c,IACT,EAWA+xJ,EAAQ7c,OAAS,SAAgBsI,GAC/Bx9I,KAAKgxI,KAAKwM,GAAU,CAAC,EACvB,EAEAuU,EAAQ/gB,KAAO,SAAckE,GAC3Bl1I,KAAK8xJ,SAAShsJ,SAAQ,SAAU6L,GAC9B,OAAOA,EAAEq/H,KAAKkE,GAAQ,EACxB,GACF,EAEO2c,CACT,CA7D8B,GAqE1BhgB,GAAQ,CACVugB,eAAgB,WACd,IAAK,IAAIC,EAAQn1H,UAAUv8B,OAAQ2xJ,EAAO,IAAIrxJ,MAAMoxJ,GAAQE,EAAQ,EAAGA,EAAQF,EAAOE,IACpFD,EAAKC,GAASr1H,UAAUq1H,GAG1BD,EAAKxsJ,SAAQ,SAAU03I,GACrB,OAAOD,GAAcC,EACvB,GACF,EACA/G,SAAU,SAAkB7C,GAC1B,OAAO,IAAI0E,GAAS1E,EACtB,EACA0V,YAAa,SAAqBxnB,EAASunB,GACzC,OAAO7b,GAAgB8b,YAAYxnB,EAASunB,EAC9C,EACAmJ,YAAa,SAAqBpuJ,EAAQuyC,EAAUgyB,EAAM8pF,GACxDvjB,GAAU9qI,KAAYA,EAASwR,GAAQxR,GAAQ,IAE/C,IAAImE,EAAS0pI,GAAU7tI,GAAU,CAAC,GAAGyE,IACjCmW,EAAS2pD,EAAOyqE,GAAeD,GAGnC,MADS,WAATxqE,IAAsBA,EAAO,IACrBvkE,EAAmBuyC,EAEvB33B,GAAQsyH,GAAS36F,IAAa26F,GAAS36F,GAAU9tC,KAAON,GAAQnE,EAAQuyC,EAAUgyB,EAAM8pF,IAFtD,SAAU97G,EAAUgyB,EAAM8pF,GAC9D,OAAOzzI,GAAQsyH,GAAS36F,IAAa26F,GAAS36F,GAAU9tC,KAAON,GAAQnE,EAAQuyC,EAAUgyB,EAAM8pF,GACjG,EAFiBruJ,CAGnB,EACAsuJ,YAAa,SAAqBtuJ,EAAQuyC,EAAUgyB,GAGlD,IAFAvkE,EAASwR,GAAQxR,IAENzD,OAAS,EAAG,CACrB,IAAIgyJ,EAAUvuJ,EAAOnE,KAAI,SAAU0O,GACjC,OAAO4hI,GAAKmiB,YAAY/jJ,EAAGgoC,EAAUgyB,EACvC,IACIj7D,EAAIilJ,EAAQhyJ,OAChB,OAAO,SAAUvD,GAGf,IAFA,IAAIkD,EAAIoN,EAEDpN,KACLqyJ,EAAQryJ,GAAGlD,EAEf,CACF,CAEAgH,EAASA,EAAO,IAAM,CAAC,EAEvB,IAAIs5I,EAASpM,GAAS36F,GAClBtW,EAAQ4xG,GAAU7tI,GAClBs0B,EAAI2H,EAAMyxG,UAAYzxG,EAAMyxG,QAAQwM,SAAW,CAAC,GAAG3nG,IAAaA,EAEpEq0G,EAAStN,EAAS,SAAUtgJ,GAC1B,IAAIs7B,EAAI,IAAIglH,EACZ5P,GAAY2J,IAAM,EAClB/+G,EAAE0hC,KAAKh2D,EAAQukE,EAAOvrE,EAAQurE,EAAOvrE,EAAO0wI,GAAa,EAAG,CAAC1pI,IAC7Ds0B,EAAEyiB,OAAO,EAAGziB,GACZo1G,GAAY2J,KAAOoG,GAAkB,EAAG/P,GAC1C,EAAIztG,EAAM9tB,IAAInO,EAAQs0B,GAEtB,OAAOglH,EAASsN,EAAS,SAAU5tJ,GACjC,OAAO4tJ,EAAO5mJ,EAAQs0B,EAAGiwC,EAAOvrE,EAAQurE,EAAOvrE,EAAOijC,EAAO,EAC/D,CACF,EACAuyH,QAAS,SAAiBxuJ,EAAQuyC,EAAUi9F,GAC1C,IAAIif,EAEA/f,EAAQvC,GAAKnjE,GAAGhpE,EAAQksI,KAAQuiB,EAAU,CAAC,GAAWl8G,GAAY,QAASk8G,EAAQzN,QAAS,EAAMyN,GAAUjf,GAAQ,CAAC,IACrH7P,EAAO,SAAc3mI,EAAO8xC,EAAOu/G,GACrC,OAAO3b,EAAM0b,QAAQ73G,EAAUv5C,EAAO8xC,EAAOu/G,EAC/C,EAGA,OADA1qB,EAAK+O,MAAQA,EACN/O,CACT,EACA+uB,WAAY,SAAoBhxB,GAC9B,OAAO0L,GAAgB8b,YAAYxnB,GAAS,GAAMnhI,OAAS,CAC7D,EACA2yI,SAAU,SAAkBl2I,GAE1B,OADAA,GAASA,EAAMo9I,OAASp9I,EAAMo9I,KAAOC,GAAWr9I,EAAMo9I,KAAMjM,GAAUiM,OAC/DhH,GAAWjF,GAAWnxI,GAAS,CAAC,EACzC,EACAogJ,OAAQ,SAAgBpgJ,GACtB,OAAOo2I,GAAWtF,GAAS9wI,GAAS,CAAC,EACvC,EACA21J,eAAgB,SAAwBC,GACtC,IAAIxwJ,EAAOwwJ,EAAMxwJ,KACbywJ,EAASD,EAAMC,OACf/9B,EAAU89B,EAAM99B,QAChBoe,EAAW0f,EAAM1f,SACjB4f,EAAiBF,EAAME,gBAC1Bh+B,GAAW,IAAIhoD,MAAM,KAAKpnE,SAAQ,SAAUqtJ,GAC3C,OAAOA,IAAe7hB,GAAS6hB,KAAgBhjB,GAASgjB,IAAe1iB,GAAMjuI,EAAO,oBAAsB2wJ,EAAa,WACzH,IAEA5hB,GAAS/uI,GAAQ,SAAUs/H,EAAS8R,EAAMiW,GACxC,OAAOoJ,EAAOr9I,GAAQksH,GAAUuR,GAAaO,GAAQ,CAAC,EAAGN,GAAWuW,EACtE,EAEIqJ,IACF5a,GAASj2I,UAAUG,GAAQ,SAAUs/H,EAAS8R,EAAMxmH,GAClD,OAAOptB,KAAKhD,IAAIu0I,GAAS/uI,GAAMs/H,EAASwN,GAAUsE,GAAQA,GAAQxmH,EAAWwmH,IAAS,CAAC,EAAG5zI,MAAOotB,EACnG,EAEJ,EACAgmI,aAAc,SAAsB5wJ,EAAMg4I,GACxC+H,GAAS//I,GAAQi4I,GAAWD,EAC9B,EACA6Y,UAAW,SAAmB7Y,EAAM4I,GAClC,OAAOlmH,UAAUv8B,OAAS85I,GAAWD,EAAM4I,GAAeb,EAC5D,EACAuG,QAAS,SAAiBnpJ,GACxB,OAAO6tI,GAAgBsb,QAAQnpJ,EACjC,EACA2zJ,WAAY,SAAoB1f,EAAM2f,QACvB,IAAT3f,IACFA,EAAO,CAAC,GAGV,IACIt1G,EACAz8B,EAFAgoJ,EAAK,IAAIvR,GAAS1E,GAYtB,IATAiW,EAAGvT,kBAAoB/G,GAAYqE,EAAK0C,mBAExC9I,GAAgBtwI,OAAO2sJ,GAEvBA,EAAG7V,IAAM,EAET6V,EAAGtT,MAAQsT,EAAGnU,OAASlI,GAAgB+I,MACvCj4G,EAAQkvG,GAAgBuV,OAEjBzkH,GACLz8B,EAAOy8B,EAAMi2G,OAETgf,IAA0Bj1H,EAAMw2G,MAAQx2G,aAAiB66G,IAAS76G,EAAMs1G,KAAKyT,aAAe/oH,EAAMorH,SAAS,IAC7G7S,GAAegT,EAAIvrH,EAAOA,EAAMs8E,OAASt8E,EAAM04G,QAGjD14G,EAAQz8B,EAKV,OAFAg1I,GAAerJ,GAAiBqc,EAAI,GAE7BA,CACT,EACA9sI,QAAS,SAAiBgnH,EAAMvuF,GAC9B,OAAOuuF,EAAO,IAAIstB,GAAQttB,EAAMvuF,GAAS,EAC3C,EACA27G,WAAY,SAAoB37G,GAC9B,OAAO,IAAIq8G,GAAWr8G,EACxB,EACAg+G,kBAAmB,WACjB,OAAO/C,GAAO3qJ,SAAQ,SAAU6L,GAC9B,IACI8hJ,EACA/6H,EAFAw5H,EAAOvgJ,EAAEu/I,WAIb,IAAKx4H,KAAKw5H,EACJA,EAAKx5H,KACPw5H,EAAKx5H,IAAK,EACV+6H,EAAQ,GAIZA,GAAS9hJ,EAAEujI,QACb,KAAM4b,IACR,EACA70J,iBAAkB,SAA0B8Q,EAAMkb,GAChD,IAAIxf,EAAIwE,GAAWF,KAAUE,GAAWF,GAAQ,KAC/CtE,EAAE0E,QAAQ8a,IAAaxf,EAAEhJ,KAAKwoB,EACjC,EACA5a,oBAAqB,SAA6BN,EAAMkb,GACtD,IAAIxf,EAAIwE,GAAWF,GACfzM,EAAImI,GAAKA,EAAE0E,QAAQ8a,GACvB3nB,GAAK,GAAKmI,EAAER,OAAO3H,EAAG,EACxB,EACA2vF,MAAO,CACLzvE,KA51GO,SAASA,EAAK7iB,EAAK4Q,EAAKnR,GAEjC,IAAI4T,EAAQzC,EAAM5Q,EAClB,OAAOgyI,GAAShyI,GAAOq+I,GAAWr+I,EAAK6iB,EAAK,EAAG7iB,EAAIgD,QAAS4N,GAAO6qI,GAAmBh8I,GAAO,SAAUA,GACrG,OAAQ4T,GAAS5T,EAAQO,GAAOqT,GAASA,EAAQrT,CACnD,GACF,EAu1GI+1J,SAt1GW,SAASA,EAAS/1J,EAAK4Q,EAAKnR,GACzC,IAAI4T,EAAQzC,EAAM5Q,EACd8qH,EAAgB,EAARz3G,EACZ,OAAO2+H,GAAShyI,GAAOq+I,GAAWr+I,EAAK+1J,EAAS,EAAG/1J,EAAIgD,OAAS,GAAI4N,GAAO6qI,GAAmBh8I,GAAO,SAAUA,GAE7G,OAAOO,IADPP,GAASqrH,GAASrrH,EAAQO,GAAO8qH,GAASA,GAAS,GAC7Bz3G,EAAQy3G,EAAQrrH,EAAQA,EAChD,GACF,EAg1GIk9I,WAAYA,GACZrsI,OAAQA,GACRwtI,KAAMA,GACN/rI,UAz2GY,SAAmB/R,EAAK4Q,EAAKnR,GAC3C,OAAOg/I,GAASz+I,EAAK4Q,EAAK,EAAG,EAAGnR,EAClC,EAw2GIi8I,QAASA,GACT/qI,MApjHI,SAAe3Q,EAAK4Q,EAAKnR,GAC/B,OAAOg8I,GAAmBh8I,GAAO,SAAUiW,GACzC,OAAOsjI,GAAOh5I,EAAK4Q,EAAK8E,EAC1B,GACF,EAijHIysI,WAAYA,GACZlqI,QAASA,GACT+jI,SAAUA,GACVyC,SAAUA,GACVuX,KAh4GO,WACT,IAAK,IAAIC,EAAO12H,UAAUv8B,OAAQkzJ,EAAY,IAAI5yJ,MAAM2yJ,GAAOE,EAAO,EAAGA,EAAOF,EAAME,IACpFD,EAAUC,GAAQ52H,UAAU42H,GAG9B,OAAO,SAAU12J,GACf,OAAOy2J,EAAUE,QAAO,SAAU1gJ,EAAGyF,GACnC,OAAOA,EAAEzF,EACX,GAAGjW,EACL,CACF,EAu3GI42J,QAt3GU,SAAiBjwB,EAAMp7D,GACnC,OAAO,SAAUvrE,GACf,OAAO2mI,EAAKx4F,WAAWnuC,KAAWurE,GAAQ0wE,GAAQj8I,GACpD,CACF,EAm3GI62J,YAj0Gc,SAASA,EAAY/kH,EAAO2N,EAAKwgG,EAAU6W,GAC3D,IAAInwB,EAAO9wG,MAAMic,EAAQ2N,GAAO,EAAI,SAAUnkB,GAC5C,OAAQ,EAAIA,GAAKwW,EAAQxW,EAAImkB,CAC/B,EAEA,IAAKknF,EAAM,CACT,IAEIrrG,EACAp4B,EACA6zJ,EACAzmJ,EACA+d,EANA2oI,EAAWllB,GAAUhgG,GACrBmlH,EAAS,CAAC,EASd,IAFa,IAAbhX,IAAsB6W,EAAS,KAAO7W,EAAW,MAE7C+W,EACFllH,EAAQ,CACNxW,EAAGwW,GAEL2N,EAAM,CACJnkB,EAAGmkB,QAEA,GAAI8yF,GAASzgG,KAAWygG,GAAS9yF,GAAM,CAK5C,IAJAs3G,EAAgB,GAChBzmJ,EAAIwhC,EAAMvuC,OACV8qB,EAAK/d,EAAI,EAEJpN,EAAI,EAAGA,EAAIoN,EAAGpN,IACjB6zJ,EAAc10J,KAAKw0J,EAAY/kH,EAAM5uC,EAAI,GAAI4uC,EAAM5uC,KAGrDoN,IAEAq2H,EAAO,SAAcrrG,GACnBA,GAAKhrB,EACL,IAAIpN,EAAItC,KAAKL,IAAI8tB,IAAMiN,GACvB,OAAOy7H,EAAc7zJ,GAAGo4B,EAAIp4B,EAC9B,EAEA+8I,EAAWxgG,CACb,MAAYq3G,IACVhlH,EAAQohG,GAAOX,GAASzgG,GAAS,GAAK,CAAC,EAAGA,IAG5C,IAAKilH,EAAe,CAClB,IAAKz7H,KAAKmkB,EACRihG,GAAcl8I,KAAKyyJ,EAAQnlH,EAAOxW,EAAG,MAAOmkB,EAAInkB,IAGlDqrG,EAAO,SAAcrrG,GACnB,OAAOmlH,GAAkBnlH,EAAG27H,KAAYD,EAAWllH,EAAMxW,EAAIwW,EAC/D,CACF,CACF,CAEA,OAAOkqG,GAAmBiE,EAAUtZ,EACtC,EAywGIsW,QAASA,IAEXia,QAASjkB,GACTkkB,QAAShjB,GACTijB,OAAQ7c,GACRkT,WAAYvS,GAASuS,WACrB31B,QAASoc,GACTmjB,eAAgBjnB,GAChBknB,KAAM,CACJnW,UAAWA,GACXoW,QAAShkB,GACTwI,MAAOA,GACPb,SAAUA,GACVmM,UAAWA,GACXmQ,SAAU3iB,GACVuC,sBAAuBA,GACvBqgB,UAAW,WACT,OAAOtnB,EACT,EACAxwH,QAAS,SAAiB+3I,GAOxB,OANIA,GAAS,KACX,GAASzxJ,KAAK5D,KAAKq1J,GAEnBA,EAAM7X,KAAO,IAGR,EACT,EACA8X,mBAAoB,SAA4B33J,GAC9C,OAAOkwI,GAAsBlwI,CAC/B,IAIJ+0I,GAAa,+CAA+C,SAAU3vI,GACpE,OAAOqvI,GAAMrvI,GAAQ22I,GAAM32I,EAC7B,IAEAm1I,GAAQ36I,IAAIs7I,GAASuS,YAErB/c,GAAc+D,GAAMzkE,GAAG,CAAC,EAAG,CACzBo1C,SAAU,IAGZ,IAAIwyC,GAAsB,SAA6Br/B,EAAQ7sH,GAG7D,IAFA,IAAI0iJ,EAAK71B,EAAO8hB,IAET+T,GAAMA,EAAG9yH,IAAM5vB,GAAQ0iJ,EAAGmE,KAAO7mJ,GAAQ0iJ,EAAGG,KAAO7iJ,GACxD0iJ,EAAKA,EAAGjX,MAGV,OAAOiX,CACT,EAwBIyJ,GAAuB,SAA8BzyJ,EAAMw7I,GAC7D,MAAO,CACLx7I,KAAMA,EACN07I,QAAS,EAET9jF,KAAM,SAAch2D,EAAQwvI,EAAMd,GAChCA,EAAMwa,QAAU,SAAUxa,GACxB,IAAIoiB,EAAMx8H,EAaV,GAXIw2G,GAAU0E,KACZshB,EAAO,CAAC,EAER/iB,GAAayB,GAAM,SAAUpxI,GAC3B,OAAO0yJ,EAAK1yJ,GAAQ,CACtB,IAGAoxI,EAAOshB,GAGLlX,EAAU,CAGZ,IAAKtlH,KAFLw8H,EAAO,CAAC,EAEEthB,EACRshB,EAAKx8H,GAAKslH,EAASpK,EAAKl7G,IAG1Bk7G,EAAOshB,CACT,EAnDY,SAAuBpiB,EAAOqiB,GAChD,IACIz8H,EACAp4B,EACAkrJ,EAHA1pB,EAAUgR,EAAM4W,SAKpB,IAAKhxH,KAAKy8H,EAGR,IAFA70J,EAAIwhI,EAAQnhI,OAELL,MACLkrJ,EAAK1Y,EAAMgS,UAAUxkJ,GAAGo4B,MAEb8yH,EAAKA,EAAGhjJ,KACbgjJ,EAAG/T,MAEL+T,EAAKwJ,GAAoBxJ,EAAI9yH,IAG/B8yH,GAAMA,EAAGxN,UAAYwN,EAAGxN,SAASmX,EAAUz8H,GAAIo6G,EAAOhR,EAAQxhI,GAAIo4B,GAI1E,CA+BQ08H,CAActiB,EAAOc,EACvB,CACF,EAEJ,EAGWrD,GAAOsB,GAAMugB,eAAe,CACrC5vJ,KAAM,OACN43D,KAAM,SAAch2D,EAAQwvI,EAAMd,EAAO/0I,EAAO+jI,GAC9C,IAAIppG,EAAG8yH,EAAIn4I,EAGX,IAAKqlB,KAFL14B,KAAK8yI,MAAQA,EAEHc,EACRvgI,EAAIjP,EAAOirC,aAAa3W,IAAM,IAC9B8yH,EAAKxrJ,KAAKhD,IAAIoH,EAAQ,gBAAiBiP,GAAK,GAAK,GAAIugI,EAAKl7G,GAAI36B,EAAO+jI,EAAS,EAAG,EAAGppG,IACjFi3H,GAAKj3H,EACR8yH,EAAG95I,EAAI2B,EAEPrT,KAAK29I,OAAOl+I,KAAKi5B,EAErB,EACAyiB,OAAQ,SAAgB6pG,EAAO3hJ,GAG7B,IAFA,IAAImoJ,EAAKnoJ,EAAKo0I,IAEP+T,GACLje,GAAaie,EAAGj5I,IAAIi5I,EAAG78I,EAAG68I,EAAG9yH,EAAG8yH,EAAG95I,EAAG85I,GAAMA,EAAGxiJ,EAAEg8I,EAAOwG,EAAGhjJ,GAE3DgjJ,EAAKA,EAAGjX,KAEZ,GACC,CACD/xI,KAAM,WACN43D,KAAM,SAAch2D,EAAQhH,GAG1B,IAFA,IAAIkD,EAAIlD,EAAMuD,OAEPL,KACLN,KAAKhD,IAAIoH,EAAQ9D,EAAG8D,EAAO9D,IAAM,EAAGlD,EAAMkD,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAEjE,GACC20J,GAAqB,aAAc1Z,IAAiB0Z,GAAqB,aAAcA,GAAqB,OAAQxZ,MAAU5J,GAEjIsH,GAAMt7H,QAAUy6H,GAASz6H,QAAU0yH,GAAK1yH,QAAU,SAClD+vH,GAAa,EACb4B,MAAmBoK,KACN2I,GAAS8S,OACT9S,GAAS+S,OACT/S,GAASgT,OACThT,GAASiT,OACTjT,GAASkT,OACTlT,GAAS4B,OACX5B,GAASmT,KACRnT,GAASoT,MACTpT,GAASqT,MACTrT,GAASsT,MACRtT,GAASuT,OACRvT,GAASwT,QACZxT,GAASyT,KACFzT,GAAS+B,YACd/B,GAAS0T,OACX1T,GAAS2T,KACT3T,GAAS4T,KACT5T,GAAS6T,KAjBpB,ICz0II,GACA,GACAC,GACAC,GACAC,GAEAC,GACA,GAoJAC,GAhJAC,GAAkB,CAAC,EACnBC,GAAW,IAAM34J,KAAKI,GACtBw4J,GAAW54J,KAAKI,GAAK,IACrBy4J,GAAS74J,KAAKG,MAEd24J,GAAW,WACXC,GAAiB,uCACjBC,GAAc,YACdC,GAAmB,CACrBC,UAAW,qBACX98I,MAAO,gBACP/E,MAAO,WAEL8hJ,GAAiB,SAAwBnS,EAAO3hJ,GAClD,OAAOA,EAAKkP,IAAIlP,EAAKsL,EAAGtL,EAAKq1B,EAAG16B,KAAK2R,MAAkC,KAA3BtM,EAAK6N,EAAI7N,EAAKsO,EAAIqzI,IAAkB,IAAQ3hJ,EAAK+nB,EAAG/nB,EAClG,EACI+zJ,GAAqB,SAA4BpS,EAAO3hJ,GAC1D,OAAOA,EAAKkP,IAAIlP,EAAKsL,EAAGtL,EAAKq1B,EAAa,IAAVssH,EAAc3hJ,EAAKnH,EAAI8B,KAAK2R,MAAkC,KAA3BtM,EAAK6N,EAAI7N,EAAKsO,EAAIqzI,IAAkB,IAAQ3hJ,EAAK+nB,EAAG/nB,EACzH,EACIg0J,GAA8B,SAAqCrS,EAAO3hJ,GAC5E,OAAOA,EAAKkP,IAAIlP,EAAKsL,EAAGtL,EAAKq1B,EAAGssH,EAAQhnJ,KAAK2R,MAAkC,KAA3BtM,EAAK6N,EAAI7N,EAAKsO,EAAIqzI,IAAkB,IAAQ3hJ,EAAK+nB,EAAI/nB,EAAKqO,EAAGrO,EACnH,EAEAi0J,GAAwB,SAA+BtS,EAAO3hJ,GAC5D,IAAIjG,EAAQiG,EAAK6N,EAAI7N,EAAKsO,EAAIqzI,EAC9B3hJ,EAAKkP,IAAIlP,EAAKsL,EAAGtL,EAAKq1B,KAAMt7B,GAASA,EAAQ,GAAK,GAAK,KAAOiG,EAAK+nB,EAAG/nB,EACxE,EACIk0J,GAA0B,SAAiCvS,EAAO3hJ,GACpE,OAAOA,EAAKkP,IAAIlP,EAAKsL,EAAGtL,EAAKq1B,EAAGssH,EAAQ3hJ,EAAKnH,EAAImH,EAAKqO,EAAGrO,EAC3D,EACIm0J,GAAmC,SAA0CxS,EAAO3hJ,GACtF,OAAOA,EAAKkP,IAAIlP,EAAKsL,EAAGtL,EAAKq1B,EAAa,IAAVssH,EAAc3hJ,EAAKqO,EAAIrO,EAAKnH,EAAGmH,EACjE,EACIo0J,GAAkB,SAAyBrzJ,EAAQuyC,EAAUv5C,GAC/D,OAAOgH,EAAOvH,MAAM85C,GAAYv5C,CAClC,EACIs6J,GAAiB,SAAwBtzJ,EAAQuyC,EAAUv5C,GAC7D,OAAOgH,EAAOvH,MAAMC,YAAY65C,EAAUv5C,EAC5C,EACIu6J,GAAmB,SAA0BvzJ,EAAQuyC,EAAUv5C,GACjE,OAAOgH,EAAOytI,MAAMl7F,GAAYv5C,CAClC,EACIw6J,GAAe,SAAsBxzJ,EAAQuyC,EAAUv5C,GACzD,OAAOgH,EAAOytI,MAAMv9G,OAASlwB,EAAOytI,MAAMr9G,OAASp3B,CACrD,EACIy6J,GAAyB,SAAgCzzJ,EAAQuyC,EAAUv5C,EAAOiG,EAAM2hJ,GAC1F,IAAI3kH,EAAQj8B,EAAOytI,MACnBxxG,EAAM/L,OAAS+L,EAAM7L,OAASp3B,EAC9BijC,EAAMy3H,gBAAgB9S,EAAO3kH,EAC/B,EACI03H,GAA6B,SAAoC3zJ,EAAQuyC,EAAUv5C,EAAOiG,EAAM2hJ,GAClG,IAAI3kH,EAAQj8B,EAAOytI,MACnBxxG,EAAMsW,GAAYv5C,EAClBijC,EAAMy3H,gBAAgB9S,EAAO3kH,EAC/B,EACI23H,GAAiB,YACjBC,GAAuBD,GAAiB,SACxCE,GAAa,SAASA,EAAWvhH,EAAUwhH,GAC7C,IAAI7rD,EAAQtsG,KAERoE,EAASpE,KAAKoE,OACdvH,EAAQuH,EAAOvH,MAEnB,GAAI85C,KAAY+/G,IAAmB75J,EAAO,CAGxC,GAFAmD,KAAKo4J,IAAMp4J,KAAKo4J,KAAO,CAAC,EAEP,cAAbzhH,EAMF,OAAOsgH,GAAiBp2D,UAAU3zB,MAAM,KAAKpnE,SAAQ,SAAU4yB,GAC7D,OAAOw/H,EAAWt2J,KAAK0qG,EAAO5zE,EAAGy/H,EACnC,IAGF,KAVExhH,EAAWsgH,GAAiBtgH,IAAaA,GAC/BxpC,QAAQ,KAAOwpC,EAASu2B,MAAM,KAAKpnE,SAAQ,SAAU2C,GAC7D,OAAO6jG,EAAM8rD,IAAI3vJ,GAAK4vJ,GAAKj0J,EAAQqE,EACrC,IAAKzI,KAAKo4J,IAAIzhH,GAAYvyC,EAAOytI,MAAMv1I,EAAI8H,EAAOytI,MAAMl7F,GAAY0hH,GAAKj0J,EAAQuyC,GAO/E32C,KAAKopJ,MAAMj8I,QAAQ6qJ,KAAmB,EACxC,OAGE5zJ,EAAOytI,MAAMymB,MACft4J,KAAKu4J,KAAOn0J,EAAOirC,aAAa,mBAChCrvC,KAAKopJ,MAAM3pJ,KAAKw4J,GAAsBE,EAAU,KAGlDxhH,EAAWqhH,EACb,EAECn7J,GAASs7J,IAAan4J,KAAKopJ,MAAM3pJ,KAAKk3C,EAAUwhH,EAAUt7J,EAAM85C,GACnE,EACI6hH,GAA+B,SAAsC37J,GACnEA,EAAM4d,YACR5d,EAAM47J,eAAe,aACrB57J,EAAM47J,eAAe,SACrB57J,EAAM47J,eAAe,UAEzB,EACIC,GAAe,WACjB,IAIIp4J,EACAo4B,EALA0wH,EAAQppJ,KAAKopJ,MACbhlJ,EAASpE,KAAKoE,OACdvH,EAAQuH,EAAOvH,MACfwjC,EAAQj8B,EAAOytI,MAInB,IAAKvxI,EAAI,EAAGA,EAAI8oJ,EAAMzoJ,OAAQL,GAAK,EAEjC8oJ,EAAM9oJ,EAAI,GAAK8D,EAAOglJ,EAAM9oJ,IAAM8oJ,EAAM9oJ,EAAI,GAAK8oJ,EAAM9oJ,EAAI,GAAKzD,EAAMusJ,EAAM9oJ,IAAM8oJ,EAAM9oJ,EAAI,GAAKzD,EAAM47J,eAAyC,OAA1BrP,EAAM9oJ,GAAGmyI,OAAO,EAAG,GAAc2W,EAAM9oJ,GAAK8oJ,EAAM9oJ,GAAG2D,QAAQ6yJ,GAAU,OAAOzoJ,eAGtM,GAAIrO,KAAKo4J,IAAK,CACZ,IAAK1/H,KAAK14B,KAAKo4J,IACb/3H,EAAM3H,GAAK14B,KAAKo4J,IAAI1/H,GAGlB2H,EAAMi4H,MACRj4H,EAAMy3H,kBACN1zJ,EAAOnH,aAAa,kBAAmB+C,KAAKu4J,MAAQ,MAGtDj4J,EAAI,OAEQA,EAAEywI,SAAal0I,EAAMm7J,MAC/BQ,GAA6B37J,GAE7BwjC,EAAMoyH,QAAU,EAEpB,CACF,EACIkG,GAAiB,SAAwBv0J,EAAQooD,GACnD,IAAIosG,EAAQ,CACVx0J,OAAQA,EACRglJ,MAAO,GACPlU,OAAQwjB,GACRG,KAAMX,IAOR,OALA9zJ,EAAOytI,OAAStB,GAAKmkB,KAAKE,SAASxwJ,GAEnCooD,GAAcA,EAAW0gB,MAAM,KAAKpnE,SAAQ,SAAU4yB,GACpD,OAAOkgI,EAAMC,KAAKngI,EACpB,IACOkgI,CACT,EAEIE,GAAiB,SAAwB/rJ,EAAMgsJ,GACjD,IAAI78J,EAAI,GAAK2e,gBAAkB,GAAKA,iBAAiBk+I,GAAM,gCAAgC90J,QAAQ,SAAU,QAAS8I,GAAQ,GAAKrH,cAAcqH,GAEjJ,OAAO7Q,EAAEW,MAAQX,EAAI,GAAKwJ,cAAcqH,EAC1C,EACIisJ,GAAuB,SAASA,EAAqB50J,EAAQuyC,EAAUsiH,GACzE,IAAIC,EAAKC,iBAAiB/0J,GAC1B,OAAO80J,EAAGviH,IAAauiH,EAAGE,iBAAiBziH,EAAS1yC,QAAQ6yJ,GAAU,OAAOzoJ,gBAAkB6qJ,EAAGE,iBAAiBziH,KAAcsiH,GAAsBD,EAAqB50J,EAAQi1J,GAAiB1iH,IAAaA,EAAU,IAAM,EACpO,EACI2iH,GAAY,qBAAqBpsF,MAAM,KACvCmsF,GAAmB,SAA0B1iH,EAAU3X,EAASu6H,GAClE,IACIroJ,GADI8tB,GAAWu3H,IACT15J,MACNyD,EAAI,EAER,GAAIq2C,KAAYzlC,IAAMqoJ,EACpB,OAAO5iH,EAKT,IAFAA,EAAWA,EAAShL,OAAO,GAAGshC,cAAgBt2B,EAAS87F,OAAO,GAEvDnyI,OAASg5J,GAAUh5J,GAAKq2C,KAAYzlC,KAE3C,OAAO5Q,EAAI,EAAI,MAAc,IAANA,EAAU,KAAOA,GAAK,EAAIg5J,GAAUh5J,GAAK,IAAMq2C,CACxE,EACI6iH,GAAY,WA5KW,oBAAXn8J,QA6KSA,OAAOtB,WAC5B,GAAOsB,OACP,GAAO,GAAKtB,SACZs6J,GAAc,GAAK73J,gBACnB+3J,GAAWuC,GAAe,QAAU,CAClCj8J,MAAO,CAAC,GAEOi8J,GAAe,OAChCd,GAAiBqB,GAAiBrB,IAClCC,GAAuBD,GAAiB,SACxCzB,GAAS15J,MAAM6J,QAAU,2DAEzB+vJ,KAAgB4C,GAAiB,eACjC,GAAa9oB,GAAKmkB,KAAKG,UACvByB,GAAiB,EAErB,EACImD,GAAe,SAASA,EAAaC,GAEvC,IAIIC,EAJArB,EAAMQ,GAAe,MAAO94J,KAAK45J,iBAAmB55J,KAAK45J,gBAAgBvqH,aAAa,UAAY,8BAClGwqH,EAAY75J,KAAKwH,WACjBsyJ,EAAa95J,KAAK+5J,YAClBC,EAASh6J,KAAKnD,MAAM6J,QAQxB,GALA2vJ,GAAYnwJ,YAAYoyJ,GAExBA,EAAIpyJ,YAAYlG,MAChBA,KAAKnD,MAAMyuG,QAAU,QAEjBouD,EACF,IACEC,EAAO35J,KAAKi6J,UACZj6J,KAAKk6J,UAAYl6J,KAAKi6J,QAEtBj6J,KAAKi6J,QAAUR,CACjB,CAAE,MAAOv9J,GAAI,MACJ8D,KAAKk6J,YACdP,EAAO35J,KAAKk6J,aAcd,OAXIL,IACEC,EACFD,EAAU9yJ,aAAa/G,KAAM85J,GAE7BD,EAAU3zJ,YAAYlG,OAI1Bq2J,GAAYvvJ,YAAYwxJ,GAExBt4J,KAAKnD,MAAM6J,QAAUszJ,EACdL,CACT,EACIQ,GAAyB,SAAgC/1J,EAAQg2J,GAGnE,IAFA,IAAI95J,EAAI85J,EAAgBz5J,OAEjBL,KACL,GAAI8D,EAAOmrC,aAAa6qH,EAAgB95J,IACtC,OAAO8D,EAAOirC,aAAa+qH,EAAgB95J,GAGjD,EACI+5J,GAAW,SAAkBj2J,GAC/B,IAAIk2J,EAEJ,IACEA,EAASl2J,EAAO61J,SAClB,CAAE,MAAO98H,GACPm9H,EAASb,GAAa73J,KAAKwC,GAAQ,EACrC,CAIA,OAFAk2J,IAAWA,EAAO3nJ,OAAS2nJ,EAAO1nJ,SAAWxO,EAAO61J,UAAYR,KAAiBa,EAASb,GAAa73J,KAAKwC,GAAQ,KAE7Gk2J,GAAWA,EAAO3nJ,OAAU2nJ,EAAOh+J,GAAMg+J,EAAO99J,EAKnD89J,EALuD,CACzDh+J,GAAI69J,GAAuB/1J,EAAQ,CAAC,IAAK,KAAM,QAAU,EACzD5H,GAAI29J,GAAuB/1J,EAAQ,CAAC,IAAK,KAAM,QAAU,EACzDuO,MAAO,EACPC,OAAQ,EAEZ,EACI2nJ,GAAS,SAAgBr+J,GAC3B,SAAUA,EAAEs+J,QAAYt+J,EAAEsL,aAActL,EAAE09J,kBAAoBS,GAASn+J,GACzE,EAEAu+J,GAAkB,SAAyBr2J,EAAQuyC,GACjD,GAAIA,EAAU,CACZ,IAAI95C,EAAQuH,EAAOvH,MAEf85C,KAAY+/G,IAAmB//G,IAAashH,KAC9CthH,EAAWqhH,IAGTn7J,EAAM47J,gBACsB,OAA1B9hH,EAAS87F,OAAO,EAAG,IAAyC,WAA1B97F,EAAS87F,OAAO,EAAG,KAEvD97F,EAAW,IAAMA,GAGnB95C,EAAM47J,eAAe9hH,EAAS1yC,QAAQ6yJ,GAAU,OAAOzoJ,gBAGvDxR,EAAMoK,gBAAgB0vC,EAE1B,CACF,EACI+jH,GAAoB,SAA2B/kC,EAAQvxH,EAAQuyC,EAAUgkH,EAAW99G,EAAK+9G,GAC3F,IAAIpP,EAAK,IAAIjN,GAAU5oB,EAAO8hB,IAAKrzI,EAAQuyC,EAAU,EAAG,EAAGikH,EAAepD,GAAmCD,IAO7G,OANA5hC,EAAO8hB,IAAM+T,EACbA,EAAG95I,EAAIipJ,EACPnP,EAAGtvJ,EAAI2gD,EAEP84E,EAAOgoB,OAAOl+I,KAAKk3C,GAEZ60G,CACT,EACIqP,GAAuB,CACzB38J,IAAK,EACL48J,IAAK,EACLC,KAAM,GAEJC,GAAsB,CACxB7f,KAAM,EACN8f,KAAM,GAGRC,GAAiB,SAASA,EAAe92J,EAAQuyC,EAAUv5C,EAAOurE,GAChE,IAUIwyF,EACArgI,EACAuF,EACA+6H,EAbAC,EAAW9vH,WAAWnuC,IAAU,EAChCk+J,GAAWl+J,EAAQ,IAAI0vE,OAAO2lE,QAAQ4oB,EAAW,IAAI16J,SAAW,KAEpE9D,EAAQ05J,GAAS15J,MACb0+J,EAAaxE,GAAer0J,KAAKi0C,GACjC6kH,EAA6C,QAAjCp3J,EAAOq3J,QAAQptJ,cAC3BqtJ,GAAmBF,EAAY,SAAW,WAAaD,EAAa,QAAU,UAC9ElgB,EAAS,IACTsgB,EAAoB,OAAThzF,EACXizF,EAAqB,MAATjzF,EAMhB,OAAIA,IAAS2yF,IAAYD,GAAYR,GAAqBlyF,IAASkyF,GAAqBS,GAC/ED,GAGG,OAAZC,IAAqBK,IAAaN,EAAWH,EAAe92J,EAAQuyC,EAAUv5C,EAAO,OACrFg+J,EAAQh3J,EAAOo2J,QAAUD,GAAOn2J,IAE3Bw3J,GAAyB,MAAZN,IAAqB5E,GAAgB//G,MAAcA,EAASxpC,QAAQ,UAKtFtQ,EAAM0+J,EAAa,QAAU,UAAYlgB,GAAUsgB,EAAWL,EAAU3yF,GACxE7tC,GAAU6b,EAASxpC,QAAQ,UAAqB,OAATw7D,GAAiBvkE,EAAO8B,cAAgBs1J,EAAYp3J,EAASA,EAAOoD,WAEvG4zJ,IACFtgI,GAAU12B,EAAOw1J,iBAAmB,CAAC,GAAGpyJ,YAGrCszB,GAAUA,IAAW,IAASA,EAAO50B,cACxC40B,EAAS,GAAK9+B,OAGhBqkC,EAAQvF,EAAO+2G,QAEF+pB,GAAav7H,EAAM1tB,OAAS4oJ,GAAcl7H,EAAM6e,OAASy4F,GAAQz4F,OAAS7e,EAAMoyH,QACpFpgB,GAAOgpB,EAAWh7H,EAAM1tB,MAAQ0oI,KAEtCugB,GAAyB,MAAZN,KAAqBN,GAAoBhC,GAAqBl+H,EAAQ,cAAgBj+B,EAAMuwB,SAAW4rI,GAAqB50J,EAAQ,aAClJ02B,IAAW12B,IAAWvH,EAAMuwB,SAAW,UAEvC0N,EAAO50B,YAAYqwJ,IACnB4E,EAAK5E,GAASmF,GACd5gI,EAAOh0B,YAAYyvJ,IACnB15J,EAAMuwB,SAAW,WAEbmuI,GAAcK,KAChBv7H,EAAQ4xG,GAAUn3G,IACZokB,KAAOy4F,GAAQz4F,KACrB7e,EAAM1tB,MAAQmoB,EAAO4gI,IAIlBrpB,GAAOspB,EAAWR,EAAKE,EAAWhgB,EAAS8f,GAAME,EAAWhgB,EAAS8f,EAAKE,EAAW,MAnC1FF,EAAKC,EAAQh3J,EAAO61J,UAAUsB,EAAa,QAAU,UAAYn3J,EAAOs3J,GACjErpB,GAAOupB,EAAYP,EAAWF,EAAK9f,EAASggB,EAAW,IAAMF,IAmCxE,EACI9C,GAAO,SAAcj0J,EAAQuyC,EAAUgyB,EAAM8pF,GAC/C,IAAIr1J,EAsBJ,OArBAk5J,IAAkBkD,KAEd7iH,KAAYsgH,IAAiC,cAAbtgH,KAClCA,EAAWsgH,GAAiBtgH,IAEdxpC,QAAQ,OACpBwpC,EAAWA,EAASu2B,MAAM,KAAK,IAI/BwpF,GAAgB//G,IAA0B,cAAbA,GAC/Bv5C,EAAQy+J,GAAgBz3J,EAAQquJ,GAChCr1J,EAAqB,oBAAbu5C,EAAiCv5C,EAAMu5C,GAAYv5C,EAAMk7J,IAAMl7J,EAAMuzB,OAASmrI,GAAc9C,GAAqB50J,EAAQ6zJ,KAAyB,IAAM76J,EAAM2+J,QAAU,SAEhL3+J,EAAQgH,EAAOvH,MAAM85C,KAEG,SAAVv5C,GAAoBq1J,KAAar1J,EAAQ,IAAI+P,QAAQ,YACjE/P,EAAQ4+J,GAAcrlH,IAAaqlH,GAAcrlH,GAAUvyC,EAAQuyC,EAAUgyB,IAASqwF,GAAqB50J,EAAQuyC,IAAau7F,GAAa9tI,EAAQuyC,KAA2B,YAAbA,EAAyB,EAAI,IAI7LgyB,MAAWvrE,EAAQ,IAAI0vE,OAAO3/D,QAAQ,KAAO+tJ,GAAe92J,EAAQuyC,EAAUv5C,EAAOurE,GAAQA,EAAOvrE,CAC7G,EACI6+J,GAAyB,SAAgC73J,EAAQ0E,EAAMomC,EAAO2N,GAEhF,IAAK3N,GAAmB,SAAVA,EAAkB,CAE9B,IAAIxW,EAAI2gI,GAAiBvwJ,EAAM1E,EAAQ,GACnC8M,EAAIwnB,GAAKsgI,GAAqB50J,EAAQs0B,EAAG,GAEzCxnB,GAAKA,IAAMg+B,GACbpmC,EAAO4vB,EACPwW,EAAQh+B,GACU,gBAATpI,IACTomC,EAAQ8pH,GAAqB50J,EAAQ,kBAEzC,CAEA,IAGIqE,EACA7D,EACAs3J,EACA5Q,EACA9vI,EACA2gJ,EACAC,EACAhR,EACAC,EACAgR,EACAC,EAbA9Q,EAAK,IAAIjN,GAAUv+I,KAAKy3I,IAAKrzI,EAAOvH,MAAOiM,EAAM,EAAG,EAAG2iJ,IACvD1tJ,EAAQ,EACR2tJ,EAAa,EAmCjB,GAtBAF,EAAG95I,EAAIw9B,EACPs8G,EAAGtvJ,EAAI2gD,EACP3N,GAAS,GAIG,SAFZ2N,GAAO,MAGLz4C,EAAOvH,MAAMiM,GAAQ+zC,EACrBA,EAAMm8G,GAAqB50J,EAAQ0E,IAAS+zC,EAC5Cz4C,EAAOvH,MAAMiM,GAAQomC,GAKvBuxG,GAFAh4I,EAAI,CAACymC,EAAO2N,IAMZA,EAAMp0C,EAAE,GACRyzJ,GAFAhtH,EAAQzmC,EAAE,IAEUgjE,MAAMqkE,KAAoB,IAClCjzF,EAAI4uB,MAAMqkE,KAAoB,IAE5BnvI,OAAQ,CACpB,KAAOiE,EAASkrI,GAAgBtkG,KAAKqR,IACnCu/G,EAAWx3J,EAAO,GAClBymJ,EAAQxuG,EAAIqyE,UAAUnxH,EAAO6G,EAAO7G,OAEhCyd,EACFA,GAASA,EAAQ,GAAK,EACQ,UAArB6vI,EAAM5Y,QAAQ,IAAuC,UAArB4Y,EAAM5Y,QAAQ,KACvDj3H,EAAQ,GAGN4gJ,KAAcD,EAAaD,EAAYxQ,MAAiB,MAC1DJ,EAAW//G,WAAW4wH,IAAe,EACrCG,EAAYH,EAAW1pB,QAAQ6Y,EAAW,IAAI3qJ,QACvB,MAAvBy7J,EAASzwH,OAAO,KAAeywH,EAAW7pB,GAAe+Y,EAAU8Q,GAAYE,GAC/ElR,EAAS7/G,WAAW6wH,GACpBC,EAAUD,EAAS3pB,QAAQ2Y,EAAS,IAAIzqJ,QACxC5C,EAAQ+xI,GAAgBtkE,UAAY6wF,EAAQ17J,OAEvC07J,IAEHA,EAAUA,GAAWnuB,GAAQ5jE,MAAMxhE,IAASwzJ,EAExCv+J,IAAU8+C,EAAIl8C,SAChBk8C,GAAOw/G,EACP7Q,EAAGtvJ,GAAKmgK,IAIRC,IAAcD,IAChB/Q,EAAW4P,GAAe92J,EAAQ0E,EAAMqzJ,EAAYE,IAAY,GAIlE7Q,EAAG/T,IAAM,CACPlD,MAAOiX,EAAG/T,IACV/+G,EAAG2yH,GAAwB,IAAfK,EAAmBL,EAAQ,IAEvCn6I,EAAGo6I,EACH35I,EAAGy5I,EAASE,EACZ78I,EAAG+M,GAASA,EAAQ,GAAc,WAAT1S,EAAoB9K,KAAK2R,MAAQ,IAKhE67I,EAAG75I,EAAI5T,EAAQ8+C,EAAIl8C,OAASk8C,EAAIqyE,UAAUnxH,EAAO8+C,EAAIl8C,QAAU,EACjE,MACE6qJ,EAAGxiJ,EAAa,YAATF,GAA8B,SAAR+zC,EAAiB26G,GAAmCD,GAOnF,OAJAvnB,GAAQttI,KAAKm6C,KAAS2uG,EAAGtvJ,EAAI,GAE7B8D,KAAKy3I,IAAM+T,EAEJA,CACT,EACI+Q,GAAoB,CACtBnkI,IAAK,KACLC,OAAQ,OACRH,KAAM,KACNC,MAAO,OACPjiB,OAAQ,OAkBNsmJ,GAAoB,SAA2BxX,EAAO3hJ,GACxD,GAAIA,EAAKyvI,OAASzvI,EAAKyvI,MAAMyD,QAAUlzI,EAAKyvI,MAAMgC,KAAM,CACtD,IAIIhsI,EACA2zJ,EACAn8J,EANA8D,EAASf,EAAKsL,EACd9R,EAAQuH,EAAOvH,MACfusJ,EAAQ/lJ,EAAK+nB,EACbiV,EAAQj8B,EAAOytI,MAKnB,GAAc,QAAVuX,IAA6B,IAAVA,EACrBvsJ,EAAM6J,QAAU,GAChB+1J,EAAkB,OAKlB,IAFAn8J,GADA8oJ,EAAQA,EAAMl8E,MAAM,MACVvsE,SAEDL,GAAK,GACZwI,EAAOsgJ,EAAM9oJ,GAETo2J,GAAgB5tJ,KAClB2zJ,EAAkB,EAClB3zJ,EAAgB,oBAATA,EAA6BmvJ,GAAuBD,IAG7DyC,GAAgBr2J,EAAQ0E,GAIxB2zJ,IACFhC,GAAgBr2J,EAAQ4zJ,IAEpB33H,IACFA,EAAMi4H,KAAOl0J,EAAO6C,gBAAgB,aAEpC40J,GAAgBz3J,EAAQ,GAGxBi8B,EAAMoyH,QAAU,EAEhB+F,GAA6B37J,IAGnC,CACF,EAEAm/J,GAAgB,CACdU,WAAY,SAAoB/mC,EAAQvxH,EAAQuyC,EAAUylH,EAAUtpB,GAClE,GAAmB,gBAAfA,EAAMzvI,KAAwB,CAChC,IAAImoJ,EAAK71B,EAAO8hB,IAAM,IAAI8G,GAAU5oB,EAAO8hB,IAAKrzI,EAAQuyC,EAAU,EAAG,EAAG6lH,IAOxE,OANAhR,EAAGpgI,EAAIgxI,EACP5Q,EAAG2E,IAAM,GACT3E,EAAG1Y,MAAQA,EAEXnd,EAAOgoB,OAAOl+I,KAAKk3C,GAEZ,CACT,CACF,GAwEFgmH,GAAoB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAChCC,GAAwB,CAAC,EACzBC,GAAmB,SAA0Bz/J,GAC/C,MAAiB,6BAAVA,GAAkD,SAAVA,IAAqBA,CACtE,EACI0/J,GAAqC,SAA4C14J,GACnF,IAAI24J,EAAe/D,GAAqB50J,EAAQ4zJ,IAEhD,OAAO6E,GAAiBE,GAAgBJ,GAAoBI,EAAatqB,OAAO,GAAGhnE,MAAMokE,IAAS5vI,IAAIoyI,GACxG,EACI2qB,GAAa,SAAoB54J,EAAQ64J,GAC3C,IAGIniI,EACAi/H,EACA7E,EACAgI,EANA78H,EAAQj8B,EAAOytI,OAASI,GAAU7tI,GAClCvH,EAAQuH,EAAOvH,MACf8d,EAASmiJ,GAAmC14J,GAMhD,OAAIi8B,EAAMi4H,KAAOl0J,EAAOirC,aAAa,aAIP,iBAD5B10B,EAAS,EAFTu6I,EAAO9wJ,EAAOy8F,UAAUs8D,QAAQC,cAAcziJ,QAE/BlS,EAAGysJ,EAAKxjJ,EAAGwjJ,EAAKvjJ,EAAGujJ,EAAK1sJ,EAAG0sJ,EAAKh5J,EAAGg5J,EAAKp8I,IACzCzY,KAAK,KAAyBs8J,GAAoBhiJ,GACvDA,IAAWgiJ,IAAsBv4J,EAAOi5J,cAAgBj5J,IAAWiyJ,IAAgBh2H,EAAMi4H,MAGlGpD,EAAOr4J,EAAMyuG,QACbzuG,EAAMyuG,QAAU,SAChBxwE,EAAS12B,EAAOoD,aAEApD,EAAOi5J,eAErBH,EAAa,EAEbnD,EAAc31J,EAAOk5J,mBAErBjH,GAAYnwJ,YAAY9B,IAI1BuW,EAASmiJ,GAAmC14J,GAC5C8wJ,EAAOr4J,EAAMyuG,QAAU4pD,EAAOuF,GAAgBr2J,EAAQ,WAElD84J,IACFnD,EAAcj/H,EAAO/zB,aAAa3C,EAAQ21J,GAAej/H,EAASA,EAAO50B,YAAY9B,GAAUiyJ,GAAYvvJ,YAAY1C,KAIpH64J,GAAWtiJ,EAAOha,OAAS,EAAI,CAACga,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAAKA,EAAO,KAAOA,EAC/G,EACI4iJ,GAAkB,SAAyBn5J,EAAQusB,EAAQ6sI,EAAkBC,EAAQC,EAAaC,GACpG,IAeIrD,EACAzhJ,EAEArc,EAlBA6jC,EAAQj8B,EAAOytI,MACfl3H,EAAS+iJ,GAAeV,GAAW54J,GAAQ,GAC3Cw5J,EAAav9H,EAAMw9H,SAAW,EAC9BC,EAAaz9H,EAAM09H,SAAW,EAC9BC,EAAa39H,EAAMimE,SAAW,EAC9B23D,EAAa59H,EAAM69H,SAAW,EAC9Bz1J,EAAIkS,EAAO,GACXjJ,EAAIiJ,EAAO,GACXhJ,EAAIgJ,EAAO,GACXnS,EAAImS,EAAO,GACXd,EAAKc,EAAO,GACZb,EAAKa,EAAO,GACZwjJ,EAAcxtI,EAAOu8C,MAAM,KAC3B2wF,EAAUtyH,WAAW4yH,EAAY,KAAO,EACxCJ,EAAUxyH,WAAW4yH,EAAY,KAAO,EAMvCX,EAIM7iJ,IAAWgiJ,KAAsB9jJ,EAAcpQ,EAAID,EAAIkJ,EAAIC,KAGpEnV,EAAIqhK,IAAYnsJ,EAAImH,GAAeklJ,GAAWt1J,EAAIoQ,IAAgBpQ,EAAIqR,EAAKpI,EAAImI,GAAMhB,EACrFglJ,EAFIA,GAAWr1J,EAAIqQ,GAAeklJ,IAAYpsJ,EAAIkH,IAAgBlH,EAAImI,EAAKtR,EAAIqR,GAAMhB,EAGrFklJ,EAAUvhK,IAPVqhK,GADAvD,EAASD,GAASj2J,IACD9H,IAAM6hK,EAAY,GAAGhxJ,QAAQ,KAAO0wJ,EAAU,IAAMvD,EAAO3nJ,MAAQkrJ,GACpFE,EAAUzD,EAAO99J,KAAO2hK,EAAY,IAAMA,EAAY,IAAIhxJ,QAAQ,KAAO4wJ,EAAU,IAAMzD,EAAO1nJ,OAASmrJ,IASvGN,IAAqB,IAAXA,GAAoBp9H,EAAMo9H,QACtC5jJ,EAAKgkJ,EAAUD,EACf9jJ,EAAKikJ,EAAUD,EACfz9H,EAAMimE,QAAU03D,GAAcnkJ,EAAKpR,EAAIqR,EAAKnI,GAAKkI,EACjDwmB,EAAM69H,QAAUD,GAAcpkJ,EAAKnI,EAAIoI,EAAKtR,GAAKsR,GAEjDumB,EAAMimE,QAAUjmE,EAAM69H,QAAU,EAGlC79H,EAAMw9H,QAAUA,EAChBx9H,EAAM09H,QAAUA,EAChB19H,EAAMo9H,SAAWA,EACjBp9H,EAAM1P,OAASA,EACf0P,EAAMm9H,mBAAqBA,EAC3Bp5J,EAAOvH,MAAMo7J,IAAwB,UAEjC0F,IACFjD,GAAkBiD,EAAyBt9H,EAAO,UAAWu9H,EAAYC,GAEzEnD,GAAkBiD,EAAyBt9H,EAAO,UAAWy9H,EAAYC,GAEzErD,GAAkBiD,EAAyBt9H,EAAO,UAAW29H,EAAY39H,EAAMimE,SAE/Eo0D,GAAkBiD,EAAyBt9H,EAAO,UAAW49H,EAAY59H,EAAM69H,UAGjF95J,EAAOnH,aAAa,kBAAmB4gK,EAAU,IAAME,EACzD,EACIlC,GAAkB,SAAyBz3J,EAAQquJ,GACrD,IAAIpyH,EAAQj8B,EAAOytI,OAAS,IAAIG,GAAQ5tI,GAExC,GAAI,MAAOi8B,IAAUoyH,IAAYpyH,EAAMoyH,QACrC,OAAOpyH,EAGT,IAMI/jC,EACAE,EACAskB,EACAwT,EACAE,EACAva,EACAmkJ,EACAC,EACAC,EACAC,EACAC,EACAX,EACAE,EACApjJ,EACA/F,EACA/C,EACAC,EACArJ,EACAiJ,EACAC,EACAnJ,EACAoP,EACAG,EACAoa,EACAssI,EACAC,EACA7mJ,EACAG,EACAG,EACA4d,EACAC,EACA9d,EArCArb,EAAQuH,EAAOvH,MACf8hK,EAAiBt+H,EAAM/L,OAAS,EAChC6mI,EAAK,KACLj9J,EAAM,MACNg7J,EAAKC,iBAAiB/0J,GACtBusB,EAASqoI,GAAqB50J,EAAQ6zJ,KAAyB,IAyMnE,OAxKA37J,EAAIE,EAAIskB,EAAI7G,EAAWmkJ,EAAYC,EAAYC,EAAQC,EAAQC,EAAc,EAC7ElqI,EAASE,EAAS,EAClB6L,EAAMi4H,OAASl0J,EAAOo2J,SAAUD,GAAOn2J,IAEnC80J,EAAGz+I,YAEgB,SAAjBy+I,EAAGz+I,WAAqC,SAAby+I,EAAG9+I,OAAkC,SAAd8+I,EAAG3+I,SACvD1d,EAAMm7J,KAAoC,SAAjBkB,EAAGz+I,UAAuB,gBAAkBy+I,EAAGz+I,UAAY,QAAQyyD,MAAM,KAAK5qE,MAAM,EAAG,GAAGjC,KAAK,MAAQ,KAAO,KAAqB,SAAd64J,EAAG3+I,OAAoB,UAAY2+I,EAAG3+I,OAAS,KAAO,KAAoB,SAAb2+I,EAAG9+I,MAAmB,SAAW8+I,EAAG9+I,MAAM8yD,MAAM,KAAK7sE,KAAK,KAAO,KAAO,KAA8B,SAAvB64J,EAAGlB,IAA6BkB,EAAGlB,IAAkB,KAGjVn7J,EAAMud,MAAQvd,EAAM0d,OAAS1d,EAAM4d,UAAY,QAGjDE,EAASqiJ,GAAW54J,EAAQi8B,EAAMi4H,KAE9Bj4H,EAAMi4H,MACJj4H,EAAMoyH,SAERgM,EAAKr6J,EAAO61J,UACZtpI,EAAS0P,EAAMw9H,QAAUY,EAAGniK,EAAI,OAAS+jC,EAAM09H,QAAUU,EAAGjiK,GAAK,KACjE21B,EAAK,IAELA,GAAMsgI,GAAWruJ,EAAOirC,aAAa,mBAGvCkuH,GAAgBn5J,EAAQ+tB,GAAMxB,IAAUwB,GAAMkO,EAAMm9H,kBAAmC,IAAjBn9H,EAAMo9H,OAAkB9iJ,IAGhGkjJ,EAAUx9H,EAAMw9H,SAAW,EAC3BE,EAAU19H,EAAM09H,SAAW,EAEvBpjJ,IAAWgiJ,KACbl0J,EAAIkS,EAAO,GAEXjJ,EAAIiJ,EAAO,GAEXhJ,EAAIgJ,EAAO,GAEXnS,EAAImS,EAAO,GAEXre,EAAIsb,EAAM+C,EAAO,GACjBne,EAAIub,EAAM4C,EAAO,GAEK,IAAlBA,EAAOha,QACT2zB,EAASt2B,KAAKC,KAAKwK,EAAIA,EAAIiJ,EAAIA,GAC/B8iB,EAASx2B,KAAKC,KAAKuK,EAAIA,EAAImJ,EAAIA,GAC/BsI,EAAWxR,GAAKiJ,EAAImlJ,GAAOnlJ,EAAGjJ,GAAKkuJ,GAAW,GAE9C2H,EAAQ3sJ,GAAKnJ,EAAIquJ,GAAOllJ,EAAGnJ,GAAKmuJ,GAAW18I,EAAW,KAC5Cua,GAAUx2B,KAAKwS,IAAIxS,KAAK6T,IAAIysJ,EAAQ1H,MAE1Cv2H,EAAMi4H,MACRh8J,GAAKuhK,GAAWA,EAAUp1J,EAAIs1J,EAAUpsJ,GACxCnV,GAAKuhK,GAAWF,EAAUnsJ,EAAIqsJ,EAAUv1J,MAI1C0P,EAAMyC,EAAO,GACbob,EAAMpb,EAAO,GACb9C,EAAM8C,EAAO,GACb3C,EAAM2C,EAAO,GACbxC,EAAMwC,EAAO,IACbqb,EAAMrb,EAAO,IACbre,EAAIqe,EAAO,IACXne,EAAIme,EAAO,IACXmG,EAAInG,EAAO,IAEXyjJ,GADAxpJ,EAAQiiJ,GAAO3+I,EAAKC,IACAw+I,GAEhB/hJ,IAGFud,EAAKva,GAFL/F,EAAM7T,KAAK6T,KAAK+C,IAECiD,GADjB/F,EAAM9T,KAAK8T,KAAK8C,IAEhB6pJ,EAAK1mJ,EAAMlG,EAAMmG,EAAMlG,EACvB4sJ,EAAKxmJ,EAAMrG,EAAMsG,EAAMrG,EACvB+F,EAAMD,GAAO9F,EAAM+F,EAAMhG,EACzBmG,EAAMD,GAAOjG,EAAMkG,EAAMnG,EACzBsG,EAAMD,GAAOpG,EAAMqG,EAAMtG,EACzBmkB,EAAMD,GAAOjkB,EAAMkkB,EAAMnkB,EACzB+F,EAAMua,EACNpa,EAAM0mJ,EACNvmJ,EAAMwmJ,GAKRL,GADAzpJ,EAAQiiJ,IAAQllJ,EAAGwG,IACCw+I,GAEhB/hJ,IACF/C,EAAM7T,KAAK6T,KAAK+C,GAKhBohB,EAAMxtB,GAJNsJ,EAAM9T,KAAK8T,KAAK8C,IAIAohB,EAAMnkB,EACtBpJ,EAJA0pB,EAAK1pB,EAAIoJ,EAAMgG,EAAM/F,EAKrBJ,EAJA+sJ,EAAK/sJ,EAAIG,EAAMmG,EAAMlG,EAKrBH,EAJA+sJ,EAAK/sJ,EAAIE,EAAMsG,EAAMrG,GASvBmI,GADArF,EAAQiiJ,GAAOnlJ,EAAGjJ,IACCkuJ,GAEf/hJ,IAGFud,EAAK1pB,GAFLoJ,EAAM7T,KAAK6T,IAAI+C,IAEAlD,GADfI,EAAM9T,KAAK8T,IAAI8C,IAEf6pJ,EAAK7mJ,EAAM/F,EAAMkG,EAAMjG,EACvBJ,EAAIA,EAAIG,EAAMpJ,EAAIqJ,EAClBiG,EAAMA,EAAMlG,EAAM+F,EAAM9F,EACxBrJ,EAAI0pB,EACJva,EAAM6mJ,GAGJL,GAAapgK,KAAKwS,IAAI4tJ,GAAapgK,KAAKwS,IAAIyJ,GAAY,QAE1DmkJ,EAAYnkJ,EAAW,EACvBokJ,EAAY,IAAMA,GAGpB/pI,EAAS+9G,GAAOr0I,KAAKC,KAAKwK,EAAIA,EAAIiJ,EAAIA,EAAIC,EAAIA,IAC9C6iB,EAAS69G,GAAOr0I,KAAKC,KAAK8Z,EAAMA,EAAMG,EAAMA,IAC5CtD,EAAQiiJ,GAAOj/I,EAAKG,GACpBumJ,EAAQtgK,KAAKwS,IAAIoE,GAAS,KAASA,EAAQ+hJ,GAAW,EACtD6H,EAAcxoI,EAAM,GAAKA,EAAM,GAAKA,EAAMA,GAAO,GAG/CqK,EAAMi4H,MAERnmI,EAAK/tB,EAAOirC,aAAa,aACzBhP,EAAMu+H,SAAWx6J,EAAOnH,aAAa,YAAa,MAAQ4/J,GAAiB7D,GAAqB50J,EAAQ4zJ,KACxG7lI,GAAM/tB,EAAOnH,aAAa,YAAak1B,KAIvCn0B,KAAKwS,IAAI8tJ,GAAS,IAAMtgK,KAAKwS,IAAI8tJ,GAAS,MACxCK,GACFrqI,IAAW,EACXgqI,GAASrkJ,GAAY,EAAI,KAAO,IAChCA,GAAYA,GAAY,EAAI,KAAO,MAEnCua,IAAW,EACX8pI,GAASA,GAAS,EAAI,KAAO,MAIjC7L,EAAUA,GAAWpyH,EAAMoyH,QAC3BpyH,EAAM/jC,EAAIA,IAAM+jC,EAAMw+H,SAAWviK,KAAOm2J,GAAWpyH,EAAMw+H,WAAa7gK,KAAK2R,MAAMvL,EAAO06J,YAAc,KAAO9gK,KAAK2R,OAAOrT,IAAM,GAAK,KAAO8H,EAAO06J,YAAcz+H,EAAMw+H,SAAW,IAAM,GAAK1D,EAC5L96H,EAAM7jC,EAAIA,IAAM6jC,EAAM0+H,SAAWviK,KAAOi2J,GAAWpyH,EAAM0+H,WAAa/gK,KAAK2R,MAAMvL,EAAO46J,aAAe,KAAOhhK,KAAK2R,OAAOnT,IAAM,GAAK,KAAO4H,EAAO46J,aAAe3+H,EAAM0+H,SAAW,IAAM,GAAK5D,EAC9L96H,EAAMvf,EAAIA,EAAIq6I,EACd96H,EAAM/L,OAAS+9G,GAAO/9G,GACtB+L,EAAM7L,OAAS69G,GAAO79G,GACtB6L,EAAMpmB,SAAWo4H,GAAOp4H,GAAY/b,EACpCmiC,EAAM+9H,UAAY/rB,GAAO+rB,GAAalgK,EACtCmiC,EAAMg+H,UAAYhsB,GAAOgsB,GAAangK,EACtCmiC,EAAMi+H,MAAQA,EAAQpgK,EACtBmiC,EAAMk+H,MAAQA,EAAQrgK,EACtBmiC,EAAM4+H,qBAAuBT,EAAcrD,GAEvC96H,EAAM07H,QAAUxwH,WAAW5a,EAAOu8C,MAAM,KAAK,KAAO,KACtDrwE,EAAMo7J,IAAwB6D,GAAcnrI,IAG9C0P,EAAMimE,QAAUjmE,EAAM69H,QAAU,EAChC79H,EAAM+tG,QAAUF,GAAQE,QACxB/tG,EAAMy3H,gBAAkBz3H,EAAMi4H,IAAM4G,GAAuBzI,GAAc0I,GAAuBC,GAChG/+H,EAAMoyH,QAAU,EACTpyH,CACT,EACIy7H,GAAgB,SAAuB1+J,GACzC,OAAQA,EAAQA,EAAM8vE,MAAM,MAAM,GAAK,IAAM9vE,EAAM,EACrD,EAEAiiK,GAAkB,SAAyBj7J,EAAQ8qC,EAAO9xC,GACxD,IAAIurE,EAAO0wE,GAAQnqG,GACnB,OAAOmjG,GAAO9mG,WAAW2D,GAAS3D,WAAW2vH,GAAe92J,EAAQ,IAAKhH,EAAQ,KAAMurE,KAAUA,CACnG,EACIy2F,GAAyB,SAAgCpa,EAAO3kH,GAClEA,EAAMvf,EAAI,MACVuf,EAAMg+H,UAAYh+H,EAAM+9H,UAAY,OACpC/9H,EAAM+tG,QAAU,EAEhB+wB,GAAqBna,EAAO3kH,EAC9B,EACIi/H,GAAW,OACXC,GAAU,MACVC,GAAkB,KAClBL,GAAuB,SAA8Bna,EAAO3kH,GAC9D,IAAIw3G,EAAOx3G,GAASrgC,KAChB6+J,EAAWhnB,EAAKgnB,SAChBE,EAAWlnB,EAAKknB,SAChBziK,EAAIu7I,EAAKv7I,EACTE,EAAIq7I,EAAKr7I,EACTskB,EAAI+2H,EAAK/2H,EACT7G,EAAW49H,EAAK59H,SAChBokJ,EAAYxmB,EAAKwmB,UACjBD,EAAYvmB,EAAKumB,UACjBE,EAAQzmB,EAAKymB,MACbC,EAAQ1mB,EAAK0mB,MACbjqI,EAASujH,EAAKvjH,OACdE,EAASqjH,EAAKrjH,OACdyqI,EAAuBpnB,EAAKonB,qBAC5B7wB,EAAUyJ,EAAKzJ,QACfhqI,EAASyzI,EAAKzzI,OACd23J,EAAUlkB,EAAKkkB,QACf0D,EAAa,GACbC,EAAoB,SAAZtxB,GAAsB4W,GAAmB,IAAVA,IAA2B,IAAZ5W,EAG1D,GAAI2tB,IAAYqC,IAAckB,IAAYjB,IAAciB,IAAW,CACjE,IAGIztJ,EAHA+C,EAAQ22B,WAAW8yH,GAAazH,GAChC/+I,EAAM7Z,KAAK8T,IAAI8C,GACfuD,EAAMna,KAAK6T,IAAI+C,GAGnBA,EAAQ22B,WAAW6yH,GAAaxH,GAChC/kJ,EAAM7T,KAAK6T,IAAI+C,GACftY,EAAI+iK,GAAgBj7J,EAAQ9H,EAAGub,EAAMhG,GAAOkqJ,GAC5Cv/J,EAAI6iK,GAAgBj7J,EAAQ5H,GAAIwB,KAAK8T,IAAI8C,IAAUmnJ,GACnDj7I,EAAIu+I,GAAgBj7J,EAAQ0c,EAAG3I,EAAMtG,GAAOkqJ,EAAUA,EACxD,CAEIkD,IAAyBM,KAC3BE,GAAc,eAAiBR,EAAuBO,KAGpDX,GAAYE,KACdU,GAAc,aAAeZ,EAAW,MAAQE,EAAW,QAGzDW,GAASpjK,IAAMijK,IAAW/iK,IAAM+iK,IAAWz+I,IAAMy+I,MACnDE,GAAc3+I,IAAMy+I,IAAWG,EAAQ,eAAiBpjK,EAAI,KAAOE,EAAI,KAAOskB,EAAI,KAAO,aAAexkB,EAAI,KAAOE,EAAIgjK,IAGrHvlJ,IAAaqlJ,KACfG,GAAc,UAAYxlJ,EAAWulJ,IAGnCnB,IAAciB,KAChBG,GAAc,WAAapB,EAAYmB,IAGrCpB,IAAckB,KAChBG,GAAc,WAAarB,EAAYoB,IAGrClB,IAAUgB,IAAYf,IAAUe,KAClCG,GAAc,QAAUnB,EAAQ,KAAOC,EAAQiB,IAGlC,IAAXlrI,GAA2B,IAAXE,IAClBirI,GAAc,SAAWnrI,EAAS,KAAOE,EAASgrI,IAGpDp7J,EAAOvH,MAAMm7J,IAAkByH,GAAc,iBAC/C,EACIP,GAAuB,SAA8Bla,EAAO3kH,GAC9D,IAkBI1oB,EACAG,EACAF,EACAG,EACAm9I,EAtBAnd,EAAQ13G,GAASrgC,KACjB6+J,EAAW9mB,EAAM8mB,SACjBE,EAAWhnB,EAAMgnB,SACjBziK,EAAIy7I,EAAMz7I,EACVE,EAAIu7I,EAAMv7I,EACVyd,EAAW89H,EAAM99H,SACjBqkJ,EAAQvmB,EAAMumB,MACdC,EAAQxmB,EAAMwmB,MACdjqI,EAASyjH,EAAMzjH,OACfE,EAASujH,EAAMvjH,OACfpwB,EAAS2zI,EAAM3zI,OACfy5J,EAAU9lB,EAAM8lB,QAChBE,EAAUhmB,EAAMgmB,QAChBz3D,EAAUyxC,EAAMzxC,QAChB43D,EAAUnmB,EAAMmmB,QAChBU,EAAW7mB,EAAM6mB,SACjB/kJ,EAAK0xB,WAAWjvC,GAChBwd,EAAKyxB,WAAW/uC,GAOpByd,EAAWsxB,WAAWtxB,GACtBqkJ,EAAQ/yH,WAAW+yH,IACnBC,EAAQhzH,WAAWgzH,MAKjBD,GADAC,EAAQhzH,WAAWgzH,GAEnBtkJ,GAAYskJ,GAGVtkJ,GAAYqkJ,GACdrkJ,GAAY28I,GACZ0H,GAAS1H,GACTj/I,EAAM3Z,KAAK6T,IAAIoI,GAAYqa,EAC3Bxc,EAAM9Z,KAAK8T,IAAImI,GAAYqa,EAC3B1c,EAAM5Z,KAAK8T,IAAImI,EAAWqkJ,IAAU9pI,EACpCzc,EAAM/Z,KAAK6T,IAAIoI,EAAWqkJ,GAAS9pI,EAE/B8pI,IACFC,GAAS3H,GACT1B,EAAOl3J,KAAKw7C,IAAI8kH,EAAQC,GAExB3mJ,GADAs9I,EAAOl3J,KAAKC,KAAK,EAAIi3J,EAAOA,GAE5Bn9I,GAAOm9I,EAEHqJ,IACFrJ,EAAOl3J,KAAKw7C,IAAI+kH,GAEhB5mJ,GADAu9I,EAAOl3J,KAAKC,KAAK,EAAIi3J,EAAOA,GAE5Bp9I,GAAOo9I,IAIXv9I,EAAM06H,GAAO16H,GACbG,EAAMu6H,GAAOv6H,GACbF,EAAMy6H,GAAOz6H,GACbG,EAAMs6H,GAAOt6H,KAEbJ,EAAM2c,EACNvc,EAAMyc,EACN1c,EAAMF,EAAM,IAGViC,MAASvd,EAAI,IAAI6Q,QAAQ,OAAS2M,MAAStd,EAAI,IAAI2Q,QAAQ,SAC7D0M,EAAKqhJ,GAAe92J,EAAQ,IAAK9H,EAAG,MACpCwd,EAAKohJ,GAAe92J,EAAQ,IAAK5H,EAAG,QAGlCqhK,GAAWE,GAAWz3D,GAAW43D,KACnCrkJ,EAAKw4H,GAAOx4H,EAAKgkJ,GAAWA,EAAUlmJ,EAAMomJ,EAAUnmJ,GAAO0uF,GAC7DxsF,EAAKu4H,GAAOv4H,EAAKikJ,GAAWF,EAAU/lJ,EAAMimJ,EAAUhmJ,GAAOmmJ,KAG3DW,GAAYE,KAEd7J,EAAO9wJ,EAAO61J,UACdpgJ,EAAKw4H,GAAOx4H,EAAKglJ,EAAW,IAAM3J,EAAKviJ,OACvCmH,EAAKu4H,GAAOv4H,EAAKilJ,EAAW,IAAM7J,EAAKtiJ,SAGzCsiJ,EAAO,UAAYv9I,EAAM,IAAMG,EAAM,IAAMF,EAAM,IAAMG,EAAM,IAAM8B,EAAK,IAAMC,EAAK,IACnF1V,EAAOnH,aAAa,YAAai4J,GACjC0J,IAAax6J,EAAOvH,MAAMm7J,IAAkB9C,EAC9C,EACIyK,GAA0B,SAAiChqC,EAAQvxH,EAAQuyC,EAAU20G,EAAU8Q,GACjG,IAKIxrI,EACA46H,EANAoU,EAAM,IACNxL,EAAWllB,GAAUktB,GAErBhM,EADS7kH,WAAW6wH,IAAahI,IAAagI,EAASjvJ,QAAQ,OAASwpJ,GAAW,GACjErL,EAClBuU,EAAavU,EAAW8E,EAAS,MA4BrC,OAxBIgE,IAGgB,WAFlBxjI,EAAYwrI,EAASlvF,MAAM,KAAK,MAG9BkjF,GAAUwP,IAEKxP,EAAS,MACtBA,GAAUA,EAAS,EAAIwP,GAAM,KAIf,OAAdhvI,GAAsBw/H,EAAS,EACjCA,GAAUA,EAASwP,MAAiBA,KAASxP,EAASwP,GAAOA,EACtC,QAAdhvI,GAAuBw/H,EAAS,IACzCA,GAAUA,EAASwP,MAAiBA,KAASxP,EAASwP,GAAOA,IAIjEjqC,EAAO8hB,IAAM+T,EAAK,IAAIjN,GAAU5oB,EAAO8hB,IAAKrzI,EAAQuyC,EAAU20G,EAAU8E,EAAQgH,IAChF5L,EAAGtvJ,EAAI2jK,EACPrU,EAAGpgI,EAAI,MAEPuqG,EAAOgoB,OAAOl+I,KAAKk3C,GAEZ60G,CACT,EACIsU,GAAU,SAAiB17J,EAAQX,GAErC,IAAK,IAAIi1B,KAAKj1B,EACZW,EAAOs0B,GAAKj1B,EAAOi1B,GAGrB,OAAOt0B,CACT,EACI27J,GAAsB,SAA6BpqC,EAAQ8pC,EAAYr7J,GAEzE,IAGI47J,EACAtnI,EACAyjI,EACAC,EACA9Q,EACAF,EAEAiR,EAVA4D,EAAaH,GAAQ,CAAC,EAAG17J,EAAOytI,OAEhCh1I,EAAQuH,EAAOvH,MA0BnB,IAAK67B,KAhBDunI,EAAW3H,KACb6D,EAAa/3J,EAAOirC,aAAa,aACjCjrC,EAAOnH,aAAa,YAAa,IACjCJ,EAAMm7J,IAAkByH,EACxBO,EAAWnE,GAAgBz3J,EAAQ,GAEnCq2J,GAAgBr2J,EAAQ4zJ,IAExB5zJ,EAAOnH,aAAa,YAAak/J,KAEjCA,EAAahD,iBAAiB/0J,GAAQ4zJ,IACtCn7J,EAAMm7J,IAAkByH,EACxBO,EAAWnE,GAAgBz3J,EAAQ,GACnCvH,EAAMm7J,IAAkBmE,GAGhBzF,IACRyF,EAAa8D,EAAWvnI,OACxB0jI,EAAW4D,EAAStnI,KA7BR,gDA+B2BvrB,QAAQurB,GAAK,IAIlD4yH,EAFYjS,GAAQ8iB,MACpBE,EAAUhjB,GAAQ+iB,IACiBlB,GAAe92J,EAAQs0B,EAAGyjI,EAAYE,GAAW9wH,WAAW4wH,GAC/F/Q,EAAS7/G,WAAW6wH,GACpBzmC,EAAO8hB,IAAM,IAAI8G,GAAU5oB,EAAO8hB,IAAKuoB,EAAUtnI,EAAG4yH,EAAUF,EAASE,EAAU6L,IACjFxhC,EAAO8hB,IAAIrsH,EAAIixI,GAAW,EAE1B1mC,EAAOgoB,OAAOl+I,KAAKi5B,IAIvBonI,GAAQE,EAAUC,EACpB,EAGA9tB,GAAa,+BAA+B,SAAU3vI,EAAMzE,GAC1D,IAAI4Q,EAAI,MACJ3F,EAAI,QACJ0I,EAAI,SACJhE,EAAI,OACJ07I,GAASrrJ,EAAQ,EAAI,CAAC4Q,EAAG3F,EAAG0I,EAAGhE,GAAK,CAACiB,EAAIjB,EAAGiB,EAAI3F,EAAG0I,EAAI1I,EAAG0I,EAAIhE,IAAIzN,KAAI,SAAUwjC,GAClF,OAAO1lC,EAAQ,EAAIyE,EAAOihC,EAAO,SAAWA,EAAOjhC,CACrD,IAEAw5J,GAAcj+J,EAAQ,EAAI,SAAWyE,EAAOA,GAAQ,SAAUmzH,EAAQvxH,EAAQuyC,EAAUylH,EAAUtpB,GAChG,IAAIrqI,EAAGmrI,EAEP,GAAI12G,UAAUv8B,OAAS,EAMrB,OAJA8H,EAAI2gJ,EAAMnpJ,KAAI,SAAU6I,GACtB,OAAOuvJ,GAAK1iC,EAAQ7sH,EAAM6tC,EAC5B,IAEmC,KADnCi9F,EAAOnrI,EAAEpI,KAAK,MACF6sE,MAAMzkE,EAAE,IAAI9H,OAAe8H,EAAE,GAAKmrI,EAGhDnrI,GAAK2zJ,EAAW,IAAIlvF,MAAM,KAC1B0mE,EAAO,CAAC,EACRwV,EAAMtjJ,SAAQ,SAAUgD,EAAMxI,GAC5B,OAAOszI,EAAK9qI,GAAQL,EAAEnI,GAAKmI,EAAEnI,IAAMmI,GAAGnI,EAAI,GAAK,EAAI,EACrD,IACAq1H,EAAOv7D,KAAKh2D,EAAQwvI,EAAMd,EAC5B,CACF,IAEO,IAuOsB74H,GACvBtS,GAxOKu4J,GAAY,CACrB19J,KAAM,MACNixH,SAAU+lC,GACVznB,WAAY,SAAoB3tI,GAC9B,OAAOA,EAAOvH,OAASuH,EAAOq1I,QAChC,EACAr/E,KAAM,SAAch2D,EAAQwvI,EAAMd,EAAO/0I,EAAO+jI,GAC9C,IAGIq6B,EACAC,EACAhR,EACAE,EACAv+I,EACAozJ,EACAznI,EACA4jI,EACAD,EACA+D,EACAC,EACAC,EACAjgI,EACAo9H,EACAhR,EACA8T,EA/xBmEnjK,EACrE8vE,EACA5wE,EACAE,EA0wBE4sJ,EAAQppJ,KAAK29I,OACb9gJ,EAAQuH,EAAOvH,MACfq8I,EAAUpG,EAAMc,KAAKsF,QAuBzB,IAAKxgH,KANL49H,IAAkBkD,KAElBx5J,KAAKwgK,OAASxgK,KAAKwgK,QAAU7H,GAAev0J,GAC5Cm8J,EAAcvgK,KAAKwgK,OAAOpX,MAC1BppJ,KAAK8yI,MAAQA,EAEHc,EACR,GAAU,cAANl7G,IAIJ0jI,EAAWxoB,EAAKl7G,IAEZ44G,GAAS54G,KAAMyzH,GAAazzH,EAAGk7G,EAAMd,EAAO/0I,EAAOqG,EAAQ09H,IAiB/D,GAZA/0H,SAAcqvJ,EACd+D,EAAcnE,GAActjI,GAEf,aAAT3rB,IAEFA,SADAqvJ,EAAWA,EAASx6J,KAAKkxI,EAAO/0I,EAAOqG,EAAQ09H,KAIpC,WAAT/0H,IAAsBqvJ,EAASjvJ,QAAQ,aACzCivJ,EAAWlgB,GAAekgB,IAGxB+D,EACFA,EAAYngK,KAAMoE,EAAQs0B,EAAG0jI,EAAUtpB,KAAW2Z,EAAc,QAC3D,GAAuB,OAAnB/zH,EAAE+5G,OAAO,EAAG,GAErB0pB,GAAchD,iBAAiB/0J,GAAQg1J,iBAAiB1gI,GAAK,IAAIo0C,OACjEsvF,GAAY,GACZjc,GAAU30E,UAAY,EAEjB20E,GAAUz9I,KAAKy5J,KAElBG,EAAYjjB,GAAQ8iB,GACpBE,EAAUhjB,GAAQ+iB,IAGpBC,EAAUC,IAAcD,IAAYF,EAAajB,GAAe92J,EAAQs0B,EAAGyjI,EAAYE,GAAWA,GAAWC,IAAcF,GAAYE,GACvIt8J,KAAKhD,IAAIH,EAAO,cAAes/J,EAAYC,EAAUr+J,EAAO+jI,EAAS,EAAG,EAAGppG,GAC3E0wH,EAAM3pJ,KAAKi5B,GACX6nI,EAAY9gK,KAAKi5B,EAAG,EAAG77B,EAAM67B,SACxB,GAAa,cAAT3rB,EAAsB,CAsC/B,GArCImsI,GAAWxgH,KAAKwgH,GAElBijB,EAAmC,mBAAfjjB,EAAQxgH,GAAoBwgH,EAAQxgH,GAAG92B,KAAKkxI,EAAO/0I,EAAOqG,EAAQ09H,GAAWoX,EAAQxgH,GACzGw2G,GAAUitB,KAAgBA,EAAWhvJ,QAAQ,aAAegvJ,EAAajgB,GAAeigB,IACxF9iB,GAAQ8iB,EAAa,MAAQA,GAAcjuB,GAAQ5jE,MAAM5xC,IAAM2gH,GAAQgf,GAAKj0J,EAAQs0B,KAAO,IAE3D,OAA/ByjI,EAAa,IAAIxwH,OAAO,KAAewwH,EAAa9D,GAAKj0J,EAAQs0B,KAElEyjI,EAAa9D,GAAKj0J,EAAQs0B,GAG5B4yH,EAAW//G,WAAW4wH,IACtBiE,EAAoB,WAATrzJ,GAA4C,MAAvBqvJ,EAASzwH,OAAO,IAAcywH,EAAS3pB,OAAO,EAAG,MACpE2pB,EAAWA,EAAS3pB,OAAO,IACxC2Y,EAAS7/G,WAAW6wH,GAEhB1jI,KAAKu+H,KACG,cAANv+H,IAEe,IAAb4yH,GAAiD,WAA/B+M,GAAKj0J,EAAQ,eAA8BgnJ,IAE/DE,EAAW,GAGbiV,EAAY9gK,KAAK,aAAc,EAAG5C,EAAM4jK,YAExC/F,GAAkB16J,KAAMnD,EAAO,aAAcyuJ,EAAW,UAAY,SAAUF,EAAS,UAAY,UAAWA,IAGtG,UAAN1yH,GAAuB,cAANA,KACnBA,EAAIu+H,GAAiBv+H,IAClBvrB,QAAQ,OAASurB,EAAIA,EAAEw0C,MAAM,KAAK,KAIzCmzF,EAAqB3nI,KAAKg+H,GAexB,GAZA12J,KAAKwgK,OAAO3H,KAAKngI,GAEZ4nI,KACHjgI,EAAQj8B,EAAOytI,OACTimB,kBAAoBlkB,EAAK8sB,gBAAkB7E,GAAgBz3J,EAAQwvI,EAAK8sB,gBAE9EjD,GAA+B,IAAtB7pB,EAAK+sB,cAA0BtgI,EAAMo9H,QAC9C6C,EAAqBtgK,KAAKy3I,IAAM,IAAI8G,GAAUv+I,KAAKy3I,IAAK56I,EAAOm7J,GAAgB,EAAG,EAAG33H,EAAMy3H,gBAAiBz3H,EAAO,GAAI,IAEpGuvH,IAAM,GAGjB,UAANl3H,EACF14B,KAAKy3I,IAAM,IAAI8G,GAAUv+I,KAAKy3I,IAAKp3G,EAAO,SAAUA,EAAM7L,QAAS4rI,EAAW7tB,GAAelyG,EAAM7L,OAAQ4rI,EAAWhV,GAAUA,GAAU/qH,EAAM7L,QAAU,EAAG2iI,IAC7Jn3J,KAAKy3I,IAAIrsH,EAAI,EACbg+H,EAAM3pJ,KAAK,SAAUi5B,GACrBA,GAAK,QACA,IAAU,oBAANA,EAAyB,CAClC6nI,EAAY9gK,KAAKw4J,GAAsB,EAAGp7J,EAAMo7J,KAx4BtD/qF,SACA5wE,SACAE,SADAF,GADA4wE,GADqE9vE,EA04BtBg/J,GAz4BjClvF,MAAM,MACV,GACV1wE,EAAI0wE,EAAM,IAAM,MAEV,QAAN5wE,GAAqB,WAANA,GAAwB,SAANE,GAAsB,UAANA,IAEnDY,EAAQd,EACRA,EAAIE,EACJA,EAAIY,GAGN8vE,EAAM,GAAKqvF,GAAkBjgK,IAAMA,EACnC4wE,EAAM,GAAKqvF,GAAkB//J,IAAMA,EA63BzB4/J,EA53BHlvF,EAAM7sE,KAAK,KA83BJggC,EAAMi4H,IACRiF,GAAgBn5J,EAAQg4J,EAAU,EAAGqB,EAAQ,EAAGz9J,QAEhDq8J,EAAU9wH,WAAW6wH,EAASlvF,MAAM,KAAK,KAAO,KAEpC7sC,EAAM07H,SAAWrB,GAAkB16J,KAAMqgC,EAAO,UAAWA,EAAM07H,QAASM,GAEtF3B,GAAkB16J,KAAMnD,EAAO67B,EAAGojI,GAAcK,GAAaL,GAAcM,KAG7E,QACF,CAAO,GAAU,cAAN1jI,EAAmB,CAC5B6kI,GAAgBn5J,EAAQg4J,EAAU,EAAGqB,EAAQ,EAAGz9J,MAEhD,QACF,CAAO,GAAI04B,KAAKkkI,GAAuB,CACrC+C,GAAwB3/J,KAAMqgC,EAAO3H,EAAG4yH,EAAU8U,EAAW7tB,GAAe+Y,EAAU8U,EAAWhE,GAAYA,GAE7G,QACF,CAAO,GAAU,iBAAN1jI,EAAsB,CAC/BgiI,GAAkB16J,KAAMqgC,EAAO,SAAUA,EAAMo9H,OAAQrB,GAEvD,QACF,CAAO,GAAU,YAAN1jI,EAAiB,CAC1B2H,EAAM3H,GAAK0jI,EACX,QACF,CAAO,GAAU,cAAN1jI,EAAmB,CAC5BqnI,GAAoB//J,KAAMo8J,EAAUh4J,GAEpC,QACF,OACWs0B,KAAK77B,IAChB67B,EAAI2gI,GAAiB3gI,IAAMA,GAG7B,GAAI2nI,IAAuBjV,GAAqB,IAAXA,KAAkBE,GAAyB,IAAbA,KAAoB0L,GAAYt0J,KAAK05J,IAAa1jI,KAAK77B,EAExHuuJ,IAAWA,EAAS,IADpBkR,GAAaH,EAAa,IAAI1pB,QAAQ6Y,EAAW,IAAI3qJ,YAGrD07J,EAAUhjB,GAAQ+iB,KAAc1jI,KAAKw1G,GAAQ5jE,MAAQ4jE,GAAQ5jE,MAAM5xC,GAAK4jI,MAC9ChR,EAAW4P,GAAe92J,EAAQs0B,EAAGyjI,EAAYE,IAC3Er8J,KAAKy3I,IAAM,IAAI8G,GAAUv+I,KAAKy3I,IAAK4oB,EAAqBhgI,EAAQxjC,EAAO67B,EAAG4yH,GAAW8U,EAAW7tB,GAAe+Y,EAAU8U,EAAWhV,GAAUA,GAAUE,EAAW+U,GAAmC,OAAZhE,GAA0B,WAAN3jI,IAAsC,IAAnBk7G,EAAKgtB,UAA8CzJ,GAAxBG,IAC5Pt3J,KAAKy3I,IAAIrsH,EAAIixI,GAAW,EAEpBC,IAAcD,GAAuB,MAAZA,IAE3Br8J,KAAKy3I,IAAI/lI,EAAIyqJ,EACbn8J,KAAKy3I,IAAIzuI,EAAIquJ,SAEV,GAAM3+H,KAAK77B,EAUhBo/J,GAAuBr6J,KAAK5B,KAAMoE,EAAQs0B,EAAGyjI,EAAYiE,EAAWA,EAAWhE,EAAWA,QAT1F,GAAI1jI,KAAKt0B,EAEPpE,KAAKhD,IAAIoH,EAAQs0B,EAAGyjI,GAAc/3J,EAAOs0B,GAAI0nI,EAAWA,EAAWhE,EAAWA,EAAUr+J,EAAO+jI,QAC1F,GAAU,mBAANppG,EAAwB,CACjC83G,GAAe93G,EAAG0jI,GAElB,QACF,CAKFiE,IAAuB3nI,KAAK77B,EAAQ0jK,EAAY9gK,KAAKi5B,EAAG,EAAG77B,EAAM67B,IAAM6nI,EAAY9gK,KAAKi5B,EAAG,EAAGyjI,GAAc/3J,EAAOs0B,KACnH0wH,EAAM3pJ,KAAKi5B,EACb,CAGF+zH,GAAeY,GAA0BrtJ,KAC3C,EACAm7C,OAAQ,SAAgB6pG,EAAO3hJ,GAC7B,GAAIA,EAAKyvI,MAAMyD,QAAU,KAGvB,IAFA,IAAIiV,EAAKnoJ,EAAKo0I,IAEP+T,GACLA,EAAGxiJ,EAAEg8I,EAAOwG,EAAGhjJ,GACfgjJ,EAAKA,EAAGjX,WAGVlxI,EAAKm9J,OAAOtrB,QAEhB,EACArsI,IAAKwvJ,GACL/Z,QAAS2Y,GACT7Y,UAAW,SAAmBh6I,EAAQuyC,EAAUg/E,GAE9C,IAAIj9F,EAAIu+H,GAAiBtgH,GAEzB,OADAje,GAAKA,EAAEvrB,QAAQ,KAAO,IAAMwpC,EAAWje,GAChCie,KAAY+/G,IAAmB//G,IAAashH,KAAyB7zJ,EAAOytI,MAAMv1I,GAAK+7J,GAAKj0J,EAAQ,MAAQuxH,GAAU6gC,KAAwB7gC,EAAsB,UAAbh/E,EAAuBihH,GAAeD,IAAoBnB,GAAsB7gC,GAAU,CAAC,KAAoB,UAAbh/E,EAAuBkhH,GAAyBE,IAA8B3zJ,EAAOvH,QAAUwyI,GAAajrI,EAAOvH,MAAM85C,IAAa8gH,IAAmB9gH,EAASxpC,QAAQ,KAAOuqJ,GAAiBrZ,GAAWj6I,EAAQuyC,EACvd,EACA+9G,KAAM,CACJ+F,gBAAiBA,GACjBuC,WAAYA,KAGhBzsB,GAAKtgD,MAAM4wE,YAAcxH,GACzB9oB,GAAKmkB,KAAKoM,cAAgBnI,GAGpBhxJ,GAAMwqI,GAeT,8CAfyC,KADfl4H,GAgBqB,4CAfzB8mJ,kFAAkD,SAAUv+J,GACjFk0J,GAAgBl0J,GAAQ,CAC1B,IAEA2vI,GAAal4H,IAAU,SAAUzX,GAC/B0rI,GAAQ5jE,MAAM9nE,GAAQ,MACtBo6J,GAAsBp6J,GAAQ,CAChC,IAEAy0J,GAAiBtvJ,GAAI,KAAOo5J,+CAAyB9mJ,GAErDk4H,GAI6K,8FAJvJ,SAAU3vI,GAC9B,IAAI0qE,EAAQ1qE,EAAK0qE,MAAM,KACvB+pF,GAAiB/pF,EAAM,IAAMvlE,GAAIulE,EAAM,GACzC,IAGFilE,GAAa,gFAAgF,SAAU3vI,GACrG0rI,GAAQ5jE,MAAM9nE,GAAQ,IACxB,IAEA+tI,GAAK6hB,eAAe8N,IC5gDpB,IAAIc,GAAczwB,GAAK6hB,eAAe8N,KAAc3vB,GAElCywB,GAAYtM,KAAKvb,aCGnC,MAAM8nB,GAAS,IAAI50B,GACb60B,GAAY,IAAI70B,GAAyC,CAC3DvvH,OAAQ/gB,SAAS6B,cAAc,YAEnCsjK,GAAUtxD,cAAcvyG,OAAO8jK,kBAC/BD,GAAU99I,QAAQ/lB,OAAO+jK,WAAY/jK,OAAOgkK,aAC5CtlK,SAASC,KAAKkK,YAAYg7J,GAAU/0D,YAEpC,MAAMm1D,GAAQ,IAAIj1B,GAKXk1B,GAAQ,CAAC,EACfA,GAAM5uJ,MAAQtV,OAAO+jK,WACrBG,GAAM3uJ,OAASvV,OAAOgkK,YAEtBhkK,OAAOpB,iBAAiB,UAAU,KAG9BslK,GAAM5uJ,MAAQtV,OAAO+jK,WACrBG,GAAM3uJ,OAASvV,OAAOgkK,YAGtBn4I,GAAOwvB,OAAS6oH,GAAM5uJ,MAAQ4uJ,GAAM3uJ,OACpCsW,GAAO+vB,yBAGPioH,GAAU99I,QAAQm+I,GAAM5uJ,MAAO4uJ,GAAM3uJ,OAAO,IAOjD,MAAMsW,GAAS,IAAImjH,GAAwB,GAAIk1B,GAAM5uJ,MAAQ4uJ,GAAM3uJ,QACnEsW,GAAOkE,SAAS5wB,EAAI,GACpB0sB,GAAOkE,SAAStM,EAAI,GACpBmgJ,GAAOjkK,IAAIksB,IAKX,IAAIs4I,GAAe,IAAIn1B,GAAmB,UAAW,GACrD40B,GAAOjkK,IAAIwkK,IACX,IAAIC,GAAa,IAAIp1B,GAAiB,SAAU,EAAG,KACnDo1B,GAAWr0I,SAAS7a,IAAI,GAAI,IAAK,KACjC0uJ,GAAOjkK,IAAIykK,IACX,MAAMC,GAAiB,IAAIr1B,GAAiB,UAAW,EAAG,KAC1Dq1B,GAAet0I,SAAS7a,KAAK,KAAM,IAAK,IACxC0uJ,GAAOjkK,IAAI0kK,IACX,MAAMC,GAAgB,IAAIt1B,GAAiB,UAAW,EAAG,KACzDs1B,GAAcv0I,SAAS7a,IAAI,IAAK,GAAI,IACpC0uJ,GAAOjkK,IAAI2kK,IAGX,MAAMjtH,GAAY,IAAI23F,GAChBu1B,GAAQ,IAAIv1B,GAElB,IAAIw1B,GAKAC,GAAMC,GAENC,GAAaC,GAEbC,GANAC,IAAgB,GAOhBC,GAAqB,GACrBC,GAAoB,GACpBC,GAAe,GACfC,GAAc,GACdC,GAAiB,GACjBliK,IAAK,EACLmoH,IAAS,EAETg6C,GAAmB,IAGvB,iBAEI,MAAOC,SAAiB77C,QAAQl/G,IAAI,CAChCsoF,GAAmB,uBAGvBiyE,GAAY/+J,KAAKid,MAAMsiJ,GAEvB,MAAMC,EAAe,IAAIt2B,GAAoB,KAAM,MAKnD,IAAI,IAAIkO,KAAQ2nB,GAAUU,WA8BtB,IAAI,IAAIC,KA7BRviK,KAGA8hK,GAAmB9hK,UAAWumH,QAAQl/G,IAAI,CACtCsoF,GAAmBiyE,GAAUU,WAAWroB,GAAMl7G,cAGlDgjI,GAAkB/hK,UAAWumH,QAAQl/G,IAAI,CACrCsoF,GAAmBiyE,GAAUU,WAAWroB,GAAMx3H,WAElDy/I,GAAeliK,IAAK,IAAI+rI,GACpBs2B,EACA,IAAIt2B,GAAwB,CAACzoG,aAAa,EAAM3jC,IAAKoiK,GAAkB/hK,IAAG,MAE9EkiK,GAAeliK,IAAGkC,KAAO0/J,GAAUU,WAAWroB,GAAMuoB,SAG7CN,GAAeliK,GAAE,GAEhBkiK,GAAeliK,IAAG8sB,SAAS7a,IAAIiwJ,GAAeliK,GAAE,GAAG8sB,SAAS9wB,EAnC5D,GAjBC,GAoDsF,GAEvFkmK,GAAeliK,IAAG8sB,SAAS7a,KAAO2vJ,GAAUU,WAAWjiK,OAAO,EArC9D,GAqC4E,GAtD3E,GAsD2F,GAIpG8hK,GAAiBniK,IAAKkiK,GAAeliK,IACrC2gK,GAAOjkK,IAAIwlK,GAAeliK,KAGR4hK,GAAUU,WAAWroB,GAAMwoB,QACzCt6C,KAEA65C,GAAa75C,UAAe5B,QAAQl/G,IAAI,CACpCsoF,GAAmBiyE,GAAUU,WAAWroB,GAAMwoB,QAAQF,GAAQ9/I,WAElEw/I,GAAY95C,IAAS,IAAI4jB,GACrBs2B,EACA,IAAIt2B,GAAwB,CAACzoG,aAAa,EAAM3jC,IAAKqiK,GAAa75C,IAAO,OAMpFu5C,GAAaC,UAAmBp7C,QAAQl/G,IAAI,CACzCsoF,GAAmB,8BACnBA,GAAmB,uBAOvB6xE,GAAOG,GAAUrnH,OACZxgC,MAAM7H,IAAI,GAAI,GAAI,IACvBuvJ,GAAK10I,SAAStM,GAAK,IACnBghJ,GAAK10I,SAAS5wB,GAAK,IACnBykK,GAAOjkK,IAAI8kK,KAGXC,GAAY,IAAI11B,GACZ,IAAIA,GAAoB,KAAM,KAC9B,IAAIA,GAAwB,CAAC1oG,QAAS,EAAGC,aAAa,MAEhDphC,KAAO,QACjBu/J,GAAU30I,SAAS7a,IAAI,EAAG,IAAK,MAG/BsvJ,GAAW,IAAIx1B,GACXs2B,EACA,IAAIt2B,GAAwB,CAACpsI,IAAK+hK,GAAap+H,aAAa,MAEvDxW,SAAS7a,IAAI,EAAG,IAAK,GAC9BsvJ,GAAS5nJ,SAASzd,GAAK,EAEvB2+C,IACH,CAzFD,GA2FA,IAAI6nH,GAAmB,KACnBC,GAAgB,KAKhBC,GAAcnnK,SAAS6B,cAAc,WASzC,IAAI+2C,GARJt3C,OAAOpB,iBAAkB,aACzB,SAAqBuR,GACjB01J,GAAYrmK,MAAMu7B,IAAM5qB,EAAMjR,QAAU,KACxC2mK,GAAYrmK,MAAMq7B,KAAO1qB,EAAMnR,QAAU,KACzCulK,GAAMtlK,EAAKkR,EAAMnR,QAAUgB,OAAO+jK,WAAc,EAAI,EACpDQ,GAAMplK,GAAOgR,EAAMjR,QAAUc,OAAOgkK,YAAc,EAAG,CACzD,IANmD,GASnD,IAAI8B,IAAkB,EAClBC,GAAwB,GACxBC,IAAS,EACTC,GAAY,GA2LhB,SAASnoH,KACL,GAAGp/C,SAAS0C,eAAe,QAAQ1B,UAAU4B,SAAS,UAAU,CAEhE,MAAMouH,EAAcu0C,GAAMp0C,iBAGb,GAAVm2C,IAAkBtB,GAAU9hI,SAAS0D,QAAQ,EAC5Co+H,GAAU9hI,SAAS0D,SAAU,IACvBs9H,GAAOxjI,gBAAgB,UAAYskI,GAAU9hI,SAAS0D,QAAQ,IACpEo+H,GAAU9hI,SAAS0D,SAAW,KAGlC4sG,GAAKnjE,GAAG00F,GAAK7nJ,SAAU,CAACwF,QAAS,EAAGjjB,EAAGuwH,IAKvCr4E,GAAU89E,cAAcovC,GAAO14I,KAG3ByrB,GAD+B,GAAhCyuH,GAAsBziK,OACR+zC,GAAUk+E,iBAAiBwwC,IAE3B1uH,GAAUk+E,iBAAiB6vC,KAG9B9hK,QAENqiK,IAAqBG,IACrBxuH,GAAW,GAAGxoB,OAAO0Q,WAAW,GAGjCmmI,IAAoBA,GAAiB72I,OAAO3pB,OAASmyC,GAAW,GAAGxoB,OAAO3pB,OAAS2gK,KAClFxuH,GAAW,GAAGxoB,OAAO0Q,WAAW,GAChCmmI,GAAiB72I,OAAO0Q,YAAY,IAGxCmmI,GAAmBruH,GAAW,KAE3BquH,KAAqBG,IAEpBH,GAAiB72I,OAAO0Q,YAAY,GAGxCmmI,GAAmB,KAE3B,CACIv2B,GAAaplI,SACb65J,GAAU/lH,OAAO8lH,GAAQ/3I,IAEzBk2B,sBAAsBjE,GAC1B,CA1OA99C,OAAOpB,iBAAiB,SAAS,KAK7B,GAJAF,SAAS0C,eAAe,aAAaC,QAAU,WAE3CrB,OAAOC,SAASimK,SAAW,cAC/B,EACGxnK,SAAS0C,eAAe,UAAU1B,UAAU4B,SAAS,SACpD5C,SAAS0C,eAAe,UAAU1B,UAAUG,OAAO,cAEvD,GAAG8lK,GAiEC,IAAI,IAAIQ,KAhERznK,SAAS0C,eAAe,SAASC,QAAU,WAEvC,IAAI,IAAI+kK,KADRJ,IAAS,EACOD,GACZ9kK,QAAQC,IAAI,QACZgyI,GAAKnjE,GAAGg2F,GAAsBK,GAAMr2I,SAAU,CAACo1F,SAAU8gD,GAAWhnK,EAAE,EAAGE,EAAE2lK,GAAcrhJ,EAAG,IAC5FyvH,GAAKnjE,GAAGg2F,GAAsBK,GAAMxpJ,SAAU,CAACuoG,SAAU8gD,GAAWxiJ,EAAE,IAE1E/kB,SAAS0C,eAAe,SAAS1B,UAAUC,IAAI,UAE/C0qH,YAAW,WAIP,IAAI,IAAI+7C,KAHRxC,GAAOjkK,IAAI6kK,IACXtxB,GAAKnjE,GAAGy0F,GAAS5nJ,SAAU,CAACuoG,SAAU8gD,GAAW9mK,EAAG,IACpD+zI,GAAKnjE,GAAGy0F,GAASz0I,SAAU,CAACo1F,SAAU8gD,GAAWxiJ,EAAG,IACpCsiJ,GACZ7yB,GAAKnjE,GAAGg2F,GAAsBK,GAAMxpJ,SAAU,CAACuoG,SAAU8gD,GAAW9mK,GAAI,IAE5ET,SAAS0C,eAAe,aAAa1B,UAAUG,OAAO,SAC1D,GAAGomK,KAEH57C,YAAW,WACP,IAAI,IAAI+7C,KAAQL,GACZnC,GAAO/jK,OAAOkmK,GAAsBK,IAExCxC,GAAO/jK,OAAO6kK,IACdxxB,GAAKnjE,GAAGy0F,GAASz0I,SAAU,CAACo1F,SAAU8gD,GAAW9mK,EArKhD,IAsKL,GAAG8mK,KACH57C,YAAW,WACP07C,GAAwB,GACxBZ,GAAe18J,SAAQ49J,IACnBzC,GAAOjkK,IAAI0mK,GACXnzB,GAAKnjE,GAAGs2F,EAASzpJ,SAAU,CAACuoG,SAAU8gD,GAAW9mK,EAAE,EAAGskB,EAAE,GAAG,IAE/DyvH,GAAKnjE,GAAGy0F,GAAS5nJ,SAAU,CAACuoG,SAAU8gD,GAAW9mK,GAAG,IACpD+zI,GAAKnjE,GAAGy0F,GAASz0I,SAAU,CAACo1F,SAAU8gD,GAAWxiJ,GAAI,GACzD,GAAGwiJ,MAEH57C,YAAW,WACPu5C,GAAO/jK,OAAO2kK,IAEV,IAAI,IAAIlS,EAAK,EAAGA,EAAG6S,GAAe7hK,OAAQgvJ,IACnC6S,GAAe,IAAMA,GAAe7S,IAAO6S,GAAe,GAEzDjyB,GAAKnjE,GAAGo1F,GAAe7S,GAAIviI,SAAU,CAACo1F,SAAU8gD,GAAWhnK,EAAIkmK,GAAe,GAAGp1I,SAAS9wB,EAtKtG,IAsKqHqzJ,EAAG,GAAI6S,GAAe7hK,OAAO,GAAInE,EAvLrJ,GAuLoKskB,EAAG,IAE5JyvH,GAAKnjE,GAAGo1F,GAAe7S,GAAIviI,SAAU,CAACo1F,SAAU8gD,GAAWhnK,GAAMkmK,GAAe7hK,OAAO,EAxKnG,GAwKiH,GAAInE,EAzLpH,GAyLkIskB,EAAG,IAGtIqiJ,IAAkB,CAEtB,GAAGG,KAEH57C,YAAW,WACP86C,GAAe18J,SAAQ49J,IACvBnzB,GAAKnjE,GAAGs2F,EAASt2I,SAAU,CAACo1F,SAAU8gD,GAAWxiJ,EAAE,GAAG,IAEtDqiJ,IAAkB,EAClBE,IAAS,CACb,GAAGC,KAEP,EAKoBpB,GAAUU,WAAW,CACrC,IACIe,EADOX,GAAiB72I,OAAO8T,SAAShgC,IAAI0c,MAAMC,IACtCswD,MAAM,YAAY6P,MAAM7P,MAAM,SAAS,GACnD02F,EAAqBxB,GAAmBoB,GAAU,GAEnDG,GADWC,EAAmBjnJ,MAAMknJ,WAAW32F,MAAM,YAAY6P,MAAM7P,MAAM,SAAS,KAErF60F,GAAU9hI,SAAShgC,IAAM2jK,GAG7B,IAAIE,EAAiBd,GAAiB72I,OAAO3pB,KAE7C,GAAGwgK,GAAiB72I,OAAO3pB,MAAQ0/J,GAAUU,WAAWY,GAAUV,SAC9D/mK,SAAS0C,eAAe,aAAa1B,UAAUC,IAAI,UACnDjB,SAAS0C,eAAe,SAAS1B,UAAUG,OAAO,UAClD+jK,GAAOjkK,IAAI6kK,IAEXW,GAAe18J,SAAQ49J,IACnBnzB,GAAKnjE,GAAGs2F,EAASt2I,SAAU,CAACo1F,SAAU8gD,GAAWhnK,EAAG,EAAGE,EAAE,IAAI,IAEjE+zI,GAAKnjE,GAAG41F,GAAiB72I,OAAOiB,SAAU,CAACo1F,SAAU8gD,GAAWhnK,EAAG,EAAGE,EAAE,GAAIskB,EAAE,KAE9E4mG,YAAW,WACP6oB,GAAKnjE,GAAGy0F,GAAS5nJ,SAAU,CAACuoG,SAAU8gD,GAAW9mK,EAAG,IACpD+zI,GAAKnjE,GAAGy0F,GAASz0I,SAAU,CAACo1F,SAAU8gD,GAAWxiJ,EAAG,IACpD0hJ,GAAe18J,SAAQ49J,IACnBnzB,GAAKnjE,GAAGs2F,EAASzpJ,SAAU,CAACuoG,SAAU8gD,GAAW9mK,EAAE,GAAG,GAE9D,GAAG8mK,KAEH57C,YAAW,WACP86C,GAAe18J,SAAQ49J,IACnBzC,GAAO/jK,OAAOwmK,EAAS,IAE3BnzB,GAAKnjE,GAAGy0F,GAASz0I,SAAU,CAACo1F,SAAU8gD,GAAW9mK,EAAG2lK,KACpDlB,GAAOjkK,IAAI+kK,GACf,GAAGuB,KAEH57C,YAAW,WACP66C,GAAYz8J,SAAQ29J,IACLA,EAAKxjI,SAAShgC,IAAI0c,MAAMknJ,WAAW32F,MAAM,YAAY6P,MAAM7P,MAAM,WAAW,IAC5E42F,IACPL,EAAKr2I,SAAS5wB,EAAI2lK,GAClBsB,EAAKxpJ,SAASzd,GAAK,EACnB4mK,GAAsB3jK,KAAKgkK,GAC/B,IAEJL,GAAsBt9J,SAAQ9I,IAC1BikK,GAAOjkK,IAAIA,GACXuzI,GAAKnjE,GAAGpwE,EAAIid,SAAU,CAACuoG,SAAU8gD,GAAW9mK,EAAE,GAAG,IAErD+zI,GAAKnjE,GAAGy0F,GAAS5nJ,SAAU,CAACuoG,SAAS8gD,GAAW9mK,EAAE,GACtD,GAAG8mK,MAEH57C,YAAW,WAEP,GADAu5C,GAAO/jK,OAAO2kK,IACXuB,GAAsBziK,OAAO,GAAK,EAC7B,IAAI,IAAI8iK,KAAQL,GACTA,GAAsBK,EAAK,GAC1BlzB,GAAKnjE,GAAGg2F,GAAsBK,GAAMxpJ,SAAU,CAACuoG,SAAU8gD,GAAWxiJ,EAAIsiJ,GAAsBK,GAAMxpJ,SAAS6G,EAAI,IAAK9iB,KAAKI,MAE3HmyI,GAAKnjE,GAAGg2F,GAAsBK,GAAMr2I,SAAU,CAACo1F,SAAU8gD,GAAWhnK,GAAM8mK,GAAsBziK,OAAO,EAvIzH,GAuIyI,GAAInE,EAAG2lK,GAAcrhJ,EAAG,IAC/IyvH,GAAKnjE,GAAGg2F,GAAsBK,GAAMxpJ,SAAU,CAACuoG,SAAU8gD,GAAWxiJ,EAAKsiJ,GAAsBziK,OAAO,EAAG,IAAK3C,KAAKI,MAEpHglK,GAAsBK,EAAK,IAAML,GAAsBK,GAAMr2I,SAAS9wB,GAAK8mK,GAAsBK,EAAK,GAAGr2I,SAAS9wB,GACjHorH,YAAW,WACP07C,GAAsBK,EAAK,GAAGr2I,SAAS9wB,GAAK,EAChD,GAAGgnK,UAKf,IAAI,IAAI3T,EAAK,EAAGA,EAAGyT,GAAsBziK,OAAQgvJ,IAC1CyT,GAAsB,IAAMA,GAAsBzT,IAAOyT,GAAsB,IAC9E7yB,GAAKnjE,GAAGg2F,GAAsBzT,GAAI11I,SAAU,CAACuoG,SAAU8gD,GAAWxiJ,EAAGsiJ,GAAsB,GAAGnpJ,SAAS6G,EAAO,IAAH6uI,EAAQ3xJ,KAAKI,KACxHmyI,GAAKnjE,GAAGg2F,GAAsBzT,GAAIviI,SAAU,CAACo1F,SAAS8gD,GAAWhnK,EAAG8mK,GAAsB,GAAGh2I,SAAS9wB,EArJpH,IAqJmIqzJ,EAAG,OAExHpf,GAAKnjE,GAAGg2F,GAAsBzT,GAAI11I,SAAU,CAACuoG,SAAU8gD,GAAWxiJ,EAAKsiJ,GAAsBziK,OAAO,EAAG,IAAK3C,KAAKI,KACjHmyI,GAAKnjE,GAAGg2F,GAAsBzT,GAAIviI,SAAU,CAACo1F,SAAU8gD,GAAWhnK,GAAM8mK,GAAsBziK,OAAO,EAxJnH,GAwJiK,EAA7ByiK,GAAsBziK,OAAWnE,EAAG2lK,GAAcrhJ,EAAG,IAI3L,GAAGwiJ,UAGF,GAAa,GAAVD,GAAgB,CACpB,IAAI,IAAIR,KAAUO,GACXJ,GAAiB72I,QAAUi3I,GAAsBP,KAChDtyB,GAAKnjE,GAAG41F,GAAiB72I,OAAOiB,SAAU,CAACo1F,SAAU,EAAGlmH,EAAG,EAAGE,EAAG,GAAIskB,EAAE,KACvEyvH,GAAKnjE,GAAG41F,GAAiB72I,OAAOlS,SAAU,CAACuoG,SAAU,EAAG1hG,EAAG,KAInE,GADAqiJ,IAAkB,EACfF,IAAiBA,IAAiBD,GACjC,IAAI,IAAIrT,EAAK,EAAGA,EAAGyT,GAAsBziK,OAAQgvJ,IAC1CyT,GAAsB,IAAMA,GAAsBzT,IAAOyT,GAAsB,IAC9E7yB,GAAKnjE,GAAGg2F,GAAsBzT,GAAI11I,SAAU,CAACuoG,SAAU8gD,GAAWxiJ,EAAGsiJ,GAAsB,GAAGnpJ,SAAS6G,EAAO,IAAH6uI,EAAQ3xJ,KAAKI,KACxHmyI,GAAKnjE,GAAGg2F,GAAsBzT,GAAIviI,SAAU,CAACo1F,SAAS8gD,GAAWhnK,EAAG8mK,GAAsB,GAAGh2I,SAAS9wB,EA3KhH,IA2K+HqzJ,EAAG,GAAInzJ,EAAG2lK,GAAcrhJ,EAAG,MAEhJyvH,GAAKnjE,GAAGg2F,GAAsBzT,GAAI11I,SAAU,CAACuoG,SAAU8gD,GAAWxiJ,EAAKsiJ,GAAsBziK,OAAO,EAAG,IAAK3C,KAAKI,KACjHmyI,GAAKnjE,GAAGg2F,GAAsBzT,GAAIviI,SAAU,CAACo1F,SAAU8gD,GAAWhnK,GAAM8mK,GAAsBziK,OAAO,EA9K/G,GA8K6J,EAA7ByiK,GAAsBziK,OAAWnE,EAAG2lK,GAAcrhJ,EAAG,IAI3L,CACAmiJ,GAAgBD,EACpB,CACJ","sources":["webpack://festival-mmi/./src/menu.js","webpack://festival-mmi/./src/style/main.scss","webpack://festival-mmi/./node_modules/css-loader/dist/runtime/api.js","webpack://festival-mmi/./node_modules/css-loader/dist/runtime/cssWithMappingToString.js","webpack://festival-mmi/./node_modules/css-loader/dist/runtime/getUrl.js","webpack://festival-mmi/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js","webpack://festival-mmi/./static/image/Bouton_avancer.png","webpack://festival-mmi/./static/image/Emprunte_Van.svg","webpack://festival-mmi/./static/image/Oeil_Loading.svg","webpack://festival-mmi/./static/image/Tattoine.svg","webpack://festival-mmi/./static/image/bas.png","webpack://festival-mmi/./static/image/croix.png","webpack://festival-mmi/./static/image/cross.svg","webpack://festival-mmi/./static/image/droite.png","webpack://festival-mmi/./static/image/gauche.png","webpack://festival-mmi/./static/image/liste.png","webpack://festival-mmi/./static/image/overlay_commandes.png","webpack://festival-mmi/./static/image/replay.png","webpack://festival-mmi/webpack/bootstrap","webpack://festival-mmi/webpack/runtime/compat get default export","webpack://festival-mmi/webpack/runtime/define property getters","webpack://festival-mmi/webpack/runtime/hasOwnProperty shorthand","webpack://festival-mmi/webpack/runtime/make namespace object","webpack://festival-mmi/webpack/runtime/nonce","webpack://festival-mmi/./src/style/main.scss?a221","webpack://festival-mmi/./node_modules/three/build/three.module.js","webpack://festival-mmi/./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js","webpack://festival-mmi/./node_modules/three/examples/jsm/loaders/GLTFLoader.js","webpack://festival-mmi/./src/utils.js","webpack://festival-mmi/./src/cameraHelper.js","webpack://festival-mmi/./node_modules/gsap/gsap-core.js","webpack://festival-mmi/./node_modules/gsap/CSSPlugin.js","webpack://festival-mmi/./node_modules/gsap/index.js","webpack://festival-mmi/./src/artistes/artists.js"],"sourcesContent":["document.body.addEventListener('contextmenu', e => e.preventDefault() & e.stopPropagation());\ndocument.body.addEventListener('mousedown', onMouseDown);\n// document.body.addEventListener('touchstart', e => onMouseDown(e.touches[0]));\ndocument.body.addEventListener('mouseup', onMouseUp);\n// document.body.addEventListener('touchend', e => onMouseUp(e.touches[0]));\ndocument.body.addEventListener('mousemove', onMouseMove);\ndocument.body.addEventListener('touchmove', e => onMouseMove(e.touches[0]));\n\nlet value, showing, anchorX, anchorY, min = 100;\nconst wheel = document.querySelector('.wheel');\nconst links = [\"./index.html\", \"./iut.html\", \"./anciens.html\", \"./game.html\", \"./mentions_legales.html\", \"./gallery.html\", \"https://youtu.be/VrPx1opuGQM\", \"./artists.html\"]\n\nif (\"ontouchstart\" in document.documentElement)\n{\n\twheel.classList.add(\"burger_menu\")\n\twheel.classList.add(\"burger_menu_img\")\n\n\tdocument.getElementById('menu').onclick = function(){\n\t\tif(document.getElementById('middle').classList.contains(\"cross_menu\")){\n\t\t\tshowing = false\n\t\t\twheel.classList.remove('on');\n\t\t\twheel.classList.add(\"burger_menu_img\")\n\t\t\tdocument.getElementById('middle').classList.remove(\"cross_menu\")\n\t\t} else {\n\t\t\tshowing = true\n\t\t\tdocument.getElementById('middle').classList.add('cross_menu')\n\t\t\twheel.classList.remove(\"burger_menu_img\")\n\t\t\t// wheel.classList.add(\"cross_menu\")\n\t\t\twheel.classList.add('on');\n\t\t}\n\t}\n}\n\nfunction onMouseDown({ clientX: x, clientY: y }) {\n\tshowing = true;\n\tanchorX = x;\n\tanchorY = y;\n\n\twheel.style.setProperty('--x', `${x}px`);\n\twheel.style.setProperty('--y', `${y}px`);\n\twheel.classList.add('on');\n}\n\nfunction onMouseUp() {\n\tshowing = false;\n\twheel.setAttribute('data-chosen', 0);\n\twheel.classList.remove('on');\n    if(value != undefined && value >=0){\n        window.location.href = links[value]\n    }\n}\n\nfunction onMouseMove({ clientX: x, clientY: y }) {\n\tif (!showing) return;\n\n\tlet dx = x - anchorX;\n\tlet dy = y - anchorY;\n\tlet mag = Math.sqrt(dx * dx + dy * dy);\n\tlet index = 0;\n\n\tif (mag >= min) {\n\t\tlet deg = Math.atan2(dy, dx) + 0.625 * Math.PI;\n\t\twhile (deg < 0) deg += Math.PI * 2;\n\t\tindex = Math.floor(deg / Math.PI * 4) + 1;\n\t}\n\n\twheel.setAttribute('data-chosen', index);\n    value = index-1;\n    console.log(index)\n}\n\n// document.body.addEventListener('touchstart', function(){\n// \tif\n// });\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/api.js\";\nimport ___CSS_LOADER_GET_URL_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/getUrl.js\";\nimport ___CSS_LOADER_URL_IMPORT_0___ from \"../../static/image/Tattoine.svg\";\nimport ___CSS_LOADER_URL_IMPORT_1___ from \"../../static/image/Emprunte_Van.svg\";\nimport ___CSS_LOADER_URL_IMPORT_2___ from \"../../static/image/cross.svg\";\nimport ___CSS_LOADER_URL_IMPORT_3___ from \"../../static/image/Oeil_Loading.svg\";\nimport ___CSS_LOADER_URL_IMPORT_4___ from \"../../static/image/gauche.png\";\nimport ___CSS_LOADER_URL_IMPORT_5___ from \"../../static/image/droite.png\";\nimport ___CSS_LOADER_URL_IMPORT_6___ from \"../../static/image/Bouton_avancer.png\";\nimport ___CSS_LOADER_URL_IMPORT_7___ from \"../../static/image/bas.png\";\nimport ___CSS_LOADER_URL_IMPORT_8___ from \"../../static/image/replay.png\";\nimport ___CSS_LOADER_URL_IMPORT_9___ from \"../../static/image/overlay_commandes.png\";\nimport ___CSS_LOADER_URL_IMPORT_10___ from \"../../static/image/liste.png\";\nimport ___CSS_LOADER_URL_IMPORT_11___ from \"../../static/image/croix.png\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);\nvar ___CSS_LOADER_URL_REPLACEMENT_2___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_2___);\nvar ___CSS_LOADER_URL_REPLACEMENT_3___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_3___);\nvar ___CSS_LOADER_URL_REPLACEMENT_4___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_4___);\nvar ___CSS_LOADER_URL_REPLACEMENT_5___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_5___);\nvar ___CSS_LOADER_URL_REPLACEMENT_6___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_6___);\nvar ___CSS_LOADER_URL_REPLACEMENT_7___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_7___);\nvar ___CSS_LOADER_URL_REPLACEMENT_8___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_8___);\nvar ___CSS_LOADER_URL_REPLACEMENT_9___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_9___);\nvar ___CSS_LOADER_URL_REPLACEMENT_10___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_10___);\nvar ___CSS_LOADER_URL_REPLACEMENT_11___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_11___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"*{padding:0;margin:0;font-family:\\\"Manrope\\\",sans-serif}body,html{overflow:hidden}#tattoine{background-image:url(\" + ___CSS_LOADER_URL_REPLACEMENT_0___ + \");position:absolute;width:100vw;height:100vh}#tattoine h1{position:relative;top:50%;text-align:center}#among_us h1{position:absolute;top:50%;width:100%;text-align:center;color:#fff;transform:translateY(-50%)}#van_ejected img{height:600px;position:absolute;left:0%;top:50%;animation:eject 9s linear;transform-origin:45vmin 45vmin;transform:translate3d(-50vmin, -45vmin, 0px) rotate(0turn) scale(0.15)}@keyframes eject{0%{transform:translate3d(-50vmin, -45vmin, 0px) rotate(0turn) scale(0.15)}50%,100%{transform:translate3d(100vw, -45vmin, 0px) rotate(-2turn) scale(0.15)}}.webgl{position:fixed;top:0;left:0;width:100%;height:100%}#load{transition:all 2s ease;-webkit-transition:all 2s ease;-moz-transition:all 2s ease;-o-transition:all 2s ease;-ms-transition:all 2s ease;background-color:#4960a9;position:absolute;z-index:999;width:100vw;height:100vh}.load-non{opacity:100%}.load-active{opacity:0%}.hidden{visibility:hidden}.van{background-image:url(\" + ___CSS_LOADER_URL_REPLACEMENT_1___ + \");background-position:center;background-size:cover;position:absolute;width:33vw;height:75vh;top:50%;left:50%;transform:translate(-50%, -50%)}.white_van{position:absolute;top:50%;left:50%;height:75vh;transform:translate(-50%, -50%)}#complete{z-index:999;animation-name:loader;animation-duration:2.5s}@keyframes loader{0%{clip-path:polygon(0% 100%, 100% 100%, 100% 100%, 0% 100%)}50%{clip-path:polygon(0% 50%, 100% 50%, 100% 100%, 0% 100%)}100%{clip-path:polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)}}.cursor{position:absolute;transform:translate(-50%, -50%);padding:15px;border-radius:50%;z-index:998;border:5px solid #fff;cursor:none}.cross{width:3rem;height:3rem;border-radius:50%;position:absolute;z-index:999;transform:translate(-50%, -50%);pointer-events:none;background-image:url(\" + ___CSS_LOADER_URL_REPLACEMENT_2___ + \")}.look{width:6rem;height:6rem;position:absolute;z-index:999;transform:translate(-50%, -25%);background-size:100%;background-repeat:no-repeat;pointer-events:none;background-image:url(\" + ___CSS_LOADER_URL_REPLACEMENT_3___ + \")}#arrow{z-index:998;position:absolute;top:1%;left:3%}#hub_arrow{z-index:998;position:absolute;top:4vh;left:3vw;transform:scale(0.9)}.direction{z-index:998;height:100vh;position:absolute;transform:scale(0.2) translate(-200%, -200%)}#gauche{border:none;background-color:rgba(0,0,0,0);background-repeat:no-repeat;width:50%;background-image:url(\" + ___CSS_LOADER_URL_REPLACEMENT_4___ + \");top:95%;left:1%}#droite{border:none;background-color:rgba(0,0,0,0);background-repeat:no-repeat;width:50%;background-image:url(\" + ___CSS_LOADER_URL_REPLACEMENT_5___ + \");top:95%;left:10%}#haut{border:none;background-color:rgba(0,0,0,0);background-repeat:no-repeat;width:50%;background-image:url(\" + ___CSS_LOADER_URL_REPLACEMENT_6___ + \");top:75%;left:100%}#bas{border:none;background-color:rgba(0,0,0,0);background-repeat:no-repeat;width:50%;background-image:url(\" + ___CSS_LOADER_URL_REPLACEMENT_7___ + \");top:95%;left:100%}#replay{height:150vh;width:80vw;z-index:997;position:absolute;transform:scale(0.1) translate(-400%, -400%);border:none;background-color:rgba(0,0,0,0);background-repeat:no-repeat;background-image:url(\" + ___CSS_LOADER_URL_REPLACEMENT_8___ + \");left:95%}.blackscreen-active{background-color:#000}.blackscreen-non{background-color:rgba(0,0,0,.1)}#blackscreen{position:absolute;z-index:999;width:100vw;height:100vh;transition:all 2s ease;-webkit-transition:all 2s ease;-moz-transition:all 2s ease;-o-transition:all 2s ease;-ms-transition:all 2s ease}#commande{position:absolute;z-index:998;background-image:url(\" + ___CSS_LOADER_URL_REPLACEMENT_9___ + \");background-size:contain;background-repeat:no-repeat;border:none;width:20%;height:20%;bottom:0%}.wheel{--x: 0px;--y: 0px;position:absolute;top:var(--y);left:var(--x);width:200px;height:200px;transform:translate(-50%, -50%);transform-origin:0% 0%;z-index:999}.wheel.on .arc{opacity:.8;transform:scale(1.5) rotate(var(--rotation)) !important;transition-timing-function:cubic-bezier(0, 0.5, 0.5, 1.5)}.wheel.on .arc p{text-align:center;transform:rotate(var(--test)) !important}.wheel .arc{position:absolute;top:0;right:0;width:80%;height:80%;transform-origin:0% 100%;background-image:radial-gradient(circle at 0% 100%, transparent, transparent 29.5%, var(--color-border) 30%, var(--color-border) 30.5%, var(--color) 31%, var(--color) 50%, var(--color-border) 50.25%, var(--color-border) 51.5%, transparent 51.75%, transparent);transition-property:transform,opacity;transition-duration:.3s;transition-timing-function:cubic-bezier(0.4, -0.4, 0.7, -0.3);-webkit-clip-path:polygon(0 0, 0 99%, 99% 0);clip-path:polygon(0 0, 0 99%, 99% 0);opacity:0;transform:scale(0) rotate(var(--rotation))}.wheel .arc p{position:relative;color:#fff;top:42%;left:-27%;font-size:.5em;text-align:center;transform:rotate(var(--test))}.wheel[data-chosen=\\\"1\\\"] .arc:nth-child(1){opacity:1;transform:scale(1.6) rotate(var(--rotation)) !important;filter:brightness(150%)}.wheel[data-chosen=\\\"1\\\"] .arc:nth-child(1) i{color:rgba(0,0,0,.5)}.wheel .arc:nth-child(1){--rotation: -22.5deg;--color: rgba(179, 179, 179, 0.6);--color-border: rgb(179, 179, 179);--test: 22.5deg;transition-delay:0.015s}.wheel[data-chosen=\\\"2\\\"] .arc:nth-child(2){opacity:1;transform:scale(1.6) rotate(var(--rotation)) !important;filter:brightness(150%)}.wheel[data-chosen=\\\"2\\\"] .arc:nth-child(2) i{color:rgba(0,0,0,.5)}.wheel .arc:nth-child(2){--rotation: 22.5deg;--color: rgba(179, 179, 179, 0.6);--color-border: rgb(179, 179, 179);--test: -22.5deg;transition-delay:0s}.wheel[data-chosen=\\\"3\\\"] .arc:nth-child(3){opacity:1;transform:scale(1.6) rotate(var(--rotation)) !important;filter:brightness(150%)}.wheel[data-chosen=\\\"3\\\"] .arc:nth-child(3) i{color:rgba(0,0,0,.5)}.wheel .arc:nth-child(3){--rotation: 67.5deg;--color: rgba(179, 179, 179, 0.6);--color-border: rgb(179, 179, 179);--test: -67.5deg;transition-delay:0.015s}.wheel[data-chosen=\\\"4\\\"] .arc:nth-child(4){opacity:1;transform:scale(1.6) rotate(var(--rotation)) !important;filter:brightness(150%)}.wheel[data-chosen=\\\"4\\\"] .arc:nth-child(4) i{color:rgba(0,0,0,.5)}.wheel .arc:nth-child(4){--rotation: 112.5deg;--color: rgba(179, 179, 179, 0.6);--color-border: rgb(179, 179, 179);--test: -112.5deg;transition-delay:0s}.wheel[data-chosen=\\\"5\\\"] .arc:nth-child(5){opacity:1;transform:scale(1.6) rotate(var(--rotation)) !important;filter:brightness(150%)}.wheel[data-chosen=\\\"5\\\"] .arc:nth-child(5) i{color:rgba(0,0,0,.5)}.wheel .arc:nth-child(5){--rotation: 157.5deg;--color: rgba(179, 179, 179, 0.6);--color-border: rgb(179, 179, 179);--test: -157.5deg;transition-delay:0.015s}.wheel[data-chosen=\\\"6\\\"] .arc:nth-child(6){opacity:1;transform:scale(1.6) rotate(var(--rotation)) !important;filter:brightness(150%)}.wheel[data-chosen=\\\"6\\\"] .arc:nth-child(6) i{color:rgba(0,0,0,.5)}.wheel .arc:nth-child(6){--rotation: 202.5deg;--color: rgba(179, 179, 179, 0.6);--color-border: rgb(179, 179, 179);--test: -202.5deg;transition-delay:0s}.wheel[data-chosen=\\\"7\\\"] .arc:nth-child(7){opacity:1;transform:scale(1.6) rotate(var(--rotation)) !important;filter:brightness(150%)}.wheel[data-chosen=\\\"7\\\"] .arc:nth-child(7) i{color:rgba(0,0,0,.5)}.wheel .arc:nth-child(7){--rotation: 247.5deg;--color: rgba(179, 179, 179, 0.6);--color-border: rgb(179, 179, 179);--test: -247.5deg;transition-delay:0.015s}.wheel[data-chosen=\\\"8\\\"] .arc:nth-child(8){opacity:1;transform:scale(1.6) rotate(var(--rotation)) !important;filter:brightness(150%)}.wheel[data-chosen=\\\"8\\\"] .arc:nth-child(8) i{color:rgba(0,0,0,.5)}.wheel .arc:nth-child(8){--rotation: 292.5deg;--color: rgba(179, 179, 179, 0.6);--color-border: rgb(179, 179, 179);--test: -292.5deg;transition-delay:0s}.burger_menu{z-index:998;position:absolute;top:30%;left:18%}.burger_menu_img{background-image:url(\" + ___CSS_LOADER_URL_REPLACEMENT_10___ + \");background-size:30%;background-repeat:no-repeat}.cross_menu{background-image:url(\" + ___CSS_LOADER_URL_REPLACEMENT_11___ + \");background-repeat:no-repeat;background-position:center;background-size:contain}#middle{transform:translate(120%, 120%);width:30%;height:30%;margin:0}\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/style/main.scss\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"*\\n{\\n    padding: 0;\\n    margin: 0;\\n    font-family: 'Manrope', sans-serif;\\n    /* cursor: none; */\\n}\\n\\nbody,\\nhtml\\n{\\n    overflow: hidden;\\n}\\n\\n#tattoine{\\n    background-image: url(../../static/image/Tattoine.svg);\\n    position: absolute;\\n    width: 100vw;\\n    height: 100vh;\\n}\\n\\n/* #among_us{\\n    background-color: black;\\n    background-image: url(image/Ciel_Among_us.svg);\\n    position: absolute;\\n    width: 100vw;\\n    height: 100vh;\\n} */\\n\\n#tattoine h1{\\n    position: relative;\\n    top: 50%;\\n    text-align: center;\\n}\\n\\n#among_us h1{\\n    position: absolute;\\n    top: 50%;\\n    width: 100%;\\n    text-align: center;\\n    color: white;\\n    transform: translateY(-50%);\\n}\\n\\n#van_ejected img{\\n    height: 600px;\\n  position: absolute;\\n  left: 0%;\\n  top: 50%;\\n  animation: eject 9s linear;\\n  transform-origin: 45vmin 45vmin;\\n  transform: translate3d(-50vmin, -45vmin, 0px) rotate(0turn) scale(0.15);\\n}\\n\\n@keyframes eject {\\n  0% {\\n    transform: translate3d(-50vmin, -45vmin, 0px) rotate(0turn) scale(0.15);\\n  }\\n  50%, 100% {\\n    transform: translate3d(100vw, -45vmin, 0px) rotate(-2turn) scale(0.15);\\n  }\\n}\\n\\n.webgl\\n{\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    width: 100%;\\n    height: 100%;\\n    /* background: #000000; */\\n}\\n\\n#load{\\n    transition: all 2s ease;\\n    -webkit-transition: all 2s ease;  \\n    -moz-transition: all 2s ease;  \\n    -o-transition: all 2s ease;  \\n    -ms-transition: all 2s ease;\\n    background-color: #4960A9;\\n    position: absolute;\\n    z-index: 999;\\n    /* background-image: url(/images/Emprunte_Van.svg); */\\n    width: 100vw;\\n    height: 100vh;\\n}\\n\\n.load-non {\\n    opacity: 100%;\\n}\\n.load-active {\\n    opacity: 0%;\\n}\\n\\n.hidden{\\n    visibility: hidden;\\n}\\n\\n.van{\\n    background-image: url(../../static/image/Emprunte_Van.svg);\\n    background-position: center;\\n    background-size: cover;\\n    position: absolute;\\n    width: 33vw;\\n    height: 75vh;\\n    top: 50%;\\n    left: 50%;\\n    transform: translate(-50%, -50%);\\n}\\n\\n.white_van{\\n    /* clip-path: polygon(0% 50%, 100% 50%, 100% 100%, 0% 100%); */\\n    position: absolute;\\n    top: 50%;\\n    left: 50%;\\n    height: 75vh;\\n    transform: translate(-50%, -50%);\\n    /* animation-name: loader; */\\n    /* animation-duration: 2.5s; */\\n}\\n\\n/* .eye_van{\\n    position: absolute;\\n    display: block;\\n    width: 100vw;\\n    height: 100vh;\\n    transform: scale(0.1) rotate(0turn);\\n    animation: eyeSpin 4s alternate;\\n} */\\n\\n#complete{\\n    z-index: 999;\\n    animation-name: loader;\\n    animation-duration: 2.5s;\\n}\\n\\n/* @keyframes eyeSpin{\\n    0%{\\n        transform: rotate(0turn) scale(0.1);\\n    }\\n    100%{\\n        transform: rotate(2turn) scale(0.1);\\n    }\\n} */\\n\\n@keyframes loader{\\n    0% {clip-path: polygon(0% 100%, 100% 100%, 100% 100%, 0% 100%);}\\n    50% {clip-path: polygon(0% 50%, 100% 50%, 100% 100%, 0% 100%);}\\n    100% {clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);}\\n}\\n\\n.cursor{\\n    position: absolute;\\n    transform: translate(-50%, -50%);\\n    padding: 15px;\\n    border-radius: 50%;\\n    z-index: 998;\\n    border: 5px solid #FFFFFF;\\n    cursor: none;\\n}\\n\\n.cross {\\n    width: 3rem;\\n    height: 3rem;\\n    /* border: 2px solid red; */\\n    border-radius: 50%;\\n    position: absolute;\\n    z-index: 999;\\n    transform: translate(-50%, -50%);\\n    pointer-events: none;\\n    background-image: url(../../static/image/cross.svg);\\n}\\n\\n.look {\\n    width: 6rem;\\n    height: 6rem;\\n    /* border: 2px solid red; */\\n    /* border-radius: 50%; */\\n    position: absolute;\\n    z-index: 999;\\n    transform: translate(-50%, -25%);\\n    background-size: 100%;\\n    background-repeat: no-repeat;\\n    pointer-events: none;\\n    background-image: url(../../static/image/Oeil_Loading.svg);\\n}\\n\\n#arrow{\\n    z-index: 998;\\n    position: absolute;\\n    top: 1%;\\n    left: 3%;\\n}\\n\\n#hub_arrow{\\n    z-index: 998;\\n    position: absolute;\\n    top: 4vh;\\n    left: 3vw;\\n    transform: scale(0.9);\\n}\\n\\n.direction {\\n    z-index: 998;\\n    height: 100vh;\\n    position: absolute;\\n    transform: scale(0.2) translate(-200%, -200%);\\n}\\n\\n#gauche{\\n    border: none;\\n    background-color: Transparent;\\n    background-repeat:no-repeat;\\n    width: 50%;\\n    background-image: url(../../static/image/gauche.png);\\n    top: 95%;\\n    left: 1%;\\n}\\n\\n#droite{\\n    border: none;\\n    background-color: Transparent;\\n    background-repeat:no-repeat;\\n    width: 50%;\\n    background-image: url(../../static/image/droite.png);\\n    top: 95%;\\n    left: 10%;\\n}\\n\\n#haut{\\n    border: none;\\n    background-color: Transparent;\\n    background-repeat:no-repeat;\\n    width: 50%;\\n    background-image: url(../../static/image/Bouton_avancer.png);\\n    top: 75%;\\n    left: 100%;\\n}\\n\\n#bas{\\n    border: none;\\n    background-color: Transparent;\\n    background-repeat:no-repeat;\\n    width: 50%;\\n    background-image: url(../../static/image/bas.png);\\n    top: 95%;\\n    left: 100%;\\n}\\n\\n#replay{\\n    height: 150vh;\\n    width: 80vw;\\n    z-index: 997;\\n    position: absolute;\\n    transform: scale(0.1) translate(-400%, -400%);\\n    border: none;\\n    background-color: Transparent;\\n    background-repeat:no-repeat;\\n    background-image: url(../../static/image/replay.png);\\n    left: 95%;\\n}\\n\\n.blackscreen-active{\\n    \\n    background-color: rgb(0, 0, 0, 1);\\n    \\n}\\n\\n.blackscreen-non{\\n    \\n    background-color: rgba(0, 0, 0, 0.1);\\n    \\n}\\n\\n#blackscreen{\\n    position: absolute;\\n    z-index: 999;\\n    width: 100vw;\\n    height: 100vh;\\n    transition: all 2s ease;\\n    -webkit-transition: all 2s ease;  \\n    -moz-transition: all 2s ease;  \\n    -o-transition: all 2s ease;  \\n    -ms-transition: all 2s ease; \\n}\\n\\n#commande{\\n    position: absolute;\\n    z-index: 998;\\n    background-image: url(../../static/image/overlay_commandes.png);\\n    background-size: contain;\\n    background-repeat: no-repeat;\\n    border: none;\\n    width: 20%;\\n    height: 20%;\\n    bottom: 0%;\\n}\\n\\n\\n.wheel {\\n\\t--x: 0px;\\n\\t--y: 0px;\\n\\tposition: absolute;\\n\\ttop: var(--y);\\n\\tleft: var(--x);\\n\\twidth: 200px;\\n\\theight: 200px;\\n\\ttransform: translate(-50%, -50%);\\n\\ttransform-origin: 0% 0%;\\n    z-index: 999;\\n\\n\\t&.on {\\n\\t\\t.arc {\\n\\t\\t\\topacity: 0.8;\\n\\t\\t\\ttransform: scale(1.5) rotate(var(--rotation)) !important;\\n\\t\\t\\ttransition-timing-function: cubic-bezier(0, 0.5, 0.5, 1.5);\\n            p{\\n                text-align: center;\\n                transform: rotate(var(--test)) !important;\\n            }\\n\\t\\t}\\n\\n        \\n\\t}\\n\\n\\t.arc {\\n\\t\\tposition: absolute;\\n\\t\\ttop: 0;\\n\\t\\tright: 0;\\n\\t\\twidth: 80%;\\n\\t\\theight: 80%;\\n\\t\\ttransform-origin: 0% 100%;\\n\\t\\tbackground-image: radial-gradient(circle at 0% 100%, transparent, transparent 29.5%, var(--color-border) 30%, var(--color-border) 30.5%, var(--color) 31%, var(--color) 50%, var(--color-border) 50.25%, var(--color-border) 51.5%, transparent 51.75%, transparent);\\n\\t\\ttransition-property: transform, opacity;\\n\\t\\ttransition-duration: 0.3s;\\n\\t\\ttransition-timing-function: cubic-bezier(0.4, -0.4, 0.7, -0.3);\\n\\t\\t-webkit-clip-path: polygon(0 0, 0 99%, 99% 0);\\n\\t\\tclip-path: polygon(0 0, 0 99%, 99% 0);\\n\\t\\topacity: 0;\\n\\t\\ttransform: scale(0) rotate(var(--rotation));\\n\\n        p{\\n            position: relative;\\n            color: white;\\n            top: 42%;\\n            left: -27%;\\n            font-size: 0.5em;\\n            text-align: center;\\n            transform: rotate(var(--test));\\n        }\\n\\t}\\n\\n\\t@for $i from 1 through 8 {\\n\\t\\t&[data-chosen='#{$i}'] {\\n\\t\\t\\t.arc {\\n\\t\\t\\t\\t&:nth-child(#{$i}) {\\n\\t\\t\\t\\t\\topacity: 1;\\n\\t\\t\\t\\t\\ttransform: scale(1.6) rotate(var(--rotation)) !important;\\n\\t\\t\\t\\t\\tfilter: brightness(150%);\\n\\t\\t\\t\\t\\ti {\\n\\t\\t\\t\\t\\t\\tcolor: rgba(0, 0, 0, 0.5);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t.arc {\\n\\t\\t\\t&:nth-child(#{$i}) {\\n\\t\\t\\t\\t--rotation: #{-22.5 + ($i - 1) * 45}deg;\\n\\t\\t\\t\\t--color: rgba(179, 179, 179, 0.6);\\n\\t\\t\\t\\t--color-border: rgb(179, 179, 179);\\n                --test : #{22.5 - ($i - 1) * 45}deg;\\n\\t\\t\\t\\ttransition-delay: #{($i % 2) * 0.015}s;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\n.burger_menu {\\n    z-index: 998;\\n    position: absolute;\\n    top: 30%;\\n    left: 18%;\\n}\\n\\n.burger_menu_img {\\n    background-image: url(../../static/image/liste.png);\\n    background-size: 30%;\\n    background-repeat: no-repeat;\\n}\\n\\n.cross_menu {\\n    background-image: url(../../static/image/croix.png);\\n    background-repeat: no-repeat;\\n    background-position: center;\\n    background-size: contain;\\n}\\n\\n#middle{\\n    transform: translate(120%, 120%);\\n    width: 30%;\\n    height: 30%;\\n    margin: 0;\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \"\"]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};","\"use strict\";\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nmodule.exports = function cssWithMappingToString(item) {\n  var _item = _slicedToArray(item, 4),\n      content = _item[1],\n      cssMapping = _item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (typeof btoa === \"function\") {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    var sourceMapping = \"/*# \".concat(data, \" */\");\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\"\\n\");\n  }\n\n  return [content].join(\"\\n\");\n};","\"use strict\";\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign\n\n\n  url = url && url.__esModule ? url.default : url;\n\n  if (typeof url !== \"string\") {\n    return url;\n  } // If url is already wrapped in quotes, remove them\n\n\n  if (/^['\"].*['\"]$/.test(url)) {\n    // eslint-disable-next-line no-param-reassign\n    url = url.slice(1, -1);\n  }\n\n  if (options.hash) {\n    // eslint-disable-next-line no-param-reassign\n    url += options.hash;\n  } // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n\n\n  if (/[\"'() \\t\\n]/.test(url) || options.needQuotes) {\n    return \"\\\"\".concat(url.replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\"), \"\\\"\");\n  }\n\n  return url;\n};","\"use strict\";\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce = typeof __webpack_nonce__ !== 'undefined' ? __webpack_nonce__ : null;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAFWmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgZXhpZjpQaXhlbFhEaW1lbnNpb249IjI1NiIKICAgZXhpZjpQaXhlbFlEaW1lbnNpb249IjI1NiIKICAgZXhpZjpDb2xvclNwYWNlPSIxIgogICB0aWZmOkltYWdlV2lkdGg9IjI1NiIKICAgdGlmZjpJbWFnZUxlbmd0aD0iMjU2IgogICB0aWZmOlJlc29sdXRpb25Vbml0PSIyIgogICB0aWZmOlhSZXNvbHV0aW9uPSI3Mi4wIgogICB0aWZmOllSZXNvbHV0aW9uPSI3Mi4wIgogICBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIgogICBwaG90b3Nob3A6SUNDUHJv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\"","export default \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj48c3ZnIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIHZpZXdCb3g9IjAgMCAxOTIwIDEwODAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgeG1sbnM6c2VyaWY9Imh0dHA6Ly93d3cuc2VyaWYuY29tLyIgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoyOyI+PGcgaWQ9IkNhbHF1ZS0xIiBzZXJpZjppZD0iQ2FscXVlIDEiPjxnPjxnPjx1c2UgeGxpbms6aHJlZj0iI19JbWFnZTEiIHg9IjU4MC42MDMiIHk9IjE4NC4xMjQiIHdpZHRoPSI3NTkuNTIzcHgiIGhlaWdodD0iNzEyLjE3N3B4IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjk5OTM3MiwwLDAsMC45OTg4NDUsMCwwKSIvPjwvZz48L2c+PC9nPjxkZWZzPjxpbWFnZSBpZD0iX0ltYWdlMSIgd2lkdGg9Ijc2MHB4IiBoZWlnaHQ9IjcxM3B4IiB4bGluazpocmVmPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQXZnQUFBTEpDQVlBQUFEQkJGZnJBQUFBQ1hCSVdYTUFBQTdFQUFBT3hBR1ZLdzRiQUFBZ0FFbEVRVlI0bk95OWU3QWwxMTNmKy8yZGVXdWtrYXpSbVpIbVNMS3NnelYrWVZzYWtJMXRiTEJ6TENRbjVXQVRZNE5zZzBaK2tZVGs4c2hNWFJLS3ZFaTV1T1NtS3JmQ0RZa3RpUkJDNE5hRkNnRW5tbHl3blFlMkhFSUlDYUZJamVNQUk4MVltcEdSRVg1SU91diswYjNXK3ExWDkrcmV2Yy9aKzh6M294cnQzZDNyMWZ2czNmMWR2LzcycndXRUVIS1pjZDJ4a3lzQXJ1ejZKMklPdHUvM0RtemVqQmlTQWZBY2dHY0FQTnUrTGhON0FPeHVYM2NCRUdOa2FCdHRoZXFQNzZzQS9oakEwKzFyOGQ4VGozNTBjK2hnQ0NGa21SbDhCQ2FFa08xbWRlMitGUUNIQVRrSzRDaUE2OXZYSXdDdVJyZDRQd2pnd0RZTW0weEdPQWtvVHlaY3VTK2hmekx3UndBK0QrQzhNZVlDQVB2djRzWEhIdUFFZ1JDeVZGRGdFMElXZ3RXMWt5c0Fya01vMk9OLzE3ZWlmaFZOcE5nall3TG5xam9QaDNQRmpMcXdvUnZvRmZIVkl3bVdrbmFUOXA0RDhEaUE4L0NpL3dLQUMrMUVRSzkvZ3BNQlFzZ2l3RE1hSVdTdXJLNmRGQUEzQUxnVndDM3dJdDBMZVRGSDBZajdYYmsycXNVM2oyZzdrMG9OM3p1SjZCZnpuZHY5WktCWTd6a0FUOEJQQUxUNFB3L2djd0ErQytDeGk0ODlNT09NaHhCQ3l2QjBTQWlabWRXMWt3Y0F1UldOaUcvK2lWbUhGL1hPRWxNVTYyTXQyN00wTWJ3TDBzZkVzclhjM01DT0NzV0xrNExxeWNEZ1NRQUFmTWtZOHprQVo5RUlmdnZ2TElEL2VmR3hCNzdVVlprUVF2cmc2WXNRVXNYcTJ2M1hBbmdSZ0hXSXVSV0FGZkMzQ3VSNnhNZVRxcU9MWk43MUZoM1NRVFU4R002WDZjUFZwbk94dTNURmFESkZrc25Bd0VsQXBmZzNiZVJmaTM3Nytyc1hIM3ZnVWxkbFFnZ0JlRTRqaEVTczNuanlDSUNYMkg4Q2VRbUFsNks1Z2RWVFBIcEl6ZWErUnJxN21senMweTB4ZnliK0d3M1Q5NE1ybXZvQzBlclNKR0IyOFcrTUFScTd6KzlFLy83YnhjY2VlTHhZa1JCeTJVR0JUOGhseXVxTko2OUhJOXl0aUxmL3JxdFI1MldOM1gxWUtSZXJ2SWxTUmx3b0dGZ3kyeThaeUpEUGU3UThCMHk4cHZKN1pHcDd6aGVzdWlLUTFKbEYvUGNLL3llUUYvN25peFVKSVRzV0NueENkamlyTjU0OEN1RGxBbmtwdkloL01RVFg1bXRrWFBJOTRqM2QzQ095cWtWNmp3VkM1bk1JNDRGeEd1WXlSZW9WOVBsZXl4T0RudTlxNzBTZ2J3SXd0ZmdmSFBHL0JPQy9RNGwrR1B5WGkrY2Z1RkNzU0FoWmVuZ2VJMlNIc0hyalNaSG1SdGZiM1QvQjdXZ3kxU2dLRnBxQ09POFg3NkZvN3hmcmVaSGZWNnRyVGQzbStVU1VTWWtKUHUvZVA4TmdaMzFiTUNmdTA5cHVUWEV5VURNSkdERUI2QkwvbmRGOFV4dnRCNXFzUHI4Wi9EUDQ3TVh6ek81RHlFNkFBcCtRSldUMXhwTzdXMXVORmZHM0EzZ2xnRU8rVkJTSjc0aXVkNHY0TGdFL1RMVDMzbExiYTl2cDFoNHlwNGcrMlY1TUVyV1A2ZmllRkt1YTdzMis4NmlQd3FTaU5HbW91UUtRSFc2MzhNOUgvSE85RExMNVBBWGdQeU1VL2I5ejhmd0R6eFlyRWtJV0VwNE5DVmx3anR4NC8wRUFyMEFvNWw4S1lGODJHajg0RXQ4WGdlOFc4Zldpdld3cG1FcVlsOXNaS2hESjlJejdHL1NMKzhyZXMrMUUzOGt4azRHT0NVQ3YrTy9zT3QxUUhFVkorTTlvODJrL3M2OEErRzhJUmY5dlhUei93TlBaU29TUWhZQm5OVUlXaUZiTWZ4MEVkd0s0QTQyWWZ5R0FsWHhFZmdvUkw4bjJtS3lJRC9yUEM0U2h3dDJYcjcxeHNyUzU5a29DMlU2cWIzQ3RycEQvM2d5ZEpBeWZESFE4WXFzd0FSZ2YrUzlORExvL0t6ZkNHVVMvK2x3MkFmd1BOSUwvUDhIZ013QStROUZQeU9MQTh4d2gyOFNSRys4WENGNE00RlVBWHQyK3ZneVFYZFVSK1VUa20xRWlQaHU3NzRpODF3cjNWTEJuNm1WMmR2Q0JLUm5QMURaaUhpcjdtZk5uUGxTazU1WjZJdlJESndSaE9mVWJTNm9YWXUrQnVDOUYvdWNuL1B1OS9mMzJIdlVaUEFmZ3Z3TDROSUJQd2VCVEFINlhubjVDdGdlZXRRalpJbzdjZFA5aE5FSytGZk55SjRDcisyNWlsZXcyTDlhelFuNlFpRTlQM24wQ3ZsZTRSK1B0UGRBVUkvZEp3ZTcyQmx0OXhtb1BIam9idHVqekt3anVUcjk2cnI4TzRWNDNJZkNDdTI4U2tHNVgzL0VvK3AvdlNvdjdYTlIvZ1BEdnMvbmtSSDlWcEw4enlnOEFmd1RnRVRTQy85TUFQblh4L0FNWGswcUVrTW5oV1lxUU9YRGtwdnYzb0xucDFZcjVWd05ZRDNWdmw3MG1qY3JYUnVRVENSdzBYQitGYjdabkJIeU5lTzhVN0JuRFQ3VjNYcExoZERHL0F4d1BuZE5IN0FlMm1oSEpuc0xmeDhUeXR2djdtWnNRQkMwVUl2V0FkRTRBOHVKL3FQQ1A5cUowTDBEY2JHYmxGS0svTXNvUE5FL2t0UkgrVHdQNHp4ZlBQL0JNdGlJaFpEUThTeEV5QVVkdXV2OG1BTjhBNE5XdG1MOWRnUDBBeW1LK3lsNGp5Ylp3UzdjbnZsN0U1eVA3L1pIeVZLaElzRDBtRWlHRll1VlI5eHl5K2h4QVE5c2pjNkl2SWwrN1lkYjJPcXhqd1dTZ01JRW9UZ0RhZDlsSnlCRHhuN1A5akJIK2FiUi9zT2dmYU8ycDlQSUR3SmZSK1BnYmF3L3c2eGZQUC9BSFNTVkN5Q0I0ZGlOa0JFZHV1djhGQU43US9KTnZFdUFXQUlQRmZJMjlKaEg3R1Z0Tmw1RFBpbmdWaFM5SDRHT2hVWXE0UitXcVJIYkowaE12RGp4RWJkRVJyV1BxYzluUWNWdnBQRG9iVmFFWVlDK3NLRzh1VEFTS1Z3VHlFNENrWEtiOU92R2ZzL3RrL2lJbG04OEkwVis4NnVHMmQ0bit0dTg2V3c4QWZBNEdId2Z3Q1FDZnVIaitnZitaVkNLRWRNS3pGQ0VWSExucC9uVUEzd1RJRzZRUjlqZm5QUFBUaVBsWXlMZHRvQ3prUTA5OEd0VlBhbVVqOEtwY0l1RHpFZmRhNGQ0cjJLc3ROM0g3aGNqcVhPRmgwN05WSWo4V2xSSnRyUnhIVDBnLzBkdUZpdm5ObVVtQU1RVmhMTjNpUDRuOER4SCs2ZVNoTDlwdmt2VitIUDJpdjBmd2o3RDFaUGIxOTJFYXNRL2c0eGZQUDNBMnFVUUlDZUNaaXBBTVIyNjYvemI0NlB3YkFLekZ3ajNVOTZHVlp2NWlmb2lRSHkvaVM5Y1NaaFh1YmhSaXVndjJOQ2lKd0s4Y0FGbHd1dit1eHNSLzE5cUpSaWc2aXhPRFVST0JRb3g3a1Bqdml2eWJUTWRsNFQrSjZNOWNBVWhGZjdnaUVmM0JXLzM1enlUNHo3V0MvK09BK2NURjh3LytYbEtKa01zY252MElBWERrcHZ0ZnJLTHpiNERnaG1aTFYzVGVpL2F3VkNqbTR4S3h4V2F1UXI1SHhCY2o4SDBDZm1iaDNuNHFSWUUrN3RERUo5bnVUTVkvN0tva2ZrdFI1YWplNElsQWFRSlFpTllIYjNMaXZ4ejFIeHZ4VDRSL05KaXdxUXJSUHpUS0gwZjRnZGtGdjhGamdJM3dtMDljUFAvZ2YwOHFFWEtad2JNaHVTdzVjdFA5dHdKeWx3RGZET0QxRUJ6TmkzbjlKbzdPRDRuTUR4VHphZ0FTRmdTaWszNVJ5R2NqOGVIS0lRSmVJRE1JOSs1RHpXaGhuczUwQnZSS0ZwV3NZT3d1VU5kdTcwUWhFdUlESmdMWlNVRFhCQ0FUL2M5SC9ydUVmeHJ4RDdaSEU0Z3hvbitZNEllclg0cnlaL1kwRmYzWnp6MHYrTFA3WkhBQndDZlJSUGovMWNYekQzNDJMVVRJem9iblAzSlpjT1NtKy9lMUVmcDdBTndOd1cwMTBmbFVMblpFNXl2RWZOWXJuNHZLWi9MTWp4THl3Y3NRRVo4N05NajB3ajJaUk5XMDJsVnc2Q0Z0bUZMa3piVjVodDl3TytQZnFiSzc0a1NocC82NGlVQ3VqaGtrL2t1Ui8xSEN2OHJtc3hXaWY2RGdEOTVxd2Q4djlzTnhCOFYvRDhESEFQTXJCdmpFcGZNUGZpVXRSTWpPZ21jcnNtTTVjdFA3YmxHQy9vMkFYR0czOVF2NmFhTHpwY2o4c0tqOERFSSswZlMyWUsySTc3cmkwRUVrM0l1bEN3TGZFNTZzMDV0c3U0Y3grU0dPUjh5VWtkSDBtUnBOOUg3dHhMTmI0TWR4OFBFVEFkVlNqL2h2M25WTllFWUsvMnFiVDUzbzMxckJINDA3RytFZkhkMy9Fd0MvQ3BpUEdlQlhMcDEvOEhOcElVS1dINTZ1eUk3aHlFM3YyeXZBNndIY0E4SGRnTHpJYmhzajZPY3Y1dnVqOGpNSitheUliMnYyV0cyS0FuNW00Vzc4K09vYXFGcnROK2Y3NjZwQnRvTmhmNWZlS3dURnpkMUszcUQwTzVobUl0QTNBU2hiZ0FxUi81endUMVYrTkE4WUZ1M2ZFdEUvUVlSL2t1aCtzL2k3VnV3RCtPU2w4dzkrTmFsSXlCTENzeHRaYW83ZTlMN25vNG5RM3dQSUd3RWNCTFpTMENNb1h5L200NGxBWHN4blpYVFFiVm5JOTBYaXUwVjhRY0NQRnU3ZGtmZXlNSys5VWxCVmVuNWNEamYzanI3UmRZS3VlMWVVQ3ZSTUZQb2FIamtSQ09UeUlQSGZGL25QQ1AvTVBvVEN2eVQ2Z1hLMFB4Yjk4eEQ4ZWpoYkwvZ0xZdjlwd1B4cUsvWS9kdW44Zy84cjJVbENsb1RMNEt4RWRoSkhibnFmQ1BCYUFIOFdJbmNEZUFrd1Z0QlBHSjJ2RWZOWjdkc2g1bU1oRDJURWZMZVE3eFB4MmEzQjUyZ3g3V1FpVzdoak1ZNVE1c3RYSDRqbUxLUjVRSndQYzU4YVZFdytNb0h1ekFwcGw0WlBCRXdjS2ZjYkNtTXBiQnNzL0EyeVZwOW9oM09pUDEybDlpRVEvVk5IK2FlSjhNOVo3QU13djJPQWp3SDRSUUQvL3RMNUI3ZHZsa3ZJUUhnK0kwdkIwWnZlZHdLQ2R3SHlEZ0EzQVZicmpZM1E5d2w2WGJiNTMrRG8vSkRJZkc5VXZxMVJzTlpraGJ5S3R1ZDF1VjVyVk4vWlJ2SVRqckhDdlZLb3ArT2U5eUdMaDhUcG1iTW1LajR3YW5qZHBJMGhFNEhTRE1Mb2N0RnZMcXNyODhLL0dXNjh3UXJpK1BkbzIrbUs5dGRHK211ai9IcnNOWUkvN0N3Vi9Ib1lYWUxmTHd3VC9CVmlQeHpmSHdENE9RRC83Tkw1QjM4ajJURkNGZ3llemNqQ2N2VG05NzBZa0hjQmVDZUFGeVpSK2tDTGpvL1F6eWM2UDV1WTcvTElKMkplZlNiZFF0NGd0ZENVaEhsQndNOG8zTVBQZEFqeDMyeGc5YW00SEt3NFE5a202MDdhN2NCeG1FUU9EdW1zTUFud3Y1Zng0cjlEK0djRzNCWHhMMFg3dDBMMHA1T1Z2T2l2aS9CSFk5RVIvK1RqMHVzS1lyOGlzdDhSMVljQi9nZUFuMFVqOXBsem55d2tQRnVSaGVMb3plOTdBU0R2UkNQcVg1NklhUmVsSHgraHp3bjZJTVpkRlBSYksrYkxVZm40YWtMOHBrZklaMFY4Ym52Y2QvbHdNVXk0UzMzUmp2NmxTcHJONFJESG82Wm5MdHErdjFFVC94RUdUaktNRW10REtoUkxseVlBMlVsSWhmZ1BJczhWd2o4enNPNW8vOVNpMzNVNlNQQm5rOXowUmZnSDJYbjhRbTZTVkJ2Wkw0bjl0djUvQWZDek1QalpTeGNlL0ovcEhoR3lQZkJVUmJhZG96ZS83d1kwMXB0M0NmQ3FKT3JzaEYwbzZrTkI3OXZyRi9RbHUwMU5kSDZMeEh4T3lLdjFkbnhGSVIrUEpZNFNEaFR4L1FKK29HaDNmOE9TWk9wcGFNWWoxL2g4OWp4a3BveFQrY056NXcvdE5sL0FUUTRxSndXOWs0R2FLd0U1RzFGTzJCZkYvelRDZjU2aVB4eXFHcDh4Q0s1U0RMeDUxMFRSK3JTL1FNNmpNN29mVHphQ0Y0TjhaRDhZVHQ4RTVOTUEvaGtNZnU3U2hRY2ZBeUhiQ005V1pGczRldlA3RHRsSXZRQnZnR0JGQy9oVWdMZHZBMldhajlMWFIrZ3pnajZZUENCcUkxd094alMxbUkrRXZPOG5IVmN3RHBoNDVUQVIzNm5RZTBSOHAyalBWT3JWOEhHQnZnb2pKd3Rrd2NpRmRmditockdBN2hIdjJjM3B5cHJKZ0VuVmVyWlF2c3RjbjNGenJmRHRFZjdwVGI2aHVwMnY2TytJOGxjSy9uUjhYZUphQy81OGREOFUrNW4yQm9yOStPL2NJL1EzQVh3Q0JqOExtSis5ZE9HaHAwRElGc016SDlsU2p0NzgvcHNBL0dVQjdvZmdVQ3JxdTZMMHpiYitsSlcxRVhyVnRGN1JGNTJYYU1YRVlqNHI1SU94VmdqNVVaRjQ2WS9BaTBRQ1ByZC9IZFZkZ1VMQm52ejhIY09hQVI0R3Q1WWVNVnlxTmJpYVZXdWx2NitWZGtNbkEvRmtRam9IMTNrRm9DVDh3NHErZHBmd3ovV1RDUCtKUmIrSlByOW9mUEcrcDBJY1JjSGZ0aEJNRU1yKy9hRHg2S09JSnh1Mno2Q2hkSlI2M3pvc1BEMzJIUUI0Q2diL0dEQi83OUtGaC80QWhHd1JQTE9STGVIb3plKy9YWUFmZ09BZGdPeXVFdlVxU3Q5cHU0bEZzL2JmUS9vajlCMkN2anM2UHljeEh3aDUrUDMwdzQzNnlVeDRDdXY5K0V1YllnR3Z4MXRhbkVhMGwwWDZ5TU5VWlRVZUJMZVdhcDArYmg1UXJOZy9RZWlhRUhSTUJoTFJyWmU2cndBVW8vOWR0cDlPNFIrSi9tUWJKaEw5QmNIZlJyN1RTVWV6a0JYOFNzRDNldmhkQTZuZ3I0dnVxOTcxaEVDUEt4WG9rZGpYOWVJb2YveEJCcTA4QzRPZkE4eVBYYnJ3MEg4R0lYT0c1ell5VjQ3ZS9QNjdSZkFEZ0x3eEVmV0pubzdXSmFKZWwrbkljcFB4MEhjSyttQWNzYUN2ak01UEl1Wk5abjN5QVlSaktLeDNlNWpkMUNIaVN4bzlKK0lyaEh0ZXRQZUcrWWVVN2loUnFSQ1pHV2RycVE3RmovdTdKbHRyaGIxZEdqVVJNQ2pHNGdzVGdDN3gzMm43cWJEN3BOVWo0VCtCNksrTDhrOHMrQlA5WEJEWGJybEw3SXRmWi96NjRGTTBTUG9mSi9TVENjT3ZBdmcvTGwxNDhHTWdaRTd3ekVZbTUrak43OThyd0hkQzVQc0F2Q3dVMUVaRjBUTUNPL0hTUTVYUm90Ni84U0ozcktEWG84OEwrdDdvL0l4aXZpOHEzeVhrNjZQeHlZd3FiaWtxMHkzZzAzN3JoSHZIZEtCOWpZUkRoUUR2djJtV1luOWJtVm5VdDgzVS9CMlR2Z3JmcTNqdEpCT0JuUGh2MW5kSC82TzJWZVE2MzZmSmJrZ25OM0c3Y1ovalJIOU84RGZkNlJWVENuNi9QMzVMRk4xWFFqNGYzYStJN0pkdTBIWDloT05PdmZxaHo3OG5vZzhZODE4QitYRUFQM1Bwd29OZkJTRVR3ck1abVl6cmIzNy9OUkI4RUpDL0NKaGpzUzhlNkkvVUY3MzBXZHVORi9SeDI4TUYvZmpvZktEdGg0cjU2cWg4SVNLZjNOZzZuWWl2RnZCRjRaNktuRUxEYW15cVhIa2dJNmxycHk3OUpxa2xTV25aVVhLYUR2TUN2eHhoTC8wR011STRYVjB1WDVvQVJKSC83TmhNZnFGYitPY21FRU9qL2QyaVA1ZVNNdDZUWUYwbXlqOVc4T2MrLzZaOTlmZlRRbnlVMkZmTE9zcXZDeGkxcjI3VkRFSy9XWDRVa0w5dllQN3ZKeTg4OUFVUU1nRVUrR1FTcm4vK0I5NExtQitIeU9GWXhNOHU2aVBiVFNGTlpwZ3B4NzVNSU9qSFJ1ZEhSK1lIaXZtb1hHS25LVnFNa3NIRks3cTZnZjVNQ2cxRzA2SnVnZC9adVZzYUtBSVprVjlPaHVhMTd4SG5kWDM1TnZMUjlyamMrQWxBdW50V0xJYS9seHJoUDRub0h5bjRuYmkxbjBuY1RxZmd0NU9HR3NHdnJUUktYaXNSWDQ3dWp4RDd2UmFlZVFsOVhBVHcvWmN1UFBnUUNKa1JudjNJVEZ6Ly9BK3NRL0FQQlhpVE8xQ1dmUGFqUlgzY2xCYlBHWUdkOWREUElPaURQUHhSWC9ya2xzd2w2c1I4djA4K25iajQvbU4xbjl2WHBQSHM0bEFCbjBUYysxUHd0UC92RVYvYkxNcXpEeGdqbzhrL2FYVkxCOUM5dVhUbHFOaU90S1ZqOFQxMkFyQUF3bjhxMFI4TGZpWHcrd1YvdTI4akJMOWZQWjNZOTMxbXlwaTRUd1JqbkUzb0d3RHkvd0g0d0tVTEQ1NEZJU1BobVl5TTR2cm5mMkEzQkQ4b3dGOERjQ0MxNERRSHR6cFJiMTk4dlp5SUQ5SlRoazJwRlJVZStxS2dMMGZuRjA3TTl3cjVURWRaSWE5T1FqTUorQjd4UHBGb3B2Z21PU2FiUkpTeTNkUk1BZ1pOQUNMeG5HMjZTL2kzMjAwNHJxNlVsYzMvNXlYNlE0RWJ2REhSM2xZTC9yYUVGc29tMTA4czNETmpjMWFlSVdMZk54VHVrZ2ttQTZsOVo0VFFkeTlCdjE4QzVHOGFtQjk3OHNKRHo0S1FnZkJzU1Faend5MGZlQldBbndUdzhseTBma2lrUGhEMUdaOStUWlRlZHpHQm9OZDlsQVQ5V0RGZnV1azFFZko2MnpnaG54a2hja0k5ZU1wdFIxck41di9UaXZlWnhYcHZkUjdlbHBjZXdUNkJuaDg5S1JnN0NXaEZZVzNrZjV6dzE2Sy9XUzVIKzVYb3p6UTJWUFNIeGFOOTFSdG5FUHpWMFgzOVB1aGZlc1YrS3NDamNxbzkzWGE5ME8vSW81OU1LQXdBK1M4RzV2MVBYbmpvMHlCa0FEd0RrbXB1dU9VRFZ3SHlveEI4RDRDVjdtaTkzYVpFNnl5aVh0UUNVdHZOMUlJKzBKNlRDUHBzK0R5TXpBOFY4MTFDUGh1Tjd4THlCUkUvVUlTUEV1MUpsWUY5RHU5eEdMeHFNSXc1VzNLR3RWNFN0d1A3SExwUFNmYWFEdkd2Qkg0WWdSOG4vUHR0UHBXaWYxNkNQOTZCTHNHZlRYMnB4aG5xL3dGaVg3Zm5SWHpjcCswdkZ1R3hmV2VZME5kanl3ajlST1FEYUo2TSt3OE16UC8rNUlXSHZnaENLdUNaaTFSeHd5MGZ2QU9DWHdCd2MzempxaFYxVHR4cGdaMTQ2dWNnNm1jVjlMRlFEaUxjNGJJZlM3eXFXOHdQczlpa1FqNWNtNC9JOTF0cVpoUHhnOFY3YVg5S3hmb0hNS3gveCt5Q3N6OE5Kd0VDV1RLU2taOXpwUUR2THhVTHhOcnVCMVRJaXYreHdqK1F4a1hSbjNhN2hhTGY1TWFnQkg4OCtFQUR4L3VYaW04My9sNHJUNGZZajI2ZURmdnJpdXFIazRJeFFsOS9oc1ZvdnZ1Zi9MNkIrZFluTHp6MG4wQklEenhya1Y1dWVNRUgzd0hnQVlGYzRjVjNYbWpIdWUyREo4bHFJUis5OTJXOThJMEZiM3JUYlRETGFOOUVOOFV1Z3FCUEppWmgyMUZYbWFoOEt0Z0hSK1FIaU9OcUlkOGo0SHRicVI1VFhqeFZpVzRlNFphUFNxMWNua3hVL3RFN1JIbnZsdG94amhUKzR5UCtjeFQ5V3lYNHM4SlkzTEllZ1JmSkhXSmZpKzFPc2QrT29SalZuMUhvUjVPSTJKK2ZGZnBhNVBzeC9nbUE3NzUwNGNHZkF5RWQ4UFJIaXR6d2dnOEtnTDhoa0wrYUYvWUFXZ0h2aFhGcXdjbUtlcmNxakxCM1cyLzZvdlR4UkdPTW9KOVd6SWZOVjRyNWFpRWZpZmkwd3l4ekYvREY5c054WmdYNjRDUFNiSk9FNGZDUW1XZXJQOStCL2NXYU02bGY2TGZvdCsvcGFNb0p3S0NJZjBuMCswRkZPajFaU0VULzFGSCtVWUxmZjY1NXdXK2lMa0pGSDRqNW90anZzUEJrK2dudE83VkNYMDlhMVA2NE52V1l3KzlTNXViaXYyV00rZUVuUC8vUVZEOCtzc1BnMllwa3VlRUZIendvd0U5QjVHM0FVR0dQVU16cmFMc1Q5ZllnUGNSNkkzbzFYS0ZBYzRzdWluZ2hGZlJ0SDFINTJhUHpYV0plblhCbkVmTVZRcjFUek05UndDZml2ZXBJVXpjeEdOam9aTkNLWDJiT3R2dGNqNFgxUTc5RDVTS3pUQUptblFBTUZmN0ZpTDhTK0duYVIzKzhpWVd0YnF2N1J0NWhVZjRoRWY1RWJBY2lQaExYZ1FoSDFHZXQyTStrM295aitwVkNQN2taTjlpbTkxa0ovcjZiY0tPSlFUc0orbitOTWU5NTh2TVBQUTFDSW5qS0lnbkhYdkRCNXdQeUx5RHk4aWlBamtZTVJ3SzhHSzBQeGJIMzFIZUwrckNlbmp6NHR0dWVZU005Z1lBZUhhRWZLK2FUU3AyUitjQXJYN0RYREJIeXZSSDVncEN2Ri9EaENUbjNRTEdLenJOdERUMEVVV1NUSE1NbkdIM2Z3ejRGYmw5NjJxbStBakM5OE84Vy9RQjB0TDhVNlErVmQ5cUVYVCtscmFkWDhCcy9kdDErc0tqcVpNUjRJdmFkeVBidFphUDZUcndySVo4VitxcE5OVzRUdk9yMjBqRU1zT3o4bGpIbXJVOSsvcUgvQlVJVVBGMlNnR012K05CcklQS0xnRm4xTjg4Q0NDTDJ6ZjlxaEwyMjRJUTN6WTRWOWJvZlJSRGRUNlBmdFJINmFhTHpvWER2aTh4UEp1YUhDUGxzTzM0YzhlU3NwOE9rZmtYbEJSWHJDem1vSGNCZ0JUNVgrblh5REJPQUdjVC8zSVIvRXUzUGlYNXB0OGVpWDR2bHVHb2tsTzI2cVNMOFk2UDdKYkZmaU95YklIcXVoemloME05Ryt2VStHbFUySFUrUHlIL2N3THoxeVFzUC9Ub0lhZUhaakRpTzNmcWhPd0g4R3hHNUN0QUNQQ2Zzb1lTdHFFbUFxOUpXQ0tQMWs0bjZqaWg5SW9Kbmp0Q0hFZXVvWjJoQnZ5Vml2bGJJMTBiaWk4UFFHeFpKdkk5c2ZERm5GTVF5MnVjenY4bkQrSWxBb2VKSThUOVUrRThYNlkrai9IYXNlYUdkRi96dCtwem9uMHJ3VHlyMmRWVWwzTjE3WmQreFpTS2huencwSzVra0dEVVIwT05VazRBdWthL0g1eHFSTHhxWU56MTU0YUhQZ0JCUTRKT1dZN2QrNk9VaThuRUF6MHVGdlJibnhxL3ZFUGJsYUgwNFdRRFNyRGRWMXBzdTI4MlVFZnJhNkh5Zlo3NURYUFpINWNkRTVJMGFYNmxTdk1FVTF2ZDBOUk9sU1V6UEJHS09vbzRzRDZiamU5b1VLSDFQcHZuK2RPdm8wdStwVnZ4M2kvNThTNlp6MTJvai9WblIzMm50S1FsK3Z5SWY1UjhhNGE4USsrcC9ZWE1sc2E5RWZDNnEzeXYwN1ZqaU1yRXcxNU9BYUt5ZDBYdzlYRFVCY01XQ3Y4VWxBL05OVDE1NDZMZEJMbnNvOEFtTzNmcWg0eUx5U1FCSFJKVEl0amZQeWdxNmhIM0pocE9QMXVjajlkclg3ZlYrT1VvZmlQcFkwQStLMEpmRXZOM214ZnZXaVBsd1RFSHBtU0x5cGNoaWZqeXppZmhGRk8wODFDMEg4L3NPREo4TXpENldzcDR1L1E1TnR0aVFpSDlZMHVSV1JsVTdONnFXdkpBUHQ0L3o4Z2ZkS2lWZUV2eURvdnU5dm4wdDl0WDdaREpSdHU4RVF0K0VkV0RpTnZTeUdtdFFQMzBkS2ZJdkdKalhQM25ob2Q4RHVhemhXZTh5WjIzOWUyNEI4RzlGY0dNam1pTlJMcWdROWlVYlRtVHRVZStIaS9wU2xINkdDUDBNZ3I3V2FwTVY5Qmtobnk3RjdSbzFwbHpodUJXVFdkZlIvR0NpeWhMdnkxaHhWREVvSHJXSXB1cXJOdXo3V0p3TVREUUpxQlArcFVsNXVEb2I4WitueGFkTDlOZDYrVHNGdjBHVm5TZVphOVNML1hBTVlaWWJWeUlXNVlrQVJ5REEwenJweE1HWU9LT09DYllCRWswQzFMWWVYMzcwZWYraGdmbkdKeTg4OURtUXl4YWVLaTlqMXRhLzV4aUFUNHJJZXRabjd3UndKT3hkUVMvc082UDFJbENOUlcwQ3RhSStKOURiVW0zN1F3UzlPakYxQ3ZvWnhienFmbWhrZm9xSS9PS0krSjZCOEVoRXRvTGVyMno5ZHpxWkJFeDRCU0RyWVErb2pmaDNqOUhFNytZaytFMW1YVjd3NThTN0Yvd0dtOUhnYlJ0eGRMOVc3R3RocmdSNVFaeTdHaVdCcmF3MmpWamZSQ3ptZzdyUmhNT05wV1RaY1FPdkV2bG4yMGorb3lDWEpUeXRYcWFzclgvUEFSSDVkUUN2YU1TOEZlUGFqdE1mc2E4VjltRm1IYWh5QTBTOVhvK1Y5bzBYOVVNOTlGVVIrdEdDdmlEbWt6Yjd4SHhhdGxCd3BKaWZWY1JuT3QzR293b1BhRHVQOFRKNW5wMTNqMnBxOGQ4ZjhTOGRKL3hpamVqUHl2OFpSUDh3VzA4Y1dmY0x2WGFlWU4xQXNSK0o3T0ZDdjMwTkJIZmVuKzlFZTl5V0Z2ZHh1K28xWDY1VDVQK1dnZm1HSnk4ODlDV1F5NDdkMnowQXNqMkl5TitINEJWV3REdVI3Y1M0anVMSHdoN3RSQURwOW5ZZHNLTEVkUnF0SHlycVErdE5zQi9SaWo1QkgzUUFZS1VRb1k4ajRYVmlQbG5LaXZseTNYSmtQaXc3VE13UEVmR2xrM2JjeHBEK2h6TytlVXI4bllhTjNZNWg1c2xCOGVza2hRN3NienphSUxwRWRNeXFFUCtsMzdzeHVRMWFWTnNEb3ZISFA5V0ZnUW1PUTY2RUUrR0lQZ012Sk9OallpQ2s5WEZlNit2NG1HNE1JQ3V3bVdqRTJPTzFtaUFFTVJoOUxhRGRJeU9BR04rRytneWl2WVlQQjZsUEtKbURDSXdZaVBxTWJDdEIvVGcySkkzZ2RqMGF3TmhBV0R1aGlUNHgxNXBwcWpmbDIzYU5lMjNPdTZiZFR6SFNsclBybTcrRmFUcHZ0dnRHWGlHUXZ3L2dmcERMRHA0TkwwTnUvSm8vLzI0UitTa0F6UUdoRmV0SkJoeEoxMlU5K29Hd1Z4T0duTEF2Wk1McEZQWFZVZnFjb0I4WG9hLzF6cGZGUEJDY1ZKUG1ja0krN1hONFZENDNpY2tJamxLOW5sVWpSek5weWJEYXRzWjN5WGFRRmJWVkZTY3NOYmFoc1pIL1dTUCt1ZVBNZ0VqLzFGSCtVb1MvSTdydnVsSFIrbkJvQmwxV0hoM1pEMjdRamFMNndhWWdXdDZPSmJEaCtIM01SZGtUMjA2d0RXazBQNHJBaDc3OG1TTDU3N2wwNGNGL0FuSlpRWUYvbVhIakMvLzhTd1R5Q0FRSG5XQjNPbDJjYUErajlrM2RiRVMvcmVmV042djllb1R2dy9hQXNFS2xxUGZGb1VYOUxCNzZTUVY5dG9za2JoVDFueDFXZ2Fod2NBL0RRQ0UvNHhHZ3YzcGxCeFRxWk41VVR3ejZ2NHN6ZjFzN0JYaXVlRjVzVHlmOGEwUi9hUXk2Vmxudzk0bjlwbHFINEsrNFdiZnVSdDJ5Mk5jM3VPcHRSdGZ0RlBvOXRoMjNyTHo1cXZJZS9mVUFBQ0FBU1VSQlZINHV5NDZiRU5nR2t3a0VvcmF6SXY5cFFPNjhkT0hCM3dHNWJLREF2NHk0OFlWLzRhQUFqMER3a2s2dmZXdDdpWDMyVnVBSEVYc25yRjMxckxBUE0rc1lWWGlNcU5kOTlJajZHUVI5R25UWGE0enFQNjJyeTZUcmh3aDZWYkJheUU4bjRzdFZGMG00OHpCMmVUSG43OVNNRTRHdEZQOU8rSS8wK1BjTGZyVXVFUHR4bWJDeFJQNVBJZmo3b3Z0RnNhL0h2cW1XdzNxekNYMHR3blgvWHVpSDBmeXdqN3pJVDRWOGttR25WdVEzaTc4RDRNNUxGeDU4R3VTeWdCNzh5d2dCL3E0WDkxckloNUY1cjhXdHo5NUg2blBDdm16RGlhUDFZZWplM3lpTHBKNTk4VkxiSURkeGFGQSsraUVlZWduTGxhUHpKdHd1Y2VsQzlFdTNYYVVaK3NSODdvUTRqWmdmTE9Ubkp0d3Axa2tmUTc4akE3K3J0ZC90d2tTZ2EvSmQxWElhV1NpS2ZuL2MwMXZFcitpSjlzZkhwVTVQdjAyZUVIYld2cGpndUNoQjN4SjlWS1p0THV6TGlkTGcyS2Y2YUlOU0VoMTdiUlRkUG9peFdkYjNkZWtwaWNCNzlsVWZkdjl5RXhHNFhXOFhyQ3ZmOWlkeEFyZlVQNC9HTzI4L1NpUEc3WnNSRzVJeSt0T3pYYlgzQTdUM0JkZ0poVWl5cmV6Smg4MncrUklBL3llQTk2ZDdTWFlpUEp0ZUp0eDAyMS84QmdEL1hrU1V3MFpaY3RxRGMrQzFWNksvS2Q2ZU9QUmtvRzNIYjlmdEtHSHZOTHR0STQ3V3g2SWV1b0ZnSEw2bGdWSDZVS0ZYQ1BxNFQxMHJIOFVhSEptdjlzcEw5dTNBM2dadGFUWlBJZVFYNHpBakN6SU9rc2NVdi90YnpZemo2TDBDTUhIazN4UVgxTnBFeVEvcU5ZNk9OeFFDRzBHa1AxSzlTUTBUcjFERnN5dFZUYXU2N2ZxQ2xhY1kyZmZLTjRpQ3R5STZHRVBzMHc4aStqYVNyc3JsYkR0SkpENnk3TGcyTnNPckNybG92ZW9uamZMN0R6U1RpdE1BZU0ybEN3OStLdjF3eVU2RFo3ekxnSnR1K3d1N0JQSVpDRzd2dHVRMDVXM2FURGNKMEdYdHV2YlZsVmV2ZVJ2T1NvV28xNUdpY1BKZ0M0cmFIak0rU3E4RWZWb29LRE5PMEd0eGJ2ZXQ3OFNhRzBzOWFiVkNRek1MK08wNWhGQ3NrKzJiRU14ckFwQzJPN3ZvNzI0aGIvSHA3M1dRbDkvb3Y5VTR3VC9vWnQyQzJGZTYxNzBKNXprWnI3NXVzbTB2RlBCNmZGMjJuVXJMamhidXVadHZWYi9aRzIrRGNZZDJIelVoK1UxQXZ2N1NoUWVmeTMrb1pLZEFpODVsZ01qS2h3RGNYb3JPNTIraWJRNktqZmIzcWNmc3NpdXZYcjJ3dCs5MXRENk04TU0zQTcwZ2JYcE50UUhoWldnbDFtZTAzVWltZkRFcWxSdHpsbFRNTjJ1RE0wbHVkSU8wOHVDSS9FeENmaG94VFZGT3BtVHE3MVA5aEdGY2hONVhMNG5WMHJROFg3NnpGMG5lWkNvWXhCYWZXbnRQbmJXbmJWaFNXNDlMNDZoSDZZUzVIclpwWXo1aCs3R2RSOVFRVXl0UEcyNnl2aGtYcGJmVjdWOWVHaHNOQUNQTlRiRGg1eTl0cThhdHRYY0UrSkNXYnorMDdiVHJPeTA3d2JQWjNYNktpQ3Z2SG1acnl4c2dTS0haL2kzc3VzWW1aTnArWEFEdGRoanpJUUQvVitHUFJuWUlQT1B1Y0c0Ky9yMUhBUHllQ0s3T1czS1VTQzlHN2NOMGx6Nnk3Z1cvanRoN1llK3FRRWVrSlh6anh1UXBSK3Buc2QzTUowSWY3S1JhV3pyOTVzYlFUK25VbjY0ZUsrU25QUlJRekpObFovb3JCQ1BibTJmRXZ5ZlNQOWJhVXgzaGR5L1I5Z0UzN0haWmVib2orM0ZYcVgwbnZpazN2b2sxelhwVHN1MWtvdmt1S3Qrc2QrUFM5WXFSZk9UYnRGRjdhejNLUlBMYmVsOEFjUHpTaFFjL24zNTRaS2ZBQ1A1T1IvQlhCYkc0OStJOHpaQURKZHJEVjFjdWVJV3JWQ2ZzZFZrdDRnZEU2dVB0cWwxUGM5RFRLVDNEMGpORzZKUG9mTzZFTjF6TXoxZkl6eWE2RjA2ME03WG01Y3ZvWFBqMURQMis5MDhJK3RvcjFKOHg0ajgrMHE4aS9LcFlQc28vSnNKdmo4MHErT0tpKzM1TUV2U2piOWhOby92ZGtYMjdyaG0vRmRUKzV0endMKzRpOGtZeUVmMXdmNEkxcHVuZnRKK2ZqZWE3Z0wyTnVyZDFmRDlvUDEvVGx2Zmo4WkY4WkcrOGJZTDBiWnRpOXcxdEJCLytwbHZicCtBYUdQd1FnTCtVK2NPUUhjS0NuYkhKbE56OG91ODlJcERQaWVDQWk2NnI2SHhzeVhGQ3ZsM1haY2VKSS93bFllL2ZHeS9zMWJjdUw4N0hpL3J5amJIVFJPaXJib0xOTFBhMDN0SE9VQkU3elU5NjRjUjhEZ3I4eTVzdEVQbXpNTjBWZ0lIdEpKL0xESkgrWWlRK1h0c3QrSlB5blJGK2s2d3UzYkFieFBuN0l2dUZxSDU0RVNQMTZudVB1NDdvKzV0eGMvNzg1RlZIMElPb1BBQnMrb2krOXZJWEkvbTJiUjNKTjRYMWZoOHlmdnd2d1poYkxsMTRpRkg4SFFvaitEc1lnWHlmQ0E0VXJUbGEzT3YxUUJMRmh4TDgyajdqYjU0dENIc1h4SGFkdDBzNmV0K3U3UkQxRWhaczM2Z0x5TUVFSUNmb0pheGFwQ1RvVFZxbXNOalJhbitsUWFKMW5NRFpjdkZPSVU3bXdUeStWeE5PR21wL1orTWovNVVSLzFraS9ibGdTVWFjcDE3K05nWHlsQkYrTGZhRENIMGovbnNqKzRXb3ZtdkRSY2lOMzAyVmJyUFoxdmo3Vzh1N2pqUkZFWGsxRkh1ZU5jWkY4ZFdldzVnVjc4dTMwZmpPU0Q3VVZZRzJqTzFiOHVrejdXY2UrZkVQQVBKOUFFNW5Qbnl5QTFqc0VBZ1p6Zk5mOUpldUVjSHZRK1NxdkxpMzRoMnAvOTYrOWtYdFhYdnRlbDNHUmV6ZFNsUUorOTVJZmM1TDc3ZEZHNmFQMEM5cFpINWJJL0lVK0dTWjJLWXJBN05IL0tlTjlBOXF6U1J2b3MyelJQaTFaQTZqK3lYdi90RElmaGpWOTFGeDE1YUo2cm9vZUJ4cHR3MllhQjNTTERtMnJxcm5JdmZWa2Z6TnNKKzIvZUNwdDdydFlCOE1EUEJGR0R6LzBvVUhud1RaY1RDQ3YwTVJ3YnRLNGo3MDIxdHhuN1BrNktnOXZMQkhWQjhJeEgvYkUxemtQNGp1aEpNR1BXQy9OVnpuVGc5SmxMN1pwaXBNRzZFZmNKNmZWdEFQRXhoekYrOExKOUFabHlDV09YdzNaL20renpBNW1EM2lQMjJrUHc1MmRINHFTYkJGVjVndHdoOUc5MVdNWEhMZS9mckl2dmJyaTl1czI3WFphM3hFMzJmSmFhdWFGUmpaN0lubXg1bDJ0Qy9mK0RadDFwdE1KTCtwNlBjdGpPUWJ0OW5haHBwb3ZiUi9ZN3ZmOWtLRjllTUxBSE1WQk84RThCTWdPNDZWN1I0QW1STWkzOWtsN2h0QnY1S0krK2JGbG9XMTVMZDEyaFNXZHIzbzltMFpQV21BYTFkUEhIeGFUYit0YlJhNlU0RnV6MVpJZHRSWHlaN2Y3SUJYQUZsUnpjYzNrT2tkSzNTVmxsWkZvelZpd24vVkxkV2Q1RVg5UjhqbHk0SjkvN2RnTWp6OGQxOTVmRW1PV1dHOXdVY3Fmd0JQYXRqanJ6dHV0OGZuWE12NitLNnZGZ2ZsOURrTFFLTm8xWHE3QjFGd0s3eDZyT3ZiYzF2aFBCbWNTMWY4T1UrL0luZTEzUGRqMi9UOXhPZFZmMDV5Z1RRMXp1UURjbjM0dnhmY2Z1cy9pUC80MmxMZldmNGprbVZtd1k2T1pBcHVlZkZmdmtWRVBndDNYTkFIcEp3RkoxNjI1WXcvQ0VXVEJWZlB0cVZXU0xBUnZrMjMwSTdKYjJ6ZjlObHYxQW1pODVzclFhSFVkaE9QcGJlbHpqWE42cG9UKzdDZjIrVGlmY3NqOFR5OGtHVmxpMzhyYzdBRkRiZjg5SlN2VE5mWjIydFNJSzdmOWxOaDU4bGJlWEkybnJETmtvVW5zTzhVclR2TmdvbGUzVTI0YW4yYXBySzEyYWozcVFWSDFiRVdIbVhuU2UwOUpoaWJNWnQrVjRPeTRWaVUzY2dZbUZzdm5YL3djOFVQbWl3bGpPRHZRRVRrTzRyaVBoSHo4WEkwQ1lpaTlqcXlnVGE2WWQ4N1NhclVkeTVpTDdxY05BZFFjWDI3UWNWN05TQlNieU14T2txdmRrTDhZdkV6ZEpzbC9CZEh1WW9SZXNuODY0ZVJlVUlXZ1MzKy9jMWg4ajE1cEw5NDdBdnI5Ujd4a2tOaldFTkg5NXZqZFQ2eUQ3czVDandGcjJMUFFTNnU1TTUzYnJTbHFINHVvcSthVDgrdlFCak50MlB6L2ZtK3hiMzM3ZnFyRUxaZE4vN2d2T3ZPdEc3TThkVUFmeTcyWXcrVFlRQXE2Q1lDZkVmcHowV1dGM3J3ZHlLQ2J5MktlMWlSSHg1VXRJQnUyM0RpM2wwcVJMd2Q3bjlpTDRtNmN1cGdyQ1A3YnJua3E2LzExQWRIV2FSZWVrbUs5clNVTHp3SDcvenlSZVk1MlNDWEkyTys5elA4Rm10K3h5TWkvWDNIbTNwUC8zQXZ2MlRxWlZzUjljYm8xZlhlZlgydThMNTllMDRST0c5OTdOZTNrWHBwMjR0OStsYWNHNmlNTnRaSmJ5UG5BcHZidm1sVDJvdzV4dnZlYlYvMjZyZ3IwL3J1Zy9hdEo5Lzc5K0U4K3lzdzJIUi9WKy9IaDgrb0k5YVBiMGZhbnFWVlZoM296OWJJdHdMNDBkeWZoaXd2UEhQdk1GN3cwdi90aUFqT0F5SjVXdzZpNVZqYyswZ0Vrblcycm9wNHRPc3MvVmFjT0ZlOUZ2WFJKQ0xCejBDS3RwdktiM1I4Q3ZLTHRTZm9ZVCtkdVVia0tmQUpXU0RtL0h1Y1U1YWZ5UzA5cmxoNW9sRFZRbUxEMFV0VytadGlhOTUxbzIyZTJuWVRGalRSaHFKdFIxbHRkRDgrZzQyMzdBU1dIRnVtdGVQNFBQYXgxY2JBWjlQeDlaTnNPVHE3anE0UDMwZHM2OUg3WmJ4MzUvcUw1L2xrMjUwRUkvZzdEQkY4aXhYMzl2cGlJT2JGaS9CRTNNZmlYVWY4YlJ2Tkt2aW9mUzVpYjdkRE5XVGNPSHdoTCt4ckl2WHBFMlByUmYxc2duNmJ4UHpjaERzRk95SHpZOGp2YThSdmZJc2ovVE5uN2FtTThCZjNTcUlGSmRodG9NZllxOHdka2YwMDE3Nk42dnRJZlRQY01LS3ZJK1hkMFh3VmJZZU5xUHNzTzdaODhGVGFKSktQS0x0T3MwdnViR212Q3JRZFNQdHhxcmkvZjhLdHNhTnZyaHE0eG0zZDl1TnFzK29JSUhjQitDZWxQd05aUHVqQjMzSEkzYUVsQjZHNGQ2dTZ4SDBZMlcvS0syOGhmQjNmRmdEVmpoUHpZbGY3dHRWWVExdFF1QitJczk2b1RsemJwWE9NUlA5OFBSUCtLMytPNk93Z0tVM3ZQQ0ZrS0hNNlhrd1lIQmp2NVM5dGpvL0I3YmtHbFVkZFY4aVh6bWJsaVZyeG5uaEUyN3ozM1o2M0VvOCs0TzJ1dG93ZGpLN256cG5hQ3JzU2x0SG5UZGV2T21kTCtIbXIzZlNmVW5CTzEyVkZqVTEvVHVyY1gvNms3Kzc2Mk1ueVFUV3lnN2oxWmQrM1MwUStEOEcxL29hYkZYY1FjQWVQR25FZkhiVGN0bUxVdnRhS0k3NUlnRUJ2U0ZOWW92UGJtbTZLMXZTSytYNFdOekxQbnpFaGx3Y1RIenNtdFB2VVczd0s1V1o5OEpaSjN2UmFlRkw3anJhdCtMcjl0cDN3MWI4WTEzWFdyaE5sMVBIdjFUcGwwOGxuMXRrTUxEMDFXWFZzR1RlK1pwOHV3V0QxNHZrSE52cythckljTUlLL3M3Z1RzT0krbk9FUEYvY3FFdEFsN2wwYndMaUl2WTVJd0VWaTlQcXVrSTdmRkVVbEJtVzVLY1BJUENGa2NaajRPTFF0a2Y3Q2NYZXk3RHk2anM3SWsyYmo2WXZvV3krTEcwRlhOTitkYzNVUXF5ZVNIOVcxNXpJM0pIWE9EdHBTc1RNM0xuc09EYzdoVVBYMWl6NC91MzIvRm9KWGxUNWVzbnpRZzcrREVJbnNPZnFTNFdCeHJ3NUV6V2I3ditEQTVqYzEwUThmMWZmUkVIZGdDa2VyNnR2b1NuZ1F5dTVqNWwyejJIZWk2ai94ekN6aUdaa25oTXlkbXVQQ2dHUFJ4SjcrZWk5L1hHNUM3NzZvTjIyazJtWjZNMjZkcjIzUFQvRlRjOXZUV3V2eGg4dUNZMFB4N3Ftd0lzNjdiNFc5OCtYcmJEZzVUMzdUY1hBKzlYWjVvenoyYlZ1Mmp2aGVZRGJiOWY0ODdIUDIyN0x3OWFYMTZnUE4yUHkrM0EzZzEzTWZLVmsrR01IZlNZamM3WFR6ck9JK2lpNDBMNzZjaTJxb2NrR2tBQWo3VSt1Y3QxN2RKT1dPUUlYemlOOWtReGhESXZUbGt4TWo5SVNRbmNmRXg3TUpnaGY5eDltZVkzYUZkNy9jckQ2RGxMMzZhVVRmbmcrQnJtaStyZXl1UG9zdlV4UEpENTlVNjgrcnJoMDFQbmNLOUcvZ3JMajZ5b0lhcDlvYi9ULzFkM1YxNk1QZlFWRFY3QkRXWC83OVJ3Unl2dEhxOXViVVVLVG5IcUtSRmZlMmZQdmF2TmdEUWx2SGJZdWo5dTI3NUp0bHgxTG5yWmZNdTJaeHZKZWVFWHBDQ0FFV3ljcy9MKzkrc1ZVVGw1TnM5aDNBKytoaDQrYlcyOTdXQ1QzM0pxM252UERSazIrMUp6OTVlbTJjUGhNZGZueWZPalAvbEZzQVpsT2x4TXlWVTMwRHhoaHovY1hISG1DNnpCMEFJL2c3QklIY0JRbHozME5IRm56SVFzM2c2eVAzc0ZXVXVNOUY3ZnNpOW41ZFBtSS9XNlMrOC9QcDNFNElJWmNQaXhQaG41ZDN2M2hXY0J0c3VlNklmdENLUFVlcWFINXludFQxVkFTK0dNa1h2YzFIL2RXMWduYW9FcHh2ZlFSZm43dmpjNTFSSGJRQk9iZEw5aHdjUlBFRndGMjVqNDBzSHhUNE93V1J1NjMxQnZDSHBPemx2K0FoVnVGdjNTL0g0bDRkaGpPK2ZIZmc4Z1BLQzN2ZFVWZzZMK3p6T3h2VVNMZW0vMVZSZWhSN2Iwck5ydkYxL1NPRWtPMWk0bVBVak1mTzNIRTdmK3p1R2VOSW9kKzhzMTc0VUt6SFFqOHI4aVU2MzJxUkx5dkJPaS95bGFBUHpzZGF0SWZuYjllT2FzTk5JdFNNSVR6M3grMXAyNDc0TVRYN1Jwdk9Eb0VxWXdmd05TLy9nWlVtUGFZY0RxdzU0bis0VnZ6SFQ2ajE2OFBYNWtXTGU3dGVwNzhNRDRLZXR2L1lYNTlCNG5lZG9yN01KQkg2eVN3NC9Ga1JRbllLRXgwWFowekoyVy9sNmJQd2pMWHVaS3czYmpteTY2Z2JXN1V0eHR0dmRQcEs1OVZKckRjMVZwMm0zYzJzWFNlMDlPZzI0ZE5xUXBVTjdUb1hqVEZITGo3R2RKbkxEaVA0T3dHUk95RTRySzA1Ym5ZZWlIdEp4VDFVRk1GV1FJZTRsMUNzaDVZY1FSaTFkeUdHZE1qd01aT21UQzdTMHgxSkduMkQ3TndqOUlRUXNsT1k2RmczMHpFM1BONFBpdXlQaXVpakdNMzN5MjJVdk4zZ3ptYytFaDdVS2FldlZBRXpIWGwzVmgyNzk2cTRTREFXYmRjSmRJRCtHRXBSZlBIMXBmbWJIRWFUY3Bzc09SVDRPd0FCN282dE9jRVAzUjF4ZkEydjM4TTcrcHVYRG5FZkhOeWlVZVNpOXRHUnRGL1l6MG5VRTBJSW1aZ1pqOE56OWU3UEl2UnRtVGlIZmlyeTlmbXpLUEp0T3M1d2MrckhEMUpMYTZHdVJYazQ0WEFUQjlldTZzdU5XWFdLOW55dUIyQS9IMStlTnAwZEFBWCtUa0RrSHJHQ083a1JCLzRBb3FJSTRSSEJIano2eEQxZ013b010ZVQwQzNzMzJuVDNob3I2bWIzMDB2T1BFRUpJdzR6SHlnbTkrOTNqaS9xckVmcnVyR1dqK2UybTVQeFhGdm5RNi9WcjIzNlhIOStQQVA0MG5UM1BxODljMUhtK040cXZOWUtld0RCZDVrNkFhbVhKZWVFcmYvQUlSTTRMUkdML2ZkbDNyMzdrU3F6M1IrNzd4SDFlMkFmdktrVzkzenJpS3pxemw1NC9DMElJbVlZWmo4Y0R2ZnVEdmZwOUhuMmp0MG5neXpjbUttZ3QrSkVuMzZYUWRLazFXeTg4Vk9yS3dLZVAwRWNmcE1OVUh2ck4wTHVmZVBSSGUvR05BWEQwaVVjLytualBoMGtXR0Vid2x4NjV5MnQxUFh1MzBZa21XcDVHQzlyYThlRXNFZWdka2Z2WWI1OFY5NldJZlRuQ1V4MnhuNXVYbmhCQ3lEVE1lSXdkZUl5djkrcEg3WmNpK3RsSWZoRHQ5Z1VGQ0xMcnVISStlT2JLcWZjdTJKWllkV3ozVVZscDkwNzUrUE5SZkg5VndIODZ6Umh6WG55MUx3S215MXg2S1BDWEhjSGRQb3F1Vnh0MVlJb2k5YnE4dHVhSTI2cTIreGJqZzFuSmtoTWNKaXVGUGIzMWhCQnl1VERqY1g1QUlHY1dvUjhXdGV1N1JYNWZudngrUDc0WDVZR1Z4cFhOM1hCcnRMWjNJdDcxNDNveHZsQzhmNjVsZDY2blRXZkpvWnBhWWw3NHlyK3lJb0xQaThoaGI4dng0bDNmaWU4T1BEcGE0SUlLUHJwUUplNWxwVlBjKy9YZGRwekJZbjYwOVlaZmMwSUlXWHhHSHVNbnNmSGtyRHVaa3NhMklKMTJuVENGWnNtcW8rMHpVQmFkNkNtM1poT05peVpNb1JsYWNveXFvL3ZjVkUrMGhYcXZ4d0EzVHQ4T0xnTG15Qk9QZnBUcE1wY1VSdkNYR2NHZFVPSSttS3NId1lteU5XZXd1TytKM1Bzd2dpcVRpZG96VWs4SUlTUms1SGxoUk1yTmZOOVJSTjlmaXc2TERZbmsyMHFTUDkrRzlodjdObnJLcmVpemEzU0Z3VGRaaU9LSGRpRWR4US9YNjg5R0lHSU9BL2o2ekFkRmxnUUsvQ1ZHSUhjSGdmWDRBS0dFZlZzK1BMRDRodFM2ME5xVDg5eUhsZHdTbkxDdjhFaDJGeGpyclpmQ1AwSUlJY3ZCeUdQNENLOSt1WC9WWml5b1haRXVrVy90TWFtUWp2MzQ5blJyeXpTcmRZRE1ydmZLUGNpUzR5WVQ0dnRVU2o5T3R6a3daU1p0T2tzTUJmNHlJMDMrK3pnL2ZmT2licXdGMUpUZXpnTFVnVWJON01PTU9XRm52Wkg3U3E4OUlZUVFVcy9JODhaa0lqOVR1bFBrdTZpYU8vOG1nVFhBMVpXa2JwajlUcEx6clc1VGRWZU00cHRrVHdWNnNxQ21JT0ZPVXVBdk1WUmJTOHB0dDU5YUZjRUZpSWk0bVRuYUgvMksrdUhhaVg3NFFLdGgxaHdiaFVpejVaVEZ2VjZxaU5nUGdsOWJRZ2doQTg4ZFBWNzkxSEd2bGxVNlRaTVVzWjU4YjFmM25uenZ4N2ZwTUxVZjN4aFZ4dnJoa2ZIVXEvVTYxV1hPaXgvVWhRRTJ2UysvU2EyWit2bVRWSjBHQURZM2pjSFJKeDc5NkJQOUh5NVpOQmpCWDFZRWQxbHhYNDdlZTBFZlIrOTE4WDVyemh6RlBTR0VFREtLZ2VlWHdSSDlYQ1MvVk5mWldoVEtxZ09FLzAreTZnUW5iZit2SzRxZkc3RXQ2NnNIR2lCL05TQzhldEM4R0tCNWhDL1RaUzRwRlBoTGlnRDN1UGZxQjIyOTkvcUg3T1YvZEdPdE9qajRkMTNXbktELy9LaWltdDA3TWRaYlR3Z2hoQUNEencwemkveThWYWQ1NzhlUkNPWWdkYWF1cjYwMjZwenNxaXJQRFVJdnZ2L1hYbVdYOExNSXordTVtMnBGOVpsdWJjZHhEOGhTUW9HL2hOeDIrNmtWaU53Vi9oelQ2SDJ6ckg3QWhSdHJ3d05PYXMwSksrakRnSTdlTTNKUENDRmtPOWxla2UvOStPM3E0THdxY1lWb25UcWJCeWZsTm9vUEU1L0MxYms0OXRobkxMYlZOOXZxejBBQXlGM1hIYnVQV25FSjRSOXRDUkhCcXdGY0M3RVB3MEFTdlE5L3BMcHVOQ0VZWWMzeDIvTUh5YUs0cjg1d3dJZzlJWVNRTVZTZU8zck9SZU5FUHRCdDFVRWg0QmFuelhTck0wRTBYYjhWL3lxaTd4NTg1YmJabXQwMzJ3WTJIcmZPQU1CaFFGNlZmRUJrNGFIQVgwN3U2Wk85L21EUkxoV2o5L29TWHRpQ3MrWkVVWU0wY2k5QkxVSUlJV1Q3bVMyaTN5bnl1L3Jycytyb0dra1VYMThxYndOdnBiejRvczdKME9meitHcUJST2Q3MWJmdUxyME8wSll6dE9rc0lSVDR5NGpJVzRKTGJtckdIYVN5dGNVejN2dUdVdlJlVHdqcUJYdHY1TDZqSmlQMmhCQkNwbWRBUkQ5YnV5RHlCMWgxR2pLNThaTXI1bmFvc1JlLzZ6NjRTSnFyT1liRXUrNGkvZUg1M3JkZzBuRTFGU2p3bHhBSy9DWGorQjJuamdGNHBWMldRS1Ezci9wU1gzb3BNQmU5ajZqT21rTXhUZ2doWkZtWVN1VFg5T1N0T21rVVB4eFBkeFRmcmxHUmVPV25EK05qOFlPdkpLamQvV1JicUVzQ2Fxek5aM0w3ZGNkTzNqRDRReURiQ2dYK3NpRnlkNXdhTXgrOXoxeUthN2MwaEJPRElIcWY2N1p2V0xrUzFaRjdRZ2doWkN1WVF1VDNSL0dUK2dMa3ZmaHhJUlZsRDhiYm51ZGppNDhySWNoYmJYWDk4TUdYOGMyMmt2eGZoUXpGOEtGWFN3WUYvdkp4RHhCZGZzdEc3OXYxZzczMzZnQ1MvT2p6MFh2Njdna2hoQ3dQNDBSK1YzdlpGb05nbk8zWG5vakRjMmsrTDc0S3dJMjkyZFlIL2xWNTA5YU9uOUpydDlsdXRBaWdUV2Zab01CZklvN2ZjV3FQQUgvS3IvRlJoRndFUHMxZm40dmVEL0RlMXg3MEdMa25oQkN5MEF3WCtlVW9mclJWN1BJNEw3NHI1MDdKN2JtNjgyYmI2S3Arc284NnFKZTVvaDlNRW14L1FSTWIxeDA3dVR2NVVNakNRb0cvVElpOERpS0h0QkRYczN3YkZlaTZVNzR6ZWw5TWk2a2o5NjRqMVQ4aGhCQ3liRXdVeWU4b044U0xIeXdsRTRPcWdTUjdGR2JlMUpNS0wrakRuUGpGVmcrSm1OZU5HQlRaSmlqd2x3dHZ6K204dWJaZEh6MVlJNDR1Sk5IN0RGMkhtT0hpbnBGN1FnZ2hpOFN3YzFJMmlnL0ErdkhEVGFXMmpYKzFKMkViUGMvMTVZUHFQcWhubyt6Wm0yMEJkek91YThDL0RMUHA2QjJpVFdlWm9NQmZJZ1M0SjdtMEZ0bHovRTgwVG8wSjk2TnU2UGZlK3czNTZEMGhoQkN5L013aThpdGFLdVRGRDIrampjL1ZWcFNYYjdhTmJyRlQ1ZlFJNHl2dXNUMG50ZWwwWk5PaHdGOGlLUENYaE9NblRqOGZJaS9STjlmcUo5ZjY0NGY5a1lhLy9ERE9IMGZ2b2NvbjZyNStrRVh2UFNQM2hCQkNGcG5DT2FyWHB0UHBiV2xmY20wWWRjNVdWUWJmYkp1K1MwY1VwY1hXa2Z6MnlrRmZOcDJXbDY2dTNYZHpabWZJQWtLQnZ6elV6Wnlkano1WTJiNmF3ckdvMXA0VFJ3SUlJWVNRbmNKWWtWL1Jwb3FvK1NoK2V5N3RTcGtKZy9EY3JjUjZUMDU4dTMzMmJEcEJjSkJSL0NXQkFuOUppTzA1dzNMZkErTnVyaTJOcFZiY00zSlBDQ0ZrbWFnN1p3M0xpdzhJSW8rKzNaZ3I3SmFNRityQmRtL1RpV3ZubysrWnNmWmswOUUySFhIcmFOTlpKaWp3bDREakowN3ZnOGdiZTNQZjk5aHozSXJBbnFNaS9tRzF0aktmV2tzSUllUnlZb3pJcjJpdmtESXp1TmtXVVhETzlUUEFwcE9KMVEzTnBwTXo2TFExM3JpNmR0Kys0cTZTaFlFQ2Z6bjRKZ0JYQkd2RXBNZUtVZmFjdU53SWV2UGVFMElJSVV0TXJSZS9JNG9mcklwdE9uWXBzZWtBMXFhVHUwRTNhOVB4eFp4NGR5djFoZlZ4MlhRT0F2S0c4dWRBRmdVSy9DVWdhODhKcHRuUkRUUVlacy9KOUlkUzlKN2VlMElJSVpjbE0zcnh1MjA2cGF2bFNyeG42blhiZFBJUHZmSnJPMnc2emg2a1dxVk5aNm1nd0Y4R1JPN3B0dWVvOVJQWWN5WVk4TlFORWtJSUlWdklHSnRPUnhUZkZTblpkTUp0VTJUVFNkTmhSNEpmMUJpempnQy9JZHI4RnBDRmh3Si93VGwrNHZRTEFYeE5UZG5COXB5dTFKaTlqK2ttaEJCQ2RqTFRuL1B5VDdidHMrbFlDODJ3YkRvU3ZkZlpkQUtiam5VQ1ZEL1ZWcjVtZGUyK0Y0Ny9GTWhXUUlHLzRNVDJIUHN5U2ZhY2ZIKzlhL3dtZXU4SklZUmNSdFFHdndZOTJUWVcxZkcxOXpIWmRHSmJiOWl1bHhBbTJoS1ZkSHBEaXc0RE1GM213a09CditpMDloeTR5M1gyVHphZjdEbk5Na1U3SVlRUWttWEFPWEtZVFdkc05wMnUza3MySFJmYUwxeWRUeWNVMFJ5RkFuL0JvY0JmWUk2Zk9IMEZnRGNBZGdaZktOaVpQUWY1ZWxNOHVUWnRkTWI2aEJCQ3lDSXg5SnpXNlc5SkZzWmswMGx0T2pwYXI4cEx1MFlIMy9XVjk4Q21JODdxVTJmVHdSdFcxKzY3b2x5S2JEY1UrSXZObXdDMCtXYjlwVEZKZnR5ZTJKNFRSQWI4aG14blhmWWMrdThKSVlSY25reDUvaE52dWVuc0k3UGNaZE1KckRUdHNydVUzMmdGY1RZYmErM1JOaDJUWFBYM3k5bDBtZnNBZVZQdFhwT3Rod0ovZ1JHUmU3VDFwckhuYUt0Tk81dHZDcXVLOFh3K3R1ZWdiTThoaEJCQ3lDQUdaOU5Kc0pINXlFOGZaZFBSN2ZmYmRGVEt5OEtvdzMrWnVrRkUzMDhPbUM1ejhhSEFYMnlhOUpoZFdYQWs5OE5VbC9NcTdUa3VJc0RzT1lRUVFzaDhjTzZaam13NjdpbXp1ZXF0WUsreTZkaElmV3pUaVM0Z0NGUVdIbHNtcnl1aXRYZFg3VFBaRmlqd0Y1VGpKMDYvRE1ETnpWTGVudVBmdFhmQno1QTlKNlhMZ01mc09ZUVFRaTVqWmdxR2xjckYzdmZZY212RmZaMU5SMi8yVi9MRE9tR1g3UlVIVjBRM0VOcDAya25GODFmWDdudHB6UjZUclljQ2YwRko3VGw2K2czNHgwdkhGZU5EUjJ6UG1kZkRyUWdoaEpETGlGa0RYVjNaZElKaXlxYVRlZnA4c1hub3VMdjIyT3QzWVNnL25EaFluWkY1cWkwQXBzdGNiQ2p3RjVmSW5wTzUvR2JYeDlmYU1tOVRwbFQzT1pzUUlZUVFzbE1ZZW80TFJIQnY3WnhOcDl5eWt1N2VEMThZb3c0U3hxMUVWd0Rpb2JzckFVeVh1WXhRNEM4Z3gwK2NQZ1RndGNIS3dKNmpWaGZzT2FWSVFLNFI5NVBOUHZxYXdwMFFRZ2laT3BDbGZmaTVQaUloSGRwME9wNXE2Nnc0NmttMi9wOU5oZG4zVk50NE9EbnRJQUR3MnRXMSt3NE4yRzJ5UlZEZ0x5QUN2Qm5BYnJ1VTJuTUtoeGsxQTlmQ2ZNQVZQVUlJSVlTTXBDcWJUcUxjazBiZ2czT3g2YmIvcWJaUlVyMGdVcCszNmRnbC9WVGJ5Y2NaQ2dBQUlBQkpSRUZVdUk3eEdpTVlrdXdCWktPOE0yUzdvTUJmUkVUdUNlOW96OWx6MnA5a1NiM0hYamxYUCtlLzE5SDdzRFFoaEJCQzVrVEJoeC9iZE9xZmFsczZiK3NyKzdxVk1NU2ZudmRWdWt6ZkdaemFaN3JNaFlVQ2Y4RTRmdUswQVBnV3dOdHZTcFNmWGx1dzV5VGw4aGZkeWgweWV3NGhoQkRpbUNRNHBvUjZGSmlieWFiakcyMzF1QVROUzN4T2J5MDhOcmpZOVZUYmFOWGQxeDA3eVlqZ2drR0J2MkFJY0R1QUc5d1NnT0ZQcnkwczBxdERDQ0dFVE11WXdKZlQzWVc2OFZYMllLblNwcE1UOXpaU0h6L1ZOdER4S250TzI0RHZKNXN1OHdZUmMvdUF2U2RiQUFYK29sR1JIbE5mTXZQMVVzZGNiTStadzJEbjFDNGhoQkN5aUl5THp1ZXo2ZWlJdTZZN1hlWlF2TDgrbkE1a3h4bmMrQnV0Y3hGK3V5M1lOOXAwRmd3Sy9NV2pJajJtOHRJN0pIcWJNOStFL252M1UrLzE3aEZDQ0NHa1lWNEJzNHpXang5YXBkYlYrUENEZHhtM1RmaFVXM1ZWb1BCVVc0bi83emRSNEM4WUZQZ0x4UEVUcHc4RGVGV3djckE5cHk4OUprVThJWVFRc3UwVWJUcldRNS9JNmJDTWRkaG82dzFXWEtUZEorc0lMdkZuTHI1THVNNXBDZlhrMnc3cDBJN3pWYXRyOXgzdTNXZXlaVkRnTHhBQzNBWElpbDBxMjNQU2lqbDdUakFySHp3V1RnUUlJWVNRK2RKaDAzSG4vVnl0WVVrNFZLd2ZWbDk0SDc0dG8xSmlJbFVPb1VjL0xpQXJnTnpWT1NpeXBWRGdMeElpOStnTW1DVjdqcHF5dSsxUlEyblQyZlNZaEJCQ0NKbWFxbno0MVkwcEVWNmRMak0vcW9aU3VreGJKZ254KzIzNnlvQ3Q1L3VsVFdlQm9NQmZFSTZmT0wwQ29HcjJXNTY1bThKdk1yWG5wUDU3M1Q1bkFZUVFRc2pjQ1d3NjJvZXZmZmFKMzExRkFrdnBNak1Cd3JZTmwvclNYVHlJbm1ycnluaEJYMHFYR1hIWGRjZE9VbGN1Q1B4RExBNTNBcml1ZWV0biswUDg5Mzc3bUZ6MVhRWTc1cjhuaEJCQ2l0UUd5MFJucWZFbEM0Mm1YdmxncVNkZHBndTArNGxESEtsUHJ3aGtyRGpKVTNVRmhYU1oxNG1ZT3dzN1E3WVlDdndGUVNaSWora0xTelF4S05oektOb0pJWVNRYVJod1RzMUsrcTUwbVIwMm5lRW9nWjZNSm96K2g2OHFQejdUWlM0OEZQaUx3MFRwTVV2VVJneHFLUG56Q0NHRWtNdUJvZWZBcnF2a21WWFZOcDNBbmFQdTRkTmJvbXNKa3F4QjRoSncrdDFIRVgxR25VeCtIMStWQW45Qm9NQmZBSTZmT0gwVXdCM04wamg3VG45NlRMV3FZdzM5OTRRUVFrZ05VNTR2YlFDdkx4aVhXYzdZZE1US094RnYwMG5TWldxUGZlakRkK0xlcGN1RWF5OC9EcWNmN2xoZHUrOW83VjZUK1VHQnZ3QUljRGNpT1orMzU2Qm96OUhDUEh2MWpycWRFRUlJMlZJbXlhYmpkRUJ1VTRjdFNOTHRYbDFFMGY5c29NOWtTbXFianA0STZCbUEzTjIxTzJScm9NQmZCTnIwbUtHbnJYblY5cHorUzN4eG1ZNklBTFBuRUVJSUlZdEZ3WWN2em45amkwVlg5YlYwRjZEN0NmVVNCQWpEVmxTRVhpZnZTR1JFbUozSFN4Q215MXdVS1BDM21lTW5UdThHc0FIMHpNU3oyOE5aZGszMm5CckRqdC9FN0RtRUVFSklOV09EWjdGSkhsWTdoNEc3dkEvZldtbHk2VEo5R1orL1hqV21EUVA2bkI4RTVIMzl5blNaYjE1ZHUyOTNieWt5Vnlqd3R4a0JYZ1BnR3JjRVlIeDZ6R2p5UC9PZDlvUVFRZ2daeE9qQVdDNlJodHRVV2tCdnVrd1lSTEloaU5TSFQ3WDEwZjJtUkROeDhPOXRIZHRQTmwzbTFRQmVXNzNiWkM1UTRHODNJbS9SczJwL21VMlVLNmNuUFdiQm5wTjdPK05ncDJ5TUVFSUlXWEtHbmhNcmZQZ2owMlVPZTZxdHRlK1d5a2owVDQzZGFSTFkyVUpZanVreUZ3SUsvTzNuSHNET3dKdDNDWjNwTWN2Mm5Oek5OUWo4OXhUcmhCQkN5R3pNNDF5YTJuVDYwbVZXUDlYV3RxSWorY3JORXpvQm9KNXFDMi9UQ1VlWkd4Y0YvalpEZ2IrTkhEOXgraVlBTHd0V0RrNlBXYUFqbFJVaGhCQkNGZ3ludFlmYmROeFYvb0pOcHpkZEpyUnc5eDRkMzBzVThROHNCT0c2ZGdRdlcxMjc3NmJ1SFNiemhBSi9HeEhnbm5CbXJTOXhBY1BTWTRaUHJ4MCtGazRFQ0NHRWtPMUZoZElEOGxmcnhkbDdoeVhwVUdZZTNXdjBMclRrNUVzYVAzbEk3RHkwNld3bkZQamJTWnNlMDN2dEk5bGVUSS9adDZ4K3pOVHRoQkJDeUxZeVNUNThWNzFjb3laZFp2b3V0UUJMS05RTFkweXZHSGlkejNTWjJ3MEYvalp4L01UcHZRRGVWRk8yUERPM1hydlMwMnN6UGpubXZ5ZUVFRUlXazhDbUUvdndvemg2NHNPM2RwbnVkSm1CVGNkNTdQMzcrS20yenNZVFBQbFdVQ0VkM3JTNmR0L2VNUjhEbVIwSy9HMUNnRGNBT09pVzJoY2RzSzlQanlsZEUvcnlDSXFiNHZ6M3Vhc0loQkJDQ0dtSXpwRzF3YlJzRkw5MHZvMUZkVnhyWUxyTW9PZllYcE91OWVreWN5UFE2VEtkNWZnZ0lHOG83QXlaTXhUNDI0WElQVjdSQStMK0ZQcnBjRDNwTWUyS2FEbTI1M1JGN3draGhCQXlCZjBpZjFoekVyMmRSN3BNd0ViKzAxWjBDQjlJOVVhN0xvam9XdzNqK3FWTlo1dWd3TjgrR3Y5OWNDa3Rvak05SnNyMStqY1NRZ2doWk52b3VvcmV2V0hhZEpsb0E0ZXhZeUM2a3Urc1BLS3NQT1Y0dm9JQ2Y1dWd3TjhHanA4NHZRN2d0bWJKaHRtSHBzY3M1TCt2OHVyb3kyK2NDQkJDQ0NHTGhRM3c5WW5vekhLWFRjZFpnWlVQM3haVEh2dWtqbXZmdExvaHp2Q25yZ0tFTnVQYlZ0ZnVXeCt5NTJRYUtQQzNBVW5zT1lIeEh2WHBNVnNIWGVHcUdTR0VFRUlXaDltejZlU1RhOVNteTB6SG8yeTgwTkloTTg1Z3d1SFhPY0dmZTZwdDg1NVIvRzJBQW45N2lPdzUwV1d6bXZTWTJTTkJ4NHlmMlhNSUlZU1E1U0x4NGF2QW9FZ29JWFMxb2c4L0orRWxDQ0FHcllndW8xU0RuWnVJZTVOT0ZIeS9iK25lU1RJUEtQQzNtT01uVGg4QThFM0J5c2llNDk4MVA4alU1MWF3NTJUSS9XRExoZVBzT1lRUVFnZ1p6ZGpnV215U0wyK01ObGxoYjVSUm9MM2FieVZmTGwybUw2YkV1MDMwb2JyVU45TTZjVjhlVjd1dmIxaGR1KytLOHFESlBLREEzMklFZUNPQS9YWXBaOC9wL1BGTDZNOFB0UC93WEptRUVFSUltU2VqQTJlNVJCdHVVMmtCRW1YWmlldmwwMlg2ZCtMRXV3NDRXdVZoc2ozNmJXRzZ6SGJ6ZmtEZW1COFFtUmNVK0Z1TnlEMFN6Sm96OXB5KzlKaUp4dzNoKzhsMGZzNG1SQWdoaEpBOFE4K1pGVDc4cnF2NG85Smw1bnJSUHZ1dXNlWjBnZElzdVhTWkRmVGhiekVVK0Z2UDNZQzMzMlRwVEk5WnR1ZkVkZHlNdlBOSFRRZ2hoSkRwbU1lNVZnbDFGV2wzVzdKWDh6dWVhdXVXVlhsQjhGUmJ1eWwwQ3RneTR0N3JwOXBxSDM3VXk5MkRkNW5NQkFYK0ZuTDh4T2tYQTNoQnMrUm43Y1BTWXhZSVVsVVJRZ2doWkttSW8vaE9OQSszNmVpSWVpaTZyWUFYbnk3VHJRN04rSVBTWlFiVGpUQmRacnY5bHRXMWt5L0o3d2laQnhUNFc0Z0E5OFNldG5EYVc1c2VzMzBYSHdWeVBSYTNjQ0pBQ0NHRUxEWXFsQjZRdjVwZm15NHpmOFhmWnVFemdWSUpTOFhCUkgyMW9CWDhjYnBNYncraVRXY0xvY0RmU2tUdUNUTmdScks5TnoxbW5GWlRsekJCVWEvOW1SNlRFRUlJV1NTeStmREh0cE5rczhuMG8rUkYrRlRiNkoza05FTGtMdENSL0tSb0psMm1od0ovQzZIQTN5S09uemg5RllEWEJTc0hwOGUwbEo1ZTIzV1FvS2duaEJCQ0ZvVWg2VEwxTTI2MER6OEo2cmw2VnNTYkhwdU90L0tFRGgxeDIwV01EOTZMYXI4ZFIrekRMKytydkc1MTdiNnIrbmVhVEFFRi9oWWh3SjhDWks5ZHFrNlA2WDVEZWdaZFk4OFpNcmc0LzMzdUtnSWhoQkJDNm9qT29iV3BNclBaZFBxQ2ZmbEVHcDNwTXUzMnFKY2c4MDZtZjc4MWx5NHpqT3duYmdVeGV3RFpLQTZJVEFvRi9sWlJZOC9KcGNkTUc4cXN5ZGx6cFA2QVFnZ2hoSkNKR1NueWk4MHA4WjJ4eHZpM3NkQ1A2bFZrMXNzcERkK09SRUhIcUdad3hZRHBNcmNMQ3Z5dG8vOUwzWmNlTS90YnFySG5FRUlJSVdSeDZmUzN0Qzk1ZlRDUGRKbXhKVWYwbGY3QXBxT3RQRFUySGFiTDNDb284TGVBNHlkT3Z4TEFzV2JKWGFvYWxCNVR0TkQzR3lwSG9DK3ZjU0pBQ0NHRUxCZE9hYWZyVzV0dlVDN1lIa2ZWZlQzdkxQQVIvc0FPRFAxVVczSGRlWnVPaWRXTFdzNm15enkydW5ieWxaVTdUV2FBQW44TEVKRjd0UFZHc0FKMzZjcjlNTHZUWTdvVmdmOCt0ZWNRUWdnaFpEbkladFBwZXFwdGdncjZaV3c2a2drS2hqYWRVcHZXTnB3ZmRSTGlqK3NHRVgwL09XQzZ6SzJEQW45cmFQejNYVGFienZTWW1VMjJYblpqM24vUDZEMGhoQkN5dk9TejZYVFlkRnk5VnJBbnpnRUpTcWhjbXMyYXdLWVRYVUFRQkUrMWJjcmtkVXkwOWkxMWUwdG1nUUovemh3L2NmcDVBRjdkTE9YdE9mNWRLVDFtL29FV09kTGZkWmNoTHM2ZVF3Z2hoSkM1TVRiNFZsTHV5SzBQTGI0dUdwK3o2YlJsNHFmYWhuMm1UN1VOSFFidEZRZFhSRGNRMm5UYVNjV3JWdGZ1dTdaamI4a0VVT0RQR1JHNUM1QmQzcDZqcDhQQXNQU1l5RTRNR0pnbmhCQkNsb1JKc3VuRTYzTEZsRTJubEozUHVndWlwdlJFUUlJdDlsMFl5ZzlMV2wyVGVhb3RBSWpaQmNoZCtRR1JxYURBbnorUlBTZHpPY3l1ajY5OUJXOVRDMC9mbzZpSGs3TUpFVUlJSVdRY1E4K3Ava3AvdmJGV1hlWHZ6SHV2cEx2M3d4Zkc2TVY2MmtvWXpZL2pqaTdhbjN1cXJlK0tQdnc1UTRFL1I0NmZPQzBBdnFXbWJGbXNEN1huU00rUGxoQkNDQ0ZieHp6T3hiRVAzd3Z2eE0yamJUcWxkSm1pckRnMjhPZzg5a0Q5VTIyRDRTRzM3MjJmZDYydTNVY05Pa2Y0NGM0UmFiejNxM2JKM3JDaUgzYlZseDR6M0paYm9JZ25oQkJDZGc2RktMNXo5eFlDZmxKYzhEYWRVcnBNbUVCajJDbURYY3JiZE95U2ZxcHRYTWY0S0grUVRFUldBZm1HL0k2UUthREFueWNpM3g3ZVlaNzU0dWVlWGl0eHlkZzZVeEwxT25vZmIrRkVnQkJDQ0ZsdWRNUmRrNy9hbnlidDhHM1VQZFhXUnY3RGRhRTJ5VDNWVnFYTFZPUDFGeHdNQUx5ajBDbVpBQXI4T2RIYWM3NE42SnB0Mnk5LzM5TnJjM2ZkaC9udmN4ZkIvRHVLZTBJSUlXUlJHWGVlam0wNmJUdE9WT3VpT2laZmFkTnAyMGpUWlVZWitGb0xqdzFtMWp6VnR1WHRxMnYzVWFETUNRcjhPU0hBYXdHc3VTVUFRNTllRzI3TExmQjNRUWdoaE93RTZ0TmxsZ0tIc2FpZTBhYWp4YjJOMU1kUHRYVmQycWZhNm9pLzdpZWJMbk1Oa05mMjd6UVpBd1grdkJCNWg3YmVCSmV6WEZTK3hwN1RydFFGWmg1Ym5QOCt0Z0FSUWdnaFpEcWljMnh2cWt3ZkdFeWwveFEySGRWRTFWTnRTeXBCb24rNnBOVTRVRE1CZno4aWJUcnpoUUovRGh3L2NYb0Z3TnZ6NlRIdFlwODlCMGs5dnpwbnp4RXdldzRoaEJDeXFBd1YrZlZ0cGcrUXpmaDM0NEJqNGlpSWRJcDlGeFoxVFhVOTFUYTI2ZVNtQ08yMDVlM01wak1mK0tIT2g5Y0JPQmFzR1d6UEthVEhwRDJIRUVJSXVYd3AyblJhRzAxZnhEM1E5eEt0MTZreUEwdUJEZmNuVDdVTjdmYjFOcDEyK3pGQVhsZTU1MlFBRlBoelFJQjNoRVliTlRNTzdEbEk3RGxRdGR5N2VPbzhhQ3ljQ0JCQ0NDRTdpdzZianRNWnZsendWTnZPVm9jLzFUWnZ6K20yNmZoMXRPbk1Dd3I4aVRsKzR2UUtSTjd1TGw4RjAxWDk5TnJ3Y2xpd1hTM0h4UFljUWdnaGhPd01KQkhPd0xDbjJ1cnE1Um8xVDdXTjMrVVVTVEFxcDkrVk5VZnlyVVJ0dmYyNll5ZXBSeWVHSCtqMGZDT0E2MnNLZGo2OU52ZTd6Tmh6M0U4bDQrVmo5SjRRUWdqWmdRUTJIU1hVblNwUVFqcVlNMWhoMy8xVTI4U200LzZKMjY2ZmF1dUQ4OWFLVTNxcWJYeUZRQURJOVNMbTlUTjhHaVFEQmY3RVpPMDVVY0MrejMvdnQ0KzVBYWREMUNmWmN3Z2hoQkN5YmRRRzU4UUxlVjJ5MEdqc2M0KzI5cWZMakdzSEVmOXN1NUVsSjF2U3RKTURSS0xJQUJEYWRDYUdBbjlDcXUwNVBla3gzUXFFL3Z1aVBZZWluUkJDQ0ZsT0JwekRzNUsrSzEybXRzakV6OWNaWk5NcDlhK0RrbXJTa0R6b0twMVFSRmNYM2thYnpyVHd3NXlXTndJNDJsdXFLajFtV2llL2NSWWJqcHBCRTBJSUlXVE9ERDNuZGwyVlR4ZnFiVHBBbjAzSGUyK2MvU0Q4QndRMkhhL3pmU0F6ZmFxdHN1a0VyZ1k1S21MZVdONVpNaFFLL0FrUjRMM0pwYWxKMG1QbWYrQzVtYlR1aVJCQ0NDR0x4cFRuWi9HV204NCtNc3Rqbm1yckREdjZxYlorSk02S2sxRWhpVTNIdHVldUhzaDdhL2VhOUVPQlB4SEhUNXkrQ2lKdjg5NHlRTENDMEdwVFRvOFpHbmxpZXc3SzloeENDQ0dFN0NobXo2WVRwOHRzbThpbXk4elpkSHJhVGthYnNla2tGR3c2bnJkZGQremtWUlVESUJWUTRFL0hud053QmREK2NFbzJtMEo2ekFabXp5R0VFRUpJSmM3bTBwRk54L25pYzlWYjUwRGlOQWpEanRxbTR5dzM3ZnVpVGFjTmVLWTJuZEk0NUFvUjgyM0RQZ0JTZ2dKL090U2xwVzU3anAwNWIxbjJIRUlJSVlRc0ZmWEJ1bEs1V0ZUSGxtQWx3b1B0b2gwODNwVWdla3hSMUY2OTh6YWREcU5RMEhad2hZSTJuWW1nd0orQTR5ZE92MEJFdnRGL1k3WFZ4cjVZZTQ0dlk3ZUZQNERZbnRPUlBZY1FRZ2doQkFpMUJZQytiRHA5VDdYdDZBaGxtNDRMN1JjbUtBV2JqaS82K3V1T25ieGw1TUNJZ2dKL0d0NERkOVhLUk4vVzhPbTFnN1BuMUczc0pzbC9uN01KRVVJSUlXUnJpTTdCdmQ3M0RoOSt6K204TDV0T0dsV1BncFE1bTQ2TC90dW1sTTRJYkRyU2I5Tnh6VFloZlJIem51NDlJalZRNE0vSThUdE9DUnFCMzlKdHozRnJxckxuQU9tTVhNMTVNemxyQ1NHRUVMSU1EQlg1M1czbGZmaEZrNHhmN3NxbVU3THBpTzFUWjlNUjUwcndOaDNUTVFLaityUVZEUUNod0orQTNkdlI2ZHI2eHRVQW5nZmc4WE5uenp5OUhXT1lESkhYaWNpdG9UM0h6cHQwOXB4bXVUOTdUbGJUVjJ0NDNtQkxDQ0dFN0VUYVlLQVl3RFNDdm45SzBMb0tUSnBOeHhnVHRkRzBMNUlVVDl1RUFOak1qREJuL01rNEYwUVpmWXlKVFQvcjF4MDcrYm9uSHYzSXYrc2F4YUt6dHI1eEpZQlZBSmZPblQzelIxdmQvOXdFL3RyNnhpNEEzd2pnTGdDM0FEalcvcnNCd0VGVjdvc0FIZ1h3V1B0NkZzQ3ZBUGowdWJObmx1RVJyZThGN0t3Mmw0dldidXlaU1dkMWVUZ2pEd3J6NmJXRUVFSUkwU2gxM3J4dFJUc0VKaVAwWFRVSUREYTk2bmFLMjY4UUdCaVJkdEVnbUdLMDhpZm56SSs5QmdhbW1FdkVxUjdaZkMrQWhSZjRhK3NiQXVCVkFPNEJzQTZ2ZFk4QnVGS1ZleHFoMXYwY2dIOE40TitlTzN2bXVYbU1iZEp3NzlyNnhoVUF2Z1hBV3dHOEJjRGhHWnA3RE1BdkFmaEZBTDk2N3V5WnI4dyt3bWs1ZnNlcEF4QTVMeUtIdEwvTXZVZTBEbkJlTk5qM2dOdmVyZ3l0UGE2QVhXT1hjNCtVTHZ3NWs4a0FvL3lFRUVMSTloT2RuMDE2Zmc3ajlFYVZpeUw0eGpTbUYrT2Z1ZVAwdkRFdVdtNEZ0akdxak5uMDIrMDJnMGIwcTNYTmVydThxY29hdHoyL2pQejJ1RSs0OGs4Wlk2NS80dEdQZm1tR0QzY3VySzF2N0FQd0pqUmE5OCtnQ1Z5UDVTS0FYMGFqZGYvMXViTm4vbVQyRVRaTW92VFcxamVPQWZqckFPNEZzSCtLTmlPK0NPQWZBZmpiNTg2ZXVUU0g5a2R4L01UcDd4Q1Jmd29JWk1YZEhnTDNsRGF4NjFhOFJ0Y1RBVWdnOGdFdDlBSElpby9nVStBVFFnZ2hPNHgrZ2QrVWl1N1R5d3I4dHFUeDVYekF2bDJ2UkhYell0eTZVTHpYQ0h3RFl6WWo4WTVRM01NQW02SFk5MjNIL2NXVEQvT2RqNS83Nk0rTS9tZ25abTE5NDFvQVB3VGcvVkRSK1FuNUVvQ2ZCdkFqNTg2ZWVYVFd4bmJOVW5sdGZlUFFvV3ZYZnhqQXo2QzVSREV2eTg4K0FOOEE0QU9IcmwzSG9XdlhmK09MVDM3MjJUbjFWYzExeDE3MzR5S3lMb0dnWDFGUmZLaUl2WS9jdTBrQTRDY0RzR1ZzNitxOVRtL2wvaGVzc1RYQ0FkcUhUeVJRNEJOQ0NDRUxoM1B6OXB5bjNVMnV1VzBTdmMybnkweWJMTldMTllpMTZVU2pOR2l5NldTekJYcWJqOS9KeUlLY2FwdXIvdVNMdi9uVHhRRnZFV3ZyRy9zUFhidisvUUIrSHNBM0E5ZzdwNjcyQURnQjRFT0hybDAvZU9qYTlmLzR4U2MvTzlxOU1rcnByYTF2N0FId1BRRCtLb0RyeG5ZK0EzOEk0SWNCUEhUdTdKbjBMbzh0NFBnZHAyNFVrZjhGa1pWWXpHdEI3NlAxZmp1Qzl5WnZ6OGxFNzlzU1NGTmVxbTBhUnU0SklZU1FCU2RqU0k4aStVTnNPdjVsb0UwSGFZVGVSdkdUeUx5ejNjeGkwMm5yMnpHbE5wMU5ZM0R6RTQ5KzVOeklEM1ltMXRZM1Z0RGNaL2szQU55NERVTjRBc0RmQXZBUHpwMDk4OHpReW9QVFpLNnRieHdGOEhFQWZ3L2JJKzZCNW9QK0tJQi9zYmErY2RXMmpFRGtYdWU5YVZhZy9IQ3JqbWFRRWZjRklaNnVyYkRuRUVJSUlXU0JtZkw4N1lPSUlVYnBrclRQdm9kZXhkdkZ0dGxHNHVQV2dvZGV1V1U5dk9oZXhPRC9qaFVSYzIvbndPYkUydnJHSVFEL0FvM1czQTV4RHpRYSsrOEIrTFcxOVkwalF5c1BFdmhyNnh1dkJQQUlnTmNNN1doT3ZBWEFwOWJXTjlhM29lLzNBb2dTNUdpeEgyMHNQYjIyY0NtT1Q2OGxoQkJDQ0JBSDhhdzROc21XdXNhMEZTZVY1cmFMem9kZXVVTFdXYUNHRlQvMHFuVTRPRnRSWWo5V2t3VFh2YXY0M3FHN055dXRwdngxTkJwekVYZ3RnTSswR3J5YWFvRy90cjd4ZGpRcGkyNGVPTEI1OHhJQW4xNWIzL2ptcmVydytCMm43Z1R3b21SRDlIQXIvNjVrbFlsdW1uR2JKU3FuNXJhWjlKaU0zaE5DQ0NIRUMyVHZieGVsbkx1ZmF0djY0Z3NQdmRJSlJPRHN4MHE0SS9mUUs5dVdVUzE2RFNTcVQ5MU8wNFFCZ0JkZmQremsxMC93eVZUUmFzbEgwR2pMUmVKbUFQOXViWDNqYmJVVnFnVCsydnJHWDBGemM4SEJ2ckxieEdFQUQ2K3RiMnpOVEUva3U3eS9YbDkrOGwvcTlKSlZORk9XOU9tMkF3Y3hRMTFDQ0NHRUxCUDFtcUZVVHFKTkdadE9ITkgzUXJ2WHBwT09WZ2NyNjIwNnVvVW00bSsrdTdCRGs3SzJ2dkZkQUI0R2NPMVc5RGVDZ3dEK243WDFqUitzS2R6N2JWbGIzM2duZ0g4MjY2aTJpR2NCdlBuYzJUTy9OcThPanQ5eDZpQkVIdlc1NzRIKzdEbE4zU1E5cHA1VnE4aC9NWHRPRU1IWDJ3cC9SdDVrU3dnaGhDd0JjMGlYQ1FGTWs0Y2t2T20yRWVYMlJsaTN6dDJFQzUvaU1wZjZVdDJRYXpaMU9iL09wdVVzM1pRTGQzTXVWS3JOVFpjK00weWxpYWVNTWNlZWVQU2pUNC8vZkx0Wlc5OTRJNW9IVDgzdEFiQVQ4ODV6WjgvODg2NENuUkg4dGZXTnIwTnpnOEd5c0J2QXo2K3RiOXc2eHo3ZUpjQWh2K2k5Y0lGSWQ1SjhkbnZPWUxUL3piVkZjVThJSVlRc0p0RTV1dmRwOVIwKy9NeENrSTY3ejZhanpRaVJUY2NaRjFTVklGbElZTlB4SStpMTZRaFNWNFJ2NHBBSTN0bnpnWXltOWR6L1BKWkgzQVBBQTJ2ckd5ZTZDaFFGL3RyNnhnMW9ucXgxWU9wUnpabkRBSDVwYnRsMVJEN2dIMWFsUFczNjBsT2FQYWRzejZuTm5qTXdlazhJSVlTUUpXS295Tzl1SzJlNW1UV2JUbGQvWlp1T25URVViRG9kTWtiVi84RElnWFdpc3VVc3FpMm54QUVBdjdpMnZuRjlxVUJXNExlUDRmMEZBR3R6R3RpOGVRbUFuMmx6bUU3RzhUdE8zUUhnNit5eXVCK0tucjFDVFhIanFXNzZVNHBoOWh4Q0NDR0U1RmlJYkRyNjRaMml5L25vZjlPbThjdmFldHkyRmJvZUVQV25yeVlZQVBqNjY0NmR2SDNvTG5iUmFzU2Z3ZUxkVUZ2TGpXaEUvcjdjeHBJQS9rRTBUNlpkWnY0MDJsU1dFL0tCckVBZmt6MG5tRUhiemFrOUo0M2U2OVk0Q3lDRUVFSkloTlBkMDJmVEVSaEVwb1FLbTQ0a3lpYlFSQzdDcjhmbzZ6YjltS21qK04rRnhVbUZPWlpYQWZpQjNJWkVJYTZ0YjZ3Q09BdGdleDRnTlMxL0NPQzJjMmZQZkduV2htNjc0OVJWMHR4Y2U2V2R0VFpmNnVqbVduZ2ZtWTNteDArdjlUOG9DWDRrdWFmWGpyTG44T1phUWdnaFpBbVp3ODIydWFmYVF0MDgyMjZ3VDdXMTYvVFRaOTFOdGRrbjB1b2JhamVqN2I1dGYrTXVvcnJwamJqK1psczdIZ01ZZk5FWUhIdmkwWS84OGNnUDE3RzJ2bkVBd1AvQThqcFZORThCV0Q5Mzlzd1RlbVV1Z3YvWHNEUEVQZEJjdnZqZUtSb1M0RHNBWE9tWEN6NjFTTnpyQnNJZ2YveWpGZHB6Q0NHRUVESXRnUlVIQ0pKOGROcDBiQm0veGx0M0lwdU9jKy9ZOTIxQVU5bDBRcnQ5SnBVNGZGMFhCUFVEQVlDclJNeDNETjcvUEg4Sk8wUGNBMDNpbDc4V3J3d0VmcHQ5Wmk0M01td2pwOWZXTjZhNGVTS3g1L2c3djZHK2pGR3B4SGF6bGRsekNDR0VFTEswVEp4Tng3K3Z5YWFUMm1hS05oM1h1MzlYNmpjenVHQnlFZlRuWGx6Yk0ydlV0ZldOd3dCT3o5ck9ndkhCdGZXTkYrZ1ZjUVQvYndQWU82VEZsWlhkV05tMUo1bjVMUkRYQVBpaFdScTQ3WTVUWHcrUjI0UHNPY0V2UWorcHpVYmhvMjkrdTI2cTdEbUVFRUlJdVF6WXdtdzZWc3ZsWEFyNm9WZEZQU0xwbGlDMVpoRHA5M1puVzlDTGV6dUJTSjVzZThkMXgwNStIV2JqaHdCY1BhU0NyT3pDeXE2OUVKazBkOHVVN0VXajRSM3U3N0Mydm5FVXdLUEkySFprWlJmMjdyc0tlL1plaFpYZCs3Q3lzZ2U3ZHUyRnJPeUdyT3hxdmo1bUUyYnpXVHkzK1F3Mm4vc3FOcDk3QnM4Kzh5ZDQ1aXRQNGRsblpyYkF6OG9mQTdqdTNOa3pYeGxUK2ZnZHAvNHhSRTZLdStRRWREM2NTdHR6VWo4KzRIOUl0b2VKSG01Rjd6MGhoQkN5NUdRRWZlVEZOMG1aZ2hlLzU2RlhyU1crNDZGWDFqdHYzNGZyL0VPdDhwNTh0TDc4Y0xuTHoyOGZiaFcxNGJ6N0FHRCs4ZVBuUHZLK01aL3MydnJHZmdDUFExbXVMYkt5Z2oxN3I4S2VmVmRoMTY1OVdObTF0NmgxTnplZndlWnp6K0M1NTc2SzU1NzlFcjc2NWFmdzdETi9NbVpJVTdJSjRJWnpaODk4SGdpVCt2OFpLSEcvc21zUDl1Ni9CdnYyWDRNOSt3NWgxKzU5elU0NlladmVKZDM4RVRiYlA4Z21qSGtPbTg4OWkyZWVlUnBmL2RJWGZ2K3JYLzdDenovN3pOTS9aNHo1TFFEUFE1TjM5Rm9BSjlEY0JYempuSGI2U2dCdkF2QXJReXZlZHZ1cFF3RGVtWE9tTmRsemRCUy9mTW1wd2Q3Tjd1OXFid3NtNjFKeFR3Z2hoSkNkajlVRTB6VWxWdVMza1hGanZJNnh3WHlqdXhVSlpJa1lYOTlxRXpGTlJYdHZyamNpQzRCTnRSYzZMdS9ISmNiT1c0enlRYlF6RHQyR0cwdnJrakI0MTNYSFRuNy9FNDkrNUtrUm44aWJvTVQ5eXE0OTJMdnZFUGJ1dndaNzkxL2RhRjNaRFZsWjZkRzZWdWVhVnVzMlFlMnZmdmtMLy9FclgvN0MzMzMycTMvOFdXUE1rd0F1QVhnYXdCc0J2QVBBV3pIdzZzRUFWdEJvK1k4QW9jQi9xNGhnOTU2RHVPS3FHN0Qzd0RWWVdkbUxsVjE3c0xLeUs5eTVFaUlRN0FxdUJPM2FqZC9admZlSysvZnRmOTZuZnVOWGYxaC9ZOCszL3dEZzM2MnRiL3dFZ085RzQ0dTZaZlR1bFhrclJnaDhFZHdMa1lNSW92ZG8vdkJOQ2VYQk4wQWIxZmNOV0RkUDZFbnJzK2RrUnFKclI1czRDU0NFRUVKMkxGNE5ONHV0WkMrWDA5dEtFNGI0bmtBN0FSQVlZMXdQUGdWSU96a0lSTGhCOGs0TXhMUzE3UVJEVEREZVpwak5WWVdtL2MxdzM4VDRmbzJlV2dnTWNGREVmQ2VBbitqLzRCTGVDZ0M3OXh6QUZWZmRnSDBIcnNYS3JsYnJ5dTZNbFNtRHRWdkxTcXZHOW1EWDd2My9ZZmZlZzMvenQvL0QzLzFYaFZxL0RPQ1gxOVkzOWdMNHN3QitFdk1SK205RksvQUZBTmJXTnc3dTJyUC9pU3V1dkdIL2dZTkhzR3ZQQWF5c1RQTEUzazhBK0xPUFBIenFDN1VWMnAzL2x3QTJwaGlBNGp5QVkrZk9uaG1raG8vZmNlcTNJUEx5YmJIbkJOK3pNUUtmRmgxQ0NDRmsrU2ljMTR0V0hST1ZLZGwwL0wyRVB6VzVBQUFnQUVsRVFWU0NOaTFtOHlvdUhhWlBqUm5aYXBvVmlVMG50dDFvbTA1K1cyekxVZS9SMkg2MFRjZEd6S09VbWIvMStMbVB2SExJSjdxMnZyR3lhL2UrUnc5Y2VmM1JBMWNld2U3ZFYyQmwxMjVNb0pYKzFpTVBuMHF5MlBTTTVXVUFQb2JwblN0ZlJtTkpmM28zQUZ4NTlVMTNIYmp5NlA3ZGV3NU90Yk1BOE04QnZQZVJoMDhGdnZkclZ0LzlJa0QrZFBzRnV5U1EzMzd5OFovNmpOMSs3dXlacjY2dGIzd2JnRThDZU1VVUEybTVIczBEQVQ1VlcrRzJPMDY5Mm9yN1ZzMERnTHZoUTErMTZiVG5CQmFjZm51T2JYR3lTM1NFRUVJSTJjRjBhSWJBcGhOdkNKV0ppZHB4RmhtVWJUcnh0UUs0ZGpZUklnaW1IcUt2RHJSOUdkTUVSRzI3cnNIMm1vV2d2VHFBVjZ5dW5YelY0K2MrOHVtZUQ4Wnh4YUZqcjdyaXl1dVA3dDU3SlhidDJvTlVkNDNpb1p5NHYvcnd2Vjl2Z0s5RlkwTUhnSC81MU1XZi9sMjcvZHpaTS85MWJYM2oxV2ljSlMrZllpQXQrd0c4R2NBdk5BTC9tbHZ1MmJWN0x5YU0rSDRhd0xzZWVmaVUrN3Rmcy9ydXV3RjhHSkN2OVJkeUdxSDh2Q1B2K1RWQWZ1VEp6ei8wU1FBNGQvYk1VMnZyRy9lZ0VlTTNUVFVvTkU4c3F4YjRvbEtHTm9selRLanFvU0wyTnVTZXMrZTRrbW4wdnRCdjd4cENDQ0dFa0RxY1Y4YWI1Z0Y0QTM0ay9VVmNSTDJwM1dmVHNRTGMrK1cxalVoYXdhL0Z2THVoTnBsVzJBbEVOS25RaFpwN0J6NkFSbTlXY2VoNXQ5NnphOWUrT2h0T0hXY0FCRGY3WG4zNDN0Y0QrQkVBM3h4TnVYN3MwT0Y3Znh2QXFhY3UvdlRIQU9EYzJUUG4xdFkzM2dUZ3M1ajIrVk52QWZBTEt3Q3dhL2UrcjVsWVJQNk5TTnkvSDVCZnlvbjdCdmxtQ0g3dDJxUGY5VGE3NXR6Wk00OEN1SGZLUVFGWXJ5MTQyKzJucmdIdzdlRmFHNjQzV1pHZXBwWHljMW52MFk5TFJIZW45RkI4ZW0zU0x5Y0ZoQkJDeUhKU2R3NFBOWUhYS0xWcXdVZnh0YVZZYjdaNndpZ2pnN1ExVnR3NmExVzJWWUtVNE9wOTJLK0UyNTN0T1JNc0ZkV1dhMSsrZlhYdFpMV1BmZGZ1L1Y4em9iaC9Dc0NmZStUaFU4L1lGVmNmdnZkdEFINE53RGVyb1d0RjlyVUFmdW5RNFh2ZHBLQjkrdXcvbUdwUUxldUF6NXB6Yk1LR2YrT1JoMCs1bTFtdldYMzN0d1B5RHdHenF5RHU3UjlyQlRELzlOcnJ2K3MxZHN1NXMyYytDZUMvVFRpMit2MFV2QnNpQjdMMkhQVmwxSGQvdTZxUlBTZTR2VGI1NGJpRzFEdEJ6bGRmKzNNbGhCQkN5TEl6NFRuZnlSWnZDWlpJaDVYNnplZlJyK3MwcnVVbkEvcWZGdTFSN2VSQlc3cUF1UUxBdXdjTWFFcXQrek9QUEh6cWorekMxWWZ2ZlEyQWY0cE1xbmxMdXdlN0FQemtvY1AzNmdEeWp3T1lNc2ZtTWFpQjNEQmh3ejlxMzF5eit1NFZRUDU2Nk9mS2ludTBsNDcySTcwcitoOU5PTGJxL2N6YmM5b3RiWW5VbmlOQkEyR1FQNDZxMS81WUtPb0pJWVFRa3FmOFhKeFVNdWRSTitycVpCK1NFZHh0TXo2am9OWTIwY05BSXhFdmdiTFg3OUw3RU1Nb2ZxTVJyZWFLb3ZoRG5tdzdwZGI5eVdqNUo5RDQzenRSZS9ramh3N2Z1d0lBNTg2ZWVSelRhdDFHNE4vNTVnOGZRaWJoL3d4OHhyK1Zid1hNY2NCZVdNbGNkckhpM205NCtlSHJ2MXZmY0ZCS09UU0dxdG5iYmJlZmVpMUVYaHJPR3UwWE83VG4rTGxsZTNVaWljcG43bkIzSlVKN1RsZjBuaEJDQ0NGa1p0UzloS0hsUnFtZXhHMWdSWHNjVVJjbitLTVlaeURqMDZtQ0V2dWlKd1lTdFdQYmp6cHdCY3pMVnRkT3ZpYmRrR1VxZ2YvNEl3K2YrazI3Y1BWMTczNEZCdHdvMis3Rmk5Q2t5N1I4SmxkMkpGZXVyVzljdFlKcEwxa0FUVkwvRnZOeVFFWHRnOGg5NU10eUlsY0E0RzViY21YWEhwc3Jmd3F1WEZ2ZjZMMlJRYVNOM3JkZnRERDNmZnRsRlFEdzZhYVNiN2F0cjc3V2ZmYWN3WWpoWklBUVFnaTVYT2c5NTNkb0NxZXpPckx0aExmQnVxQmxXRWRORGlRc243eFRKZ2ZYdnhpdDdWVVUzd1NUaHltaitCTUhzMk5kK2kxUUU1UWEybEp1VXJCcjkvNUxwYklqT2JZQzRMb0pHL3pLSXcrZmVsb3RYNXRFN1lNL2lsK2xYZ0RCWHZ2MkQzN3ZWLzVJWk9YTEU0NnhjMzl2dS8zVXRRRCtYRlZMZ1prczJCQitKeEdYcVJYMSttY3l3MFNBRUVJSUlUdURtUUo3VG1WSDYvVTlrbVc5NFMzVmVvMXZVMGZpbmRZVFh5NTVLcXlPNHF0TEFhRlRvaGxmUnhUL0hhdHJKNS9YcytOVGF0MEwwZksrY0R6Vkl0K20wTVJWMTl4eWFhTG5UMWxXVndBOE9XR0R3UU90eEQvbXk2M3BGdmR1TXVDU3A1NTQ0NC9zT1hob3JYalR3Z2d1OW14L0QwVDJoMTlDTlZ0MHE3dnNPWlo2ZTg0MDVDWWJoQkJDQ0ZsT2FzVmlKb2pZbTAxSFJlSWovU0JBMkhXTlRTZWJaVjgvQXloc1RsdnliV1EranVMN2xKbCtPUlBGM3cvSWU0cTcyZENuL1lZUWVPMEYyRXcrNDdwb3Z0TzIrdyt1WGpwNDlVMFpIVG1hU3lzQUhwdXFOUUNyZDc3NXcwZmRrdUJYb0JaQ2NlOW5nSkc0aDRoODNOYmF0V3YvU3c5Y2RmM2V2ZnNuZWFMdlUrZk9ubm1xcTRDejV5QU8wR3V4Ynhmakx4NkNMeXF6NXhCQ0NDRmtOaWJVQUU1M2RkbDB3b1hZcHBNODE2ZGswMUdUQW1lM3lkNXNHNytIcTJPajlqNmdueEhPelJnNmJUcHR4cHN2ZHBVWndNdnZmUE9IOVNBK2JvZVIwQzMwZjltKzJiVjc3OWNldVBJbzloMDRQTkVROGRqS0l3K2Z1b1RtMGJaVHNBTGcyOVR5d3dDK2tCWDM4V3pUTC80aGdQL2dOOGtyOXV5NUVsZGNkV3lLbWMwZmRtMjg3ZlpUcndmd29yQVhQeE5PdWhmSi9FamlxeE54VkwxMkh5anFDU0dFRUZMSDRHdzZYYTREa2FCb1dMNzF5eXVOWTNQaUJ6YWR0b3Erb1RZZVIrTG95S2JNOU1GVWUxVWdEcVFLNU1Xck41Nzh4dlFEQ09qVWdBTTRCT0JXdGZ6dmJkdEY1WmJxMTBzQS9vMHE4STdkZTY3QUZWZmRBRm5aTmV2NHZuVHU3SmtuN2VXQkthUDR6ci8rNU9kLzZobEFmalFyN3QxM0ovcHppM3p2RTQ5K1ZLdm1lMlZsRi9idHZ3YjdEbHlMR2ZtRHpxMkNEM2ovbC9xQ2FwRXVkazB5YnIwQVpzOGhoQkJDeUdLakl2Rk9oSXZla3BidmlFcDNYUm5RTWM4bU9wKzcyVmIxV1lqaUIxNTg4WTFMLzgyMlV3bDhRRDJJOVF0UC9CTUQ0SHZ0Y3FYSS96dC9kUEdubndHQU85Lzg0UU1BL3JUSUN2YnNPNFFEVjZ6T09yYkhBTy8vZVhUVzFoVGZlT2ViUCt4U0VUMzUrWWQrVENELzNHMVZmMFVKRlM1RTVNZWZlUFNqdjJDTDN2bm1ENzhXd0o4Q2dGMTc5cmN6bTVucytNVS83bTIzbjdwT2dMZnJkZVhjOTBDblBjZVZiSDhzb2d2NEVtVjZvdmZNbmtNSUlZUmN2Z3pKcGhPWGRZSEtYQnRHYVJ4VnBXVFRzYkltaU5TM0pYUk8vS0RmbkE3UzdYVkg4ZTJ5dVBZYzM3WjY0OGt1ajh1VUF2Ly9aKy9PNHkyNzZqcnZmOWV0U2xVR0VraENCc2dBSVJCb0JqR0FCU0lOZFB0UVRXczdZTGUyUFAyZ1FSQlVmQmdqRlVWQTBnMVNNbXFMekVnRFBxM3Q4T2dMdE8yVXJSSVZOWFlqQ0NqVEpaV1FtMHBTcVVwbHF2bmUxWC9zYWEyMTE1N08yZWVlcy9mNXZKWGNNK3pwM25QcW5PLys3ZDllKzVVN2R1N09lOGNQM2ZueC8xOUc3OGp1RytkL0ViOTU5NEZQdk4yNS85MlN6cENrTFZ1MzY3UXpMOVRLbGxPbTJiWmJwU0xnNzUxbVNZRVZTUi9mc1hQM051ZXg1MHQybDR6eS9uY1QzRWpmUE9GWnp2bmxmSTNab2xPMlAxQ25UcmRuVTFmQi8xRkoyK09Ic2Z5eDc5TU5pdnpqY0k1U3hGN1ZmQjVUK2FxWFptazdJUUFBV0I2ZGhzeXN5QkpPa2JLbzRxZlp3N2hGVFhlaXRFdkJGRlBuNjRnVStJdWc2M1kzRklzcm5XenJ0bkc3R1RIc3hRODZLMlMwM2NqOGFQd1hsZFRVeGRITmcxUWFjZEdjVjVmcUpkMGo2YldTL3Uvc2dSMDdkMThpNlYzNUVzeUtUdG4yQUoxMnhnV1IyVnU3U1NvQy9uWFRMQ25pT3lWOUxEc0o0ZUR0SDdVSGIvOHZ2NlJrU0tBbkcrbFZrdm16SU54TDBvK2NkOUdQZlp1em5GK1ZNNkxPbHEzYmRkb1o1MC9UaS8rNXFpZU0wVXZjOXB5NnNlL0R0WWZ0T1g0N1VrdlJrMVRhL3A3MTd5Z0FBREJrN2I3am04Zk04ZStZMGptUjZaT3hpZk43N2hWdjAraHVWSkZqL0dXMk90bldhNU4ydXlBaXZmaGhGZC9vSlpWL0FPbXpOYzkxdFUvU2Y4dnVQT2k4Rit5UTlJSnd4MFRTbnlhWlYwK1dkTTdkQno3eHRyc1BmTUpLMG82ZHU4OVdjakhYaTkwRmI5bXlYYWVlY2Q0MHZmai9RNUt5UVRjL0pXbGRVdlBTck5YSmswZDA3TWhCSFQ5eVNPdnJ4MlJXdG1wbFpZdFd0bXpUS2R2UDBxbW5QMWdySzF2L3ZaS3hRbCtSelhyd3RvK3VLL2tEZi9iY2g3endmWkwrVWRKbDJmUEphMlorV2RMVEplbUc2M2I5cngwN2Q3OUgwditiUEwraXJkdk8wTlpUenRDSjQvZDEvWVh2VnNWVmNhKzRjdGUva0hSRnE2VzRlNUVWN1RudUxxOC9sbXQ1YU15cXZWb0FBSUJDdTZ5UXBJMDJtU0tyeEJ2SnV0TUhKOXZhWWlodzYweVh6RzJkelRMT1k4YmJXaU1yV2VQZGQ1ZGtqRTFXWTVMOUJPdGMrQ3IvcjBubVNwN1B0aWZiVHNsWUl5djc2UE12ZnZHejc3amxRMzhlK1lYL1dFa1diQnlXMGRvTm5UaDJqNDRldmxQcko0L0xicHlVdGV1U2pMYWQra0J0UCszc1YzenUrbCs4UjVJZWRONExqS1JmbG15Mjk1SnQwemRrOVYySDd2ejRzWEQ1YWQvOXB5UTl0clJ5WTdUMWxGTzFiZnVaT25ia1VPbnBCaWVWanM2elJaTFdWdi9reUVXWFArZGZTSHA0L1M5N3QrNCsrSFhkZi9jdE9uYmtnRTRjdjFjblR4elIrc2tqT25uaXNFNGV1MC9IangzUzhTT0hKRzFveXltblB2WGlSLzZySjE1MCtYUDJycTMreVpxN3ZDUDNmZTdrNldkZWVZc3g1b2ZTM3lpcmhGOXl4Z09mOUxYRDkvejlGeVRwb3N1ZjgxZVNma1RKV2N1UzNkRDZ5YU02Y2F4MnRNdVkzMXhiM2ZPN3NTZk9mZWd6M21xTWVYeTJOMmxXbkFzeTVOVjg5N0VzdytmYjdCM0tLaXI2d2NVYWlzTklLaDROSDZ1cDRHY25wSlJRdlFjQVlPazRCY1dhQ2ZMcDRvWDVJb3I3Sjl0V3JNSVovcko0eXBuYVdOV2ViT3QxNEdUck5xWDdiaUcxZENYZGZLUGMwWHp5NTA2OS81N1BsdkxlMnVxZnJGOTArWE1lSStsYjR4c25XYnV1NDBjUDZkNjc5dXIrdTcrcDQwY1BwVm4zc05aUEpubjN4UEY3Lytpcm4vMzExMlh6bkhyR0UvOGZPU2ZaT2tjbFhuVG96bzkvMFYzK2pwMjdWeTY2L0RrL0lPa2prcDVhdFIyU3RMNStYTWVQZGc3NG4xNWIzZk0reVJsa1g5SWZWRTF0N2JxT0hyNVRoKzc4aW80ZTNxOFR4Ky9UK3NsanNoc2I2Zk5XZG1OREd4c250WDdpcUk0ZE9hQjdEbjVEaC9aL1dTZFAzUDg4U1grelkrZnV2OXl4Yy9mejNMRkREK3o3OWQrVjlPZGVFRGFTa2RsOS9pVXZQbDJTYnJodTF6MXlqZ0tzYkRsRjIwNTdVTmRmV0pMK2ErekJLNjdjZGFhUnZqKzduK1QzaXBOcjB6M0tmTUo4Smlmd3UvT1Uva0g0aW5CZlBxd0ZBQURRYU1vcjI4YmJkTUtUYmJPdWhJckFyU3ozaDNuR1A5azJ2TEp0TVcxdzMyUUw5Qzk4NWZmaTI3ek5wOGhna3FUbm5YL3hpOCtzK0lWL3Mrb3ZzYkYrWFBjZHVsbUg5ditUanR4L3UwNmVPS3lOOVJPeUd4dXlkaVBKdXRZZTNsZy84YkpzbnJQUC81RXpqTXhiUzM4NzZVOFA3Zis0TzJqTTZUdDI3djVwU1YrVjlEdEtXbllxcmF5Y29tMm5QbkNTbHZROHk3c0IvL2RqVTI1c25OVGhlMi9UUFFlK3JoUEg3czFEZlIxcnJkWlBIdFhSdzNmcTNvTTNhdjNrVVVuNkRrbS9KNVg2bzE1cGpFMFhtdjhpRjB1NkpydHp3M1c3ZmxmSm9Rd1pzMFZiVHpsZFcwODVyWEU3SFBzbC9jK0s1NzVieHJRNHVWYnkybk5pMDVkMkRJcm5aM1BsV2dBQWdEcEZwb24wQnFUUHhjTkovY20yY29KMmRxOFlFejkyc3ExWG5YYzNyV0xJVE9Nc0tOYUw3KzhNWk1zejIyWDBYUlYvakQrUmRHZjQ0TWJHU1IyNTczYmRkL2MzZGZMRUVkbU45WXJaZGUzYTZwNjl6djFyWkhSUjhGZGRsK3dyZy9rK0lPay9TN3E4YXNFZVk3Umw2Nm5hdXUwQnJTWjM1RmsrRC9nM1hMZHJyN3hCOTVQSy9iRWpCM1h2WFRmcTVJbkRYVmNpdTdHdW8wY082TjY3OW1wajQyVDI4TFU3ZHU0K0s3dHo1NjBmK2J4a1BsUWMxc24zOHE2KzROS1hYT29zN3FjbEhaYWtMVnRPMFNuYnoxSUh2NzIydWlmNmFobWpIOGh1MUk5OVgvNW5VUjc3UHYvTlN5dnhGbFE4VWJubnplZzVBQUJnTTdoVmZEZXMrMUVrVWdxdEdSTS9QcWZKRisyMVBpdk1YazFWZkdmbklsdXlLWllncGRrdWNNTjF1MDRxS1RibjdFYlNwWEx2b1p1MHNYNjg3dGY0Z2xRTWhYbjIrVC95TUVsWEY3OVovbHQrOE5EK2ozOGh1N05qNSs0ZGNrYk9hU3VyNG5ld1oyMTF6MDM1L01HVHUrU2swL1dUeDNYNDNuMVpCWDRpRytzbmRQVHdmdDEvVHo3ODZQbVNYaGRNOWpvWmU4ZzlkQ09qMHlTOUxadmdodXQyM1NUcEY2U2lpdC9TdXBJOXA1SXJydHgxcXFSLzdUNVdQZmE5dTIzK0xta3daWElyM0QwTlZCOEY2Qkx1blowUUFBQXdjdTIrOHl0emhBbmFjYUpkQjVuNEJUdkR0aEgzbWthbE1mSGQ0bWxhaFM5Q2ZIbkl6UFpWL05JS2l5MUpkaHkrNi94TFhyeTk0aGQ3ajVKc0tNbnF4SW43ZE85ZE56WmxYU3ZwcFd1cmUwNDZqNzFOMHFuWnBxUmJjRWpTNjRONTM2WHFQM0lsczdKRlc3ZTI3bGF4Y2pwZnBDRGczM0RkcnM4cTdVL0t6aUErZHVSZzEyMHFXVDk1VE1jTzM2bjFrL21KeEsvWXNYTjNmcG5mL1dzZnZ0UElYT3NYekkyTTlFTVhQdXlsN3FXSDN5WHBIMlJXdWx3RTREMXJxM3MrSDMzRzZEa3k1Z0h1M21QeEt2bGozeGRYZG1zYSt6NFczU3ZhYzdoWUZRQUE2R1RLa0YrMUJMZVNYc29yZmtlRE4zMWVqWGNueUtyc2RWZTJMYXI1Zmc3TGx0TlV4WGNHTjVIa1hZUEk2QUZHNWpteFZkOXczYTUvVURJTXV6WTJUdXJZNFlNNmVmeisrSFlXUHJDMnV1ZXZzenRuWC9Dano1U01QdzUrc3U0M0hkci84YndGYU1mTzNUK3NkR1RJcm93eFd0bXlyWG5DeEg5ZFc5M2pEUU1hdXl6czZ5UWRYejk1VEVmdXY3MnVENm1Ua3llT3Vqc0wyeVg5VWpESnIwcjZTbEhGVi9yVHZ2c2hEMy9waXBRZldubXBNV1pqWmFWVndOK244cDVVemtqUHltOTdPNExsc2U5cjkyQW5iYzlwaXl2WEFnQ0FLcDB1ZWhWL0tsN0FkQXVjNWVYMGU3SnRrTVVhcS9qKzBRanZoTnZrdjNuR2kzaURwSDBiSjQvcjZPSDlOWk5KU29aOHo2dmo1MXh3MVlxa1g0NFVkYjhzayt3NFNOS09uYnRQbGJTN2FlRlZqRmJhQnZ6amtuNCtmTEFVOEcrNGJ0ZU5rdDVuTjA3cStOSE9RMUZXMnRnNEVRNzM4MjkzN056OXpPek9IYmQ4NklSa1hwM2NLMTRnWTh5VEpMM1EyYjYvTVZwNWY4dGYrbFZycTN1cWZ3bGpudElxWm9mdnVQeng0TTNuN1JTa0U4UVdWL01JdmZjQUFLQ3pLVWZUU1g2RUdTUWNUU2ViTEF6NlJsNEZYVTBuMnhaelpRK0dGNzVxWDhWM1YrQmNoTXVZcDFUOXRqZGN0K3NlV1h2MSt2b3huVGpXZUYybFY2MnQ3bkVEN0l1TVRHeW96VmZkZGNmSDNCYWVWMHU2TkRKZE84Wm9aV1dMakluVjRqM3ZYVnZkYzJQNFlOVmN2MkR0eGpjMk5rNU12RjBsZHNOdDBjbThhOGZPM2ZrMjNQSE5ELzZSalBudmtweGROeU1aOCthSFh2YVR4Vm0xeHZ6c3lzcVcyeHArNlQxcnEzdCtxK3JKUno5cGw1RjBwWDl5YmZaR0tmSzh2L2RhWE93aDNaRHNsNHYrQTNEbkliY0RBSURONUJjTnMrQmJNNXFPTzdWVG9hNGZUYWNJNGJFcXY3ODlLdkpkL2o5VDJzNXlGZDhaT1NlczRuc05GYzVSQk9sSkYxejY0NVViYzhPZWEvNi85ZlhqZjJwdDdlaVExNjJ0N3NtSFdUL25ncXZPa3V4L1NyZFN6aC9rais2NjQyUDV4VlIzN054OW9hU2ZyVnR3Rzhac2FXcEpYNVgwcHRnVDBZUjh3M1c3N3JKMjQzdnN4dnE5MDI1Y3hscWJqS1RqWFMxTlQxSnlFU3ZYcTQzUmlYeFBMZm43WFNCVEhINjQ0YnBkZDh1c3ZOS3NiRldGK3lXOXJPckoxQlhLTHA2bE5JaDc3MXozamV3T3laUS9uYjlSdzhOTDVUdnUvbW8yYzJ4bmdMMEFBQUN3eWJMc0h4MFQzd1FQT1JYMGZCNjNrOEhOL1VWUzkwY3FkUEpRNmVpQXV3M0IvTEVxdnR3cWZoRzZqWFNXWkI1VjkydmI5Wk12azFSVndqOGk2U2VEeDk2Z1pMQVkxd2xKcndvZWU3T2t6bU5jbGhpamxlcXNlNCtrNzExYjNYTlg3TW5LRXZqbi8rS3QveWpwK1pLYUI3NmZ6bHQyN054OVJuYm45cHMvOEdYSnZNYzkyU045Z1Y5eDBlVS85Y2hzdXM5OStzMi9KYnZ4eHlvN3F1UVgvbHJ0V28xNXNxbXIzdWZyVlJyaXEwNnVWZjVtQ25acmExZmZhcnJLM3Z0d1hRQUFZSGxVWklDMnhjTm9GYi9JUEQ1bk5KMjZrMjNUUXFsYitjOENkL3hrMnl4enVaWDVvclR2amM2VGI0ZVR5NElxdmdtblRXN1VYbERxUzMvN243OHM2WHVVWk1mUWYxcGIzZk9ON000NUYxNzFLQm05M04wcFNYUGpyOTUxeDhlK21rMzNxQ2UrNEVwSlY5V3R0elZyVlhHRVlVUFM4OWRXOS94ajFheTFQUzVycTN2K1VEMGNZcEFrWTFhMFpldjJ5QnRIRDFFeVBLZkR2c2xJZC9wSFArdzJTZTkwcDlyWU9QbFRTdmF3TWljay9idTExVDEvMm1LVDh0NnNjdlUrWDJkNVA3WjBjbTE4R0tsOHVjNWk2NnIzQUFBQTdiVVArWk11MngwVHYvRmsyN0F2MzdqYjRuUkhlRU5tWnMvNWVjdTc4RlhwS0lDL0RkSGUvZUtFMjhvKy9NemE2cDQvbC9TRFNqSms1aC9sRE5XZWVxZWtzRjltdjRJV21aV3QyOTZwaG56ZGx0V0dOdGFqN2ZMWHJLM3UrYU82ZVJzM1lHMTF6eTlKK3VDRTI1WXpLN1ZqMTErOVkrZnVTN0k3dDkzMGdVT1NTVWUvOFE0RmZjL0ZqM3haUHV4UmVsTEJmMHp2cmt2NkQrbE9TZlAyR1BOay93aUJ2RGRpOHA1MkQvbjQ0ZDk0VTZadnBOSWVyYk5zQUFDQXVhcnJHc2greEhZUXVweHM2NjZtK21UYmZNSzhpcStnaXU4dmI3SXF2cW10NEdmV1Z2ZDhTdElMbEZUR3N6SHY4MlI5N29WWDdaVDBiNHJmTFMvd3Z2NnUyLy9MM2RsMEQzdk05ejV2KzZsblA3dk5PcHRaMlkwTjkwS3htUStzcmU0SmR6NUtXdTFockszdWVZbVNTdjdFN1Rvcks2ZG8rMmxuVnoxOW1xUzNlbzhZZmRCSS8rQVYxWlBYL0YyWFBPcW4zWWFrdDB2NkIway90cmE2NTdjN2JOS2pqVkgrYmpPbGtGNnN1SG5zKzFEVzBtTXFubyt0Z3gwQkFBQXdUMFY0emg5eE9od2FUN1pOSy9teEtuOXBMZTZRbWZsUmdzZ2lXMWZ4M1hWbU93cDZkTnZmUEIyWTVhV1NQcnkydXVjdnM4ZlB2ZkNGV3lYenJzZ3NuNWRUQUwvbzh1ZHNXOW15N1czYlRuMVEyMVhXc3RiSyt1RitROUt1dGRVOUwyMHpmK3REQ0d1cmU5NHE2ZnNsZFQ3eDFxeXNhTnYyczdSdGUrMGxkNSsvWStmdXAyWjM5dDM0dm5YSnZGTHlYemdqOHpnWi9ZU3pYU2NrL2ZPMTFUMGZhN3M5ajNueU5hZEx1aUJaWXVUazJyQTl4NFJ2SU1rL3ViWnE3UHQydUhJdEFBRG9ybDBtYUQyYVR2VWRsWXVXWWZYZWJkUEpjbE0yV3hqUTNYaHVpOXY1Wk4ycitGN3dMemJqd2dzZjl0TFdsNE5kVzkzeklhbkltT2t5ZmxMU1k4dS91bm5sd2RzL21oZStWMWEydm56YjlyTXVYOWxTZVZKc045WnFmZjE0ZHU5ZVNkK1hkdFcwMHFsSGFHMTF6eWVWWEpHck5ONW03VXEyYk5QMk14NHNzN0tsYmpJajZkM3VBN2ZlK040L004YjhudVRzeVNXVHZ1blNSNy84SEdlN3VnM1liOHhsN3F1Zi9MQitMcy9IVnkzTjZ4NTVVcjdYNlIyT0tnK05tYitWUy8xb0FBQUFrK283VDhRR0ZwR2lKOXNxS0g3bVc1TmxLaWRybVZoSFJQRmNscWxLSXhPYVlwTHN3VmdWUDl3Q1oxc3VpNnkwMHRycW52d0tyK2MrNUlYbktqNE01ZThldlAyamY1N2R1ZmlSTzg4N1pmc0Rmdjcwc3k2S2JNOWtyTjNRUmhMd3Z5SHAyOU0yb3RZNm53U3d0cnJuaTVLK1RkS3ZTU28xQmtVM2NtTmRKNDYxS3Z3L2JjZk8zYzhQSHJ0YTBySDhSVS8yN001UnhiaWZMVDNDYTY5M3JseGI3Q2dHYjlnT0o5ZG1TNWdZVjY0RkFBQ1RhaHhOcDZhS24wOFNCTzI4amNhSjFhWE9CdVVGVW0vZURpZmJaamVOWDluTjE1OXdxL2lxcU9Mbmh3TWVFZnYxV3JwVzB0bkZ6b2VrWk1TZHE5Mkp0bTU3d0p2T1BQdnlCNTV5eWhuaC9CUGIyRGg1NHNUeGU5OGo2ZHZXVnZkOHFldjhFNTNsdTdhNjU4RGE2cDZYU1hxc3BOOXBtbjVqL1lTT0hUbW9ZMGVpUTNXRzNycGo1Kzc4Y01yYTZxL2RhSXplR2RsQis0bUhQZVlWait1MDRZVkhaQXNKRlcvTzlGN3R5YlhwcmJEeUgxc20xWHNBQUxCWnBpd1V4c2ZFMzR5VGJkdGMrTXF0NG9jN0F1NktyVXllK2JwNThFTi83UEZLZXZMRDViN3o0RzBmM1pzOTh2Qi85djJQTyt1Y3kxK3k3ZFFIUmpQZ2hINTdZK1BFWTcvKytkLzQ2YlhWUFFjbldjQlV3L2lzcmU3NTJ0cnFuaCtVOURSSm42NmI5dVNKKzNYL1BiZkV6Z1lPWFNycE5mNUQ1aTFHWmwveFFrcEcybXFNWWljOU5ETEdYT2IxaFRuVmZIL3Z0T25rMnZJYmlpdlhBZ0NBeFZkUnhYZnpUVjFnclR2WjFqalBWNFp2cHgvZkMrcHRMbndWL2c3QnBucFZmRjFXL1V2VWVyZWtzTGY4VmlPOXhYM2dySE1mOWM3dHA1Mjl4WmhlUnNiOHRLU24zbkRkcmgvNjNLZmYvUFZwRnRUTDFxeXQ3dm5idGRVOXo1YjBHRW5YU1BwckJhK1EzZGpROGFPSGRPVGUyOW9zOHBvZE8zYy9KTHR6eTlmZmM1K3k4ZmpkNnJyTWN4NysyRmQrN3dTYjdPek5CVFg1cGoxVDd4MVVkWEp0NU0xY3NTZk42RGtBQUdBUnVWWDgwbWc2emxUbGVmekt1bit5YmZKQTBDQ1IzOGdLci82UW1iRXF2dE5zNGEycm1DZlZ1WUwvNEllKzZQc2tmV2Q0WkVMU3p4NjQ3YVAzWjNlZS9DOS80YnUybjNiT1RtTnF6ekd0WTVWazVtc2tQZWFHNjNZOSs0YnJkdDB3NmNKY1BaM3FtMWhiM2ZNVlNic2w3YjdvOHVkY0tPbDdKZjByU1ErWDlOQ045ZVBuSDc3dnRwVnRwejFJcDJ3clhjRjNYZEtYSk4wZzZlOUtDemZtWTBiNktVazd2SjFMbVhkYzlyaFgvZkdOWDNyWDhkSThWZEorTEpNRzc5SUw2TzZCNW8rVmRnV1V2K0hxVmxYelNDbmNWeDVPWXljQUFBQlVLVmUrazRldFpQM2NZU3ZQSFF3WFY3SE1yR2hweThWUTZ6MW1sWjFzYS9ObHBibkxGbHVSck1vVXkwdlg3VzZwTWRaZlJ2YTd5Wi9QS0x0cmk4M3MySU4vM2tVdjJtYXQzaEg1dGY5V1ZoOTNIOXF5OWJRdlMvcHhTVHNrUFZYUzQxU3UrbWMySk4waDZWWkpleVg5c2FSUDNuRGRybGFWNzY0Mk5UbGVkUGx6dHF5c2JMM2d0RE12Zk9nRHo3M2lYR05XN3BWMFVOSmRrZzdlY04ydTZPVzZNcGMrK3VWUGs5Rm5qSXpKZTYrU3ZjRFhmdU9MNzJvYzlEL3oyQjAvZDUrTU9jUHRCOHQ2dnNJVE5QTHc3NXc4NHUzRk9ydWRSUUhmL2NlVS9qZlNmMC9BQndBQS9hbklFZFlFVXdVRGhhVGgyVys5eUtZMGtpMHVnNVNGK09SbkZ1cHQ4di81YyttOE50a1JjTzhuajZYanZKZW1TeC9MYnN1ZDFybXRZdnAwRW1kK1p4dVNhZS9mZCtQN1NsWGxLdWRkOUtMWFNuWjN0dDlnOHowR1BmM0F2bC8vbTdwNWQremN2VlhTMlpMT1NmOTNscVFEU2tMOTdUZGN0MnU5WnZaZURTNDVQdXd4TC8rRWpQa1BYaGczNWg1anpCV3JYM2pIN1Uzei83TnYrN2tMakRHM1pUc0hXUTlZRWZJbG1aWFNHZG5aZE1uZWFLU0NiMVlVdTdnVkFSOEFBR3lPcmdIZm1TY2E4ck9BYi9QcDhpSjlWb1YzZmlZL3JQTllHTWpUeDdTUjN5L0NlM3JmbTlZTjdjWDAvbktUSVNXVnp4dnNFQ1FQWExCdjcvdnZhUHJyblhmUml5K1E3TVB2RGVvQUFDQUFTVVJCVk5ja2U2WjdNTUphKzRrRCszNzlCVTN6TDVKZWV2QTMyUzRqM1orMFYrV0hhczZTOU9aV2N4dHptVlQwYTVXdVhHdGk0Nzk2VFRuRnJYRGUwbHpwZnhrOUJ3QUFERTZhaVVyOXlQSFJkTXFzVS9lc3prQlpoNFRmVDk5MkZLQ3N1T3IxM1ljZEdaZTFXcFN4YjVGMFp0RERmNytTSHZsQkdWekF2K25MdjdJbW1kM0pQWk9lWFMxSmV1RWp2K1hxSnpYTmIyUWZrWitWa1M5RFNvWlM4dDk4NVpNcnFrYlBrV1l6ZW83L1pnVUFBS2cyU1did2U5cTdMTUdrd2JvVWpkd3pZcDExdEx1eXJUTk4xbDFSZTdLdDAyRlIvZnMxOXVHZmYvR0xueXpwcXNoVGJ6Mnc3OWZYbXVaZk5JTUwrS20zR1ptYmtwdDVxODZLcEY5dW5qVTkyU0pzaDJrYSs5NGJsN1Y1OUp4eTlUNlloZUFPQUFCNjEzKytpSSttWTRKVlpjOGJaNTRzNzlqeXRNWXBqc1pYcWpBdDFRK1o2U3k2UEVSUG14TnQzeTJsSjJmbTY5SmVTVzl2TWUvQ0dXVEEzL3RQN3o0cW85ZjZyNStSakhuR283NzFaLzU5N2N4R2wyVlhydTAyOW4weGJadjJuTmlLdlcwRkFBQ1lnOVk1cEtKckllR2NxSnVmdU9qTzY3VGFoR1BpdDd5eXJWZlJkMXB3M0F0cG1YUWJzcU1KWHQ3S3pyVnNHQXYvL0V0ZS9NT1NuaEY1NnJWMzN2cVJvM1h6THFwQkJueEp1dkZMNy9wdmtxNzNIN1dTekM5ZGNlV3UwMkx6cEx3eDhMTTNSdlBZOThFWjUrNjBYTndLQUFBTVNPZGlveHV3M1lLbkY5MkRWbWV2ZjkrZnQycE0vSHphdkN1bmZHVmJHYmUzUDN2TWI5TXBjcHhWM3IwUmNjRWxQMzZhcEY4cVdvZHkxOTk1NjBkK3UycStSVGZZZ0o4d3J6VEdiT1FuWmlRL0w1WDBNNVZ6eUR3aUdmdmVmZERaNjR1MTU2am1IMExseGEyNi9CcTJzcFVIQUFCZ0tvMFp3NjJzQjRrbkw1WlhMTU5JdFVYU2ZCSFcyVEZJZndadE9sbExkQkcyM1FKcnR1eDJiVHJCZkhVdE9xK1ZkRW53Mklha1Y5VE1zL0FHSGZDLzhjVjMvcjJrajBUMkduYzkra203TGc2bmYreFRYM2VLWkM1MjNxM3BqMzdiYy9MdFlmUWNBQUN3Q0tZcUpCYlZkcC9UWjk5MHNtM3BvcUxsTmgzL1pGdDMyZG5UOVcwNnhUTGNvdzFHTXJyNG9aZjlST25pcmhkYytwSkxKTDNXejN0V2tqNjhmKzBqbjZ2NmF3ekI0SlBuNWQveW12T056TmRrZEpZeEsrNlk5cjluakhsWEZzalRGL2djbzVVL3lONGsvdGozN29Xc25NTkdrdk9tU3U1TWMzR3JkQzcvbHlqOW94djh5d0lBQU9ZcUV1aHJ4OE4zNWduSHhJOWM5TXEvYUcxNVRQejhxcmJ6R2hPL2ZOR3I3N1d5ZDhsLy9OV1NmVjUrTGF0a25YZkw2b3I5YXg5dUhEZC9rWTBpU1Q3eWlWZGZiV1RlbG9YelBMZzd3eThsRHhtbjE4dWZ6ZzNyeGRpcHNUM1NOaGUzTWtGb04vNXpJUUkrQUFEb1haQXZwZ3o0VWhic2c0dGV5UW5oemhQK1JhLzh3RjFjaU1vUCtObjBSWGpmNlBtaVYvNXpDaCtUdlhyL0xSOSt4eVIvN1VVeTZCYWRndmxsR1gydHNrMitOSDY5eWUvUHBqMG4vZ2lqNXdBQWdFV3hxYVBwQkcwNnljTnQyblNNRzhQYXRlbmtTMmpUbHVUOVhsK1Y5Q3N0WmxwNG93ajRYLy84MjA1STVzM2VSUkVhNWluZXE0eWVBd0FBbHRPbWphYmozUFBYN3JSRmx6YWw2TC8zcHMyZks0K200N1ZkbDRxMWtqZlNUdm0zKzhYOXQzejRSUG5oNFJsRndFL2RKYm1kTk83VjBkSTNoYmZ6V0x5aGdpZThOOHZtanA1VC9LTUJBQUNZVHRNNWZ4WFRMOXhvT3BIVlZZMm00eFZuM2Uwb3duK051K3FlSEpMeEJQek83VGwyUnUwNUpuTElDUUFBWUI2Nmh2d1d5K3BwTkowdWJUcHl1aWJDSFlmYUxmYkh3L2UzT1Z6TWlHTGJhQUorOS9hY3FqMDhGKzA1QUFCZ21kUlU4V05UdXczeXNlWGs5NXlkQUsrdnBsMmJUallBaWwrMWQ3WXdYNlFUNUNzM2Z2emhiVFFCMysycDhpOVZYTHhSUzIrYXV2YWM0TXBwcFF0anVjdjJabzd2R1hPQ0xRQUFHQU5UcW9iblQ1UWZpaFpQYlI3UDh4bUROcDJxTlplYWZtSlh0VTFXTEsveVg5NndoblVOMjRnQ2Z2Q1NHeWUvdTN1VzZkNWYxL2FjcXZWVVArcSsxY2I5SmdJQUFNTTEwV2c2ZFYwUEhVYlRpYXdnMmFKc3VqREhlWXVNOStHSE5mN1M0aFZycFI1WFZodFJ3RS9VeCsvc0xaeU9lK3BPUVhzT0FBQllVcE1WSTlNSTdSUkV1NDZtay9YaFY3WHBGTG5OK2RuVWg5K3FEYnUwS2FNeW5vQ2Y5dDlIMjNOSzA3cmwvY2llWGVPYnBtYlpyYmFWMFhNQUFNQm1DVEpHMnhOdEp4NU5KM2lvTkpwT0dzQ0wzbXJWdCtrNGxYejNLRUxZaDQvY2FBSisrU2lRODZKNy9mZDFid0xqdkdYY3cwVDE4K1o3cVZPZG1RNEFBREFyRTRiODJrVzI3MzRvVFJjYnE3NXhmYkhwL1VKdDA5SjZLTk1Pd21nQ3ZxU1Q3aDFUMmpQTWZwU0h4NHkyNTBUZlJEVjdyQUFBQUtNd1hmeHROVnhtNDdxZGNldnpQdnp5MXBtc0s4SUw5LzVJT2lic3ZxaGUvOG1xSjRabVRBSC9la24zbEI4dTErUnJlUy82cEdIZWZST09mUjhSQUFBc2wvTEpxZDV3bWJHZW52eGU1TnpHdEE4Ly9vVGJoMS91clkrdFkwTDNTUHAwSHd0YUJLTUorRi81N083N2pQUTZOVjJGTEQveG90eC8zN2dyRU92WEJ3QUFHQUVUQ2U1dHg4TXZxeStTZGg4UHY3U0FtZ2RiWGJYV2RaZWsxOTN4elEvZDEzYUdSVGU2bVBxWXAvemNhY2JvYWNhWUxkbGhtZlFTeFM4MVJ2OU94ZjFpRkNmMzhJL3gzeFQrK1BjcnlzZCtkYnQrU3YzM0RTZDlsUFpTUi9jeUFBQ0FoUlBrRDF2T0g5YWJ4anJUK2MvSVd1ZEg3SGFTbDZ5MXpyVEpiWnRPYkoxbEpNOUpWaHZwYzhsaitUeldtZC9hWkd1Y2FmTDUzWGtVekdQMU83TDIvY204K1RMWEpmczN0OS84d1NPVC9sVVgwZFo1YjBEZnZ2eS8zbkpFMHArRmp6LysyOS93dzM3clRIaVJocWJxZk5zUVRsZ0hBQUREWkdUQ0tGODVaVDdtdlkwTktWNGtMZXQyMWhpVDNxNmV0M2FWR1craDhVMXpKczUrSHJyMXh2ZitTZnNWRHRkb1duUWFHVDBvK1JIMGdqSCtQUUFBd05TOFBuei9tYXFKbTVkWjhXaDVEZUVvUWRFNUg5UnFwU093UEFGZk9qdDJnU3RKVHN0V216ZmJGT20rTlA0OUFBREFuRXd6SG43alBIVlBOWjFvNjR4NlU3cWliWmVWbGRaemR2VldqY3ZTQkh3am5lMmZKQnVlMVozOWJIR0NyVGRQMkg4UEFBQXdFRk5tbUhMTHMxVFZEUkcvNEpVSkhva1BaUmtmSkxQTjlua0krQ09VSEpZeDRadHBuaFpwV3dBQXdMaDF6UnkxWmZpV2kyaWEwQWJMY2dZeUtjMWFzelBTYmtlRkZwMFJhcmZYNXZTUHRidjZiV2xtQUFDQUJkVm5WcWxNNHVtekxjSjl1S3o4M29SSEZ1cFhTUVYvVEI3LzdXOHdram1yK2dxMnpXOTJUckFGQUFCTGErTHg4TFA1M2R0VjdUZHRoYTAvclhjR0h2alF5MzV5S1pMY1VnUjhTUTlVTDc5cmk3UEM4MmVXNHYwREFBQ2cvTXhFVTl6Mm40bFAzK0ZpVkgxWWtYVFdacTV3WHBZajRKdTJoMlFxaHNpc1BNRlduR0FMQUFCR0pYcEYyd21XVW45ZkU0VDdQbllHN0ZLMDZTeEh3SmNlMUhUSjVENzNJS25lQXdDQTBXdUtPeDJIeXB3OUl5M0ppYlpMRWZCTmZsSkYxa2NmdjJydGRNRzg3bDBjam4vUDZEa0FBR0Jld290Q3hhOUUyNCsyVjhVTng4S3ZualMrYmFadHRLS0NQeUxPR1BnRWF3QUFzT3lhUTM3YjVjU3I4ZkhsaFdQaDF5MTNSZ2o0STFKN09LYjFXNGg5QXdBQXNLeE03S0pXbTdEYXFnZTlKMXJ2b05DaU15SWQ5dFk2aklIUENiWUFBR0RKeEFOM1hWN2FwRkVIMjhVeUt2Z2o0bHpGTnRSaERQeU84d0VBQUdCK3dnUm5xZUNQU3E5N2EwUjdBQUNBdU1xQ2ZWMkFxdXljNkdNQWxPeW5sYWpnajBxN0Y1UGtEZ0FBRUpnOElHVXRPUFZMbUtEbGVmSXVhUUwraU9TSFk2ckhYWjJtbjU0OUF3QUFnTUltREFrK1dYU2pSV2RFZXRoYkk4UURBQUI0WmhDUHBqcnh0aFQ2U3c5UXdSK1JwWGd4QVFBQTVpSHBrSmhQTWRUYWhnWWdtNGI4NU1kU1pNSmxDZmhMY1RnR0FBQmdLWVVoMzFiMjd5eEZKaVRnQXdBQVlHSFlxYzZMZEJjVVhRNFYvREY0L0xlLzRUUkoyK2U5SFFBQUFPaksxdDV0TzdzdHd2NzJoeno4cGFkT3VWRUxiL1FCWDB1eXB3WUFBREJHNVl0Vk5hVDg1cDJBMFdkREFqNEFBQUJHcFNIamp6NGJMa1BBcC84ZUFBQmd0THIxN2RnbHlJYkxFUEJIdjVjR0FBQXdEcE9kWU52NnhOeWtGMy8wMlpDQUR3QUFnQUZvRStKdHpYVDU0NlBQaHNzUThEZjFNTXhVVjE4REFBQllPbWJTd24yTjJnWFNvak1Dbzk5TEF3QUFXQjVURmxPdEhYMDJYSWFBUC9xOU5BQUFnSEhwcTZTZkxjZTRQMGVmRFpjaDRJOStMdzBBQUFCaG1JOC9xeVhJaGdSOEFBQUFMSlBSWjhObENQaWpQd3dEQUFBd2ZrWmRXbmVxcHpTano0YkxFUEJIdjVjR0FBQ3dUTnJIL0t4ZHg3by9SNThObHk3Z1c0YXhCQUFBV0FpdEwxQlZzd1QzVnN1bEVmQkg0TXo4bHUxOWtGVUFBSUJSbXN1MWZXeGY2NnhkenBsMVQ0N0JNZ1Q4Ylp1MUlpNXlCUUFBTUpuKzY3Q1ZDOXkwYkRndkJQeE5aVFQxeFJrQUFBQjZFV1FTczdpZERqMXYyUUpsdzlrWWRjQi8zTk5lYnlTN2RkN2JBUUFBc0ppR0ZQSjcyN1pUK2xyUW9ocDF3TmU4OTlDTVhlaC9LQUFBQUVzaGlHTVhYUHFTVVZmeENmZ0FBQUFZa0dTOEhHdWRvUzg3REtHVEduVkdISHZBSC8waEdBQUFBTVRaNmpOM1I1MFJ4eDd3UjcxM0JnQUFnRUFRNml0Qy9xZ3pJZ0VmQUFBQXkyYlVHWkdBRHdBQWdHVXo2b3hJd0FjQUFNQ3lHWFZHSEh2QUgvVUpGQUFBQU9qS1NpUFBpR01QK0tQZU93TUFBTmdjNlFXeHhuTjluMUZuUkFJK0FBQUFsczJvTXlJQkh3QUFBTXRtMUJtUmdGOFNISG95cHA4dEFRQUF3S0lnNEEvWUtYblBtRVJZQndBQVdGQ2JGOU9NeEVtMmcxYmFPek5oaFI0QUFBQWQ5SmZFVGJpc3pUdUpsd3IrZ00zdXhSdlBXZVFBQUFDZHpMY253a2d5TWxVbC8zYUhBZ2o0QXphakY0OVdId0FBZ01Vd1VTNGo0QS9ZcUY4OEFBQ0FaWkRXN0pzbUtEOXNLaXY5bzg2SVl3LzRvejZCQWdBQUFCTVpkVVljZThBZjlkNFpBQUFBV2lnWDhVZWRFWmMyNEZlZW1BRUFBSUFaV0tqc1JjQWZzRTE0OFJicXpRb0FBTkNiMnI3M1lTUGdEOWlvWHp3QUFBQk1aTlFaY2V3QnY5MEpGTFRyQUFBQTlLOVZ4SXBkVzJqYWJHYWJsc0ZKdGdQV2V1OXN4SWVnQUFBQVpxZ3FROW5ncHp1TDhaL2IvQmhHQlgvQStudnh5UDhBQUFBOTZocXVpcXA4TWFkL3E3ekUyTkVCU1FUOFFSdjFpd2NBQUxBd2VtbDUzclNLNnFneklnRWZBQUFBSTFmYWNSaDFSaHg3d0IvMUNSUUFBQURvSWcvNm84NklZdy80dmUrZDBZb1BBQUF3TzMwTmZOS3dGQ3I0QXpiQmkyY1lOUk1BQUdEY0NQZ0RscjU0RlluZE5PM2RrZlFCQUFCbXFuVmxOUmhhcy9QekhnTCtVQmxUdkhpVEh1NHg3ZDRrQUFBQW1OQWNTcW9FL0FIcjZRUUtLdmtBQUFDekZjdGIwM2JreCthMkVpZlpEdHFvOTg0QUFBQVdTOGM0UHFjVEg4M0lNeUlCSHdBQUFMTVZDZktiMndadHcxMlBVV2ZFNVF2NFZYdUtKdjhQQUFBQWVoSTIyWmk1RGxlWTcxUVE4QWRzMUM4ZUFBREErS1E3QUxFZEFkTzJLNzl4bWxGbnhMRUgvRkdmUUFFQUFMQ0l6TFNkRVoxbW5XZzlvODZJWXcvNG85NDdBd0FBV0FvTmJUMUZWZCtvWmVBZmRVWmNrb0J2MWZLaUJ3QUFBQmcvQXY2QWJlTzhXUUFBZ0dFeVJ2MFBwWmtzajRBL1lLTis4UUFBQURBQk0rNk1PUGFBSDV4QUVlNEJVdDRIQUFCWURsN3U0eVRiQVJ2MWl3Y0FBREFVQzFGV0xkcDlScDBSUnh2d0gvZTAxNC82MEFzQUFNRGc5Skh5alJvSHkybXhHblBCcFM4WmJjZ2ZiY0FYL2ZjQUFBQ2paOHpFSXlXT05pc1M4QUVBQUxCd1REakVlVjFaM2czNTdZOFNqRFlyampuZ2ovYXdDd0FBd01KWWlPYjZpWXcySzQ0NTRHK1QwdmZjcE9PbjlqM3VLZ0FBd05BWnF6NVR2Wm5sSGtKazBjNURWUEFIYUp2M0V2WVoxaWZ2OVFJQUFCZ2hVMjZwNlRqLzVocjN4YTVHSHZEYklyQURBQURVRzI1bmc0a1hlZ240QXpUQmk5WTE2QS8zalE0QUFEQjdwbE5jMnVUdWFBTCtBSTMyeEFrQUFJQmxWUFRySndQaFYxVG1rejJGNXIyRjBXYkZNUWY4MGU2VkFRQUFZR3FqellwTEZmQW5Qdm1EVGh3QUFJRE5VVEdZU1gwY000MVh0NDBnNEEvUWFGODBBQUNBaGRTbGlYNyt3NUdQTmlzUzhPZi81Z0lBQU1EbUkrQVAwR2hQbkFBQUFKaTNFWlJJUjVzVnh4endLL2ZLS3MrNGJtVUViMmNBQUlDbFVEUFNEaFg4UWVyOVJTUGFBd0FBVEdPaDBoUUJmNEJHZTlnRkFBQmdQR3p5djFsbi8vTHlSNXNWeHh6d3Q4NTdBd0FBQUxDd1Jwc1ZDZmdBQUFBWUNLdXNGRjhVNUt0Sy80M1hQeHB0VmlUZ0F3QUFZQm1OTmlzUzhBRUFBTENBdWpmbGQ3eVk3WmJPS3hpSU1RZjgwYjVvQUFBQW1OcG9pOEZqRHZpamZkRUFBQURHYTlPRzBoeHRWaVRnQXdBQVlFN2lZZDVzVHNnZmJWWWs0R3ZUM2tRQUFBQkxxbkZFbTVrdzllc200QS9RYUY4MEFBQ0FZWmhQc0c5cHRPZHJqam5nYitxTHhsRUFBQUNBUlZHM1k1Rm50dEVXZzhjYzhDZDYwVXorbWhQWUFRQUF4c2xLQlB4QlNsODBNM0YxM1N6MllTVUFBSURoTTBZeWJkTmFObFZWUnF0YlN1azVBdjRBZFh6Uk9sNGFBUUFBQUQyYmJSWUxsazdBSDZENkhueERuQWNBQUJpQ0dXVTJUcklkb05IdWxRRUFBQ3c2RTZieTBnTnpOOXFzT05xQWI4d2l2V2kwL3dBQWdFVzF0QmxsZ2JKaXYwWWI4RFhpRncwQUFLQmZpeGJ5dVpMdE5BajRBQUFBV0V5bWp5NkkrUHlHSHZ4Qkd1MkxCZ0FBZ0ttTnRoZzg1b0EvMmhjTkFBQUFVeHR0VmlUZ0F3QUFZQzdtZkZIUjBXYkY1UXI0aXpjOEV3QUF3RUpyZTQzWlRzdWNKcE9aMkRiRjdvZVAyZUFuQVgrSWVuclJtdCtBczNqakF3QUFETVlDUktGMmVTeWRKdG5CR08zNW1tTU8rS045MFFBQUFKYUtNUjA2TVZydmJWREJINkN0eWVzNzE5NHVBQUNBcFpIMDFDOUFPYjhkQXY0QU9TL2FKb2Q4WTVQL0FRQUFETTN5WkJnQy9nQUZMOXBnOWlZQkFBRG1hemxDL21qYnVaY280QU1BQUdBd1psK2JIVzFXSEhQQUgrMWVHUUFBQUtaR3dCK2doaGZOUkc4Q0FBQ2dYNU1PS1c1a1oza1pJd0wrQUkzMlJRTUFBQmlHeUFXbkZxZXdPdHFzU01BSEFBREE4akhqYmVjbTRBTUFBR0FaalRZcmpqbmd0OXdyVzRwaG9BQUFBT1p1NnU0YzQveDB1bjlNT0t5bmFiVXVBdjRBamZaRkF3QUFRS0Q3MlAyanpZb0VmQUFBQUxTVWxjd0gzQUZSRE10REQvNEFFZkFCQUFCUWtrYjgwV1pGQWo0QUFBQVd3S2FQbnpuYXJEam1nTC9GU0dwL2RZUUJIMm9DQUFCQVZ3VDhBUnJ0aXdZQUFJQ3BqVFlyRXZDcnpQQzZ5QUFBQU1QWFgxWXk4N204TFNmWkRzbmpudmI2RmJudnVqN0QrcERQR2djQUFPalJ3cGREVGUyQStBVDhnU2xWNzAwdlBmWUwvellHQUFCQVN4ZGMrcEpSdHVtTU5lQnZJWXdEQUFBTXp5WjNTUlB3QjJTVUx4WUFBTUJTMkx5VzZGRm1SZ0krQUFBQUJzaElNakpWSmYvR1F3RkdHbWtmUGdFZkFBQUFJekJSYjg4b015TUJId0FBQUlPUTF1eWJKdWhpbEpseHJBRi9sSWRiQUFBQTBDc0Mvb0NNOHNVQ0FBQkFkOFpVOXVxUHNpaThkQUcvOGtRTUFBQUFqRnM1Qm82eUtMeDBBUjhBQUFCSWpUSXpFdkFCQUFDd2lSYXFtMktVbVhHc0FYK1UvVlFBQUFEb0ZRRi9RRWI1WWdFQUFLQlhveXdLRS9BbnRsQ0hsd0FBQUJaWHE5aGtaNzBWTWFNc0NoUHdBUUFBTUVNZGd2dm0xMDlIbVJuSEd2RGJIVzR4cHY1cWFBQUFBQmh3WHJKcTJHc2c0QS9JS0Y4c0FBQ0E0WXBVOHVkL2ZTSjY4QWVFZ0E4QUFEQjRNOThCR0dWbUpPQURBQUJnenVaeWdxMDAwc3hJd0FjQUFNQWNUVktsTjhHY0p2SnNLNlBNakdNTitLUHNwd0lBQUZnT205YWJUOEFma0ZHK1dBQUFBT2kxbldlVVJXRUNQZ0FBQUhvdzl4RnhKSFhlaWxGbVJnSitrOFY0cndJQUFLQi9CUHdCR2VXTEJRQUFzUERtUDdaOUY2UE1qR01OK0tQc3B3SUFBRUN2Q1BnRE1zb1hDd0FBQUwwYVpWR1lnQThBQUlCbE5jck1TTUFIQUFEQXNocGxaaHhyd0FjQUFBQ2FET3FNNExiR0d2QVB6M3NEQUFBQXNQQkdtUm5IR3ZEdm5mY0dBQUFBWU9IZE4rOE5tSVd4QnZ4UnZsZ0FBQURvMVNpTHdtTU4rS044c1FBQUFOQ3JVUmFGeHhydzc1bjNCZ0FBQUdEaDNUM3ZEWmlGc1FiOGc3MHR5ZmEySkFBQWdQR3pnd3BQaCthOUFiTXcxb0IvMTd3M0FBQUFZTGtzUnJEdnVCWDlGWVVYeUNnRC9wZis1ai9lTGVua3ZMY0RBQUFBVFdLUmZMcWRoWlp6bjlSSTI3cEhHZkJUVlBFQkFBQUdvY3YxcG1MVFRyUkRjUEQybXord0dJY2RlamJtZ0gvbnZEY0FBQUFBbVVrdUdsdVZ2M3ZKNVFmNldNZ2lJdUFEQUFCZ2htcUMvWlFuNUU0WjgwZWJGWmMrNE5zRk9TRUVBQUJndEZyRkxUT0Q4M1JyanhvUThBZG9mK01Vd3hyR0NRQUFBSjFWNWowQy9nQ045a1VEQUFEQTFKcUx3UU0xNW9BLzJoY05BQUFBVXh0dFZseTZnRzlweXdFQUFPaWszM01XTnorTDVmblBYelVCZjREdTZIK1I3QndBQUFBTVVhVElTOEFmb05tOGFEWTdHNXV3RHdBQWx0dG1wNkdlMXplRFl2QmlHSFBBdjkyOVl5ZTZ1QUlBQUFEaTVsUHNMTnFGYkhMUE92ZXRzMW1OYmRtV2dEOUErNVc5eFBUZEF3QUE5Q0RyWmUrM2NHcWRaRzV0ajh1dnpvQld0T2dNenhmLyt0cVRrZzYyRC9mQkc0bWRBZ0FBZ09HTFI3cTdicnZwQXljMmVVczJ6V2dEdmlUWkVmZFdBUUFBWUdLM04wOHlYS01PK0JyNWl3Y0FBTERZM0tiNGhUTHFqRGoyZ04raWdzL0p0d0FBQUp2QjV2OXBPMzNZUXQzYmRoRHdCOHg1OGNKM2hLMStDZ0FBQUoxVmpWbzR6WVd5b3FkRldua0hCNncxL29tNXRpYmVKUXNrNEErVzFXMUpoWDYyVmZwK3IrNEdBQUF3WkRQSVJmMFBmbkpiM3d0Y0pPTU8rTDI4ZUlSM0FBQ3d2Rm9WTW1jUmwwck5GNzJ1aEFyK2dQa3YzbVlOZmRuejJMQUFBQUNiSm14M0daVzhwNGNLL29ETjc4VWI3VDhNQUFDQVpuVjExZXpxczFVOSsvVUxqaDFWc0tVcjNKWVBBUmozSndGL3dEYnR4YU1QSHdBQW9FYW5Ub3E4MGo2VFRSRXRPb04yaDZxNndrcG5WeS9zT0swQUFBQUQxVWRIdzdSbDFOTGNWaU8vR09xb0EvNFgvL3JhRTVJOVFIVWRBQUJnbm1xQ3ZyV1N6ZEphVTJickplb2Z1TzJtRDV5WWFrRUxidFFCUDlWNENNYmRBU2lPQk5sU1h4aTdDUUFBQUgyYU5GMVY3VERZbXVmekh2MVI5OTlMeXhIdzkvVzdPR0krQUFEQUxQWFZmVkd4bEo2ejRlSWg0QU1BQUtDemFIanU1YVJZRy94MG1jamoxcnRWbnF0VXpSOTlObHlHZ0o4ZmhzbGFicXo3NXR1VXNmR3ArZ01BZ0VXMW1RT054REtZU2Y2M2VYR0pnRDhDdDBxYUxzaVhkaFFuT1NPY2tBOEFBTWFxS3VlVWhpMXNzYWgyT2F0NXNVbTFQeS9zRmpQYzJuR0xCbWYwQWQ5SysyWlhwU2UwQXdDQVpWVE9RQk5kdEVwWnYzMDZoczZNb3BYMUYwd0Zmd1JhdklnbStKbmFsUFlkQUFDQUljZ3E0V0ZlMnJ5MWgxZXJMWUs3OVR1TjBxRTNLeER3UjhBNURFTmdCd0FBbUFlYi8yZXpWMXBDd0IrQjlFV3NHdzhWQUFBQWZiRTlwUGxTeTQ5ZnZDOE9LRmpqSDFWb1dLMGw0QS9mRno5ejdmMlN1V2ZlMndFQUFJQnVKdTJXcnB6TjJudHUyL3YrdzVOdXoxQ01QdUNuaWoyMXFuZktYSTRiQVFBQWpFbnM1TnNwODFWOVAzMlhCVWxMVUwyWGxpZmc5elljRXJzQUFBQUFIVGtCUFRzeHRuclVuWnFoTlNjT1l2bUFLcU1mSWxOYW5vQy9MN3IzR0gzL1dPYzlhTk0zSDdFZUFBQ2dkMTVsM2thZUt5ZTQrQ01WRGZybHBSUHd4OE91VGIrSXprOEFBQUFNV3FmMm1va2I1cWR1NHFsYmVQZ0FBWDlFbHFMZkNnQUFZUE5WeGZOcExueFZ0NTZhMWg3bitZcWxFUEJIcFBIRm5PVytJd0FBd1BMS0FubTV0U1o1empoUDJZcHArMXEzSmVDUFNONmlrNTNRNFYyeXVQTWhKWFlHQUFBQUdsVVc0eWZKVXNWNWtjNHB1OTR0RzVrMk1IM2I5Z0FzVjhEdlpZaWxWSGlaNWttbkFRQUFXQVRoQmFQOEoydnU5YndOZlM0dXkzN0ZCbFBCSDVGYjI0Zjc4S3BwMDQ3ZFNzZ0hBQUFqWWR1T0xoZ2Z5YVk4bFR0OFp0UFMvSkZ5aW00TTY2OHVXSkQxN3hQd3grSUxuN24ybUtRRDlWTk5IOFRwNHdjQUFDaXJ2NTdvRFBKVGZHL2h3TDY5N3ovVy84b1d6MUlFL0ZUYWN4VTd3YU44RXdBQVlKbDFLVnhXWGJTcXQrSm54VEQzTm13cmNxOXhWSXA4UFF5YlBoQkxGUEROV2w2bG42anRwdDA4OVc5azlpQUFBTUNpYU5kRzA3aUkrSjBwRnp1VEZ1ZWxhTStSbGlyZ0w4cFowNFI4QUFBd1hyVzk5RFliQmFjbXdPZlYrZlEvem9teWsxN0ZOclVnV1hEMmxpamcyN1YyaDRrSTRBQUFBTDJwU3Z4cGVQY0h2clQxODB5K0VaSjBTODhMWFZoTEZQQXI5dHFzKzVaeWJqa05YT0ZlSnJzQUFBQUFkVXp3TTlTdTZGb2U3NzdMOHNKNURBRi9oSHArVVluNUFBQUFreXRmeFhiNmszS3JUdmFWUkl2T0tFMy9vcExwQVFEQWtvdkdvVjViYW1MTGFqdit2cnNFNDkyVExCWDhFY29EZnRaeTQxMzRZS28zSnNrZkFBQXNvNGFyVThYdTlONWYzeG9WL0xINXdtZXVQU0RwU1AyYnFxSmZyUExrRUs1U0N3QUF4cTRxQjJVL1lubG9naEJma2F1cXIyRGszeXJ1SmRWKzY0eStJK253dnIzdlA5aDlvNFpwYVFLK0pNbG1oMmFvdUFNQUFIVFhQVU5WWGNYV09yRzhxYWcvYVcrKzA2MnhOTlY3YWRrQ3ZyUVdQL21Dd0E4QUFGQ3JSZWVDclVyelhWWlQ2cVFJN3pqVitXdzR4UHh1T201K2VST1dwdjllV3JxQTMySjRKTEkrQUFEQTFLeHNjMm0rUEZQeW8vZGg4SmZuQkZ0cDZRSytzL2RXKzg0aDVRTUFBTFRYUjNZSzByME5kaENDQzlWYWEveWpDdEhDZmI1Y0F2NTQyVzlXOVhCMWZWdXlDd0FBQU5CZTFsWmpaU3F1WXV0TlhYdTN2WHdBbFc5T3VvUWhXcktBWDdIM0ZoL1FOWEkxVzJJOUFBQkF2Y2xHR1F5THNPRm9PZVVpclh0aHJLQzhYMTRPQVgvRUdsL2N4ck8wSzU4bS9BTUFnSEhvTkdwTlpkdHpWZEMzaWwzRjF2ODVyZExPQUMwNkk1WUgvT2lZclozUDZDRFVBd0NBWmRYMklsZnU0NU5rcDRyckZKVldaaUtyenU5UndSK3JMM3ptMmpzbEhYWGZYSGJhMDdUYlhPeUtDMklCQUlCRkZaNnM2ajlaYzYvMUN0cHRRNHRsTkYva0t1TXQ3OGkrdmU4LzBMd1I0N0ZVQVY5U2gyR1NXbDdOdHZWNkNma0FBR0NnYlB4Y3hISkhSRHh1bCtkemk2MTEwN25UTm95QkwwbmhPWlBKemFWcXo1R1dNZUEzSHFLWlBvaFBlclUxQUFDQTRhbk9QZlhYdlpwZFhnbzZOSmFxUFVkYXpvQi9jL0tqZkNaMjdHWVo0UjBBQUl4WHEwSmxaQkoveVBxZThsTEZJRG1sTWZDekRYQ3VZbXVMOGZRSitPTm52cGxYNlh1L1RGcWgvbzNOVGdJQUFKaVhkbTAwMDYrbXl6cHMrdjhUZGxMVXI0cUF2d1J1cm5xaWZCckpMTi84aEh3QUFEQTI4WUR1WGVTcWdiWHlyMkpyMjR5Qlg1dXNLclBmV0MxaHdLKzRtaTE1R3dBQW9DYzFRYjd1S3JZVGQxZFVGV2F0Uk1CZkNvMHZjdnpNYmx2YTYyU2ZBQUFBTExXWlhFUElTMkxwejNaajRNY2ZNd1Q4SlZEZmg4WEZyZ0FBQUhvU3kwbmxxOWoyZFZKdXhSQXE5T0NQM1JjK2MrMjlrZzY1ajNXKzJGWHAzY01ZOXdBQVlOemFYZkxLVGxIN3JOb1phSHVScS9DS3QxYVM3dHEzOTMzM1RicEZRN1YwQVYrU1pPM05TZTlYMzhHY2FqNEFBQmlqTmhlNWFscEVGdFNMV0o2Y1VOdG5IaXR0NTlLMWM0NkR3QUFBSUFCSlJFRlU1MGpMR3ZDbG0rcWZEdmNBVXpNY1ZoTUFBR0N4WktQWWhIa29NbVg5RmEwbVhudnJxOWc2bys1WVovUWRFZkNYU2hyd0Nld0FBQUN6TUlQTTMzS2xYdnQxUTFGM25KWTE0TjhjdjlnVmdSOEFBS0M5V092T1pIbkt5aFJqNEx1TGJycUtiWDNiLzk2Sk5tYmdsalRnbSthOXVaYnZUWFlKQUFBQUFrNEJ0ZmtpVjVHRTNsZGJ0TFcwNkN5Um02b3VkaFc3bW0xNUxIeGlQUUFBZ0svRnliSjFuUlBXNzdyUEptbStpbTN0UmE1bzBWa2V0dkhGYmp5OFZQazA0UjhBQUF4VHAvYWF5aXA3dzBXcHJIOGhxNzdHd1BmV1VReVlRc0JmSXJkTE9pcFZIQzdpWWxjQUFBQVZhbkpQNWZENFRWZWtyVnRZdTZ2WVJpNXlkVlRTSFIxV09CcExHZkMvOEpscnJhU2JZLzFoRTJzemhpc1h4QUlBQUlzaVBGblZmN0xtWHVzVlZEenVYTVhXbXBwcEoybUw5cFozMDc2OTcxdktLdXhTQm54SmttMXUwMG4wUEJZK0lSOEFBQXlGYlJ1eXEvcmd3Nm5jNG1yVDBxcXVYUnRiWTNRN2w3STlSMXJtZ044NGJOTDBRYnpmbmpJQUFJQmhxQjhEZjVKVzZKcUxYTGxUK2tOczd1MjRvdEVnNE1jNnRpSTNBUUFBeHF4TFlkSTloOUY2MFduS01mQ0xCNHFmZFdQZ1p4dGdyVE5OdnFDOUUyM01DQ3h4d0RkNzR4ZTdhcXZkUFBWdmRQWWdBQURBWm1uWFJ0TzRpUGdkNStFcHpuSHNQSDN0czdUb0xLRzlWVS9FeHNLZkhVSStBQUFZdXZyVzV1cUxYQ21OV2w2WlBuKzhlUXo4dWs0Z3U3ZDJvMFpzaVFPKzNWdDFzU3NBQUFCTW9pN0lXMmNNZkQra0szcXZqZHFMWE4zWWVYRWpzY1FCWC91VWpvVmZKWDZtdHkzdGhiSlBBQUFBbHNyTXJ4blViUXo4eUdOSEpYTmJ4NVdPeHRJRy9IUXMvT3JlcktuZXVFUitBQUN3ektyR3RYZkd3Ty94S3JhUklWUDJMdXNZK05JU0IveVVkK2ltK2tTUWlyM0gwcnVKTWU0QkFNRFExYlhOVkY2cWRvcjZadjFGcnRxTmdlLytYTzcySEduWkE3NjFOeWE5WUFSekFBQ0Fzbkw0N3B5YmJCYlVpMWllbkZQYlovNHFiU2NCZjRsOW8vN3Bxc3I5MGg3eEFRQUF5NkkwM255WGVhZFlyZHp6SUJzdWNwV05nYS9TUmE0SStFc3NmZkVKN0FBQUFIMllTNm9xWCtTcW9ZZzdic3NlOEw4UnY5Z1ZnUjhBQUtDYTAyb3paVzRxdGZ5MHZZcHQvV29KK012TE5MLzRaSDBBQUlCR1ZsYXhxOWcyWHVSS2szYy8xMXpraW9DL3JMN3dtVGZkYldVUE5rOVpkWUlKNlI4QUFLQlJOTUdIVjY1MWRoQmFYY1cyY2tTZkEvdjJ2ditlcWJaMzRKWTY0S2RXWXcrMmp1N2UrUndUTFFFQUFHQ3VPbzFIUDNHNVBieUtyYjhGRXk0MHVHK2tpbXkzVEFqNHNUZEI5RDFtdmF2WkFnQUFMSmVPMXd0cVhGclZDUHROVjdGdFdpNEJuNERmOENibzZ3cHJBQUFBNDFZVnlEY2pTM25ySU9EUGV3TVdRUFdib1BNaEtIWUdBQURBRXFwc2g1K3VHbCsvTWxPMWFnTCt2RGRnQVh6ZHZXT252WWhWbTZ1eTlYcmxOZ0FBZ0E3QzRTYjlKMnZ1dFY1QnhlUEdlY28yVE50Vjl2dFlpWUJQd0ZjUThEY05JUjhBQUN3cU84L1JBb3QxbC92eVcyM1YxL3Jlb3FGWitvRC9oYjk2MHo1Sjk5ZU8wUW9BQUlDRlVSUHk3OXQzNC90dTI3d3RXVXhMSC9CVExhcjQ0VlhXNkxjSEFBQllNRXZmbmlNUjhCUFcxaHpLbWI2eTN6d1NEenNMQUFCZ1Z1b3VDdFgvbXRwTkdNOVgzYmV5dEp5bGI4K1JDUGlaQlhnekVQSUJBTURtbTI1SThIWTdEKzQ2bXBvZ3VtK1BOLzFYTzg0OFNnVDh4TXpmREl5bkR3QUF4cXBkenRtVUxMUUFSZHY1SStBbjZnTSsyUndBQUVBREdKU0VDcjRJK0ptdmxCOXFtK3BKL3dBQVlPUnM1WjJHYVdmTkt1akRqMlM2NVVQQWwvUVBmL1dtQTVJT3puczdBQUFBTUxFRHQzN2p2UWZtdlJHTGdJQmYrTEovZCtFUFFRRUFBSXlLa1dSYVpMRHlGRmFpZXA4ajRCZDRVd0FBQUV4cmZqWFNMemRQc2h3SStBWGVGQUFBQURPVEpIL1RhZ2ZBT1ArdHVsVzYvMDhUYnRqb0VQQUx2Q2tBQUFCbW9OUjJZL28rRTlkSVpMa2NBYjlRL2FhbzNkT2tWeDhBQUl4Y1E5d3hwWXI3TkpyQ2Y3YVcwblFFL05SU3A5TW5QUDBOcDh1WXB4dGpuaVdaWnh1alowaVNNVVl5NlZ2VnBQZExoNVZNZXR2a2Y4WDhyWjN2bGZwLzN1YTkxNlYrT1FBQXdFd0VlY09hNEZsYm50YWEwalBaSldpVEgrN3Q1SWJOZjFySlN0WmE1L0hrdnJYSmxXL3oyODdqK2ZUV3lycnpCLytybnNmK3BiWDJ6MlgxYVN2N21YMDN2dS93MUgrNmdWcTZSUG00cDc1K3U0eGVZSXk1eWhqdGtER25aQUUrQys4RWZBQUFNQjZMRXZBM2lta2lZVDBNOTladUJHSGVuOWZLU2hzVk93Q3lKMlR0RGRicW85YmFqOTkrOHdlT1RmbEhISlNsU1pTUDNmRnpENVl4UDJXMDhqSVpuVzlNR3RDTmtjbkRmQmJpWXdFL3VWUGNYSkhKTHE1QXdBY0FBQXRyamdGZlFTVStteVlOL0VXQWwyUTNpb0FmQ2U5NTVYOURSY0IzZGdic1JycStqZXk1ZkdmaERsbjdIaXY3YTNkODgwTjNUdjUzSEk3Uko4ckhQT1ZudHh0ajNtU01YaTVqVGpOYXlVTjdFdVRsQlh4VGxQRUorQUFBWUFUbUhmQ1ZoUGZzK2JEOVJrckRlUmJnM1lCZVBKWThIN2JucEVjR3d1cSt0ZVYxeVI2UjFhOVlxemZ1WC92UXFDdjZvejdKOXRGUHZ1YkprdjYzcEYyU1RwTWtHZXNOejlUbVlnb0FBQUJvSzVLdEdzYkc5SjcySnMzYXFNT2lxVDlaY3Jzb3NCYW4vTnE4WUtza0MrNlM5TC9QdStoRlQ2cmRvSUhiTXU4Tm1JVXJydHkxOWNFUGZjWWJaTXpIakRFWGxxcjFUZ3RPL3JoVVZQRFRkNEp4VzNhVVBaYmRkTjQ4cFFxKzVENVMzQXNyK09HV3M3TUJBQUJtclUzZTZKaEpKb293U2RlRENZNHd1T0c4ZXRIWjg3RVJkMnp4dkpQaGloLzJmRWt2T3YzTUoyMDUvY3dyLy9Md3ZYKy9NY25XTDdMUlZmQWZkZVZyVDVYMFNSbnpSaU50ZGQ4V3ByUy9KMVVOeGVSRSt1TFdGUG1iSXdVQUFHRFlxcktNRFg2R2MwMHk1cjBUMG11M0o1YnRzcWY5d1R1RHFiWktlcU9rVDU3N2tCZWVPc0VHTHJSUkJmeEhmZXZQbkM3cEQyWDBYRWxwUlY3bHZUZjVKOVdtcGYyYUpZZlBtZXFuQUFBQUJzUXZRbWFWYmx0NnB0M0NxdWR3QzYxSlBtc0s3MVZMOFhOWW51bUNjeXlidHNNazYzK3VwRStkKzVBWG5sNnpNWU16bW9EL3lDZit6Sm1TL3RqSS9NdHlITGMxNzVPR3QyN1ZUbUYwajlKRTM2eFU3d0VBd0dnNDJTa2ZNbHpsdkJQMnpkY3NNSEpMYVhnM1hwSGVHRnN1M0p1czB1OVcvTjNpcnR1SDcrL0FwTnY1blpMKys3a1h2dkFCTFRkNDRZMGk0RC95VzY3ZUt0bFBTZWFmMXgvS2lTdUg5ZXhOMGJTc2lqY2tBQUFBQW1uUHZIT3VvaW1TdS9LT0NyY0NuNGZ5dWhOdDNWNzlJc1BsejdublY3cVRlTlBybVpMKzhKd0xyOW82elcrNEtFWVI4Q1g5Z3BGNXB2dXFsZDhDa2orQ1RwZElQa252R0FBQXdGaEYycGZkODFpOXJoK3ZCQjhrdGZCb1FQR28xOUlUWGE4Si9oZlp4dEw2c21leTZyMTFIM3ltU2ZyeUIyL3dvK2hjL2kxWFA5c1k4MEZqa3JOZ2pmTS95Y2lzdUtQbE9CZTNVdEdqbGZWdWVXUGcxNDZnczFLOFdkdzNzM1BmZjdTeXo2ZnBBUUFBZ0o1MWI1MlpiUDYyaXl1UHBKT29Pbm5YbE9LVyswaDVOV0diamp0aEtlODk0N1FIZk91bmo5ejN1WnNxdG5ZUUJsM0J2L3dKcnpuWFNKK1FrcXRYQmFkZHBFZGtyUHhYMUcyL2lieVpLczdMbUdZRUhRQUFnTUhMaTVwdE9odkNpbm5rSEVVanhjOWRkRzRaNVFYWnFqNzhZbnBieW5DeE5wMnFnbXhxeFVpZk9PZkNxODZwKyswVzNhQUR2cVMzU2Jxb2EvYk9LdlpldjVmL2JIcXJmUGhvK3IxZUpXL20yalBIQVFBQVptU3FBVUdLYmdlZlUyMzNUc0tOdGNhNEFkdkliY1hKYzFuZVplRm1zYUpESTc3ZDdkcDBuTjZNZEpsZW00NGtjN0drdDBjV05oaUREZmlYUCtFMWw4bm9CYVhXS3hPK1JiTTNvbzFXNGF2M1FzUEtmMlFlcXZvQUFHQ0llaXcwK3IzelRvZ08yeW9rWlIwVVlkUjJjMzJ4ckd4NnA4WEdXMU00ZjdHUXF1RXlqZjhmQmFQcHVKTys0SndMcjdxczRWZGZXSU1OK0pKKzFzamtGN0xLaDFHU1NwVjViOC9RWkk4RWJ4UHZIZFVtdVpQdUFRREFpSFVhQzc5bGRncFRmTXZsR2kvSFpXMDZSYXRPYzV1T25JSndlVFNkc0puREpCZkN1cWJEaGk2VVFRYjhSenorMVJkTCt0SGtYbnpQcnFyL3Z0Z2J0TVdFK1V6dVRYZFBNMWh3SU44THBlMEdBQUFzQWFPaTh1MCttanprajBXZkQxemlaYXJzT1RuNUtjaHIrZUFuMmYvQ05wMGcvSHZMQ0xjckdFMG4veEVzeTc4NDZsWG5YSERWUlpFRkxyeEJCbnhqekt0a3RDM3Z6YXBvcGFsc3ozSDc3NFBweSswOXB0dU9KZ0FBd0tEVkJKL2FUT1Qyc2xkUGFOTENiSkhmakV3eVhvb1QwWW9kQURlWVQ5YW00NGIyTEJPYUlrT1dkakR5ZTl0azlPcTYzM2hSRFRMZ1MzcWVlNUpHOFFJNWUzV3g5cHowa2VKV1RjVTkrcjVzbS9UWkl3QUFBR09WOThrVWp6akYxdm8rL0N6Y3R6K3R0OGg3NGVyYmpxWmo4NndZbnFSYmJHLzBaRnRKZWw3cnpWd2dnd3Y0ajNqOHF4OHQ2Ykxrbm5OaWhETk41ZkNZNldHalV0Mis3a3p3Y05xWm5HQWJPNW9BQUFEUWgwa3lSdEVGVWU1d3FGdDIvWDBUakxJajFiVHB4SzVxVzJyVHlhZk83NWY3OWNPOUEzZE1mUC8zTEphZHUreWNDNis2b3ZSckw3akJCWHhqekhQelBUWHZSVy9lRXpUcGROSGhNVTN4dkhleGhOS2VaNzRrNTVZUi9mY0FBR0J4OVZoSXpQTnpSZmFKcktyOWNKbFNmbUZTWjNGRk9UY3ltbzRKSm5TRzJEVGU4cVZpVEh4VFBPYXVLNmppcDA4OU4vNkxMcTdCQlh4SnozVlBpUEJlUEsvWHF1aXRNcEUzVC9sTkdieVRhbHA3dXVoeUFBb0FBR0JldW1XV2NwdE9JakllZm1XYlR0aUhrUVh6SXFONUpkVTB0THVGWHBOVjNvMmIzS3kvVFBjeHB5RHNGZkNkYkpsc3BqY1ZBWC9tako2Ui9LaWJKREo2anBGaVY2OHRENC9aWDNzTzRSNEFBSXhmRm9xejIyNUJ0Zmh2TWJYYnB1UE1HMm5US1YzMEtsMUg2UUpZYmtEUFFudzJYK3hrMnp6TE8wY1NZaWZiSmsvOTg0bitMSE0wcUlCLytSTmVjNWFSZVVEZWorVWNpdkY3c2JMZHNaclJjMkx0T2FvSjVaSDJuSW9KMi80NkFBQUFDeVdhZzJKOStIbmx1NjVOcDZhb21pL0NCanNHd1dnNi91cWlXeGdkRXo4dDJ2cFRPeWZiT2t2MU0yRFJHZUpVOFI5d3pvVlhuUm4vUlJmVG9BSytwQXVUSDhVYnJYelVKM3V4bkdlOXd5K3hOMlA0RHZKZjRLclFucjh0Nkw4SEFBQkxKMC9Dd2VNMmZkYXRwcnV6T2NYV2NONUlGZDJ0eHJ2RlhiL0FXODUvazU5c0cyNndwRHlERHNPd0FyNHhGMlNIV3R3WHczdlBWRjNjeW11L3lSYm5CbnYzK2MwYVBRY0FBR0JSdVRtcDNWVnQzV3A4NWJKVTVDcHYySE9UUGJLU0w4eHRyWEdqZTJ5SjdVNjJ6WFk4SlArOHplRFhMWjlzZTBIRHI3NVFCaFh3a3ordXMxZm03TUg1Z2Q1OW83Z0xDSzZNNWo2bS9PVlZPRWwxZTA3VGZRQUFnSEdMWDlVMmU4Z2ZGak0rTkxuTjA1MDdiN3o5eDJteHlROEVoQ2ZiZW9rdStGbjVTNlEvZ2lNQ1JRWWs0TS9RdVZWN2JuN09kMTVNN3dWenA0OVU3Nk43bmZFM1JIR0VwME43VHRZakJnQUFNRyt0TWtsTk1QWmFXMkxCdmNoZllZWGNQeEUyS0xBYXQ3SWZYSkUyZXk2djl2dGwrN1pYdGkxeW5IdmtJQ3NlUjl0MEhsejloMWc4d3dyNHhxeDRPMVl0VHE0dDNqenB2Y2FUYXlkdHp5a2RLR3J4Q3dFQUFNeFJyNFhIck9xZDNjNkNsZzJlcjhoTWtTSnRXTVUzNWJtY2ZZejJWN2JOZHg2Q3BSWkxMbDNaZGxDWmVWQWJXM2R5YmJISHQxSThHK3pkMVo1Y205LzMrN1RhajU3akxvVndEd0FBaGlreVRrMzZvK3RvT201QXJqdloxbmsrZjdqaHlyWnVzVmRod2RkUGk5TmQyYmE4UXpJRWd3cjRKcWpFMS8rNTNUZFNzYWZtTDBmeTIzUEt5NmgrMUZRZHdnRUFBQmkwYVM5NlpaeXc3QzhyckphWFQ3WXR0cUI2eU15aThsNHUzblk2MlRhL3NxMnpwZTQwQTQxNGd3cjRXVFcrZU9HYXIxeWJUeGQ3QTVSdUJkTzQ4ODNrQlE2UFJRQUFBTXpLTkptanBvcWZUeEU3MmRacDAzSDZwL09xZUY1NWoxelp0bXJJVEdlNXhxbm9WNTlzRzd1eWJYYTN2azFucURsdFlBRS9ydTdLdFVYV2p4eG1pWnhjNis0Y0dGVzlzZHpxUFFBQXdGRE1JTENXMm01Y2taTnRZMVg4b0NYYU8vRTFmY0E5WVRZTDhOazg5U2ZiK2lmMG1uekh3SjNIRnROa2V4cE8xaHRhbTg2d0FyNXpxQ1h2dGFxczNxdDRJU1BMYVZPOUwwMWN1VkhGc2lxdkFNY09BUUFBV0VRVkdhV3lUU2RheFRlbDI5VW4yNlpUZVZYOGJDNzN5cmJLNTUzNlpGdmpoSGduKzVYSHhJOGNneGhXdHBjMHNJQWZIaWd4MlFzZWVTTWt0NEszWHVtRTJlcnFmZFg2cWQ0REFJRFI2UnJ5eXhNcTczNm9xK0xIVHJiTlovY3J0WnR5c20zdHIrU3VZRmdHRmZDOXd5enVZNUk2RDQxcDNHbzdWNjRGQUFDbzUrYXBDYTVzNjAyY1ZmbkRWT2VGdWZTUkNVKzJWVGh4a1EyOTh6bnppZElzNmU0a0RMU29PNmlBSHorNTF0ODdLL1lncytmU3ZjYlljSmZSNnIyM0luL1M4a0diU1g4VkFBQ0FjY21qV094a1cxdjg5Q3F5MmJ6T1RrRGpTSW5CU3ZNV0crVzMzVGFkWXZERTdFaUN1M0puVEh3bjJKZVBNZ3dyOHcwcTRJZWlKOWZtZC8yaE1lVk41dTdwTlkyTkh6NDk1U0VzQUFDQUFha2I1akkyZGZJamFMWEpxL0Z1dkE2cjkrVWhNNHZjNzZUMW9FMm4rbVJiZDV2ODlYZHIwNUhNd0NyNXd3cjRMZHB6M0RkV3U2RXhnK3E5MnJibnVOVjl3ajBBQUlBdlVzWFBpN0RPVkxHZS9ienE3Z1IyazJTMFdPMDJsc2JDbHA2Nk5wMWlBdmVpVjk2TWtkOXZjUTByNEV0K2U0NlJpaXZYbXZ4TlUzMXliU2FzL1B2TFQyLzBzSzFWbytjTTc0MENBQURHb2lLRDFGU3BvMVg4eWl2YnhvcXN3YkppSjl0Nkl5U0dEMWNNWGU2Mit6ai84MXF6VzdUcHhDNTZsV2ZMZ1ZYdnBTRUcvRlRzalZPODBQSDJITytOSUNsK1FvWjFKbmFXS3hOOWN3RUFBQXhQOTVEZmZSWHhOcDNJSGtFZXlPdXZiRnQwYVhnNXIyT2JUdlh2WHRkQU5DeURDdmpUdHVjVXR5cmFjelp0b05QaDdRa0NBSUN4c0pvK2l6UlY4Yk93SHVtaXlIN1duV3pidVUzSEZ2TUYyeG1PcHBNWGZOTkt2eW5LK3hXLzZmQTZMd1lWOEp0SHo3R2xQMy83OXB6U084VzU2VmJ2KzBMSUJ3QUFZK1ZXMjBzM1ZWY3JqNCtsMzJKOVdTWGZqWWZCUmErS0RRbDNDTnlxdjl1SDcrN0lETWV3QW42cWV2U2NMUHlYMjNPVVBaK3JHZnUrMDdZTWE0OE9BQUJnRXYxa25saWJUdnBNelpqNHBkRjBzaW5jaTE1bGkwK25LUyt2M0xSVFBKSVZpY00rZkVXM2RkRU5NdURuWXUwNWlnZjFZRmRBcGZhY1NWWS94RmNjQUFCZ1U5VzA2VVFuZDl0MFRCREVuWGJzb0piclg3VTJ0dTRpek1kVGUxQWdycGhxQ0xiT2V3TzZNZkdmK1kvZ1Jha2NFU2U2MjZqcUYzeFczRGYyVU45Q1l6Q3N3MjRBTUV4OHo4M1BqTC9uakpWc2N2NWp2cWE4amQ3V3I5MFl5ZHFLOXZuMHVkSThrckd4NVZaZjR5aFpmSkh6NnJhcmFOSVpiajRZV2dYZit2MzMvbE90UkQ5ZjRoODZzK3UvanhudW13Z0FnR1o4enlFcmtQdFpMbDVMbitUOVVuZW1yUFVuQzFwN1dsendhbEJ2NEVGVjhJM1JYY21OL0QveW8zNWtlRXhQdnhWNkd4bHozNStnNjg1QjFaajVtTXlnL2kwbTd4Y0E2TnRDNVpJMjI4Sm40ZVNtZkswYnZvY2FhdkZUcXF1WXB6VjFrMjZEOWFmMzVqU1NzV2w5UHUveXNjbUJBTGRESjc5aDBnTUY3bEVFSTJranVWc3MvR0JQditpbUdGb0YvOWJLUGJxcWRweVdKOWhPcXZITlBuVm9XNlFQWmdEQTRBeXVlTUQzM25Mb2ZxSnRjTU8vSHhaM1M4dXU2OVlvUnRLcCtkZHlhL1ZUaTJkUUZYdzEvWEVyS3ZmVGZiVFpDU3J4NFNMY3MwQW1XVTdkUEVQNzRPN1RqTDRFQnZkbENBQU41dkc1TnRXUkE3NzM0bnIrM2h2TTk1MDdsR1hTUFdHejBXNnMrMVBCNkpkT2RkNVpncnRFZDdubDlYblBEeXJnRDY2Qzc5Nko1Zm5KZXJZMlVlLy9tQmI4OXdVQUxLZVpoVWUrOSthaDNMSGczSi9xdFo1a3pQdEM5YXhOeTJ4NEg1VTdRd2o0cy9KUGYvZVdJNUx1bHJRcFBZWGVHcnczcncybUsvNnYzWUpOOWY4bTN0SStya3EzNkt5bStsM3IvdTVUdndZQWdKS1pmZWJ5dmRkdTl1bis5dFg1SnJZdHRubVMzbFIzYkxoTk5yRmI5Y0UvMk9oaTBydnV1T1ZEUnp0czROd05yVVZIa3I0aWFjZDBpNGlOd05QMVF5WStUK09KdDQyTG5YYlVuczBlNmhPek1Oc1RtUUNNM2FDdTA4TDMzc0NFUWQ1VVBST2Z1elNSaVQzWXJPNmMzS2xFRi96VldheHBsb1lZOEQrbG1vQS9jYnpPZXJmeW52dHNlVm5iajRsOENGV0gvTXhFV3hQYnE1NTROSjRoZitoTitDKzM1eW84WVJ2QTBNempjMnZxNGxacGdYenZ0Wit0bjkrNStYMVRGZTZyNTR1UEo3OElPMlhOMis3NDVBdzNaQ1lHMWFLVCt2MnVNMVM5ZE9FT28yMXoyS2IwajZqK2pkSGJoK3hVaHpFeEtjSTlBTFRUKytjbDMzdWJhdHB3YjB1VDFwMjBtajQybkplcWMvYWN0M252UGsza3NVOTkzYXJSeWlPU0llL1RTeFVia3c2dFZGeTYyQlEzOHFIenMybXl2VWZ2NUF5ejRweWthN3kvVHFtUEsxcFphUC9ublBydzZjU0hNeGY1Slo5UDVXTDJJWDQ0bjJBQWx0M3N2aVA0M29zWnl2ZGVoM0NmUDVBK0Y0Ujk3MzZXOGJPcjBscGJqSGlUUHlaWnUrRThYMHpuem1PdHpaKzNkc09menB1bWVMNllKL0o4c2I3VjIyLyt3Q003L3NIbWJvZ1ZmRW42ZytpanR1a2tGQlBacS9UbnQrNGhHL2NFOGZCVzlCOVgrNU5ncGc2VlZEWjZNWDI0RDArQWl2MFBBSVppZHA5bmZPOHRodmF2UThYcjNpWGNCenRYUmVlRWlXekw5Sy9UakY3cGVPWmNjRVBzd1plazM1VDBLdThSYXlXejR0eU9meEFVSjhHYXlLVHBucHN4YVNXLzNJOHZPVU54MnFwcWZuaS9lbHRDblNvY0U0K3Z2d2k5YjY2Ty95UTdmc2hQL3FVeXd5OEZSdXNCTUU4VFY4UGJ6dGYrZTYrWW84WG5JdDk3SGRjeVphVytjanNxbGh5RysyamgxVG8vVEZHcEwwMWwwdlhZZkxwaTNVNlZQOXovYU4xcTFQcHY4MXR0SjF3a1crYTlBWlBZdi9ZWGErZGYvS3lueU9pS3ZEMUhhWXRPbHNmVDFKNDlsbjkwT08wNmlXeTZZQ1VtR0dncGR2NVAvbDlUT1Uxc2p1YXBKdm1IM0diOWtYa0dxZjEyOS83aFZqbWI4ejVvOVQ4cVNnRG1yZVBuMWtSZkdkMW02dmI5eC9kZW5XNlYrcnFuM2ZkQnpaSWJ3bjI4ZW0rQytTZlpSbHNzdkJUMm0rWnZmUHlUdDkvOGdiZlhiZG1pR21vRlg1SzlSakwvV3RLVzVEMlN2VldNU2lQcGxONURiaFUvdGxkZlg4bjNGK3YyOFFRVE5GYjJGVm4zRkpYOXpwV05lVmMwV243NHpLeGkzeUZrVjI1RGZTV0FHQTlnY2NXK2E1b21yNWlpOGp1bjNmZGVNYlYxcHVKN3IvMVNlLzdlcTczMlQ5VWkyNFQ3ZExwUzlUNzlyOU4vbi8rMHdYSnNsdDJDK0Y0YWFqT1p4cFllejFRVjIvSjFyOHZxbW9xWkY5NGdLL2lTdEgvdCt2M25YL3pNaDBubVN1OUVXNmxqRmI4SStkR3VuckNTNy93b1RWcTZOYy9LZnBmS3hxSlhOR1pSc2U5U3NhaXV1QlBnQVN5YitDZHkxMm8vMzN2MVpyRjkzU3YxdFhQWjBvMmF0cHh3dW5iVisrUmhFOW1TbXQvRkJ2OEw1b25zR2pnLzNjS3YvY2h0TjMvZ0k5VXJXbXdEcnVCTHN1WU5NbnErcE5QU0luNmsxeWFiTnA4Z3VPczhac1BaSTVYOFpMM0p6MGhGUDNrNFBFYlV0YklmL3gwNlgwU3I5Y1ZETnJ1aTBXOEZvL1BRWHEzVzFWQ3g2S3FYUFFGMkp3QlVtZkl6dk10WFMzVDJhYi8zNGhzeFVVVi9DYjczaXFWTzhmMDN6ZmVlOWFmSVQ2YXRyTnpub1RtdHFEdlZlMXV1M3ZzVmVSdHNUSnJOb3NXM0xNUUh2NHMxYWJJUGwxVzFCQjJXekJ2RFgzdElCbHZCbDZUOWE5ZmZlLzdGejdyUEdEMDNyOEFiNWNOamxxcjQ2ZjNpY1ZzOFhsdkp0OW1DSXg4SDlWWDkrRlBUVlRpV3A2TFJ2RDBUZjdnMVZPZ25pdExOWlE0QVdIQ05oNmduWEVyYkNuLzlpdHA5LzQzN2V5OVQvZjNYdGxMZjhYc3ZVckZQN3NXcjlyRndYOVdhRStkT2x5MnYrZ1Rick5vZjMzbXo1YitYdFpIcDg3Vzk1cmFiM3Y4L2F6WnU0UTA2NEV2Uy9sdXUvOXZ6TG43V3BjYVlLN04vMDZibzBZbU1pUy9sSHhGWnlIZW1ydzc1RHBPdkpYekMrMUU1dTNkcnVnKzhmai9zWnYxQjE2V0NNVTI0YjZwWWhQK1FPMFR3eU9HK2RyT0ZPeFRCLzlnSEFEQnJwdjV6cU5zM1FMdnZ1MkRxNEpHbTc2WnBpbHdEQy9sVGYrOFZVOVF2dndqMnJiNTI2a0o5L3QxVlhsS3M3ZDJ0M0lmTGoxWHYvVlc3SFJUdXprUXgvbjJ5LytBOFh2ZExaZnNhK2JqM05uOUswb2YyN1gzL3oxZk9QaEREYnRFcC9LUmtIeTFydmlONXY5bWk4OFpLTWtiV3B0VjZLeVVuNUJxWnRDY25mVWp1VE5ZNWRPVU5veW5sZTMzV2VkSnY0WkhxUHZ5eU41MTNVUzJwT0Z4V2VTaXp2TERXYlR1dEQxc09RK2R3WDNFNTdmWVZpL281dkxGK295ZjBsS3NiQUxDcEtrODJsTnh2SlA5aFV6RkY1UHV1bUxDODZ0SlRibUJUeGZkVHJCSTdpKys5K0hvV3plVGZlLzUwVTFYcUphZGEzeWJZdThIYnI4aVhXblB5ZFRnWHVQSW1UYXZ3dHBndXVxNnNEU2UvYUZia2ZSdlovblE3L2tMU1Q1VitzUUZhL0hkMFM0OTcydXZQTjhiY0lLT0haZFg1K2xhZDVEL3VjMUs4WmNlYkpDby9USkRlQzk5MDlaVU9VM1d2dzlWeVc5ZGVHai9zWnZHVzZGSzVyMXZLcEJYN1lwcHVnYjRoekVmUDJBZUFNUXBEZk5YM1hUQjlweVBhYXZpT212RDdyM1Z4YXc3ZmYxT2ZhOWErcUZXNUpUWGZlK1h2dTRydlJXK253RmwzaDNEdlhiazJTZXBGc0xmWjR4djU0L2xWYUxQbFdGVmN3VmFTTm1RMzBsMEVaMXAzSG12dFRiTDZ0bHR2Zk8vK3FqL1ZrQXkrUlNlei81YnI3ei8va21mK0Q4bDh0ekY2a0JTMDZzaldoL3prQ1VsdXkwNDJrYjkzWHgzMm5UZnFCRzA4cFErNnlrT1lzejVzT2EvOXZrbldXL2ZoMXVGUVpHM0Z3ajBVMmJEZXB0V3dEd0Jnd2RRWHNLb0VIMlpPKzArWDc3MWdDbFYvNzVXbjlCK3QreVVXdVYxbm1yYWM0UEVlUnNGSjdvWGZlZFZmWEtYaEw5M3YzYnpIdlV1NHI2amU1K0hlMmVuSTFsUnF6NG44b3RrT1QvZ25LMjd1bGN4MzNYcmplMitxL0dVSFpqUUJYNUx1dU9YNk84Ky81Sm0vSVptbkdhT0hKZittRzBKKzhwU2kxZnhTMEU4ZTd5ZnNWMy9nbEN2NjdUL3NCaG55RzNvUE8xVXUyZ2I3eG9wRitPSFdMcG5YQi9oNUhEMEJnT2srZTlydEFBU2ZreE9lcTlZdTZNOHk1UGYxT2R5bWNqOUp1TytyWXQ5M3FQY2ZpbGJ0bmRUZUZPNkxhY1B2MzZ6Nkh2bTc1RlY5cDFLZlp3RWJtUzU1M2xwN3ZhVC82OVp2L05yTmxiLzBBSTBxNEV2U0hiZGNmL2o4UzU3MUd6SzYwTWc4dVM3a1MySFFUOE8vYzdzYzlMTXBySE83NlFQUS85QXJCM2hGLzUxUFd0RVlYc2p2b1hMZk9kaFAvdUVtMVFWNS8zMFJXWEY3VlBzQlRHTGlqKzZxejYyS1FOM2hleTlhNUtwZWRJdnZ2MW1GL01YNTNwczAzTGY5L3B2OGV5OGU2cE1mc2FxOTlSWmRIKzZ6Nm42Nk5Kdjhmbm52ZmJpY3JGMG4zSzVJRWMvL2UrWWIvRUZKUDd5MittdjMxZjd5QXpUcWt1SGpuLzZHbHhucHJaSWVZTXlLLzNrU2ZETFZ0KzFrNnNKK3VMeXFyVEtxN2RWdkRQcFNyNzM1RS9RN2R0ZjBvVlExVjh2S2Zac1B0OGdIV052ZVFtK1MwZ0pONUxHcWRic1BiY2JmSFFEaW56WFI3NGFhcGM0R0FBQWZvRWxFUVZTV1JhU3E0Ti8yWERYL3U2OXRrVXVSNzZzbC90N3psdFh0dXkrNVovSUtkdVcyUkwvM25BSm5LZFFYTXhXcmRiNXpTOEUrWFZaUXVZLzMzV2RQRjZQbTJHeVpXWis5dFVYbFBxM1NXeHZjTHlyNDkxbHJyN25sYTcvNm5zby93TUNOcm9MdnV1T2JuLzY3OHk5NTFrZU1kSVprcnpReUswNXliNmptNS85cEdmYkR3Mk4xbGYyNmluNDY3MFFWL2I0ckdyTU9tbjFWN292SHF6L2d1bis0U1dIRlFvcHVjN2hKRFZXdi9Ea3E5QURtb2JIbkp2bHdLbjEzVkg3bmREMmliVm9memVaN1Q0cC83N1U5WWgwV3Rab3I5dkh2UFRlY0I2RSsvejV0RWV6VDU5cUcrMktKZmdVL3IvWTcxZnQ4Y3B1dE02ellXOG5xcExYMi9iTDIzOTd5dFYvOXMrZ2ZZQ1NXcGxUNGhLZS80UXBKdnloamZzQ3Q0TWZDZTJQUTk2WjNodXRxcU96SFAvU3FLdnFUVnZOanV3dnpxbVkwSk5pS1NzWWtsZnMybFl1cUsrMTVzelJWTElKbGx5NjNYYjJnOG1ZMVlnOEF3S1RhZlhaWDU5eXFaNnErODdJSHlwK0psZDk5NlpPZHYvdjZxT1F2MlBkZU1YYzQvNlJGTFhlYSt1KytWdDk3WWFqM2hyYjBKbktXV3hQczNXVTZQOTJRWHp5ZWpacVRQZTlVN1pWVjZqZjg1WVdWKzZSNi83dXkrcm1idi9Jclg0MzkyY1ptYVFKKzVnbFBmK01UWmZTRFJ1YjdaUFQ0NU5GeU5WOEtnbjR5bVlLUG1XekM5RWJzZzgvOXgxZ1g5bU1mZG0wcUdtcjhzSnQrQ0xGSjN5WjlCdnhKd24xUXVXZ1Y3SnNxRnRsenBSbHJmdHY0emdFQXpGMnBNTlUwaVhzdnFQUkh2L2VLKzlNRy9WNUQvb0o5N3lWelRobnVJNVg1NHJ1dlBFZmRDRGpaUTZYdnZiQlNINFQ2WkpLMndkNVpsaHZ1czl0T3VNK1dteTA3M3BxVDNuYUh4clQ2b3F6OWZXdnQ3OXowNVYvNXZKYkkwZ1Y4MXhPKzQ0MlhHNW52bCt4M3k1aEhTcnBRTXFkMERmdXhvd0RWWWI4SStuVVYvVFk5aXQ3YUZ5cmtiMTRGbytrRGJsWWZicEdsVlc1dW5mSklBQUF3VzZYdnM5cUpTemRxQTMvMTkxN3hZS2Z2dmlsRC91UlYvUGp5cXMyNWN0K2hxRlZiME9vcjFLZnpWUWY3NUhHdkpTZWZacU9ZM3duMzNnbTUzdTM4c1JQVzJ0c2srM1ZyOVNscjdSL3MvY2QzcjVZM2JEa3NkY0FQZmN0M3ZOSEltUE1rUFZReUR6V3lENHA5RWs0Yzl2c0kra2JiSlgzWVcvWENoZnpOcVdEMDl3SFg2VkRrMnlWOUx2WUJWMTdIak1NN093ZkE4cHBzOFBvT2k2OEx4dmwvNU4zcU9DaEZ1KysrZklmaFd5VmRYVnJ6a24zdlJkZlV4M2RmL2ZlZUpQc2lXUjN6bHhVUDlmazJWRlRzdyswb1duS01zaE5xM2RCZkR2ZjU4cXkxT2lScmI3V3l0OHBxLytvWDNzRVhZNHFBUHpCUCtjNWZQRU5HM25CT3ZZWDhXWC9RemJ4eUgxYnRwLzl3SzFYcHJiN25jOWUvNFZPMXZ3Z0FvRmRQK2M1Zi9EY3krbVIyZi9OQy9td0RmcC9odnVxN3IvWm9kZU4zWDE3TWVzRG5ybi9EL2RGZkFndHBaZDRiZ0s0aWg4YWMvNVkvUk1LSXVwZzd0N01POSs0Sk90Nk1TUkVnZmRUa0UxcG5pZm5NaS9tbkE0QWw0SDhHK3dGMHl1KzlodUxUM1BRYTdydDg5NVcvOTJnbkhaNnQ4OTRBVENMOVFEUGVJK2toVFpNK1YvMlAwY3JHS3hvTjg4M0tab1Q3b21xUjN2YXFGa1dmdm5XZTk1ZkJoeHNBekpmLzNWZDhxdHZJOTVmN21WL3p2VGRya3c0bU1XVzRMeCt0VG0rNzMzMDIzSkpnSjRydnZVR2pnajh3TnZpSEdwc2krZEcxSFNaN1lzRXFHYjJHZS9lUXBCU3QyTnZ5QjF4NGNRNEF3T2FxK3U3enUwK0dlUVM3V2wvaFBwMDJxTmlYajFTcm1DNzgzdU83YjNDbzRBK050Ykw1Q1VnMTFReXZVaEhlbjNqbERjdnBZNmVodW9KUm5xenRCMXo2MDZ0Y1ZGZnM2MGNEQUFCc3VzYnZ2blpIc0t1WFh6WGZoTjk3M1RmQTM1YXFwWmUrK3piOHA1dU9XTnNPRlh1Kzl3YU5nRDg0NlQvV3hwQWZtVzlUUW43WHBUWHRGRVFxR0ozRGZmYkJWYlRqMlBMRTBRKzNmQjNaOHFoaUFNQWNoTjk5cFdmbkdQSTdycWEwL2ZGMXRxdmNPMCtIUjZ6ZFlPOTk5M1VKOXRiL3pzUmcwS0l6U0RieUQ5QjdWbm53RCtmejd2VlJjWjljODRkY3hlSEovTm1xY0I5KzZEbVZDKzhEempsc0dSeU96STVXdWgrR2xnODVBSmdqdDhoaVMxOE8zamRHeFJIZ1Rmc1V0eWI2WGRyK25MUFlaRTJGclpvajFwRndYL2ZkNTMzdk1jakVJQkh3QnlzTStWV1RMWGJJYjFwM1hRV2orZ1BPN3prc1Z5NzhEemgzQWY2SG0vc0J0NUYvU0FJQTVxVzZ1T1ZPVTNkL1lVczFWZWVjdFE3M3hhSDhzQ1hIWmhPMit1NXp2L2NpMDJNUWFORVpHR3ZkaTRPay94Q3pRNVo5OXlSdXFxWnF2c29mY2lwNkQyc1BUVlpVTG9LWmc4cStLVDRRc3cvYlJmOFRBc0F5YUhVdW1nYnkzUmVLYlcvYmNHK2RyN2wyMzMzaHpwSi9wZG5zZnRWMllaRVI4QWZJRC9uZU0vS0hCWE5DL29KcGMrU2d1WUtSUHBYZm5PWURMbnN5VzlWR3VOcGtxL21NQTRCTkZ5dHVMZUJYVzBmdWQ1Rno1RGt5U2Fkd1h6R0lST1YzWDE3VWlrMXJuWFZoU0dqUkdaeElwZHZkQzdleHFhMzhscHY1L2t0dDIzc2ZuemMrSEtieVNvNnovRmJodm5qZWJjV3hjbGVUOXU3SFZnc0EyQVJoZ2FYRmVXaVM1dDZMWDduTytQcXJDbHZocy9IQ2xnMm1qSHozeGRweEpPZTd6K1k3RHRuM0hqMzR3MFRBSDV6a0gzUDRRZWZkYnZVUGNRSC90YmFvM29mUGhpZlZkbW5MY1FyelFlV2lXS2NYN0syVmxUOGtHUUJnTTZRdEk5NVhRZE41YVBYRm80WHB4VStyOTFWYkV4c3hKM3ZHRC9jTjMzMUIxZDZtZ1Q3KzNWY3N3L0xkTjBpMDZBeE9jVnpTTzJUWjJKT1lQVmIra0pqWmxXMWJuYWc3U2ZVK3ZaK0grMnlucDhzSG5JcnAzTU9aM29lYmN6OWZVSXRmQ1FEUXMrSzd6M3NzZnpqMnZaZE4xdUc3YkViZmU1MTNKdHppVmNOb2NlM0RmZkdjOTMzbjNzNkRmZHF5NDArTUFhR0NQelQ1UDdSSU1KNmlTVzZ6UnROcDh5RlhXYjJQOXNnVWh5YzdWeS95WmRaVUxyUlJWRGhzNTQ5b0FFQWZuTysrdHEwNms2OXJFNXY3WTlWNzUzc3ZQRUxodCthb1EyR3JXTFo3NG16cHV5L1A5QnZlOXg0OStNTkR3QitZc0lldmMwL2lISWUvck8yOWoyMVg2VU11VnNINFArMmRUNndseDFYR3Y0cFpJS0d3c3dQSkxBRUpqY25XZG9TSmxDd0FpV3hBc0VCaUFSc2tWbVFSMkRBb2lIaGhKQVFpSWZac0VJdUlFQ1RDSWl5Y2hKVUhCVVlDRmtRWnlVQXlNOEZ2WnN3RXhaSk41Q1RPT3l5NnErcWNxbFBWM2ZmZGQrK3R5ZmV6NXQzYmY2cTZ1dVUrNSt1dnF1dEtlYXFtYWwvY084OE44NzdOQUplMk1jb1JRc2loeWZsamFhaU9kcmJ0Y3JuZDFudEkxaDJ6L2M3WlhNZHFZMHNWNll5MUwwMnRsUEtrbUMrZkRBRUYvbkFFZGFQdE1pYnhsQ2xEclJMM3pWbHpWS25LbFcrSis4SzlnQXBlclFDSCtBREFJRWNJSVljbkdCZmZJallSTG9icFV4RDVnSjQ1SjY5RHNXN0IySExPdXl2dXpTSHFIbXZ0MnFjWGNxVzR2bVFJS1BCSEkzWEhBYzFBcDc5Mzc4a1R2bUZibG55NXpuTXdBQ1BFYTNGZnVoZUFHK0Rtb0NiRmQwSUlJWWVuMzRNZFkvMzBEZWFiNEtnLzNyaEFNNnVzTWJZQVAvZVo5ODJVdUUreVFibjI4U1ZhMTdXUEwrT1MwZUJMdG9PU1g0eU5MNWdHODhMdFVDWitad2FCOW91MU1BNUcyVDFaRkZDT3hBcjNRaVdPR0N4MTBDU0VFSEpnNWxrbFJBUWh4TnhuZHJEcnhObmxTS3laSHJQY1hnNUxOV1U5WTh0OTJGSEdscXF0N0xHdTgxN2NhSHZGeVZqUXdSK01mTE5wRjc4T2RPdWREREdsL0lONmdkVDdwL1pmZEV2V0JibjJpN1ZPZXd0UmJyb1owL2FzOE8xNGUwbWJZbStrY2UzVDk0Vm1FMElJMlR0KzdpdGljbU9JNms0dS9wN3kzaWJ2TytsdU8vWStHMXZyYzE4VzZEbTNxVDhMcHBaeTdmVXdIVElVRlBqRDRRbnloVUMzS2I2c0ZmbDdvam1EQU9EUEhwQVVPYnBEYzlUNTU4UlFETXVaQTF3ZXRvTXM2TXQxY3hYc3FDU0VrT05Tdm5DcnQrUkV1SWRZZlpuRGVoYm12dmVOTFNmM3VlK2M2VStvY2piMytlSytxRXMvTTVDaG9NQWZqWFNmYWllanNXTno3VVluWXc5czY2SzBKWGZaVFhkUDVnQTR0MFEvS013YjdKaERWTzVGZHZrWjVRZ2g1T0FZUWR1YU9uSmVYbVZ1SFNPV0x4MXpXVTE3dWRRZGQ2OTZBVHhqeXhYM3pydG5BdFdMVFlhQ1kvQ0h4SGJWNWJINDVXNlNmd0RrVkFZanJxSVg1S0xyb2JzZDZ5QVhQMHN2eDQ2NWo0RU1wcndPWnNtMVQ4R1FRWTRRUW82T1FQMGdWVG5zZEcyK08xSnVYT3k1emx2Szk4NnNlKzlXYm5QZkZuRS9GMGhsMHZKb0dvSUFkUERIeEhYeDlaTzYzdlZVbll3R0pzaXAxZHAxajBIT0xWOE96VkdYSjFVZTFBT0MvckVRRytqeXozaXJCNEVUdWxTRUVQTDloVFp0UEhFZk41YldUdks2c2JkZm1yMVV5clo0WSs4OTkxNS9Pc2FXdm5wZGNSL05mLzJ1MmlsZEg3SUdDdnpCRURkd3RRS2RmME1lK2pidGordmZPZ1l4bHpCL3BRaDhLU0JwOXowdW5xdlY0b3I3Y2t4K0hxZlBJRWNJSVVmQktOWjltRnVIcE5NUVkwQjU3cjB5dGhydXZmZk9tVzlzclJIMzZwb3F3NHVNQlFYK3FMZ3V2cmRmL1VDUUsvQm4wN2xjbG82elBzaFYxUm4zZnJvdThTSEE2NTdzQnJyNEtaSVBIYjhUUWdnNUtQc3d0L0xtdzdqNFcrdnIvVWlsVjVjM2EwN2VOcGVxakMzVmE5MFM5NkxGdmVSY1NJYUNBbjlBMmpmYUtFNUdnNlRadlNDM29vc3lycXZjKzdodlRoQjVtTDF5OEtmS2FtZGZIWU5CamhCQ2pvaHJiam01cjJsdUhaa2RlNjY5V2VOeUNXZFlLanh6ckRDMjVwM2FScGRrYyt2VXJpTlpoQUovYUlvYkVjQm1KK05Zckp3bjM5WFRpMTJVMnIyUFdyOGVkNi9GUGNyQUpqR3c1V1dSK3VHSkVFTElZZGhxc0pUbWxpZU9UeU5IcnVtNXJuZlBPMnIzWG9sNUlPYys4d0FrVnN3amkvaVd1R2Z1R3c4Sy9OSFFkNW01NFVad011b29WZm9RMDRjWHpXTFFLbCsrMVdVODkxNks4cXE3VVpWTm8yOEs1OTZPMGZmT2dSQkN5RUhSd3JRd3Q3U0lIWUwwOExIY2MyMytwanlsSGY3Q3ZSZWdOVFFuSHo4YWhPV3duRUxjRDNJNVNZWUNmMUM4OFlqZC9WdE94cFpmM2x0eTNWZjlnbTJ6Z2ZQSDhoaEV6NFhwajcyM0RvYlhQV2tER3RLRGd2NVZQK0NjUTNRSUllUVllTU1rcTNmUXltN2RQWmhiTytZOWJ6anBpb04xTmttOWkzTHZZNDV6dTdlMXNZVXk5K1h2UFhIUDNEY2VGUGlENGQxaUxTZWpYMnJwT0R1Sy9MMmdIWFBBbk05Q2tQUEczcGNPUmhMc3lnWEt6bjlJd2F4MDd1bGlFRUxJcWVEMTlHNHZ0YTdRbnZLZU8vNWU5MExycnpxWExSMC8xT1VkOTM3YUZzVitQcndkZSsrSWV6RDVqUWdGL29oNHczUXFKNk5WNXJBMzZjVm5KZkNDbk9Qa0lHNnZ4OTZuTXQ0WWVoVzhzcE5SQjFvYjZBZ2hoQnlTR0ovMWltVnpxMVBiVVdhUnE1c3hmV3pydVM2SDU2U2VhK1BlR3dWZkQ4MUpQZE96ZHBncTlzVjlXWlFNQVFYK3dMU0g2YWdidEZmK0V0cTBpdDRzQXE1bzd3dHJTYk1MZUYyVTBuYnZVL0RTam40T29LNjRaNVFqaEpDajBoNm1VK2ErUEhYeTZYc3pmdTZiTnEzc3VkYXJIV0dlVGF6OHdKQ0c1blRGdlo3SWc0d0NCZjVvaUhPYjdjM0prR0xMeFc3b2JXTVFWeHhMZFNIcWRjbUJjTHNvY3hDc0hYOUpIUVJRU1NDN0dtbzJuVmpIY2lzSklZUmNBclhUdlZ0RXp2cC93enRvcSt1K21CaHVEOCt4N2ozTTJ2emVXZG1hVkVhUHZ6ZTVyOGpVeVlBcnhEM05yZUdnd0IrTUhKaWNtKzBTbkl5RFNOcGtUZ1RrZ0JRM2xFRnUzcmNLY3RPNTJ5NUs1MURHdmM4bFd3NUdKZTRaNHdnaDVQQm94MXF2VHA4TmM2dmIwOTA0MUY0RGZVeHdsOU56blk1aGNyMHo5ajRlcDhwOVVBYVk0K0FuZzJ6ZDJaTFQ0UWVPM1FDeUc0SXd5V0VSaEJDRjhmWVhnVklwQ1VBUXJLcm5JaThjaWZwQmpyVkZUSnZLNEI3VU92dHdvTHNvNitDMDVHQ2M2M2laQWlGbkVpQ0VrR1BnNUoyWUdrU0FFSnJwYThxWHNwRGVGbkxmcFV3d3NTS2ZOSHV1Z2NuUXk3a3F2M2VXemJIYXZZZGFiN09mYTJ3SlZqV1RuQjUwOEVlakdHK1gxMStPazdFci9lRTVqZVdHaXhHMzFScGRPZnhwdTNaTDlMR3kwcS9kZTdRZEROVTlTWEZQQ0NISElVZDROWjk3WTg4VXc5UHlZYWl6Vk9mWU1WWHRvZWZhUGdGSWRWanIzaGRHWHN4ejJoaUxPVThmaC9sdk9DandoeU5Bdi9GZXNYQVRyaHVtNHdXUjlXemEzd1M1K1hzdnlIbW5uQ3RSTzhWZ1ZuUlJ4bTlOOXg1bVczNHdRUDVPQ0NIa3NHaHpxNXdOcHZxMmJHNGxRNmd4bTg3Rjg1NWEzcUhudWxrWGJGNnoyL1JFRVkxMGxkeDdNVmZPR2xzNjVla0hBeklTRlBqRFViL0E0MDRYcVFUcWtwT3hadTNhbTNzNXlQVkhGV2E4TVlneGNDa25wM1EwWkRwT0Z2MTJlakJKZGJmYyszek03UFRQOVlsM3JRa2hoRncrd2M4ZFNhT1diblpERkcveW4zYk5lLzVlOW12T1VSYnYxMnVkdXBKSW4vZWVjNTg5bGpOckhEejN2aHpxR2swdzFRYm12dUdnd0I4VlVTL041cFhxMndvbnc5eXZwWlBoSEhJaGlHM3FuaXozNlFXUEZiUG4rS0d3Y0d2TWpEaDFpNnZ4aDRpQlVkVGxZcEFqaEpERG8rUDUwakNkZWI5VjVsYmJ4WitXdHVhOTlkaDN5TlR4QlRBencxV0phdDVlL2ZaTnpGVmVMcGVVMzZ4N1A1OUY2ZDRqNXNyOGdFREdnZ0ovTVBLVDlCd1k5RjBueGZhRzNkSDdVWTNsNDdjQzVZSzQ5OXo3Rkx2V2owSDBqMXYrVkhrT2NzMHVTdVZRZU82OWVnWlE1UmprQ0NIa2FMVGVRVk81WmZzN2FPNkJHclczanRvcFgrWStuVmhVUWhHMXZ0ZHpiWTl0ODZidHVjNzFUMy9yZHVqM3preWRLUysycHQ4a0kwQ0JQeHF6NkYwZXBxTUxGTUxVY2ZIYlRrWWRUTVg1ejJta1dtek1mckRKR2JGQnpodURhSWZuNUVUUTdhS01OYWhUdFM4WjZXQkhDQ0hrR0dTUjZyeURsbEphejl4U2VhTXFXdWErWWllc3pYdEZ2dXowaXZ2dXZUT3hSSmxPbmFHcDlsakZvNDdiYzIwZkxHeitpKzJRdEpIcGIwd284SWRFM1p6T01KMUZKd08raTI4QzNVS3dXOU8yYVZIOWdxeTd0eGVzUXY3MFpzOUo3UlNuN0lybVJlYytpdi9TTlRGQkxqc1lRcUZQQ0NISHdSR253Qlp6cXpDTWRoRDVDNDFUaXpHSHptM3c5blhkKzlpdXhvTkJkMmhxRlBLdHNzcFhNKzY5YnBjeXRBU21mdWErOGFEQUh3NzdWSjZkNnJSNS9xeWRqQ1VYUHhlUEFXaHJzRnNwN3JVdG9RVjJGZVFhVlJkakVIVzU5QU1mamN0aTJwS2FvSVlJVlVHdWREQXVZeTVrUWdnaHEybThneVpwVzhQY011WDJKZkxiZWEvYW1qeWtuck52WlBYYzdMaFVURDZoM1BmbXhCSnBXOTBlNDl3YlkwdlgxV3dxT1hFbzhFY2szZHN0SjhOVHgvVmQyZ295dTRuODdlTGVQNzRLWUlWRDRRYzU5WERRbVVIQUJNQ3F0V0lEWFdxSGMzeEdPMElJT1FMSzNHcThnNWJwekNUWGllSGJSZjVXY1MvbENzYzg2cjFjNjdoWGpmYmthNFVzQWZTdzFkTFVpc25QR1hzdldmMlRnYURBSDR6cXZ2YUdzRWkrdWEyVDBRcDA5YzJiYis0NTJEWEg1aGNQRDkydVNWMURER0k2eUdtRjNaajd2Z2h5NjJQT0xQS05LMTgrK09TNlUwQ3JIQXhHT1VJSU9Rb3J6SzM2VzIrSWFpZjNYVER2dGRLR1B5elZ1RXUySmU0UTF2TGwxMmhpTlNhVzBFMkkxekMyVit6WnRHYk91Y2hzUWVRNFVPQVBpblV5a0FKR2YwNzhGWUhPM05CTFFsOVh0U0xBTlJ3TTAxYmtRRkk1Q0ZWSi94Zjh5aUJuejZQemNxMm9lcjBFUWhPREVFS09RalhFdEdGdTVaMWJMajdRRzZxVHE5bEQza3VWcVMydXNlWDBYRmR0aXVQdXk0Y0JPM3RPU21hSU9jMW1RRjFqMWVsUDkvNlJnZ0ovT096Tm5jVndiendpMWdlNlJyQnpBNTcrdHlIQWxRNkc2OTU3WFpUVmVhb2dxUU9aN29iVXdVbmlkYkZSelN3TFVobWJQcHd1WVVJSUlRY2tSdVY2TnAzS3hlK054VTlDZWdlRGEyM2VpMFZWM2hPMW5NbE8rdHFYYSszcWNtZ3Ewdm1iRTNHRzU1Z2RKRjgzMTcxbjZoc09DdnpSa1BCdEVaem41U3hvMitNUnRWajFBdDM1ckduYmprYXMwZ1E4OVc5TmdKdStlVU56Y3J0NlkrK1ZrdDhvdEpWZ1Q1ZXFKZkxWOTNtLy9MUGVBQkMrdGVIQWhCQkM5b0pNc2Jjd2FpcHp5NlNHam92dmlYd245KzJjOXdweGowSllsOFpXZmloUjVkejN6c29IaFZqK29zTnpkTSsxT3Y3MDlSeVFiL3UxazFPRkFuOHd2bkx6RDk4RzhGb09WdlhQZDJ0Qm5KL2tlNEZ1WHIvZ2FLZzlxMy9OblVyM1FzN3p1aXJZVHVkajZqQjd0SUpjZi9hY0hEQzk0VG5CaWV2bCtFYlRhL0NxZDdxRUVFSXVFUWxuM2pDZEZQaGhqUnNybUlINlBUU2tzbFhQOEY3eTNocHhYOHlLbytzeE8rdkVKblkxOUhabFNPbHRWWHVMNFRreVZ6aVhjZHo3Qi9mdlhIL2JPMlZ5dWxEZ0Q0bThtbTlBTGVaejk1MDNvNDROSWl0RmZsTE5LQ05FbzJseHZ6VUJUaDgzRmx0eTc3MGcxNTg5SjI5YUhwNlRaOHJSRHdSenVhbHRGUGlFRUhKd29ybFNtMXQ5RnovbWtSalRQWkh2OVdKZkxPK2xkblhGZmN4UmFsNzdLb2RIZ25yMldOTW8xWnlsNFRsUXVUQ2xYUDJnUTJOclJDandSMFRDM2ZsTGppbnVyK0xCQ09mSjlWNHA4dWRnMXhYNzFUKzlNSmNYUUx2MnFTbEZBN3NPQm5UZzlZSmNyTU1idjZqcVQ2ZlFFdm1xem5tLzRnV2pienk0YzUxRGRBZ2g1TUI4NWViSC9nK0MvL1hNTFczK0xQZGdleUlmcVk2OTVMMXU3clBpM2piRE80ZGlXbWgxL3N1LysySjJuNnRVdmRibStPVm9nUHplbVFCM3k2dEZUaDhLL0FFUm5MK2toZWgwb3l2SjIrbXViSW44U25SRHB1RFVFL3ZWdnpLNGxXNUJUOXgzSEF3VndIV1FpOEZTenlCd09jTnowc0ZlQWlHRWtDTWhjd3d1emEzWjRPbjJZT3MvV2VSN2J2NkY4MTRoN0lFRmNTLzZmS3B6VGc4U2tuZkh1dDk5c2Rrc1h6dDFmUVNxbktEU0RkTjFaZTRiRUFyOE1ma3NKSHczNmQvNEp5MTczWlY5a1o4MlZiVEZmdld2Q200cXVDcEJudXIxeEgxcWl4THRLWUNuWXVwa0wyRjRqbmxReUVGT1JEN2pYU0ZDQ0NHWGowQStrL3dXSGRjZE0ya3VZRTBqOHlmM2VydHUvaDd5WHF4N25iajNjbC84TEpNOVZEMmRudXRLdUd2UlgydUEzQ1RUd084QzRlK2NnNUFUaHdKL1FHN2RmTzZiZ0h4eFdrb1J6QWE2S2xqRWZkQVErZlAyWE5SQkJ6M25ueFBjMHVGU2VSM2dISEV2Y05zVkhZd2lNaUoxVWU1emVFNXF0em5XNjBENFF1dktFRUlJdVhRK0QrRDE2V3QydmEyWDB4YktlWi8wSjVWczU3N2Q4cDQ2SkRhTGUrU2NWcDFqU29NNTErdGZXZGNTZm52UGRWNU9kUU5mZUhEMytqZmRFeVFuRFFYK29BamtlYVhqVndhNnVXVGFGcFNJOVlOZFgvQjMybWZLRmlJNnRiTVc5MlVsa2o3anVlVDJHZmQrRG5KMkJvRjRiQnU4VXJ0V0J6bEFnRDk1Y1BmNmQ3WmZDVUlJSWZ2ZzFzM252aU00LzlPY0E0QVkvN1BKN1F6VjBVSjYvcjRtOTIybHpwdGwzWFU3UEhGdnpDeGpiTm5FcFkydFhLL2FEVnQ3cmxVT3pSVS92LzFLa0ZPQUFuOVFidDE4N21WQVBtMVY2cHBBTi8weElqOXVyd0pTWEs0Ri85SS90NTQ1bUZRQlRxbnNLaURuSmxzSEEvWUZveG8vZUpVQnQ3MmZ1azZRMnhEOGtYY1VRZ2doQitWNVNMZzlmYzNES1ZOUExmUk1jSFZPV1pmN0xwTDMycmxQbTFvOWNTL3BNMjVYNXlvQjFyMjNyYzdmczlqZjBuTmQ4RmNQN2w2LzBkdUJuQzRVK0FNamtJOUF3cHZtNW9jVDZKWkVmalBZZVRlK2RQNDUrMG9oN0wwQTF4SDN2b01CbEdQdjEzZFJ0bVlRa0dJLzFTN2d3dy91WG4vTE9VRkNDQ0VINU5iTjU5NFNuSDlZbXp2WkJKS1VMNnhtenJsbFhlNHIyWkwzMVA2TjNBZlYrTGE0VDFYa3BtdGpTMC9qbko0eTR0bmw4MUpWYit5NWxqY0UrRWpqQk1rQVBIYnNCcERkZVhoMjQ0M0hyeng3S3lEOE1vQjNoQkNBQUFUWXorbWJBR0VLQ0NFbzBadTJ4MlVybk5PV3hpOW91K2dIRFRPOXBhak5Kc0kweGIzSWVWeU43R0JnRG5KMjNHVDV3S0JiWVpmMWdXUGx6ZUU1Zi96Z3p2V1ByejUzUWdnaGw4ckRzeHV2UEhIbFozNFlJVHdUWWc2YlAxWGFVK3NuYk82YjgyR3hQQ0VxZjY3RTVEMWRjenYzOWNWOThmUUN6TWFXZlhpd2RVT3RuK3VxZXE1Umw2OTdycjhIaEY5NWNPZjZ2MjY0QXVURW9NQWZuRG5RM1VmQWg0QmEzT3NnTmNXN0hMRzZ3YTdZZDZMbFZwaEM5bnNaZkZyQ2Zscm9pUHNzOG5NMXhZK1NZRTJRaS92bDVkeVZxY2NnQWdKOENwRGZldk4xeGpoQ0NEa2xIci95N0JjRHdvOEJlTytpeUZjR0Y2QnlYOTZway90MnlYdGU2WjZwRmRSM0tIZC9LbWVOTFozN3JMR2wzWHVONmJrMkZsZGhmMldEN0RmdjMzbnhyMWVjT0RsaEtQQWZBUjZldmZ4dlQ3em4vZDlDd0FkRFZ2YXJSUDYwV0R2Nlp0RWpoSGxyYU1hL1ZtQURDbUUvclZnUTk4cTFNQTZHT2xaeUluSkJmUlMvaTNLZUQ3bmFHNThGOEd2Mzcxei9YdU1LRUVJSU9SSVB6MjdnOFN2UGZpNGdQQW5nSjNjVytXbEYrck9udkRjdjlYSmZFdmV5V3R5dmRlOEYxcjAzVTIybUhGbjFYSjhEOGp2M2I3LzRpZFlsSU9OQWdmK0k4UERzNVM4OThaNzMveE9BbndzQlAyUUNuSkt5TVVDVndXN2E1SVMxVUgxWmdaaVB0TFlVOWRQS0JmZENPeDBodWUyaUlwbzNjMDR5KzkwdVN2MkFFQXVsTVp0dkEvamRlN2RmK08wM1gvK1g4dzBuVFFnaDVJQThQTHR4L3ZpVlovOG1JTHdKNEFNaDRCMDlnMnQxN3R0ajNnTjhROHZzbXRPUTJpenBVeCtqTlN5MWN1OVRYUUUyTTZydktrZUt5UDlBOEl2M2JyLzRxUTBuVFU2WUxmLzNrZ0c0K3RTMWR5UGdMMExBenlZM0lnMEZES3VDM2JUcmZ2N1hhSWw2SUhZejVraGxYZzZ1eEgxMk1HSlEwOU41SmRkQ1pITC9WWDFtMkkxSWRqWmlUMEhlNXo5RTVOZnZmZTJGTCszbDVBa2hoQnlFcTA5ZGV4OEMvaklFL0xnMXVERG5QdWhrZU9UY3A1ZVZjVlhsUUwzZTVrVnRiT1YxNXpibnBRY0NtLzlpN3B0Mk9ZY0lQaThpdjNIdmF5L2MyOHZKazVPQUF2OFI1ZXJUMTM0YXdFZER3QWROdCtVYzFGeWhEN2dCVDlNTGZtNUF5eHVuRHkzcXB4VXBlT2xBWndOYzhNVjlQR1p5NzFYQTArUHB2U0JuSHc1ZWdjakhST1RUWjEvOUpJZmtFRUxJZ0Z4OTZ0cGpDUGpWRVBCN1FQZ0pBR2JJenZ5dEZ2cG1YYzNPZVcvYVlmb3docGJPZDByMHJ4VDMxdGpLKytjOEYvTWZBSnhYT1ZFdC80T0kvTUhaVnovNWovMlRJQ05DZ2YrSWMvWHBhMCtGZ0Y4Q3dzOGo0TWs4d3RBVCt0TzJjbFRla3VodjBoVDFaWENieDhHci9zbzZ3T1gxcThSOTRkNDdEc2FaeVBsTEVQeTlpSHp1MWYvNmN3cDdRZ2g1QkxqNjlMWEhBSHdvQlB6Q25QdmVuWEpmODMyMEl2ZGRNTzhCYTNLZkZ2YlRsenlpVk9XeHVhejVFYXBkaksycHNpL1B1ZTl2Ly9zL1AzRnp0NU1rSTBDQi8zM0VrODljdXdLRXB4SHdvd0Y0RnhEZUJjZzdvejBSbFBDdmllR3g3MWFZbVczTUJoWFkwckxhMHpnWFFCcVNrNzdEZCs3ajlyUnNBOTFjNTFzaThocEVYaE9SQnlMNDh0ZGYrYk4vNzU0SUlZU1FSNElubi9uOTl3TDRLUVQ4aU1wOVA1aG5qMnZsdmd2bVBjREpmWGsvMzlRS0t2ZjV6bjB0N3EwWk5vdDhBZVFORWJ3MjU3LzdJdkxQWDMvbDQ2OHVYakR5U1BEL0Jja3duSWJUaFY0QUFBQUFTVVZPUks1Q1lJST0iLz48L2RlZnM+PC9zdmc+\"","export default \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+Cjxzdmcgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDIyMTMgMTAwNyIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4bWw6c3BhY2U9InByZXNlcnZlIiB4bWxuczpzZXJpZj0iaHR0cDovL3d3dy5zZXJpZi5jb20vIiBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjI7Ij4KICAgIDxnIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsLTI1NzEsLTM2KSI+CiAgICAgICAgPGcgaWQ9IlBsYW4tZGUtdHJhdmFpbDIiIHNlcmlmOmlkPSJQbGFuIGRlIHRyYXZhaWwyIiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwwLjkzMjQwNywwLDM2KSI+CiAgICAgICAgICAgIDxyZWN0IHg9IjI1NzEiIHk9IjAiIHdpZHRoPSIyMjEzIiBoZWlnaHQ9IjEwODAiIHN0eWxlPSJmaWxsOm5vbmU7Ii8+CiAgICAgICAgICAgIDxnIHRyYW5zZm9ybT0ibWF0cml4KDcuMTAwNDMsMCwwLDcuNjE1MTYsLTMxMzMuNzEsLTM1ODIuNzUpIj4KICAgICAgICAgICAgICAgIDxnIHRyYW5zZm9ybT0ibWF0cml4KDIuMDc1NjgsMCwwLDIuMDc1NjgsMTA1MS43Miw1MTEuNjgzKSI+CiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD0iTTAsMjcuMTI1Qy02LjI5LDMwLjU2OCAtMTIuMTM5LDMyLjYxNiAtMTYuNzg1LDMzLjg2M0MtMTUuMTI4LDMxLjMwOSAtMTAuMTIzLDIyLjg3NCAtMTEuMzE2LDExLjQ4MkMtMTIuMTc4LDMuMjU4IC0xNS44NjUsLTIuNTMxIC0xNy44MDEsLTUuMTc1Qy0xMi43NiwtMy42MDYgLTYuNjYzLC0xLjI2MSAtMC4xMjgsMi4zMzJDNy4xMTEsNi4zMDUgMTIuODAzLDEwLjY2OCAxNy4wMzksMTQuNDFDMTMuMjA3LDE4LjIwNiA3LjU5NywyMi45NjQgMCwyNy4xMjVNLTQ0LjE3OCwzNy41NzVDLTU3LjMwMiwzNy41NzUgLTY3Ljk0NywyNi45MzggLTY3Ljk0NywxMy44MDVDLTY3Ljk0NywwLjY4MSAtNTcuMzAyLC05Ljk2NCAtNDQuMTc4LC05Ljk2NEMtMzEuMDQ2LC05Ljk2NCAtMjAuNDA4LDAuNjgxIC0yMC40MDgsMTMuODA1Qy0yMC40MDgsMjYuOTM4IC0zMS4wNDYsMzcuNTc1IC00NC4xNzgsMzcuNTc1TS03MS4xNjgsMzMuMTc1Qy03NS44MTMsMzEuOTIxIC04MS42NjIsMjkuODgxIC04Ny45NTIsMjYuNDM4Qy05NS41NDksMjIuMjc3IC0xMDEuMTU5LDE3LjUxOSAtMTA0Ljk5MSwxMy43MjNDLTEwMC43NTYsOS45NzQgLTk1LjA2Myw1LjYxOCAtODcuODI1LDEuNjQ1Qy04MS4yODksLTEuOTU2IC03NS4xOTMsLTQuMzAyIC03MC4xNTEsLTUuODYyQy03Mi4wODYsLTMuMjI2IC03NS43NzYsMi41NzEgLTc2LjYzNSwxMC43OTVDLTc3LjgzOCwyMi4xODEgLTcyLjgyNSwzMC42MiAtNzEuMTY4LDMzLjE3NU0tMzUuMTg1LC0xOS4wODRDLTU3LjIyOCwtMjEuMjE0IC03NC4wNzIsLTE0LjQzMSAtODIuNzM3LC0xMC44MjJDLTEwMC44MzgsLTMuMjg2IC0xMTIuOTY5LDcuNDI2IC0xMTkuNjE3LDE0LjIzMUMtMTEzLjU0NCwyMC4wODggLTEwNC4wOCwyOC4wMjkgLTkxLjAwOCwzNC44MjZDLTgxLjQ3NiwzOS43NzggLTY1LjAxMiw0OC4zMzkgLTQyLjU2NCw0OC4xNzZDLTEzLjI5LDQ3Ljk2NyA3LjUzNywzMy4wNjMgMTUuNjcxLDI3LjA3M0MyMi4zNjMsMjIuMTQzIDI3LjMxNiwxNy4zMDIgMzAuNTM3LDEzLjg1OEMyNS44ODMsOS4zNjEgMTkuMDAzLDMuNDA3IDkuODIxLC0yLjNDMC41MzgsLTguMDc0IC0xNC4yOSwtMTcuMDY4IC0zNS4xODUsLTE5LjA4NCIgc3R5bGU9ImZpbGw6d2hpdGU7ZmlsbC1ydWxlOm5vbnplcm87Ii8+CiAgICAgICAgICAgICAgICA8L2c+CiAgICAgICAgICAgICAgICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgyLjA3NTY4LDAsMCwyLjA3NTY4LDk1OS40NzMsNTI4LjY5NCkiPgogICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9Ik0wLDEyLjI5N0MtMy41ODMsMTIuMjk3IC02LjQ3OSw5LjM5MiAtNi40NzksNS44MTdDLTYuNDc5LDIuMjQgLTMuNTgzLC0wLjY2NCAwLC0wLjY2NEMzLjU3NiwtMC42NjQgNi40OCwyLjI0IDYuNDgsNS44MTdDNi40OCw5LjM5MiAzLjU3NiwxMi4yOTcgMCwxMi4yOTdNMC4yNTMsLTkuMDIyQy04LjEyNywtOS4wMjIgLTE0LjkxOCwtMi4yMjUgLTE0LjkxOCw2LjE0OUMtMTQuOTE4LDE0LjUyOSAtOC4xMjcsMjEuMzE5IDAuMjUzLDIxLjMxOUM4LjYzMywyMS4zMTkgMTUuNDI1LDE0LjUyOSAxNS40MjUsNi4xNDlDMTUuNDI1LC0yLjIyNSA4LjYzMywtOS4wMjIgMC4yNTMsLTkuMDIyIiBzdHlsZT0iZmlsbDp3aGl0ZTtmaWxsLXJ1bGU6bm9uemVybzsiLz4KICAgICAgICAgICAgICAgIDwvZz4KICAgICAgICAgICAgPC9nPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+Cg==\"","export default \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+PCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj48c3ZnIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIHZpZXdCb3g9IjAgMCAxOTIwIDEwODAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgeG1sbnM6c2VyaWY9Imh0dHA6Ly93d3cuc2VyaWYuY29tLyIgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoyOyI+PHJlY3QgaWQ9IlBsYW4tZGUtdHJhdmFpbDEiIHNlcmlmOmlkPSJQbGFuIGRlIHRyYXZhaWwxIiB4PSIwIiB5PSIwIiB3aWR0aD0iMTkyMCIgaGVpZ2h0PSIxMDgwIiBzdHlsZT0iZmlsbDpub25lOyIvPjxjbGlwUGF0aCBpZD0iX2NsaXAxIj48cmVjdCBpZD0iUGxhbi1kZS10cmF2YWlsMTEiIHNlcmlmOmlkPSJQbGFuIGRlIHRyYXZhaWwxIiB4PSIwIiB5PSIwIiB3aWR0aD0iMTkyMCIgaGVpZ2h0PSIxMDgwIi8+PC9jbGlwUGF0aD48ZyBjbGlwLXBhdGg9InVybCgjX2NsaXAxKSI+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjE5NDMuNTkiIGhlaWdodD0iODI3LjgzIiBzdHlsZT0iZmlsbDp1cmwoI19MaW5lYXIyKTsiLz48dXNlIHhsaW5rOmhyZWY9IiNfSW1hZ2UzIiB4PSIxMzA4IiB5PSI0OTUiIHdpZHRoPSI0MjJweCIgaGVpZ2h0PSI0MjlweCIvPjx1c2UgeGxpbms6aHJlZj0iI19JbWFnZTQiIHg9IjcwNy43NjQiIHk9IjUyLjIwOCIgd2lkdGg9IjEyMTIuNTJweCIgaGVpZ2h0PSIxMDI3LjhweCIgdHJhbnNmb3JtPSJtYXRyaXgoMC45OTk2MDIsMCwwLDAuOTk5ODA3LDAsMCkiLz48cmVjdCB4PSIxMzc5LjQ1IiB5PSI3NTQuNjcxIiB3aWR0aD0iNTQwLjU0OSIgaGVpZ2h0PSIxNDYuMzE4IiBzdHlsZT0iZmlsbDojZjg5ZjgxOyIvPjxjbGlwUGF0aCBpZD0iX2NsaXA1Ij48cmVjdCB4PSIxMzc5LjQ1IiB5PSI3NTQuNjcxIiB3aWR0aD0iNTQwLjU0OSIgaGVpZ2h0PSIxNDYuMzE4Ii8+PC9jbGlwUGF0aD48ZyBjbGlwLXBhdGg9InVybCgjX2NsaXA1KSI+PHVzZSB4bGluazpocmVmPSIjX0ltYWdlNiIgeD0iMTM4Ny42IiB5PSI3NTguNDQxIiB3aWR0aD0iNTMzLjU1NHB4IiBoZWlnaHQ9IjEyMS4zOTRweCIgdHJhbnNmb3JtPSJtYXRyaXgoMC45OTkxNjYsMCwwLDAuOTk1MDMsMCwwKSIvPjwvZz48cGF0aCBkPSJNNTU1Ljg5Miw3MjEuOTc3YzE2NC45OCwwLjg1NCAzNTcuODY4LC00MC44MjkgNDk1LjQ0LC0xNS40MThjNTYuNjMxLDE3LjQ1NSA2Ni4zNCw3LjA2MiAxMDguODc1LDkuODE4YzEwOS44Niw3LjExOCAyMzIuNjgzLDI4LjkwNyAzMzIuNDE1LDY1LjU4N2wtMTk2LjAyNSwxMDIuMDAzbC03NDAuNzA1LC0xNjEuOTlaIiBzdHlsZT0iZmlsbDojZTM4NzdhOyIvPjxjbGlwUGF0aCBpZD0iX2NsaXA3Ij48cGF0aCBkPSJNNTU1Ljg5Miw3MjEuOTc3YzE2NC45OCwwLjg1NCAzNTcuODY4LC00MC44MjkgNDk1LjQ0LC0xNS40MThjNTYuNjMxLDE3LjQ1NSA2Ni4zNCw3LjA2MiAxMDguODc1LDkuODE4YzEwOS44Niw3LjExOCAyMzIuNjgzLDI4LjkwNyAzMzIuNDE1LDY1LjU4N2wtMTk2LjAyNSwxMDIuMDAzbC03NDAuNzA1LC0xNjEuOTlaIi8+PC9jbGlwUGF0aD48ZyBjbGlwLXBhdGg9InVybCgjX2NsaXA3KSI+PHVzZSB4bGluazpocmVmPSIjX0ltYWdlOCIgeD0iNjg1LjMxNCIgeT0iNjk5LjczMiIgd2lkdGg9IjgwMC42MjlweCIgaGVpZ2h0PSIxNzguNjQzcHgiIHRyYW5zZm9ybT0ibWF0cml4KDAuOTk5NTM2LDAsMCwwLjk5ODAwNywwLDApIi8+PC9nPjxwYXRoIGQ9Ik0xOTIwLDg1NS4wNzVjLTU0LjM4NywtMTguNzA4IC0xMjIuNTM3LC0zMC4xIC0yNDkuNjQ0LC00Ny40NzhjLTYyLjMzNywtOC41MjIgLTI1My4xNCwtNTkuNjQ4IC0zMjcuOTg5LC01MC42MTFjLTg2LjQzMSwxMC40MzYgLTU2LjgwMyw5LjY5MyAtMTMxLjE3OSwxMy41MjdjLTQ5Ljc3NCwyLjU2NiAtMTM2LjM3MywtNDMuMTgxIC0xODEuOTEyLC0zMC41MjdjLTExNy4xNjEsMzIuNTU1IC0yMzkuNzQ1LC0yMS40MTkgLTMwNS42NCwtMTcuODM3bC03MjMuNjM2LDE3LjgzN2wwLDM0MC4wMTRsMTkyMCwwbDAsLTIyNC45MjVaIiBzdHlsZT0iZmlsbDojZmFiMDgxOyIvPjx1c2UgeGxpbms6aHJlZj0iI19JbWFnZTkiIHg9IjAiIHk9IjcxOCIgd2lkdGg9IjE5MjBweCIgaGVpZ2h0PSIzNjJweCIvPjxnIGlkPSJNYWlzb24tLS1PbWJyZSIgc2VyaWY6aWQ9Ik1haXNvbiArIE9tYnJlIj48cGF0aCBkPSJNNjMyLjY5Miw4MzYuMTQ2YzAsMCAtMTcwLjczNiwxMzUuNDg3IC0yMjAuMDQ1LDE3NC42MTZjLTguNTM4LDYuNzc1IC0xOS4xMTcsMTAuNDYzIC0zMC4wMTcsMTAuNDYzbC0xMTkuNDA5LC0wYy04Ni41NzgsODMuMjA1IC0xNTMuMzIyLDg4Ljc2MiAtMjE5LjA2NCw5MC4zOTVsLTEzOS4wNjUsLTYyLjU3Nmw1MC43NiwtMjI1LjY4OWw2NzYuODQsMTIuNzkxWiIgc3R5bGU9ImZpbGw6dXJsKCNfTGluZWFyMTApOyIvPjxnIGlkPSJNYWlzb24iPjxwYXRoIGQ9Ik02MDguMjU2LDY2Ni4wMTVsLTMwMS4xNzgsLTBsLTE2Mi44NTQsLTQwbDAsMjMxLjE3OGwxNzguMzE0LC0wLjQ4MWwyOS44NCwtNy4xNjNsMTE3LjEzOSwtMC4zNTZsMTM4LjczOSwtMjBsMCwtMTYzLjE3OFoiIHN0eWxlPSJmaWxsOiNjMjcxNzc7Ii8+PHBhdGggZD0iTTU4MC41MTQsNzY0Ljk1MWwtMTA4LjM3NiwwLjU4M2wwLC0zLjI2OWwtMTIwLjE1OSwtMC4zMTRsMC40NzQsODcuNzgxbDIyOC4wNjEsLTAuOTE0bC0wLC04My44NjdaIiBzdHlsZT0iZmlsbDojYTc1NTViOyIvPjxwYXRoIGQ9Ik01ODAuNTE0LDg0OC44MThsNTIuMTc4LC0xMy44NDFsMCwtNjkuMzY1bC02LjA5NSwwYy0wLjY4MiwtNTMuNTQ5IC00Ljc4MSwtMTAwLjc5OSAtMTkuMzA1LC05OS41NzRjLTEzLjkxOSwxMC44ODIgLTE3LjY1Niw1MC4wNDkgLTE4LjYzMyw5Ni44ODhsLTguMTQ1LDJsLTAsODMuODkyWiIgc3R5bGU9ImZpbGw6I2Y4OWY4MTsiLz48cGF0aCBkPSJNNTk2LjMzLDg0NC42NWwyMS40MTksLTUuNjg4YzIuMDUxLC03NS45MDkgMC43NiwtMTMyLjY4MSAtOS4xODUsLTEzNC4zMjZjLTE0LjM2MywtMy4wMzcgLTEzLjM0Niw1OC4wNTMgLTEyLjIzNCwxNDAuMDE0WiIgc3R5bGU9ImZpbGw6IzUwMjcyYTsiLz48cmVjdCB4PSIwIiB5PSI2NjYuMDE1IiB3aWR0aD0iNzEuNjgyIiBoZWlnaHQ9Ijk2LjkxMiIgc3R5bGU9ImZpbGw6I2MyNzE3NzsiLz48cGF0aCBkPSJNMTM4Ljc4OCw2MjYuMDE1bDM4LjQzNCwxOTkuODg1bDE0NS4zMTYsMzEuNjMybDI5LjkxNSwtNy45NTFsMCwtMjUyLjQ0NmwtMjEzLjY2NSwyOC44OFoiIHN0eWxlPSJmaWxsOiNjMjcxNzc7Ii8+PHBhdGggZD0iTTMyMi41MzgsNzYyLjkyNmwtNTMuMTM0LDBjLTAuNTYsLTcwLjg2MSAtNTMuODc2LC0xMTQuMjIzIC0xMjYuNTA2LC0xMTYuNTAxYy02OS4yMDIsMi41ODcgLTExMC44NDgsNTIuOTU4IC0xMTEuOTMyLDExNi41MDFsLTMwLjk2NiwwbDAsOTQuNjA2bDMyMi41MzgsMGwwLC05NC42MDZaIiBzdHlsZT0iZmlsbDojNTAyNzJhOyIvPjxwYXRoIGQ9Ik00ODEuMzk2LDY4Ni42MzhjLTYuMjI4LDE1LjAxNiAtOC4zNjgsMzguMTMgLTkuMzE1LDc2LjI4OGwtMTYzLjcyLDBjLTguMzc2LC03OC41MjEgLTU1LjEwNCwtMTIzLjk0NCAtMTY0LjUwOSwtMTE1LjI3NmMtODMuMjc3LDkuMDQ4IC0xMDYuMTE1LDU0LjAyOCAtMTEyLjgwOCwxMDguNjA1bC0wLjA3OCwwLjY0M2MwLC0xMzYuMzI5IDExMC42ODIsLTI0Ny4wMSAyNDcuMDEsLTI0Ny4wMWMxMDQuMzczLC0wIDE5My43MTQsNjQuODc1IDIyOS44NjYsMTU2LjQ3N2wtMC41MSwwLjAwMWMtMzQuMzE2LC02Ny4xNDggLTgzLjYzMiwtMTA5LjA3MSAtMTEwLjQ3OSwtMTIyLjcwOWMyMi43OTgsMTguMTM5IDI5LjcyNSwyOS45NjEgNDIuODc2LDQ5LjIxN2MtMjMuMDg3LC0xNi40MTUgLTIyLjI1MiwtMTYuMjAyIC00Mi44NzYsLTIwLjc3N2MyNy4wOCwxMy45NzkgNzUuNzM3LDg2LjIxNSA4Mi4yNzEsMTIwLjYwNGMwLjY3NywtMi4xNzkgMS40MjgsLTQuMjAzIDIuMjcyLC02LjA2M1oiIHN0eWxlPSJmaWxsOiNhNzU1NWI7Ii8+PHBhdGggZD0iTTQ4Mi42MDQsNjg0LjAwM2wtMC43MDQsMS40NjhsMC4zMTQsLTAuNzI2bDAuMzksLTAuNzQyWiIgc3R5bGU9ImZpbGw6I2E3NTU1YjsiLz48cGF0aCBkPSJNNTA0LjM3OSw2NjYuMzc1bC0xLjE0LDAuMDAzbDAuNDc1LC0wLjA0M2wwLjY2NSwwLjA0WiIgc3R5bGU9ImZpbGw6I2E3NTU1YjsiLz48cGF0aCBkPSJNMzIyLjUzOCw4NTcuNTMybDI5LjkxNSwtNy45MjJsLTAuMTM0LC04Ni42NTlsLTI5Ljc4MSwwbDAsOTQuNTgxWiIgc3R5bGU9ImZpbGw6I2MyNzE3NzsiLz48cGF0aCBkPSJNNDgxLjM5Niw2ODYuNjM4Yy0wLjg0NCwxLjg2IC0xLjU5NSwzLjg4NCAtMi4yNzIsNi4wNjNjLTYuNTM0LC0zNC4zODkgLTU1LjE5MSwtMTA2LjYyNSAtODIuMjcxLC0xMjAuNjA0YzIwLjYyNCw0LjU3NSAxOS43ODksNC4zNjIgNDIuODc2LDIwLjc3N2MtMTMuMTUxLC0xOS4yNTYgLTIwLjA3OCwtMzEuMDc4IC00Mi44NzYsLTQ5LjIxN2MyNi44NDcsMTMuNjM4IDc2LjE2Myw1NS41NjEgMTEwLjQ3OSwxMjIuNzA5bC0yLjk1MywwLjAwOWwtMC42NjUsLTAuMDRsLTAuNDc1LDAuMDQzbC00Ljk4MywwLjAxNWMtNi44ODcsNC4yNzkgLTExLjk1NCw5LjczOCAtMTUuNjUyLDE3LjYxbC0wLjM5LDAuNzQybC0wLjMxNCwwLjcyNmwtMC4zMDIsMC42MzJsLTAuMjAyLDAuNTM1WiIgc3R5bGU9ImZpbGw6I2Y4OWY4MTsiLz48cGF0aCBkPSJNMzIyLjUzOCw3NjIuOTI2bDAsMzIuMzUybDQuNjksLTI1LjQyN2wxNC43NDgsLTYuOTI1bC0xOS40MzgsMFoiIHN0eWxlPSJmaWxsOiNmODlmODE7Ii8+PHBhdGggZD0iTTQ3Mi4xMzYsNzY0LjAxNWwwLDEuNTE5bDEwOC4zNzgsLTAuNTgzbDguMTQ2LC0yLjAyNWwtMTE2LjUyNCwxLjA4OVoiIHN0eWxlPSJmaWxsOiNmODlmODE7Ii8+PC9nPjwvZz48Zz48cGF0aCBkPSJNMTc0NC43Miw4NTQuODQybDExMi42MywyMjUuMTU4bDEwNS44MDEsOC41NzdsLTEzOS44MTgsLTIzMy43MzVsLTc4LjYxMywtMFoiIHN0eWxlPSJmaWxsOnVybCgjX0xpbmVhcjExKTsiLz48Y2xpcFBhdGggaWQ9Il9jbGlwMTIiPjxwYXRoIGQ9Ik0xNzM2Ljg2LDg3OC45MjZjLTEuNTc3LDAuNTk4IC0yLjgyOCwxLjgzMyAtMy40NDYsMy40MDJjLTAuNjE5LDEuNTY5IC0wLjU0NiwzLjMyNiAwLjE5OSw0LjgzOWMxNi40NTEsMzMuMzg3IDk3LjA1OCwxOTYuOTkgOTcuMDU4LDE5Ni45OWwyMC42MjQsMS4zNTRjLTAsLTAgLTg2Ljc0OSwtMTczLjkyOSAtMTAyLjQzMywtMjA1LjM3NmMtMS4zNzIsLTIuNzUgLTQuNjA0LC00LjAxNCAtNy40NzcsLTIuOTI1Yy0xLjQ0MSwwLjU0NyAtMy4wMjcsMS4xNDggLTQuNTI1LDEuNzE2WiIvPjwvY2xpcFBhdGg+PGcgY2xpcC1wYXRoPSJ1cmwoI19jbGlwMTIpIj48dXNlIHhsaW5rOmhyZWY9IiNfSW1hZ2UxMyIgeD0iMTc0My4yOCIgeT0iODgwLjM2MiIgd2lkdGg9IjExNy4zMDRweCIgaGVpZ2h0PSIyMDMuMTc5cHgiIHRyYW5zZm9ybT0ibWF0cml4KDAuOTk0MDk5LC01LjUxODM2ZS0xNywwLDAuOTk1OTc3LDAsMS4xMzY4N2UtMTMpIi8+PC9nPjxjbGlwUGF0aCBpZD0iX2NsaXAxNCI+PHBhdGggZD0iTTE3NTAuMDUsODYzLjIxN2MtMS41ODYsMC42MDIgLTIuODQyLDEuODQ4IC0zLjQ1NiwzLjQyOGMtMC42MTUsMS41ODEgLTAuNTI5LDMuMzQ5IDAuMjM0LDQuODYzYzE4LjM2MiwzNi40MDUgMTE0Ljk3NiwyMjcuOTYyIDExNC45NzYsMjI3Ljk2MmwyMC42MjMsMS4zNTRjLTAsMCAtMTAzLjE1MywtMjAyLjU0NiAtMTIwLjQxMywtMjM2LjQzNmMtMS4zODYsLTIuNzIyIC00LjU5OSwtMy45NjMgLTcuNDU0LC0yLjg4Yy0xLjQzNCwwLjU0MyAtMy4wMTQsMS4xNDIgLTQuNTEsMS43MDlaIi8+PC9jbGlwUGF0aD48ZyBjbGlwLXBhdGg9InVybCgjX2NsaXAxNCkiPjx1c2UgeGxpbms6aHJlZj0iI19JbWFnZTE1IiB4PSIxNzU1LjkzIiB5PSI4NjEuNTgzIiB3aWR0aD0iMTI5LjI3OXB4IiBoZWlnaHQ9IjIxOC44ODJweCIgdHJhbnNmb3JtPSJtYXRyaXgoMC45OTQ0NTEsLTUuNTIwMzFlLTE3LDAsMC45OTk0NiwwLDUuNjg0MzRlLTE0KSIvPjwvZz48Y2xpcFBhdGggaWQ9Il9jbGlwMTYiPjxwYXRoIGQ9Ik0xODQ1LjkxLDg3MS41NTZjLTEuNTMyLDAuNzA2IC0yLjY5NSwyLjAyNCAtMy4yMDQsMy42MzJjLTAuNTA4LDEuNjA4IC0wLjMxNSwzLjM1NiAwLjUzMyw0LjgxM2MxOC43MTUsMzIuMTczIDExMC40MjEsMTg5LjgyMyAxMTAuNDIxLDE4OS44MjNsMjAuNjY4LC0wLjA3MmMtMCwtMCAtOTguNTQ1LC0xNjcuNTI4IC0xMTYuMzYyLC0xOTcuODE3Yy0xLjU1OCwtMi42NDkgLTQuODY5LC0zLjY4NyAtNy42NjEsLTIuNDAyYy0xLjM5OSwwLjY0NCAtMi45NCwxLjM1MyAtNC4zOTUsMi4wMjNaIi8+PC9jbGlwUGF0aD48ZyBjbGlwLXBhdGg9InVybCgjX2NsaXAxNikiPjx1c2UgeGxpbms6aHJlZj0iI19JbWFnZTE3IiB4PSIxODUyLjY5IiB5PSI4NjkuNjcyIiB3aWR0aD0iNzcuNTY4cHgiIGhlaWdodD0iMTc5Ljg1N3B4IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjk5NDQ2NCwwLDUuNTQ2NzJlLTE3LDAuOTk5MjA4LC0yLjI3Mzc0ZS0xMyw1LjY4NDM0ZS0xNCkiLz48L2c+PGNsaXBQYXRoIGlkPSJfY2xpcDE4Ij48cGF0aCBkPSJNMTg2NCw4NzYuNDMxYy0xLjUzMiwwLjcwNSAtMi42OTUsMi4wMjQgLTMuMjAzLDMuNjMyYy0wLjUwOSwxLjYwOCAtMC4zMTUsMy4zNTUgMC41MzMsNC44MTNjMTguNzE1LDMyLjE3MyAxMTAuNDIxLDE4OS44MjMgMTEwLjQyMSwxODkuODIzbDIwLjY2NywtMC4wNzNjMCwwIC05OC41NDQsLTE2Ny41MjcgLTExNi4zNjEsLTE5Ny44MTdjLTEuNTU5LC0yLjY0OSAtNC44NywtMy42ODcgLTcuNjYxLC0yLjQwMmMtMS40LDAuNjQ1IC0yLjk0LDEuMzU0IC00LjM5NiwyLjAyNFoiLz48L2NsaXBQYXRoPjxnIGNsaXAtcGF0aD0idXJsKCNfY2xpcDE4KSI+PHVzZSB4bGluazpocmVmPSIjX0ltYWdlMTkiIHg9IjE4NzYuNjYiIHk9Ijg3NC41NTEiIHdpZHRoPSI1OS40ODRweCIgaGVpZ2h0PSIxMzkuODg5cHgiIHRyYW5zZm9ybT0ibWF0cml4KDAuOTkxMzk3LDAsNS41NDY3MmUtMTcsMC45OTkyMDgsMCw1LjY4NDM0ZS0xNCkiLz48L2c+PHBhdGggZD0iTTE3MzIuNzIsNjQ0LjMyMmwyMS4yNzIsNC40NTVsMCwxMS4wNDJsLTIxLjQyMSwtNC45NDhsMC4xNDksLTEwLjU0OVoiIHN0eWxlPSJmaWxsOiM1MDI3MmE7Ii8+PHBhdGggZD0iTTE3MzIuNzIsODA2LjMwNGwyMS4yNzIsNC40NTVsMCwxMS4wNDJsLTIxLjQyMSwtNC45NDhsMC4xNDksLTEwLjU0OVoiIHN0eWxlPSJmaWxsOiM1MDI3MmE7Ii8+PHBhdGggZD0iTTE4MzMuODQsNjQwLjMyMmwtMjEuMjcyLDQuNDU1bC0wLDExLjA0MmwyMS40MjEsLTQuOTQ4bC0wLjE0OSwtMTAuNTQ5WiIgc3R5bGU9ImZpbGw6IzUwMjcyYTsiLz48cGF0aCBkPSJNMTgzMy44NCw4MDIuMzA0bC0yMS4yNzIsNC40NTVsLTAsMTEuMDQybDIxLjQyMSwtNC45NDhsLTAuMTQ5LC0xMC41NDlaIiBzdHlsZT0iZmlsbDojNTAyNzJhOyIvPjxwYXRoIGQ9Ik0xODIzLjMzLDU5NC42MDZjMCwtMy4xNzUgLTIuMjQ1LC01LjkwOCAtNS4zNjEsLTYuNTIyYy0yOC44NDgsLTUuNzI3IC01MS4xOTIsLTUuMzc0IC02OC41NzMsLTAuMzdjLTIuNzY5LDAuODYxIC00LjY1NywzLjQyNSAtNC42NTcsNi4zMjZjLTAuMDIyLDM1Ljk1NyAtMC4wMjIsMjYwLjcwMSAtMC4wMjIsMjYwLjcwMWMxMy43NTQsMTQuNzc3IDY2LjE4NiwxNC45NTkgNzguNjEzLC0wbDAsLTI2MC4xMzVaIiBzdHlsZT0iZmlsbDojNzI0NTQ4OyIvPjxwYXRoIGQ9Ik0xODQzLjYyLDYyOC45NDRjMCwtMS43MjYgLTEuMzk5LC0zLjEyNSAtMy4xMjUsLTMuMTI1Yy0yLjg0LC0wIC03LjAwOSwtMCAtOS44NDksLTBjLTEuNzI2LC0wIC0zLjEyNSwxLjM5OSAtMy4xMjUsMy4xMjVjLTAsMjMuMjQ4IC0wLDE2OC45NjggLTAsMTkyLjIxNWMtMCwxLjcyNiAxLjM5OSwzLjEyNiAzLjEyNSwzLjEyNmMyLjg0LC0wIDcuMDA5LC0wIDkuODQ5LC0wYzEuNzI2LC0wIDMuMTI1LC0xLjQgMy4xMjUsLTMuMTI2YzAsLTIzLjI0NyAwLC0xNjguOTY3IDAsLTE5Mi4yMTVaIiBzdHlsZT0iZmlsbDojNTAyNzJhOyIvPjxwYXRoIGQ9Ik0xNzM0LjcyLDYzMi43MjJjLTAsLTEuNzI2IC0xLjM5OSwtMy4xMjYgLTMuMTI2LC0zLjEyNmMtMi44NCwwIC03LjAwOCwwIC05Ljg0OCwwYy0xLjcyNiwwIC0zLjEyNiwxLjQgLTMuMTI2LDMuMTI2YzAsMjMuMjQ3IDAsMTY4Ljk2NyAwLDE5Mi4yMTVjMCwxLjcyNiAxLjQsMy4xMjUgMy4xMjYsMy4xMjVjMi44NCwwIDcuMDA4LDAgOS44NDgsMGMxLjcyNywwIDMuMTI2LC0xLjM5OSAzLjEyNiwtMy4xMjVjLTAsLTIzLjI0OCAtMCwtMTY4Ljk2OCAtMCwtMTkyLjIxNVoiIHN0eWxlPSJmaWxsOiM1MDI3MmE7Ii8+PHBhdGggZD0iTTE3NDAuNjIsNjYxLjk0NGMwLC0xLjcyNiAtMS4zOTksLTMuMTI1IC0zLjEyNSwtMy4xMjVjLTIuODQsLTAgLTcuMDA5LC0wIC05Ljg0OSwtMGMtMS43MjYsLTAgLTMuMTI1LDEuMzk5IC0zLjEyNSwzLjEyNWMtMCwyMy4yNDggLTAsMTY4Ljk2OCAtMCwxOTIuMjE1Yy0wLDEuNzI2IDEuMzk5LDMuMTI2IDMuMTI1LDMuMTI2YzIuODQsLTAgNy4wMDksLTAgOS44NDksLTBjMS43MjYsLTAgMy4xMjUsLTEuNCAzLjEyNSwtMy4xMjZjMCwtMjMuMjQ3IDAsLTE2OC45NjcgMCwtMTkyLjIxNVoiIHN0eWxlPSJmaWxsOiM3MjQ1NDg7Ii8+PHBhdGggZD0iTTE4NTAuNjIsNjYyLjk0NGMwLC0xLjcyNiAtMS4zOTksLTMuMTI1IC0zLjEyNSwtMy4xMjVjLTIuODQsLTAgLTcuMDA5LC0wIC05Ljg0OSwtMGMtMS43MjYsLTAgLTMuMTI1LDEuMzk5IC0zLjEyNSwzLjEyNWMtMCwyMy4yNDggLTAsMTY4Ljk2OCAtMCwxOTIuMjE1Yy0wLDEuNzI2IDEuMzk5LDMuMTI2IDMuMTI1LDMuMTI2YzIuODQsLTAgNy4wMDksLTAgOS44NDksLTBjMS43MjYsLTAgMy4xMjUsLTEuNCAzLjEyNSwtMy4xMjZjMCwtMjMuMjQ3IDAsLTE2OC45NjcgMCwtMTkyLjIxNVoiIHN0eWxlPSJmaWxsOiM3MjQ1NDg7Ii8+PHBhdGggZD0iTTE3OTMuMDMsMzA4LjUwOWMtMC45NzIsMy44MDQgLTQuNDI0LDYuNjIgLTguNTI4LDYuNjJjLTQuMTA1LC0wIC03LjU1NywtMi44MTYgLTguNTI4LC02LjYybC05LjQ3MiwwbDAsOC45MjlsLTI2Ljc5NCwtMTIuMTFsMjYuNzk0LC04LjgwMWwwLDguMTM3bDkuMzU2LDBjMC43NzksLTQuMDYzIDQuMzU1LC03LjEzNyA4LjY0NCwtNy4xMzdjNC4yODgsMCA3Ljg2NCwzLjA3NCA4LjY0Myw3LjEzN2w4Ljg4NywwbDAsLTguMTM3bDI2Ljc5NCw4LjgwMWwtMjYuNzk0LDEyLjExbDAsLTguOTI5bC05LjAwMiwwWiIgc3R5bGU9ImZpbGw6IzcyNDU0ODsiLz48ZWxsaXBzZSBjeD0iMTc4NC4wMyIgY3k9IjU5MS41MjYiIHJ4PSIzOS4zMDciIHJ5PSI5LjY1MSIgc3R5bGU9ImZpbGw6IzUwMjcyYTsiLz48cGF0aCBkPSJNMTgwMS41NSw0NzMuODU5Yy0yNi4zMjEsLTEuOTM5IC0yNC4zOTEsMS4yNDQgLTM1LjA0MSwtMGwwLDExOC4zNTVjNC43NTYsNS4wNSAzMC42OTMsNS44IDM1LjA0MSwwbDAsLTExOC4zNTVaIiBzdHlsZT0iZmlsbDojNzI0NTQ4OyIvPjxwYXRoIGQ9Ik0xODM2Ljg0LDY3MC4zMjJsLTIxLjI3Miw0LjQ1NWwtMCwxMS4wNDJsMjEuNDIxLC00Ljk0OGwtMC4xNDksLTEwLjU0OVoiIHN0eWxlPSJmaWxsOiM3MjQ1NDg7Ii8+PHBhdGggZD0iTTE4MzYuODQsODMyLjMwNGwtMjEuMjcyLDQuNDU1bC0wLDExLjA0MmwyMS40MjEsLTQuOTQ4bC0wLjE0OSwtMTAuNTQ5WiIgc3R5bGU9ImZpbGw6IzcyNDU0ODsiLz48cGF0aCBkPSJNMTczNi43Miw2NzIuMzIybDIxLjI3Miw0LjQ1NWwwLDExLjA0MmwtMjEuNDIxLC00Ljk0OGwwLjE0OSwtMTAuNTQ5WiIgc3R5bGU9ImZpbGw6IzcyNDU0ODsiLz48cGF0aCBkPSJNMTczNi43Miw4MzAuMzA0bDIxLjI3Miw0LjQ1NWwwLDExLjA0MmwtMjEuNDIxLC00Ljk0OGwwLjE0OSwtMTAuNTQ5WiIgc3R5bGU9ImZpbGw6IzcyNDU0ODsiLz48ZWxsaXBzZSBjeD0iMTc4NC4wMyIgY3k9IjQ3My45NTgiIHJ4PSIxNy41MjEiIHJ5PSI0LjE3NyIgc3R5bGU9ImZpbGw6IzUwMjcyYTsiLz48cGF0aCBkPSJNMTc5MC4zNSwzMTcuNjAzbC0xMi42NDMsLTBsMCwxNTUuNzZjMS4xOTksMi44NiAxMS4yNTMsMi44NyAxMi42NDMsLTBsMCwtMTU1Ljc2WiIgc3R5bGU9ImZpbGw6IzcyNDU0ODsiLz48cGF0aCBkPSJNMTc2Ni41MSw0ODguNDgzbDAsMTAzLjczMWMwLjc5NywxLjI2NyAyLjE2LDIuNDI4IDcuNDkxLDIuODQzYy01LjI1OSwtMzUuNjU2IC01LjcwOSwtNzEuNzU1IC03LjQ5MSwtMTA2LjU3NFoiIHN0eWxlPSJmaWxsOiNhNzU1NWI7Ii8+PHBhdGggZD0iTTE3NzcuNywzNjkuNjg0bDAsMTAzLjczMWMwLjc5NywxLjI2NyAyLjgwMSwxLjkzNyA1LjExNSwyLjA5N2MtNS4yNTksLTM1LjY1NiAtMy4zMzMsLTcxLjAwOSAtNS4xMTUsLTEwNS44MjhaIiBzdHlsZT0iZmlsbDojYTc1NTViOyIvPjxwYXRoIGQ9Ik0xNzQ0LjcyLDYyMC43OGwtMCwyMzMuNjYzYzEuNzg3LDIuODQyIDguMzM2LDYuOTA4IDE4LjI0MSw5LjIwM2MtMTEuNzk2LC03OS45NzQgLTE0LjI0NSwtMTY0Ljc2OSAtMTguMjQxLC0yNDIuODY2WiIgc3R5bGU9ImZpbGw6I2E3NTU1YjsiLz48cGF0aCBkPSJNMTgwOC41Myw2NDMuODE0Yy0wLC0xLjkyNyAtMS41NjUsLTMuNDkyIC0zLjQ5MywtMy40OTJsLTYuOTg0LC0wYy0xLjkyOCwtMCAtMy40OTIsMS41NjUgLTMuNDkyLDMuNDkybC0wLDE5Ni42NWMtMCwxLjkyNyAxLjU2NCwzLjQ5MiAzLjQ5MiwzLjQ5Mmw2Ljk4NCwtMGMxLjkyOCwtMCAzLjQ5MywtMS41NjUgMy40OTMsLTMuNDkybC0wLC0xOTYuNjVaIiBzdHlsZT0iZmlsbDojNTAyNzJhOyIvPjxwYXRoIGQ9Ik0xNzgyLjgyLDI5Ny42OTFjOC43MTIsMC4yOTUgOS42ODgsMTUuMjgyIDEuMjA3LDE3LjM5OGMzLjg2NiwwLjQ2MiA5LjA4OCwtMi44OTggOS4yMDgsLTguMzU1YzAuNTksLTUuMTA0IC00LjQzOCwtMTAuMjU3IC0xMC40MTUsLTkuMDQzWiIgc3R5bGU9ImZpbGw6IzUwMjcyYTsiLz48cGF0aCBkPSJNMTc1My4zNiw5MDEuODlsMjIuODE3LC0xOC40MDdsNi45NDEsMTUuMzc4bC0yMS40NDgsMTguNDU0bC04LjMxLC0xNS40MjVaIiBzdHlsZT0iZmlsbDojNGMzMjIyOyIvPjxwYXRoIGQ9Ik0xODM1Ljg1LDg4My40ODNsMTguMDgxLC0wbDYuMTMzLDEzLjI1NWwtMjEuMTgsMGwtMy4wMzQsLTEzLjI1NVoiIHN0eWxlPSJmaWxsOiM0ZDMzMjM7Ii8+PHBhdGggZD0iTTE4OTcuOTcsOTkwLjk5OGwxOC4wODEsLTBsNi4xMzMsMTMuMjU2bC0yMS4xOCwtMGwtMy4wMzQsLTEzLjI1NloiIHN0eWxlPSJmaWxsOiM1NDM5MmE7Ii8+PHBhdGggZD0iTTE4NDYuNzQsOTA2Ljg4OWwzNC4zODcsMGwxMS42NjQsOC42MDZsLTQwLjI4LC0wbC01Ljc3MSwtOC42MDZaIiBzdHlsZT0iZmlsbDojNGYzNDI1OyIvPjxwYXRoIGQ9Ik0xOTA0LjQ5LDEwMDkuOThsMzQuMzg2LDBsMTEuNjY0LDguNjA1bC00MC4yOCwwbC01Ljc3LC04LjYwNVoiIHN0eWxlPSJmaWxsOiM1NTNhMmI7Ii8+PHBhdGggZD0iTTE4MzAuMTEsMTA1Ny41NmwyMy40NzEsLTIzLjA2bDYuNDg0LDE3LjI1bC0yMS42NDUsMjEuMjM1bC04LjMxLC0xNS40MjVaIiBzdHlsZT0iZmlsbDojNTUzYTJiOyIvPjwvZz48L2c+PGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPSJfTGluZWFyMiIgeDE9IjAiIHkxPSIwIiB4Mj0iMSIgeTI9IjAiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDUuMDEzMTNlLTE0LC04MDguNzcsODE4LjcwNSw0Ljk1MjI5ZS0xNCw5NzEuNzk0LDg1NS44MjcpIj48c3RvcCBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNmZjhmNDg7c3RvcC1vcGFjaXR5OjEiLz48c3RvcCBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiM3MzRiMzE7c3RvcC1vcGFjaXR5OjEiLz48L2xpbmVhckdyYWRpZW50PjxpbWFnZSBpZD0iX0ltYWdlMyIgd2lkdGg9IjQyMnB4IiBoZWlnaHQ9IjQyOXB4IiB4bGluazpocmVmPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQWFZQUFBR3RDQVlBQUFCZHR0REFBQUFBQ1hCSVdYTUFBQTdFQUFBT3hBR1ZLdzRiQUFBZ0FFbEVRVlI0bk94OWJhTHNxZ29sV0hkY1BhY2VZcy9yVmVnZkFnS2lNVldwL1hYazNuMHFVV1BVR0pZTDBlRC8rNy8vQjdacytRZUV2cnNBYndwK2R3RzJiUGtxS2Q5ZGdDMWJ2a0IrT3lnQi9JMDZiTm15SlAvdFlkaVdYeWIvc29KK3ArNzdWZC95YTJRenBpMi9TZjVsVUhwWGR0dHQrVFh5MzNjWFlNc1dsbzhxenQ5T0YyNXFuRmsydjcySnR2d2gyY0MwNVNmSXgwSHB0OU9GTDZnRHdRYW5MVDlFTmpCdCtTcTVSYSsrb2psL095Z0J2STRhRit1K0dkV1dIeUVibUxaOGhkd0dTbjhCWkY2VlYrcCtZNXR0UnJYbHkyUUQwNWE3NU9PTTZJNGIvRGJOK202ZFY5Rms4VDZiVVczNUV2a1BkM2ZhOHI1OENTTzYybFgvUXRmTzZ2QUoxbGplejNjenFpMjN5V1pNVzY3S1cvcnJMa2IwTDJ2QUd4bVFTMy9EczhtUy9jdVBhc3VMc29GcHl4VjVHNVQyQ3RHdkVkdFdxMjEreGxaZmZIYWJTVzI1TEJ1WXRvemtKVDMwN3FqN0oyaXdyeTdEcHgwNjdtQ3BJM1RaVEdyTEoyUUQwNVpNWGdhbFZ6M0hQaVh2NW4wM2FHVGx1VkxHVDVibkxPOFJ1bXdtdGVWdTJjQzBSZVNTZm5sMTlQeVRRR2hGTTM2WDVoeVY3Wk5laTY4ODA4Mmt0bnhDOWlhdVd3QmVBS1ZYTk1yZGZlMU1JVjR0ejJyNVZodnJuZnhXQVFpVDR6dFoxU3R6VlFCdmVmbHRKclZsTTZaL1VINGxNeHFWNHd4Y3JwUi9GU0RlcWR0VlpSM3Z0ZUk5OXlsV2RiVXRiMkpTRzZUK1FkbkE5Ty9JUndIcE80Qm9kRXlEWTBuM25acnVGWFBqYWw0elVKSzQ3SnAzWk1iU1Z0cCs0ZjZTWkFQVVB5UWJtUDROdWNWVU4wdi9qbHhsUTVreXROcnIxZko4NTN6U1NNN0t0TUx5WWx1TzZNaGRiT29xSTczQW9qWTQvU095Z2Vudnl0TDcvbDNNS0NxeURJUm1MT2dxQU0yWXhFK1NxMEIwcFY2dm1BRGY5Yks4Nmp4eGtuNmIrUDRSMmNEME4yVVpsTDZLR2MxRzhTTW1kRlVMdlFJKzhVdVpvN1NmY2p1ZkFmQklWc3hoSzIxaDIvdFRqT29xazlvTWFndkEzaXZ2TDhsbGhqUjdzKzgyejQzbWh5SVlqWmhRcHJCV3l5amdzekpaTVdOaXI3S3JWMW5OcUx5dnNxYXNEU1A3bkRHbkVzNnZ5aXJJWGJqUGRqZi9vN0laMDkrUVd4blNIWE0wcTBDVXhWOWxMUm00WlJJQmFqWC8xZmlyc2dJNFdYdU42bnNWdU04QU9ydUhoTjNCcEc1bVVQYnlEVTYvWERZdy9WNTVpU0d0cExzaUk0V1ZnVkttWEtQaVdkRXFvOUY5Qmp3ajluVW1kODIzbk4xdjFWeVp0ZUdJQ2M0QWErVWVaL2UvQzZSV3pYd3ZQSXNOVHI5Y05qRDlUdmxXaG5RVmpLeTU2Q29RMmZReC8xbmNXWmxuYWJQd096VGRsZXRIQ245V04wbVRBUllsNmM3S05HdWJGU1lWN3pXVEdVaTk2TTIzd2VrWHkzLzcyZjBhK1ZhRzlDNHp5cTRkM1NjcXZka2NVY3hyeGR4MzVab1VFSzRpekNUdkVSdkkybmVVWmdSYXR2d2xTVWZRSy9oWi96a0R4YXlQak15TU0zbUZTUTNTYlMrK1h5cWJNZjBPdVlVaHZmSm16cFNOalQ5alJsZVVmNlpFWjhkbithWFhZQjVPNGVnVlJrRXJpVGhpK2t4TVJpc0RneGczbXVlTFlEVmlWRFAyazIwNXRNcWtyb0xVVFhOUm0wSDlJdG5BOUhQbHh6R2txQXhmWVVhWjBzeUFhS1JRc3pLa2dJVlpQU2cxQjBvKzd2NG5EVFpUaEd2N3hKSDg3KzdyV0F4S0dPYjFwWFhBa3ZnWVowSEpIcCt4S1RnSnZ4T2tyakNvQlhES3N0M3l3MlJ2NHZvejVTV0d0R3FpbXVVWEN6RURwR0xDVitkQVJtQjB4b2FHU3JFRG9ESDRaSm5ZdUw0dHg0L2hyRzNQSHlBQ29Ta2Y1ZGNSQUNCNUhxZG5XUCtKakVjU3pBREIzaXVyaTJWVDJUWDJ1dEdBSVhQN2ptWE5Camt6T1FPZkM1dkhiZ2IxZzJVenBwOGp0ekNrdThCSTRrYk15U3FJbFhtYk9DSUhHSnZzc25PQUNrTHRlbDk3VllMaFFqUmg5VnB5Y1dUU0YzZGRhTjJMRGRzbHA2eWxUUnR5ZEtGZStST2pMMUttbUZzKzVCcXp0VklFdmxGVnJqS25qTzJKMkdjN3V1ZXJBRFY3Qnk0eXNzMmdmcWhzWVBvWjhoSkR5dUpYNVFvN0dwbUhWczZ6ZVlqWmI1YVpCYUppeTRiaGVxU3V2S0x3RzZCU2wzZGtWQkhBK3JKY0V3ZEJiS09MN2ExUnRualVuZ0xadXBDOXBqSW1wQlp2eTM4SWU3SUlMWFdaZEthTTJVVGdzam5PQUc4RVpGWmllN3pEb0RwZ1g4dHFNNmdmSlAvdFIvSHRNbjF2VmtkL3E0OXhCa2dyN0dnVmpLNnlvaEViMHZ1akxXTlYxTVdBampJTzhPQ2oxMWphd09kYU5rMmJzNlRUWitDUW9uOFN2Y0sxdEFoZCswaFdKTFhrL1BSNld3Q3FyWDN3cWJDdEdvcUExTnBJTHZhbVFOL2E2SzRmOXdkSlAvTDBnMEhZaUVYTkdQZG1VUCttYk1iMHZYSUtTcDlnU0NOekhTVmgyZlZaK3N5TU0yVkZqb1dRQmtXVG5LaE9EQVdJQUZRNDNMSUZkRGNtQmFoYVh0SjhOSWtGcjBIam9zMDNGZXBPaDlxT1FzdTV0TWdnUmZ4L3ZiSndnc09rZjhneFNoVVlzTENCRlFFQUlpcjQxUHRSeXd0OHhjN1lsRDBlZ1JrTXdtd2VJK0FZTXNvVDJRenFiOGdHcHErWEx6WGJ6WlJDVkE1WDJaRWRBY2RKNXhrWTJYRjZCa1JrZ1VpQng3TWdDeUlveDlnQXFrWlF6NWdrRDZ3QVJucHN5Mm5nQWZQbmdEUE56VUtCN2VnOUZCeFF6K1duQUFBUXdtRlJ5Z0FZTVVnVkFoTldDeW5QUUZqVmc0OEZyQWlvZ3BmY2o0RktuNEZsVk54b1oyd3FEa0JzR2dqcHJweGJ5ZGphVEc1bVVCdWN2a0cyVjk3WHlpVlFHajJibFdjMllrZzJMaHVWV2dXUUtad3Nmd3hwWFJxampkMjlIQmhRTzBkaFR0UVlRTWQ0T0wwQklBQVBVR2pDNVJ6WmUwQlpsUUdwakNtNVBFeGNCclpPS0RuVUEvUnhqQUxLWk9SY2p2bmM0SkFDWGdVZEJLTEdxb1Jsa1psd0lrMExqVmt4VUZsV0JZWlJJUUFRQXhVQWc1alVJSURVQ0l5aXJBQ1doRVV6WWV5cmk2em5GTXdXdlBnMk9IMkRiTWIwZFRMdC8yZWp1RHNZa2h5UEFNbEszRzBoTHNhMDEzVEFsSUFSQXBoNUluS09DdzVzOUhwcWMwZ1dlQUlJMlRCQWdNTEhoUFk2QTFEbWVvcHhBWnpJaHVrOVEzc05nQ2w5MklTdURaRk03dVFaRmdrZ1VVdUw1TU1WaktTd1JPenNnTlhGM0lBVkVkODVBTldEZ2Fvd1MydWdnSDZRd2pTTXRGMjRyQUczWjR6SHBoc0JGQXpTeG55dkFOUU1uR0tmbmlUTGlyZmxRN0tCNld2a0ZKUm1DVmJlaEFoc0dlaGtvMU1iWnhWUmxxOGNseEJtbWM2WUdaRXptU0dEaEdVbHVpYUp3d241R3N1RUROZ2dHdkNRT0hkdTgyYTJ4UEgyWHFTVml5WkVjdlZJRzJVZ0JwdE5HQ29nVkdKajJKTVV3Z0NSb1NzTlRBU2dGSnhRcnlkQytFL2lEc21QTkU3b0VnMkFxa2g1amRsUHNScFJUWVRLeXNBektWYzN5STlYK3VXb245cCtlWlZCM1FCT01mbVdEOG8yNVgxT2x2cjUyWWh3TlkvUnVjMGZvYitmSEplVGRPbDlqUGExU3NLRkN3QkFCWm9DamMwZ0g1Y0FIb0JtVHNtQ1RSRlFvWGFkZ0ZieGFSd3dCVUJUdDJ2TG5qQ0NVRE1keHZxU3FWOHU1aUpxWjZyWXdacm0wTVVKY09pTkRKT1N1U1FFQURva0Q1TW1wRVUrRndEVFg4MkxOQjZKR3RnQmFYNFYyeXBRYVQwWXBBb0l3RlVIQ3BUMVZseTNySi9KY1dhcU80dXo1MW1mWHdFbmtTenR4ZTlBYmRYNVFkbU02VE55Q1pTeThOWHI3UTB4aE51WFcrNFYzNmpNZ1FIRGRlNStybkRVdk5wVWovV3N3NXJreE9rQUF3QkpuQVdTZGk3TWlXdFFHaWhab09yekFMMFdESWdWQjNnQTFoUm9rY1RGZ1FYYzJBNERjUS9YQUE2WU9TVEpqRHhycXRjM2t4MElDeEp6b0FBSFlRTWZRSUREZzFRREo1NS95b0JLMG9JRktsQndVZFprbVplMkQ4b2pBZXM4SVNCRjVKdHFwTkZ0bHhreHJwZytZMUFRd2tlU3ZYc1pBRTVrZzlNSFpRUFQvVEx0ejJlanRxdWdGRTBhSTRZRWsrUFJYblV1TEdOSG90Z0RNNExBakJxQVFBT0tlSTRWWUxDME1GUlFzbURGSUZROGNKV1lsMnJMbWhZQUhJQkpZWEVBU25wczZoVTlCUmY0a2t1a0RFZFB3bkVBSjNGdXlKZ1BHakJ5YklrQTRFQ1hIdlQ2Qm1iSGtRTlZUU01PRlFnSHN5a0ZWaGtiWUFPcEd0dllVcTJuYlZjUHhKbEdqMjA1WWswamdNckdETzh3S01sekFaeXk3TGE4S1J1WTdwVlRVSm9sV09uWlo0QUVKbnlWSWRsODNRdU85dHl6SXkyRnNnNkFCNUF6MHlGNmR1SUJwSUdOT3kvWnNRR2g0dk53WUlNUjdCb29TUmtLK3ZPT0pYVmVlSlpCSVRnR1pkcHErbkNEMjNnRXBNYUtLdURZT010OElBRWJCQXNzcUl6SmhpRkJOZjBKNkJ4OEh3R2p3ek1xQVMwaWhJZGhiUWNCRkd2eVkyWWxMdWdITmpEVkpxRUtYY1FkeHdLVWJiYllyMFhPQUNxTGkvbTh3NkFXd0NtNzVaWTNaUVBUKy9JbERFblNYZ1drRllZVVI1dk5ZKzZFSFZubUE0M2xSQ2Jrd1lqRFN3TVdNRUJVR0h4c0dtQW1WVUhJaDlYOEcvQ2hQUmJHWk1MMDE1Uy9OYVpuVDkxQ1d0TllLOCtOdWdOUjJOallnMUhrMW9TbkRFaUtaWmlTTSsxQjBmaG14dlBBNUlEbzREZ0Jxc09ERTFCZEkzVWNxTmNEeDZPV0FaaEoxVElUMTZPNm5kZWUxcXBzWGVISnpVVkpuVE5RSXBpYm1UT0F5b0FMUXZoTVp1Qmt6eWV5d2VrbTJjRDBubnljSWRsMHR0ZVBHTkdyREFuTkNScEF5dG1SekJzMXo3akNwak1CalI2TVdudzEyUW00R09aVVNGbVNtT3JJcGk4QmhNeTE0c0huNTZUa0hCb1lLWU5xZFFKbzhiYU8vZ0dRVjZnTDRsSlRERFdnQTZDc3lwcnlGSERBc3liSG91RFFNQUdlWnRhekRJcEJ5TVpiY0RvQURnTmVENVBYUVFoNFpDQlY2WktBRk5sZkZHQnRwajRCRzVtTHFnM1FIRUZHckdrMENNdlN4cmlZNWd5Z1J1QTBpMCtTYjNCNlV6WXd2UzRmQjZYNDhzVVhORHQvaFNHMWdHaXVHN0FqWlJ6MXZGZ3dLT2RnVkFvQk9RQXlJQ1hwVFZyTHFCU0VTZ3RMNTVhTU9jOHhKQUdxQkpUaWdsM2ZTTmVCcVJNQkhmc0VMR0JSdTNWYklDdmhCcmdzU0lGblNPallFQmlXeE9BbDgwL0NpSmd4NFZIQng2Vm5JTlA1ckFNZFNCR0RYZ1V4YXQ1N0hBY0l6YlU5cUhma3VtaTR1ano2cHBreEpIc2VqKzM3TUdKVkk1a3hwTVU4TmppOUtmKzkrNjc5bzdJRVNyT21YWTNUVVdiSU4xN3Y5bndMYWJJd0NXQjE1OWdST3FWZHo1c3pnZ0VhdzRxNmVhSFNnMUdiSTZxL0FrYnlSeWFkQlNtdzZZTXBzSm5vZ3ZlZE1lVTFod3NUbjlUUmE3bitFYVB1aUhxbTJrSWpoMHZVWFZ5RVFocHFpbHNBU3hoUkRXOE1TZjdpSEpRRkV3dFlFWGlFQVZuMmROaDA0UmdGMUlSaHFhTUZBaHpOemZ6ZzBSQ1JnQ24zTWdJNHhER0M3SndUYjBackFPb01VTEtCV0RaWWl3TzN1SGo4RmRrN1JueFdObU82TGg5bFNxTVI0UWpzUmlQR1dKWVNJaUlneWJuRVVURFhaWjV5amlHWk9TTTF1d1h3cVFCenFKa095OUZBQ0Fud1FWQ1k3ZGo1SlFkQ2dTRXBtekxIdFk3SkhCT0grNGFsZHRxMFpJL3FBQTNvcmtwa1JjSVlYUHdNbkVDWkU0RGZBUUlCZFo1STR1VGN6aXRaVTU4RExjT2doQWs5QkpCTUhDVmhlRmlRQTZEU3pndWIrbERtc1BqeDFDMlErUDQ2K2NSbXZnQlFmTnIxNi9nZVpBQmxXclJqVDNGd2QvYStadkdiT1gxV05qQmRrNWRCYWFWM1ppOU45cUpsNFJUaVJNNEFxUVkzUUxMelF3QURkdVJZVUFVWVRFQ29NRUExTUNJM2p5VEhrVDFaeHRUWVVBTW1CMElXbUtDZEExQmxPTTVNTjJGRjBoWUpVOUk0UUgvTnFnZ2pDbVlybnhYNmgyaEJ5SnhyRnVLSUFJMFJDU01CTmJkQmkyTjJvOWNGbGlSbVBNZVVMUEE4R1pDZU9WaXBpWS9USDN3dlFLcHhERlRscUdIS3JBQ3JhVmJLRDIwZUtnSlVlQndwUU1WNEdLU3gxNjhNSmpjNGZhMXNZRnFYdFAvRmpuNldaaGFmbVNLeTY1UEJmQmZtcmxsZ1NBNlFzSUpWTk05RkV4MWFNQ21rQU9VQXFCem0yTEFmQTJiZ3JvRUdUSkVONmR5UkJ5VVh4blVCQ0F6SGdwZHJvR1JJYnZMd1lTSGg3TUhTOEtUTlZUa21GZTVIYlY0R0thUXhJQ1hBSk9tc21hK2RJNkR4MkVNQ05kR2hBYWNLV0tYTlFWbUFlakRvUExDWit3NEVPZ3F6SjlCak9yQU9DZzRFS2dnbzgwOUg3V3pXV2FJUUtFQXBDaE95UXcwNGdKSzZyekFpQ01lUXBKbWxqYkxCNld0bEE5T2FERUhwYlB5OEFrcDI1Q2JuV1U4ZWpmeUc5emxqU013aVVrQlNNQUtlRnpvY0dHbjhRMERxQUhpUUFhYWpBNjJPR1ZtZ01zRGs1NVhNK1FsRDB2cktndHFDR3Q3YUpJS0VQWk04czhic2NXa3FrN1F1SDZZRHJWU29ZZWpTR0VhbFRnWWVtRVNwdS9RclFLWHpSd0NnNWpkbVNiTEd5VEFsZURJRGVqYW5CM2dpSEFjMWxoWFpFNE1VSGRYTUI0Y3dxUjZnbEVFUnRtZEs4b2tTYitLTVFHT2JQd09kMFlEUFhqOGJZRzV3K2hyWndIUXVId0dsR1V2S1FPZHNGT2p5UlFsZllFZ0tVc1lFMTVucktNd1pIWDRlaWMvRmRJZVB4cElBRHdOT1pNRHBxQVVwaDdLa0RwZ2lHN0x6UTBoYWo4aVU5QmpSdTd2SGg1S0JVaGMrU24rVG9Qc1pxcS82WVVNR0dhazdBU0FXMWRMTnRBZERGdFVCbFRwSHNDY2RrWnIyNk5GQUN4NE5iTUN3SnpvT2dHZUJvN1M1S1dJbUpjeXFCSkFpQnFseWdEcE15RHpVaUVFQnlqb3BlWTZ0ZnI2ZDhrZWNBVkxHbmpDa3pSN1hESnpzK1VLeUxRUFptN2pPWlFoSzlqZEx0QUpLTVMrQzNBTlB6ck0wQUdieG9XVkVIQzU3MDZrQ0ZCWmttRkp6eWM0ZEZrbzVJSnJyOVBoaEdkQmhUSEkxenJFaU1lc3BHMnFNVE9lU0NqVEhodExZVVB5OGhUMzJYb1NHZTBpakFjQVpHK3FZVkpia3JwY2x5MGRZankySDBhUTZzQ0QwOGNoKzJkcFUzR3NVclBnVEdIeVBOdC9FNThYTVJSM2N3NFFsQlU4OEJhbG5tSU42SEZDT1VzMTd3cktPQm5BZ2NkWmg0a0NndXRZQURtUHFjenRLVUswOFlmMmNoMTJJYkhlVHNMdWFSM0RvQm0yK1dmVjltakd1S0tPNHhlczNPQzNJWmt4am1ZTFNLTkVxSU5rd2VZRXlwbVRUQUFSbkJwTkdQWmtkUy9LQUpML0NRR2FBSk9ZNUJTRm1RVVZOZEF3eUR3OVdFQndod0lDWU5lVTFzMXlZVDVKNUpBQU5BM004QWlFSFFCRzVUZHFwUmpoVEZ6ZXBreHpncUQ5eldqWUFGM2NZdENkeURWRlYrc1RQWFRMajNjUlJWc0FLMEJHd3V4d0FRSEdtUHJRZ0pTWTh3NlJxZUFFNFNGa1dIUWowcExwUTl5Z0tVdkJFTnk4bGZ3VXJVQjVvNXFJc09CRkFZWUJxM29qU1NGelgwRFRhMXFaMUlpRE5qck56T0ltN0FHNGJuRTVrQTFNdWwwSHBGWjJXc2FLc2MyZlhhN2hoU2NLYUNwZk9zZ3haQkFzSThEQ01wUWVrQml4RlRYSU1SZzkyNzM0WWNIS01LUUVnYTg1amRtUVpVelRYMmJWSFF5Q3lJRFJvR0FUeVVTdXFJRG9nekdSRnJWeklMbWJZWjAvK3lIVWFoT2ErQjYzZHpOd1Q4WGtONTBRa2pBcnF5SWJNRFpqaFFHa212OHF1QWlnZENQZzQxSFNId3BnZXpMd09xb0IySUZBcGZBM3gvRlJqVW1MeVU0QVNRR1J3cWc0VHlJTTRVdk1lZ096ZkJ3NmdSdTlWQktISXNLNkNVM3c2RzV6dWtRMU12WHdNbE01QUtPWjFCa3BtMk9qbWtheHJ0TjNDcDJBREJkMlRiZ0JJYU5pUFpVdlF4YlY4T2srNzZIVm4vcnJ0Z2hSMHNEazJsQk1nTWlBMGJVQ1Y1TkZlVVExWDFjZ28vUmxqeW5xZ29WbGRGZEYrN0ZEeU1HQWxmY05vVDkzOEc0VTFNWnVDbzltRkJheDBNYTc4UWc5T0IrbThFekpqVW1CNnNLUEVnd0hwV1VHS0RsSWdBMlB5S3dkS2tTcmJJb1FIQVJ5SGxCbEJQaWN2QUlVTXZ1ckJSMk5RbUwxN0VaeHN1dGs0WTNSTmpBdXl3V2tnRzVpOGZKUXByVEFqR3ovS3kzMzdDS0F6MjRuaTk0dGhFMEN5amd5UEE0b0RtS09aNlI0Y1poaVU1cUhBZEp3QUVnUndncDRWYVJyVDBxRmhNQ3J3OU9HRTFwczlwRXVzNWp1RjNJK0tzSVF1YVFBckFTcTlyREVxK1pvdEVnRkNZZUFpc045OEVwQnFlK1poWTFVSFZrcmpXQlF4RTJMd0tReFNoYzE5VHpJQVZabldjVUFGcFdlOTMvTkEwQy9uSHJWR1VxWTZzMWJ0QkR3MEUwSmUwL0g2Sjh1ZXNvSGg2SGowanE1Mmx3MU83OGtHcHBPK2RoY295VGxCNjRremdFcm5rb3pDRmtDS1pqdDFiRkNYNlRaWHBPQmtXSkxPR3hud1VRWmxUWGtTeithN1p1S0R4cFRjSEZJRG43aDFVQVNqQmtCa0o4dDZJRHBqR2pQNitWZWtxeU90Z1pVcWNJNHdRSVcyVTRyS0oyREtnaDZraWdHbEFtM1I3aEZOZkJXWXlyTStVMkZJRlpTS1lVOENVQWo0cEdyYUs1VTVQWjdWUVlLby91cGNGSGMxV1E5VlpNMlhjUzhuYXM0Um1jVTNNcVA0TG82VXdneWNZdHdHcDlmbFg5OHI3eklvNFNCdWRHMEVvZWgxVjVKclV2M0tpbHVCeXlqM3RpNnA3YjV0MXlJVnMvV1B1bmNicHdXMGdQUTRPbllrb0JUWmtycDZUMWlTTTkyTndNaGlrWVNsalh5QkNmMUxrclVUaFFUb2lhaWEvelJlZUFjNHJTMnNRMFpVQ2xKbTdna01neExUSEI0RVFLWE5OVDBQZFhvQXk1WWVCTWNUQVk0QzlDUkE2MGhSdkpPRTdGYWhRTWhNNm1CV1IwQ2dYK1BsS2gzTW5yVGUwTjY3RVRqRmZmREkvR0s0WnZRb1JnUFlEVTVyOGk4enBvOHdwUXhVTW1aazA0N3lFMEJDVTRJQ0FNMXJEZFQ5RzZFeGxtSUF3czRmZVNBYUFKSTZORFFUbjdJa05NNE5rdi9Ec0NEajVhZUxZMC9BeUFGUjJoaG5qR2xMS3E2dEFsQjFqQ29IS2VCSHlSU0U1NkNBUWFyT0thbEo4RURRaVU2ZGl5TDJ4aXNWeUdRZUNxazZVandPb0djQlpEWjFGS3dESjc2R2tKb0gzeE9ocmlXQTlxV1BnNG5iQWVxOUI0QmdqWHNQQ093SkdzbTA3MlhHbkVaaForQUVJWDR6cCt2eUx3UFRVTjRGcGNpc1ltZU9uVFNtMDNCUjdORFdKSWxTRndjQi84bUpROWxLTk5kaE9aeVhYVEhBWk1HbkF5VHIxR0RCU2VlVElHZEhPbGQwQWtheFFheG5ITUs4d2Jlc1Myemp3S2hhdnh1QUZFRHpNT2VIVnI5dHhRRFVQc3lsM254QXdNekhPamtVd0ZJWkV4eEZseUlvUUJXQzQxbWdJRlhHOUt6Z2RLQXN5TVcyYng4S0lGYkhDS1Q2KzREbXZVZkdPYUtHQ0hqbVRiUUtXTytDMDBRMk9NRUdwazd1QXFYc2ZBWks3dGV3Sk0zTHVFckhqVldkdDUwejIxbXdFWGJFYkNreDNRMEJLWGpidVhta0IwekFxSlY3em94c2VHamxLYS9kOHJJTUJ3Tm9vZ0pJeWFCSTJJbmdHd2xvTWF0Q1pqMmNuM3I0aWZmZUV3RktxY2VGZDRuUWdRN1dQdlpBT0o2a1RoTm9RSXFRNTdFazc2TytKVVJZelhBRWJSY01CeTBBYUw2aVMrRFprNmxsZHg3ajNnVW5xeDhTK2VmQjZiOS90UDVwZjdnVGxPeHhCa0JaQVNKTEFrRGpjWWVHSlVFRHFHaXlRNy9PQ0FQb0ZEbC9SRys3bHNZNk0vUUxZLzBmaWpGZmdBbk1yOWFabXZFK3R1NC8yZjErbUV3R0NXMDhNWm1Ua2xqa3VhV0M3SWR3S0NBcGk1SzFVUWZWaGJsOGpiQWpLSVU5Rytvdllha2ZKRVFBS2dqSEUrQ0J2RWozeVFYQWVqL2dYYTRPSXYyMEJsS2Rjem9BNnR3WWl1ZGVMWDN3cXUrWUVvVHp1NW5UNU5wL0dweitSY2IwWmFDVVhUdGtTZm9QZ3c4QTJMa2tuVHZxV05LaGU5UVZBU0pkL05xQVNJNGhzQ2E3TGtsM2VNQUVrSXpYSFlCaFNHTEtnL1k3ZEdDSVpyclkwRnUrWDY0d0tkUFpsVVU5bUsydzZ6a2RQSGdwV0hkK1FQdkhjMDFIQVhqeWNTRW9Ed1Q2SDBFcE1zOVUrOTR6bXZpd3NHTUZRRUhQb09vYUtMRTVFSWhydVZTeWRsL2luWm5RcmQzZTRQVDk4cThCMDVlQzBpaDlCMTdZbUFVUEFFSE5KbVpPeVgyQ1BIVnNhT1k1YjdwcmYycTJpMnVUSWlCWjd6cTVuMk5HZ1NYWmNuY050OW5ScjVRVXBGRCtyMFJZSFNVYTliQWI1NkoreWJhQ1EwMkhua2tkREVyUGF0TERnd0ZKVEhsUEFDb0VqMExNbXBoSllXVlc4Z3RQckhOUnlNNFVERkxpNms1c1hqek0zRk9oZWk2Rmp2dnViWEQ2SHZtWE5uRmRCcVVSMnhsZFo0K2orN2Z0dERhc21FUzZVQlk4S0NrckFtaGVjSTRsMmQvZ1lmZDRWZ2VJeHdGUW5nMk1Iayt6TVBZd2dHUllVNXhQU2dHcGxoTng4RXJwMWdLaGNiZjhjaUh6SEEyTHd1WUxwNFl5QmlveHFRRXlRSW1qQk1hL05wY0VQTmVFendKVXFobVBTbVZMV0FnT1BnWUdLWHd5ODNraVBQbEZLcnlKQlhIWEp0Nkl2WUM0bGxkd2VoREFrOTlVeEFaT3ZqYnR2YVZ3L0NvNHlma296amY2dndWTy93cGorZ2hUc3VmWkNHaVVqK3AxWVVRU0ptN1hoaVhwemcxRDkrL0dqSnpaenE1SE1zeEp0eEw2ajV4elE3K0hYYkl3RnVSNHM2Ti9XdFJVa0xBb01BQVZHQlN4U1EyS0FhaUVQVld6WHdGRXFxN2xNZ2RWU01HcHpqOFJBQmFlZjZwelZnY2lQQTZBUXhibllxa2Vld0R3bERWWVI0WFV3NVQxQVhWdWlnRGFiaE9tdWhHQUFEeDdBbmdObkRaenl1VmZBS1p2QTZWNHJyL0cxTkhPN1NMVStrbUt0bzBRNzlDQVpMWU9Tc3gxeG13SGp4WUc4WmRkditWN1NmRHdvTlF0a0FWb2dDVGxkbS9vWmtmL3RKQlgwZHBIQUJ5dFFOMlRyKzBrVVQ4SzJMT25Da3JpQ0VFQWhrWFY5NlB3ZWloU0YzTUZxcWY4SXZ0YVZKQ3EzNHVxVmovNTl0TmhkbzBvekpiRWtZTkFzWFVLVHZGOGc5UDc4dGVCNlRaUUdqR2YyQkd2Z0ZKY213UklVTUFEUk56VFRzQkhIQm5LRkl5ZVE4ODcvNW56Qllaa1d5b0E2Ny94cW13Wml1MFBpbEhZMWoyWmVVaEEwTzgrS1lPQ3luaFFxRGdEQ1NJd2k0SUtRUC9qdVNjVTVvVEtvcUFRSEZpZEl3NHNVSjVRNTV2WXhNZHZsaTdJUFFnQURzRk5iOXFUTlUvYThVMDMzK0QwTmZLWGdlbkhnWkxPeThoMVJ2a3JROUkxU3Mxc1YrSWkyWkZ6UXprQS8zdDZJTkx0aEJwYjBqa21CMG93QmlScmRKZHpXN0hOanJaRU1TeEt4bDRVQmpLSXdxQ2d6VUVkOGg0d1FtRGh0YnQ4L3F6blI2RzZGcXJVejJUSVF2TnE1cXRBQjgrNlUwUTE2OVhmQ29xbGdoTXZuNkpEU2xuTHAzQkpESjNvdTd3RkoxT2REVTQzeWw4RnBsdk5kNUxXQXMwcm9GVGlmSkw4TWpDMC9lME96NVFFZE5pWm9Ud1lmUDRUWUhvcVkvS2c1RDN1M0VKWmhIcCt4cEJjeFRaRDJySW8rbkpJbnpFQUpmMHZHZDlncVdhMWxnZnZ4eWo3NURGYktvWTlGYXp6VDhCeHlLeXBPdVhWK0lOZHl2Rlo0TUNEZDVLb2JBeEtCYWRhSm1aenV0K2VXWkNiZ0JPQUI2Z05UdmZJWDl6RWRSbVVPdkFZWEVjQTA4MVhzNDFZOVRpWXdSN1dkQWV5SGdrQURCaTVPU1RaQWZ6eDFQM3R5dVBwekhiNDMxUE5kMjBlS1RnMjJIVkpTSUM4WTROYndNRnN6akVrYW1YZkRHbkx5ekppVU9hRlVkTWZFNmE2ZlRpdk1VTCtCQWEvVUlqVjJjRTZSR0FCb1A4UkhHYnVTYlk1UXAySEFzQURtN2ZmQWJyM0hoQldCd2lTN3ozeEhCVy9BL0pWNE1pWU1vbUQxaXZnSk9lak9OdXFNRmRmdjFiK0dtTzZsU2xGNE1yWVVZeHo0UWFVRUhqSEJoQkdJcCttOEI1M0ZhRHM3dDhDUUU4bzR1NnRjMHJQNW0xbjF5bkZMWVdFTGRsMVNWSmlBU1FIbUtHbC9tVFgzL0tsb29PYUFZTXlieEJLV0ttZmVBYzhBRUhtblpqbFBObTBkN1Jab3JvZWlSZmhvbmp0RVJ4UWRQQW9KcjNDdndBSUR5andCQUFpZ25MVVhTTHFHMXAza0RqMFZhbmdKRVR3ekt3SDROTnM1clF1ZndtWVBnSks5dndNbEJ5UU1mZ0FRSEJ5TUdZN05PWTY1d3B1bkJzWWJJb0RwR3EraSs3Z3pueUg3YnRKM3ROT3dLbVd4N0s1ZHJnWjBwWVBTMlJRT2dOVktZb1FlU3J0ZlFJeHR5RWY4TXAwQkFRcUFLWFVSYmtIRnQyUnBMQ3B1ckdtQ2w3SGs5Y3pZUUdDQXg2QThHUVRZam5BZ3hNQUhJQU5uTUN2ZDVxWjljREVRWkl1eWdhbktuOWxnZTJ0NWp1Smp5T2RrY2tPd0p2NnJGa01vWUpRRFNkOVdkb3U0RWY3RlpOZElmYW9zN3MyUElQanc3Tm5TZGwyUXJnRVd1NEFBQ0FBU1VSQlZCR1ErRVZWRTY3MW1Ob01hY3RYaVdOUUFqQU5udVRNS2ViQ245cG9tMFdDT0VnQUF3NWduY3NsckpCUzNjV0xmakpLY3E2V3U3cjNIZ0hDZ2FXdWYrSjdGUUxkMHFndXltMm1QRERnQkFhY3Npckc4QlVFMldhOXY4R1libVZLRWg5Qktlc2NtYWx2QlpUQXNhUjhzYXc0TkZUbXhNNE4vMWwzOERhdnBONTI2dVRBSmtGczkyMU9EVElValcrVU1lTnRoclRsSzJYb3dWZUJSN3NsUW90blhQSU1paGtOMWcxZXhWdXZnbFExOWRWekFFRCt2QVpBTmZYaG9TYS9BMENkSWhTcG9GS2t0cThlT2RqTXpIb3dPZDltdmJuOGRtRDZGbEFhL2xwUUVoQ1FzT2dHamdhTWtvV3l6WFRYbUZGeGMwbFBYWk9rakVtOStnWm1PelVuY2dGdDYveUo3cnpsVjRwcVdzT2VkTzZwSmFnc1IwSVlKRXAxaUVDaFhJZ0F6NXBYd2JaMkNiRE84ZEtUYjhYc3F1RVBtdC9pd0ltTzVreU8rdTJwZW8vR29qWTQzU20vR1ppK0RaVGkrUXlVRUFJWVdaYUViYkdzWlVMRjdtK242NUtlZFllRzZCSnVObDExTElrZEsrcEwzZ0N5TmNxZVI5cnlRMlRROTVBRVJOcWJpR2krVDF1b3JrRlNHL3RSUWFwZVZJTWViSWFULzVBWDJacjdWUHdwSUp5Sk9FVEFxWlQ2QWNJaTlnYURLbnFyUlhBYS9ZN2tYd1duM3dwTXZ3YVUzR2ZPMlNWYzU1T0tOOXVoOGJLellicG1LY3dueVlhdTNWeFNNV1k3eTVKc3kvekJkUUpiZm9DOE5NQzUwQmZGWE1jbldMY0hyNmE5SWtWby9LY21LOVhjeHk5cjNJZ1ZvSUVUQWRYdCtoaDE1SHVIQmNYM2d0MGZkSGZ5WnRMei9LNGY4MjF3V3BmZkNFdy9CNVEwSWdFbGJOc0w5YUJVelhMV0ZUeUNrWnRMY3V6bzBLL1NPZ2NIY1F2WFY5WjJaZmtKdzdvdFcwU3M5aHpLVlQxM0lUMU5UZ203eU1xbXpKdktBSVVJMWZ3V3dVa1dMVDFhWG54Sk5TNDhlSnNpTXV5SmVFazhmNzY5UU4zb1ZjSEpRSS9NUFVVUWlzQ3p3V2xOZmhzdy9SeFFNbmZ6b0VTOFlYSUREVEhkRlR4Zzd1RFFBNVExMjNsQUN1dVN4T01POXBxa0xVR21nNUJSRDcrYXp4Mlg5QURVQlZPU0RpdURJWG1Kb2U1Y1R1SjlxaTUyMVJoM2lETTRDZGdBRkVLQUIvR080d2NnbGJxdWlhb1RoZUlmYis0YVRYb3pFeDZFOEExTzUvS2JkbjVZQnFVZVBIS1JoN204aTBNTWsyMkYrRmcvVzRHeWQ1ZmR6YUV4SlNoMUhxbXhKUTlJTXI4VWR3V3YrOXVaVDFUb3pnMkJKV1VlZDdiQ1czNi9uREtjRjEvc29GWHo3ckthOXpDRDlUTEVOODkwY2MyZjVMY21RTjR4M082eFZ6OVlTQURNaEE0aUtBOHl2MGRiOHNIeEFHS21xOXlNc1EwT0FuZ2NLRE5hQUdBK05takdnOEZtMFFHUTZCNGJWbURlWkNQZ3krS00vRHB3K20yTXljbGRUQ2xMUDJOTkFCNlVpZ0pFQlFjQnBWTE03K09BVXA3TmpPZkE2S2tNQ2d4Z2daMUx3a09CS0Z1YnBCdkNka3hwMEVDckRiWGxmbmxwY0RCNlVJc1BjR1lxRy9YMmxYS2VhZEV1L3d2WGE1TEJXMnJBaWNUY0Y4MSs2QUZLUHFQUjFoRldjTUlpbitNZ1h1QkxVSWpncWFDR3VxZGU5UmhrSGNKS3BKb0ZLempGUGZYc2NkUTdtem5sOG11QjZXNVFHb0ZVeXBvaUtHa0NjaVk4NmZnalVLcDcza1ZRZXBxNUpPc0dmaGdBOGt6SmZkVnNXT05CMkxzTTZtN0tmV2QrUDdWc3EvbXMzbzdTd3o2VDJiTldEYnB3MCtVKzQvT2lxMlhoUEdxUit2NnFyRW5DNVJ0UGxOeEg1NGFZMktBQm82TWVsNlB1c3lmQUJBeE9CNEZPU01rM0RibGs2V2ZhRVkzM0hveUJaNFBUV0g0TE1FMWZoYXVnRkg5SFQyc0dTZ0FHbEJpRUh1cUJKOXNLVlVCeERnODZyL1EwKzk0MWwvQVJLS0hZeTYzNUxxMHNnaHV5YmZsZFF2MXgzdmxGTzE0MGwwVkdFVzlnUU9CMHZITXFaM1lIbUpaZEFTYUNwVjdqNjA1cTB1UHlId2hBeVBtZ1VmZ05QT3A2cU9aQWhJY2ZXTmIzcnJLdHVxZ1hWUWNRMVRtbkp6UUtKVTRaZFc4L09aOER6d3k0L2xWdytnM0FkRHNvMmZQc2dXYS84ZmlSZ1pMeHZrTUhTanluVkpnZEZjT1V5Z0NVMUxIQkhDTzB2OWdPWk4vZkZUWjBWOSs4dTQvZm1kL1BmUC84WXprQmlrc1pyeXIvcHRCVGhuVUdYcXRpQUlXVzhod3dxZ0JNSFZNQ2NHVzJBRVg4S1hXWjFISFg4cUhzSUNFdTUzUlFZMVhNcklCNGdhNEFGVjlMUlBEQXlweWFmYThWYkxicDZ3YW5zZngwWUVyYkZaUElMd0VsQnFNaEtGblhjR3p1M1cyOVV0eno3cWx1NElnSFZNY0d2ejVKYjY2RnNVTkVMVmc5ZGEzMTluQjNTeWYzdk10NEpaOFIyRXpqSjhBekJJaWNnZmt1ZGJIK1E2YlQ1MGRaZlBvbSt2elVQR2dCaXV0RDFNNUpOc3R6amhJK00vRzNFNGFFaU0yc2h3d3lTRkFLd0pOZDB4SHI0dHZLd0tyamhXeUEzbHphYTd3WU9XYmdGR3YvUVhENjBmS1ROM0U5QmFVUm16bTdSaDVXNW9FM0FpeWg3K3E1NDZoK1BTNTRlTk9kOWFoejMxZnkzbmJ5elNUbmJhY3ZTWHlMME5Pai9JMCthUkVULzI0SHVLcXNUdVVuTTZZdllwbnVjVTdTVWxXV2ZYZ0dDRGxJVURDSDlhYkJBWXRaRUVyTmpBTTJQK2hIMWJrQXgrbXllbEJMUnc2TTZuSGJ5YkpkcjBWRk1POHoxU1ZNN0ZkZUJHWjRPZFRCVGhHbDFLL3d5dTByS0ZYMjlDQjVrMG1mbFpqM29rZGVKbFpYWFduKzN3NU9QNVV4VFVIcGlveEFhY1NVVGtGSmdJakR4ZGxCZGdsWFc3VmxTM1pYQjJ1K1U0YkViQ200ZjdlV01GMUxYbFFIU0MrMERPSk5QZlptNWYrdk96K2tiR1hNUEJDem51elRkZUFENEJWOEFLYlVlV0IwajRuVTNiY25nTE1JVWpuQWdYazNiQjdDbERpT0FVblpFMERkS1lLZ2JReEIrazFDQUFZUWZZOFplQTRBQURvQXNWUkFBbDRleGZrZzFIMzJDT3MzbkFDSUxZaHRZOW9LVC9XOUc4MDlBZlN2NVFwemluRlJqdzFhNzhmeWtwOElUTDhPbEpROUdWWlVEQWloTHF5VmVTUmlVUEt1MytwWWdkQlhXSWR6TU82ZGwyVHdzbC9PNXFleWtydnpnbVkyZWxzeWxqTzY2Wmw2UVY4dThuSDlQWm9pZDhDblduSEFtT2lGN3JMb3RPQUF0RXNMaWVsVDJKRE5JMTZMcmN6T0tZSVoxR0dPUVY0cmFzNE5za0MzSEVCVW9KU2F4WUVIbEtPMitVRUllQ0JRNFU5ak1GREpodVNvM2cvdCswMkhBYWV5d1drb1B3Mllsa0FwSnBxMXJHMzVUNEdTKzdpZlpVTG00MzJJYmU3SWJpZlVXRklvTkJkSVJyc0lBRlN3SmNWMys5UTkvZkUrWlMzeWM0RUo3ekpiTHJ0a0IrYVF2aDJsRDFvQm9Pd2VaTm5KbUtXZGlyNVFmUjVkZnhtQmxjWmp3NXlCR2M5ZXIwR0VKZzNIVWQyRm5Jd3poTXNCUVhlTG9NSWJ1aElBUGc0NER0N0JuTnY3d0dxQko2bnJBZlVCRWRZdGpnN0dQazVnWGNwSlRJSW5PNVBmQ1U2VGEzNGtPUDBrWUxvVmxHYnN5QjYvRFVvTU9NV0FUcHhMc3VjVmlJVGtKNkFrbGRST1hRTUllSFNtaFh5ekw5Mm1ZMzh3TVAwU1V4NTFCd0FXV0pJTVdwenpmRFB4OGJyVVBPZlgyOVNRUU5jSDNSUGcvRW5sODEvbXlobXdtSGgwTEc0RTF1TTZXek1lZFhtUTE5d0l6VXV2SEF4azlWTVloQUFGRHlCRUtGUS85VTVVNHducjc4R3Y5MUhhWG54K2NJenFZSHNBS0pNQ1g0Ui9IcHgrRWpDZHlxdWdkUFp3WHdJbFdWdGs1cE82Ynl5cHE3ZlpjTFVZdzdZYW1obWt5QllJdVlDeEpvUEd1Q3J4ZTB4djUzT1QzSnJmdldXN2pSMU9tZGNFa0l4Uzc1akJLUDhKQ0tVTVJCYUhUb0Z4RUpYbyszRVovVVhlTEJjeWkzTk95ZlZUVUlyM1RPcUVTUFV6N3ZLQkpwT3V1b2xYQ2xUMzRLdG1QRURrUGZvOE9BRmlOZmZWc1dyOUxIdWxvd0JJeGdyaVA5TXV0Um1CMDVsZVc1SGZBazQvZnE4OHF6NW43Q2VPNHVMREsrQWZMQ1o1MUlQbXM0TUNHQWpxZlNmbXVLSnJsc3ltcktWOXRnTE1kNWJjenVCQWJlRXN0dnQxdFk2bUJzZWczaFNYMTRlWTE2dlozdWpsbDQ3WTM1RGIyS0h6cUV3VGpMVkhWTWhEeDRDTVdZenU2eG1Kam9leWN1VVp1Tmc4WDF1WWtKcWl3cHkzczR6YjZ2emFvR2ljb1J0L05hU3MxNks0SnBoQ3Fxc2NBVExJRUNGUUFZQ0RqMlZ1NlVBZ0t2V1gvNkFnME1FZklaVFBjYkN6UmYycjl4V0hESUkyNTdSaTFvdlZtYkdycnMzTzAvMFljUG9wak9uU2EzQUdTakVPb1grd0w0TVNCbEFxaHovbUJiVjJIWk9kVDBMNWdGOUVIcGtvMVpkWmhweFdtZHdFSW1mRHJFdTNHU1Ira1lqZE9XZDFhYjNRWW82MzU1TzBVd2MrWFlKQnRxK0NrZTJHM1VGV2h0Q1JWdnNWaFpOUVhqRWc2SnM2ZXJGTkllVVpkMEJxTFEyUktxTDcwWG1pNmhETDVXTDJLTWRJMWNrQkQzWjZ3SG9PQjhHQnBiSW9SUDVVUnQzZXRRRENRYVhkNU9BUGRlZ21zK1pkQjh3ZVI2cmZNdlkwdXc2U3RLK3dyYStVbndCTXQ0QlNkdjBaS0xtOHhGd0hjMUI2R0srNjlsbjA1Z29POXJoVU4vRG1EbTVjd3JQMzNWVW1HVzIrTldLbjBITW5lVjNvc1o5akphdUYrTUlCM2wxdmNpaHkwN09yenlRWlZvV3lkVHNjaks0L3JkTkUvUVVGbjE5ckVuZXNoZy9hOTlMTmxHdDlSM3JBeVZFS25USmdoNGxrYXk3VWY4VUJnWFROa1lCWjNjeVZiMDU4VC9rcjlSTVpkRlF6SGh4MXUzRTZTbVZVendxWEZhZ0tsS09DMUhFZ1FDbDFQejZvZ3laZGpxZ0RVZXcrREJDWlV3U2xFYk9LeC9aYUdNVC9KUG52bTVuYkZKVE93ck1SUXNhRVJreEoweGtQTnhUVEdydU5Jb01USU1GREZzRmFsdlE0ZEo0cE9qeEVEenkvV0xZZW95M2dHWkYrdFJkWjVxVlpyVDEzL0xhdWUwTy92SHZ4NzAwZ3ZMeVpLVUNydzhwam1BNXMxdkxKZkhHR0YzWDkxYWZ6akxWeG9kclhMVnBRU3hMYUdFMFEyYlRaTFRVaFpWMGVtbFVDQlBmNG5oWWdxUldTZjVHcVZ4MFM4QytiN1k1cTRpc0h3dkhrYnpVaEFEMExWNitDM3hQNHE3bmlGSEhJMTNDQndRbjF0aGpBYWVVWHpQa01xQUNTUjliTFFwTFB5M2N5cGt1Z2xLV0xGRGMrcEF5TU92QXlIYjEwVE9rd29OUjcyYmw1cFlRdFlXa3NDUjFiRXFEaUV1a2JNbXFWRitVcStVamtETUJ1NzhHZnFQOVBsMkdkTDFiQXZCUjFjMUlMVHBZOVRJQnhkTXMwbjFFNXhnOVJHUXYyL1ozMFBUQkloTzAwdmFYVHZGSTJEOEtOU0luNWpIeG1sTHdvWVVDQXlwSnFIQlU1WjdhRTlaZWVBSVFFeDdQdzkzUHI5M0JKem81U1hjMkJQNVBCdEJCUnZvQkxsOEVwTnNWZkFLZWZZTXBUT1dORVdWd016NGhIQmxKMUpCWkJDUXdvdGI5aVFVbjN3V3Vic0RZSEI3TVJhMWhJMjRHU2V3a1d0ZkhWcm5LamtoOHpwN3RaeWIzWi9UaTV4SHhXVU1PTzltTnFDaWtUQlh4bEpEZ0NITFRack9SdHlteUprMFo3OEpzNW5WRElveXVEWktPWU5jZ3JZNlpLNytveEZ2UTdtQitsZ3NtVEFMQUFQZXRPNWZUa3RVNGdEbjZGdjVwYjU1OEtGRGdPcUhOUWNoc0RSSExYR1Rxc2dGT1czbFlOay9Ba3liZklqd0dtR1NobGFXMnJaY2N6MW9RaFhOZk9KK3VUK3ZWSWZtc2gvZUtzblZlS3J1S1JKV0hvT3FlajFQdWxBNXEvRGdpM3lBMFBCTnVBM28xTlVnMjljbi9SM21QUWFMc2JURlNRSkovbE01TEJOYWVXeitidDRHOTBvUzhPeXlzU1JyQTlNUG1IRWNtVW9Wc05rSFRIQnhKYkhKU0RnTEF5cHNUakhFQjRFOVZQdFVzeEtuUGllUzFFOThGQjJ6d1pXNElRMXJWTkNQOU40UFJkbTdobTNkRkZSaURKMG1jc3lFb3g0V1RPQVZxSExzNTBWd0dqTUpqWXpWZ2RTMG8rV2FFN1BqemFMdUhWUjkxdk85U3FQakdKRE4rMUswL3JUSW1Hdk5MazU0cjQ5bVZNOTJaM3M5eFV1cVJaWDUzTDY5cWZrc096WFVLc2NqOTdvR3BXU3lzUnlyYllCMTJaKzJ2R0xPY2srNlJncmt6VXErVDBkUlRtUkFDNmN3U0s4d01CUWFsTUNTcGpxbXVWYWw1SHlQdWd5cE1PS1BWVDdWSVByT0IwSVBMR3J3VGlEQUhRNXFRa0h3c3FXVzFIRnFWUnkwekE2VnZrT3hqVHRQNHJ4b3NzZlBhd09xQXpuVlBtZVdUTCs4Sm10OEplZEVWTWR3YU0xR1NuZTk4RkU1NHlMcWd2dlpqeWhLK2ZOUVhxUHlGY1RDQUxEVExMZjVqK0JiazB1bjhudnhleXVodmxYc2x2K1ZtOUtDTUMwRVd0UFkrK3pjNEJxSVpsNmM0cVN0M0wyV2VERjFqY0NNRHMrejY5V1N4ZHk5V0NrN3FLSTFNZUFuald0VXZ3RkJiVXJwVVZJb2VvQVNqMXk3aWNzS0NrUjlsYXIzMHlJL0hVczdXVm9lNFpPMXFSbndST1h3MU1hYjFYd1djVUhrRnBaTUlEOEtEMFVMQVFNeHNCcUFuUDdPSmdRZW54NUEvOTJlOHBQWlVwWWFsNVZFQUN3NVRBdkFqRVplbnIxdDZoeVNoMytyNS9kZGY2S1YzNTgvSVNubVRqQ3lFS2R6VGRTcUdpeHBvbEdJQUpwaWR6d0hocFlKQUE0OW5DWmtxT0x0eGdHT3h4QzBIY3grdTJRZ2k2dUpsMzZzZG5QVDJBOThSNzFDc1BFdDJFUE10MFZMRGhoYmlOaFVvMUl2WDBKc2FSU1E5Qy9LaWFxMm5Yazl3dlgybkt1d1JLczdnTWZHeGFhOExMOGlvZ0FOWG1mSFRSTEdiYkNobFFlanpibkJLYjhIUzlrbmpoQ1VNU1lBTGpnWGRTdWVrbzkrS2JQazI5T3VwOTd5N2ZtOTFQWUV5VGZPNWdkT2ZtTWxncnQxV09LeXg0WlhDMFVzSDVEUmZ1ZGUyeHZOVG1ZbTlUVUtxMGhoRHJGa2F1Qk5UcEdtSlZBRlQzMGl0VUFLaWEvb1FwUGRpc2R4Q0FiRnVFemM0M0JLVm9KWXA2Y1VUWVZ5MVRTYlpmSWovRytRRmdZV0FIdnRIbE4yTklHV1BDd0ZpQVFjbCs3Qy8zdW51cUNjK0RVdnNDcllDVG1PNFFyS01EMy9PQ2dzZ2FaYmxuck9pRGwwQW95K2VXYkQ2VDM1ZVA4NzVJSnVhN2UvSWVkN3JUVzNWbThoVUpmVEh1Q0xHYXpTdjNPcmtQYVFSeUd2TC9GcWlNRGh1RXFDbVBEVEtQQjhJVGdML1RWTUZIMGhRcWNPQUJnSFU0alFpQWhQQmtNNTZBMDJGYy82MFd3OEg1R1pKY0FhM3ZrQjhEVEZjYUl6UGJ4UWNTSDFvSkx3emFlU1V4NGRrMVNCaEF5VEtsSXFCazU1YWFHZER0N3FCbXZCY2I1dEp3Y0JTUnRPNXQrNzdkazgwbjh2dXBvUGxlUHY1WjNyMjdlOTB5NjVVTFk4RGlRQ3pMSUE2YXZyRlBOUE1hcUVLcGMwQjhBTVFvVkxrUFVRRXNCSVVPT0I2Z3lGWUk0SGp3SnpFZTFST3ZFTUVoaTRHQmdNeDhVd0hVM1pHcUtxbEFGZGMzeGJKU09INEZhSDRDT1AzM1JhUEtxUmx2bFZabWR0VVJoYlhYZUdjSDg3a0o2ekZYZUIrNzBqNkozdTNpOExCTUtUbzhSRkFpMFAxR1hJVkdqM3pWN0hFbTM5Mmx0bnlOdlBHY1V6T3UvSTdleWpmeVhKTEovVzVsaEM5bUpyN2IySEN6V3Qyb2dvZHM3ZkJvaEsvZENkbXlqenJmSkd1WTZxQzY3aHlMOGk5UmMrQWxkQUF6MG9IUjJuVFZwTGRncS90U2M5NVhNS2JiUUNuK1pxYS9DRXB5RHdTL2lOYXVWNnE3aGJkdGh0cGlXUVloYThyREhwVGFJdHJETUNRYXNLV2JGY3F5ZkdnVStvTVowNDh0MjYxMWZLRS8zZG1QWUt6cno3elVGN0t1K1F4UHJzdXJsL3VOZFN1NlZGMVNRWVRVR3NmK2VHVCtDa0pSbGxUek9PaGdiNzBLUk1RVFVRUjFWL01uTUJZaWIxVExKajFTODE3ei9MTXNTYzVYVFhxdWp1ZHB2d3ljdnNXVWR3WStJOGxNZUJET2JScUF4cFowM1lVNkl6VEc1TDVDaTM3QnJKcnVIaGFraENVOTJ5SmE2UWJXTGR5T25FNGZKMDFQVjJWMVFIalhITk9QVmY1MzUzVm5mdC9BQUticnBLd1Y3VHZiLzFYRjhBWFMya1ZXV2dtLzRUVkwxWi9CTEJFNUdqSThtUFVRQWp4NHJxbEEzYVdjQWVvQUFId1dYZ2ZGWG4wSXVoTjVOdCtVc2FkV01uKzh3cG9BZWgzN1hmTGxDMnpQN0tLemEyYS9Gb3cwRHUxbkxPVGxKRFhueWE3ZnZjT0QrWHhGYVl0blBVdDY2cG9sN1lqUTdNVmRmVzU0eXZkYTh1NTU4ajlWOTkrZDE1MzV2Ynd4YmxLQVc4cDBlUkxpaTFYV0s1TWtIN2szdG4rSnJQR3RnUk1BRytrWXFZQUFvSUlQbFdyS2cwY3o3UUd4TXdRaE8wM3g0bHNBM3Jhb01pMWhuOVZ4Z2hHUWVsUGN1eWE5VnN2dkJhZFBNNmJUZXMxbVhETGVtRFcyemF1RXRBRENEa2hCeE8yRlY4eGVlSmc3TmpRekhudmVnWmpzRENqcDNKV3BGZDc4YUgraTF2NnAydi91dk83TTc3dS96amtEbGgvQVRqcjV6akk1QldPRzBBalZBUUlINENTZnI5VjVCRkJBQW1MVEhpSGdRK2FiK0R1M1ZOZ0tBK3JZVXRjKzFlc3NPNXJwemloUmw3NmhtYjdFblBkSllMb0VTckdtbzR0SHJSTHRxOVkxWEV4cHlxTE0vSkt5cHU2ekZVL0htSUFaVkw5ZWlaa1NNVWhwQWVuN2hodGIvcGJjelZCMnYzeFAzRWNJRzFkeFpqTjJBY2RDd0hzWWdUQ25nNWtTUGhBSzFma21wTG8rU2p6MTZ2cGRmbEFrN2hHV0tkVzVwNW5KTGs1djJIUnZkb0dQZzlPWHpqRzlhMExPMkZNTXQ2QWtKanc3LzFOcHNEQWtleHptbExwdktvVlBXUmhuaCtibEovZXlCZHFNNmR2eSs2bGwrNG1zWk11NlZHb0RBRmh4SWpJbkJIYUU0Q1cweEFZNUFxQkhuVmVDQi9DY0U3SWhoMTNLQ2FHUTdFUk84RHdVaStxTnFSRXcvYVlUakUxNHEvTkxHYURGOEsrVUx3T21WOTdGakhvaTlJMWx3K1c4QUlDdVZRcUxhR1VoYlhRSGh4SVh6WG9Ubm5jSFB3RWxEZHV5WmN1Zmt3eWNxbjNQYUhWaU4vSUtIY1RNQ0I1UVdWQTVLaENWZWk3T0VFUkZMVEFGb1gwZGhJMHc4cDB0eFBvQlF5a09KK21LbVJaOWtQYW5nTk9uZ0duWmpEZXllNjZZNjdKMGJuY0hScXY2WTNaMXlQNENJQUUrellmK2t0MGRZQUJLWHoweHZHWExsbThVQTA1OHFsdm9GV0kzY25ic2xzL1hFZ0FVQkhLc1NjeDV3T2E5dW1WUnpRaVZpZFU5WTVzR0pPVFB3RVBUaXpPVDNtK1phL3FFVjk2d25rdkFZbjZ6Um94cFhUNE1DblV2UEFEbmhkZHRPMFRPZEZmRERFTlNreDMvNlNlOURDaHBiVGM3MnJMbG54UDd6aE5NNXB1QTJSTUJ3RkVESGp6ZnhKUUlDM3ZtNlp4VFZXZVBVdUFncWxzYW9aanZ4UDI4a3ErbktjNElMYzcwNkt4NkV3VDZHRGg5dVNsdkJaMGphRVZVejFwQ3pIYzF2czBweGI5dXR3WUdKU2hQSUYwczI1d2l4SjNjelNsWmx1U1hnZStKNVMxYi9pVlptVzhDQUVBQ0t1eEdmaHcxc0dEOTBDaDc1OVhQWVRCd0VRSElsa1dGS3RIQ3lyQ1F2ZlJJdGlpcUszRmRzVWJzNllwNWJqUjE4aFh5SmNCMHhmNHBZcUU0WTFoK0JHQVpDeW5sbGJoaUFLYm9YSkZsUncyYzNCb2xjWkNBNUk4SXdPNHJ0azE0VzdiOG16S2FieEs5eElOVzkzMDJJZ0N5N0treUplTDVKbkdJUU5rVkFxR2E5RkQ4OGN3OUFlQnB3R21raVVibXZDeU55SGVCMDkzQWRGdlpSNlkrZXlOTTRvdkUycjN3MUFGQ0ZzUSt6ZWNzN0x4UzNjMUJuQnNzYStyek03WGRUR25MbGkxUXdjR3BCblZlTUM3Z2RsY0lxdlk1S3ZVYlR5aGVld2Z5UUJyNDJ4bDFWNGdEbSs0N1pKN0pqTXV6QVgzR21tTFllNVcrMzV4MzV5YXVsK3A0aHRnWWppSDV0YmRWdDNCTkpLWTdhcDJodEY4TFNPUzJINkxPeVVFWVV0dld5RlIzTTZVdFc3WkVNVnMxcUI1RENPdWJLbXVpQndMVy9SMllRU0VRcjMwNnpKeTI3RFdCVkQvdmJ0YzJJWjJ6cHRYcGxCY0E2M1p3K3JncDcwcHBJL0NNYXR2bWs4aGRVQmd3b3JPRGZwWFdldUJaRXg0K0d6c0NNNi9VelZGQkE2dU5SMXUyYk9uRXNxWXczd1FBd0t5SjhHQnZCckhrQUZBcGRYQk1xQ1k5WUpNZUVFRXB4THVUdHdGNDNZMjg2Y1NvbGlJemVtV3VTZVFyelhrZkJhWXpiNDlNUmpiTkdXalY5TTFrNTlZYWdWbElLNlk3OHd0Mlp3ZnIrQUFFMWhOUDg3ZWwybXhweTVZdFVUQUJKd0lBbmgwaW1XK0NvNkVKb1o0aklaU0NkUTdxUUFBODRDZ0lSS1RleHZJcEtOV2xmSS9qUTNOTlorRjN5MGMzY2JWNVp5YTVMRDBteHdEWnRTVHpnUUJBekpZa3Z1N3cwSCtWMXY0K0RRajV6VnpiSnl2NGVndEllMTVweTVZdHAyTEFLWUlTOEx4VGFkTUU2Z2hSNnM0UGg4NDVIYndyUkdWVlJ5bUFoeXk4UmYzMGhUaEMxTFc3YmVGdGxCaTZxdjgvaVJPWmZJbFhYc1o4b3NUNXBBaGt6WHhuUndrMjk3aFdpWlFwT1lhRWJaMFNZbGl6SkNCbG1SSi9KMlhQSzIzWnN1VVZFVSs2cWsrTWVVMHRPYWp6NFFKUVl0SXJCd0xJRGhIc1FnN0luNzVna0tzWXFMYTlkbDlvUWUrYTh6N2k0VENSdTRDcHE5Y3JjMHYyUEdibzJWZjduQVVBbU0rbTF3bkNvaWE5NkZsbjJGSU03K2FVekJaRXVuMzlsaTFidHF4S002dUIyYktvZ2hJREZZTHgwa01HcVFNd01pYzZnQTVVVi9NNlQxWE5mdnpGRERoQUhja3I2QTFZRThDYU9lOTZaZS9Ecm5LZTVGVGVBcVhSZFdqK0l1TkNUV3kvdDFRZlZsRzJKTHM3a0dGTFlSNHBIcnZkSGNDWTgyd0JOa0J0MmJKbFVWaGY5Rjg2OGZQV0tPdWJqTmR3UFJmOTFYNUxDWi91RVNzUk5DeUtVeUZhSE9qMUxFelNYcFRibE9QSFRYbXJKWTFPRHhqQ0dpMzFiS25TWk90T0tmU1luUmVVQ1psZEh0SS93NVlrSHkySUFhcU5TMXUyYkxraW9qN0FtUFRZSDZJeUpxTzdpQUNPbzM1Q0hROG9CZUU0bW1tdmJ2S0tERWpRNXF3YUlZUG9DQkYxcWltU0hsKzFjSDFhRFg0VW1HYm11QmlXb1hqTXE3UW56Q1k3UG1WQUtXWVJyWE4yUU5rTEw5bHVTRWN0d3BoYWZwMFgzcFl0VzdaY0ZXZFdvMGFmVkxYWUFUWFVyWXAwYTZKcTFrTkN3T01BWk1DaUFvQlFlR2NJZEl4TXh0SHlhWXlSZHgyRXVORVV5bmQ0NS8zM2lZOXB6aHdjVnNNaVkzSnBVWjZmK1dxczBOcGlRQ244QWJiNXBVYVY0ODRPQU9vcDR6d3lObHZhc21YTHE1SjU2WUh1cFVjeUVDNmtPNDFiUjRqQ0MyL3RWNWhJdDBVaklWb2dLWVExSWRiZHgyY0E5STQvUUY3UjkrZWE3cGhqV3BJelJoVEQrOXBSYlV3RXNNMHNEOVRPTFltTE4wS1lTMHE5NzNoTW9UczdORmFXRTk4dFc3WnNlVjMwMHp4bWl6TlVuU1VEWkx1OEpjdzF5WFdGVEI2OHdRRDYrYXpveVR3eTU2M0s0alZ2Szh4M1RYa3ZPVDdNU3AwNVBGUXpucGVpYzBGZ25CUUlDQW1LK2Nvc2lRa1B6QWYvTEVERlBmQUFHaGVXQW0xYzJySmx5OXVTZU9rQnRIbHNaajhveC95THh3RUZFUTVFZFNrdnNnTTVFaHlzdnc2K0JXak92TTVwNEtGbnpYbVJDRmkxOXgwcThMODNXTmN5S00wcUhETjAxalA5bFprOW53cnRDRUhNZVdiVTBSYk55dWpDN0g5bjU1RHNsa042VXpMMzI3Smx5NVliUkJ3U01EUHBzVmtPdlY3Q3dtWTdJbDVjVzhISWVZWWhWUE9mN2hyTHUrL0pXRHRvMjVFNVQ4Sy9XK3Q5elBsaFZMRVlidWVSWm8xaFdaTlFWL0ZrMGEvVFFsaFUyNjFUU25ZTWx4R0tnaFI0eHJSbHk1WXRkd3JaQStFMkxOWk1SL3dOSi83OEJSNEhVRUhlZVp5TXA1NEJLeUZIT2tVdVg3OXRjMDEzbVBOV2RQWTc4cEU1cGl1RmpXeXFaMUZ0NnlHZVpWTHpIU0tZZmZBSU1qZHdCU2oxVHpISGJrRnRWckFOVUZ1MmJMbFowT2d4QUxBV0hPY1JiQ3hBeUh0K0ZsbkhGTll5aVI0VDBxUzN3bk10dG1ycHNqS3lldDBsdCs2VmQ0YzNIa0RiMTdEenhnUFFTVUlBeTVhYW93TkdNQXE3UHJoOThJRGR4YWwxQkQrYTJiSmx5NVlQU0dSTjVDTXQyRURodFV2eTBjQkR0akZDWlZnQ1dvRE5mUndCNmhkd21UV0pQNStWa1I1ZUFaNFQ3SWpUVnBmazQxNTVzNUxOS20vTnAyVFlpN3BXeXB5UzlXb3hYbmwySi9IT0UwL2lyZmx1eFcxd3k1WXRXKzZReUpyc2dKdDFHNGhKRCt4ZzNIdm0yYjFCYTM2TmFWa0xFNXA3UnNSWUhZSy9vQlpmSHQyL09zZTA3UGd3ay9Oci9HMmNKeDVJNHpmd0lmNHRjV05XM2ZmTzdBaGhyYXgyam1tNzRXM1pzdVVyWkRUUll6L05yZ05uc3o5ZUFLYTYrdzF3UERNci9uaWdrREg3bGR0TXJOUERWVjMrQ1kzNUNtTjZHNVJHM25nU1o1K1hmSCtrcFRNamlHN1ViZmFrREFBQUlBQkpSRUZVMEFDb01TVXo5d1Nrdis3N1NtaXF0Tm5TbGkxYnZsSXdxRlMyRUtuVktESWo5THF2emJWTHZEQW4wRUc4WnB2ZGZqRnNXb1dMNmMva2xqbW1TQXZQckdJejB4MkIvenB0QXl5WlQ0TDJVTUI3MitubXJhV0Y5U0FWN0xlMjVOdmhZY3VXTFY4aGRsMlJPWGJzUTB4NkFqSzhUbE9tbHlpd0p0bUNTTjNQU1hTbzlZWWd5TlkwMlZ0ZWtVK040MitkWTdxaTBrZnpTNVk1V1UrOEJocWVNYWx0TnN3bEladnJkTTdKc0NYSHllSm9aY3VXTFZzK0lZVHRUNEppa3V3NkRJZHVTcU5lSlVEVjlHTlBFS0l6bVEyamNMd3FuOUtlVitlWUxwVWpOc3paeGExeGZNcTJhTFkyZmxIbXd5RGs1cENDQ2MrYTdOU0V4L2ZRRzU0WVlMZHMyZks2VEVib2EvSVZ2c05mbXg4QjVLd3BqSnNya05uYk1RdlNZUG5YTE5SRjRNK3dzN2FUdWFaRUFhOG85T2lsTjdwbUVQZkt0Qlg4ZCtHU3Q4QXhNcVFsSnppVUxZZk11WnJoZUUrODBzNmJPWStnbTEvQytNVGhNN04yVzdiOFZia0tNSi9ZSWZvWGlsTXhzUTBKQU5oRGdXVFhCdjJERHB6Y0o5T042N0xaOEVGL1pZc2kyWmhhRjlzbVpjejBzWFdJaUdrL0RVNXY3L3l3TXFFMmF3d3BjZVlRVWI5b0h0bU9kVmhvdXo2QUF5elp5TFZ0ME5wQWJqQ1g5Qkt1YjlueVIrVnRsck40bTVXWDd0YXkvQURHSkdDazU3d2pBd01TMmQrUURxRm5QbGFQVWd4bkI0aURjcUN4NWp1YlIrWXJNQUtqVDZqT3Q0RHAxY0prRmJGbVBHRkpMcDBaR2RpMVM4VG11Z0tIQnk0RFhtNStTcmx0ckltWTl2Q2tZcHRpYmZsajRrYmhxMisxbWVFWURwOXZVbGZUYkg3S2RIMGlrZDBrY2Q2a0YwQ0prRmV5dEhrcEJTdWoyaXFveWRma1pBQnZQMHZvQzREc0FCSHNSNWRZVTFmVnBJcnZ5RnRlZWZiYURHR3p0UFkzQzR2WG1rY0d5cEFDWTJwelNSR2NKSU1NaUdLNEhabkFSQ1l0MWtWbGFUZXdiZmxtdWN4QVJDbXVwWHY5UG92NXZxVUNrMnRYWDBsTFRVWXlxSFBYZGpxblpBQUhBeWdkQ0VBRjZFRDlxMnJPbXZxd2phbTVrSEUrS0xOSURZc1BYanZPTEdJanJicVE5YW5jc29ucnE4OTFWRkxCZTREYTdzWGNRVDlCTE9Ba0JJZVB5ZXd2MVJoU0tJRnlWbXpCMHhLZENia2ZkN3RPQnZrdjNYWkdxTGRzR2NpdFFJVCtCUTdYK0tTcmc3MXhHZXFsaStWZnVjYzdMQzVTakZmeXN4NTV3Zm1CcUNqWVZIQmlVS0lDUUtVeEoyUG1JellMb2dHazdGbEV6V0dya3BvQXI5VnFWWllWN0VkMkYxKzVjMWI1bm5WNUx6cUU1bmxTWEh6b01TbHpFV3FMTFduM2dpMlV2RXR5TnE0NGt3R29yUmRnL1ZidlhiRGx0OGtsUUpLUjk0Q2RrRS9YN2hIU3VkdG53SFM5MytIS1RxVCtpcE9vKy9xK3JXTXpuc1ZFNllYbXFucU94cFFuNEVOVUFKUXhGWUNqdURUNjNJS2hxSldweXNFbnNoM29pc2FLNXJ3c2Jld0tPRWwvUlQ3MjJZdXJ3bU0wMTI5U1pzVW1QQkpuQnRzRVpscXAybDNSWHFoMjFYb1BCTC8xaHk5SnUxZVFMaWdkUHZaNVpZS3pMcEplRUc1RDZlRnFWcmRJSERHNjA4M3V2a2NpbUp5a2cvWXFvQTBubjZZN2w2QUJBQ0xnTUM2VmtSbnNNaXZKUzJOL3V2QVh4V1B2TEM5VXZXVFA2NFV5NURac1NFMTVEWnhzbkJ3algrc1pVNnVaWUZVSEZyelpLNWh3bTc3VjZWb0wzUVZPdHdQVEdSSm5pSHllcWEraXZZNGdXeVhjSGpJY2hVOFBBQ3dBeEIvaUl1czgyVHF0bXk2Y3ZsUUR1OTJscHpnRHRTUjdOVDNhcnZTcTNJRk1aOEJ0QndZYnBENHZLNEFVd0NoZTEzbUN4V3NTUmpVY3JIVkRSN2pXN3hnbTM1aXI2c3A3dHd2N3VoTHIzZzB5d0NUMm53eDhnTTE1T3Rla29GUzk3WlF4bVNJbDVFa1puZDBod3NvcjVyd1hBR2dKNjc2VU1XWHpTeG1xMnpRS09tRzFzeWZRUWo1NDlLQXZsLzJUajJud1UwUXlEZHJNYVNnZDE4V1BhaE5FbjVMQVc5YitGTW9memtZN1VYRDk2dkhGN3ZDeDNTMkNFbE14NWtuRjBBc2d2T1VGT1FFbGJuOC9iNVFBa090amZPaVV1MVd3NGRqZVh2dHI2QitqK3dkeG9JbEoya1h3N2ZLOXpWUWd0N3J5THNabjFPYUlhbGliUnlJQVo3WWpHV1F6VUZVMTF0SWkxSE5iR3F0UGN4Skp5VUFEcnVYeG1weUMwNnBYM25CTU5BdVBGWlJmVzlrWmt5cjJHbU9XUXk1UjZ4T29ab01LU2lVUVd3U0FRd0dwMW9oYVJwbDB3NDNSWTBuTWFiTGJielltQ2ZUWmxxRWVUc1l4R0ZwcENYQW95VFBtOVlhNHI1SmxUTTZBbENxWURVNzN5Z3lVdUw4ZElhMUlaNjdMQUNrRG94TVdGZTgxTkFNbVpZcENTWDR1RTF2MWVWNzlPemxPT2J5Wks5b294K3hobUhmZjFsc1gwUEl1b1c2UmJmSUhyQS81RnZMYXRWbDBVZzFZQUlDUTRBRUFCN0hPSU5SaGVsYkNDRXB5UEhwek16MGZ3Ni9LQ21PYWd0THN4aGtvWldteThIaE5iV1QwSXpGMnNheWd4RTE5VUIxNDZOaElRRWtlaWdHazFrUDhqYWExZ1hiOVdacXVZc2sxU3ZkaWJHZzlpK2FheEJjNmZVR0c3K0hOSTBkWEhnZ2dGYlNIakNnMlBuMVlXQkVHVmxNRDQ3a2Q5Y1dSdkJ3dmdKYm1EVHczaElQblBBTFRIamdwRHNpRy9TYldMd1M1T2Vma1h2SGFrNklCd1BnTHNlYTlibUY5QnRxTzFzb2pMdURkbWlZTFVLMUFVVFZVRlVrdGpKQk5kMlQrbFFwVW9JcXNLQUpNMWhRcnIrK3I0SFRabERkVForK3F1dGJWKzZxMHhrZG1TOVZzVjVnaHlld3RRVEdiT3lEVXVTVysybTVMRkhjVzF4c05tdEtDa1VaUHdJcUUwbkc0YTV6WVliUDQySm9kS25tRk1ESTlqdWF4N2x6OGFQR29hU1VPaUsrTXZYQWowL3N5Vi93S01GYWlnclFlWWgzZ29Fc3pqamYzNUhqbkFXdksxTzRyUDBsZk5HWEVwSTd1R2hjWDhncE1zYjBPTi9iLzdqeThBNk1MVXhZcUFBUTVHQmtWQnVaV0NBUUhPM1JaWGRuR2dqWGtFTUNNZzBqWDN1MDI4VGpjZG5qTnUzSmxyN3hMTjR4cVJ3cU15WEdVNkV5SHJIajFJcFNSUXZOSUFVdE83Y2ljYkpOSkJPVWptaUVnaElKbW9DYnNDMjI0VWNnWm1GbTIxcS9BYTNIQUhVZUhaNkdjM1ZiMldhdGlLUGROTHlhZ0s3dThYdzZnSW51NnEvZHVHY2hyb09TdU40cXlQckljcUpwcE9pamE1RjQrVGJqbkNMd0FvSnZqY3VuSCtiZ2s4anBoVnQ4a3l4aUE2V0d2b09sYTU3WnRJdnJNTTZJdzhuUDNiWU5mNVVMVmRzZnFqblQyZ3FnYStncTJZeGs0SE5SVXkwZ24yMWFqNURpVzdkM1grNHd4VFllME16VkhJVHdycUs4QXVmUDQ4T3Zqa1JmRlBqQUdKSjFia21zUWtKZ3R0YWZEbVFjd3NmZEtDb3F0NTNDaUJGenN1WGt2ZS9ZbjhTYmNNYVpSM3JiYm5JRlNpQmM1YkxnQnphbWNBRjYyaFpNcEVpcW9adUEwNnRwYjFpUlQwaWFvNjNyeFFYbXdJVUt6WmlpQWtyM2VNU3hiamg1QXlKVnhkUCs4VG0xOG1XaUZLUUNOd1RpYjdPL1RKMG5TSWhPWHpZWDA3L2RNYlB1cmJxdGxUcDloTEMyMmhrS3cyeExWNEFJQVQ1RFhYWjZuUVNLSkM0QnF0WVBrRlFIbnpUZDNpbDh6WUhyNXZqTjFNeXBON0hwcE9vZDJuaTE1M1k1UVA3VmVRUWtWbEFJd2RSbERxaXdkSDhBOFJ1TFF2VkYyWkdQU1UrdEpqVm1ZZE03MzB4NkgrN3EwNXFidVhxT3VOQnN5akNUa3BaM2R0Rm5BT3dYbkRVNWZKRDA0RE5NNXBUaktnMlVHU2hFTWhFV3B4V0owNzNBL3NzRjlmdmE4SzIrV0grZHA2OWk1S25TczdrU2NDa0MrdlBiaGJxeDM1ZFVhVVErQUFCcWtyN2lxREk0U0YzREVBNDZqS0NnVmFHUGZDbElNVUVqcWluOWd3N2pSRzJrMXhpais0cHM4QktkYjNNV1RBWE42ZDF2d1dJbU1EeUQ0dkdVRUlPcGMzTUtyYno0RGxNYktGY1RQMVFDVGZOa3hLbm9BMzFHSEMyd3o0S0QyWXNrM1U4aGM1RVpSRFNBcG5EZjlIbHVuRzVlQmI2MElWdkV0QVhEelN0UHh5b3FndjQvcjBmSzJWRUE2QmFlcm84d3RUV1lqd0t0aGNZd0RZQ2JuczNRNWd4bW10L0hUOHN3QjFiK0NPUWpaOHZWZ3grSGQvZGRlQ1BzMk9wRGljSFF4TC9ScHJpQWlBcGxOQUhRY3lFSE5tUUVCRUtFY2RZNmRBQURMQVhRZ0ZENlhQd0dwT3Bac0dyZmFuWHFsWUhYeUZUQ0tldnhxSzF6YXhEV0N4R2pNSFFFb3BzTVEzaDRtZ0g2ZWdwc1NRN3orc3BMVFRrQjEyVmlGcUFQVUljSzZoM1ArV29QWnNFQ0trSXJwNmpZLytYV0ZOZmVQNEVTaHZncWdNUjNYVXE3WHRTYjJuallNVFRuTUMyTHI0K2Fyem1UUXRheGhXckxxamdXUTdIRXlQRkdBT3V1Ukc3dytJV1BGNDRkNmFaenJzcTBUSUo5N2MxNDJJako5dkNXc1p6RTV0Ym1SZUswZEI3cHlEb0N4VjhGWHBLbHNiL1V3V1JuTFNIK1hWakYvR2JreG0zZElWRVFCcTBFUnFTN0FMV1Rta3dwUUFUam9BRHlLM2tmZ3RGQ0ZJYkp1aGFFVFJEMCthb1dadkFwT0gxbGdPNnRNMUZzWnFJVnhqZjZyaTIxMXhBRDZvRkJIQUFETmk1OE1PTFVSL0h4MFBtdnFlSTFsWXlZTk1XRFpOd1VCT3JNYnA2azIzd1pnQ0FBZG9Nb0xydm1hblNzNnA0Z1lCdUM2aG1rcmtEeFBKV21YT0pSeXZjKzNkVk1uTXlRRDQwVjFVbzcwTVczUUVuSGR6VXJYaFEyUWFEeEJaRU1Jc2hpVDA3dVJmUDJsT0RoaVJkcm1hQnVyYU9XUTUya0taajFKM1hPMkE1eitXaVFwQjVneWdoKzBhZFlKT0hiM1Q2VGJoWVlHY1JTNmF0RDRKaXljYXBwb1pkQmwrenB2anFBZWUvZ0VwQUowMkQwZG1ERmhIYkMzRWd1ZzhqM2RQUFVJTUVNemdBVzZQdnhkK2RpSEFqT3hZQlRVYmMxTEgwRDdsSHE5QjNHbzdDakY1d1JRME9mdGxTWDJMV1hqWmdWTmF4ZGZGRHRTSWxNQWdQcHA0NWloK2UxR1A2WkZFSFN2a1RhNUtoVnR3S1BVbXhyTjEzSzdseklnUnh5S1hYS2ROZUNXeHRtMzBZQVRVVnVNT0N4YnpIalN4Yk1vWEx6MkwwbW5DVWJBSDhXTTdnajY5SXBzYlVDbm01U0djS2RnTGVZa2Fpb3JUZmVrd21XMm05QWdqUTNMWGdNNWQ3aVUzaGdXQjJwejFNY0JTSTN6d1BvMTdxQ2JTQWVvenZtYnIrWTk4aENnRU1JQkJGQUtJQlVBT3FCU3BnT29GTUNqZ3RNVERrQXFEVmg0a0dyYmRXVjdvMC9MQ0poR2oreFVSb2laNFlNcWNSTXYyeGxhOGtuSXMwZjY0VDkrRWJDQmxYM1B1cHBZNVM0Z0VpdVdnZEhJaTZuYjRhQUJCRVFnR2NXbFRNN0cxZnpGeHF3TXpKVTNnSlIwM3BsKzVqSlVENnpZV0JmRUtBb0VHYjJCcVlPVXRiMVlEcHdBbW9KTGg0eFN2NFZDMkZPcmxXNGJ2LzFVc1gyNkY4V1dtRjRPSWZRL2dEQmdndGJQK0xraVVUYTRkdWRvQTdyQkFvYnI0cHlNM2hScS96ZVZBZUpYTHdLSXBEUDMwL2VHdzdVZW5FemZFL3UrTC9ZVjlNZFdsN2srNzhxWXBiTmlHeTllWTQ0Y3NpTFhwVzNvaWtSVloxQ3Axb2RTb0J3SEhGamdBSUpDRmV5ZW5CbHF1NEVCS0cvZnNDVlkxZTByNlh6RnZXVEE5RElvMll1emE3TCtyTDhDTmxBN2pYeFhTVDZSM3I3RFZEOEtxSjlOaDVhdVlUdVpPMW1GUG1pVzlIeFM2eEhEdUt3SHpRVjZtRDZuSFBPeW9wa3Nob00wQmIwclpRVURwUFlsQytNNDh1a2docEdZZk93blNFd09RN1FjZGZXUXhoWkdCeVdqNi8rcUpBTWpGd2ZRbVgvMS9hdkhOU3AwNkVTbitsYjE5MVdUVXh5R3VzRURtSElZa1Q2QzRKVmt0MnRJU3hlOVE1MXJ1SHJvWXNQeVdEL1huYkorMlBlaGJnN0kxallPdUZ5V1dWNkR2dS82TVFlUldCOVFRVXJYUVpteVBRRUFzQUJpZFlzZ0JBYW9PcGpWTnFYNDlFTFprbUpKNjExNXMxYkI2U1ZUM2doODRrMHpIZHJTeEpUeTYwRkdBWWdCU3I1V1MzZ29pN0lmRDJ5bXdkaGtLODFuTmYrZ2xqUGt0YVk1blF0Qy83VFJITmpkSVNKN21ONG55U2Npa2Q1K01Gbjhpc0syNjBGYzFScmdPSEN5TDVRREo1dWRMeDg1azRXVkRHbWowalIxNmpyZjVWSEQ3NUt1YXJVQjVGMW9pamhlSVAySGo5UDVHdkRQcjJVUFlZTWJjSjVkUVRHakQyeGxjSSttM2JCVkNWMlpmRGEyUC9uQmtGZjBVcVpZaXNrb2IwRXlZTklDdVBnTUFQMURHd0tUeTlXV3Y3N0hzdE00VVdIV0JIQ3dKYThjdkh5UnR4UW5MQXhReE83bGFJb2g4OWloS3RDMEtZWmpXeVZLempNTVdKRWxyN3pZbFpMSFBUeU9ZV200S3FnR01BZ0V5Q0NFV0FHSitMZ3lKRGtYd0FLOXR2ZHNpOGVqV2xMNERUWE9zaHVOZ2taUFJEVzZCUlVURmw4K1NzclRmVXNxbHRXWHVlbWpDRkpkQlJZa2xpM2VOK1Rwd0ZlaU1vQXkyUTdLaEpIaURlZVV2SUp5U3V6UGdaTVpsQXpBQ2VSZkhBQVVTb3BlZVZxcjljajdycnVQQXBGWjUyT1VYeXJKUUVrM0o5VWQvMDN1RnNnc0RwSTlNZThBWCsvNlAzWUhYUkhUOFkyTnhjVG9oZUhjVnFhN203MXU4QzY2SWx0ZGhHM3dwN3M5VkV0SWdRcE9VT1M0NmhkWjAwbllXSk85djR3blpZZ2ZOY3lLN3BmaXplTFA1RmF2dk5qbGJHVnNuODQ4V1FTMEZLUjBQdWtBZ2dNS0hKeTJnaFRxZVUxVG41RjFtc2pBeVpZMGE2b0VPaDFRekpvMzY0aDhyWTQyVFZwNXV6TGQycitqUFc3YUFETkIydTlOaCtaZWNmcjBUTEsyazNheGdDcDFpbXVXb0tXMTRLVFplSUFhM1VvdWpJRGxnQ3BsZ054Rzd1TXpmeGljNUxDTEE0MFhKZHB3SXJTYkFvbTlqdDlSMCtXb3V5K0ZOZ2FER1FScG4wNDd2d2x4K1pseXVFdEQveEh3Q3NEVjNtcjdqaWNnRjRvMWZrK0k4elh2SDVqNmRoZjNvQjhGSTAxSmIrdUJ0MDVWWTYzM1FVQlFGOWJLWitqZ3dEb3R3bnVHSWxJRktCN0FteFp0YWdueU44UytPVkczMy8xR3ZRVk1vNGMyVXZtak1HVkt4cm1CNEdCMnhPYTdjS3lBeEFCVm41TnRJdWtjaTAybWE0WENScFpoNURYdnRlTlJrbzhiZ0dkYVZobzN0QzI3QlNmWGZReW9SaGVsMCs2VWpZTk1uTnZhcWVVblcrKzdQRHJuajNpTEJESXBoSWUwenA1dUhFYjYvRWh2NjhMK2xNZ2dCUVpWODgrdU5jVUFwRWFZMGVudU1BZ0JBM3R4SzZGdVBEaDdCcTJNYmNzY0w3cnhqbnZrMks2UmV5ZkE1ZFpOclkzUzhsS0dLcHFDQkp3KzcyOUx6a2dta1Rvd0VadnpDaXBLSUxNbGJVZkM2amFPREZUTW1xeDV0RDBlMU5mYmpZVk5kUWlTeDVta2VWWCtXMm1NS3dDVWhSdDE1T0tGM1NBZm93RW1NZGNCQ2xzNkFQREo1cjFEelh6QXBqMGRiV1RncEpLOFlYcHF4bFMydDFrd2VzR05EWk1PMjNmVUNGQ0QrS3p6bjNWNmpDZFpHK1RYRDJ1YlJPUXZlQWFTOXA2WTlPNm9FYTNHaXdxdnB0R1h5UzFvdEdreWNQcUxFdHBuMkMzR0lPV1h2d1hGUDhvbU9MczRRSEhsaXRmUEhrWlRscER1eDVqTVJjYnRyY2lHbStOdWtQSzZwQ29oR1dCNks5RW9yNVd5VU92S1doY0VkWUlnMExZNWpxb2ZDeUpRT1JUSVpjcWpIQVJISWQxRFUvWi9CUUxkQ1FMYjI1VU5IWmRiNzJvcjMyYktHeUdrVlVmMU9ENmdCaVF5aHdSd05PY0dDMHB3QUVBREo3RHpUUWphNE1DNTlhUHhVY250c1I5UjlhTytESGJqcVl5WWd1THZuczRNT0cwN3hSZFFzaG93ckVIUmNsa0ZwVmlISytNaEFRWTA3Uk1CQjMxYUJ5NEorOUpUWFYxajdwTlZZRFR1KzR1U0FQZ1NTQUZvcnpYOXVBT3FsdlE5V2JCbUlJeVdOWkQrVU5kUDlHSndBeGJPTCs4YnJ3aWRnTW5vdlRmeFR2MHNsZ09oTWgyMlFvaXhvSFo3L3ZJU2NuWlltUklnUWdHQ0F3N2VHNGVNNWQ5L3lUWU9IKzN2REpUdWZLTWlNSFg1eHZIclNESVZtdzRtVEFvL2NCRlFFZmJEd0dOQkNaLzhaMWtUbS9JaVV6cGpFckZVYm5URm5WZldDdGlTYTNoZXE1WGdGbjhDTEhKT3JVaGRrbUU5S1FRSGhSSk1JK04zZ3BMVGpNM0YrOW1NNVVuclVBK1NTcGd3TTJ3ZkFwUUZvQVNjWnRWNVY2SCtaQms5ODFtbGg5ZlU2ekNKby9RZ0c2UzlLM0hRMGhXdlowNVJhOW51azlyZTNsQ25aM3BHMWNZS0NLOUxkR2pTeGJaUVhjUHJ0eXlJZFNnakVPdEpRbUp3cXpyekFHd1dKL0hHVkIzb3l5ZGFOaklvZ25rckprUFBXUkw0YnpZRWZxVmZUYnBRMHNWa0o0ZVkzdUswTitzSlVDbVRFaWNJdTQ3cEVpaEpnZEIwM0FTUTdLOXIyVWtydmJYdld3SUlmVU10NWtmcGRmUGlMYlNmdkhTekVRaUZRT3RHM3lXUUNwb1IvM0JlYkFCV1hTSCtLaXU2S3Vtb3dmMnNYMmZneWwyYk1aWTNaUGJvbHNxTTNXbnF2cjJXYVZxd0pmUGI2anozaGZaQ1lVdm0wcW9pUkFjMnFOQ2xORWpta2RkajJWVWN3SzZCRXBBRDgzdjlUWnBkY3daT0g5a3JMeXRFdTY4UHJBTmVkazUwck1tQUVENEI0QWtJOVJkQVdOTVQxRk9QODhtQmFhVVR5bmk3S3NmNnJLUmpEOERKWHBzK2daT2VkdlhGWFVvLzZBb2RRNHBLLyt5ZU9aUHo1TWUwL2FqSnU0SDFwUHVtN0dvc2Y1ME0zUy9aNE9la0JYdXFOSlRYbndVT3p2dzloeVY0ZVN6eW9VSE01WlhzNjJMOWo0VHJ0TUY4L1NQRGxuUStIZ0dJaU9lVkNKNnlVd1lBcUpWUTh6dC9rdmJWdnFPMnk4QTBJOHRuMTRWeGNEZ2kzL0VVbkpnTjhiRURLVFh0dGJtbUJrWVpxWnpodGoxdGJBbGRQTHBycUF1RHhyaTYvSkswcjhwc3g0a0xER2M4c2ozTEkydFhmckpwSG5FZ1FuMlNtU0RNWCtwTmlENGdKKy9LbHlELzJrUE5pNExEL3V5SStsMXlRMzZxVVJieThwK1VwMlpWcUNQOG1oYzFNRkpUSHZBK0QyTE80NXdJMi9aa3BQblZNaEhNamFSNStlWnhxODExMi9lWW9qcnF3U2dXeWdLSVlVclFGdFkyUUJKUXNtN2piYTZwQnlaWXA4OEFYdUVyT0VIeVc0K3hDK004SWhQQUpGMjgzeFY1YTNNNzRLYVI5b25oN21Cdy94SGdSNFpFb2RvREJwVUJwTnNCZXBJK0FhMVJjMis1UTE0WUFiemJYMmZ5QWwyeWIvWmQ4dFhkelVLRjNWQzNXc2h6ZmRyTWVBU3lFWkhPTlpINDZ0bnZQOVU3SVRTRFJXUkRtYjYvVTA1M2ZoakY1NFl3L3h1UEthU1JqVnI5WG5kdHR3ZDFnckIvOUFRU3hrU0dOUUdBdGF0ZWVwR3NSaFBYU3hFSElpdkg5bndRN2hUdnlpTzFGN3dLYWpQbXNkSldXWnJRUFNNWUxlVUJuazBOdDBvYXNLOFlmNmM5WWN1YmN0TkR5THA4RjdacWd2d2llZVUxdldLR0FtWTFoakZWY0tvSFNHTEdBOVdMZGxlZFp2SURzRit5dFJybVROdGtPajBMejhqSldkNjN6akhOREZkS0hVY1hxWUhNN252SDdNaitvZDhCb3NVQnVBOERtanpYU2k2S0xZeXJ1bUg0QUxTUzRUcWkzMVN4RlNjemk1eDFnVkRPcTlKeGNockhqZEpOTTB4WWsrWnhjdjNvT252dUdGNmZScU90ZDJEV0Z6YWorcU55eHZiRDcxM3lIZjFKZEkweHVUVmpFUytlMWZlUjlTbzI1b1RtVDBDc0FWVmxTb2U1MWVqTHR2Rll0Tk1kWTRBdmNYNncwbjh5dkZYRk9qOTBkSlR0cGZVOHpDOHA0d0pvelhLbGVReStZemlYZUdVM1Z1R2VEZVZrVy9tbElaOEhNUmRoMk54VThpRkJudlJDMm1tNkRJQ3VkczA0cHNwQUpBY3NqKzJVSlVtejNwUnF5KzhXQmd2Ym43RUYxMS9pUVZ4N244UWcxS3hZb251QjFSeG5nTUNBbGM4ejNRVkFJL2tQR29QN09rSGZXQVFBeGV6Nm9LeEk1NWZzSnk2c1V3UTNQQjV1ZEhBK1d1K1R0WUNTSk1qTVN4bDdFWnV2bkFyUXJRR1QzK25YcEd1N1daN2tjd1ZZcmd6MUZ2UE5sUDdTYmJMOEl3T3JZWTBaSmRmRysxdXo0R1pLVy82YzFQZTRtZlJFVlpnQnZWcWYvRUQvVU9jSVlHY0lBT0JkSUNKRHNrQTBzdG1zYXBUVmRQOE43dk5GMGpmZytNOHlJL1BuNXBVNHozUU9JcEhNbEphYXVMTG1qS0JsN3gxTmRXUitSaUJucjdmaFdicFh3R2hGRnZPeWJkU0I1U3ZsR1YwVHY4eTdrbjk4ZnBTOFRac3RiZmtqa2hrdkVyVWhaanZDOXEwNzRVUEU3S2d1dE9XczdHNHNDRU9ML3Nya3dpc1RFRjl1eWdQSWpWZ0FZc3F6WWVhUHpMRlExSGRBYVZDR3ZxRFlGTnh5MXJhSExBS2FIbzVBeDI3Tk1pckU2cGhsTmUzZ2Zpa0I2Y3UwZklkdWQrYVE3N1ROUTJSc295N0REVXBiL3BCRTg3UmlDWC9KVm5WbnVNU2E5WWpVVm5Rb0MzdnZUWGx6Tmh5WHZmSkdZL2NzcldDdHZkYWFQMjFZczJBeU9Ca1c1YXlNS2VCUVg2amJGN09ORkY5Z1B0MXR6eDdOZ05TcWtzNEFMV05NTWMyYXJNUFNaS2drUDFkYzgxKzkzNnZ4bXlsdCtldlNzU2JXRmF5QzBNdzExZjN5QW1PQ3BuY0x5RzU3NGdBaFd4N2wrZ29YamtmcFp6WDZJc2FVS1lSWldHMGtBdEpOQnRXc0U0Q3NsM2V4ZmxVeXdJcG1QWjV6dXFzNEtXTzZlL0prc2JDcDJlQ09pbWFtVHBoWDgyVjM5eTFiZnJ0VVBTT09DZ0QybFdUZ1ViQ3lmNkQ2VkxZbmFxcHFNR2krVWM2MDlPMGZDcHhYSjJFOCtqc0JIS2NFTXg0VzVhdkFLY3FjWGJqV3NlYkI5SUxWOHI5aW1zdXUvNFI4RVpPNll1cmJzdVV2aWxXZmJGM1NENE1rR3l5M0pUbmd2bmZWdGtPV2diWFAzdWZSSDEreEU4M1NmbVRuaDNPWnA1NFpxcVprVW5YMERDSy9VMUdaZTJkZ3BVbFd5NGdtNmJ2MU9ybitzd09veG5wdXVjOEdveTMvcWtRRUlxTlQyalNKV3FUNHR3R1luVi9xdjhka05lc1pBTDBqSHpYbGRhYlBMalM1SU5aYUhSQ1lJZG5kdjd0dGdNeTE4VGJEdVpzb3E1cnhMdVYzTmhhWkpiMVJBUzhEd29lVS9rdlpiZ0Rhc2dVQWdyS3RBS08vbVNhMmFwU0JTNTBpaUw4ZHVHQk4vOVFiK0JGZ1dwa0VzeEw1alh3TW8yakxRUU1rTWkwS0JlcTJSRmtKUXBQWnowWXZsMTZDTG9ESE5NMmI1cmtsOEZpOHg2Y1owRnV5QVdmTGx2ZkVhOVcyU1FFYjhJalhNMEZ6Z05BUmZkaWlLTXZ6MDIvb3gvYktreXJnNE5pbUxTRUhJWTl0ZzR6cXlGamh2RURiNkpNL2JLOWZOTzBNclpCUXAzQitGZzhYUU8xTVBvRUdQMDJKLzdUeWJObnkxNlhxTytjQVFSSmFEeW9wb2paMXhNcVlOU3NVSkhpUzFjSUIySmhaRldqYTFmNWVrUlV0K01YZlk1SXpVeFdDdG1xWlc0d0FlYXQyQktBQ2RXZUgwdHdlc1JnV2RiVDgxSzNFdFBDdzJVYW12UmtJWFNXejd6aGhKRHlhd3Ztd1RHZmx1bE0yRUczWjh1TkVIUnJZTm1jSDcrUTNjcFYzV0pidVdNM1lRbkNvL1ZhMDNGVk4rTjhMMTF5U25MdUlaenhDNDBmV1JOZE1kalZOeFduZDEwblRzTWU5WTBvR3BMcVNaS1hUSW5HUTVEZkQ5UlFoa2pRNGlGOXA3aDdBM1M0TExvc0JpRTZISmliL3Q1Nytkd1BqbGkxYkFLQi81VHp1QUFEbzU5UmRVZ1V4ZTVGZnUvUlJrRWprdjd2dUc3MDJNb09aRFNkVVowWlZ1SFhMOWdwRWRkdU1COFRkSFRvQUEvS05pbURTeDE4WW5JTVpVZUNDMGsvaXVncG40RFppYWFON1lZaWJHVmF6T2szdWdRRG5tOEpPTXpxUnM3dzNjRzNaY3JjZ0FJaDNYUlhEaU9RekdGVFR5RGVaVUtaRzBsZjJiSkQrR2ZuaUxZbHFxd1RyWlRYZklYclEwZm1rQnp2Zm9acjlVRDMweE9KNXRGdlkzWFNkOGx0bFVCRU1zalJaOEtxaVRkSXRtUjFIY045bGNwTFhpSFdOeExSSjJqOWZaVXlyczVlZkJMQXJMOXlrSEJ0anQvd1VVZFVYdEN5UlVWRnRNTytIdEpZQThObFhVeVdXbDRIcEtvN21NemR0T1ZjREpHRkxQSjNFczNqcUdVNEloSFhLcnRKU2NZQ0FZTkxMZnZzU25MZDZCaVFYQU9zMG5wS29GZERrc080aEdGWTJaWDVuQUJ6VFplV0VBZXM2QTdOWnVVYjNmMFh1SE9rTmg1UXNHNTIyL0FTeDVyZW1YWnU1VHRnVHRMMzBkTzdlcHZrZXBpUnlDa3kyZURQd25LblNXTVZhL3pxWDArYUxLdUJVTDVLaUpybmFYakxmeEI4T3BBTUFDN1N2aFJ5NkdXRzdjd0pHdzArRFo3V2RwS1VrYkpqbldSeUZXODd5VEo1QXl0UkNHQ1poTHErVmViQVRBRXJURHNBc1h1K3llSFZPN3FwY2ZlbXVBT2dHcVMxZkxlWmRqRWFqeklpVWpkVUh4aHh5SjE4RFdLZnU0aUlqY0pvWlpLeTVMazZsaVZ0RGl5OUFERGdBNWlabS9WTDlJaXh2TThoc3FYNnIvcUZmWVZRWXAvNGZBQUFnQUVsRVFWUWJxOHVFek0rSVBVMlUveElBdlFoeUFBbTRKT2NJb0FiaW9lbHZjSjRDNmFoc0VwWXhuZ3lzQnZrczJRRmtqdEFHQlFXUFhTRXVTTGp1TGJ4QVg3YXArWFhXdGx1MmZGQTYzTEFlZUpMQW5vTytob2pOM0NkVVlQVHgwaGk2TXFOc01lUk1QajdIRkZtVDdPQWtyQW5aQTY3K2k4cVd0Q0ptL29tb2doSkJjVis3SmZOSmRWazhCcHFyTGNuZ09CM3NqdEtQd2w0QnMrVCtvL3NTbVBuTUZqNnVvemxQR0ZOUHRMSXVtREdla0k4NnNVUWd5OWpZaXFJT1RDNjlKTHhVSjBudUcrR1pzcmxoSktSdC9HMEcraTFiUmwxUFFRaWFLYzlRcWppaytxNGUvREZnRWxVMTFoc05yaHBveWR4UlllYzRaSFlrYTV1SUdSTUIwV0dVY2dNbE5JMnNvd0pSR29vQndRR0RUcjZNZW5hZUtpVkJrakU0ekJuTkdqQlNHaCt1MVNLTUZMckpaVmJPRUdZdDJYMVNmNDArNVNGdzJmTXoxb3A1Y0Njek0rTXJNakV6U3VOMTdiZkJhY3RQa2ZoT2V1S1FwWEhoOU02N2MwMHNNTDMwQm5YTWNaS21aMDNJRGc0V3lBcXpIbFo1T2lJdkNrWUVaT2FZNmgzSXpDODF1T083Ti9wbFV2Z1NSbjBxK2ZwQmUyUVZKOENDY1lSOWhXVXRNS0dWWTFmdjltL0tqdEp5anUrdFM3N0NmZEswWGY0TjF1cUJ0cmpHckN2NGpLblkzejd1U2tmMzBHa1hHbElYVzRPdWxIM0xsanZrT21qb1FOU29pcWhGcFkrTFJmMzJ6OTBOSkRLbVc5OGd6NXI2ckxVUkNOM3lvY2FlcU0wZHFjbVB3Y0hRVUFtcmVRd0FpbHFZdlhzSE9oaGlYWkZqK2R0NXIrN005dkZwcmZ2OGNyUGNJcGgxWC8vbDN4Rm9kbVdiZzFxYVRrWVYwL3ZBdEh3SzlXcCtEUXdzV2dnNzRibzRnR3pBMUhmbWtYa3czcUVmUStyTEthR0U1cmtiZ05yZ3RPVzdKS29OU3Y0NHZFNm45RHBRdm1MYnVxenQzejc3VC9YcUwxdkg1UEczTm9FMTRvay9PSms0MGpQeHp2TkFSTWJKb2JaZk9EZi90cEc1RDRkd2xDdlk3Qm9Bd01DZ2lNd0RPMVArOGR5bzQxU0pTekFsZ0NHOTZ3eG9ZajFIQUVSOW1sR2VUc2owMy9DR1VIYnRLRC9UVSt5QUFuMEtuOVptSTNBUlRYNFJmR2FqVEJ1WDlBOEdIdG0vcEVVYW9PN0FhY3VXVDRnZFRWL3A0eTJGdnBGc0JWbnB0VDFjM1NlWHZmS3V4a204QnlQWkRMQ0JrNkMzSGZES2wwR2lSd2x3YVAyL3NhVk0wVm0vRXYwaXJwYXJOK3FsTElFTDVrMDRWdGNhOElESTBscEozR0IrcHZDN2ZDMkF1QnYzYWZqWHQwY0NOTFljUXdBYUFOZk1SYjNiVUhkY1JnK1kwZUp0WHhjemVJRTRIemg2UFJDOFRmejZDNXZtNmVxWmpTcXpBVWx5L1pZdHQ0Z2ZmS2syRlpBaXFPK0IrMjNwNDIvYi9OWG9ZL0M5dW9CL00yTTh3cnlucjd4NXk0ekp2djRaRDhoZSsxaXdDRTcyWEVJSW1rN1RIUjhDeU5pNUpUbjNOMnY1QTFBeVp4Y0JxWjNaYjVQNEpCUlRkbmwyOGM0TTVjSHMxSnN1WXg0SkVQYXU4Zlc0ZlU2NWo0c0FPd1ZKS2ZTSUNZMnV5KzRmeTBvMi82eUg1YjNJejFkeHFMY0lBb0JzQk56TzgrTVZzZVhwcGJHbXJNd2JqTFo4UWtKZnBCZ1d6ZGg5K3JOZWVhWG4zczJjTHBueVp1Q1VwUjFkSjhyRm0yTmFTazF2R2creFhXZlRVeml5U2xldnBUNE1rblJhaG1nQm1pamhhVHlaZUdlR3N0ZjM1YTQvRStDeUNwNWkvR2c0MUs3enpIRUdjaWFPa3JCaHU5amZPSllhS0crM2xSUk1lcnAvL2dyN3c4NjRBRTdkUzgyQkRvd1IrdnR5K3lNQ2tRVW5VNmRQMlRxMi9HTXk2VWoyMjBuNlRRc05NRzhWdWo5aFJUNytYR1lhNEM3NWIza2ZUNVpaOHJPcy9HdGRYMkpQQzdFNzYwZXEwY1JUMDJEbjFVV2RHb25OMkhJNWh5c1BKajUvTU9meTRjaGFwZ1J3elBXdEJoUnFOQUNCanJWa2FSZkJKY3NyZ2svM2Zhc2NGUG95eFdmRWFZbnl1R3czOTlNZXo5ZU1PcDBEbXd5UUZucHJXb1pRZjNtNzNXRHJYVVBHbG45YkZ2cUk2ZDhPV0hSTUxBREZ2OUdjSjJuTWdFdWl6UGJhWGFsczd4ZmRuYnk5cmhhWkJqK1RXNTBmUmdXTThWR2QrZGZZczZIK0t5RGViVUt1aVNZNDZ1NENkV1RibFZHVVNwTStWVndCM1NhOHladzM4c0x4NU9QN1dnTTdjSGdYNUw2R290ajl0WE0yZ2tIaGh6aWJWN2RWazdDQk02WVRSZUxOazA2M2dScUFVTVMrcy9xMUJwNlVKenUvOHBxTTZyOXdmMDErMW01L1NhNnFvS3Q1L3FTODdzNXZiYURWOXlTK1NKaVRzaWFzVzc5Qlhad1QvM3hHUWd2c1JNdjZtNStYNjNYNTR0M0ZtMWpXbEkzSDdVTVl3VWJrVFZtWUd3RzBmMHc2ODNrc0dRQ2JuT0lJdU9YWHgvczhMZFRHYzlzUThWcGZCa3d2YWlXWkN0bUQwTVhRMUtzRElPalRPNkF6OSs0QXpyYTgvRXp5ZGVVQTBFOWxRcnd1a1RPdnQvRGkrZDk0ZkVYTWZUR2MveE55dDNMZkFnQnRUQWNBdG8ySFFHVFArVDBqYUY5Zm9QRGJtRlA5SThPa2lBQ0lzTE9vNjdWSlFUN1o0Ly83Nms1bVdaTUZweGp2cjBrZGNzRkNTRkRqSFVEWjNETHdBcURnSmhsWElUWGkyOE1sMXdSZGJud1BDMkhVL2R1WExpc2JtZzFxd2FRZ2YzcEYzSTN5VnUvWlNRSmdLY0JCZnkyQUFSSVQxbDJUMVc4QWpsTTI4Z1VqWTRSUS9saWVYdzVZT0R5NWN1SDNTdWY1OUFYOTRxSTBMRm9wcXdVSnErOGtIQUd3ZURDQ0FrVHlaMEFKQ2w5WG9HMTVnSEN3cGlQemkvYmVvVnlmZU5xM002YUZjZnowT2dLZlJ3eno0M1hQbnNhS1BuTzBzT3JEQTQwL1YyZ0luTWhmQVNDZWNEM29PQjZCdmw2K1JMSGNqWXYxOVNQLzJ6a25oTi9oeHJaV2NVN3l3RkU4aHZNc3pTamY3QmduYWM2dUQ1TGlRcnpIckxlT3lqWktjMUtlM3laQitmVXlpUlAyZTRmY2xNLzVrM25sUG5lcTVRa3dSU0JDYzY3Z0c1bFMwZlBHZk9wRzJBSTQvcS9tZ1lCd0VEQkllUjBzUmZuMGtPdGJUSGs1eU9UZ2xLbUcyWFVBV1ZmQkpDNXlJWHZVVDJSSGVKb3hNdnV2WjFtZ1FOREtITGRRaW1XajRScXR1ZEpmQVpVcjF3M1NkT3VXSnI4cGVKNkVqVnpNM1RXWjJMalFZOXpXL1N1dkY3Y0YyVFloYzJrOXgybDZtL1lITVlxcFRFYnNJalFJQjk4aTk1ZmpycnplemZ2R3NqbUFNY0ZkR1BLM1VWdDYwdXNSd00weFZSQUNZVXhRR2xBbFpyM3NqWndXR2VZZzlTcDRMUyt3dFJLYkw5NTgxSjJqcXFpL1BSc29KdC93T0RTUEFyMDBFQmhmMytLOCswSzh4M2tYSVhPTmdFMFdiMDJDNU5MWGVzVGRJc3k5c0wvR2c5Z1pNRVZsZmc1V0dZam1YVlVBaVk5cFZJYWtUS043YTJNdmxxODdqakxvb1Yzd2hBblpjcWdwc205amwwUHNoTDlTVGhRNDlXRVUwdmFPUzNlVjVlcWxpUmE0N2JuY0NHdzRXSHZVOVZPalBTbWU4NWZBeVRBanFzQlVQNmhxL3hxQTZUY2ZxRGxCNkhwU0FQbllFQjgzSFhtbDlqSHRiSWoyRW1NNkcvTmw4YkVmakpYLzJyMVd3ak5tSmVFamhoVkhBUDA2STV0VFN5RVdXWHR1VTlnNEcyOTMxUE8rZjNZYkpvN0RMUDh6a0JvY205RStYdnJ5NzVVNFVlamorQTRJM2Q1N0kwQmExU28yM1l2ak9vcnhHU2had1ArMVNHUmtBa3BHRVdadnhuZ29lR2Q1RnRQYkxxOVJLMW9ubC96SjNsakgyWHdZUmhEeTE2aHRoa0FCU2I3S1FBSlNkbzRKYXBobFVNMUpMR08vZlczUGNHQW1aMi9KbDVyeXpsUURodU9ZUG9MR1NQd25DS1BDNy9PUERVenVXZ21iS1VjUEZnZzllRmp3aWlEVWJ6d3J0ZWp2MTJhNkZzQm5jdXpZeVJtd25QNmV4Qm5tMVRHZVZkRHFudm81QU54SFhQSjZkdVd6UTh4cEcvMWttWUZTQmtpWVhQYTY4dStrVThhRHNnMmx0MjkwMTcvMVdPNWpUSVMyUEJHQVdoaDFKai81U2tOalBjcVVvTGc1cHdoU2J1Nko3M0ZJbnRBY0gyUWhybDNqbEEzNDcrcmhMd0hUWFdPRWQyV0cyRFpPWm9iV3dTbFhsdm4zSEh2d0FmTTdpbzl4N2FINmRKRnR0V09yR0RNUU9qdlA2cHJWK3dvb3RlTysvb05ydzV6UmpKbDJ4MmNkMGVKZjExdHlMcHhsRVB0RkQwZ0E4NzBCZjZ0a29KU0JEb2Fxb3J2bTBuMFc0dnRXdlFKY09BZy96eTk5bWpkK293aHQyU2krRGFiZEdVQmFiNnhoaHdHWkJqWUNWdFVEVDhEcUVITWVZTDJPUEtpNVYzU3gvTmVIam1PNURFejNndEp2ZlhIZlpSaTlFcU1MNlQxclNvREhmcG5TTVJLVGpxQy83aVdRc21Pb1Nia0hPNmIzeDNFY1pvNHhoa2NKNEpObEJURjZ2UTkyNnRHeVRqTEhhYjYvb2E5bmloREdvSlNaeGF5aVhuSi81c3VXeXBWY1Q2Tjg4M3RuQzB0UGI3c2VzU2o5RU5pSDk4ekp0VDJERm1xNEJhczJYeVJBWTMrZE13U2ZXeGR4ejVaQTc5R09XOUh1WkVoQjhDT212UFhIMXFyMldSWjJuMy9RSy9mMnYxVjZBME0wMFkzeWtkTUlTR0RPTFNobGdETUNuVVZnTW1BM1pwbDhqREUrcWN0cUhJWHo5S0hHZG9vbnIvWUVjMjBLa0xNNi9HWVpNU1ZyWHNwTlVOWW5kZlUrd3pqMzZNYUE1OTcwRHJUWU1jQUlEUmxQQkxCeHNtc3lBV2VLN2VXUFZWTnl2UTd6TE1nOEM3dkZkWnM3c214SjJKUnhKNGUyTUxlTnM5ckdCUEhOeVo3QXJMa3VOQk1DM0RESGRPVVZuS25jck5KbmVaOTA1V0grVis1eFJmdzllekJjSGFFUHV5Wkp6cGx4STJOUHN6UXhiSFRPdngzemluVVJFRnBoUnRtNWhNVW5sd25Ob3o4aUVTRFRrK1I4RlBaN3hPN1lYbitzQXJVQTFYN3JrNXdCMHlBOFpUTU4rRVp2VlkwZnNUVjdmZlRuelZqWXVocTkzeVcrTDdlQXAvMHVBOFZ6TjBpdzdMQUJHSkVzcUszbU8xUlFLb0FVRjlZMnNHbHJtZXl6OVhKM0Q3KzhpU3RBMzNSWm9VYmttcEkwbzdTU1B0N1A1ak1yU3pMRzYrTFBxaCs3OFdqTUhmTXVJY1J5d3pKNGpMSDcrWHY1RHl1ZWxidjUvdzMrRkVRU1VLSndEZ0E5UTVOOE1LU0JrQ1l2WFJxMndvQ1c0MFErOFFxdGdzOXZBcVR4ZU5odjZtbVpoSDJ6UlBtamlSbTlZVmZBU3BUbHBLd0pNNHBnS2UrZU1xYU8zYzNLTlJaOGU0NnBCOVBxalpzQWxHaUFZRnJWWDNIMWxvRURoWGtvODZmdTRiem1pVkNBcWlZcDBtYUVVTkRySWp1b2ovb1lRbHlvWVJjM2tpOHo1WTFBWTNiOXFBTG5vRFRmN2llNy80eFZqZTRaeTVySDE1TGwyeEJGaUkwTGZDMDBrd25QN2hSck16N04wNjh5cVFWMk5ienhDY2dNbzk5UjhKOEVyM2RCODZmTGpJMEVVREtLdnZYUUNFd25nTlFCbmdTUDh1bC9WUkVuTEs0eWkxaytnM0pONUJJdUpXelE2NDNXRG5FelZVbEZBQkM5OHF5WjlaQjZrNlEzYWZnNllVYk5iWnpCbis4N2N4dlBxako3eTE5OXM3NWw1NGNWVU1yU1JUV2VoVitKRTE0UngyU3ZBTkpaZWV0NUJKcDJsZlVhbTROU2R1Y296Y1h6UE8yWlJBQ0tZUmppWHdXbWxmZ3IxN3lzTWQ1TTl4Y0F5VXRueW5QbkhxRGlncy96TjlxZloyK2hMQmoxNFZGeFovZHNURUp6d2hpMlVxNTNlOWtnRmNYREJpSnQ1VUVFSVQ2bU9NdzE1ajB5NTdxYmc5Rnk1QUdybXZFQ0tFRjhvL002UkIwM2t5dHZ4dTNBdE1LV1ZpUXltQXlVenRqS09DNEhJZnZvWjNsT0FZYy9HRWRBVEtrdHlOaXJXK2tSd0x4NEZuekNmVkZLdHZJNm5QSFR4U2RDOFNRRG15dXM2WVV5dkhUZGFqdGR1ZGNGbHZxcjVJeU54UGcrekUvY3J3QVQ5b0EzS1F1bGVUWm1rTEdIT1dNU2tKMlpDYzlsN0R4eGNsMTNONjRMbW0yQnlLZklnSnZVckZmMTBBSCttaVBVazF5YmdwbGJBZzlLNlpvMVgvWlp2ZDZWQ0V5WDg3MXpER21CSmdPbE02REs3bmpXYmVLNm9wNUJrVXVuUENHcFZPUU9TRFkwbEJpOVNZN1FBbFFHWWg3TXVwcDE3TWgvbEw2VDRRdjFWUXIybmZ2Y0FUZ3I4aTh3cEJsemlBb3lCeWxuYWdzYml2WU1aM1RQK051T3EvZFlUR09CeUFLVlQ5T3pxZ1NzWWxrbWp6Ukc0WnNiekJLQU1ody9YWXNtallVdlg5Nm1DY1FVMTlJSUVMVnNJeGdMa1BuaDhDcll4Z0Y2RnYrcVdHQjYrdzFiWXhkVytxNXFWVzd1QkhBR1NuMTR1ejYvWHorT2FPbnJpNW1iL0ZwWjhuS094QUpReXplclZRQ2xkUFBSV1F0bnJiVHltTTlxY1ljeWp2WDRLcm5TRmtrWmZ6c09xV0I0ekFrZ3FLS1AvUUdUUHdocFcxd1BEdEF4SFY4bXZrNFZ0Z0dpQ2ZENWUzbVFjdUZKZWZ4d2JpeXhSM1JmbzVsZU5SY1BSdTA2MVB2MFFFSW1yV2lISTE0TG9HMlJnWlZxR2JPSmF3ZG1XWG1YYXZXYVhON0VkWlorQlNUYWcrM1hOUk5BNnJGbXgwZDlXQTVjUUMxMUNkZjJlZmVzU1k3emNVdVd4bzlqTEZPSjhkREZlUkFlU3daQ0dWaVorUFE3VGpCL2tFdUtPR2F3d3V5eXpES2xkNWVjNVRXTEh3K25mcmVZdWxBU1prRXBCUkgvMTV2T0draXAxNWZFSi9ORTNUMVRVOXNKNEFWQTdOTzNjRkhYT2hlbXIxU05FY1hmdDBzdjJSdndxbmhXMVA2MUZoZ0xJaGl1QWVyQlJNRVQ0ckRYZzFZQjJUV2lTdHVrMWRmUURuT2pKc3JrbmJmbTBoelQ3RUZraGNqVWFMMHVBNlY4T3hwc2gxMjRmVWcyakVMWHpNUSt1c2lvSWxnSUVKRUppK2s5VkdVTFQ3dUtnSFF0My9seUFNdmp6Z1VSZ2RhR2RYSkZmNXBlZnNaWk0xQmE2YXFmQkthVjEybkdNclByVi9MOGJya3laSXdLWCtJeVFFb0F3NEZFU1poUkE1eTJtM1lTQjNrK0dSQlNPRzk1QklBRnZ5aVZFK2l4Vjdqbi9YRGxxYy9TV0NocXVqRU12Nm5QNHhpVUxhNC9rdnk4K2Mra1R6NXpZVUhSaDhWN3JZVmRGTDNWUjczeWN1QTZBNlgySkxKOTViSjhySElmUFRJSWNUM0krUHRaZ012S2dzQmtCUDBlZGpXWlZzRGR2MlV4Z0tGMFoycHpiYnJoS1lIN0huSm9nSE5RR2cwMzBDZEpzN2tUUk83SU13T2lsZnd6Rm1yRE13VSt1dVlueVBtUXJELy8vKzM5Nlpya29LNDBqSWF3TTZ0NjdaL25Bczc5WCtDNzkrcE1nNzRmU0NBd2VNak1HcHQ0dWpwdFBFOEVJUWxoSzNJMHlLRkhTcGFRVUt4RHFQYWhHUWQwdlNacDJTK3V2KzgxSWRiTDZ4b2kvdmI2WkRIYWxYZlpCTjNIMGJlM0pLRDI4ZHBmNXZvSXRSS3FpYVpzMTFQejJMVXFLOC9tVTk3dTRzTG1SK3VCUGJXMHYxVzhCZWtCMk02WlpCOFB0OWZYZWVFQ0twNUE4ZW8xamx5MnZhd3VxajlUbmViaWNjczZoa2hTVHlVcXR5dTJxWW1xaVE0NVViMk92VjlzeXVxL0xkU3ZiVTNkcG16MWtEK3FNajVLSmtmMnNiZmRsaEpxcld2WGE5MDdYbTl5RnFlL3h5TWJiSk1SWUZ2Ykp3a3B2UjltblZVeVVkay9WZnRzRUJOWDI1QnN0K1ZiMG4xenRXK3l4Mjc4QXNnWnZhdjcwYnRqTmZvVi9GRzBpYWoxSlhaSmlldm1WRjR2MUJ0UTZ4ekovRi91dS9jMTdsMTNtMVNQNDdCaWVwQy96TFlOVXRFVmJJdS9hTHR3V2pmK1cvdDUwbU0xVjc0bW83S05WYllvMXIwQldub20rWUE0SDN0OWxFcjVyVTVrUXhGMXNiR05FbEtSY1NIL3RiTS9OUGF6cVlaNnIyZTFHZ2c1T01OdTAxSWR2WDNzck5mZnFMT3MzUXBlTlJqczlPb2FHT1gxMVBmbHhlUzh1N3RIaUtndXErK1B0Z1FKS0NMZzlnaXBJcDZLa05yS3BpYVk4dXNzbFZacnZ5ajJIVC9IT0UxcFgza2QyMFJrczl6NldWcjM3TlZOcmhZWjlJaW9XTDl4SXJWWG0xQVMwTTRYbTQ2K2JtcjNtNm5OYyt2dSs5ejZMUndpcHEwRG5TR3NWWVhBWEx3eXhTM25QTThvK2llM0NZa3NnYTAvRzF1OWxJOFZabzBhdlByZmx0ZjdZYk1Yc3VkV1gvZHVXYXVZVWNwQzNYOU5PaXptTzBZenMzamFadWY0VGRUdE9OcGVuQXAzanNGMjQvMVA2dWp5WHVLbStzbm50WStRVGF0dHlJM3BWK0xSZTdKRlJsb201YW55ZDhodnRpRXBzbCtVSVo2R09sb1JWemVFZTAxSVZDMW5sakJxbVU3S3FFRkdYTzNmZnFWNWJiTXNQZTcxL1R2eUZJOFF3TjcyNWZUeHZmWGV1TEpKZVB5NnRvNzhTTlA1V1J5S3l0dGE1OWdudytzeXRxOFBDK0V3cU1qSnBvU1VLOVQ2dFZOS3NlNFpPMXo1NW5sVWxUU2wveXlwN0VYajVkS2FlRmRFWE9ETTQxUWlyNGhwOVZ2ZTA3V1NzdnRDdnRidS9ucW5TZFc2ZWw1SEtzaU4xUUNzc3hNZTJGK25YRnZlMis5QzV4NFZLcjdHRVFKN0JjNFF6dDR5dWVwV09xR0NWQ1RqZEpOY3lyK1ViNjIzcjRiNkF2SnpzZVJScHNISis4ekRoQ09kUjZZYVlLM0s4bS81UDVsWDJrU3BGWStRR2xPdncxNDl1dGNjNnAxZC9aUjFQdzdsUHJrcW8wN1pzM2pGUGo0azg4UDI1OHFwM20rVGtvd3N6NXlXeHpnVTlTZmxDc05HMzVVbXVGWjFWSmJWVSttVjVyejN2SWF0c05hbDZ5cytTMFQ3RlJ3RDFmQTJQU0twS3RoRVB1WVlPb1I1TlVoZmY5ODlXSUpxVFhldzJxMVpmM1BvNjRQRUovdlpWMHo1T3NzRzBkWlc5WFhXSlBVS3dqcHhuUWVJcVNBUDF2TEdIeEhTc053YmZ5VVpDUGx3M2tjK2RrMTZiZk5lbVJtN25HNFJUNy9NWERjckFTSXRiOVVJTGJ5cXVYRzBncTZheHMzbDUvZDFyUHk3UW9ucFE4NjdiSm5HNmZ3YUdWSmlobVpyQW9LUVVpWW9JR1JDWWlVeVN6UzlvU0JRbGZRSmd4dGwyOVBWZktPU1gxc0lHc2ZmdlBQdHR2NDJpYlNJcXJHdkt0aGsrN2lOZmF4YW1xMDJWK3ZpcW9PdG5NL3JpblZ6KzFXWnR0YnR2bnZuWk40ZjhkZmx4bEZqOVhiQmkvRVkrYlRtWTFDQWx2VUl3L3pKZUQxeDNzR2E3OW9LYXIyL09pOWRrMFE0Wi9sdSs1ZUEvSFZUTlYzK0ZwVzZFRnorU2g0aG82TVU4QnBsOE1qYmRIU2JJK3U5NGhvK0FqTk8zcHU5bFhkM1Zxa2xScW1Nd0NHU1VxR2VOTVdnZUhFNGpUQ1NkbW8veDk1WmxkVlRIWXloNjlVdDNnZElLcEZDNDFTZXFkaTROOU9aSm5zZTFYRTMrV05QOGZVSXAwZWtyWFYxVit2S3B2Mjd0ZC9PZkdHMnNtQnpUL1NaQjEwQ2lsME84NjdZYkZjYzc3Tkpxa2RJRlJuWnNrNDJocXh1U3RNZEdjV1VSanZkK09QV2ZxVnNIVWxYa3MvYURHakpaUHQ5NEhSdCtSNlFiTCtLUk51b2Z0YzF3NUd0bnNjWmN2bW84L2pJZlQrTHAweDVyYyttMVc0dWw1ZXZIZ3NCRVFJNGtWSUE3QzhZeEtFa3NjcjBrbTl5bnpCYXFxaGV1ajd2TFhVaWN4MlRXRHVOMWhPVldkcmhRZUpJcDd1bFhMaWM3YUp6VE40NnA5NHh6WFN0YXBqV1pkMFQzQ0lrTkVoUFlaK2ovcW1sUFRUR3c5SDcrZEdFdEhXOXZYdFNtU3hYcGpRN1hmMlpnZU9TVXFKRzJZcU0xaVMwUDYra2xGVlNpNERXdlJ6TmI1Rll0TFh0TWVWelpKMlByckNMOXM0T2FnSTV1dTJaWTN3M25DS21aeTZ5MVpuVkVrMHk1eVZTOHJBS2lvV2NDcFZseUltS0RJaGJaN3RkcWJmSWEzdDZZNTYzWG8xSDdtYnZjK21kZGY4WXE1eGdSNlJ1YzBkYjZoQ2RVKzZRRXBTVWpoQlRieG1aMWxFdmtLSjZMbHd2YTZ6VHhhcysvOTZ6M2JvWERWTVoxOXUwLzVnczZXVHpIZXQ4OGhsMWdpR2FSR1RQS2I1ajY1NkJkUWkzZlJQTk5UWWJGZVYwdXhIOEdrbzU5a1RMdGM0ZXVkSDA2YTV6Vk4zMDNzWjFlVG13em5mRExqR2RPZWt0dFFSQVdxSnhUUWF5d3ptUlVteXhncjBRbEJlbGxBa3JFNVFlVVlqTnRNWGl6ZTVWUER1a1FvMWxLMU5PYTc3eE9xd2E2czlWWUQxbmZ2ZjRtNkRYdkpHYmg2WHRsNkpMQ0szZjFrNDJ5Q2w5aVJ2WHVUcDMrVXhUWHliNzZiNnlnYkdIM25XMmZwVkFXdVhWT3Rac3gyMWlLcWZWSEtmek1HUnZTSTd0UEZLRFkrMC9NdWZJY2IxMHBWdzNYZGYzb3VVem9tcWRJN0I3Zk9YVE83T3YzbFZ1RVpRbGthMDNVcGR0TDEvVDFIZFNWNXZoNG51UGU2K05WOS9JNHRWS1FRd1NFczZjQ0NpU2tSY0M4cUthZkNLd1psZzUxelN4Wis1cWx4TVQxcW1CTnVhYjZxeFZHMzlrcS9yQmZlMlJ5c0hkOUF2dGZhb3IrZXBUbzcyMjJ3bUNTcFcwVm9LckZrSmpIeVVCZlc1TGNvTmdPNlNVZlVLeVRrME9CV2tKZ1RTSnlKQVFPVkFpcnhaeFVWSlNYQi9EenFmSGJwYzFybzNyTW50OTltbFF0VFNYdDh4Y0ZudGYzZlBQK05uR1pua2VaK3JqVnUxU0UxZzluZFZzdVI4N012YVpkNysxN2l1K215OFp3YllrQWxVODJUVEh5T1FFemdURktRZ2lwRTZrS1V5Y0FCMmVvbmVzL1hLT0g3RXVXaW1jYzJUM09vWHpTTHR3dmYxK21TM2ZPTC9paTJoVkMxc3F0SE1zYm4xS0ZvelN4N1p4Ti9ha2UydmQrc3lPMlVNK0VQMW5WdlJGNGdZUkY2UlV6WGYrR0M2cXFCUXkzdkl2YWU3L3Vod25mbHZYMXNwQ2tOLzU5UzB2dDk5NjNLM0t1elYzRk1lK3dlUDc3cnpwdTh0MGVVMUl0YjZ2VGZiYVBPR2lwR3lTN1EzOVVaLy9SM3dTRHhQVGtWTzNyK1M2WmFOcUtVOW5uNUtaVGdTVjFaTU5IYmY5bWpJNnQ2cHJrdHZDTmhrVlN5c2lhei9nWng3akdXcnFmNUxyNVZ2ck5vNVpmeDI3QytyWHR6TlB5TXFLNnZYSTNOL2U1OUFxNzYxYjZ1dTE4cFdHRXRseXJ2NCtDeTNTa2VrdUtRbFdJNUUyU0drMTNsRzFMMUpTMHZMYW5JZjFOc1c1b3lxTDgrMDdtTmZUT21QOUJNc20zNXJVampYRjJ2VDJLQjdiZnUvTDFIWHF1OWdtb1ZZNUo2cXh5elB4dDJnd2IvTlZtUGNHWU54YTNGdldlZ0d5cFNZemRob25TVHZUcHR4dldSbHB4RjRtSlEyT3FDcUpacURCMFplbDlVcHpjL0crVlhydjg5aGEvOHgyait5M3QvOHRNdXJ0eDk2bkhnSDMxbW5NcHhjeFlGOFo5ZlpYbHUvZlJVTXdLWWpEbHVrODBIc2YxZ1d2SkN3cWZsSXAyOEplQTZNa0NqdlM2cnI1MUNDVmhwL0kvcDlKcTFGV25VTmR5YWsvWS8xOHl1RWZ5aVY5ckplZGZRYm4xMy8wQ3oxeVhWdGZpaTNyYmJ1K2g2WDFwcXdwTTBHRllwM2V0N2VQdmZNL2drOHo1UlhWVkdxSVZpMVJsaklXY3RKZlVVK2NWSk1vS20zVkF0WFZiNzFvMjJxS04wT3lqeDVqWjkzZEo5WFlkMUVaOVhEMEZXaTF3WHJINysyenAxNGFyeVhEdEV4YWhFWGw1bXlYdFVtblBMNVozeDRuUlphMXJrUGZuYnFCMDVoZkRUZFNuOE5YWSsrNTcxUVBkbVRrNnZVbmNKV0J1N0hyM3JIU1QyM1czbXB3TkU5amhmWVo3VHdQelhpeVV3Y2MybGRhWjJOL2dsN1RvYmRpNjJ1cWxaRTlldThNY3JuTlFOakxDRWx3RlRtMW50UCsxYjRHSDJySzYyMVhYcGg5R2V1TTJLYURiWXJZMDk5ZzFzdTdPaDluczI0L0hsbnYySzZQZkFCUFlIV3FqN1JQOXJhcFA0ZXorelBrbE1palhzK1FpUDJqK2hOcWZMbGRsU0MveVdmWUlpYWdHREtrZUtmTXUxV25lZHBONWZSQ0hLb0pPcVJQcG14bEJpVno3Ym9QSldLZ3VPZjJlcnV2UWFNUllZNlpVNGJsRm5vamQycHpyNXUzb1BPTnFWYmJYcis5YmI5K2FxMzVmRlZkdE1VYXg3RlBxVVZRcTIwb241bTk4MXk5STNsT213NTV5aDY5bDRuODFMV2R4UHc0eGZSUEJGaFhUN1NheWhYUVd1cmJpOUdicWhWQ1pjWkxBUk5iZUxiQzRPYmtMcWg4d00ramVsYk5YUjQ0anMyVHQ5V0NiTzczZ2ZlbDNuMXF1ZXBDTyszeWRJcVFyTnZQUGVYRUpRbVJRem1NUmVQRUd1OVNrNXdLa21wZDFHZmc1TDN2dkI4eFZaRGVLM04va2luZGJFd0JsSTN1algzcXRtWjZSWkoyVGEwS3Nka0ZybDkvMURYRDNseFozaVdzWXAydDVaWmVlL3M2LzI1c1BkbVdobWtweXZMTzV6VkswMm45Rk1wN2JiTnlsTnNjeC9ySm44ZUhtZkxxdHF1dE4rcVQxZ2FhNmRaVTFRMmMvNm9WVldHMVd6TW5jS2plL1lySzZKbmpkeTdHRXNOVzM2clY1bWRJYk5za2tHcTVGVUVGRkc5UE9senJXcWhhVkt1amZ2V1dLOVBlUzFmN01hdnpCc3J5RDNrM3RraTVKb0NLZ0xmZVl3NGdjdkxvTmZXU2FXWVg5OTlXV1ZHQnJqdmJBa1hxb3hSTXNXNFVhTGRPTHZkYVhHRXNYeE5OVFFhMFdxTTl2MDBpVytXOVphMTlIOEhlTzdKL3BqV3h0aHIwYmhYd2dwUzNNQTh2VW41cEd0K3NSRlQ3bUdxbFZqNnIxNy85aDRucG1RTzNMckdRcjR6R3kxbFdDdG5NbDVkeHRjNzJpWDQxcVFDUG5jTXpiZGd5ZlMwQUFDQUFTVVJCVkk4bnI3blovK2NBTmxWWVZaRnF3eU50NDZwMWdOMVh2dzVaVDdNMmVxeHpLZ1VwYVdITHBNZlZLWHcwS2ZWdzlKN1VNMnN5S1lZRkVYV3FnUldzejhLYUF5VWpSRWxRS1BaWmsxbjhzZk1scWVpYzNZT1cxcFZmdVVYelFoc05MYTRlZi8rOWJMOGwzTmpNekRRM2V1eDlzQXFtemxsaTY4WGVrODlQdWFRWGxtZWl6dzJKb0Z6eE51bTdzTjUvcTFsdzVyck9iN003SHRQNmxTckw2NE8zOXVlUU55NnJFTG1OcG1HYys0OVkxbWZEUDV4ZVByTGg0cHZwZjE2Snp5YTRNOGQ3aHNSZWVPeTZjdGhWb1lSc2NqTXQrR003V0MvdjlvbmFJbHBMUUExU2FtN3pHYWlKcUsxQVdsdkVGZXc5TUFURlNOT1Vxc0pNSktRTkJPdjdvN3c5RitNaVNZWEhlZnVTcVBMWmxyL2JUOFRabFRiN0ZPNHNZMXZleTNHdzFaRGFJc0tqKzlsSE1tTDBscHNqdEpSU2VWZnp2YzRORUFLeE5DZ29KaXAyY0NucGJmMW1kYzl6NHh5M3R6eU9sNW55ZGgvSFRpT2EyR1lqMW5KdFVUY3VkZFdaOXNnTDhSMVUwMGZpSTY3djZHdTI4VG14V2Q1dFlWckZCRk1SRVlwS3FibDlxNW5VK3EybnF3b3NwUTlwa1ZLdkluekZQVytSaHhLMkxtcTNaVXVEVEVUT3JtSzdVOXJLaW5OWnlwbkhTVFhGN3kyWVpVcG1JVTJUa28rT0ttdFZra3pUU2xXaE1WMmlMMERhNUdPYnI5aWExbjJzRG5DTXBOYURnY2JTZm9EN01iUzJhdDBEZXhTcnByaGFudWVvbU00S1NSb2RISjl2bWN5dFBtWTdTY0RlbGZZRXlobThoSmkyT0tkOWd0WGpKUUl4ekEyaXZOcVIwSjNWbmZqdEJQU1pxRC91TGJTZVZkM0NORzlMODlIYTlsdTlQWFhPb1M0MEgyWFRyTmpZTjF0UzBsOHozUW8xYnFhSGVBSlZ5NzVQUnJiTVRxK3JLVElFM3h5OVZwVXFXZldrcXNnUVdqMjB1bFZTREpCZFJranJaRlhWK2oySXJSUmhCeUlrSDg2YjJTa3I5dGRuMGtNbzZIcGppUGZlSGJPK29EU1Z6SFg2UkoxNXN2cWJzK21yK2J4VVM5djBzcWVhbnNXbnBpUkt3WWlXY05RRVFGWnFJcXNsc3pYcThsWmpkcERTRitKSSs2K2hoRFpWMU43K1c4ZXl4MmkxMUhzVlV1ZTNHWW5ITDM3VmVoVUJtMitsZGNDMVlpcjNDYVFtbjFFMXZDSWFvUFR2RVlpeVF1TG1NT21Xak5hS3FTQ3pkQ3JIbEZOeC9wM3ZtK3JuY1dpNlpjbzdRa2p0ZFVveWVmS0ZhUFFYcTg5MTY0NVo4aW1mRDRQaG9NYTdsSFdIQTFoVUU4eVdHanErMVJ6NmFId2lNWldYMVpTUGJKWW04MEJ1NVpVMzZ6TnYwOERqcUJSUHE3ejJEejVzQjJpMUwxdktZbXZiYXI0Z3BSNnhmUVFhNTkwa3FOWjFiWkJjUVZMUzBpNmk2QXdCQmF1a01rbkY2ckpGUmcxRlZrOHpjUFlCWnoxZ3I2TytycTExVEsxUkhMclZ1RGltbXJMcWYxMDk5THdBdC9XazlrcHlTRkY0QkRzRUpnQlhQWWs4RUZGYnUzMm9naW9POEFuRVZKOXlMUk9yVnBmNVlFam15ekZuOGo3U25oK3V5QVkrRndkSUtzMCsrS3AzMzRYdEQydDFIZ2M2WXI0ZVBaVllFV0x4MGxmbjFsV2Z1cEJSZjRPV3BLeGl5a3JIcWlJbEtoUmsxSXJRSzJQdDZsOGx4RGFvNjFmc1BCZXpmbE5Ka1V5YndCaXExMWxobjZSZWFzMDlVWSt0dnc0eS96dHo3Nk5hc3R2WWtIME5JR01USkdPZjFKazc4d0tray9paTdPSkNMQktPeDZsTXlTbXpQc1QvdEI0MU0rOW40Q2VpUjFLdDVXZDIyM2duam5CUzg1aEhXOCt2UkkrY1VKVzN5SHhkM0NlcU5ra1ZHNjJpNjFvcXlCQlYrb2J0K3JvZlZOc2VyZFFqbVd5YjMzb1h2eWF1OW11d1UvMnVOdUwySTNrU1o1TStVMk9xSGlYWWRwaWxsRjRyRHplVWdqb3NaMitlNDNFYnhETjRXUkxYRmwyczIwaHJhdEdibDE1c1J2NGdWcU5ZMWg5SlM0b1BzdnA1T0ZTYlByZ3ZMVDd6WG53RkliV08xU01vaTk2OTR1Sm52YW9sSlYyWVRYWU1ZT1VITnV1bDhvWlNXdm1ZMG56cmZQY3JZOXBZdG11KzQ2cThhWHJiZXJiY0lWRGRmNmt5bm50UG5ubnZTZjZWYXBYRnB3VFM1eHFKaVFCUlNia1VBRWlVazlYTkZwMG16TXV2NW9zVUU5QldQL0YzYlFLbzUrdjkxQi9ad00vR3M4L3hoUXJzNlcyZndaRm0rWkZ6VThMb21QMVNjYTZPaXVwV0E1S2EvWk9xNzlTUVQvRWRtNkNsMDdtNTArcEd3ZFNFZzBTbjlVVVY4ODN3Ymw2djEwZDF6TU5Kbi9meDNFQVRKTzEwcTVna21JVVltaVVuRTlLYS9IZm91VnZ6ZmdTK2dKanF5eWxOQXFXZmFWMVc5SGRpUWc1M3hjZmRwWUVmaGpQSzR1eCt2Z0xQWGs5bis4S1Awek1oYWpXWHY3VzBWVUZVTU9TakNzbjB1REdtbWJNVmNGWXN0UW84b216NVFOM3dqSkorWlNQb1VXTEtqWE9TNDhjU08wbzRrS1B2ekdsU2UwOTdSL3BvZk82d0YyU0lwR2xqb1BaZjBmdmNsdlhUY3d3TWxQaHRiOG5aNjJtUmpsbFdLQkEyUkNMZmE1RXBIS3N5WHBucDdKZEo1bkFQVkw3TlRYcG11OGJ5dzdmcXpEMzlBQ2ZUa2NNcE51MXAxa1NYbittaHVwTFZKSmgzM1dxeWZEUk9FZFBXaGZXb1pudkxqc2xPRkZLS3lpT1RTc051cTYwemJyMllBd01ER1ZzMVcyUFpaaDh6dTQwMEVMbGUyWHpiVFVmMmthcXU5T08wei9WcytiN3ByWDltNjIxZUdaVjNxdkt2WFdoVUw5UjdENG04SzRycXAxZnZkalc5Y1FvZmdrODM1U1VHdGtNdk5Ba0tXU21aaGx3MEYxaVRnVFZIOUJUWndNQkFpWU5FdGVwalZ0ZUNkcDZMYlpKaGFUUGM2NEFwckVsc0RaS3dQcWdtR3A2U2JqVnhzUDc0YkNuUk9Yd2U2N0hPMzc2R1hUY0pZbnl2V25NM2lTdlF2L2QxdWZZYnI1ZFZsbWlUNjBrNmdpbVRGNzRsRi9zNWlISmkvWVZSVCtsT21nL2p1OXpaZ1lFZmhaNjlvL3FnbWltbHRzaXE4RXBoWFd2c2Y3RGI0eU8xenJHM0dqOUJKTit4WXNuMVhnNm9iNUZ6cmxkdDUxc0EwTkcyUWlvdnNXWEcyeU95eWhoOENrOHBwcU1IWEs5WHZkeHBDR3pqUDdKQkVPeHl1VzE5eVR3TlFob1llQ0VPRWtuZEtDeFdaNndIYjZqM2ZSUWJ0Y3pXZUdJdk9mWjN4a1lOekZReWgweHJjVWlGcFNrdnIweDJzMC9IcDVyeXJBbFBPYjRjTzhTYTgwd1pOY2hxWmY1cm1TWisyNHM0TVBESldGWDhPNHFuY0diVUpybEh6K0hoaFMvRU42bExxSjdZbGdkWlNkWDFKbFhMVndjQXF2cjRFNUFPOUdXNThzcXlEdGxRTnVNbHhTVExZdGk0ck1kVkMrOVVLMnBnWU9BNGVrRk1lK3ZZNGpNVjNUUG10KzRKL0Z6c1JwK1Z4QktMakJNcENZQXNCTnBaZFQ0ZHhjRm5ISkFXWjB4Mmg0OHNCZW92NHFMUVJmTWQ1L0ZnaUtyb3ZHVDJxL2YrQzE2K2dZRWZoYTNhY21QOUl3NktoNC85YjJHbGVrd2FLRFprSkdhcmJOUHIzT2l2dnF1cW1BN2J2VjVoSU12U01zNGxFMStsaWxLR2NUSitKczJQeXlpaTlJajRhL0p1RGd3TWRQREVSemkrMzROb21kN01mRDI4U2RYUk9UVGRJbCtxbkFBY3lKV24yRnF0dmpXdHlEeTdyQjRPbXN4TlNhTmVhcnA5YThvakIxREkvcWJoWnhvWUdQalhZVE53a0Jscnl5YlBiUkdVTEZkTFgvSTdVUTZzMzQ2M1BNNExaM0hZeC9RYWM1NWNhc0VYQkUxdFMrcFhrazYxS1EwUkdtYThZUHhNYkc0aDI5K0JnWUdCZndXbWhpWmp2a3ZMS2plSWxLK0hGZXJzODdFemVRaXRlTTZYZzZ2ZkdsVGRtSEowVFJlVmttRjdXaW1tK2dFTURBd00vRlpZSlZTN1JreDl5Q2F3b1JqWExxN2JTNmI3SFpyMEQwWGxIVFdRdFZSV0tROWpqaTJ5T2JkYWNyUE9sYmNLSDVldEdRMC8wekRuRFF3TS9GYVVacnpzNWtEWmVLZThma2xRVmFQK29HL25vMnZWUTVrZkxIb2VuUzBoV05zcTdYaUtwZCtKWlBTUUJpSEJwUjdMNlpmei9QcXNCaUVOREF6OFlteFYzbzJrQldSSVIrdk1ZaUJCczh4VlpiRzg3MSt5eTdhMk9Zb1A3OGRrZXlsRlJNSmdjUzJsTWxLU1dpc2tGcFZVQmtLVU54MmMvVlJSTlkxc0VBTURBNzhObldxZUtpSnFSdU8xMUZLNXowZUo1Tlg0TUIvVDNzVlpkdGFTTkJ3d2xiK0Z2d2t1OHJsSlUwU0pxSG9uOFIxdTljREF3TUNyMERESG1lNHpiQnYzM0NJbG1ESVUveDg1OGtmalpZcnBETk5hSHhQQVJab2lTSGxXUjBKRVJqbnBYNDdlMDMzcFErQmNOcUx6QmdZR2ZodXFhaTZXYVZMc2tyQzRucmZrMUdtODI0QzFyMmpXVzhWMDZQaEgvRXIxZW11c3R5ejlST2JtQ1FreG9rSWlsRGNaUWw1cEtBeXFoMllmR0JnWStBMW9lWEZrM2lhNFh1VVRYWWVKVzdKS3FZbG9mWXdqdGVnTG12NnJ3OVNLaVY1em5ISm5QZFl0L1V4SXBNS0FxQ0VIY0RBTTc1RE5lYks4N25CckZWSVJwLzdTU3hzWUdCajRHaEEya2d6VXVmQ3FSdnhxbXhKSEZOSkxNa250YkhJNDgwTnZUM1YxWCsrdU4wYVRMdE1sY1QyTnlLZXNmSWdBcDRSa3htTVMwckk1eWprTkloaExVM3cvalVDSWdZR0JYd1psRWMxL0o0UlRqTXBnLzdSZUZYKzhqb1dYNmxBeXUrc2NhcXQ1Mzl2bUVUemtZM3JXN2xoZVhKeGpiUVhvelRXcGlmS3c2a0pRTmtwUGI3U04zMC9TRnZsSWc1Z0dCZ1orTE5RblJLa0NMbE1QbWJyUEVsSDlKK1k2cTZiVXF0VXpGVzUxd1Btb2F2WGxVWGxITzk3cURZbFQ5cmVXcHM2d3ZEcjJKQ0FDV1VsQmxGUWlwQ1o3RHIvVHdNREFUNGV0NXdoMTFCMDNmRXlhMXUxb0hmalZOZVg4aWxQWWtuZThzenk3aFFpTVlCamR4UVdTV1p5dGY0bGNOT1ZaMlFvbkRxdXNucUlGVDhxR09XOWdZT0JIb2xkSDE4cklXSlJrWHV0TlRxNFFWNjBuRGZ0VTcyNGQ3emllcldvL0pWZWVvdStMTWpMVnNyeTFtMUlrSkpBekVYdk8vRm01V3F1dXhyRUdCZ1lHZmhKczVnWWJIRUQ2WDAxU3BaTFNobnpoOGtCdHhvTXB3MmJaaDZZa2VuVERMVC9UOGNpT0dLSmduV3J4MTVLTUtDRVRuYWVLU1gxTUtacFBmKzFJdHpwT1U5Ry9hV0JnWU9DSG9TQWdPMTMxOGF6bWlRakJob3JublRXcXcrUCtwZjVXejZPVksyL3ZIRllydHphcTk5dUt6a3NFbGpZV1dxSk1UcWtUTFRVVWtreFQybnVvWXZoNUhRUXhNREF3OEdOZ3JFa2F4MFdvdXNoVWxpTEtFY3lGWWpKRFlaUUNvQlFHaXFPNThmYVdQWUtlWWpwRlRpMjBMckoxa1BVaDFjNnB2aUgxR1RrUWhkd2lNQjF1MmF3REN1Sk9NaTBMNjE4YWZab0dCZ1orRXNoT3JQL1lLcVhPT2lzM2h6RUZVbVhhK3c3NFZCK1RvcVFFS3Fjb1cwUHIzSG5xdEZNelhsSlBHaFNoV1NDS2h3R0oxZ1B5T1BjREF3TUQzeDJtc3NveDNUbkRnNjVURHd0a1NjdlVnNjBCQWJuejJ6bUx2Yk04Mjl6djd2cnBYSGwxdXZNOU8yVExnWmFVS1pNeDc1a3VYUnBsUjVWWnIrclhaTlZWR3NsV2p5cjUrSXF6R1huMEJnWUd2aU9vUFZPbmJsdVJFYnRzc3ROMGJrbFI1ZjB4ekRxTkk5bWE4WU9DSGpiNTdrTVYwOVlGOWJKQlpPUXg1MHVIbmtUbklmdWFiTVNlNXNtcmMrcVJ0amhTUHFtbkwyOWdZR0RnWTVCODR6RDFscGJWaWtpaWxTdmYrOHA2bEpLODVzTlFZK283NEV0TWVUVlNFa0dvV3RwdUZVU21kNm16YmZFQWRCajJWY2o0dW5YdzNSN0d3TURBUUFtcmxuUys4ZGNZMnFJOWphU1dIakhqMWVzOFljYmJ4SllwYjg4eWwvQ3NPWStLaFJwQ1RpYmJiYzZQRndNZ0pIbHJhaVc0cEtTWUFqUUdNQWVqYThkYk5pMk9FVG8rTUREd2paRk5Sc1pOVVRmUWpia08wcFdtSnFRVUdCRnRTY2xhOVlBWjc3T3dsOFQxTURsUk5YMDJkTnh1NVdSV28rc0lCSFlPRkZoTWRpRVJraU9YVEh5Y1RIb2hQWkNjWjgrUVhlMXJHZ3cxTUREd2JVRFZyODVXN2dtVDBZR1FUWGtwaDZqTHBFV0FsSnM5aTJYUVZlckplT1lMYklXSXZ4b2ZQclE2MEkrUHIxUGFsVGVEaXJVMUxEejdtVUxWdnltSGtvTWNxQmd1STh0WVlpNTVhWERTd01EQWQwTkxMVmtYaFZGSmRlWWJoa3ZKQmxJOVNsVFZoOXNtdkNPblovR3FhRHpGeTN4TVc3YkhVL3NnRzNrQ2VRQzZReXRkYldkYjA5RzJkZ0NTZFFDYWZYd2E5dzhNREF3Y1Jic3VLbElRTlh4TTZuZG5UWG9ObHlQdkdtUzA5cmRYeDN2bUVyWnhxTEw5Rk1YVVFsczEyWEdVSUthNG5MUW9EcmNlVXhTUitKS1lURkpYNjJ0Q1NDb3JEOVBlVUUxRE1RME1ESHduaUs5OXBaYmNXaDJsUkt3bTZDc05yMTUwdkVYUklNK3VsSFVRUk0rTTk1bjR0S2k4b3hlMlZrMXlZeW1UazhyWHBtb3FRc25yenJZTjFaVDRlNmltZ1lHQnI4U0dXbEtMa1RIWGFVaTQxbzExSGNrRmViVXRSRjlneGp1RUk0cnBjSFJBeXpsMi9xVFhXOFcrc2FWOUZheXRBbEZOYUVmb3hWK095VnoxUVRISHdJcWhtZ1lHQnI0VHJGcHlWV1BhL2hXcGhTeEpPZGlzT1VrdFllMVQrcTVxQ1dnbmNXM2hGTWRzN2JOZTFwM1hCMFFveDFWS2ZpWVQ4RUFFY2s3TWZIYThKZ2NnNU8zTW9GckZWYVZjZWtNMURRd01mQVdvckg2a2JtSnJ0ck5xeVpDUkpTbEsxaVFsTFdTWEJuSUgyNXFJZWg3M3ZVaThldm1yOE9rZGJFK1o5QXlzemRTbFVXMUxJaXJNZUhERjh0UWhOLzBOR2hvWUdQaHU2TGdlb01xbzhoMVZ2MlgwSFJJNXJZUFR2cVQyTzN6UUR3bCtPTlBodGw3SEJJZm4vVkZNS1JSU1h5VHpNRkw0T01lV2duTUF1MEpCRmFIa1Zqa1ZPcGIxWUFmT2VHQmdZT0JWb0xJU2JLa2xqVVl1bEZMNXE2TjYyMnpqVUpXVUFpREtJNStwNlo3MExaMWl3bStRWGJ4L2dUbnpnOERjY0VLcGlqU0VuQ3JsbE5aTDgxWTEyWGJEMEU4REF3T2ZqZHBRVnZtUXJGcXFUWHBWa2xhQ3JSK1IxUktWeCtLRGRkMVhOczgvaFpqT1Z2bWFFNnJZamlqM1VEYkVVcW9tNDE5eVFsQ3VIbHpRUG5RNXU1RkRiMkJnNEt0Z0crRHl3NnFpQ3JOZEZZVmNxU1UyWmp6N1c2c2xyZDJlSVo2UEpxMHpwcnd2c1hIbDRUQ1U1MVgyU2w0b2xweDR4TkJVUmMxK1RScWhCNXREVC9iSTBuZEt4MnNhbHJ5QmdZRVBSNnRCM0ZCTHR1OVMxU0JQcWRkZ3BpbDN5TTFEMEdWZjA1Rm05eXNTSmp5RHZWeDVOVTVWMjdWSVJiVng2OUNscWJYME5RRUVweEYwamxLRUhZR0FRRkVkZ1FHVzFnVEh2MHhXREhJQkhKd0pIeGV2Vm9yODA1TVlERFV3TVBEQnFOVVMyUWxyd3F1VWtyRUlSUXRSMmFtV2JFZGIyVXNrS1pQRUZlMEsvYXNpOFN3K2RUeW1JOHY3YWV5bzhkQUlWaFZwNUowZG53a1VBeUhLVkVVdEd5Nndla21HU1c5Z1lPQkRRRlh0di9ZZHJkd1BSaTNaSUxDYzNjSCt3dXlmakorcHhObW05NE5OOWRNVjZhY0hQeHc1UTZybnFERXY5dGM4cW0wbUluWU5Vbko3NGVPYTlIQmdZR0RnczJCOTNUcGZtdTFTeE4wcXEwMk94RU5ETFJublJ6ckduc1hxQTB4NEQrM2lhQWZiK2tDbmlMTmxTUVcyelhxdVdpZjdseGl3UTdDTGFvcmg0a3BRbk1pSU9STVJPeGY5U1pKckwvYVNCcGkxRTY3c0k1Z2pENVBld01EQVMyRjgyZExBenVXV2tHcUxVSTQ4enFOM1p3VlZxQ1hrVWVsV2g1UGx2VkVmVUpXM2xuODBIbFZNcDg3dmtXcDlUVWoyNE9yZ1ExWTZTajZVYmEra2lzbVpNSElOR1crRVgwSjhUUTljNHNEQXdNQUIxTjZiVkpFMS9rbzFsSWRPejFhaWRzTFc3RnRTMU9ycHV6ZTF2NlFmVXd2SC9WSGx5TGI2NERTTE9LV0hWeVYySlFmUVZJU1FrMmwxRkQ0bisxQ0hyMmxnWU9DVnFPc1VVNS9seEt0VlBXYlRFTmxVUkdycWsyMnRMeW1GbkIvQW5vbnZRVHk4cTA4anBoYng3SjMxS2RWa25JV2xhcG9BbWdCWGtaS3pmWnhNNXpScjZpMmNpSU9jQmdZR25rRkZGSTNNRG1YUWcvR2IyMmx0akVPNnpGU0tLZnFZTWw2aGxoN1k1cWtLODh2R1kxSllEODZlRGRQNmxaaFkramVaUFNYRnhNaCtKazVoNDBqcGlpWXd4M1VvRGROdUxiQ2hEQjhmR0JnWWVBcTFDVTkrS3hOY00zcDRsVkRBckNQN1lnMXNJSE9NcjFWTFQrRlRUWG12OWpXbDFvR29waFNWNGlnR09waklQRW8rcHdrNVNvK1FvL00wbFZGdDBodXFhV0JnNEFVb3JEQVZVVFhKYUsyV1Nxc1FyZFVTdm9WYWVoclBFTk9IMU5KbmZVMVpRVmt5RWJJcHdzWW5zSkFTcGM1cFUvR3d5NzloMGhzWUdIZ0ZPaWE4aGlLQ0NlU3EvOWlRa20xQXExcWl6dkcyU09tNytaWVVqNFNMMXlmd0VLSFd3dlpJL0h3T2Y0elpIeUpQU084alJpSWxPQVlGemZUQWVUaDJNZVd4bVBXSU9ZYVVhNXFpb0xrZ3NsSWFKcjJCZ1lISDBUTGh3VmhqTEVuMXlLZ01kS2lIN3lsODVIR3F5RGVxODNXZGVpVERRNnY4eEFVL2pDLzNNU2xxY2pvV001OXBKS2VJQjRpZDVNNVRRcG9BbG1FeGFJckV4UXdXL3hPUjV0cGpBTUdFYjhxWkVPV2hNZUxCOERVQ2QyQmc0TWRoWmNJejA1V0pya2RLQlVHWjRJZHkrUFNJT3N2RG5sSXlaL2R0OEdYaDRvL2FPcTJ2aWRNMDVYSWdPUWpKUEdoMjBYU24vcVpvNXB1eXoybVZFU0szVW9aSmIyQmc0RHlPbS9CNFJWQnJYMU94SG94L3lSNnZtbTdWVWtmcTNxOXVkcy9saFQyRUQ1TVBQZm5aUFEwS0VvSEhhVEtlSElNd2llaGhBRkV4Z1JrTUIvQVVUWG5nbVBYQk1TaUVBeWE5b1p3R0JnWmFzS1JrQ0VSTWI1YUFDbEtTQmpOTEZ4ZTRLUTNqRXh2U3FxYkViVkdRayszamVieDIrbzVON0ZlWjhoNnFvVnMyenFNM1VuMU56R0pKcmNMSGN6Q0VEUjlYUDlNa1pqd2hLUEZERVhGTVNoN1VyRWRaRnhjZVJIN3dpZ2NHQnY0SjBHb0N5UWVlR3J4dE01N045Vm4wWDZJOHZNVzY4Mnc5L3ppK1E3WDJiWHhNaWlPK0pvWWhKOUV4c2FGUTA1eVk0bXlBQStlK1RXbjRkVXd5SmxOVVRPcHprclI4aUg0bnhPMnRqMm40bXdZR0JsYW9hcXlpSXkwYUpyemExN1FtTE0xc1l3TWVDaVVHNDlwQXY5Mzh3YjZsbCszdTJhaThsNkZsS2QwTFpVelBoek5KT1NESldZSURVNlF1UnhJUTRTYlp3SUdGa0NEUmVlQXBLaWJtU0U2T1FZSFN2Z0U3YnRNZ3A0R0JnUm90RTE3TFgxVDZ0VmZsenE1ZkRuT1JSa0VRVWxMMXBBRURyV2k2dW16TDkvUWdKN3lVU2w2cG1ENjBkdTVINlVVelh1cjJiTTRpUnBBVEdEbEtMNm9obHlMMTJJbGFFcE1lZ29TWUkwNFh1K1NRNTNuNG13WUdCaXdxVWlvbXFmeXpmaVl6TkE4WEtxbFVUTHFkalVCdU4rbDN6M0tGNzFaenZkcVU5M0R0M0NLZU0yWTlYVmQwVFNRaTJZc0RJWkFET1FtRTRDbVNXU0luQnhLVEhnQ1Rya2pDeUVIUmYyWEN4b2tveGxFTWY5UEF3QUN3SmlXcWlhaXZuS3cvaVN3cFFYUGhTVlNlM1I5c2U5ek1WL2lKVmRPMzh6SFZPRmJuMTZvcEIwSW9VZW5nV2RwQ1lhaEpUMy9sVC9zOVNaUmU3SGdMNUZ4NmNneXV6SGpEcERjdzhBK2o0MWZhSWlPWHk5aFpFMTdsWXlxVVZqNkVIV3NwenA4K3k4UGJQYkRicC9DdGlPbElwOXErYXFLb2NEaWI4UEp5OFRjQmtXQUlvb1lta0FSQ3FFa3ZyaDhKS3dWQkVPSXZBRVpJWnpEOFRRTURBeXNUWGsxS3RZOHBSZDFOaFZLcVV3OGxFMTRLbEtCeS85WC9MZXo1NmI4aktRRWZRMHhQMWN4SFRIcGIyOFYxU2RRT0pWTWNnTFZKVHhXVGhJNnppNmE4RkVLdTBYb2t3UkZCOWhsanl0UDdXUGliQmprTkRQeERhSkVTVVBpVnlDR0hobGVLeU9iemJJU0g3NW53RkY5a3d2c1FVZ0tBK2ZuK3RVMDhYVE1mT2EzMU90R001elJLVDB4NmRqazVBa0lPSVkrbnFSMXNJYjh1bDdHUVZVRHlXeEZDMzk4ME1ERHdqNkFpSlZ0ZW0vRnFFNTNUWUFmdFNHdE1lNjdhbGlqeFhZNDRobVJLVzJ1bVZuUmR5OHJVS2o5MzhSK0hiMlhLczZpVlU0dnBlcWEvVXJDVVdjZ0pEc0ZGb3NtZGJyTTZVa0tLV1NGaWNJUm1oVWorSnViY01qTHFhZTF2R2hnWStMVlltWGFPK0pVcWs1MHJ5OWJtdkd5Nlk2c2lEQ245Um54YlltcmhHRG1wTWE5VVRkRkhsRTE2VEtWcVVyTmVGRDRzaVY0aEpqMGtreDRScEgrVCtwdmlNV05uWEM3SjZYbmhPREF3OEMxUk5adWIvWlg2NU1SSHlNZ0VQbVFTMmlhalZtM1RVMHZmR1I5SlRFL1h5a2VDSVhxSFRwa2JtaVk5U2FJSEZyc3VweUV5QUVsUGhEaktMY0gwZDlJTEt2bzNqV0NJZ1lGL0MycUNLZjArUlJrc0lhbUpMZ2M4MU9xcElLaGlIOWFmSlBWTVJ5MGRJYVVYNGNPbDJrY3JwcGVUMHltVFhuVXEyYVFYalhvQlRyb0tzUEpVREl5UVlJYVVwc2dtZVdVMS9hRU1oaEQxUk5EdHpjczZ5R2xnNEplQXFncUp6SzhOYmpCcXlWVnFpYVpNVUU2Q0c4aU9TR3UydDJvTWZWSTZpdThhaFZmalI1bnl0dEEwNlRWVWsvVTNwU2c5U0E0OHlmemczSVJnQ0FtaWhLSnBEM0ZBUWFxQ0lVeXkxMHhPK1ZRR09RME0vSFJZVXJMK251TytwWlpmaVNYZ29SNG1IYlZmQ2YwYTVCUFYwcWZnUnhEVEVkWFVSc3VrQnlHbjJNSnhMb0JERGlHSCtweDRBanM1T2tNaTlOUWZOZVVJdnV4bWdpWjcxVWk5ZlBZWTVEUXc4S1BSSUtWbVpvZktUR2ZNZDMyL2tna25OL3V1L1VwblRIZ3QvS1NhNXpPU3VMNnNOcTdKU2JIZFdzaUVwSFRFeFRaaXpsTTduakVQQndrbEI5dGZRRE5Fc0t3WEZaUTZLZU0rd2FFVFJqN0lhV0RnWjJHRGxGWUtxYWVXSmhCTk9jTkRzWDVXU1hid1B5ZCtKZXRqYXRWN1ZQM1dlRUZvZUhYeEg0L1BVa3d2cVkxN3ZxUlRPeWZFUUFpeUR5ejZpV0xFblI1SmxKRkU1Z0VvTWtNa1BSUTBFem5FelZSSXFGSXBwUk1kNURRdzhETndsSlFhUGlWWEJqcXdaSHRJZy8wVkNzcVNFaVdMQzZNNnR1QUxhbzlQdFF4K3BpbnZVOG1wWEMrcUpvaEpqelJLanpJRkVWd2M4Vlk2MHBJejZnaFRDb0tvelh5cFk2Nk9tSnZDeUoyczJ3Z2pIK1EwTVBBRGNJU1VPajRsc3VTVVI2RlZwYlFWR3A3ZEFGVDg3SnhwRXorMWh2bnM4WmhlV2h2WDU5NjZGcXVLNmtTdjRDeVgweDZrZnhPQytLSTBUUkYwdEZ3MjVybkpIRWY2TnFWM09hUmxnNXdHQm40Z2pwQVNqSDlvNVZzU0luTHI1WTdza09weFB5blJ0RGttbWZySm11VDI2dTBYbXUrK0JEOGkrS0dISS8yY3JFK0piSUh4TjJrNXNVc0pHOWdCRG95UVZOR1VBaHMwR0FKQVRnSkJLSHhPK2ZXUk1QSkJUZ01EUHdjcjFXSitrN29SVW1tbEc2SXBObXJWaEdmTWVpa25YcW9qakd2Qk5wUTdwTFNIRDZoTlBwM2ZmalF4QWNmSUthTWlBZkUzc1FpbytINVFOdTBSUTFMcnBjYVIrcGVTbjRsek5KOUc2UkhWZWZjR09RME0vQXowekhjQUxKbTAwZ21sQ0R6alI2S3BVRkZrZlVrYi9aWHM4ZjgxVWdLQStRc08rK20xY0ttYTFpYTlncHlZb25MaUFKSU1FWTRZUVFZT0xNMTMycWpoWXA2MWlCbUVNTWhwWU9CSFlJZVV5SktTSlJkTndtbzZ6YnJzVjdKbXZSendVQkpTM1YvcGtYcjV0NUFTOEhXSzZhVzE4SG1UWG8rY2NqNDlEWWFBSkh1Ti9aenMvalFvSXA2QkRwaWJ5Q25rb1BUVUFWZmY4VUZPQXdQZkRGdWtWS2thSVNTcS9FWWE3RUFyODkxVStab3FVa0o5M0R6OWhiNmlMM1ZQZmFVcDc5UEpxVngzVFU2UTRkTXBCUzVJdnlhSnR0TkJCbk5Fbmw0QkY4ZlBacjZRT3VCRzMxTVk1RFF3OE8yd1IwcGl3alBoNEdTSUtQMDY5Ui9WNXJ0MU9MajZwemdkNjl2NWxiNFVzL3YvL2YrLzh2Z3lvcCs1clJYRDVNdytwaEtIMEFJSHMxNlFNaTBJRXVJTk1FdldCdnNiR0V3QjhHYWVsN2h1V09LOHY4ZUVyV0VCdkFNSGdEM0Eza2RmVWdEWUJ5QUVrQS94ZkRqRS9rNHNxUmgxU0YzaG5ueCs4ZkpKTDVpTEJRTURBNThDcVd6WWZIbGs1c1dIckthMk9NM3BGK1RqNTAwTWRwZFlwemdTa3gyREhBR1RFdGNNbXFLSmo2U01oUFRJVFNBWGZ4a3h1VFE1a21VYVF1NnkwRktUSWpUNkNyQ2pka05TcmFXTElVQlNSOGk2NkxmbWJWTFJMd0lWT2QyK0FCeFpveTVMRlhWQktpR3M1a01JOGRkN3NQY0k5bTlaRUpZRi9uNWYvOTF1V1A3K3hYTDdpL3QvL3d0LyttcnZYZ0FBSUFCSlJFRlUrNHY3Ly8wZi9PMHZsdi85ZjdqLzMvL0MvL2QvNGYvK0g3eE1oLy8rUDRTLy93LzQrNy9BL1g5QjkvK0MvSC9oL0YvTXVHT0d4M1VLdUU2TTZ3VjRtd21YR2JoTXdHV083K2M4RVNZbjd5cWxISTdwdlZrbEtrYWVwOW9PL1FSZXRhOVhudE9yOS9kZHorMWZ1TVpYN3V0VisyRzdyNEo0WW5VVG1CRTR0aTg5QTk0emxnQXNIbGc4NDc0QXQ0WGozeDM0ZTJmY1BPRzJFTzZZNFBFR1AxMFFwbmZnOGdmaDhnNWMza0Z2LzRQcDdUK2c5Lzlna3IvNXovL2c4dWNQNW5mOWU4ZjA5bzc1ZXNWMHVXSit1Mks2dnNYNTZ4WFQ1WUpwbnVIbUdkTWNDVTUvbmZ5UmN5RG40T1NYSk5nQ1JNVnZVYmErMmFCWHYxUVA0RnRHNVpGSzNKbzBLYWZrWUNBK0JFUTNrR05HWUFiSm4yTUdwamgwaFJNeXEvOG1NNTNVRkpBSXp5b3NIVEFRY2h3Z2Iwc0FmSWduUlI1eVJ1dXNWbkV3M054TVVSK1cwMkFmMDVwSkFSVDVPL3JxUnN6QXdJOEZWek9icEJRQUg3Wko2Yll3L2k3QTRvV1U2QXJ2TGdqVEcxZ0o2Zm9IZFBrRHVyNkQzdjVnZW52SEpML3oyeHVtNnh2YzlZcnA3UzJTMGVXQ2FiNUVFcm9JR1YwdWlYZ3NLU2tSRlNUMFMwZ0orQWJFUkVReWpCSFg1WlhmSnRmZHRpemRaT2NpSWNteWxIdkJrTTVLSGJhSVNaV1o5MUR5c2VzNUlhV0FyT3JDZ2tSZThTMEhRQUcwOUs0NmVxRm1JQTJBT3cxeUdoajRFR3lSVWhDRFRXQWdSS3Q4U1VvTDQrN2JwSFQzaE1XUUVrOVhZSDZQZjRhYzNOc2ZJU1FscFhkTTF6ZE1iMjl4K2hKVmtac3ZjSmRMVmtpWFN5S2pwSXFNUWlySXlaQk9UVVlGS2ZYd2pVZ0orQWJFQkR4SFR2b2dkRVJhQUNVNVZhUmp3Y3lZUkJuVnhCVDlSZkxHcHVsUUVGQkl1Zk1rR0h5UmlYRFBDc3VjZTNWMHdKQVRncGoyclBsdWtOUEF3RlBnYWtMZDFEMVNXZ0xEZTBSaVdoZzNxNVlzS1MydVZFcnVpakM5Z3k3djRFdjhkZGQzMFBzZnVMZi93TDI5WTNwWDFmU082VDBTMUh4OVM2UTBWYVEwS1NuSm41SlFiYnBEUlQ0L25aU0FiMEpNUUorY3pISUFhM0xTU0Jmbm5Fa0NoR3pTRTNQZVZPMnZJQ1daWjZ6TmZlVkpBR2xvRENVbnMweUpDaUU2SjhrdjBDMktZME8vazNnVkV5TmxOa0gra2VzZTVEUXc4QWhXcEdTbUE4Zk84RUdJU2MxM1hreDNpOGVLbEtKUFNVaUpuUkJTSkNXK1JMTWRMbi9ncm45QWIvK0pTdW45UDFFcC9ma1A1cmMva1pEKy9DbFUwM1M1UmwvUzIxdWhsRnpsUTdKa1ZQODVRMUtGZXFxeFIxTGZCTitHbUlBSHlVa1ZFMUNRay9xWmdwQlRRTzRheTZxS0xwZTBiK3RMQWh2eTBlWHA3V1lzUm1GUnBpb1FnSENMRTJJSkJQc2xiVnQvS0dtL0RraFVzMGRPc3VvZ3A0R0JObXJUSFNDZk5lSzMxQ1FsQ1hUd1BwcnU3bXJDdXpOdVN5U2w2Rk9LU21taEdaNHlLVVh6M1ovb1YxSlMrdk0va1pUZS94aFMrZy9tNjF0U1N0TjhFVks2cmtqSlZhU2twcnc5VXNJUEp5WGdteEZUQzNVZ1JFMU95WXlIa3FpY2M1R1V6TDdVdE1lMVVwSkFpTnJuWkdHSmk0UFZabGsxRmVRRWdMMHdpUGZRZ0lnZW5lUWtSbUp1eUYybzhqb2FzU2U3TVR3MU1EQ0EvU0FIRFFLV1hpTHczdnFVb2xLNkw1R01ia3RVVEVrcGVjS2RIUmFheFhUM2xrbnAraC9RNVQyUmtudjdBM2Q5anlhOHR6K1ZQMG44UzJxMnUwclFnNWp1cG9xVXFCZHhad0ljVnFZOHdVOEtlTEQ0OXNRRWJKT1QzdkNhcU5Ed09VSDJVWmpvS3FYVUlxVzRXaTYzMit0MGdKb1dMVGtSRmxGT1dCQjlWVXBBeGNlQ0tPZVlNWUdTejJseWViOGs2dzdUM3NCQUc0ZElDWlI4U2o2d3FLWG9XN292d0wwdzM0bGFra0NITytab3ZpT0p2dE5BQnlXbDkvOUpwSlFESFNJcFRXSzZtd3RTaWtySnpVWWx0UUlkZXBGM0ZSblY1cnVmU2tyQU55U212VUNJVmprTVVka1E4bUs5eXVla3FIMUpPajlYOHozQ0loQTArQzZSRTh2dkxlYVFXTHo0d3Z3UzQvbVl3VXlvOXhaTmdoelpiVUlPaUpDSVBUMzhJS2VCZ1l5bTZVNytZMGo4a2lnbFZVdEJTQ21GZzBzRTNzMkdoUnRTV25qR0lxYTc0SzZSbEM3UmJJZTVJcVgzU0V6SmZQY2VmVXJ6KzN2cW0rUWFZZUcycjVLTnhtdjFWVXBrdEJjYTNzTTNKaVhnR3hJVGNKNmN0dm8zcFZXRW1DRGtwT2dSRXlBM3A0N1dhMkF5bjBZaUp6MlhlMlFSZ3NOZGZFNXExdE9lVGtrOTViTUFJM2JFWlFrbjE4ejY1cEtiZmllWkhCajRKOUFqcFJTSFpNMTNRWW1KeFlRWEZkSWlTdW0ycUJsUGdoMDhjRjlFS2RFRndiMGhURmZ3OUFaYy9nRFhQOXVrcEIxb2xaUWtMSHhxUmVDZElDWDhjbElDdmlreEFjK0ZrTGZJS1FWRFlHM2FzOGVZS3FLcTV3c3dOMzJNTmxLUFpaNDl3V2tZaEYvQUhJVHdTck1lR09BcG14MW0yUTlpaHBPVjM4bm0zaHZxYWVCZndsRi9rZzF5Q0d6TWR6YlF3U2lsdjNmZ0hrajZLYzN3TkVkU210L0E4eHQ0bGs2emx6L25TT250RGJPU2s4bm1VSVNGN3dRNkhPNUVxL2hCQVE4VzM1YVlnTmVTVTRyUTAzbmRXVU14VFRwdi9VNGJzSXZqU3hESGRHS1NYL0VTTVJHQ3AwSTVzYWlqMVVjMTVZTEpaYk9mdU0yUzN5a2VzNjJlZnQ3ck9EQ3dqejNUblpLU0VsS1FDRHp2R1lFcEJ6bDQ5U21KQ2U4ZWlla2VIRzRMWWNFRm5tWjRkeFZDaXFTRTZ6dm8raCtRQmprOFNFcUZYNmxEU2c5bGRsRDhVRklDdmpreEhVR3ZmNU9XcFljam1TRUFGT1NVc3prOGRSS3JJcC9LZGF3Vmloa2lRR0F2djJFQnM4OCtKeEZ2UEdmVFhsUlRNU2dpSFlVeVFkbFRTTmN1RThPME4vRGIwRlJKYUp2dVFsQi9rZ2wwQ0VwS0V1eFErSldBdTNlNEI0Y0Y2bE82UktVMHZRRkNTaTZSMG44ZVYwcWQwUEJWdXFGcUhnMHlPa1ZLUDhDTUIvd0NZZ0syeVVrZnBNME1BYUJRVXIxK1U4L0MyejRGY2c1Qi9XSEJBWUhpT0ZCK0tja0oyY0xJazg3SGM1eEFoZC9KMVFjZHByMkJYNGpWRjNyQWRGY1NValRkK1VCdFVsSi9Fay93bU9Hbkt3TE5DRk0wNGNYT3N6RWNuSzd2Y0cvL3dmVG5mK0N1N3puNmJwZVVMaXRTYXFVYjJpS2xRNWtkZmpncEFUK0FtSTRHUW5USnlZU00xNkVMRGdDbXFVMU16eEJXT3BkTVJxcWFsS0Q4SW4yV0FpSEdWSGl3MSt3VEpDMi8yclNucGtZa1ZtSzVqaU9tUFdBUTFNRFB3MW5UblFZNitNQXh6WkJtY3dobFF0WkVURDRycFdpNmUwTndNOEwwRHA2dWtaUlVLVjNmaTg2elRrbXBqcjVya2xJakIxNlZtSFVyQjk2S2lQcmsweXYvTVovL3R5Y200R1BKaVpqalMxR1ZOMU1TOWMrdmVCbnlpK01RWkFqbW9KMW40eG9nOFQxNVJPVUV2b09YUlZwODRuZVNEeThZN3N3UmZJeUpLWVdTMTZZOU9ZeGNZNTRlNm1uZ0o2RXdUNk1rSk9DSTZTNlRVUTUyeUthN216Y1p3cVdQa25jWFNjYjZsaEt5cWxJaW0yYm8vVS91UFB0aVVtcmx3TFBrOUp0SkNmZ2h4QVE4VDA2OW5IcDFOdktFTTRySkhMTXNjL0JVNmhrV0ZrbWpXWktEOTlIdnhBeUV4YWVJdlJDRW5JTDRuUWlZYlN2UjhjcTBSOFhSaG5vYStKazRxcEwyVEhkTGtaQVZ4b1FYeDFKYWdwTStTalBZWGVIcEluMlU1RzkraTlrY3hIem4zdDVURHJ6NVBYZWVmVFVwYmVYQSt3MlpIZmJ3WTRnSmVKS2MxTThESENJbkd4VFJsYzNyRTB5L09wd3lYT2xuQ3M2Qi8wYXkwb2c5VlU4SUxpcW5JQkY3SEpKWkw0amM0c240bmppYjl0Z1JtRXlIM05XNXljOVFUd1BmR0UxQ2tvKzRxWkxZUk4yRjNEOUpUWGYzeGFRWk1zUjBEeExrd0RhYnd4V3NDVm12ZjRETEc1eU1welM5Lzhla0Y0cStKTTBRUGwzZlBvMlU4QStRRXZERGlBbDRuSnhTYlIzQ1lYSXlPejlHVE1ndkN3a3BwYUdUaWVBcHZtaEJROG1Kd09UQVFtTEJPN0FuVEV5NGhTVitkR0JKengvVHhRYmpmMUlUSHlOMjhtVWE2bW5nNTZLbmttaEhKU1ZTRW4rU0Q3WHB6blNlVlpVa2tYZkI2VmhLYitENUNwN2VRVy92T1V1NCtKUWlLZjJuSExiaS9VOU9NeVJKV2JlaTcxNUJTaTAvMDI4akplQUhFaFB3K2VTMDE1UGFrbEh2QlZvSzJ6REJKMVhsd0M2U1UxQzdzbzhwSDVqdjRNV0RwNXpHS0k2MEdhOXpGdVVVNUhkeWNrdk9xQ2VaSHdRMThGWFlNOXVCdGxWU3FFMTNHZzYrSWlYQWg5aHBkc0VVSSs3Y1JWU1M1TDY3dktVK1NqcW1rdnFTbkE3eTl5WkRWeWdoYWU2N09XWnptR1g0Q2pmUGc1UWV4SThrSnVBNE9aa0ZENU5UMkZOTWpaZW1mSEZrMmhISVRmRHk0b1ZwRWpLS3hNUjNCeUtIUUJQWU83aEFDSHhIV0JhRUtaNnZUeDhvSVFncFhZeDV6N2tZR09IMjFCT3d5bFlPRFBQZXdPZGhsNUJRUnR3MVRYY3JVaXJ6M3QyOXFDUlB1SHNIaitoUENsTWNjVGE0TjZBZ3BUOXAxTmt5Ty9oNzhpVk43M0dBdjBoU1plNjd1VEdtMGlDbDgvaXh4QVI4TGpsdG5vZHpzYzlTMmtFMjN4RzUyTG5YQkRzUUVSWVh5MEVPUVpRVGhKelU3d1J5NE9Da3oxUDBPNFVRSkFKSncyTmpnTVFrSkRVTFNUbmE5ajJwM1Y0SmFxaW5nYy9DS3FTb0c5d1FHMWtBSlRKcXFTUTE0YVgrU1RZa1hFaHB3UlJWVXVvMEt6bnZwamZ3SlpPU001RjM3dm9tL1pUK1JNSXBFckZXV2NJYlE2SVBVbm9jUDVxWWdIMXkwcWVVUXI4L2dKeTJJbVZnWGpTSWo4bEx1U2VYekhsQnpIa2t2MHdPZmlFNENZd0lnUkQ4SFlIRTd5VEVGRDlTd2lYa2dJamc0cEFaTGQ4VGtWeVBrRktLRHBIcFFWQURINGtqS3FrMjJ3SDdLaW1sR0RMOWsrNEJpWlM4REZuQmxUOHBxYVRMZXdweW1ON2VDN1UwdnhtVDNac0pjakJEVnlSeXFoT3h2cHFVL2hIOGVHSUN2cDZjVmk5Tnk2eW54M1ZVcnVOY011OTVjc0J0QW1nQ3BnbE1FOWhOZ0o4US9JUWx1R2phOHdHTWdIQVBLVEZsWU1CTFlNUTBSZitUK3A0Y01Sd0RFOFYrVDJ4UEFabWcxTWs4Q0dyZzFUaEtTQkNWcEVTVXpYZnhIZGZnaHNWa0IwK0JEaVpMK0JJSUMyZVY1RjBNZE9BcDVyM0Q1UjEweVJrZFVoaTRrRklrcEdpcW00d3ZhYnFvRDBtSXlKSlNSVXh1bWdZcFBZaGZRVXpBMTVKVFR6RjVsS0hpT2ZtaWt5U05VeVFqTWV0RmdoSlN1c1hsZkp1aWtvSXpwcjA3MkhzRUluZ09rWmlDZkx5aW5zS1V6WHFUZzVqMVlyOG41VVluSnI3Q3Y2UUVOUUlrQmw2QTQzNmtTRWphVWJhTXVzc3FTVW5KcXFSRmgwSFhjSEJQOERyU3JKanVlSXFraERrcUl3Z3AwZVZOMU5HZjBwK2tSQ1NrbE1qSWt0TFdlRXIxWUgrdklxVi93SXdIL0NKaUFqNlJuSHFtdTF4UUVwTDlLN0lEeSsva01rR1JRM0JSS1lXL2NSMTJVVVVGUDRHOEF4QWo5Z0lXVEFzUU9LU0J6eTZpbm1idC8rUWlRUVdPNUJTWUkxRUJ5Y1JIQUJ5YitJN0svd1FNZ2hvNGh5MUMwcCtjY2l1YjdTd3hxUzlKTTRMN2tEdkwzbjJwa3U2ZVlyOGxQOEZqZ25keERDVjIwajlwanY2a2FMcVRJU3V1YjJ2ejNmVTltdWhVTGVsUTZOZEtLWmsrU2hwOU4wanBkZmhWeExTRmw1SVRhZTQ3NUgwMDVwTnlhaEVVWlpWRTB5UWtGUlVUVFJQQ0ZKVVNic2FrZDU4Qk4wblUzZ1FPTnpBdDRPREI3T0daazNwUzM1Tkc3czBTUXpGTnVZWHFYQXlRb0FaQmtTcXBRVkFEQjdFWDFLQS9QVUxTSEhmNUhZNm11OEJHSlJsaXV1dXZWOU5kakxxTGcvck40ays2eHVDRytTMW1jYmk4UzVCREpLWFptUENtcXpIZFdWS1NTTHY1Y29XckIvaXIvRW1EbEY2RGY0YVlnTmVSRTFmRVJCUVR0WnFDSFB4UXYyZ2FzYWN2cFNnbWNzYWtOMDJnYVU1RTVVUkJZWnFBMjRRZ0pNWitBdnVicUNmQ0ZLTHZ5WWNRelhuSlVVendVeVNuV1ZSVW1OUzhGMzFRRENWY0lTaVUvcWRCVUFNOWRBbkpCTmEwQ0tsUVNWeW1GQW9CV0RTVEExUE00TkFoSmMrcWtpNElGQWYyczZZN3pOZm9SN3BhMDEzMkphVk9zOWRyeDU5MHlVT2hYeHVaSEthcFBhYVNjNE9VSHNTdkk2YWVPYzhzZjVxY05HTjQ4amtsaVpIbmk1ZE1JL0dxc3FaWnowMEk4NFRncGhoU0xxYTlNRVhGeERRQmJnS1dPTTAwd1FjbHFBWHNQU1lpQkE3d2dYRXhXWmI5UlBEY0lDaUtTc2s1RnI5VERqRW5PazlRdXVyQTc4YWVRbEplT2tKSXBSOHBEdXFuMmNDOVRTMGtacnU3Qjd4M1dKaFNCZ2UyU2trVUVxN3ZVU1hOVittZkZNbklYZDh3Q1VITmxUOXBlbnVMbldYMTk5SW1wWUtJcXVIUVc0UDhEVkk2amw5SFRNREhreE5RRGpiWU9NRHFSU3YrMENBbVk5THo4NXlDSUtKcGJ3Wk5NNEtvcUtEcXljMEl5d3dFSVNsVlQ3d2dlSUlQM3BBVE1JdDV6NXMrVCtxSGN1S0RpdjJkSWtFeFVlSmNKMEVSSkFSa0xIMm9vL2lBb2FKK00vWUlxUWhxd0Q0aEJVTklTU1ZKeEYzZGFmWWVvaS9KaDVpOXdic1pnV2J3RkRNNGhPa1NmVW56dGZRbGFlVGQ5UTN1SW4yU3JyR3o3TXAwbDBhWXJVakpaSEtvaWNoT1c1V1V4bEVhcEhRS3Y1S1lnSzhscC9xbHE4MTZ5WVNuWmp1cUpQOXRUbEY3UkE1K2lrUkUwd1NlWm1DYXdiY1o3T0swcXFjZ0FSS083N0hQRStzUUdoejlUeUgremNtNURNd1RZWExHQnlVa1pRa3FtZmlvREpLSTVqKzArMEhKL0ZCUnZ3T2JaQ1FUQlNFeEFEcEFTQXdob3R4Uk5tY0ZqOEVOa2FRbytwRjg5Q1VGVGJ5cVdSeXNTcHF2VVNWSm9FTU1hcERPc2pKdFE4SGQ5WnI3SjZrcW1pL1JuM1NaTVYydXBSK3A0Vk9xL1VyMThPZURsTTdoMXhJVDhFSnlrcTlMaVlnb0R3RG9pQkk1NmNzVkxBRzExSk56S1MxUlQvSVQyYWk5Q1c2YTRVVTFZWnJCaHB6WU9jRE5nSnZCeTR3UWJnRE4wRXpsSEFLbTRPRmR3Q3pFZE9HWWtzOEhqc3JKeFQ1T3M3aTZOZ2tLbWFEWWtGSXRrNGFLK3Rsb2ZqV2RnQWFnN0lmRURNQW1ITzRRVWdnc0Nxak1kWmRVa284cXlYdUNwd2tMbk9TM2l4MW00UzdTV1ZZSktmWlJjcGUzNkU5Nit3TzZYQ1d3UWZ4S1NrVFhhNldXcm9YcHpqWHkzTFhVa2gxdGR1VlRNdC84SUtYaitOWEVCTHlHbklqem9JRk8xeEZTMGlDSUlOdTRqZ25Qdm9pcW1JSzh1TGEvMDhxMEo3OWUrejNOTTl6dGdpQWtGYVk1UnU2NW01ajZackNmRWVnR0RoTVlkd1Mrd3pQZ3ZQaWV4SjUvbVl4TjMzRk1hK1NpZ2dvSENVcXpTVFQ5VURJL1ZOVFB3bWwxbE1yS0tEdmdPQ0ZGUDFKVVNUcE14UklJUGt5eFR4S1Q5RWxTMDUyWTdlWTNZTHBLdnlUMUpVVmlVcFVVeWVpdERIQXdwcnY1ZW9VVFVrcWgzMks2UzJhNmlwaHFFbXFSa2gwT2ZaRFNPZng2WWdLZUo2ZTB6SmozWU9aYjBYb2FWZzd6THRtWE1ZaHFLc3g3UlBEM3lyUm5uS3QrdW9DRWxPQ205QmVtR2JqL1RlSGtXT0xIUzJFRzZCWXpSL0Fkamhkd1dEQ0ZnREF4ZkFpWUEySDJrYVNtQVBpSnhiUlhFcFJ6eGdkRkxJRVJCRXpaOTBTMUgycExSVW5aSUtudmdSNFpwY21Lbk9wT3NkbWZsTWtJV1B1UVdvUlVLNlRGSTZva2R2Q1l3QnBwSjBwSkU3Q3FMeW1PbS9TZWZVblh0MG9sNVdFcHBtdlpVZFpHM1VWU21uUC9KT3Mvc3RGM0RYVTBTT20xK0NlSUNmZ2NjcXJEeUxueDRqWE5lL0l5aDlxY04wMXd0em1xcGRzc1FSQnFCaFQxTkY4UWJoZjRTY3g2OHdXNC9SZHdFM2laNFdrQzBRU0VDZXp2WUV3eE9DSUVUUER3SWNSb1BUSHhlUi9qS2l4QnFYSktLb28wQmFDR21hc1pNNU9UTTBFUzlyN0creUEvSFZNZjZ2VUhQZ1M3WkNRVFcrcW85aC9aRkVJTUdGSXFjOXl0L0VrKzVyYnp3Y1YwUSt6Z1NkU1JpOWtia3RuT1hZSDVrdnNsWGE2Um1ON2U0UzVYVVV2dk9ZT0RVVWx1MXVpNkRkT2Q5ay9xQkRZVVBxVk81TjBncGVmd3p4QVRjSjZjRktzSzF2aWVpTGtaRkFHc2lXckx2RmNRay9xV2JuSGFHZE9lYzZLZVpsRlA4d1VrZjJHK0lOeit4cUNJdXdSSFNQZ3MvQVhzYnZBU1ZnNTRoTEFnaEFXZUF4YkhtSDJNMUNzSVNreDhreWlveVFHZXhNVG5JSm5NSTBrNWwwbUtyWXF5OTg2cUtETmZFMWY5aFA2NUwvTURzT1V6S2lZUGtKR3FJNnVRNG5RMjJXMWxBcS85U1VzZ2VLYllId2t4R3BXbFh4TG1hNHk2bTY3WmJEZGZnVGtTVXVxWGxFanByVlJKdHFQc2ZJbG1PdzF3cUV4M1RSOVNxN09zblRhTnkyYVFBOUFsS3NVZ3BSTC9GREVCTHlhbktpakN3aUdQNDVTeVJsUm1PK3RUVXRQZUtnaGlrdkdiNUVPbzFWT1k1aFJTamttSWFMNUk5TjRGZlA4dmVKcEIvb0p3bjBIVEJjSGZ3T0VPc0VPQUEvR0NPUVI0QkN3czVqMG5Dc3BGRTkvazFncHFrbjVRbW5QUFdaSnFxQ2o3RzI4Mm1qS3BOdmNCZzZnZVFmc056d3U0TTErVGtaYlpEQTJxaGxaa0ZISkhXWTM4dEVsWEMwTGkyUG43dmhBQ1l0YUc0S1lZYVVjUzRDTkVCSGNGcGtzMjIxMnVrb1ExRXBEKzFtWTc5UjBWQVE2WEM5dzBGNmE3bmcrcGpyaGIrWlRNZDF5b3B3MHpmdEVvN2VFZkppWGdIeVFtd0pDVG9wTmJUOHYxL1dpWnBoaUlMeVV5T1dsa25nWkhjRVZJTm5KUFgyZ2xKU1VoRzUzbnBnbGVrcnE2ZVlZejZzbFBmMk1Lby9rQ211ZXNtdVlMY0l2T1lwcHY0UHRmMERTRGx6dDR1WURDRFVRMytIQUhpZS9Kd1NPRWFONVRCVFZOU0VwcWNzQXlNV1puRkJTTGVqTEVwSCtxb2dnUGtKUXBhNWtCQjFHdHNVZEV4V1NIaktoQlJuWmFjOWxaUXNyakpHV0Z0SmpNSXhyNmJaV1N0d3BKdWpwd010MU5zVS9TZkFWcGdNTjhCYzF2aVpCaTFGMVdTRk1LQjcrV3ZpUWR4RThIOEp0TnBGMHY2dTVBV2lHcmxrRFVKS1dXcVc2UTBqSDhrOFFFb0hqd0xRWDFGRGt4RjZURTVtVnNoWklITzkvd05ZWEZCRURjSkZydkZzUEhhWTUvNFM3UmVwY3IvT1dLY0x1VzVyM3BBbDV1Z1BzYmxaVy9TSURFSGVUdllIZFBwajNpQlpNUDhCUXdNeGRtdnNrRGZqSUtLbWowSG1XQ2NxV0tJZ21ZVUxOZWo2UkE0cXVERU5ZVFJHVVcvVXAwU2FoYTJDTWlvRlpHY1lKUmtsSFRkOFF5a25KU1NXeUNHMndxb1dnU1RvVEVsSHhJVmlIVmhJVHBBcDR1a1lna3VBRnpuRmNpVWxKU2xUU3JPcExBaHVSTG1uUEdCaHZnNE9aalExVHNaWEt3NGVBclVtcVk4UWNwSGNNL1Mwd1dQZlBlbytURXFZZGhodTJNV3hPU0phbVdLUy9jN3dpTEpucDFjTXVjZkUzNjRjVFE4VnVNNnBNd2NxL212ZWtTelh2TExmN2UvNEtYTzBqSmFybkpVQnFSb0NoRUJSWGdFVUtBQ3g3ZU1SWWZNRTJVbFpTTGxWSHMvOFE1ZXMvRm9UVW1CN2lneEtRQkU5c2twYW1RVnZmMktGRnBlV1AxYXZHUHdDWUJWU3R3bzN5WGlMaGFoclhaVHNmN1N1cW95djV0aDZUd0hoSjF4L0NCa3Y4b3NJdS9jQjJGZEFHbTZFdUMrSTlvdWdKQ1FEUmZveS9wY3BWcGE3cFRoWFNCTTBFTnpwanRVa0JEUXlYMXlNajJUK3BsY3JBTnlsYUFnMktRMGprTVloSzhrcHkyZ2lKVy9aM2toZWRHUzB4TkJGN0lLU2tvL1ZodStTTUs4d1grZm9HN1hlRG5Xd3FLY0pjTC9PVUt2bDNoYjMvQmN6U1I0UDRYZkwvRWozKytJU3czMEJKOVQrVHZZTHJEaHdXZXZVVHZlVGoybUZSQkJjTGlHSk1vcWNYbGdBZ2xLUjJZTUNtb0FCTWcwU1lwUnl3S1U4czY5N2xIVkxKQzgrdmVJYXpXcmo0U1I4Nmp0M0thcmU1RGs0aGtBUU1wMnRUMk03TEJETGtza3BHcW9wVDV1L0FkVlVsWDdTQitUR0xPYzlGa3h3NEJNWjFXZ0hZTXo0UVVHMDlYd0YwQUlSLzFJY1dnQmpIYjZiU2E3UzZYU0ZEeW16STJtSDVKUFpYVUNuQ29RNzgvUEpORHVYeVFrbUFRazhHajVBU2lSRVpKTFcxa2lsRHpIaEdCUTlna0ppMjN2cWV3U0E0OTU2SkNjaFBDNVI1RHkrY0wzUDBDZjcvQlhXYjR2NWNZOERCZlFKY3J3dTB2M0h5Qm55N2c2Uy9ZMzRIbENrdzNZTDVGVmJYY2tva3ZjQnhXdzNFMDhmbmc0VUxBNGdJbUVwT2VqK3Bwa3ZSR21hUTRoWmFyaXJKbXZscEpFUmpPRVRSNFFtOHQ0VUdpU2cvUXJJZ04wakVMVHBIR3M5ZzQyR3BSUXdrQm1WUktSZFFtSXAxUHlnalduOFJnNHplcUU2d1d2cVJDSGNHb3BUaUdValRYVFpHUXlNVUVxektFaXpYWnFVTENwQkdtYjBrVnFVSlNkYVRFcE5GMnpwanJYUHFkSC9JbHRjeDFINTNKSVU4T1VySVl4RlRoRVhKSzgvSzE3MldLMEw4VXRVZnRBQWxMVE5iM0ZKWUZkTDlMNWdnSmpyam40QWl2L3FoWjdPcENVT0Z5UTBqK3B5dkMvWXB3ajZhOHNGeVNnbUloS1BoN1ZsRGhEcUlaZ1JjUWUzajJjTUZqRGpHY2ZBbU15Y3NnaENhMGZFcm1QVFkrcUlxa1FycDBHUjhLSlRGdEVGVXFNMHhsaVd1VHNOTERsVjl1RjM4RXVxZlVVMGEyak5mVExkTWNVQkVSTWlGWk0xM3lIekVBRUh5STc2dzNwcnU2TDFJdzRkK2VLWm51dkpyclFNbFVwMlk3VEROWUVxNUNDVWtVa2xQejNSeUpoMVlLU2Z4SWFxNnp2OWFQTkJsRlZCSFNJOE9kai81Slg0TkJUQTJjSnFlOXpyaVZhYThWdGNmbXBiYStwNVdTTWhGOFNsUitrVmFmQ1k0STl6bm0xNXZqcjV0bStQdU1NRitqMlcrK2dPNVh1THVRME8xdlVsQzBYTUZUOUR2QjM2T0s4cEdnaUJkUThBaTh3SWtmeXZrQUI4WkVBWTRZRTJuZkp4TVVJUjF6azVKS3lvbVNZcHJVWjZVcUNsbFpCY29OVENJdTFCTjZaSVg0TU5KMnNvek5Pa1hCSjJMdmtIVnZocEtBdEl4VnJLZGwxcjNaSkNMWnJ1NkRwTVNrSnJ3UXN1bXVHSTdDemt2SWQ5eDJnaWVYa2drenBrb2hYVUR6VlFoS3pIWFRGWmptYUxKVFFoSmxud0liYW9Xa3c1bGZyem5rVzlYU3ZDYWxJNEVOemFBR1YvWkphdnFUZ0VGS0g0UkJUQjI4bEp6cS9rNk5xRDJybnV4TDNpS21vdC9UTkVYMXRFVDd2WnNtdUxza2ZMMWNRRGZKb1hlNXdOMXVDUGNiL0gyT0VYdjNXL3F6Q2lxUzB3MjgzSUhsRHA1S0JZV3d3UGtGbnU0SXdjZjJzZmlqQ0VKTXpKR2tIREJKMkhoTlVxcWtDdlZrVkJXaDhra2hLNnQ2SGpDcVN2N1RlWDBtK1JuS0JKZnpkVTNSYzJHZHFWSmEzZVZhbTdlSUo1WnpjNTBWY2NsL2FwckRCaEd0Q1NtSGZiT29uMVZRZzZva3B1UnZpa0VOVVNGRk1oTGZFYmtZOFRsRnhRUlJTS3poMzlORm91eXVKU0hOVjBORWIxa1JHVkt5MFhiWlJOYzMyMjFsLzI2bEVlcEYzUldrcEExT1lKRFNCMkVRMHdaMnlVbm5xKzJVbEZaK2tGN1VIcTE5VDBwVTZvT3FQeUFsSlEyRThNdVNvL2ZFcEJlV0pmWjFtbWU0KzF3RVNManBJbUhsZjZONTczNUxDa3JKaVpjYitIN0xQaWhSVUZqdUNPNE84QUx5QzVnWFVGZ1FPQkpVUUlEbkFNY01Gd0ljaWFMU29JZ3F2RnpKcXB6bXlnZVZpYW9tS0NmejNwQVZJTVFrcGtCOVRsbGg1WHZmQzVhb3E0ODArNlRDSXBTRWszWnJUWFJWV2RPSHhFaWp4R1pUSFJkbXU1cUl0cUxzUXVEVVNkYVNVZklwd1NFRVFxQkpNanNJSWFrcWtnZzd1RXVjRjRWRTgwWE1kQmZ4STBXQ29tczA0ZEY4RlpQenRWSklPY3BPeDBaeTAxeEcyeWtCU1c2N281MWt0MVFTYUIxMTExUkx3Q0NsRDhJZ3BoMXNrWlBDRWxCZDFpS25sV21QZWFXZW5CSlVDT0FRaWc5RFZWVHdIa0hJU1VrcTNPOXgyaWdvdWtrNHVWK3k3MGtWMUh5QlgrN2creDFodVJVcUtpeTM2Ry95ZDdDUVZWUlFkMlBtRS84VEIxQllBT2tMRllNbEFnalJGMFZnVE9LUElsOHFLVWRHU2JYNlFsVkVSV0lDVE1TVXJTcUZtbElTcTAxOGdDM1BySlRXUVQwUjRYcFZpaTN2a05ZWjA5MktmS295Nno4aThJcUVldUhlcW5UeXJ5R2ZSRkNjZ2hkaTlnYjFHOFUvVHNFTUU5aEYweDJtNkVkU1FxSko4OXJGd0p0SVRCZmpSNXJoNXV4RG91UUxWVk5kR2ZhZHpIYVZRckxSZHZWSXNsUXBvOE8rSkxWY0dETmV5NWVVSHYwZ3BRL0JJS1lENkpHVFdmNVUxRjRmeXVhWUFBQVZvRWxFUVZRS21xQkc1SjRRa3k2akVQcm1QU1VwVlUvVEZQMVBia0x3Qy96OWppQWZ1TC9OY0tLVTNPMkdjRmtRbHF1b3JreE9yTCtYU0VKaHVRRnE0bHZ1d0N3RUphVEVma245b01BeHhEeUVCWVNBd0FGTENKakFXRUtRTE9VTUI2dWthbEtpY2o0cEtDN0lKLzVtc2dMeWZ2UVJ0RWhxcGFEUVYwcUJzQ0tyUTZoSWh5aVhzVjJGemJ4UlNxcUV5bmxkSjQ5NXhBQTR4QWFQamF6TGlva3pNU2tSVmVtRFFrQTB4YWt5aXJHUzBYY0VWVVl4OUJ1VEJEVzRTUWF0akVURTB3VTB4ZmVMcG15eWk1M0JMMEpLK1k5TXpycFZRSU14MlJVS3FSUDJ2Um9uU1UxMkIzMUpSNlB1OHJ1eUpxb1ZCaW1keGlDbWczaUduTkw4VnRTZWtoVnQrNTVZaWFyeGNhbUMwcHg2S1hwdm1oRDhuTXg3L242SEV3VVY3cGRFVU9GK1I3Z3M4UGVMQkVuY0VLNTNrSkFUL0FJbjVNU0xxcWhGL0U4THdJdFJVVkV4K2JBa0plWFl4NGcrQkJCN09BNGc4VVZGczEvMlBTbFpPWk1jMWtiMGxXYStuQUxKbXZsc0FFVU9ONmVDak5ZS0NxbWdya21NYStFVTZsY212UXJGT2x5c2E4bkgrb3hxZGFTdlpFRkFWaW5Wb2QvQjVMWURpWG5QaVZLSy9pSVdNZ29RTTkwVS9VWk1rWlJpY3VBcCtvMG9qZ0VHTndOelRManE1bXl1aXhGMjBYU3N5WWJkSlp2dU5FaUJqREpLV1JwU2x1K0toQzZsUW1xYTdleTM4WUF2YVl1VVJ2K2tqOGNncGhONG1Kd09SdTBwUWUzMWV3b05jbXFwcU1ML3RDeGdQOE5QUzBGUVZrRkYxWFNIdTE4UWxqdjhQU29vdnR6RnRIY0grd1h1Zm9OZmJzQjFpV3BLaUluOUFscnU0UGtlNTRXVTJDOUE4SkdrMkdjbHhSN2dFQWtyaEVnMENDQXZTV0FSVXRSZUlpeE5FRnYwaHlySnFpWW1hL0pUMHgwWjRxRnEzajQ3d0t6bjVMbWVrRTFjU1NOVlRGMmZrV3lYUjRPMUJMVU9ZbURRS3V6YmRvb3R6WE15bjdZaFVUOE96SVJBTHFzaGNnamtBQWxtWURjRGNERWhzQVl3dUJua3BtaXFjN01KWU1nbVBGVk5icjZBSktKT1V3UGxzTzlMTnRYSnJ4SlNNUjVTTlJ6RmtkRHZoMzFKcWNVeVNPa3JNSWpwSkQ2RW5JeGlTZ1JGKy8yZWJJaDVpNWljS0NpYUp2QThJM2lmSS9na2hGeE5mRmxCaVdwYTd0SEVkMTNBUW1LODNHV2RXMVJSeXgxT3lDa3N0eGdJc1FncExURjZENVdKTDNpcnBEd0lIaHdpV1VYQ1lqZ0tvQkFpYVJIREJVNkJFVW8wZWJEQ05WbEYwMTd1cUt1a0UrOVZTVVF0eFJUTE9KWHBUNjVqZUdYdWE2RVpPZGRZcnFTVHBnMVIyUTZ3YTFLcTFGSXdCQ1ZxS0c3dmpGSlNNb3IrSW9hTEptS0s0ZDdreEdSSExxYXpFaktDcWlLSnFFTkZTRkVSemNsTVI5T2NmRWZaaDZTK0lUditrUWxxTUNZN0c3QmcreU4xUTc0YnFZTldpdWlFTDhsK3o0T1VQaCtEbUI1QUlpZkZrMUY3UkZTWTgxYkJFUTMxVkFkS3RNeDdQRTBnNytHbUtacjVaRG9wcUhtR1g1Wk1TdDRqekpGOHB2czlSdTB0OXhqZHQ5d1I3bEZSOGVVTi9uNFRuOU1kZExuSC9sQStMb2VQKzRDL0E5N0hvQWtmQ1NvcEtLOStxQkFKS25nd1BKZzlncGo0Q0FFQklRWlJjSUNUSm45T1l4Uk5ud1JEVWk0cm8waE9WakZ4UVVoV1RlbDlMZ2pLUER4TFl2VUR0YlBGbTVCVVVmbXExSXFKYTNVRVMxRGNKQ1ZMVGpuYVRvbUlaQjlrVkJHQk9UcndBbVcvRVpNRHc0bWZLQTRxR2NqRllWU0VqTkwwTk9WZ0J2RWpwYjlFUU5ka21zdWtwR2E0MG15WHpIU1ZEOG1PMnR3eTE2MENHdmFpN1RaSXFPdEx5aC96SUtVdndDQ21CMkZmdkphQ09oTzFwK3R2QlVlc1NNbTVTRVppMW11YTkwSklwRVRlTnhXVUU1THl5d0wySHVGeWlmUHpIYzdIWlRFZ1lrRzR5SzlmTUMxdldVVXQ5MFJVenZ1WUlOWm41Y1QrTG1Ua0kzR3Brdkl4UUlLRGo4dUZsQkNpL3dud2dKQVdJZHFvS0JHVmVFS0lrN0lpeWxra2dHait5K3FJRS9GWWt4OWdTWW9MWXFyOVRPcXJRdU41dHNCbWdrMVpmTzdyQktwS1VFRzNrZklRWkRrb0thSVUrSURZcUFraG11Y2kwY1J5d0NWU2dwanBtQndnNGQwZ0YzOWxQY2dveUptSW9pOUp4L3FLSnJ4SUVuQnpvWWFzUW5LR2pCSVJpU29pRzhSUUt5UlZSYlhQcUNJbFMwd3RIOUtLb0pSd1R2aVM3SGM4U09uek1ZanBCWGc2YWs5ZzV4bFk5WHV5dmlkaVR1UlVFNVFsSmt0V2JENXFWVkJCQ1VySngvdG81ak4rS0o0dnllVEgza2QxVmFtb3VQMDlrWXdTRmk4TGdpRXArS3lhZUltK0o1YkFDUTVlVEhoeFhDaUVHQ3dSaEp5QWtFaUtJREpCU0NtU0ZtZkNBdU9PR0VRUmZVb3MyeWxKR2ZLcFZKU2FXMlV5L2RyK1VFZXhJaWQ1eUVWUVEzNDFrSktuRmdvcW5pU3ovTWxWQkVRaWdwWVpOUVJRSnFLa2ppZ0dMU2c1elROQVUveHpUc3h5RXN3d2xRUkZvcGFjcXFQQ1ZEY25ja3JLUjBuSG1PbElPNENMcjRoYzVTT3FmVWpPZGYxSG0yYTdsdm51Q0NIcHMyK1k4b3I1R3VYeVFVb3Z3Q0NtRitIWnFEMmdOTy9wTXR2dnlmcWVJUE8xLzJsU0pkVWpwbW1LWmFxZzlFK2krSlNjaWtBSjc4SGV3ODJSZUlMM1dVVmRSVkVKMGZnbC9uS0k1V3JlVTVJaVZVckJ5elpDV3Q3RGhVaE9Ta2h4T29CRFhBNko1b09ZOWlEcUtnZ3BKWEl5MHdCTEh5dlZISHF2YlFSZlZrcE9mcTFpMHRRL0FLMThTNjFhcU9kTDBtbVNjVDFLUXRKNWw2ZVJLOHNRZ0Vnd2hsN0pDY25Fd0FVSUNVVjFKTXRGRVlHaWFUZVNrUHhPZWRyTlVRMlJteElwa1NpbWdveW1lVTFHS1VvdUV0czBYeUtoMkNDR3BIcXFLRHBEVExVUHFWWkhoNlByR2lhOG9aQitGcWpWQTMzZ2NYQXJoMHk1M002Z1hEM1phTkkwRy9OZVhhYkVVMC9Eekt1SkwzaWZ5NFNNVXJrbEtGM21mVUZVY1gxWm5zbzEycy9EaXk4cTNGVTErVWhTaWJUa1YwZ0lJVzZydnhwaUR1L0Z2QmZFRHhXSkNpeS9JWk1TQzRFcCtiRDNjUm15ZW9xMnNRQ29nU3N5alpCWFZsRktBNndoNS9KTVNKK1RKYlVUMVZDT2VkR0dDUURuY25nNGtUQVpHV1VrODFSb1BHUXlrcVMvSUlCbXdCbVNRbFJGYWQ1WlJaU0pTRWtuRTFFczB5ZzdrdUFZV0RLYU1ra3BvVVF5bVEwcGlmbE94d3RUMG5LVFdiODB6L1hTQlQya2tJelpyaVlrZlE0dDVhUVlwUFE5TUJUVGkvRUszMU5hcjQ3VWF3UkhhT0JFOGozSjhrTUtxdVdEQ2lFVGxhZ2xKWjlFVUplU29EaGtYNVVTRnF0NThMSWtRa3NrSmVZNzUzME9NZmM1ckR6NEdMSEhmZ0Vab21LdlFSSkJDRW9qK29LUWNTVEVtQTFCRkZWU1YzTHZLQk5XSWk0aEtGVkdTbG9pbDVCSVM1OVhJV3NiRFRzRzBtaUg4V0dXejVkelJhbGtSS0p3MUZqSTZWMXhtYkFvbStoaXBTcmtNeGtpb2tnMnVqOElJYWhTS29oSWlDb1JrcHVrejVFSmFwaW1ySXltS1pHUG5YZHVLbnhIaFRxcWlhY0s5KzRwb2oyRnBFcG81VWN5S21rVjJKQS93clY2V24vSWc1UytFRU14ZlRCWWs1ZjFseGVWVzB0QjFVcXFMazlwaXpwcTZveUNxc3Vzb3VJUVNnWGxvLytuTUFFR244eDVRWUlkVkgwcGNRUWhwRlNXeUN3U0dodnlTa1RGa1l5Q2xFWEZGRTE1OEI2c3BqMHg5YVZRTlNVbUNUK1BVQVVsOXpDbzJjK1k3cGlqZWpMM1BmbWc4b3BJNDByVWNLcDBaUFdraENBK0xLdDZsS2hNV1RMalpXSktSQ1FWYmxaRVdSMUZFbktKaENpcEpNb3FTZFdSS0tjMG4wZ29rNVVyekdzYXpKREpLUG1OYkFTZGtwWVNUQy9NZTR1RWRrSy9lNnJvMldpN1BEbDhTVitKb1pnK0dJLzZuaFE1aWl1dnY1dmE2QWtGcFgrcXBGYkVkYmxrdFNUazVLY0ZZWTZFb0lFVWliUzh6eVNseExNc0NNR0RGeSsvaXh3M0U1T1NGM3NQNTVka3VuTWhteFdkbU85WWlZc0RPSEFpTGlVdkpTMHVmRkRSUE1mYUkxWHVLU1d6WFhUMGhCUjhIWkZEK0FFRTlmdVo1MmxtMkZaazZSbkd5akNrU3RGMG5rWW1LQUJDUUtLU29FVGtRTVZ2Tk5NVkpLU1ZzdnFNS0MrUEVYV0dpS1lZQnU2Y0pTbHJZbXNwbzJsRlNKQnh3WklwcnhmV3JRRU5sb0RNL0JHRkJFTStXMzZqNFV2NnVSakU5QWs0VEU2S0o2UDNFa0dwbVk5TnVEbHovS0Ezb3ZnU1lVbWdoS3ZJeVlXUXpIeXNJZWVHeE54OEtmeFJTbEtxdUZKa24vRmxLWW5vY3ZZK0JsRDQ2RnVLcHJ3NDcyUWVITExLVXA5VHlQNm5TTktac0p5cUxCamZrNmdsdHVZOFZWTFdwSWVzVnBOYktBQ002cGtXc3NxSVlTRWVqYXdrUTBnd2hGUVFGR2xGYkV4M1dqSExDTVpLT2twT29GanhrMUZOYnA1enVTbkx5a2dKd0txYkdXNlc5Wk9pcWN4eHJxRjh4S2QwTkhEaFRHTFZMWVcwV1NiM2YvaVNmZzZHS2U4VHNXZldNK3V0ekh2Tm9JbWQ0SWhWbVRYdFdYT2ZNZkZ0bFcwRlVLUmx0UWt3aE94anNnRVhvVlJkUVFJYnRBejFkaHlTOGtvK0p6SGwyZldoS29xektZK05LVStKU1luTitwZXN1WlRrL2dEbGZjKzZwL0ZjVUxiRTg1S3FjcXhOZUVKVUlFb3FpNFJJTXFFNW80eWlpbEt6SFltZmlRcFNjb2xVU0JRUnlCbkZZNGdva1VRWm1LREhzZ3BLbFZGQk5vMGdodFBrODlrS0tTOFlwUFFOTVlqcGs3RVh0V2ZXc3pOTjM1T2RQa1ZRSFhKU01sS2YxQlpabGNSVGtsWWlxMlNpeStRRkRqbkFRb25KcUNVbG1SVlJjUUQ3a0pRWEd6TFM3Wk95MG5Malowb0tLL21heEl5blpqM3JsNHAzMXR4bnpzOUxUSDNkWjdpcXc4UzRaeXJWdEpsVlRMbzhCVU1vdVFnSnFUcWFwcnlPSVE1cjNpTkxVdm9ueTFwRWxNaEZ5V3BTLzVFcnk2d0ttdWVTVkRySzZBZ0pGU0hlenlna1lGV2VIOHZ3SmYwa0RGUGVKMk12YXMrc0I3UGVVOUY3VzJWcVdpb3lTZWl5QmpGcG1mcWczSTdDcXBYVWFya2hFMHRDU2w1cFd5VWFMVmYva1E5bTJwS1VrQnNiSDFJd0JHVkpKK1NRZTB0Q3JOdktmQ3BmOVZUYUFNc3pjazRmbUhtMnRDS25wSjVVOFZoVmxjeDFocmlTaWE2cytFRXUrWE1zNlVCSlFWV1JtQXV0VDRoYzZmTnhodHk2NUZPcHBLUEVWS2loV2hHZFVFakZkMU9UVmZsaERZWDBBekFVMHhmamxJS3FWVk5qMlVzVWxNNVhoQVBtUXlhL1h2UmZzYXp1UnlXRWtjeURscGdzOFJUN3Fja3FLaC8yTnVnaFg0dWE4R0puWFh2ZFpqMzdtNTdKK3Y2ZWdsU3lNbE8wN290bFZLcUZySlFpV2RFMEZjb3JLaVpLNU9TY1M4c0xFaktLS1JHRE5lblJtbUJLRmJWV1JvZlZUMFZDdGJtdUpxVWo1cm1tUXJMM3VsR1dKd2NwL1FRTVl2cEdPQnRhYnNzUCs2RE04azJTcXN4NlNsalBtUDk2WmRiL3RGck9aanREV3BaazdEbEU4alNFeFN6cVNkUVFzNmlzU0RoV1RWcFN0aDZpWkJMTUpUajYzUkJWZ3poWllrRlo0WUpLdFZBc0F4WEVrMGduQlVISThpbXFMS2VtUDYzNExabFFnMkNJVnNxcnFYUTJsQkZSUlRSbVAyZVUwU01LeWM2ZkNtd28xeHVrOUUwd2lPbWJZVTlCMVFUVUt0OVVVR2JiTFNXMTZodFZLYW1haklyMWVvUzB0OXlXZWQ5V2FCeUtjeWtVbVpLTm5udDlUTlpnaURVaGxmZW9VcWVCRy9mNndIZFQrSkVFemduUEdCT2VvQ0FqcmZ5SkVzSFlZVTdJRUlSRys5VXFKeW10bG9JeEpyNFZhUnd4eVRVSWFFVk1adm9SODl3WmhaUm5HOFRWUTduZUlLVnZoT0ZqK21iWTgwSFZ2aWRkWG45WFBSOVVXbTRxWmwxVzlJMGlFMTdPREhhdUlKK1dMNm9tSjNxV3ZCcnFiTFd1TmRQVkpGUXB1clNPTEt0SnVTWndRamxmM0Rlcy9YNnQrOTlxc2NlSzFoWEwyS3hicUJlWlQrU2psWFZGQ0pCOWRoV0szZCtPbitkSURyb1ZNY2s1SFBJZE5ZZ252YXRiSkdYdWFYa3ZoMEw2YlJpSzZadmprSGt2enpUTG0vNnBXa1h0S0tnanZxaXVLWENsV2lvbDFGaStJcTFHK1VydHRNNmpVbGdGTWJYdVJhV0dla3JUa253WFVrSFhJRlBwTWhxVnJCSlRxeEkzNXIrdVdXektRUk85NFIrMnl1dDFXc2ZiUEg2MXo3Tm11YVpDNmhET1VFaS9FNE9ZZmdEMnlNbXNkOW9IdFZxbi9nV2E1U3VTcWlwL0paK3RkYnErcXg0SkhUaGVsN0NhQkZTYTVlcjluYmwvTldpSGxQb21xWFdsM0t6VWpRSXFsTllCc3RnbHBTMzEwMW5XUFFkN2JaM3JPWHB2bWx3eUZOS3Z4Q0NtSDRJOTM1TlpENjMxamlnb25hNkpTZmUxcGFSV2Zwb045YlJKTWx0RXRVRnFQUkxhT20vWTdhdnJySysvdWM0RzZrclhsaDlWQ2l1MVVGWCtxNHErUVM0dHBkTmF0eFdBMEJ0MnZIdjhlcnQ4Z1YxQ2FxcWplbHJ2a2RsZnMzeDlzKzE2ZzVSK0VBWXgvVUI4bUlLcTVyY3E3SlhxMkNLdWxsbzZRaVlkOG1sdGwvMUlCODZuUlZMVlBkdTZkMGZ1UFlCK2EzNUxFV3dSMW83eU9FeEtCNGludDc5RDUyUFVVazFDVGZYVHVmYWhrUDVkREdMNm9maElCVldYRlNSMXNFSS9TajU3QkxLcHhGckVaNjcxQ0JtMUNIWjF6ZVdOMlZWTGlsM1ZsQXVhU21HelVqOUlGSWVVemNZK05wZFY1N1dsakZiWHZYVVBkTDltV2JOOGZXUHRlb09VZmpBR01mMEN2RnhCNVFXcmJZNmErdXp4VGltWHZmV3I4K29SMCs0KzYydHMzSi9UOTh2Z2NJdS9WU0YzaUdsVnFUOUFWRThyb3ZxY2o1RFV4cldmdmwvOUd6N0k2QmRoaEl2L0FoQko5bkpGcDlJa29tYnZtOTdYekxwTXZuZG1IWTZjMXBXMnpKT3B0RW0zYVJBRThUSHlhaEZlYXp1dVRIbGRFdHNobnhYcGRJaHB0eUZ3c1BXL1YzRWZNdkhaYlUrUzFZcjR0clo1NXJ4NjEzamdIblV4Rk5LdnhTQ21Yd0w3WVRLTzVlQXo2MitTVTlvMjdrQVdiUGVMU3Rzb0VXRk5VbmJiczc2Z1F3cXRXbmR6V1cvZVhwOVo1eFMyS3VPT1d0TDVRNVcvUGNhT2dqbERPRnVxNk96NXJ0WTVlYTg2NncweStxVVlwcnhmQ203WHJsdnJOOWZyVnRJZDFYRzA0dDlUUUdmSjVzeitqMXhIZmIzUGZpZXZNTzNaK2RZNnp5aXJSL2UvcTRaYSt6TExXdmVwaTZHUS9oa01ZdnFIOEt3dnlpN2ZKTElkMDlqS3pGWnR1NldvV3VzZUlxeU40KzFkOTFjU2syNjdwMEwyVk5UcVBEYk1iV2YyMzl2bTlIWHZZU2lrZndxRG1QNHhjRmt6YjYzWEt0eGNmcVNpUDZXb2pxeHpWTG50N0t0MWpkMXpmZ0JIVk1OVzVYNVlxVHlodUE0ZDd5VFJiRjVURCszMUJ5bjlReGpFOUEvanFJSXk2eitucERybFozMCt1OHJxbWVPdkwrcHBVcXB4cExJK1NsNjc1clFkRWpxNnp5UG5QcFRSd0tzd2lPa2Z4MUVGWmRadkZXNHUzektSblZaVVZmbVpkWStlMTlIbFQyR3Z3ajZvUUpyekI5ZTE1YnUrb3BQbjFUcWZMb2J2YUtEQ0lLYUJoTE1LeW14M1RrbmxCZVUrT3VXSHllWWtBVDE4M2kvQXc5RnBCeFJRYjltV3FqbXl2NzE5UE1RcFF5RU5ORENJYWFEQTJXZytzMTJyY0h1NVhYYVNPRTRSMXNhNWZMWVpUM0dFQUZyVFQ1UElvNFM0Yzh5enlzaHNOMGhwWUlWQlRBTzcrQ2dsWmRkN2lOZ2VDVlE0UXpaZlNFeEgxdTJTVnk1c0wzOUVFWmx0aHpJYStHZ01ZaG80aEpjcXFjYjJqeWlxUjlZN2JaNDdxcTQyc0VjYVI3YmZyZE5mUkNobmxOeldzUnJiRFZJYU9JeEJUQU1QNDFFbFpiWi9UbEd0Vnl6M2ZXQzlJOGMrdE04TmRJTUZqdS9nMlBiUEtDR3pqNmM0WkNpamdSZGdFTlBBVTJncXFiend5UFpIRG5LS0ZGNFZUZmVsVVhrdjN2Nk1LZS9Jc1RlMkg2UTA4RFJHcnJ5QnA3QlZFVEg2T2Z2TTlydkhZS0NieTI5cm0yZEJ3Q21UMi9rRFBMN3Z3d3FvY2N5aGlBYStPd1l4RFh3WWlLcXM1elVPcWhHaWRsYjA3dm9uMXQwNThLdjI5SEljVlVDYjIrMnYzTnIrKzk2VWdWK0RRVXdESDRwbkZaWFp6K0ZqUHFLd2ZpeWVWVURiKy8xbmJ1UEE5OEx3TVExOEtaNzFVVzNzOStGdE4zYjYySFlmV0w4L2FzNDdzTjlCU2dOZmhrRk1BOThXejBiOXZSb1BCVU44bEtKNUZFTUpEZndBREdJYStOYllWRlRybFQvd1RQUVE1NDd4S1J4d3pzYzBTR25nMjJNUTA4Q3Z3WGRUV0orQ29ZQUdmaUZHOE1QQXI4RnVGT0N6K0o0K3BrRktBNzhPZzVnR2ZoVStzcUkrRTBXWU1CVE53TUJwREdJYUdEaUlSeFRaSUtXQmdmUDQvd0FOQWsvMjQ2WjZsUUFBQUFCSlJVNUVya0pnZ2c9PSIvPjxpbWFnZSBpZD0iX0ltYWdlNCIgd2lkdGg9IjEyMTNweCIgaGVpZ2h0PSIxMDI4cHgiIHhsaW5rOmhyZWY9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFCTDBBQUFRRUNBWUFBQUNmaEdrY0FBQUFDWEJJV1hNQUFBN0VBQUFPeEFHVkt3NGJBQUFnQUVsRVFWUjRuT3pkWFhiYnlKWUdXRWh5M25xcGdkVFFla2c5dEJwSVBYUlZXblkvcEhFZFBvcC9CRWlRM0hzdExoRUJrQ0lwQ1pueCtjVEIyd2JROFBOLy92dnQzcS9oVEcvLytWOC83LzBhQUFBQVdPdXBKN0xBY2I4Q3IyYy9WL3dVZkFFQUFEeVhaNS9JQW9uSmlxMVhPVThNaDE2Q01nQUFnT3Q2bGNrc3ZMd1hxZGk2TlJWaUFBQUFGMlVDREUrZ3M0TEwzL3M1bXFHWFlBd0FBT0QyVElMaHdhbmdlZ2dxd2dBQUFHN01SQmtlUUtPUzZ4Wi94ODkrcnJoRklLVWlEQUFBNElhZWZTSUxEKzhDbFZ6My92NjM4SE83VGZEVm9pSU1BQUJna1dlZnlNSkR1RU1sMThoelB1SVZIMmVDbzVISG5CbE1mWGx1UVJnQUFNQzRlMDlNNGVYZG9aTHI3TzkzaGNxd3N5dTNibDBacGdJTUFBQmcwTDBucHZCU0NoVmRLLzhPVjEzRjhjaHJ1c1dWSkhzQ29DTWgwYXJuWHhsVXFRQURBQUFZSVBTQ0c3bEJSZGVxNTMrRTEva29sVnludjA3QkZ3QUFRSjdRQzA1d1lrWFhiTyt2MlI1ZVovVVR1MnJvOWJOd2YrUnhxL1pOZjI5QkdBQUFnTkFMbGp1eG9tdjJlVy85dU5yejVlN1BtQTJuZXA1M3RnbitMUi9YZkY3QkZ3QUE4T3FFWG5EQWpTdTZWbFo1OWZiZFdoMTZyVDduckE2TlJwK3ZOM3k3UnlXWUNqQUFBT0NsQ2IxZzBvVXF1czQ2L2tpRjJNeStHYXNEbzVuUXE3ZWgvUlVxd1ZTQUFRQUFMMFBvQlFOQ1pkZFpWemc4VXVXMU1zeTZ5ckxJR1dlSFRETVZYaXVydlpaVWdBbkFBQUNBWjNidmlTazhqSVdWWGZldXpHb2ROeE9pOVl6ZDBteFFOQkpTcmF6d09xdkNyUGs4Z2k4QUFPQlozWHRpQ3BkMlVtWFhrU3F2MW1OWGhWNW5McSs4aDlXaDBxb3dxeFd5cmFnaWExSDVCUUFBUEtXclQxVGhidTVRMlhVMGpEcGF3VFd5Zi9TeDkzQmthZUZJR0hVa0hMdFZ1TlpMNVJjQUFQQTByakk1aGJ0YWVCWEczdWM1R2pxVjlwOGRtclUra3l0VmZmVUVRV2VIVXJQN1p5ckFWdlgrY3RWSEFBRGdLVnhsY2dwMzgwUVZYYlh4MXYyelg5czkzRHFRS2gwNyt6MVVnQUVBQUJ4d2xja3AzTVdDd0d1bVY5ZFp3ZFBaNDBkZTJ6MGNDWTVHdzZqVjRkVlpGV0I2ZndFQUFDL2pLcE5UdUxsRmdkZVJ5cTR6S3JacTk4OE94SHIyMzlJWmdkT1I4WHVHYUwzN2U2bjhBZ0FBTHU4cWsxTzRpUU5YWXp5alY5ZVpBZFdSc2RueDNQM2EyRXF6VlZGbmplY0NyN05mUSt2KzZGaUx5aThBQU9EU2hGNjhqQU9WWFdmMzZvcmpJOGV0ZUk2emdyRGUvU3Zjb3FwcnBLS3J0ZDF6L3hhVllhUEhGUjh2K0FJQUFLNUc2TVhUeWx5UjhZekFhMFd2cmhXQjFhclFhelp3eTkxdlBlZEtSeXFnZW9PbmxhSFhxc3F3SS9keno5MXpYUEh4Z2k4QUFPQktoRjQ4cFVWWFpGeFZ1VlVhSDZuYXF1MTdxNHkzdnYrcTZyQ1o4WlhPN01OMU5MQXFiWjhSc00yT3p4NzM1WEdDTHdBQTRDcUVYanlkeWNDcnR3L1ZhTFhUMFpDcE42Z2FEYlI2dG8rODdwN3hsVmFFVzdWOXE3Wkw5MXY3ZXI5WDdialcvZHh6OUJ4WGZKd0FEQUFBdUNlaEYwL2xRT0RWODVnVmxWMmpRZE1ab2RmWkFWbnIvaGxXTDEyY0RiSnEyMGVPNjMxZFI0OHJVZmtGQUFBOEhLRVhEKy9BRlJuMzQxdExHSHZ1cndxOVlqQzFPdlNxamE5NDNWdkgrSmxXTFZzY1daSjRpOUNyTjJBYmVUK3QrN25uN0RtdStEZ0JHQUFBY0V0Q0x4N2F3ZDVkUFlIWGJKZzFjbXd0bk9xdDJPcXA1Rm9SbU5XT0dibS8wbGxWWGlPQlZHOVExUk5nSFFuTlJ0OWpwUElMQUFCNEdrSXZIczZDeXE3YVkyY3F1MVpVZE1WOXMwRlZ6L1AxUHFiM3RXNk5zZHI0Q2lNQnp0RnFxOW54MmVjYURjeU9iTGZ1UjRJdkFBRGcwb1JlUEpRTFYzYk5Wa3F0Q0wxR24rdU1LckRTZG10OGhTTkwvRzRWYkkwRVdVZGV4OUgzSHJXQ0xjRVhBQUJ3V1VJdkhzYUJ3T3N0Zk0zdGE5MWZVY2wxSktocTdaODU5c2pyNjkxdWphZjdhMmFDbHpORHI5R0E2c2l4UGEramRuOTJ1M1cvZDMvSnY0OFZnQUVBQUdjUWV2RVFEZ1plcGNmZG9ySnJWYWhWMjNjMEpKdDVmYm50STRGWFQraTFPdmc2VXRGMU5QRHFEZENPQkcyNThaN1BKYmZkR3UvZFgzeWM0QXNBQUZoTjZNVmxIZWpkVlh0Y2FkK0trQ3U5MzF0Qk5SdFM5UVpadHdxOWN1T3QrN1d4bkpHd1pWVkZWMjU4SnNDYXVmVisvL2dlYTYrbjlablV0bHYzZS9lWENMNEFBSUNsaEY1YzBvTlVkczJFUlNzQ3FqTnU4WDIyOXBlT3lSM1hHczhkdDIyRGdjazJGK3JNQkVlM3ZJMTgvOUo3cSsyZi9meGE0NzM3dnh3ditBSUFBRllSZW5FNUp3UmViK0ZyN3Y1czZOVWJFdDBxdkhvLytQalNlK3c1cHZSNXRjWnp4MjNiT2FIWGJEaDA5UFpqOGZQTmhsNnR4NHhzbC9aRmdpOEFBT0F1aEY1Y3lrbUJWeHcvRW5MbHhtYkRvOVdCMWZ1QzV6ankzbXFmWCt2K2lKNktvMVlRVkJxZnFiRHFEYjFXQlYveGVlTDdQUktTalg2ZXBlMUk4QVVBQU55YzBJdkxtQWk4V2dIS2tjQ3JGZTZzRHIxNkE2dmFNU3RDcjk1Z3JQUzU5SHpHcmZHYVVuaXlPdlJhZlN1RlhxTkJXTzU1WnQ5THorZVNlKzdhTWJuN3ZmdUx4d3ZBQUFDQUdVSXZMbUV5OEtvZGZ6VHdtZ211Um9PeDBjQ3FkVXpQL2lzR1h5T3VHSGoxQkZlMTBLdjErQjhkMzJ2Ris4bDlMcjJmWVZRYTc5My81WGpCRndBQU1Fcm94ZDBjdkRwakswREozWjhKdlZhRlJMT2gxM3ZIL1ZXaDJFendkVFQwV21FbTlHcU5qVlJnOVFaWFBhSFhiREMyNGxiNlhIckcwKzNXL2RKald3UmZBQURBRUtFWGQzR2ozbDF4dkJaeTVjYk9DTFpHQXFsYUVOWVRoczBFWXl1Q3NOcG4zV00vcmpmZ0dBMjllb0tka2FDcForbmlTT2cxR255ZEdZaVZQc1BlejM1MnZFVHdCUUFBZEJONmNYTTM2TjFWQ2x0YUFWZHBmRFRBNmcyMVdvSFZTT2cxRzVqTnZwOVZvVmR0ckJTUzVNYU9obDY5WWRKSUlKV096NFplUndPeFZjRlhUeGlXanBYdUM3NEFBSUNiRVhweFV6Zm8zVlhiN2dtM2F2dGF3VkVyMEJvTnBsb1ZYU1BiTTBIWXF0Q3JGbmlObm9ONmc1TldvRFY3eXdWTXJUQnFKTWdhM1c1OS96T0RzTnhuRzlWK0xyWGpXZ1JmQUFCQWs5Q0xtMWtZZU1Wd3BYUjhER042ZzYzYXZ0NlFhRFNVS2xWNWxSNHo4L3k5QWRySzBDczMzcnFmTTFOSnREcnNHZ21pV3FGWHFRS3N0TDBxQ090NWZ5dENyNTZmUzFSNmZNbS9qeEdBQVFBQU9VSXZibUp4NE5VejNncXlTc2UxZ3F6Yy9aNGdhU2JBcWdWZlp3Wml0ZmZWQ2dsTG4zMDhadXNZVDgxVUV1WHV6d1pBUjRLbldwRFZHM0NOZlArWnlxK1JrQ3grMXJWOXZkdFJhLytYNHdWZkFBQkFKUFRpZENjR1hyVkFwUlY2bGNaYW9WY3BBT29ObGxvQlZ1NSthNngzL0Vqb1ZkcGYrcnpmSzhkRVo0UmVhY2lUMnpjYS9oeXB5RG95SHNkNlg4Tm81ZGRvNkRVU2lNV3hkRHQzdjNSOGkrQUxBQUQ0ZzlDTFU1MGNlQjBOdlViQ3JwNzdyY3Fybm9xdWtXTnFRVm5QOTYxdDF6NkRkTHYzYzgzOWpPTFBxcVluOU9vTmF2YjduNW5qYXIyM1ZnVmN2Y2ZXYnJtd3F1ZCtmQzh6b1ZmcmM4NzlMT0o0TkRwZUl2Z0NBQUQrVGVqRmFlNFFlQjBKdlVZcm5VWXF1MmJDckZKd2RlUjVaMTc3U0NCWUM3eTI1TmpvYU9qMUkzTmNUL2pWV2dhNGVzbGliNEExRW55TlBGL3RmWStHWHZIWXJYQy9GWG9kQ2NSS0JGOEFBTUMyYlVJdlRuS253R3MyOUNvRlBLMnFydDdLcnBuQWEvVFc4N3h2bVdQMzEvVFJlRDhyZ3EvY3p5aDNQNmNXbE94NlFwdHQrek80cVZWQXRjS2xyVEFlbi9PejhUeXRmVE8za2RDcnB4S3NWaG1XL2l4Nks4QjZ0MXZqSllJdkFBQkE2TVY2QTRGWFR3QXlVOUdWRzIrRk5xWFFxMVRoZFhibDFxcmJSL0o5MzhKNExjakx2YjljMEZYNjNOS2ZRZnlacE52djI1Z1l0T3h5SVV1dUdxbTJOREFYN0h3V2pvM2p1YUFwUGZZejgzMTdicCtEeDQ5VWxOWEN2VlpsVnpxVysveGJvWmZnQ3dBQU9KM1FpNlVHQTYrUnBXNGo0Vlp1WDYwYXFSVjYxY0t0TTRLc2p3V1BqNityOXB5MVNyWGVTcmMwd0VxRHJKNXFyOTd6VUdscFhBeTA0dkc1Q3E3OStGcndGUU9uMG5nYWd1VkNyYyt0cjlxckZIcXREcjVLb1ZldDRxc1VodlhlNHM5RThBVUFBSnhPNk1VeUp3UmVvMVZlcFlCbEp2UTZVdEYxTk5qNmFPelAzYjVsWGwvdU9lSllUNUNYcXhUcitWeHJQN1BTZGsxdlVGSzc1UUt3VXZDVnE3U0tqL2tzN0NzRlk2TUJWdXN4UndLeFd1alZxZzdycVFUckNiMEVYd0FBd0dtRVhpeHhVdURWczkxN0d3bTlTdFZRdmFGWEs3QXFoVm9mSGZkekZWMGZuYy9aQ3I1eUZXSTlsVjg5bi9HV2ZFMHJ3YmF3cjZRV2Z2UXNzY3VGWGFYZ2E2UWFLNFpPcGJCck5zanFPZlpvOE5VYml0VUNybFlvbHZ1WkNiNEFBSUJUQ2IyWTlpdm8ydDBpOEpvTnZYckNtbExWMDJqbzFSdG9sWTZKNDNFc0JsUGZPcDY3RmFDOWRZeS9KZHNqWVZkUHRkZXNHSGp0WDBjcWt1S3l4TSt3cjFYQkZRT3FWaUQxbWR4K2RqeW1GR3FWdnUrdGxrS1d3c05XdGRkSUtKYU9qZHd2RVh3QkFNQ0xFWG94NVlKWFoyeFZjVzNibjJGT0xneXIzWTRHWHJWZ3FyVXZMbDM4eUJ3YnE3MXl6NThiaThGV0tmenFyZmFxVlhtdERMNWlpSkxlYjkxcVZWNjU3Yzl3dnlkMFNyK1d3cS92NFh0OXp6eFg3ZnVNTHFHY0RjUjZLdUo2UC92UlNyRG9hT1dYNEFzQUFGNkkwSXRoZHd5OFd2dHFWVnpibGc5dGVnT3QwY0NyRldTVnRuUEJWVzVmcnNyclc4ZHpsTWJTeitFak14WS91N2V3ZjdTNmEwWG9WVm9HVnd1N3RxMGQ1cFNDcjFLd1ZSdUxvVmZ1ZnV1eHVVQnJkU0RXVy9IVkczck5CR0h4WjFtcjZoSjhBUUFBVFVJdmh0dzU4S3J0ejRVeXBkQnJwTUtyRkhDTlZuTGx0bk5qMzhKenA4RlczSjl1NThLd2thcXZWdUNWQzdkS24zbXV1aXYrN09MWWlKL2hheHpycWZ3YUNiNWFWVlBmdzFqY2w0Wk5zWnFyWjdzV292VUVaRDFoMkpIS3Ixb0YzZEhncTNlN05mN2xPTUVYQUFBOFA2RVgzUzRRZU1Vd3BWVGxsUXUxdHUzUE1HbTJ3dXRvd1BXUkdjdFZhY1hqWS9nVlE3TGM4YTFLcjFLQVZ3b0ZleXJyYWtGWEx2aWExUXBFMHZGYThOVUt3VnBYWnl4VmErVkNydjI0NzVuSHh1ZEl3N0tmaldPUEJHRXpGV0Mxeit0b0JWajZNeFI4QVFBQWh3aTk2SEtSd0t2blZxcmttcW5zR3UzUFZRdThhcmUzN2M5Z2EzK09kRHV0OFBwV09iNFduTlZDcmx5NFZRdThjcUZYL0htV1FxNmpsVjdiMWw3K0ZvOXBoVjZsRUt4MWk1VllzZklyRjNMbFFxL3Y0ZkcxTUN1M3Y3YXM4c3dLc0puUXF4WjhwVDlEd1JjQUFIQ0kwSXVtR3dSZVIwT3YzcEJySnZUcVhjcllxdWlLMVZtMTU0aGhWeTRJKzFaNTdsemxWeW4weXQxcUlXSU10OTdEZHZwejNBcmJxODQ3cGRBcnQ2OTN5V084M3dwOVdqMjhTc3NiYzBGWURMUnFTeDl6NFZjcDhHb0ZYeU5CMkpIS3I1RnFyeU5MSDF2alg0NFRmQUVBd0hQNmR1OFh3Tk9aQ2J5T2hGNjNyT3lhcmVRcUxWSE1WV2J0NC91K0dHNTkyK3FWWHFYcXJ0cVN4dmc1YmNsWUxkeXFMV2ZNYmQ5S0tRQXJCU3JiVmc1aWNzRk9LZmhxTFR1TXdWWXUrTXFGWHZ2dEl4bC9EOXY3TWJYZjcvMTF4TzM5WjVpK255MForOXpxZjRNL3dtZGRDcVQyNDk0TG4zVXU0RXJ0NDIrTjdhMHhIcjM5L0ovLzNnUmZBQUR3ZklSZXJIU3J3Q3VHTVN1cXVscVZYVWNDcnpTTVNrT3JYQkFXZzYzMG1HK1ovYVhnclBSK2FxRlg2M1BmS2wvai9YdUtyNk8wOURGK3JRVmh1WXFtMXRMQTJqTEc3NW45dVZBc1YvMVZDNy8yc1pIZ0s0WmU2WFlhZ1BYYzlzOW1sd1pkNmZZc3dSY0FBTkR0S3BOVUxtcGdhZU10QTY5Y1FETWFjSlZDb0ZvdnJKNmxpN1hLcnIrMmZKVldyT29xaFZ1MXIvRjE1ZDVQTFJnc1ZYQ1ZxcmhLWTQrZ3RCUnUvMW9Ld25wN2ZzVWdMRlpzNVhweXhUQXNIZnM3ODdqU01zanZ5Zkd0cFk2dCs3bGxrRDNMSFVkNmY4M2UwcCticFk0QUFFQ1dTaStLTGhSNDFTcTdSa092M2lXTXM1VmRhVkNWTG1QY3YvNFZqdTJwNUNvZGwxdmlXRnJPbUg1ZU1UVGN0N2Z3OVZGRHJaWldnQmVEcjNTc3RPd3hIWXRCMGJldEhrQzFBcSs5SWl1dDZDcmRmMHVPTDRWcnVRcXZYT1ZYcmdLc3ROU3hwUlJPelZaK3FmZ0NBQUNhaEY1a1hTendxbFYyallSZXRkNVdwUkJyTlBENmE4dUhYYm43ZnhYMjF4NFRnNjVTU0plNzFUN24xTE9HWGIzMnorVG45dld6cURWalQwT3VYSFA3T0ZaYXh2ajNyK2ZZQTZyOWZxN3lLNFpmSDl2dm9PeGoreHArdlc5ZmwwREczbDYxMEtzVWZMVSt6eGh3NVhwOWpSSjhBUUFBVlVJdnZyaHc0SlVMdVVhcnZGcExHVWR2TVpoNjMvS0JWUzdZK21zckIxOHhHT3NKdTlLS3J2ajV4TS8vbVN1NVZpbjlicWRoV0F5OVByWS9xNzVxVjNqY0s4RGlVc1Z2MnovQjFmNHpqeFZnNmY0WWZxVkJWaHB1eGFBckYzejFobDY1NEN2OWZPSXRWOUcxcXZKTDhBVUFBQlFKdmZqRHhRT3ZtZVdNc2Fwclp0bGlLV3hLbHl1bTFWMHg1UHFyc04wVGZNVXFyMXpRbGF2b3lsVjJwWjg5ODNLVllEKzNmejd6WEErdzJBc3JMamxNbHo5K1Q4WmkySlhlUHJaODVkZDdzbS8vbWk2UnJBVmhwVnVwRWl3TnZ1Sm5FME96cU9jcWo3MEVYd0FBUUpiUWkzKzdRZURWMnRkVDFkVVRlT1dDb0hpVnc5N1FxeFE2eGFXTWFVVldiRmlmaGw3cC9UZ1dxOEJHdzY1UzBDWGtPa2Y4Zlk3OXY5N0QxMXpsVit5NzlXMzdHbnJGOEN1dDhvbzl2OUxmajFMQTlWa1lid1ZmdWIvWmZUejlISEovNzFFTXZZNWU1Vkh3QlFBQWZDSDBZdHUybXdWZXRmMmwwR1ltOElxaFZpN2NTdmZYbGczbVFxODlrRXFYTXNZcXJWSzRGU3U3WWhWWXJicXJ0N0lyL1l5NW5UUmtUQU93dEFKc1h3TDVJN21mYTI1ZkM3MzIzNDg5OE5xUDNjT3dQY3lLdnpkcFNGYjdtMnBWWWVhQ3IvMTk3NkhlYU9pMWJZSXZBQUJnTWFFWGp4QjR0VUt2WE9WV2Jyc1VJdFdXRUxZYXlxZUIxc2YyTmVDSzIzRkpZeW4wYW9WZE1lanEvUmx5RzdVQUxMM2E0eDVHNVpZOXByOW5jWmxqM0pjR1lCL2I3eVdQYVVYWDkrVCszOXZ2MzZGWTdUVWFldTIzL1QxczI5ZmZ4OXl4dVJCSjhBVUFBQ3dqOUhweE4remhWZHJmRTNqVlFxOWF5TlVLdlVwWFJDd0ZXMm1sVjZ6VXFsVjJ4ZnNmbWNmRjd4ZXIxRXFoUlBxNWNrMjV2NDgwQU5zcnYrS1ZIdE5xcjdUcC9SNTY3ZFZlc2VsOXVpLysvcVFCMTkrRjhkYmZacXZpSzMyZmNUc0dYem0zRHI0QUFJQW5KZlI2WVE4VWVMMVh4a3Y5dVZyYnBhcXFYTUNWVzhxWXErSXFqZWNDcmhpUzFYcDNwZTg5OTduekdHTDFWeHA4cGIvRGFRQVdLNzNTWUNzR1hPa1N4NyszOHQ5SXJBRGJmNzgrayszUjBDdjNYblBuaGw2Q0x3QUE0RENoMTR1NndGVWFSd0t2bmx1cEoxY3U5TXBWVnVXMlc0Rlhyb3JycnkwZmR0VjZkNlhmbzFiWnRXMWp3UUhYbFZaOGZXeGZsejZtQWRWbjVuNGFlc1d2TWZENk96eGZ1ajlYOVhVMDlOcXJ1R3FWWHoxdUZYejFCbUdXT0FJQXdJTVJlcjJnSndxOFNsVmV1WXF1R0hyVituVGxycWJZcXU0cTNXSTRGcDh6dnI3V01rYWVTNnorU3IvdUZXQnA0SldHWHFYd0svMjkvanNaU3dPdjNOTFpVcSt2a2RBckYzZ2RJZmdDQUFDbUNiMG9lWVRBcXlmMGlwVlV1VjVkdWVXTXJkNWR1V0RyWDc5dXVXTmowSmFyUkZQWjlkclNuL24rTjFHci9DcUZYekhzaWoyK2NnRnJxZW9yWGU1WSt4dE8zOE9xd0dzbitBSUFBS1lJdmNpNWF1Q1ZDN2w2cXJ6aUVzVlM2SlZiMnRqcTBmV3ZyVjdoMWVyZHBiS0wxRWpsVitsM1B3WmVjY2xqN204cFYvVzEvMjNtL2w1alFMZUY3ZEx0czNCOGkrQUxBQUFZSnZSNk1RTkxHNlBTNUxaMDNCbUJWKzl5eGxib2xidktZcXowNnFudVNpdTdTc3NaYzBzbFZYYlJvMVQ1bFRhK2IxVjk1U3E2WWdoV0M2blM1WTYxZ0R0dXQ0S3YwdU5yemdxK0lzRVhBQUE4Q2FIWEMzbWh3S3ZVbUw0VWVPV3VxTmhxVWgrWE12NHJQSzdVR3l4OUR5cTdhTWxWZnUxaFYvd2J5bFVRN3ZmVHY0TmNJL3YvMi9MVlhHbndWYnVsci9mTTMyZkJGd0FBMEUzbzlTSU9OSzlmVWRsUkM4TE9DTHhxdmJ0eUZWNnRxcTVhNzY0MEJNdDlqMXpnRlplSFFZOVkrUldydm1yTEZmL2V2djRPcHNlOEZjYjIyL2Z3dmU4VmVtM2J1dUJyVndxNGVvTXZBQURnb29SZUwrQUZBcTlTWlZjdTlJcExEbXZWWGJsK1hYdmdGWHQ2NWFxN2NwVTMrL3VIR1RFczdmbDdpaUZZN1BVVi95NXpvVmVzK21vdGkweGY3eGtobU9BTEFBQm9FbnF4YTAxT1p3T3Z1TFR4ak1DckZITEZzYlFpS3hkNHhYQ3JGSGlsU3hwTFYyaE1YNytsakp6aGZmc25qTm1YUGU1L1gzdFByN2V0M05lckp5U0x6M20xNVk1SGc2OWRhOGxqY3lta0pZNEFBSEJOUWkrMjdmRUNyeGhvMVpZeXB1TjdTSlVHWHFYcXJseEZWeTRJSzFWNDVjSURXRzMvM1NyMSs5cXY4bGhiK2hqL3Z2YWVYL3R6NzRGWCt2MWk4TlY2ZmFYdG93UmZBQUJBa2REcnlYVXNiU3p0YjQzZk0vREtMUitzOWU3S05hUlB2K2JDclRUa3lvVmRmeFcrVDF6S0tQRGlGbUlvOVdQci83dUxJVmZ1YjNkTDd1L2phWit2MG10NkQvdlArSHZZZzY3U2M3ZWExY2ZqWnBjMENyNEFBT0JpaEY1UDdBVUNyMUtWVnd5a1NsZGkzQU92V3VqVkczaWxyMVBZeFQya3YyLzczOTllOWRYemQxajcrNDBCVnZvNy9uZDREZkZ4dDdDSGZLWHpsdUFMQUFCZWtORHJTUTAwcjQ5bWx6SzJBckJXRURZVGVKWDZkc1ZsaHg5YlByUktnNjM5MlAvWXZvWmZ0Y0JyLzk1cDM2TnR1OTFrSDZLNDVER3Qrc3I5L2NYdFhCK3c5THlRQzhaMlY2aHdqRXNjZXl2QVl0RFYyZ1lBQUM1TzZQV0VYaWp3aWoyN2Nrc1hQN2F2bFZ3eDhFcURyZGJTeHZnOWM4c1o0UXIyMzhWMGVXSXA4S3I5dlpiK3J0UG4zQXJiOTVJR1g3WFhKUGdDQUlBbkp2UjZYYTNKYXB6b2xoNWZtaEQzQm1HbEFLd244S3IxNzBvRHI5eFZHVnVoVjZtWFYxeFdlWVhLRmloSmc2L2EzMlQ4MjYwZEh5dSswdC83djdmei9nNzJLMVhteHVQNzJiYnhKdmU5d1ZaenZ5V09BQUJ3RFVLdjEzUTA4Q29kZDVYQUt5NXBqQ0ZXclc5WGJydlV2MHQxRjQ5Zy94MU5yL0JZKzV2c0NiM2V0aitYODZiZks5ZmphNFZhNkpVR1g5c20rQUlBQURhaDE5TTUwTHkrdGI4VWhJMEdYSzJsakNzQ3I5aW9mdS9WMVFxOVdqMjhOS3Zua2IxbHZ2YmVjb0gySGlURjcxRUwxTThRdzdEUzFSeDdYMHRyeVdNdndSY0FBTnlaME91SjNERHc2cDBnM3l2d2lqMjhjc3NXNHkwTnhVb042MlBnQlk4bXJZUWFDY0ZxVGZCenQxdktWWURscnVZNDh0b0VYd0FBOEFTRVhrOWlZZlA2T041YitkRnFWdDlheXRnS3dFWUNyM1JaWWlua3lvVmVyY0RMY2thZXhmNDduSWE0UFVzYWUyL3grNHlJSWRiUHdxMTBmRlNxL01wOTN5MXpqS2IyQUFEd29JUmVUK0NDZ1ZkdnhkZVpnVmY4dWxkeTFXNmx3TXZWR1hsRzZlL3o2SG5nVEt0RHIyM0xWMzdGNzVrU2ZBRUF3Qk1RZXIyTzFsS2ZWUlVlb3hWZlI0S3dWdUNWVzc3WTZ1V1ZobDNmdHE5aEhqeWI5eTEvQmNSU0g2OHJMRitzN1kvdkpYM3QyL2ExbVgwcndHb0ZXODM5bGpnQ0FNQjlDTDFldzYwRHI5SGIyWUZYS2Z5S1YyelV2NHRYbFZ2dUdDdkJhdFZnWjVvSnZYTEIxN2JsZzYvY2V4QjhBUURBRXhCNlBiZ1RtOWZIL1VlRHJxTkxHdU9WR1djRHIxekQrbjl0K1NXTkFpOWVTUXlHYXNGNEhPOVZXNVpZV3NaWUNyMUd4MmV2NnJpcXFUMEFBSEJqUXE4SGRvUEFLeDczYUlIWGYyemx3Q3QzcFVZTjYzbDFhZkRWK3YwLyt2ZHhKUFQ2dWYxZWx0bDYzdFRzVlIwRlh3QUE4SUNFWHErblZiRXh1ditzSUt3bi9JckJWNm1xS3czQVNqMjg5dEFyOTk3aGxieUZyL3Y5K0RleCttK2tweUg5ZnR4K0Rzazl2cmZIMTI2MldpMEdYNVk0QWdEQXhRaTlYc3ZSUU91ZWdWY2FkTTBHWHEyck5BcTg0Qis5U3gxWEdnbTlhaFZlSXoyK3RzeDI3MnZkSDF2YmpnUmZBQUJ3UTBLdkJ6V3h0TEYwL0ZuQlZtL1FWUXE0Y29IWHh6WVhlUDNIMXJla2NmODhnSC9zZi9PbGM4ZU0zTkxGSDFzNXJHb3RkK3pkSDVWNmZLV1B5MmtHVzYzOWdpOEFBTGdOb2RjRGVzREFxeFI4M1R2dytwYThObUVYNU8xL0d4OWhiR1hvOWRkMis5QnIyL0k5dnZiSDFBaStBQURnQVFpOUhzekM1dlc5UVZnYUNvMEVZVEhnbWwzYU9IT1Z4dDdBSzEzU0NKVEY0R3RGNkRWNlhHK29WWHRjTGRSUGo5KzI4dnZUMUI0QUFCNkUwT3VCWEREd0tnVmZ2VmRyN0EyODlwdkFDKzRuVi9FMVl5YjBpa3NnMC9HMHFYM3VxbzR4TEd1RlhqM25CY0VYQUFBOEFLSFg4eHNOd2tZRHJ0R0tyNW1tOVdsWUZVT3NVdkFsOElMMVpvS3YwV1dMZjJYR2ZteC9CbDM3TFJkNDlWN1ZNV3IxK0txOXYvMXh0ZTNJRWtjQUFEaVowT3U1elZaK3JlN3RkYVRDS3cyMzB1Q3JkdnNyY3hONHdScTU0S3NXM0pSQ3J4K0YrK2t4dWNxdVhNVlg3dnZFOFo0S3MxS1ByeGJCRndBQVhKRFE2MEVzYUY3Zlc4bFZPcjYwMUxFVmRMV2EySmVDcjdSeGZScDhsU3E4WWhQNzlGaUJGNnhWcXZpcU5aUlBqL214L1ZtOWxUNDJobHFsaXEvYzgvYmVSczZGUjV2YUF3QUFkeUwwZWdBM0RMeFdMV2s4c3JReFhxa3gvWm9MdXRLdnBjQnIvMzRDTDFnbkJsK3hJaXY5bXNwVmR2M1k4bUZYYml4blg5cTQzMVlFWCtuN0ZId0JBTUFERW5vOXY5NmdaellBRzYzd3FnVmZ1Y0NyVmVIVjA3OUw0QVhucUZWOHhhKzFNS3ZVc3l2WDM2dFVBZlpqKzlyanEzWkxYMnRQMVd0SkRMb3NjUVFBZ0lzUWVqMjMxWUhYMlJWZXBhK3QvbDJ0d0d1dlRnUFdLd1ZmVVF5b2VudDI5UVJmY2Jua1h2blZDcjFxRlYvcCsydWRQd1JmQUFCd1FVS3ZpMXV3dERHTzl3WmFvMHNiZXl1OFNsZHIvQmIycDgzclJ5cTg5UENDMjB1RHI5RXFyMUo0dFcvbm5xUDF1TjZLci8xY2x0TzZtbU1yNkFJQUFPNU02SFZoRndpOGVpdTdlaXU4YWtIWSsxYXU4cXBWZTZYSGZBdlBXNXZRQW12bGVuenRYM3R2cFNzNi92ajF2RC9DclZZOXRuL3Zub3F2a3RMVkhJc1ZXNDM5QUFEQURRbTlubGR2WUxZNkFHdFZlT1hHUzQzcjA3QXJGM3lWbGpZS3ZPQStjbjkzSTRIWGorMXI0TFZ2Zjl2R1FxODk4T3BwYk4vemp3THArOW0yZGhCbWlTTUFBTnlaME9zNXJRcThScS9XMkFyQVNuMjg0bmF0aDFjcDhOTERDNjRoRGI1Nmc2N1A3WisvNDFxb05iSzhjZWJXRzNyVnpxK0NMd0FBdUJDaDEwWGRZV25qYUJCVzZ1VTEydE1yanZXRVhXbS9yL2hjYVVnSDNNL2I5bWR6KzFKUXRZZGVNZkNLb2RkbjVqbFdobDZ0NEN0OVh6M25GOEVWQUFEY21kRHJnbTRRZUxYMnIxclMyT3JqbFZ2V0dDdS80dTFmbWNmRVBsNENMN2l2L1c4d3JmajZ0dFdEcjFvWTlSbU82UW5KY3VlcUk4SFgvajdTOTljaStBSUFnRHNTZWoyZjNnQ3NORDRhZU0wRVgzRTVZK3pqVlFxN2N2MjdWSGpCTmFYQjEzNVZ4ejBFYW9WZXVVQXJQU2EzRkRMWDR5dWVvN2F0SFhwdHlYSHB1YkIzaVdMcGM3REVFUUFBYmt6bzlWeU85dkthRGJ4Nmc2L2Fzc1pjd0ZWYTJoZ0RMMzI4NEpweXdkZTJ0Y09xVWlYWDN0QysxZWVyOTJxTzZkVVpZeSt5bmtwWndSY0FBRnlZME90aVRsemFXQm8vdXFSeE5QRDZhL3U2ckRHOW4ydFdud3U4NHBVYWdXdEt3NHdPeTM4QUFDQUFTVVJCVktSdCs3M1VzZGE3cTFUSjlabDgvYmFWZzYvZXF6bStiNytEcjU3QVMyOHZBQUI0SUVLdkM3bFE4L3A0MWNaU0VCYURyWjZyTnViNmVLVzl1a29CVit6NWxYNC95eHJoMnRKelNLbTMxeDUyeFNxdnorU1dxL29xVllUVmVuemxRckJ0YXdkZU02SFgvcndBQU1DTkNiMmV4Nm9BTEFaYnJjcXYzc0NyRklMRkpZeTVwWTY1SnZjYTE4TmpTU3VwMGg1ZnRSNWV0YXF2UGRTcUJWK2xIbCtseXErZXBZNjdmZHNTUndBQXVDaWgxM09ZclJCYjFkTnI5bXFOclFiMnVjQXI5dkFTZU1IamVOdStCbDZ0MEtzMVhydWE0eDUwZld4L2htQ2wwQ3ZYQXl4WDZaVUdWNEl2QUFDNEtLSFg0MWpWeTZ0MFhPK1N4dG5BSyszbmxZWlh1ZUNyRklUdHp5UHdnc2UwLzgyT1ZIclZsam0ycnVZWWc2K1IwR3NQdk5KK1pOdXY3NSsrRjcyOUFBRGdvb1JlaitIV3ZieEdnNjVXQUJhWE4rNWpwYUFyYlY2ZnEvQnlwVVo0WFB2NUpnMmg0aExGUGR6NlY3SmRDcmIyNTZsVmU4V2VYdkZXQ3IxaVVKVldmc1gzMDBQd0JRQUFOeVQwdW9pT0p2WWxxd093MVlGWHJPNUtnNnpTa3NaY00zdDl2T0I1N09lYVBiRGFtOUwzTEdjc2pkY2Uzd3ErYXFGWHFibDkrbDdPWE9JSUFBQk1FbnBkd0FtQlYybi9yU3EvU2szc1cvMjhjbUZYckJRVGVNSGoyLytHMDM1YnRhc3h0cFk1OWw3TnNSUjhwY3NzZTgrUDZYc1JmQUVBd0FYRlhpVmNUMi9JYyt0ZVhqMDl2ZmIrVzJraitseWZybmpmbFJyaCthWG5tdmczSDIrbG9EeWVKM0pMcVV2VnFhVmI3ejhHekZiVERuOU92LzVoQkFBQUdLVFM2OXBtQTYvUkNxL1c1RzgyOElwTjdHdmhWMjRTbXphdTE4Y0xuczkrZnZtNS9UNWZwSTN0WTRYWDkrMXJ4VmVzNUdvMXRjOVZmTzBWWHJYbGp2ditMZG1PVjNIc1BVZU5WblM1aWlNQUFFd1FldDNaeE5MRzNpV05veFZlS3dPdlhPaFZhMXlmQzhIU3FneFZYdkNjY3NzYzA5QXJEYkMrSjl1ZjIrOGVYdW45L1RuU0paTXp3VmRQYjYvNEhvNHVjUVFBQUJZVGV0M1JDWUZYUEc1Mm1jNlJKWTFwOC9yY2tzV2U1dlVxdk9CMXBPZWR2YkY5N21xT2YyMi9RNjcwL243YlEvYlB6T043ZzYvWjNsNng0a3Z3QlFBQUZ5RDBlbHhIbHpTT0xuV01nZGRJTS90U3hWZXJoNWRlWHZBYVl1aVZYbzB4RjNLbHl4M2pNc2ZQWDgrUkhsYzZsOFhnYXcrOTBzcXYxaTAybzQvbkt3RVlBQURjaWREck1mVlVIdlFjTjdxMHNTZndTcHZYeDZzNDlqU3ZGM2pCNjBtWE9hYUJWRnpDdUo4djRuTEhYQSt3ZmQvSDFoOThwYUZYcmJkWFQ4Vlh1ajM2T1FpK0FBQmdBVmR2dks1U2dEWDd1S09CMStnU3gxamQxZHU4UGczV2hGM3dPdlp6VCtrY0VwZEJwK2VQWEdWcDZ6elZDdk5Icis0WTMwZmNMaDNmL2ZtNGlpTUFBSXdSZWwzVGJPQVZqejk3aVdNdTVNcFZlYVhONlV0TEdtUGdsVTR1Z2RlUW5vTnE0WG5wWEZKYVh0MGJmTVZ6NE93NU5MNGZ3UmNBQU55QjVZMlBaL1hTeHQ3QWE3U1hWNnpBeUFWZnRRbXJ3QXRlVDFydHRTOG5USy9PK0czN1oxbmpmZzRwTmJXUFYzUk1sekh1U3gxelBiM2lWUnhydmIzMmZ6U0tTeDVIbHppdVdob0pBQUFFUXEvSGNyU0NxN2VTYTFVdnI3ajhxTFNrTWJlc1VlQUZyMm4vMjkvUE0vdVZHSE5ON1dNRjJON2NQcDZiMGw1ZmFZK3YyZUNyRkhqRmY0Q1liV0l2K0FJQWdBV0VYbmZ5YTRsS1Q3QXpldHpxd0t1M3NtdmZseTQvaXNGWHVoeEo4M29nSncyOTlsQXFEYTlpMkpVR1h0OHl4MzF1ZjRaYmFlVlg3VnpYVy9GVnVzVUFxMFN3QlFBQUp4RjYzY0VKZ1ZjOC9xd0tzRm92cjNSSll4cHF4ZDQ3dFg1ZVIzcmRBTThqbnBOaTZKVmIwdGk2cUViUDBzWlc4TlZ6RmNkY3hWZUw0QXNBQUU2Z2tmMzFsQ1pLdmVPM1h2TDRFYlpqRS90NDVjWlNsZGYrSEVJdllOdkt5NmhMb1hudVhKTXV2VzR0MXk3ZFN1ZkkwWFBzS3ByWkF3QkFKNkhYdFl3R1hxUDd6MWp5V0F1N1N2ZmpaRFdkUkFMczl2TlRUNUJlV3pJZHoxR2o1N21qVmJTckNiNEFBS0NENVkyUHB6U1phZ1ZtcmNDckZZVGxlbmpscWpCYVYyc3NUVXpUMXdDd1M0T3ZIOXZYbmwxcEEvdS93dmlQN1d0dnI5d1N4M2lyTFhVY3ZiV2EwOGR6bm1iMkFBQ3dpTkRyc2JTcUNHYVhOUFpXZnVVcUovYnh0TzlPdkZwanFmb2k5LzBCZHJselVtNjVZKzUrN1VxT3RjQnJSZkNWZXgvYlZnNndCRjhBQUhBQ29kZU5uWGpWeHJnOUduaTFncTdXZUdsNVl5bjRpczhoOEFKeTNwT3ZlNlZXTG9DUGdkZm45alhvU2grN1YzejFMbW1jRGI1aWNGVUt1QUFBZ01XRVhqZDBvYXMyamdaZXBTV050YkFyWGU1WUdvK3ZBeURuYmZ2bm5QRnpLMS9KOGZ2MisxenpQVGt1ZDMrMmwxY3IrRXBmYnpwV0NyeTJzQjhBQUZoSUkvdnJxQzJMcVZWeWxjYVBCbDZqamV0clYxZ3I5ZjF5dFVhZzEzNitLcDFuWWxWcDZSelZxbUp0QldDdDV2YnA2NjF0MTk1bjEzR2EyUU1BUUozUTZ4cDZBNjg0ZmxhRlYrOEVNRmZsbFZaM2xhN1lxSmNYTUNJOVo4WGwwYVh6VGJxZExzT2VDYnhHZzY5V0lOYjdmcHZIQ2I0QUFLQk02UFU0amdaZ3ZaTzBudDVlY2RsanE3RjBXbjJobHhjd0l6MVBsWUt2ZUw3SlhTVTJ2UWpIYk9BL2M0dnZZL1I5QXdBQWc0UmVqMkYwOG5TMEVteWt4MWV1VDFkdGVhTmVYc0NzdU1TeHRIUzYxV3N3UHNldGdxL1pjNTV6SlFBQVRCQjZYVS8zc3BZdFA0bGFGWERWZ3EvNE5TNGZpbGR0eklWa0puSEFqRDEwcWxXYTFrTDNVbi9CMFlEcjZCTEhWWUVZQUFCUTRPcU4xM0swQ3FCM1VuV2tsMWM2T1N6MTlJcGhWNXhZbXVBQk05NjJmNjUwbUo2UDBxc3kxdnA4NVNwTmoxWjI3ZnQvYm1QbnRkWXhydVlJQUFBTHFQUzZrVi9OaG10TEVWdGExUUN6RlYralFWaXNzTWcxcnk5VlVzUUpKOENvM0RtcmRVR051QVI3WmtsaktRZ3JCV090MXc4QUFKeE02SFVEQ3dLdmVQenFXMjh2cjFyMVZtblNtVnM2Wk1JSHpJcm5ydGJ5eFZKUHJ4WGgxK3c1RndBQXVBR2gxM1gxVm5hZFZkRVZBNi9lS3pmVzlsdmFDS3hRcXZRcVZaKytiL2t3ZnNVU3g5bkFhN1FpekhrVEFBQUdDYjJ1NldoMXdHamdOUktNNVNvamNsVVZ0YVdOQUVmRlNxL1M4dXIzOFBWSTgvcFZsVjI5NTNUQkZ3QUFIQ0NBZUR5OTFRR3JLOEUrd3YyZW5sNmxQbDRtYmNBUjhYeVZDN1gyZmJtbDFqM2hWK25jdUxyQzYvQS9jdnhhUWc4QUFBUkNyOGUwdWdxaDFhRDVQV3lYK3VUVXJwU21ueGV3V25xdXlvWHh1V1dPTVJCTEg3dDZpV044bmIyQmwrQUxBQUFXRUhwZFIyOEZWOXhlWGRGVjIxK3FvbWhWZW4xczQ1TTRnSnEwY2pSM2ptb0Y4ck5MSGt2ajZlc2FxZkFDQUFCT0l2UzZodDdKVCttNDFjRlhhV2xqNmNwbk1mQnFWVWNBckpBN2orWE9TN0VxTmEzOFduR2IvVWNKQUFEZ1JFS3ZrLzFhY2xJTHFrcmpvOVVDbzBIWFNQQVZqOHRWZGNYeDB2TUFyQlNYT0pZcVUwdm5wZEh3YXpUSUdqMm5seDRQQUFBTStuYnZGL0RNRmdaZW84dG5Sb092bmdxdzNHUXlGM3k5WjdaTjJvQXp2Q1ZmYTh1dzQxTEdWUUhYaWtCcjI3YnRaK2Y3YkIwSEFBQWtWSG85cnQ3SlZXL1ExYXI4S2kxdExBVmZNU2dET0VQdTNGVmI0cGlPZjl2R2c2L1pRS3ozZlFBQUFJc0lJeDdMN0xLYTBpU3V0OW9oMS9RNU43R01BZGpJaEE5Z1ZqeW5sWnJaNTRMNTBlcXZrY0FydnI3WmlqQUFBR0NDME90eEhKMWM5VlowbmJHMGNkdE02SUR6NU01dHBTV09yUXF2MXJueTZGTEgzbitzYU8zL012NXJTVDBBQVBDTDBPdTVqRTdHUm9Ld1dEbFJhMW9mbjh0RUREaGI2UnlXaGwveEtvNHgxRC9TeDJ1a0NyZjJIa2FDc1MvamdpOEFBUGhONkhWL3JVbFI3NlJwVmVCVkM4Qmk2Qlg3ZmVXYTExdTJBOXhDN3R5Vk8yZmxxci9TY0w2M3NtdDJxV1BwZFFNQUFJdTVldU45alFaYXBmSFZnVmM2M3VwMTQ2cU53TDI5SlYvanVhdDBGY2ZhdWF5MTlIRmxWZGkydVNvakFBQ2NRcVhYOVpTcUEwcmJxeXE2ZWl1K2NrM3RYYlVSdUxkU3BkZG94VmR2OExYcUJnQUFuRVFvY1UydDRPdG9BTmFxWGloVlFKUW1pYVVLTHhNNjRKWks1N200QkR0M05kcGJWSGdCQUFBM0pQUzZ2ZExrcDNkU3RLb0NyRGZ3S29WY3RVcXZ0RCtPaVI1d0srbjVySFJlcXkxeDdLbm82ZzIrU3ErdDlkcG45d01BQUlIUTY3WmFrNkhSU1Uzdjg0MVdmdFdXL0xRbWpDb2JnSHZxRGZKejU3RjllN2FTcXpmNG1xMEVjMTRGQUlBQkd0bWY1TmRsNDFkTVRucXJCbVlydmthRHNGWVlabmtqY0UveFhOYmJ6eXNHWHF0N2VaVmUzMzc3bWV6UDBld2VBQUFHQ2IxT3NERHcyczFPb2xiYzRqS2g5SDVjMmhnbmpRQzN0SWRIUFJXc000M3Nqd1pjUGErL1J2QUZBQUFETEc5OEhHY0ZYajJUdTNTN3RMeHhkSElIY0lhZTgxdHRtWFpwaWVOb0w2L1cvbFh2RXdBQUtCQjZQYmF6QXEvWmZsNldOZ0pYTUJMdWoxUndyVjdxR0YvdjdQc0VBQUF5aEY3WDFack10Q1pQcXdPeDNzQnIvd3B3RDdWeldxNnYxMXZtYSs0Y2VEVFlpcSt2OUhxUGV2dTF4QjRBQUY2ZTBPdmFWbFVMekFaZXRhV01wZkZ0V3pOeEE1alZVODM2dG8zMzlWb2RmSjFWcVNYNEFnQ0FUZWgxVDczQlZXc3lOYnUvTkltckxYUDhLQnp6RnI3WHRwMHprUVBvMVRxMzVZS3ZJd0hYYUJCMlZ1QUZBQUQ4SXZTNmo5SGxMNjNqZXBmTHRBS3ZWdlZYYmVKNGR1VUN3SWpjK2E1MDdvcm5zVE5ETCtkSEFBQzRFYUhYWXIrV2xJeE1hbVluUTZOVkJEMmhWazlqNTF6UXBZazljRFU5NTd1UGptTjZ4M3NEcmxYLzZBRUFBRFFJdlJaYUVIajFQdjZzNm9QYUpPOXR5emQrVnNVQVhNMWI4clYydGNaYzc4S1ByUjFzeGYwenI2L25IeXNBQUlBRGhGNjNNeHVJalQ3UDZxQXJMZ3VLazhoY2J5K0FleXVkNjNJaFdLNkg0ZWk1dFBkMXRNYmovdDV4QUFBZ0VIcmR4dEZxZ043bm1RMjhjdjF0ZXB2WTV5YUhBRmVRQy9GTHdkZE13RFY2enUwTnNuclA5UUFBUUlYUTYzR3NtbXlOQm1HdENxOTlIT0JLWXNoVU90Zk5CbGFyQXE3WjhaYTNYMHZ1QVFEZ1pRa3JIa1B2Wkt2MStDTkJXQzBReTcxR2dLdW9uZE0rd2xnOFpzV3Q5SHA2WC9jc3dSY0FBQzlONkhWOWh5YzlnN2ZTeEs5M0FnaHdKYlVxMWxXaDFwRUFiUFI5QUFBQW5iN2Qrd1d3MUswbWJhWEpJc0NWNU01WnRaNWVzejIrV3VmQW8rZksrSmlmRTg4QkFBQXZSNlhYOWZST25rcmpyY25WU0toVld0WVluei9lQjdpYTJ2a3VobUl6UWRkb29OVTZSd01BQUFjSnZhN3ByTW5RU0JCV3FveW9UZnhNMUlDcjZRMzZqelMxYjMydjFtc3JiUU1BQUFjSXZSN1g3TEthMGlTcjkxYXI5Z0s0b2xpVldxdHNQVnJoTlhzOEFBQ3dtTkRyTVkwR1ZhMUpXZTE1YzBzY1k5aGx3Z1pjVlMzd0twM3ZTdHVqbFYrMTF5VDRBZ0NBa3dtOXJtdDBVblJXZGNKSXhaZEpHM0JGSStld283ZldhNWpkdi9weEFBRHc5SVJlMTNZMFVKb0pza3BWWHEzcUI0QXJxNFZldmVGWDZ6bDdqMXZOZVJnQUFES0VYdGZSbWl5TlBxNTEvT3JLQmhNdTRHcHk1NmQ0eml5Ri9LVWdyUFE4cmVjSEFBQnVUT2gxTGF1V3R4d0p3bm9xSHJiTkpBNTRET2s1cTFUaHVqV09LZTJ2ZlUrVnNBQUFjR2RDcjBWKy9zOS9yd3FzZW84ZlhXNHpXa2xXcW5ZQWVEUXhyRzhGV3JrZ3JMVTkrbzhQcTZ0NEFRQ0FRT2kxd0lIQWE5ZjcrTjRxaE5ieFBVSFl0bzA5RjhDVjFjNWZyWEIvOUI4WlJsOVQ3emdBQURCQTZIVjdaNFZGczhGWmEveTljTnkybVpRQjF4ZlBhNjN3S3o2dWQzdmtkVGgzQWdEQURRaTlidXVxVlZLOUZXUXF2WUJIMW5zZUd4MmYvYjRBQU1DSmhGN251OWZrcHJjcW9UYmVhdkM4YlNadXdPT1lDYnhHSzc1V0xYRUVBQUFPRW5xZDZ5cUJWeHp2clRaUWtRQThpOTdsMzdVcjJPYU83em5YOW54ZjUxa0FBRmhNNkhVOXM1T3IzdWViWGM0RDhNeGkvOEpkV3RXNjRsemI0aHdNQUFDTENMMnVhWFRTYzdUYVlIYTVqeVdPd0tNNTBsOXI5QjhOWmw5YmFSc0FBQmdnOUhvK3EvckpqQVpmQUZlVkMraHJJWDR0ZUhMK0F3Q0FCeUgwZWk2ckFxOTBuMGtkOEd4NkE2N1dPQUFBY0dGQ3I4ZHoxcVFzTm05ZTlid0FqK0RlNTc2Vi8yZ0JBQUJzUXE5SGM5WWtwN1ZrVWRVWDhNeEtnVmVwdWYxVk9DOERBRUNGME90eFhlMktZQ1pld0xOWTJZeStOQzZ3QWdDQWt3bTlIdE5zSStVVkRaaGR1UkY0VnF2T1ozcUZBUURBQlFpOTZGWHE5d1h3Nk02bzdBSUFBTzVNNkFYQUt6aXpIeUlBQUhCQlFpOWFUT2lBWitZY0J3QUFUMHJvUmN2UGU3OEFBQUFBZ0ZGQ0wzb0p2NEJIVmpxSE9iY0JBTUNURW5vOXBwL2hkdmJqNHVNQm5zblA4SFhrY2JuSHhQSGU0d0FBZ0lXRVhvOXJOdkNhZlh6NnVOeHptTGdCcjJnMjRCSjRBUURBeVlSZWorV3NTVktzQUl2ZncyUU5lR2E1Yzl5MlhmODg1MXdNQUFBVlFxL0hjOVlrNThkV0Q3MjJ6RGpBczdoM2dIUzBlaGNBQUFpRVhxK3ROV242dWYwVGhnRThvMXB6KzFZRkxBQUFjSEZDcitkeHRMbDk5S013RHZCb1lyVnFyUjloUE1ieWJnQUFlRkJDcjJ1NjlWVVpBVjVGcVlLcjV4eDY5cm5XT1J3QUFCWVNlbDNQMlgxZFppWlZwYVUrZ2piZ2tiWDZHT2FPTFcydmZrMEFBTUJCUXEvSGNMVHlxeFZVOVFSWndpN2drZlZVY01YdHZhOWg2WHgzOW5uUmVSWUFBQTRRZWoyT1ZjRlhhMzl1c3BkclpsL3Fod053VmIzbnhOeXh2Yy9aR3A5OXpRQUF3Q0NoMTdtdVBsbnBuY3lWeHE3ODNnQ2lWdVhycW5QMmFPQjE5ZjlXQUFEQVF4SjZuZS9SSnpPeDZpc2RpL2NCcnFwMHp1cXQ3T3BkeWpoYmxRc0FBQ3dtOUZyZzdULy9hL1JmODQ4dWV6bTY3S2IzZFpXV1BBSThrbGlkR3MrSjZWTHVrZlBoYUJBMmVrNEdBQUFPRUhvdGNpRDRtdFhiUDJabXdwWnIzTHdxc0FPNHBWemd0WDhkT1dmV25uL2xjZkY0QUFCZ2t0RHJHbzVPZ281V0crUUNyeCtGeDJ6aHE0a1o4SWhLNTd4dCsxcnhkZlpyQUFBQVRpRDB1ci9SU1UrcEtxSDNlVWVxRytLU254L2IxeXF3K0JYZ2FrclZYVDIzcmZIWTNQY2FPUTRBQURpSjBPdGFWaytDams3cWVwNWoyMHpjZ09zYURieHlsVjh6WVpsS1dBQUF1RE9oMTNYMEJGQTlqeDk5bnR4a3I3UnRRZ2M4a2xiZ2xUdm5iWTNISEQxWEF3QUFOeUwwdXJiUlNkYnM1RXNWQS9ETWVxdTd0cTErVGwxOWpsM0Z1UmdBQURLRVhvK2pGSEQxSGgvSGUyK3hyNWNBREhna00rZTdXclZyZk43Vzk1c2RIMzEvQUFCQUlQUjZMSzFKVm1uODZLMTMyU1BBMWFRVlhPazVMSGVoanR6KzJybXU5eHhhZTIzT3BRQUFjQktoMStOcFZSdk1CbHZ4OGJrSlgwKzFGOERWdEFLdjB2NlpvS3YwdlkrT0F3QUFnNFJlMTNSMG1jdXF5cTdQN1d2MXd6NFdKNFhwYXdDNGl0N3pYWHFPNncyeVppdTZqcjRIQUFDZ2c5RHJlbzVPaWtyalBSTy9XdFhEajh4MktmZ0N1SUtmbWEvNzdYUDdIWER0NTdOMGUvUWZDN2JNOThpTkgza3Z6ck1BQURCQTZQV1lqbFlaOUZZOTVFS3Yzb2tmd0JYa3ptV2w4OXhvME5VS3ZGci9HTkg3Mm1mOWZQdlAvM0plQmdEZ1pRbTlybTkwY3RWYlpUQWFoUFZPQ2dHdW9DZlUzeXUrU2tIWWtRQXN2bzdTZHUvN0dDWHdBZ0RnNVgyNzl3dWc2bWZ5OVVoRlYrOXhJK0dYSlk3QUl6Z2E1QjhKdkk2K1pnQUE0QUNWWHRjMXV5eG01UVF1Tm5qT1RScmpoTTlFRGJpSzNEOGNyS3pxeWxWd3JmcEhDc0VYQUFBY0pQUmE2TmRTa2hWQlZjdktZS3NWZU5XYTJPZXFKUUN1b0hRdWk5dWZtV05qUU5ZNjM2MDY3NDYrTndBQW9FTG90ZGlDNEt0WDc2UnBkSEpXQzdaeXZXOUtTNFFBN3VWbjhqVjNYb3Zuc25Uc2M4dWY0MVlIWGtmZW0zTXNBQUIwRUhyZDE2MG1MNk9Uc1hSQ21Kc2t0cFlIQWR4YktjeVA1N0tlaXE1YlZYSTVod0lBd0VKQ3IvdnJyUURyblR5dG5xVFZBckhQeW5FQTl4UUQrVktWYXF6c2lpSFkwWUJyOUp6b0hBb0FBSXNJdmU2ak43aUsyNnR2UGRVTnVXYjJuMXQ1cWVQK3VrM2FnSHNwbmV2UzdkdzViUFd0OUxvQUFJQWJFSHJkejlGSjBkR2dxeFI4NVNhRnNicXJKeXdEdUtkY3hkWitEdnNNKzJPUTN4T0V0UzdpTWZ1UEZ3QUF3Q0pDcjJ2cnJRZzdvd0lzVGdCcllWYzZvVFJ4QSs2dEo2aHFYYXlqRnV5M0FxL1c2MWdWZUJVRHQxOFhWUUVBZ0pjbTlMcXUyWXF2MHZob0pWaHBRbGc3UnJVQ2NHODk1N05hVlZjcEZDc0ZYbWNIVzYzMytXVmM0QVVBQVA4UWVwM2cxNFRqbnBPTzBXVTV0YUFydDd5eFZBM1dXLzBBY0piUythNVV2VHJ6andKbkIxeG5CMllBQVBBU2hGNG5XUmg4alU2cVppZHZ0YXFHbjF1NXIxZXJHVFRBcmZ4TXZwWUMvRnhZbnhzN0svQ2FQWmNEQUFDRGhGNjNOVHQ1bVYxRzB4dDAxWTR2VlVyRSs3bndDK0RXU2xWZXJlQys5eUlkWjl6aWEyKzlOd0FBb0lQUTYvWldUMXA2SjFHajFRdWxTVjl1OGxpcjlnSzRwWGplcWdWZnVTV1BzNVZkUnl2QWRxM0tMd0FBb05PM2U3OEF0bTByVDJUZUJoNWZDN3g2SzhCcVZRNmxTV1JQWlVUdit3QTRvblZPS3kxdlhMMjBjVFR3RW1nQkFNQUpoRjdYRVNjOE1TanFyZWlhdmRVbWdMV2xRTFZKcEVwQzRGWnk1N1RTMHNXZTg5ZFpnWmRLTGdBQXVCR2gxMzN0RTV4U0pWU2NBUFZXRDZ3TXZuTExnYjV2NWFWQnVTdWlxZlFDYmlHZXk5SnpVdWxycTJyMWpNQkx3QVVBQURjZzlMcS9VdkRWcXZ4S2o1c0p2bHBWRFhFcFk1eEU5bFI4N2E5TDhBV2NxWGFPcXdWZnBZQy81M2Ewd2tzQUJnQUFKN1A4N0Rtc1dzb1lqMHNuaUxucXJuUXNGM2laekFHM0VwYzBsc0w2MW5sclJlQ1ZlMjIzV05MNDgrMC8vOHM1RndBQWZoRjZQWjZqeTJ4R0d6V1hxaVZhRGFIakZSMEJ6bFE2WjlXV2FQY3NjNXhkeWhoZlYybDdGWUVYQUFBRVFxL0hjalR3bXEwQTY2MmNLRlZFYk5zNWt6eUFiY3RYcWNiYjk2M2NwM0Mwb211MjhxdDNmTFp5REFBQVNBaTlIa2Rya3JNNjZLb0ZZTGtsanQrM2NvUDdINGZmUFVCZWVpNHJWWGVsNTZsNDd0cVBpZWZEVnNCMXRCS3NOL2dxdlY4QUFLQkJJL3RyYVUxa1dzM2dieEY0MVNva1ltVkZuQkJxWmcrY0laN1RjdWVpM0RMRzB0TEcxam15ZEM0OXEySkwwQVVBQUJPRVh0ZFRtdGk4SmZ0WDNGcVR0NTRsanJrQXJGVHA5YjRKdm9DMWF1ZXUzcXZNamxaeWpWWjg1VjVycmVLcjlCNEJBSUJCbGplZTZGZFQ0WjUvM1IvOTEvNmpRZGRNdjVwMHdwZ3VaY3pkanhOUGt6YmdMUEdjRlFPdTcrRnJxWkY5ZXE2YVhicllHM2c1SndJQXdBMEl2VTYyTVBoYUZZejFMdDhwVlhuRmlXTnVRcG5ycTJPaUI2eVdDN3h5RjltbzlSNk12YjVhdDZNQldQcmFuUThCQU9CRVFxL25kSFFwWSs4U3gxb2xSVzRaa1FrZXNFbzhsK1ZDOTFKUHI5d1N5RnNHWHJYMzRqd0pBQUNMQ0wwZXo5R2xqVWNxdmtyVkZMVktMOEVYY0liY3VTdTNmTEhVMDJzL3J2ZjhkL2JTUm9FWEFBQXNKdlI2VExQQlZ5c1FHdzI5Y3ZkTG9aZ2xqc0FxK3pta0ZjYVA5UFE2Y3BzTnZFWURzT0w0cjZYMEFBQkFRdWoxK0VZblc2TkxIMk53RlNlT3NaTGkrNWJ2bXhPL0Q4QVIrL21rVm4yYU94LzFMbW5zL2NlQlZVc2JTOXZOY1lFWEFBRGtmYnYzQzNoeCswVGxyVEJlc2gvL00vazZFbnoxVHRweVM0YmVrL3ZmdHZLVkhHc1R6UGRmengvZk4wQ1A5QnlWdTFwanFib3JWbmlWd3F4VlZiU3QxOS83UGdFQWdBa3F2ZTZ2OWEvNnM4dGlWaTlwN09ucDFRcS8wc29NZ0JtNWMxaHJXV004SDhVSzFUTjZldDBxR0FNQUFBcUVYamZ3YStuSnluL1Y3NTBzbFlLdUl3RllyQUNMRThyYy9ialUwV1FPbUZHclFzMHRaNHpCMTB6WWRVWUFGdCtQY3lJQUFKeEE2SFVqQzRPdm81T3RvOEZYckpMb3JmUVNmQUVyNUlLdjNQa21CbCs1SG9ValBiNVdCMTd4L1FBQUFJc0p2UjdicWdCc2RvbmpmcjhVZUxVYVNKdnNBU05hZ1ZmcC9KTTd2blN4alo2ZzY5WUJtSE1sQUFCTUVIbzlqOTdsTTBjcXZISVZFclVKWjY3UFRneTlBSHJzNTR0YTRGWHE1NVdyTkoydDdHb0ZYdW5yclFWWW84Y0RBQUNEWEwzeDJsb1RuZG1yT082VHR2ZkNlQ3Y0MnEvaStIM2J0by90YTZpVm0zQisyLzRNek41LzNYL2JYTVVSYUlzVlhybmxqTFhnL1JZOXZkTFhXcXZvNm5tdlBZLzcrV3ZwUEFBQWtDSDB1cjdTaENZR1hqRTQ2cTN3bWcyK1lnZ1dKNXgvYi84RVl0K1M4WDM3ODlmOTlQc0x2b0NTM0xMRzN1QXJWb0ROOXZLS2dkZFpBWmpBQ3dBQUZyRzg4WVlxemV4N2w3bTBIbGZhUDd1MHNiUThzYlY4OGU5ZnQrL0oxOUl5STcyOWdKYjBuRlVLdTlMelRzOVZaVzhSZU1YWER3QUEzSkRRNjhZV0JsK3RRS3YzTmhwOHhRbGdXdldWVGp4N2xod0p2SUNXL2Z5UVcyYWRCbDdwT2FnVWZNVnExVE1Dcjk0Z0RBQUFPSm5RNnptY0hYelZBckZXajUxY00rbFlKYlpQSUFHaTNMTEdXcUJlcS9McXZaV0NyZG5BYXpZWUU1Z0JBTUFCZW5vOWo1R0E2eTI1dlNmanZVRlhuQnltRGUzMys2M2VYaCsvdnJmZVhrQkpESnRhZmJ4YXZieGlNL3RiQkY3eHZRaThBQURnUm9SZWo2RjM0dE1UZUczYm42RlhHampOTG5sODMvNE12TkxlWHUvYlA3OW5mMisvZzYrUDVCYXY1TGh0Z2kvZ0grazVhYVJ4Zlc1NTQ1SG05VWNydkViZkx3QUFzSURRNjNHMEprTHAxUnhiZ1ZjdTRKb052dExLcnJUYUt3Mjg0aVQwVzNqOGUzSVRlQUhiOXZ0YzFGUGRsV3RpbjRaZVA4TFhJejI5Wml1OGV0OHZBQUN3aU5Ecld2WUp6MXRodS9meG81T3pub0RyUFhQcnFmWXFWV0hzd2RmKy9QdGo5Z28wNEhXVmxqV21JVmNNdS9hdnNaZlhrYXMxcnFyd09sb0I5dVh6K1hWUkZBQUFvRUxvZFQyendWZnVjV2NHWHgvSmVLbmE2MlA3dmF5eDFkdHJEN3oyaWpRWFdZRFhGa092WEhWWHE1ZFhyTzQ2ODZxTnVkZGZDNzVtQ2J3QUFLQ1RZT0VPZmsxWVppWXRSNnNLamdaZnJkNWVwYXVseFdxTXVCU3AxRUFhZUUzN3NzYmVLcTlhUS91ZWMxWnY0RlVLdm1ydm8yZi83SkpJQUFDZ1F1aDFKeWNFWDNGLzYzR3p5M3hLazhmMDZtaWwzanU1d0N2WGUyZWZWQUt2SjU1blNqMjhjc3NiWTVnZXowbEhBcS9laXEvUlNqQ0JGd0FBbk1UeXh1ZFNXZ3I1TS9rYWc2KzM3ZXZWSEVlWE9xWWgxOXYyZThuaXZneHlYK2E0My84V3R1T1ZITk9tK3ZwN3dldUl3Vkt1eXF0MGl6MjhXbUhYWitiN3JBcTR6Z3F1TEcwRUFJQUJRcS9uMGVvZDA5dnJhNlRTS3hkNnZXKy9yOXdZdzY5MDRwb0x2K0pWSFBmWExQaUMxeEFEcjlMU3hUVGtpcUZYcWZLME4vQmEzY1IrRllFWEFBQU1FbnBkVXk2b1NyZmpjVnZZSHlkZnVjZk5CRjlwMEpWYjZ2aSsvUTYrNHBVY2E0SFgzOXZYSzBQdXdkZitGWGh1NmZrblZtemxsa2ZIb0t1bnVxdTBUSHQxNEhXdllBd0FBRWdJdmE1ck5QZ2FEYlpLU3gzZmsrM1I0Q3NkajFkMFRNT3RQZlRLVlhqRlNxKzN6VEpIZUhiN2VTaUdWNlVlWHJVTFlwU3F2SG9EcjFMNFB4cGtDYndBQU9ET05MSy9vd1hON0V2ak00Rlh6NlN2MU1TK2RoWEhXS1ZSMm80TjdkTUpxVWtpUExlNHJIRS9mK1FxdTBybmp0eFliMCt2M25QZjZncXVVbEFHQUFBc0lQUzZzNFhCMTJ5MVFlOWtieVQ0U2lzdFNwUFJYT1ZHYnJLNnZ6YmdPY1VxcnhoNDVTcTdTdFZlZjIrLyszeU5CbDZ0Z0d0MTZKZm9RQUFBSUFCSlJFRlU4Q1h3QWdDQWsxbmVlRzI5U3h4Ymo1OWQ2dGk2bW1POGltUGEyRDd0N1pXN0FsdXUwZjNmVzM2NTQvNSs5ZmVDNXhJRHBWTHorciszYmZ1L0xSOTg5VloxSFFtOFZ0K0dQeWRON0FFQVlKelE2L3BtZzYrUmFxOFlkS1czZERLYWpyOXY1ZUFyblZ5K2JYLzI5aXIxK1BwSTlwZDZlN21hSXp5WC9kelRDcnRpNEpWYnh0aHp4Y2Fld0dzMkNFdmZrOEFMQUFBdVFPaDFBVy8vK1Y4L2YvN1BmMi9iZUpqVE94R2FxZkNLb2RmYjltZndsVGF0ajhGWERLNXlsVjNwN1Z0bDMxdm12dEFMSGw5YzFsaXI3R3BWZCszM2MxZDB2RVhnTlJwb1dkb0lBQUEzb0tmWFJTem83WFcwK3FBV2hOVjZlcFY2Zk9VbXBhVStYclVyc3FVM1RlM2hPZVFDcjF6eit0TDVvblIxeHlPQjE2MldMZ3E4QUFEZ1JsUjZQWWJaSlk3eDhVZUNyMXlQcjdUQ3ExWHhGYXUvNGhMSDk4eDJxZkxMTWtkNGJHbmdWV3RlSDZ1OWNoVmZQYzNyNzkzRFM3QUZBQUIzSVBSNkhMUEIxMmkxVjZtM1Y2bXgvUjUweFdXUGFkajFzZjBaZkpXV01wYkdjLzI5OWlwRndSYzhsbmoreUZWMDVYcDUxYTcwMmxQaE5idlVjVlUxTFFBQWNHTkNyK2ZRTzZHYXFleHFoVjZ4eVgwdXJOcXJ0L2ErWUxscXJvL3Rud2x1cmVvcjdlbWwyZ3NlVDNxT1NZT3EzSkxHV3ZQNnVOU3hGSHFkSFhpZEhXaHBZZzhBQUFjSXZaNUhhMktVVm9qTkxtMHNWWHExcnVhWUJsL2Z3M1pwbVdPcytrcER0ZjMreDYvWEtQaUM2MHZQS2FVbGpmKzMxU3U4WWpCV3UwcmoyVUhYMmNHWHdBc0FBQTRTZWwxSXgxVWN6K3J0OVNPK2xEQmVDcjAray8yMTNsNnhyOWRuMk81WjVoaXY0cGplUmo0RDRQWmk0Tld6cERHM1B6YXlieTF0bkwxcTQxazl2RXBMSWdFQWdCTUl2UzdteE9DcjFudG0yLzRNdUdMZ0ZRT3lHSGoxOVBaS1E2N1ltNnNWZXBVQ3J5M1oxL01aQVBlUnEvQ3FYWjJ4dEx3eE5xL3ZDYnhHbTltdjZ1V1Yrd3dFWGdBQWNFTkNyK2N5MjlzcmpwY0NyOXlTeDVIZVhuRjVZM3JjeDVaZjZyZ0hYYlhsamxzeUJsekxmdDVJdzY3UzFScHJ5eHpUNEN2MkJEc3IrR29GWUwzdmZaU2xqUUFBc0lEUTYvbU1UTVJ5b1ZldTRxdm5hbzZmVzc2Q0svZVlmZDgrOGYwb0hGK3EraW90Yi95eC9RN0JnUHRMQTYrZVBsNjVzQ3NHWDdGU3JOVElQdGQvTURkZXF2QWFyZmdxdmZkUkFpOEFBRmhFNkhWQk4rcnQxYk5NSjlmVEt4ZDZmV2FPcTRWVWFVUDZlSFhIMHZPVW5pOE4wRFMyaCt1WURieHFmYnh5VjIzTUJWK3p2YnRHeDBlWFFKYTJBUUNBRXdpOUx1ckd3VmR1TEcxdVh3dTlZbSt2dEtxaTF1UHI3K1JycmtmWFh1WDFmMXRmZUphKzFwSFBBVmd2dDZReHQ0U3gxckIrdEk5WHFlTHJhRSt2dUIzZm84QUxBQUF1U3VqMW5FWjdlOFh0V2crdjFqTEhrUjVmZStEMWR6Z3UxOXNyVnoyMmIrLzJFTzRqMlFadUx3Mkxhc0ZYNjFaYnZyaXlsOWRvSmRmSTV6QjB2S1dOQUFDd2p0RHJlYzAwV2E1TjhtWjdlN1dXTys1ajM3Yy9HOWJYcXJyaS9hMXc3TFlKdnVEVzl2Q29kcFhHVWgrdjlOYTdyREVHVzdOQlZ5bjQybzBHWHdJdkFBQzRNNkhYaFMxYzRsaWFTSTB1MTZrRlg2WGVYcmxsaUxWbTlLMWVZSzFsanVsN0YzekJiWjBWZUgxdVk0SFg2Z3F2M2RGS01Fc2JBUURnaG9SZUYzZGk4QldQMysvUEJsK3h0MWV1NG12Zlh3cTE0bkxHR0lLMXJ1QVkxZllCYThYQWEvUktqYkhIVnludzZsM0tlTmJTUm9FWEFBQThDS0hYY3lzRllIRi91cjBIV3pXdFpZNnRpcTlhSmRmZTMydC8vRWQ0N0dnRjJMYjlXV1VHckxlZk8wcFhhZXlwOElwWGEwd2IxNWNxdkdZcnUxWmRqYkVVWkZuYUNBQUFGeUQwZW40alN4N1RpVm9wK0hyYmpsVjh0U3E1MG1QM3dHdkxQSzRuQ0l1diszMERWc3NGWG5GWlk4K1N4bHlWVnhxRTlWNmxjZlJxamJNVlhBSXZBQUM0T0tIWEE3aEJiNjkwZjg5eXh6MFFtNm40aXIyOVNyMitSbzlyVlhKOS9IcE5naTlZcDFiaFZWdkdXQXE4Y2hWZk0xZHdISzM0bXUzeEZUK0gxdWNFQUFEY2tORHJRZHdvK09vSnZkSUtzRnJvVmF2NDJzZmpzc05jbFZicnVOem5VZnFNQkYrd1RocDQxU3E3L3ZmWDdmK1NyN1VLcjlqSS9xd0tyNk1WWVBGemFIMU9BQURBalFtOVhrT3J0MWQ2WEUrbFZ6cHBiUFhVNnFuNDJqTDc5LzVlUGNmMTlQWGFDYjdndUZyZzFlcmpsUVpmNlhHMVBsNjlGVjY5UWRqbzBzYlppaStCRndBQTNKSFE2M1dNQkYvcC9hUEIxMmZ5ZkQwOXQySW85bitONDBxVlhtbEZXU1Q0Z25tdHdLdTBqUEYvdDIzNy81THQ3OXZYd0N0OXZ0a0tyOTdLTDRFWEFBQThPYUhYQTFtd3hIRjBBcFpiMHBoOWFaWFhsRHN1ZHl2MTdIcmIvcG53cHNlOWgrUGlZM29Jdm1CY0x2Q0t5eHIvM240dmFVeVhOcWJoMW41czdzcU1hZmlWYTQ1ZnF3QTd1M2RYNmZPWXBZazlBQUNjU09qMVlHNGNmS1VUdWxydzFSTTI1WHA3NVNxL2NwVmNwUXF4STZIWHRnbStZTVFlZ09lYTF2Y0VYcVdtOXZHS2phV0FxM2ZKWTI4dkw0RVhBQUE4T2FIWGF5Z3RiV3hOdUhwN2ZPMUxISGNqdmIxNktyNmlYRUEyYXcrK1JnTXplQ1Y3U05RYmVKV0NyaGg0N1Y4L3Qzcmd0ZXBxamJsejE1R2xqcnZScFkwQ0x3QUF1QUdoMSt1WUNiNTZRNis0QkhLMHQxZFBKVmRPN3ZoUlA3ZC9ncTkweVNUdzI2ckFxOVQzNjFhQjEyekZsOEFMQUFBZWxORHJBVTBzY1J6ZG54NlhtOHoxOXZpcU5iZnZXWTVZQ3JWcURmRjdsQ2FsZ2kvNExRMTRlbnQ0cFUzcmN3RllYTXI0dWYwWmhwMWQyWFgwVnZxTUFBQ0FDeEo2UGFnYkIxL3AvVmFQcjdmdHp5V1BQY0ZYU2FueTYrOXRiZWlWM2hkOHdaOEJkMndtbjE2WmNiL2ZFM2pGSGw2eGFremdCUUFBTENYMGVtNHgyQ3B0anp4ZnozTEhQUkNiRGJWbWx6dTJYbnQ4M2FWOUg4bjNnMWRUQ3J6aThzVGNyUlY0eGVDcnQzRjlLd2hiRllqMWZqYlQreTF0QkFDQTJ4RjZQYitWd1ZkUDZKWHI3VlV5RzNyTlZuZkYxeDIzMDhCTDhNVXJTcGN6eGdxdnRDOVhETHB5OXdWZVliL0FDd0FBYmt2bzljQTZsamlXbEpZMnRpWmtvejIrV3FIVzUzYWZVS2tWM3UzZU44c2RlUjJ0d0NzWGV2VTByNThKdk00T3VtYVhRTWJQcXJRTkFBQmNnTkRyd2QwNCtLcE45SExCVjA4bDEyZm1jYXVscnpHM3JMRTBzWTNWWG9Jdm5sSDZ1NThMdkhJOXZHcVZYUUl2QUFEZ0VvUmVUK0RFcHZaeEloY25kM3ZROVI3MnA1UExtYURvU08rdWtsaVJscjZYM09RMkxubFU4Y1V6eWdWZXBhczAvdTlXNytkMUpQQ0tnVlpwUEFaYXBmSFZRVmY4dkVaWjJnZ0FBSGNnOUhvU053cStjaE8rTlBqS1RScExTeDlyVm9aZSsydjRWeGdidmUzQjEvdkMxd2IzbFA2TjFnS3Z2N2Q2UlZlOHBmMi9CRjRDTHdBQXVCdWgxMnVKd1ZacGV3dmo2ZU5yazhIZWdHczAxRHA2MWNiU2hITW0rRXBmai9DTFJ4UURvZHh5eHR5Vkd2Zmc2Kzl3UC9iN1NoOTMxYWIxcTRLdTVuNkJGd0FBM0kvUTYvV3NDTDV5ejdtUDl3UmY5d3E5ZWlhOXJhdTdwVlZmKzJ1RFJ4R3JuMkoxVis0cWphMGxqWCtIeCt6UElmQVNlQUVBd0YwSnZaN0l3cWIyb3hPMVVtK3YwYXM2dG83ckVWOTdiNkJWQzhIU3gzMGt6eHNiM2NPVmpTeG56RlZ3amZUdW1nMjhlcGMySG0xYTMvcU00bkd0YlFBQTRJS0VYay9tSXNGWHEvTHI3TkFyTnpuTk5iSHZDYmwraFBGdjIrL0FhLzlxdVNOWGx2NSs3d0ZTTGZBcUxWc3NCVjZ4T3V4ekUzZ0JBQUFYSVBSNlFnZWEycmZHVzJMQXRGZCt6VFN6MzEvSHF0Q3JOSlpPanROSjhuNy9YNW54V0RXV0xuZmNYemRjUWF6dWlvRlhHazZWbGpQV1FxLzQyTS90ejJxdlZZSFhhTlA2MlNXT3F3SXVTeHNCQU9BQ2hGNVA2azdCVjY3QzYwandWUXU5ZWllamZ5WEhseDdibWp6L2xSbi9LeHovdnYydSt0bzJ3UmYzbHdhMHVhc2p4dEFxRjNiOWIzSk1MZ1JMKzRDMXdxNVlYU2J3QWdBQVRpWDBlbTJsZ0t1MXZ6U2hLd1Zkc2RkWE9rbXRoVU9mamRjMkVzU2x4OGY3bjRYWEZwYzVsc2ErYlg4dWUxVDF4VDNGMzg4WWVKV2F6WmVhMXNmUUt4ZVlwYzgzVXRFMUczaXRhbDVmT28rTWp2OTd2OEFMQUFDdVErakZMWU92M0dTelZnSDJ0djB6NGQyLzMweklWYXZnMkw5L0RNUFM2cGkwc2l1ZFhLZjc5c2ZzZmI1VWZYRVA2ZTl2dXBSeEQ1ZlNYbHU1Q3EvYU1zWjQ3TDY5UDNjdDhJb2hsOEFMQUFDNENhSFhFeHRvYWgrRHJkTDIxaGhQbnkvZE45dlRxL2FjcmVOR1FxLzlOYVlUNTgvdGE5Q1ZUc2IvbFJtUFRlN2ZmOTAwdXVkTWFXaGI2dDFWNitFViszUEYwQ3QzUmNZMDhPcnAzeFdEcmJNQ3I5RUFMUDBNcTRGV1l6OEFBSEJCUXE4bmQ2ZmdLemRCUEJwODlVNVNleWFucFlxenRBZFNLZkJLUTRWYzhQVmoreWYwK3JiOXJ2amF3Njl0RTN5eFZxdTZxM1NGeGx5UHJ0SVZIT09WR0Z1QlY2MTNWKzYrd0FzQUFEaUYwT3NGREFSZlVXL3dsWHRjYnBKNEpQaGFHWHFsamVoTGsrVGN4SHFma0tlQjJGL2JuMEhZWHZHMWgxOXBCWmlxTDFZcC9hNldncWRTcUZVTHZISzl1bm9DcjVIZVhmZGUwamk2WFdKcEl3QUFYSkRRNjBYY0tmaktXYkhVc2ZUOVdrc1o0KzJ2eWpFakUrOWNKZGplM0g2Zm1IOXN2L3Q4dlNkZllWU3NiaW90SFV4RHFYU1pZcTdDS3daanVXV05wYkNySitRU2VBRUFBRGNuOUNJVkE2N1MrTkVKWGpwaFgyVW05TnBmd3g1T3hlV0xjZnZuOW5XQ25rN1U0L0t5eitTNTk2L3Brc2R0MCt5ZVBqK1RyL0Yzc3hSNDVjS3NVcFZYN3JpWjZxN2V5cTdWZ1ZjckNNdDluak1CMTVmbkVYZ0JBTUIxQ2IySWJoRjhwUlBNMGVCcmRIS2FIbDhLdmZZbGk3VUtyOXp4TVh6NEszeU5FL205ejFjTXYvYmxqaXEveUNsVklPYkNydEp5eGhoNDVYcDh4YTh6RlY2NTBDc1h6Z204QUFDQTB3bTlYc2lCcHZhOTQ3MzJvT3M5YlBjNEkvU3FUWmgvaEsrbHdDdmV2bTIvdzY4ZllmeHorOTN2cTlUb1h1WFhhNHUvczduZnQxenZyaGhleFNzd2xxcTdjby9kdjAvcDZveTFwWXN4OUlwL0o3Y092SHFYT0xiR0FRQ0FCeUwwZWpFUEZIeTFxaldpMWpMRzBqRS9HdnRMbFdGcG1GV3Erb3BMSHI5dnYzdDlwVXNxMCtCcnYvM2NWSDY5cWxqWmxWWjR0YXE3WXBBVm05S1BWSGZsdmtlcndxc1VoSlZDTG9FWEFBQndHcUhYQzFvUWZKWDJyd3krM3JiYmhGN3B2clNxYTcvaVltNkMvcEZzLzJ2N09xSC9LL09ZUGZDSzFXQWYyKzlsanpIODJqK0g5Q3ZQcWFleXExVGhsUXV3V2tGWHJycXJGR3FOVkhpdDd0MTExY0RMMGtZQUFIZ0FRcThYZGNIZ2ErOXJ0V3RWZ09WZVIydThWY0VWZTNmdDRWZWNnT2NxdTc1dmYvYnkraDdHWXVDVkJsOXBqNi85bG9aZmIrSEc4MGgvUDlQZndWSmxWL3lhQzdKS2xWeXQ2cTc5Ky8yOWZRMjNlaXU4U2oyOFppcTdCRjRBQU1BaFFxOFhkaUQ0NnQzdTlXUExCenE1NEd0a3dyb3ZFVHdTZXUwaFY2ejYyc09xUFFCSVE2MFlnTVVlWDduOUg1bmJIbnJGaHZmcDV5UUVlenk1MzhjWW90WjZkOFVxcjFKRlY2a1NMTDIvaDF5NTVZeTUwS3Vud3F2V3crdXN3Q3YzR1F1OEFBRGd4UW05WHR5RmdxOWRyT3hxVlRmVkpyZDdZRlE2dGlmMDJyZHpGVjlwK0pXclpzbFZmTzNMR2ZjZ2JBL0RZdUMxTDMxTXIvYTRCMTlwQUxadGdxOUhrVnZDV0ZwQ1c2dnNLbFY1Zlc3MTRPc3pNLzRqN0M5VmM5VXF2RnFWWGEzUUs0WitBaThBQUdBSm9SZFhENzZPaEY2MXBVNnRXeTRFMjhPb0dGUjhiSDlPMXRQcXJiamtjUSs2MHRBckhkOURyeGlRNVpyZEM4Q3VyMVJsbVB0OXlTMW5MUFh2U2dPdW52RmNjSllMdkdvQlZ5MzBLbFYydFVLdjNPY3hFM2lWL283ai9ramdCUUFBVDB6b3hiWnRsdzYrU3IyOVdzNEl2VW9WWG5zd3RlOUxRNnkwYXVldjdjK2dhOS8rQ1BzK2Z1My9DR081WnZlMXZsOENzUHRKZi8vU2FxYjBkNmxXS1pXcjdNbzFuYTh0V2N3MXA2LzE3dXFwNmhxdDdPcXA4b3AvWHdJdkFBQmdDYUVYL3pZUWZFVlhETDZPaGw2MXlweDlNcC8yK3NxRllHazFUVnF4dFM5cExGVitwY3NiYzFWZ01mejYyUDZzK3RxLy90d0VZTGZ5TS9PMUZIVGxLcU55b1ZNTXJXcUJWeW5nK2t3ZW0zdiswdmN2dmJhamxWMnQwRXZnQlFBQUxDUDA0ZzhQR0h5MXdxcmNjYjJQcllWZU1meUsvWmpTSlkvN2NzVTl3RXF2NkJoRHIxamRsUzUvTERXN0x5MTkzRzk3TTM4QjJGb3g2SXJoVEJyWTlJWmRwUXF2WERWWDdOY1Z4MnU5dVZyQlZxdkNxeFJ3MVVLdjNOOVJEQWRyOTN2L2h1TytTT0FGQUFBdlF1akZqQmhvbGNadkVYenRGVTJqb2RmUDdYY1kxQk51dFc1L0pZL2Z3NnBZK2JXSFh6SHdpazN1YytIWHgxWU92bkpYZTh4VmZ1V1dRRzZiRUt4WFQyQmFDcnBxZ1ZjdHhHb0ZZWi9iMTlBcnQ1UXhkd1hJM3FXTFBSVmVyZENyOVBmVlc5blZHM3JGOFVqZ0JRQUFMMFRveGF5emc2KzlNaWtHWGJuQXBpZTBpWlBqOU1xT2NYdzIrSXBoVnhvRXBFM3AweVdMdGNDck5qWlM5VlhxK3hXWFFRcS84bUpZV3F0SVNuLzJlL0JWQ3BOeVYyZk1MVk1zSFpjTHUzTGhWOXdlQ2JWR2x6RFdxcnhpNkRWUzJTWHdBZ0FBaGdtOStPSkFVL3ZTK0dqd0ZZOVBnNjlWb1ZlcDR1dDltNjhBaTFkZDNFT1BiNWw5YVpnd0UzakZDckMweWl0V2ZlV3U5bGdLd21wTElKODFGQ3NGSlB2WFVrWFgvdlBOVlhpVlFxUmNBSlVMdG5JVlhhWHdLejdmajhveEkwc1dSd092MnExVXlkVmIyU1h3QWdBQWhqM3JKSllGZnY3UGYvY0dTcVhqV2dGVmE4bGRyRWhxM1krQlR1OHRCa1hwV0M1RUdybjlsVHd1Vm1qbGxpNjJncTcwL251eUhlK1gzbGVwK2l1OW4vdlp4Si9MTTZnRkpyV2dLLzFhcW00cWhVZTE0T3A3ZUZ5dWgxZXRzaXN1Wlp5dDdLb0ZYRDJoVnk0a3JvVmVBaThBQU9BVUtyMG91a0RGMXk1V2VMVXF2M29uMGJtS3IxS2xWeHlmV2ZhWVZuWGxLci9TaHZjOVlWZ011OUtLcjF3QUZ1L253c0pjRUptckFwdnBDWFoyV05aYlFiamZMd1ZjMjFaZXVwZ0xkV3JoVUF5eFNzRlhUNlhXU05oMXBMSXJGK2FWN3M4c1pSd0p1bTRWZUFFQUFFOUk2RVhWSFlLdlZpRDJJem11cCtkWCtqcHF0MWpsRlI4VFE2K2UzbDk3a0ZVS3VHcmhWeTdRaWwvVGFxN1M5bnZZMTZyNjJ1OXZXenNJMnlwZjQvMzk4Nno5SHBYMjFVS0xVdEFSNytlK3RtNjF5cVZTWlZjYUlLWGhWUXltY2wvVDU2bFZhOFZ3TEJleXJhcnNxdTJyZlM0cktyc0VYZ0FBd0NIUHNreUprOTFocVdOcFBOZU12ZFNrUGJlRXIzZTVZOC9TeDlxU3g5Wnl5RnhJbFZ1bW1MdGZxdlFxYmRmNmZMV1dQYmFDc0sxeFAxWHJGeGFQMlkwRVhxVmdxM1QvUnpKV3ErektCVDB4M01vRlVMa3dMTmVINjN0NGpuUmZMZ2lMeDVYQ3JGYXcxVnZaVlJxclZUMGVyZXk2ZGVCbGFTTUFBRHdob1JmZFRncSs0cjdSMEd1MDU5ZG8zNjlTWDZ4YXVOVUt2R29WV3JuOXBiRjB2RmI1VlZyZTJBckFhc0ZpS2ZocUxZRXMvZjcwVmhMV3htc0JWeW53eW0yM2x1N1ZLcnRpU0JVRHNseVZWMmwvS1RRclZXdlZ3clpTeUhXMHNxdFVFWGVrc3FzVmVzV3hTT0FGQUFCczJ5YjBZdEFKd1ZjY253bTlibG41ZFZZRjJMZndYREhzaWxkbzdGM09HTU94VXZEMWx0bFgra3h6bjNIcFo1WCtITGZNK0JHNUVDUWRMNFZmcFNXTVBjc1lTeFZUdWFxdjJuTEhOQlJMeDM5azlvMVVkbzBFWExYUTYxNlZYYjBWWFFJdkFBQ2dTZWpGc01IZ3EzVC83T0JySlBRYUNjQldWb0Rsd3E5Y2RWYXBDcXpuOGIwVlgrbm44QkhHM3JZL2c3SFNaOXdLdldyVlhqT1ZYcVVRWkNSVUdhbGt5aTMvRzZuMGl1RlZxU3FyRkd6VndxeVppcTVXNk5WVHpWV3I3T29OdjBvL3N5M3NLMjIzeGtzRVhnQUE4T1NFWGt3WkNMNTJ0UkFrZDl6UjRLdFZBVFpiOWRXcUFLc0ZYNlBCMkxmdzJ1SVZHVXVoVjZrQ0xBMitjZ0ZYNlZZS0RXc2hZK3ZudDBKdENWd3Q1T29OdmZidDJoTEFVaGdXSzdmUy9hVXFydjE3ZnM4OHB0Wjc2OGdTeGxiZ1ZhcndhbFYyOVZaOGxYNTJjYnkwM1JvdkVYZ0JBTUFMRUhveGJWSHdWYnJmRzNyVjlyV3F2bFpVZlBWV2d0VkNyOTVnN0czTEIxeDdJRmFySkl2ZjYyMHJ2N1pTMEZXcThtcUZYcVh0STFZRVhxV3FwVnJnOVhPckIxQnBrSlVMbm5KQldPNlkzcVdJSTRIWTZLMVV5ZFViZXZWV2VjV2ZYeHdyYmJmR2M4ZHQyN1p0QWk4QUFIZ05RaThPV1JCOGxjWkhRcS9hL2oyMDJUSmpNMVZmSThGWTd4TEkzbUNzRm1MRkFLeDJ6QjU2dlJYRzQvdU5QYjVHZzYrZXdLdjFPOVFLTzJZRHIvVCtaN0tkVmw2bDkwdVZVclZBcWhSMC9jd2NVM3Zla1NXS3JjQXJ2cGVlQ3EvUzU5WWJjUFdFWHIzYnJmRXZ4d202QUFEZzlRaTlPT3pPd1ZkdFh4ckliTnZYWUd1bThxc25HS3VGVGFXZ3FpY1VpOGZFNVkvcDg5YStWeHA2NWZhWHFyeHlsVjY1c0dzZlMzOHU4ZWUwVlk3SnlZVWdjVHplTDRVeHJTVjdwWkFyanVXcXNlTHhjU2xqckJSckJWUWp6ZVpiQVZrcHpKcXA4QnF0NkpxcDhvcjdJNEVYQUFCUUpmUmlpVHNHWDZYeDNIRXh1Qm9Kd0hyR1p5dS9ha0ZaNzFpdVNxdldjNndVZXBVQ3IvVHp5bFYreGVOMmUrRFlFNEsxMU1LUEg3L3Uvd2pqcmZBckJqMmw4ZEoycWNxcUZYUzFucU0zOUdvZDF3cnVTdnRYVjNUMUJGNGp3WmJBQ3dBQWFCSjZzY3lkZ3EvY1dHMXBYVzBaWGsvRjEyZ1kxaE5lclFyTFdrRmM3cXFNcGZIV2tzWlNnTGp2Ni9tNWpmNitiRnU3U2lpOVAxTHBGZmQvRm82cGhWYngyQ1A5dEdaQ3I1bUtydEw3S3dXRXN3SFhrU3F2U09BRkFBQjBFWHF4MUIyQ3I3aGRDN3hhdDF3Z05CcUl6VlNBblJHVXhWQ3JWTUhWZXIyMWFxN2FXQnAreGM4L0hZdEt2enV0cFcvcFdFL1lWUnR2TGZXclZWVFZRcWFlVzY2U2JDUThxNFZZUGFGWDZYT2FEYjF5UDZmY2VHazdFbmdCQUFEZGhGNHNkM0x3VmR0WHF5U0tTKzlxRlV5alZXQzFZS3UzQW14bFVOYnpQYmZNOTR2TEhucytsMXI0bGZ2WnBFRllWUHU5cVMxeis1SFozeHQ0OVZSL2pZUmJyZXFxVm1DVkM3Mk9QTDYzb3FzVmFoMnA4b28vanpoVzJrN0hjL2RMQkY0QUFNQzJiVUl2VG5KaThGVWF6NFZlNmZoNzVmamFVcjJaU3JBandkZG9TRGJ6L1diZXowallWZnZaeExFdGpOWEVhcTUwdkJWNjlRWTN0YXFubVlDcFZtbTFJakRycWV4cWhYbEhnNjJSMEt0M3V6VmVJdkFDQUFEK1RlakZhWDRGWDd1ZTM3VmF3Rlc2M3h1dWxLcThSaXVaU3N2NzR2aElFTlVUbW8yR1pLM3ZOL3ArWmo2ejNNOHB0MzlHR29iMGhsNHo0VTV2Y0RRVGhJMHNRenhhMlpYYkxvM05CRnNDTHdBQTRIS0VYdHpFUU9WWDY3aFd4VkJ2NERKekd3bUlTb0hXMFlDcUo4QWEvWDZ6b1ZjclRJeGpwWi9SakZySUZiZHJ3VXhQTURaYUxkVmJnZFVUaW8wRVd5T1ZYQ3NydkVvL2cyMWl1elZlSXZBQ0FBQytFSHB4TTRQQlYrNStPallhZktYalBZRk5id2cyV3ZtVkM2Skd3cW1ScFlxOTMyOVY2Slg3SEZzL2s2MHh0bTNsVUNTOVh3cGZhdU90MENzWEJ2VXNmNXdOcW5vQ3JOa0FydmY5dGNLdDN1Q3J0bDNhMXhvdkVYZ0JBQUJaUWk5dTZvNVhkMHpIZXNLYTN0Q3JkYjgzbEpvSnRFWkNyOTVqZWtPdjNHY1dQL2VlbjhuVzJOOEtRR29oUyt2K2l0Q3JKM0E2c2tSeUpORHE2ZEYxcE1JcmZzWXpvZGZzZUluQUN3QUFLQko2Y1hPTGc2L1NNVDJoVjJtOEZ1eVV3cTlXU0RRYU9OMHEwRG9TZXJVK3U5elBvWFMvTkRZYmVLWGJQYUZOYnpnMEduak5obGdqRldXdDhkNWplajZiM0dmWSt2elQ3ZHo5MHZFdEFpOEFBS0JLNk1WZExBeStTdnVQaGw2MWZibVFxR2RmSzZqcURiQjY3ODhHV21lR1hxM3hYcm1BWkdYb2RTUkk2cjAvc3pTeHRXUnhkcXozODJsOTFyM2JrY0FMQUFCWVR1akYzVXdHWDduNzZWaXJxcWdudUNtTnAvdDd3N0RaZ09sSWdGWDd2cjM5dWthV04vWjhodEdSMEtzVWtKd1ZlaDBKeGxiMEJoc0o0R3FQNlhudjhYTThFbnFWOXBXT2FmbjNNUUl2QUFDZ2g5Q0x1NW9Jdm5halljcDc1WmdqRlV4SGdxTVZ3VmhQWURienVucHZwYytqOUZtM3hudmNNdlNhRGNaR2wwVDJCbWdqWVZ3OGR2VDk1NDV2ZmRiUjZIaUp5aTRBQUdDWTBJdTcreFY4N1VaK0owY0NsVm9RMHhQZzFLcWFldmJOQmw2dElLdTF0SEpsd05YNlBIbysyOUxZcUZ4b1VndGllaXVaVmdaaHRXQnFwR2ZZelBPWDNsL3RQWmVPTDMyMnZmc2lnUmNBQUhBVFFpOHU1Y1NyTzliMmpWWXRqVlE4OVFaWlo0Umx0ZU5HWDJ2UGU2MTlucVY5VVdsZktUeEo3L2RzdDhaSFFxS2pvZFRJY2EzZ3JQVGFlMTkvNytjVTlSN1h1Ly9MOFFJdkFBQmdsdENMeXpucDZvNXh1eWVZcVlVNXZkVlBaOTFXaEY2enIzUGtjOW82eG52Mmo0WXBLMEt2bm1OV2hGNHp6MzhreUVyMzE0NnRmWlk5KzBySDl4SjRBUUFBaHdpOXVLUVRydTZZTzZZVnp2UlVNSzBLazJZZWM0dlFxK2Z6T0RQMDZnMU1Wb1ZlOGJHMS9TdENyNTdnNm96UWEvUno2OTJPV3Z1TGp4TjRBUUFBUndtOXVLd1RydTY0ajVlT0t3VTZ0Y2ZHWUtoMGY3WjZha1h3ZFRUMHloMDMram5sN2tlbDBLc24vQmdKdlhKanZaVlJ0ZjB4OUZvUmVQVit2NTZRYnVSenFtMlg5a1dqZ2RlL2p4VjRBUUFBS3dpOXVMUVRydTVZMnpjU2N0VzJaeXVwYXNmM1BOZkliZVQxbFY3ajdPZFVjb3ZRSzdkOVJ1aDFKS2hxQlZZenIyL0Y1N1IxalBmdS8zSzhvQXNBQUZoTjZNWGxIYnk2WStseFBaVklLME93VW5CVk9uYjJ1TjZnTEw3ZWtkQnJkanQzUDhxRlhpVzlGVWl6MjZQaFUyM2ZrUkN0ZFZ6cDlhMzZMRnIzZS9lWENMd0FBSUJUQ0wxNEtBY3F2OTRyKzByUGVUVFk2UW10U3VPOTRWVHJzYlg5dmQrLzk3M1h0cmZPZmIxcWxVUm5oRjY1OGRrQXF4YVN6WHovM1A2ajd6MWFYZG4xNzhjSnZBQUFnTE1JdlhnNGs4RlhxOUtvcHlxcE45anBDWTVHUXEzY2VNLysyY2ZXWGwvcGZZK0VYdHYyOWRnZXZaVkV1UUJtSk93WnViOHlHQ3Z0cjQydkRybHVVdG0xM3hGNEFRQUFaeEo2OFpBT1ZIeHRXMThnTTFQNUZjZDdBck1qNDdPUHJlM3ZmYTdvNnFGWGJueWtVbXBWTURVVG5QV09wOXV0OTFqYWJvMzM3aTgrVHRBRkFBRGNpdENMaDNXZzExYzhmbFhsVjJuOFNNVlhmTXlxTU8zSWMwUXpnZGZSYzg5c0tETmJDVFV6ZnZRNWV1L250a2ZlWCt0KzcvNFdnUmNBQUhCVFFpK2V3a1VxdjByakl5RlR6ekZuQldxajM2djIrTnd4dGYwelJvS1pvNVZRTThGVTc3NGpGV2lsN2FQSGplNXZFWGdCQUFBM0ovVGlhVnlrOHF0MGYyUTdqczBFVm5IN2pDQ3VOZDY3ZjZYUlVHZGw0RFJiUlRaNmJNOTI3YmpXL2Q3OUxmOStqTUFMQUFDNEI2RVhUK2tCS3I5RzloMEowRllFWnFYdDFuanYvcFhPQ3IxNnRsY0hWNjNBNmtnRmw4b3VBQURnNlFtOWVGb0xncS9jL2RiK28ySFlTQVhZcmJacnI2YzIzcnQvcFJXaFYyM2Y2bXFzVzFadzlWWnV6UVplS3JzQUFJQkxFWHJ4MUE0R1g3dWpvYzZSMEt2bi91cnFyYU9WYktQN1YxcFY4YlFpb0JvSnBucjNyUjZmUGU3TDR3UmRBQURBMVFpOWVIcWgxOWUyemYzZWoxUit0UjZ6cXBMcWpFcXhJK081KzdXeDNtTkd3cFRSbmxVcmwwTDJIblBrdUo3eDF2M1JzUmFCRndBQWNFbENMMTdhelg3L0FBQWdBRWxFUVZUT2d1cXYzc2V2REpSNlE2K1p4NHhXYjUxVjJaVjczSkdsZHJOTCtGWUhWVFBWWHJQanEvYjNFbmdCQUFDWEpmVGlKUjI4MG1OOFRDc0E2bjNNclVPeW1lY1kyWis3MzVJTHZVYWRGUWoxVkhiZGNqeDN2M2ZzVU0rdW5jQUxBQUM0TXFFWEwrOENsVit0L2FOTENzOE0ybnIzang2M1NrOEYwOHJRYTl2S1lkS1pTeTE3OTQ4ZVYzeThnQXNBQUhnMFFpL1lsbGQrSFJsYkdVRGQrbkZIanoxcUpOaFpIWHlkK2JqYy9SVmpMZjkrak1BTEFBQjRSRUl2Q0JaZDhYSGJ6cThBYSswZmFTNC9lMnp0TlkwY3Y4TG84cjJSUUduMjJIVHNGajI0OU9vQ0FBRDRSZWdGR1FzcXYzS1A3ZTJCTmZQWWUrNC9ldndaUnNPZnMwT3BGYUhaN0hQM1V0a0ZBQUE4bFh0UFRPSHk3bEQ1TlhyODJVM25lOGQ2OXQxU2IxRFVPM2FMU3F6VllWMzM4d2k2QUFDQVozT1Z5U2xjMmttVlh6M1B0eXFFV3RsMC9ncVZYRWV0WGk0NGNsenVmbTFzOXZqdTF5THdBZ0FBbnRHalQxemg1aFpXZnUzT1hqNTRSdWpWTTNZbHM0SFJXYjIwN2xYUjllL25FM1FCQUFEUDd1b1RWYmlrVVBtMXUzY0YyT3h6cGNmTVhybnk2dWVTMmRCb3BvS3JOamE3YjBsRjEwN2dCUUFBdklLclQxVGhZVnlnQXV6UkhuZExaNGRlOTM1Yzhma0VYQUFBd0t1NitrUVZIc3FOS3NDTzdxc2RJL1Q2K3JpZXNaRmpadmNOZjArQkZ3QUE4TXF1UGxHRmgzZENCZGp1NlBQZTY2cVU5N0RzS29jSG4yZDFKZGUvbjFmQUJRQUE4S2VyVDFUaEtaeFFBVGJ5SEVjcndub2VjL1Z6eWFvK1dVZXJ0RllGYjM4UWVBRUFBSHgxOVlrcVBLMFRLOENpcS9RYXU1TGx2Yk1XUDEveCt3aTRBQUFBK2p6NnhCVWUyb2tWWURQUE9mSjlILzNjTVJJYzNhcUNxL21jQWk4QUFJQitqejV4aGFkend3cXc2QmtxdUZhN1ZRWFhsKzhyNElMbjkvUC9jYzZGVzN2N2YrL3kzM1VBN3NUL2JNRUZGU3JBZG1mKzNkNnF6OWd0bk5JL2E2SGljd3U4NFBrSnZPQitCRjhBcitQYnZWOEE4RlV0OVBqNVAvKzliZWNGUzZ2K0ovRGVrN2w3VldqMVVza0ZBQUJ3c250UFRJRUpqVXF3M1QzL3Z1OTlicmxub05UODNnSXZlRzJxdk9EK1ZIc0J2QWIvMHdWUDZvNjl3VjZaQ2k0NFFCZ0VjQzVoSC9CcS9NOGxQTEhPaXJDZDgwRmU5LzhjQ3J4Z25zQUw0RFlFWDhBcjBkTUxudGhJQ0hOeXI3QkhwWElMQUFEZ1FabmdBdjgyV0JuVzYxYm5tZVhobE1BTGJrT1ZGOEJ0cWZZQ1hvWC95UVJPZGFQZVlpcXlZQk1lQWZCY2hIUEFVZjduR0RqZFNSVmsveWJ3QW9FWEFNOUo4QVVjb2FjWGNEcWhGQUFBQUxmbVg0VUI0TUdwOGdMZ21hbjJBbWI1bjJRQW1DUnNBb0RYSVh5RHgrTi8xZ0ZnZ3NBTEFGNlA0QXNleS91OVh3QUFBQUFBck9aZnFRRmdrQ292QUhoZHFyM2djZmlmZGdBZWx2QUpBSGdWd2pZWVo3SUF3RU1TZUFFQXIwYndCV1AwOUFJQUFBRGc2ZmhYY2dBZWppb3ZBT0JWcWZhQ2ZpWU5BSnhHT0FVMzVlK05WMkN5RHpjaVhPTVorSjhqQUU0aDhJS2I4dmZHS3pFUmh4c1JmUEhvOVBRQ0FBQUE0T240VjBFQWxsUGxCVGZsNzQxWHBQb0Via1MxRjQvTS95UUJ2QkJoRkUvRzd6UHdhb1FQUEExaEdyZmdmeFlCWG9UQWl5Zmo5eGw0VllJQ25vYmdpN1BwNlFVQS96OTc1NXJzT0k1elcvbUxIbXdQNmM0Mjc0L3FrK1ZraWc4UUd5OXlyNGdLbVFLd0FjbytOZ21ybklRUVFnZ2hoSkRqNExla2hCQnlBYnpMaXh3R1g4K0VrTnZoM1RIa0dIaTNGN0dFaTBaQ0NFa01tMVhFR2I3ZUNDR0VXTUxtQm5HRHpUVHlQRnpjRWtKSVd0andJczd3OVVZSUljUUROaUtJRzJ4OEVmNm1GeUdFRUVJSUlZUVFRZ2c1RG42clN3Z2hDZUZkWHNRWnZ0NElJWVI0d3J0dmlCdTgyK3R1dU1nbGhCQWdiRllSSVh5OWtFajQraU1aNEdhVWVNTFhHOW1HemJPYWNMRkRDQ0VnMlBBaVF2aDZJWkh3OVVjeXdZMGs4WVN2TjdJTkcxLzE0Rzk2RVVJSUlZUVFRZ2doaEpEajRMZDhoQkFDZ0hkNUVTRjh2WkJJK1BvakdlSGRFOFFUdnQ3SU5yemJxeFpjOUJCQ3JvYk5LdExBMThOWjhQa2toRlNEbSttejRmTkxmc1BtbVE5Y0RCSkNyb1VOTDlMQTE4Tlo4UGtraEZTRkcrR3o0Zk5MZnNQR2x6MzhUUzlDQ0NHRUVFSUlJWVFRY2h6OEZwUVFjaVc4eTRzMDhQVndGbncrQ1NIVjRkMGZaOFBubC95R2Qzdlp3a1VoSWFRMGJGNGRENS9mWFBENUlKbTU1ZlhKelJISkRGK2Z1ZUR6Y1RCc2xxMXh5K0tBRUhJZ2JIZ2RENS9mWFBENUlKbTU3ZlhKalE3SkRGK2Z1ZUR6Y1RCc2ZNM2hiM29SUWdnaGhCQkNDQ0dFa09PNDdWc3hRc2doOEM2djQrSHptd3MrSHlRenQ3NCsrZTAreVF4Zm43bmc4M0V3dk50cnpLMkxCRUpJRUd4V0hRZWZUMXQ0ZlhQRDU0Y1F3czFtYnZqODJNTHJXNWhibW1WY3JCRkMzR0RENnpqNGZOckM2NXNiUGorRWtCK3UyRGdXaHMrUExieStoYm1oOGNYZjlDS0VFRUlJSVlRUVFnZ2h4OEZ2S1FraEx2QXVyK1BnODJrTHIyOXUrUHdRUWxxT3YxdWlPSHgrYk9IMUxjenBkM3R4MFVZSVVjRm1Wam40Zk9uZzlkUEI2MGRHOFBWaHc5R2JHYUtHcnc4c3ZKNDZlUDBLVWFWWnhzVUZJV1FiTnJ6S3dlZExCNitmRGw0L01vS3ZEMXRLYkV4SUdIeDlZT0gxMU1IclY0Z0tqUy8rcGhjaGhCQkNDQ0dFRUVJSU9RNStxMFlJMllKM2VaV0R6NWNPWGo4ZHZINWtCRjhmUHFUL05wNkV3dGNIRmw1UEhieCtoY2grdHhjWEdZUmNEcHRYNmVIek00Ylhad3l2RHhaZVQwTElqTlNidjRMd2VvN2g5Um5ENjVNWXIyWVpGMitFWEF3Ylh1bmg4ek9HMTJjTXJ3OFdYazlDeUNyY2FHUGg5UnpENnpPRzF5Y3hIbzB2L3FZWElZUVFRZ2doaEJCQ0NEa09mbXRKeUtYd0xxLzA4UGtadytzemh0Y0hDNjhuSVVRSzd5N0J3dXM1aHRkbkRLOVBZcXp2OXVJaWpwRERZRE1ySEY3L1A3bjlldHcrL3haZWoxaDQvVWxHdUJuTkJaK1BQN245ZXR3Ky94WmVqMEIybTJOYy9CQnlFR3g0aGNQci95ZTNYNC9iNTkvQzZ4RUxyei9KRERlU3VlRHo4U2UzWDQvYjU5L0M2eEhJVHVPTHYrbEZDQ0dFRUVJSUlZUVFRbzZEMy9vUmNnaTh5eXNjWHY4L3VmMTYzRDcvRmw2UFdIajlTUVY0OTBRdStIejh5ZTNYNC9iNXQvQjZCQ0s5MjR1TElFS1N3ZVpWT0xkZi85UG5mL3I4V202Yjd3eGVEMEpJZHJpWi9wUGJyc2ZwOHoxOWZqTnVuMzhJWFB3UmtnZzJ2TUs1L2ZxZlB2L1Q1OWR5MjN4bjhIb1FRcXJBamZHZjNIWTlUcC92NmZPYmNmdjgzZUZ2ZWhGQ0NDR0VFRUlJSVlTUTQrQzNub1FrZ1hkNWhYUDc5VDk5L3FmUHIrVzIrYzdnOVNDRVZJTjNnL3pKYmRmajlQbWVQcjhadDgvZkZTNENDVEdHelN4M2JydmVwODJYODZuRjZmUFR3dXREU0gyNE9SMXordlU1Ylg2Y1QyMXVteThFTHNZSU1ZUU5MM2R1dTk2bnpaZnpxY1hwODlQQzYwUElPWENqT2ViMDYzUGEvRGlmMnR3Mlh6WDhUUzlDQ0NHRUVFSUlJWVFRY2h6OEZwSVFJM2lYbHp1M1hlL1Q1c3Y1MU9MMCtXbmg5U0hrUEhoM3haalRyODlwOCtOOGFuUGJmRlZ3VVVhSUVEYXp6RG45K3A0MnYycnpxVlp2Uy9YNlo1dytQeTI4UG9UOERUZC9NazYvWHRYbVY2M2VGdFpmaTl2bSt6d1BGMCtFaUdERHk1elRyKzlwODZzMm4ycjF0bFN2ZjhicDg5UEM2ME5JbnlzM2NncE92MTdWNWxldDNoYldYNHZiNXN2ZjlDS0VFRUlJSVlRUVFnZ2g1OEZ2RFFsWmhIZDVtWFA2OVQxdGZ0WG1VNjNlbHVyMXp6aDlmbHA0ZlFpWmM5M2RDMHBPdjE3VjVsZXQzaGJXWDR1cjVzdEZGQ0VOYkc3Qk9lMTZWcDlQOXZxejE5ZkNlbk54K3Z6UThIcVJDSzdhYkJsdzJ2V3JQcC9zOVdldnI0WDE1dUtJK1hHeFE4Z1hiSGpCT2UxNlZwOVA5dnF6MTlmQ2VuTngrdnpROEhxUlNJN1lTQVZ5MnZXclBwL3M5V2V2cjRYMTVxTDgvUGliWG9RUVFnZ2hoQkJDQ0NIa09QZ3RIeUgvZzNkNXdUbnRlbGFmVC9iNnM5Zlh3bnB6Y2ZyODBQQjZrUXlVdjNzZ21OT3VYL1g1Wks4L2UzMHRyRGNYcGVmSFJRODVIamF6MUp4Mi9hck5KM3U5ckU4SDY0dmw5UGxadyt0SG5xZjRaaWdCcDEyL2F2UEpYaS9yMDhINmZFazVIeTVXeU5HdzRhWG10T3RYYlQ3WjYyVjlPbGhmTEtmUHp4cGVQL0pOeW8xT0lVNjdmdFhtazcxZTFxZUQ5Zm1TYmo3OFRTOUNDQ0dFRUVJSUlZUVFjaHo4bG80Y0MrL3lVblBhOWFzMm4rejFzajRkckMrVzArZG5EYThmZVNQZHQvdkZPTzM2Vlp0UDlucFpudzdXNTB1cStYRFJRc3JENXBhWTA2NVg5dmxrcTQvMWpHRTlPcXJWMjFLOS9taDQvZTRnMVdhbUlOV3ZYN1g2czlYTGVzYXdIaG5aNjV2aFVqOFhKNlEwYkhpSk9lMTZaWjlQdHZwWXp4aldvNk5hdlMzVjY0K0cxKzh1cW0rMG9xbCsvYXJWbjYxZTFqT0c5Y2pJWHQ4TTgvcjVtMTZFRUVJSUlVUURHMTczd2VlY0VFSklDZmlCUmNyQ3U3ekVuSGE5c3M4blczMnNad3pyMFZHdDNwYnE5VWZDYTNjMzFlOHdpS1Q2dGF0V2Y3WjZXYzhZMWlNamUzMHpUT3ZuUW9Xa2c4MHNOZFd1WC9aNnM5VVhYUS96NXlKYlBTM1o2NXRSdlg1dmVMM3VvUHJteXB2cTF5dDcvZG5xaTY2SCtYUEJlckJzMWMvRkNVa0ZHMTVxcWwyLzdQVm1xeSs2SHViUFJiWjZXckxYTjZONi9kN3dldDFGOVkyVE45V3ZWL2I2czlVWFhRL3o1NEwxWUJIWHo5LzBJb1FRUWdpYTZnMlE2dlY3dyt0MUgzek9aZkI2RVVKSUVId0RKbW5nWFY1cXFsMi83UFZtcXkrNkh1YlBSYlo2dnNsYzJ3clY2N2VBMTRUc1VQMXVBZ3NxWDVQc3RXZXJMN29lNXM4RjY4RWlxcCtMR09JT20xdGlxbDJ2YlBYZVhrLzAvRG5mdS9LM1pLdEhTdlg2dmVIMXVvUHFteVZ2cWwydjdQVkcxM2RiZnM3M3J2d3pzdGZYOHV0NXVEZ2h6ckRoSmFiYTljcFc3KzMxUk0rZjg3MHJmMHUyZXFSVXI5OENYaE95UXJWTmtRZlZya24yZXFQcnV5MC81M3RYL2huWjYydjV4ZC8wSW9RUVFnaWE2czJSNnZXaitUeThKbVFkdmw3K3B0cjFxRll2SVlSMDRSc2FjWU4zZVltcGRyMnkxWHQ3UGRIejUzenZ5djlOcGxwV3FWaXpodHZtUzJwUTdlNEJMUlhtbTduRzZOcHV5OC81M3BWL1J2YjYvb0NMSGdLSHphMHAxYTVQdG5xajZ6bTltY044dGZNeFA1YnE5YVBoOVNBcmxOb01PVkR0ZW1Tck43cWUwNXN0ekZjN1g3YjhMU25xNGVLRlFHSERhMHExNjVPdDN1aDZUbStZTUYvdGZNeXZwMkxOR202Ykw4bEppazJSSXhYbW02M0c2SHBPYjV3d1grMTgyZkszaE5mRDMvUWloQkJDOEVRM0UyN1BMK1cyM3lDNmJiNGtON2U5SGl2TU4xdDkyZW9oaEJTQ2J5QUVCdS95bWxMdCttU3JON3FlMCs4U1lyNmF1WmgvandvMWpxaGVQeUVJd3U4ZUFKTjlQaG5xaTZ6aDlMdUZtSzkydm16NVcwTHI0YUtKaUdGemEwcjI2NU90dnBPYkh4NzVPSi9jK2FMLzNtN1BMNlZhdlZwdW15L0pTYmJObVRYWjU1dXR2dE9iRmFmbHE2N1BmQWZtNTJLSGlHRERhMHIyNjVPdHZ0TWFITjc1T0ovYythTC8zbTdQdjBLRkdrZFVyNStRSGFJM2FXaXl6eWREZmFjM0FrN0xWMTJmK1E3THo5LzBJb1FRY2lOc2VKMmRmMGFGMzlRWlViMStRalNjOXZyUFBwOE05WjMycFZoMFBrS3VnbjlnWkJuZTVUVWwrL1hKVnQvcEM0clRtaW9uemVla3VVVG16SlMvSlZzOU02clZXNDJxMXpmNjIvZlRxWFo5czlVYlhZOUgvcFB2dUtsK045Ykp6ODBOK1Z6elYxMEVFRVBZM1BxTGF0Y2p1bDQyWTZoUGZUOTk1dGVSdmI0WjFlc25aSWZvelJtYTdQT0pydS8welgvMTVsQTFmVDYvdGZKQjhuT3hSUDZBRGErL3FIWTlvdXRsdzR2NjFQZlR6NUl6VS82V2JQWE1xRlp2TmFwYzMraE54ZWxVdTc3WjZvMnVoM2Q0VVQrYlhuUyswK1lEei84Zml5b0lJWVFRSmRVYlVxYzFnTFBuYjhsV3o0eHE5VmFqMnZYOXFUZDZZM0VxMWE1dnRucWo2L0hJL3pIV2o4NUh5RlZVV3dRUVEzaVgxMTlVdXg3UjlaNjJ5YWQrbkg3bDJqMzB2WEpFNXN1V2YwYjIrdERjTmwreXhtMmI5bXp6amE0bkl2OUp2NEZsbmFQNjNVYTgyeXRXUHpxZktqOFhMWVROcnZ4L0I5SDFuYmE1UnV1elhsdjlhdlY2NjBmbnk1YS9KVnM5TTZyVlc0MHExemQ2TTNFNjFhNXZ0bnFqNjJIendGZlBXcC8xbnFVZm5lODFmNVVQZjJJRUcxN3A1eDlkMzJrYjl0c2JNcXozTEgydkhKSDVzdVdma2IwK05MZk5sN3dUdmFueEp0dDhvK3ZoSFY3NWNsUnJuTERlcy9TajgvMlZuNy9wUlFnaEJFRzF6Vy8xaGhlYlhibklYaCthMitaTHhrVC94cE0zMmVZYlhVOUVmcy9md0tyNEcyTFZmaU9zV3Iya0dGeTBYQXp2OGtvLy8rajZUdHRVMzM0WFVyWGY0R0s5dnZxMzVadVJyWjRaMWVvbEJFRzFUWEsyZWsrLzI4TWlYN1U3Y0tyOVJsaWxlcXU5RnJ6MW8vUDlBUmRKRjhEbVZ2cjVuNzY1ck5ZTW9GNHVQV3Y5YXZWNjYwZm55NVovUnZiNjBOdzJYL0pPdG1hT05kbm1HMTNQNlp2bmFzMkg3SHJXK3RTai9sOXdzWEk0YkhpbG4vL3BHOVpxRzM3cTVkS3oxdWNkWDh3M0kxczlNNnJWUzhnTzBVMGVLZG5xUGExcDVKR3Yyc1kvdTU2MVB2V28vd2Y4VFM5Q0NDRUlxalY3c3V0NTY5K1diMGEyZW1aVXE1Y1FEZEcvWVNVbFc3M2U5WnlRei9vM3A3TC9waGQvYzR1VWhvdWtnK0ZkWHVubmYvcW1zbG9UZ0hvNXRLdzBzK3RSLzZ6OExkbnFRWFA2L01nLzNMYnB6VGJmRSs2WWlzeFg0ZTZhN0RYZS9KdGJ0K2tkcGM5RnlnR3d1WlZ1L3RIMVZOL01abTlPYVBXeTFZUFc0K3ZEbHRPYTE5SDVabVNyWjBhMWVnblpJVnN6YWthMmVrOXJabG5ucTdiWnA1NXYvTzE2SmZTNU9Db09HMTdwNWg5ZFQvVU5kL1lHUkxhR1VEWTkzdkdGaC9xMTg3ZGtxd2ZONmZPN2xXeE5HMnV5emJkNjB5ZzZYNFdtUWZZYVQ5ZkxWazgxdmZUNi9FMHZRZ2doejVPdjRYV2JIdlhQeXQrU3JSNDBwOC92ZHJMOUpwVTEyZVo3d205aVJlWkQ2MWY0emJEYjlMUmtxNGVBNFNLbE1MekxLOTM4byt1cHZvbk4zcFE0dVNsMDR0d3kxbVNwUi8yejhrdXBWaThoQ0xKdlVxUHI0eDFidm5wby9Zenp6VmdUVWl0YlBaWDBVdXR6a1ZTUUM1dGQyZVo3Mm0vY1ZOTS9yVUZ6V2ozWjVsTk5qL3BuNVcvSlZnK2EwK2QzSzlITkcyK3l6ZmUwNXBWM3Z1ek5BdXI1eHFQMW91TnYxMXZTNStLa0dHeDRoY09HVjZ6K2FRMlowK3JKTmgrVVJpVTk2cCtWWDBxMWVnblpJVnRUcWlXNlBqYXRmUFhRK2hubm02Mm0wK3JKTnA5cWVsTjkvcVlYSVlTY1FYVERLbHN6S0ZzOTFuclVQeXUvbEdyMUVxSWgyMjl1dFVUWHg5L2s4dFZENjJlY2I3YmY5T0p2Y0JFUlhDUVZnbmQ1aGNPN3ZHTDFUMnVDblBTYlhCbnV5TXIyL042dTU2MGZuUzliZmkzVjZ5YzVxYjVKamE2ZmQzRGRyWGRpUFJscVFHbEZ4OSt1TjlUbm9xWUFGelM3c3MzdnRNMVo5czF4ZExPRDg4a1ZqOWJMVm8rMUh2WFB5aStsV3IyRTdCRGRmSm9SWFIrYlk3NTZhUDFzOHoydG51cnhhTDFzOVpqb2NYR1VIRGE4M0dIRHE1WmVkRHhhNy9iNExEVlF6NDdUM21PejU5ZFN2WDZTZytnbWtKYm8rdG5FdWx2dnhIcWlhNmdlajliTFZnOWNqNy9wUlFnaEdLS2JOWXpIUXIxYSt0SDVzdVhYVXIxK2tvdm8zN2pTRWwwL2Y2UHJicjBUNjRuK1RhL29lT0lNRnpXSjRWMWU3cHkyS2N1K0tZNXVjdHorbTFvVmE4NFVqOWJMVnMvcCt0SDVzdVZIYzlwOHlEK2N0c21MbmcvdjRMcGJMem9lb1JjOWg4cnhHWjQvWkh4cVBTNUtFbkJCYzZzbGVyNm5iYWF5YlpZWnovaks4ZFN6NWJUMzMrejV0VlN2bitRZ3VybWtKYnArTnNmdTFqdXRudHZpcTlWcnJSZFNEeGN6d2JEaGRYeithaHZJNklZRDQvM2pLOWFjS1I2dGw2MmUwL1dqODJYTGorYTArZHhLZE5NSFRmUjgyTVM2V3k4NkhxRVhQWWRxOGRYcXRkWnpyNGUvNlVVSUlSaWlteDNTK0dyMVpvdEg2MldyNTNUOTZIelo4cU01YlQ2M0UvMmJWbWlpNThQZjZMcGJMem9lb1JmOW0xalI4ZDc1K0J0aVNyZ29DWVIzZVIyZnY5cW1NSHJUWGptKzJoMWExZXBsUFBXODlhUHpaY3Z2elczejllTDBUVk8yK2ZHT3JydjFLc1pIL2taVnRUdk9icWpYVXMrMUhpNHFBcmlnMlpWdGZ0VTJYNmZyblg1SEU2L1BYZkZvdld6MW5LNGZuUzliZmpTbnplZFdzaldUdEVUUGg4Mnd1L1dpNDdWNjBmWHpmMDNNbFE4ZGo5Yjc5VHhjakxqRGhwYzcxVFprcCt1ZDN0Q3BkZ2RWdFhvWlR6MXYvZWg4MmZKN2M5dDhyWWh1OGxpVGJYNXNhdDJ0VnpHZWQzamx5cWVOcjFhdnRkNHYvcVlYSWFRSzJUZTNOelRZTlBIVjZzMFdmN3VldDM1MHZtejV2Ymx0dnRaRS80YVZOZG5teDkvc3VsdXZZcnptTjZPcTFic1R6OS9rS2c0WEZZN3dMaTkzcW0yNlR0Znp2aVBKTTErRkJsS0ZHaXZsT3kyK21wNjNmblMrR2RucXNlYTIrYTV5MjZZcTIzeXIzK0dWL1k2eGJQT3RGbDhoWC9iZjJLcjBtMXpWWHArbWVsdzBPTUJtVi9uODJUZC8wWnZsMDVzYnA5VVhIVit0M216eHQrdDU2MGZueTViZm05dm1hMFcyNWhDYWJQT3Izdnl5MWo5ZHIxbzg2NjJkcjlyekZ4TFB4WVF4YkhpVno1OTlBeGk5QVQrOVlYSmFmYnN4bXZqVDg1MFdYMDNQV3o4NjM0eHM5Vmh6MjN4N1pHdjZXSk50dnRXYlhObWJadG5tV3kyK1FqN2U0ZVhyZjEwOGY5T0xFSElMdHplOHN0ZFhMZDlwOGRYMHZQV2o4ODNJVm84MXQ4MTNScmJmdExJbTIzeTk2OG4yRzFiVyt0bm1XeTIrUWo3TmIxNTU1TlBVNTVGUFc5L3hjTkZnQ08veUtwOC8rNll2ZXBOY3FhbVJzYUdVZWY0N01kbWJWS2ZuczliTFZrKzBmblMrSGxucThPSzIrZmE0YmJPVFpiNjh3eXUzM20zeDJmTmx2R1BzdER2TXZPZFRKcDZMQlFNT2JIWkZ6NmZhNWlpYjN1bWIvZXIrM3ZteTExY3QzMm54MWZTODlhUHo5Y2hTaHhlM3pYZVZMTTBnTDdMTWw4MHZXLzFzODYwV256MGY2OHZ0WHkzZmF6d1hEV0RZOENxWFAvdUdMbm9EbkwzaFVOM2ZLNGNtTnVNMVk3NDR2V3oxUk90SDU4dVczNXZiNXRzalMvUEhpK2o1c3NtVlcrKzIrT3o1ZUlkWHZtdVcvVFVEaitkdmVoRkNzcEN0dVZMZDN6dmZhZk9wbHM5YUwxczkwZnJSK2JMbDkrYTIrYzdZK1UyYnlrVFAxenMvT3QvcGVyZkZaOC9uTVorUHNYOGIreGpueStaZkhpNGFnUEF1cjNMNXMyL2lvamVwbWU5QW9uOThqdHY4bytOUGUzK3gxclBXelpJdlczNVBicHJyQ2pkdFlLTG42cFhmS2srMk83TlFPdFhpcytlamYzeU9iUDVSdWRUeFhEQnNjR0J6cXlWNmZ0bWJYZGsyZTlrMysvU1A5ZmZPZDlwOHF1V3oxc3RXajdkdWxuelo4bHR3NHB3aWlXNFVXUkE5SnphL2JQU3FOYStpNDdQbnErN3ZuWS8rQnZGY1VBaGh3NnQ4L3RNMmZOazM0UFNQOWZmSWNadC9kSHoxOTZEcWV0bnlaY3VQNXJUNVJCSGRIRUlUUFovc1AvenVyVit0U1JRZG56MGYvZU56MEI4Y3o5LzBJb1JrSVZ0emcvNzB6eFNmclJtVXJSNXJ2V3o1c3VWSGM5cDhvdm01bnRITkloVFI4N0hPWDAxZnEzZGJmUFo4OUYrTHllUlBKbkJSSVlCM2VaWFBmOW9tTC9zbVgrS2ZyY0ZoNFI5ZFEzVCswL3hSOGQ1eGFKMXM3NHZXZWxseVpjeVA1clQ1UkhQYUJpcDZQdFh1eHJMVXJuYW5GU28rM2Qwc3lmeWo4Ky80WjZoaDF6OVRMUjcrb25ndUtCWmdzNnRjdm15YnBzek5wb2g4Yk03UXY3SS9LcDdOcmxwNlVUa3k1NStSdlQ0eUpycXBKQ1c2M29wTk1EYS9NUEdwTnZmMFA5NC9PciszUHlRZkZ5UVQyUEFxbHkvYnhpbDdBOG83SHh0ZThUVkU1ei9OdjFxK2JQSFY5THoxcytlZmtiMCs4azUwQTBsS2RMM1ZHbDdaOUtyRmw5amtCL3BINTkveHoxQ0R4RDg2djdlL09oOS8wNHNROGtQMlpvSjMvdE9hVGRINVQvT3ZsaTliZkRVOWIvM3MrV2RrcjQrTStYbitvcHRKcTBUWGE1MGZyWjlOcjFxOHRiOTNQclIvZFA0ZC80OUFMNE4vZEg2dHZ6dHNldDBONy9LeTFhdTBpYzdRVUpCb25sanZhVTJ1NlB6ZS90WGlzc1JiYVZub2VldG56ejhqZTMxa3pLK24xbk1ZWGE5bC9wL05KRW8vbTE1VWZMdEpYNDJYNXZPcUQrMC9hMkxNL0tQelMvMDk4clB4dGFldGpmK3c2WFVIMFl1VzdCdVo2RTFmdHMxN05mL28vRkwvMi9PZjVsOHRMa3M4U3NOU3oxcy9PdCtNYlBVUVc3VFB0L2UzL3RJTnRuVitaTDVzZDJhaDlhTGl2ZUt5NWxtOVk2dkY2dzZ2M2Z4U2Y4LzhLKytyTTMrMG5yVS82dnFxNHRuME9wL29SV3IyVFUzMHhpL2JCcjZhZjNSK3FTWmFiOFUvK2hwRjU4L3VYeTFmdG5oclBXLzk2SHd6c3RWRGNoSjkxMVdMZHozb2ZObnV6RUxyZWNmdjN1R2x6V2RWWDdZN3JLTHpTLzA5OHQ5OGg1ZDEvcVY0TnIwSUlWNmMxa3k1VGE5YS91eisxZkpsaTdmVzg5YVB6amNqV3owa04rZzdpYlI0MTVQdFRxcnNldDd4MmZORit6TS9QbisxUnBLMjhaUXRQeGN4SXc3NGx4dWo2OCsrcVluZXRHWGJoRnY2VjJpb1ZHOUszYWEzNjUrbGpxcjVzc1ZiYVVYb1IrZWJrYTBla3Bzc0RhOGZ2T3RCNTh1c3A5WHlqdC9OWjUwbml6L2FiOVgvQkQxSnp1eDYxZklQWTdtQWVZNW9icldjdGpDUDNsUmwzOFJXODgrdUY1MC91MTYxL05ucXFKb3ZXenhLNDJUOTdQbXRPVzErMlpwSWFLTG5aNTAvYzlNS3BjZm0xMW4rcHpTL292Tm4xenM5Ly9NODV5MEl4TERobFQ1ZjlNWXErMGEybW45MnZZaWMxTHNyZi9WOHA4V2ZycDg5dnpXbnpDKzZJV1JOOVB6WThMb3JudjQ2ZitycGNtYlhXL0d2OWhya2Izb1JRcnBrYnpaNDYxV3YvelM5YXZtcjV6c3QvblQ5N1BtdE9XMStQL09KYmc1WkVUMC82L3hvL1d4NjFlTHByL09uM3JzUDh2bUkxRnZOR2ZsNUpNN1BwdGRaOEM2djJ2R1ovTE0zSEJCM2JIbm51NlZKRitWWExUOHExanZmU2ZHbjYyZlBiODFwOC92MW5EZW5iNkxuWjUwZnJaOU5MekwrWi9PN0duK0xmOXNVMFBwWDE1czFTV2FObEloOGtzWU9VbS9GRjYxbm1aOU5yME5nc3lzMi9uUi82c1htcTZKWHBka1VuVjhiRTVYdmhQaHFldG55U2NsZVh6V2lyNmYxdC9yYStXbnJrMjY0by9XdDlTckZyOXpwY3FNL1dyZTZYdTl2NXRmRUp6TGZ5dnVpVnMvN2VvWGtaOU9yUHFjdHNxTTNSZEVOcG16K0oraEpjbnJrTzcxSmwvMDFVeTEvOVh6WjRxdnBaY3NuSlh0OVpJM291N0JtVkx0THkxcS84bDFiTy9GWjdxeks0bC85aml5MEh1L3d5cFV2SkQrYlhvVGNpL2RtNy9UbVM3VjZxdWM3UFgvMWZObmlxK2xseXljbGUzMUVodlNPREcrczY2dW1yOVdyRms5LzZtbnpTUm92SHZsdWEzeVpjL1dpNUlCL3VmRzBSWGIwcGlqYkp0ZlNmOFVYcVpleEFSUGQ1TXA0VFpCKzN2bWtmcXYrbWY1dUkzT2RFRjlOTDFzK0tkbnJJekpTYldCZXNLNnZtcjVXcjFwOFpYKzBkcFNldDErMDNUdmZTajNWNXV5Vys4b0ZDWnRkNGZtaTlhbzN4NnJyM1o0dld6MW9QemE3YlB5OWNsVEtWMTNQV3o4Nm56V256V2RHOWlhVUZPLzVzSWwxZG54RmZ6YS85dnlxTlhxcTFWTTkzL004OXkwUTJQQ0t6eGV0bDMwVG1LMWhndGJMbUMrNnlaWHRtbVNyNXpTOTdQN1Y4bFhYODlhUHptZk5hZlBwd1laWDdueHNlTVhHVi9PdnJwY3QzMjN6OGNwUk9SOS8wNHVRZy9IZTdHVnJSbFMzZStmTFZzOXBldG45cStXcnJ1ZXRINTNQbXRQbU0rTm52cWMwdjd6blk1MFByYS9WdXkyK21uOTF2V3o1YnB2UGo0K2xQVHFmdHA2N0ZvZnNaS2NBQUNBQVNVUkJWQW04eXlzOFg3UmU5azBnY2hPT3VNTko0bnZESFZmUjlsTjFUdm83c2NqdjZWOHRYM1U5Yi8zb2ZOYWNOcDhacHpTOGZ1RGRYclo2dDhWYitsZS9Nd3V0VitWL1V6emhqaXZQTzZ3eXpGZnEyL1c1WW9IQVpsZDR2dWlOVUxhTjVlbDMxSnhXVDdUOVZKMklabGQwUXlyNnZVTHJ6M2hmUFc5OUtkbnFJYkZFTitHcU44MnFOWlcwOGRueklUYjhVdi9xZXJjMHY3enpSZHU5ODVuVWMveUNoUTJ2OEh6Um01SnNtOFpzRFIvdmZMempLOTd1bmE5YXZkYiswZm0xL296MzFmUFdsNUt0SGhJREcxNnhldFhpcytmTDFpVElybmU3UFVNTmFlNm9jcktMOWZpYlhvVGtKVnZEay9iYWR1OTgxZXExOW8vT3IvVm52SytldDc2VWJQV1FXSDVlRDFITkwrLzg2SHhhdldyeDJmUE4vS2xIKzV0UFpYdnIrd1RYSTZsM2hjL1JpeGJlNVJXZUwzcFRrbTNUS1BIM3VDTUtxWFdpUFdOTlNIdVdPaXIvWFZqbXp1alBlRjg5YjMwcDJlb2hzZkJ1cjFpOWF2R1o4NkgvMTBadlBkN3A1V1BQV2hmS25xRUcyTi9Ga1FzV05ydkM4MFZ2UktJM2l0WDFhRC9ibnFVT1JBTXJNaDhxNTBuKzFmSlYxL1BXMTVLOVB2SW4wVTJzRmphMTdvclA0Sis1c2JYaXcrYVhqejFyWGF0Mjczd2g4emx1QWNLR1YzaSs2RTFMOUNhd3VoN3RPWExTdm02dm51ODAvMnI1cXV0NTYydkpYaC81QnphOGN1bmRGaC90WDEwdlc3N1Q3Tm5xUWRzejFBQi9qZk0zdlFnNWgram13Mm4yYlBYUWZsYSswL3lyNWF1dTU2MnZKWHQ5NUU5K25xOHN6Uy92ZXRENXRIcTN4VWY3VjlmTGx1ODBlN1o2MFBZZm44cjJ2MkRUS3hmZWk4SnNpL3JzbTZ6TW0rYm9Cc1JwZDFobHEyZGt6MXFYbHgydDVaM3ZKUDlxK2FycmVldHJ5VjRmK1pOZlQ2N256THNlZEQ2dDNtM3gwZjZSZW0xekpUcGZWbnZiOVBDeVo2dG5aTS9jbVBKc2ZIM1k5TW9CbTExbiszdnIwWTYxWjZzbk9tOFdPMG9qS3ArRmYvWW1VM1JUS3pyK2RIMHQyZXM3amRsbUlmcjVtRzN3MFBvdDBueldldG5qcGZQUDdoK3AxelpYb3ZObHRXZkxtL0U2dmYzZDNtVC9EWnRlOGJEaGRiWS9HMTU2ZTJSTjJlcDVzMmVycDVvOWU3NXMrYXZseXhaL3VyNlc3UFdkUXJhN3VGcXM2OHQyRnhkYTc3YTdzcXo5dmZWVzd2VHl6SmZObnVXT3FtejFmTnN6MzRFVlltZlRpNUE4UkcvK3M5bFp6OWllclo1cTl1ejVzdVd2bGk5YmZKUzJadzROMmVzN2pkNW1MUXZXOWFIMXYxKy9DRTF0ZmQ3eHAvdDc2MlhMbDgzT2V1YjJsSTJuU1B0Umk0eUMvM0tqZDczb2ZOazNUZEgrRXIzb0JvQ0ZYYVBwblc5a2w1NjNpdHZWemZqYXlHU1B5bVhobjcwUkZkMTRpbzZQMHZiTW9TRjdmYWVSdGVIMWczVjlGdnBJVGEyV2QvenAvdDU2a256V3VhTHMwdk5XK1hiakxPclVhSHJuUzJVL1lvSEJacGQ3dnV3YnBld2JTZHBsOXFoNjJPdzYyKzZWSTFMdk5QL1Q0cTMxc3VXVGtyMis3R1J2YXJWVWJISWg5YXZGbis1ZnNRbVdwc0VBdHJQNUpiTm5mUjVEN2VVWEZHeDR1ZWRqdzh0VzcwUjc5VHUrc3V0bHkwZDdMcjNUL0UrTHQ5YkxsazlLOXZxeXdvWlhMZjFxOGFmN1YydDRuV2F2bm85M2VDVzA4emU5Q01FUnZUaVAzdHhITjF0dTA4dVdqL1pjZWhwL2o4YVY1djB5UTZPcWNyTXIrck5xaFFvMVp1YjcrbFZvZ1AzVWExV3I5ZlhRMWw4dC9uUi9yZDA3MzJuMjZ2a3M2djhNL0dkMjczd2VkakdsRnhXOHk4czluL2RHSTlvZnZVbTAzR1JIYlBEUjlhRG52NnNuUFkvV082bjVGZDE0aXJaSDYybjgyZmp5MGJEVXk1SnJsd28xWnFkQ3crc0hqMW90YzFTN1cwc2JmN28vNy9hS3kyMlZUM29lclplaGJ2VHJvTXpyc3VTQ2dzMHU5M3dlbXgvTGZONTYwZm1pTi9yUjliRFpaYU8zWXMvMjJzdG1qOWJMbHI5YXZ1cDYzdnBvcXRVYlRmYUdsM2Q5Nkh6Vm1sVGErTlA5MmVTYTI5bjhxcFZuMTU3dHRRZlJLN2VBWU1QTFBWLzJUVWkyVFdoMHZteU5qb3AzZkVVL0o5SDVxK1dyWm8vV3k1YS9XcjdxZXQ3NmFLclZHd1ViWHJiNXFqV3N0UEduKzdQaE5iWlh6eGV0RjUxZlc4TVJEVkQrcGhjaGNWUnZOcHltZDN2K2F2bXEyUzMxTEJwRm5zMm5uVmp2ZkpYMXZQWFJWS3MzQTkvWExHTUR6THMrZEQ2dFhyWDRyUDZyYzUvNWErM2UrYnp0MWZORjYwWG4vemszZXYyTzdHaTlIYnRhajAydnM0aGVlR2Y3aHQ5YkQ3bEp6ZEJ3R01WNDZPM09LZXA4eis0MUQzVCtGVHZ5ZWRQR1ZyQmI2ckh4NVJkYlVjOWJIMG1sV2tsdWZqM1kxNU5XcjFwOEpuKzB0dGJ1blU5amI1c25LL1pNK2FSNk8vbS96eitOM2RwL1pHOGJRV2gveS93dHJvMHZOcjNPSUhxeHpXWlhMbnYxZkd4MnhlWWYyVDBib1RmWXMrZkw3aCtkcjVxZXR6NktLbldTM0xEaHBZdVA5cDl0MEtYK1dydDNQcVM5YmNhMHZOa3o1WlBxN2VTUFBEK3lqeG83Q0grTC9DMVNPMFNQVGEvNlJDK3lzMjFTc20weXF6ZWdaakVlZXRiWElKdi9hZm05OWFyWnMrZkw3aCtkcjVxZXR6NkNDaldTM0xEaHBZdVA5czkybDVWM1ByUjk5ODZuTFBtczcvUmFiZWhaKzMvYmVZZVhVbzlOTDBMc3FON3dpdGE3emYrMC9ONTYxZXhvTFdTKzdQN1IrYXJwZWV0THlWYlBhY3l1NzJpejRNRnNBNFhPZ2REWDZsV0w5L0tmM1VIaXBXZVZMNHU5ZXI3Yi9IL09WYnZESzFYanE5UkNnLzl5bzdsKzlZMkt0OTdJZm1QRFMzbzlvdnlybk8vWlBWOGJpT2ZCVzYrU0hhM0Z4cGRmUGt1OWFtc0hMZG5xdVkzb3B0YzMxcldnOWJWNjFlSXQvVmQ4dmZXUStTTHRiemEwbmlhZlZLK0tmNVh6SXp2eWRZVjRIVzYvYmtzc05OanNNdGZQdGprNXJSbDJZd01NcVlmeXIzSytaNi9XdVBUV296MWV6OXMvT3ArVlhyVTFoSlpzOWR4R2xxWVhHMTY1NDlIKzFmVXEyajBiV1R2NXFqU3pwUDVWenZmc2JvMHBTNzMwQ3cwMnZNejFzMjFLc20vcW9odEczdm1pR3ljVy90bWFUYmY1ZSt2ZFpvL1c4L2FQem1laFYyMGRvU1ZiUGJlUm9lbkZobGZ1K09vTktyUmVOZnRwZXRuOXM5YzM4NS9GbExyRDY4Zk8zL1FpNUYrOE42TXpvcHNGcC9sbnIrOTBmMjg5TDIyRUhhV0J6TGZyNitFZm5RK3RkM3FUS3pvL0dUTjdmanlhWXFNYUVQbS85VFBvVll0SCsyZlI2L211Mm5mclFlVmZ0YVByc2FydkZQL3M5YzM4Zjg1RitiL1pwZjUvMmRuMHdsSnQ0WnB0WXhKNUI0UEZwdFp6ays3UmdKRFdpL0xYbnJmU2xlYmI4Yy8wUEtEOHZmVVFzUjUybEFZeTM2NnZoNzgyRnZsNWl0Q3lYRDlFTjUyaTh4TnlLcjhlM2QrWE5CN3RINm1IME5Kb2FQUHYySGZyNlRYUE5IT1g2R245MytJdC9WSDUyaWJPam4vYk9MTDJ0MnhrcVJwZmJIcGhZTE5MRisvZDdLcG16OWdBOC9DL3NkbVZyVUdGOVBmV2U3Tm4rOXVlVVMyZnQzOVVYSFlkTDkwcStRazVFVGE4NVBadlZoc01xSHEwK1JIMjNYcmFab3UyUHFtZTF2OHQvaHUwUHlvZjR2eW9FV1RoLy9ZMzRlMy9hbWZUU3c4YlhycjRiSnZBYlBib1RYMkd4b20yWnU5ckhoMWZ6Yis2SHRwZVBaKzMvMjRNSWhhcFlhRmxxVmtwUHlHbndZYVhyMTJyRjEyL3RwNlZPNWNzOWJUKzFlNzBXbTBnanZ4NWgxZGpaOU9MRUJ6Um0zUHIvR3dlNVk2djVqK3pTZjAxZWhuc1Via2k5THo5czhWWDA4dVd6eHZwL0VhTDc0ck01bTg5MzlrR3JMcmVUdnpiQm44M3AwVyttYiszbmxVOTBqdDVkdk92MnRIMTdQcXY2bFc3ODhvckg2TGVVU1BJd2o5NzR5djNRcVhJdjl4b1hTTlNmMGRMa3ovYnhzelNYckhoSlprUG9pblI4MS8xOVlxUGJsNGhuM3ZMNXczbGI2RzFvNWZCSHBVclFzL2JIeG1mdlVuRnBoZVcyNXRlTTd6bmk4NkgxTk5xN2NScmNrcGowZjdlZXNoNmRyUXM2MFBYZy9CSGFVbm5acFZ2OVh5bGVPM3padjBhMHI0V2ZwTnlvVktrMmZWRGhhYVg5K0krMjJiTTJ4NnRaNTBmVlkrMkNZV09qNzR1aU91YXJhRlY3YlYrbXoxYXo5c2ZGWis5U2NXbUZ4WTJ2Y2F3NllYUjJZMzNpcnU5NFpYTkhxMFgwV1JEMXFqSmw3RjVwWW5YWHRkc3I3VlgvM1FMbFdJTnIrZkozL1R5anMrMkNXUERhMjZYTkRJc0dpSFo0cU9iVjlIeHAvdlRua3ZQMng4Um43MUp4YVlYRmphOXhyRHBGZGZ3Mm8xbHc2dTJQVnJQMno4NlgzVDlGdkduMytIMWx6OS8wNHVRZmF3M2s5bjlUNHZQVm85My9NeFd5WDlIN3laN3RKNjNmM1ErdEo1MWt5bDdFNHYxamZGdVFzM21pNjZuemFmVlIraDlhM2pINzlRdnpZZjI5OVk3eGY2ckdhLzZvL1YyL2FYMW9PSzErYUxydDRqL0NQVGUvTFh4eUh4TC9teDY2Y2krOE15Mk1mRFdzN1FqTnUwamU0Uy9wSDVKL0tydmFyd2t6MHE4bHg0aWZ1VzZvVjYzMlJwWlV2OGR2WnZzVWwvTFJwRjNFOG83SDFvdis5ckRtdXoxRVJMRnIwZjI5eEh0NzYxWDJmNW1rL3FqOVhyK3ZlYllTUHZiM3lKZTRvL08zNnVuYmVJZzR0dkdqNGVlSkY3VHVGTGxZOU5yait3THptd2JncE9hWFcvMjIvM1JUU092UEJXYVhaS21qVVVUS2Z0cmIrYnZyVmZOYnVXWFJUZExQclJlOWpXSU5kbnJJeVNDNkFhVzFKOE5yN0c5MXhEUitLUDFldjV0YzJSV3o2dzVnNGovWnJVWmhNcmZxMmYxdkNUK3JiRmtyU2VKZi9zYnNMeWo3SGMrTnIza1pGOXNadHNNc09GVnp4L2RhRUUzWHRETnBkdjB2T09qL2IzMXF0bFhmWFo4TGZMditFZm5RK3RsWDRkWWs3MCtRcnlKYm1CSi9kbndHdHV0L2EzenI5eHBOZkwzaUIvNW8vT3ZOcHVrZXQveEt3MDZhNzFSZk5nZFhqK3c2VVhJdjNnMzhHYiszczJEN00wYTZ1SGkzMnpvK0dqL2tUMjYwWlRkYnUxL2VwTXJXNVBNV3E5YS90UFJYdC9SNW1RSGFUM1MvRE45YnoxMC9FcjlieHZ3elA3ZWVsWHNiODJXRmIyby9Ddk5vc3J4cUR2RnJQVi96bVhSZTR2WE5yNUcrWmZpVXkwOEN2ekxqZGIxUlMrMHMyOXNMTzA3c1phYmRzUW1YcHV2RjcvYk1GblZXNDNkMVVOZmEzU3p5RnBQRW91SWovUWYyU1BmYnlyWWQzMVgvUzAwTStSQ3hGZlRxNWFmakVFM3ZhTHpaOU9UeGxmMlgvRkY2bFcydjlta2VsNzVWMzJyeEd1dm8zWXNQYS9SVzRuTnJpZngvejFPc2ZCZ3N5dDhnWDF6cyt2TkhxMW4wUUJENUVNMW1hTDhJcHBkbXNhalJ5UFRxcUYycXY5dGRxbGZGdDJvUEtqNGFuclY4cE14YkhyWjZtVnFTbG42ZS90VnMwZnJJZndsVGJRSzhiYzB2N0xVSVkxWDVROWZlTERoRmI2NFpzTXJsNTdGSmo2eVViS2poMjdFUkRlL1BKcHJtZlNrOGRYOGI3T3YrdXo2ZXpTazJQU3kxYXVXbjR4aDA4dFdMMHRUeXRMZisyNndhdlpvUFpPbVF1SDRhSDNyZk5LYzJmVlcvUCtLNTI5NmtadXhidEJGTnhPeU4wZWk5YXZQWjJiejFwUEc3Mm9qL0tYMTBFNy96UEhXZXQ3NmFLclYyK0xkaE5KZUwyMjlzL3hTZldzOTYvaUsvcCtKSGExWHpZN1MrOVdNdmZ5ajRyWDE3NDZ0OWEzei9ad2JqU1g1b3ZWVy9QK0taOU1ybHVpRm1QZkdRS3BuYWJmZUJLTWJIb2g0VGROQm9yY1RpOVRmdmJiZStYbzJaUDI3MTE2anQrUDdaclArbTVQVzQybTN6bzNTMlBFOXdUOWJ2TFdldHo2YWF2VVNVb1cyZ1dHdGQ1cGRvL2RtOC9hM2lsOXBsa25pcGVPUk5rSi9KZi8zK2FleGUrYWJOWmJRZW0vNkVEMDJ2V0tJWG9CNWJ3aWtldDcyN1A3WjRuZWJROWI2eUdhUlZUNU4wMGZUd1BMUWs4YXYrRnYvclhucnJkcXQ4M3Jybk9hZkxkNWF6MXNmVGJWNkNha0FHMTQ2KzQ3L055c05KV3QvcS9pMm1iS3ExNHVYam52NVVQb3IrU1huTGZQTkdrdG92VGQ5cmQ3elBHeDZSUkM5K1BMZURFajF2TzNaL1MzaXZSc3YxbzBZUkRQS001OTNmclMrVnM4N2Z1YnZyYmRpdDg2SjFyTCtYTW5tbnkzZVdzOWJIMDIxZWduSkRodGVPdnRwL3VqNDNwMUR1L0c3ZHo1WjZlODJvNnp6ZitmYnVRTkxvMmQyaDljUGJIcVJtL0RlT0VWdjlxT2JMZEg1c3RjajlZM1cxK3BaeHUvNFMrdXh0SHMydVRMbU84MC9XM3kwZnZiODJiRytQcjF2MVhlUjFpdk5QOVAzMXB0dDBLVDUwZmtzL044YUFKWjZwOW1yK3E4MGl4RHhLTDJkWnBkblBta3p5cXVlbjNPN2QyRHQ2RW4wdC9SQ0Z4cVgvc3VOU00xc0MzM3ZqYUxFN3IycFJqZFl0UEdTK1NBYUxwcDgxdU1xOWF4ZVEyOTlyWjVWL0k2L3RCNlVYVm83d283V1F1WTd6VDliZkxSKzl2eTNnMjU2UmVlUDF0UG10ODZIOXBmb3JmaHE4Mm5zM3JtcitMK2RYejJuaVYvVms0NGw1eEQ1RVBYMnp1L01OYklleVdzVXFoK3kwTGkwMllYVXpyYkF6OXpzZXJONysyZUxqMjRDV2VsbW0rZE9VMGZ5M0h2cmEvVTg0cVA5ViszUzh5aTd0NDdVN3hUL2JQSFIrdG56M3c2YlhsZzlOcjFzL2F6c2JIak40eVVOQ25TOGQ0UEZvM21FYWpaNU5RdTlkYUY2N2d1Tnl4dGVDUDFzaS90c0RhMlpuUTB2dVlaM1BxL21WNVo2c3RXUDF0ZnFTZU9qL1ZmczBtWWowbzdTUU9ZN3pUOWJmTFIrOXZ5M3c2WVhWbzlOTDEzT2lLWVhHMTYrZXVoNnF1VkgxSTlzNkhuVW82a1hvcy9mOUNJbjQ3MFJ5cmI1ajI1V1pCdTNSTmVqcVQ5YmM5TkNyNUsvdDU2M1BWcnZOSDkwdkxWZXRueGFzdGZyM1lUU1hnOXR2YlA4VW4xcnZWbThOcjgybjdmL2l0NW5Za2ZtMjdIUDZrUGJzL2ovYXNhOWVMVGVhcngwM012bmxkOXIvSE51Tkg0YVczUTltbm9oK214Ni9ZbjFRc2g3WVJ6dEgyblhic3FsL3VoTnRuVTltbnpvWEJhMVZwN1A2bXNKOVp4YTYydjBLdm5QYkpuZkwxZnNWbG8zK3FQanJmV3k1ZE5TclY1Q3N0QTJFS0x6V2R1dDgwWDZ2OWxXR2taSXZlL3p6NWR0cDdtMWtnK1ZQL3Y0YWM0L1gzWmtJNmxDdmI5aDArc2ZyTi9BdlJmRTBmN1o3TjcrMW5yb2VxeWFMRm5yc3FySFk3N0kxNTYxZm9SZXRQL3UrU3AydE02dC91aDRhNzFzK2JSVXE1ZVFETERoaGMzbjdiOXp4NXUxWGhzcnZiTkltZytWUC92NEdaei9nTWZaNi8wTm0xNzJiK0RlaStGby8yeDJiMzlydlpsbXhrYUw5VmpxRzExdjlMZ2x1NzVVTDlwL0ZwUHRQVkpxUjJuYzdJK090OWJMbGs5THRYb0ppWVlOTDJ5K2lJWVhNdDVDNy9rNnQzcG5rQ2FmSm4rVjhmTjEzdUlPcng4eTF2dFhmV3g2a1pQUWJsVFFtM2R0L3VqbVJmWnhpMlUraTlvanI1ZEYvWkY2MWZ4dnMwZnJhZjJqODFYVHk1YXZHdDdYNS9WYmNRSGFlbWY1cGZwYVBlLzRDdjV2RFlKZFBVUStTL3RiZmVoODN2NnI4Vy9OSmFUZXJqNHEzNjNqbjNNbWQxQWxyZmV2K3RqMHN1VzBoVjMweGtteUtaYjZhemU1MWswQmlmNU9iTFZ4N3h3NlYrOHhZcng2emlJdlNnZjVHdGZxYWZ5MXRlelVnNHF0WUkvVzAvcEg1NnVtbHkwZklZUzhFWDFIV0tZN3Z0NXN1M29yemEwZC9kVjhITnVPbitiODgyVzNiTFN0akx2MXNlbGx3MmtMdXVnTkUzSnp1K0tmTFI3VnhMREtIejIyenZOWjhOa2RJN1ZXY2xuV24wRlBHdTkxM2lxdWlqMWFUK3NmbmErYVhyWjhoQkRTY252RGErY090MVc5dGxtQzBsL054N0h0K0JtYy93U1B1L1d4NllYbnRNVmM5R1lKdGFsZDljOFdiOUhJc0t6SGUyeWQ0ek00aHhxM1JGL1Q2UHExZXRMNG1RYkNYNk4zZ2oxYVQrc2ZuYSthWHJaOGhCRHlEUnRldG5xOU80T1ErcU44SFB1TW42L3owWTJ2YjE3clk5T0xWRWE3OFVESFoyOW1aS3NuMDdoblcvSFpIU08xTEdyenJGK3I1eDAvOC9mV3kyYVAxc3Z1ajQ2MzF2UFcxNUs5UGkyOWI3VjNRVjh2YVgzUy9EUDltVjYyZUc5L2FmM1JlaGIyVHpOdUdka1JldDcrM25xcityUG1DaXAvMURoTGM4cDYvSE11NVIxZVArZGNGd2EvL3B0dUlXSlJEMUl6ZXFHZTJiNnlTUi9aMFBIb1RUaDYzRHNYVVV1bWNlL3g5OWpqdWZISWczck5XTld2MWZPT24vblBiTjd2ajBqN3FnOHkzMG4rNkhoclBXOTlMZG5yMDRKdWVxR3hyaytyWHkwZTdSK3BwOVd5c0k5aXJQV2srbHAvYjcyZS91cDFRK2YzSFBjZWN4ejB1bkpaR0Z6UzdFSnFSeS9RcTltak43OFZHMkFaNnNneVhtbDhXZVMzMExSNnJmUnNsdmtxeE0vOGQ4OWI1VVBaMFg3Um4zbmUvdWg0YXoxdmZTM1o2OVBDcHRkZDhhYzB2VEkydkhiT28vUnVhM2loRzRTWng3OFdmRGoyYTM3OWVoNkhoY0ZsRFMrRWZ2VGl2Sm85ZXROYnNlRVZYVU9tc2JUeGRlTzRKWHMrNy9pWi95ekc0ajNUcSttMTZzdW1sMjI4dFo2M3ZwYnM5V2xoMCt1dStCT2FYbGtiWGoyYnRkN3REYTlzK2EwYlhwbnF1Mkg4NnNQZjlDS1YwRzVFMFBIWm1nVWNyNC9aN0pLOWZ0bm9zdlhYMmoyYlhCbnpuZWFQanJmV3k1YnZkS3l2cDdhcEk2MVBtbSttUDlQTEZ1L3RINkgzU1d4L3E5OWFUNnF2OWQvVis5V01kL1ZSK1N1TUpjOS9obnBQSFArYysyUE1waGNXNzRXdDk4SmJpMllqOUdiVGJOSzE4ZGFiOEpQR1dXdjV2SnpqdVA5YTlzcURpRi81ZTdkOHY1bjU3K2haNWx1eFIrVzYwUjhkYjYyWExSOGhoT3p3MXJUUStNOGFQbEo5YlQ2Sm5yU0JnOHlmcFhtaUdYK2U4WHl6TnIrR2phUEtZemE5TUhndmFMMFgzRnJRR3lUTHpmSk9mTFIrNW5IdmNlUTRlMzFaeGxFNUVmR3I1N1h4dStlenhhM2F2ZlBjNm8rT3Q5YkxsbzhRUXFUYzN2QkMzTEdHeXIvVHJNazJYbWw0WmF1M2ZYelVtRTB2UGQ2TFdlL0Z0aGIwNXNocWs3d2JINjJmZWZ4WjhNbFFVNmI2T1A2Ym5maVJKanAreDEralo1RlBZdmZLY2JNL090NWFMMXMrUWdpUndJYVhyLzVxQSt4VGVOeWIzOXRkWUZucVBicnh4YVlYeVl4Mlk0R09qOWF2Tm02SnJPY3pPT2VabitQM2NVdTBualIrNXUrdFY4MGVyZWZ0ajQ2dnBsY3RmelhhT3pha29LLzNyQjVwUG11OVdidzJ2emFmMXQ5YnI0SzliVkJvL05zWWl6dXFwUG1rWTJ2OXJHUHZabGhFL3JmeEc1L0dYbjdNcHRmWmVHODBrUG5lYkJKL2RIeTBQbklja1N1cUhta3RIdms1ZmgrM1JPdEo0MmYrTTV2VS95Ujd0SjYzUHpxK21sNjEvSVNRbWtqdllOTHFvZjJqNzhpeTFzODBqbWgrUmVSL2F3eTkxZUtaMzJYTXB0ZVplRzh3clBORmIyYXo2V3ZHdmNjZTQ2aDZvdWNmZWMycmpWdWk5YVR4TTMvMCtWUHMwWHJlL3VqNGFuclY4aE5DNnNHR2wyNXNyWjlwL04zNGVacnpWbVB2L0wzRzA5UHg4Y3J2Tm1iVDZ6eThOeGZXK2FJM3NkbjBOZVBQZ285WERWNzF2T1dJdnVhWlhoTVp4eTNSZXRMNG1mOHNSdXAvZ2oxYXo5c2ZIVjlOcjFwK1FrZ3QyUERTamEzMU00Mjk3M1NLeXY5cHp2Y2VlK2QzRzdQcFJTcUQzbWhvTjhOby9lek5oTXoxZkFibmtQcXpjWFQrS3VPV2FEMXBmTFIvTlh1MFhuWi9kTHkxbnJlK045cjV2SDJyYm9uMTlaZk9SMXJQVE45YnI0Mlgrcy95ZWZ0NzYwWFlQODI0WldTWDZsbjR6OFl0MHZoZC9iYVpnY3FIR211YVQxNzVKUG5SZDFwOVhzNmg5RWZqTno2TjNYeHMrc0g0NjcvcEZqN1pGbzRXQzJlSlpzVEdaeFFqOFYvMVhZM2YyUlJMNW9JY0kySXoxNE9xelhxdTBqcWk4bGNadHlEMVZ2NStVZTlOSHY0N2VwbnMwWHJaL2RIeDFucmUrdDVvNStQZDlMTEdlajVvZmEyZU5MNmF2N2VlcGYzTjVxblgycVM1VitJMStYZnlTV3FKSFBjZVM4YmUrVWI1TGZXdHJ2dEticTk4ZjQxTkZpWnNkc0hqa1kyc0ZSOUx1OFZtRUIwZnZWbjNhSHBrMWNtcWg5Q016bDloM0lMU1d6MnZqZmM2YnhYblpZL1d5KzZQanJmVzg5YjNoazJ2UDJIVDZ5ei9VNXBlMHZOb1BZK0dseVkvc2dIbWtXK25FZUxWVExGdUhsbnFXelNmUEpxRGFoMzR3b1FOTDNpODkrYkIyNDdlOUdyak0rZDdhM3FnTkRQVWsxMnZwK25aR0lyTzd6RnVRZWlOY3FEalBmdzFlaG5zMFhyWi9kSHgxbnJlK3Q2dzZmVW5iSHFkNVg5QzAyc1U0NkhuMWZEYXpYOWJ3NnR5UGt0OWRETnRwL0hsa2U5MXpOLzBJcDVFYnhUUW0zSHJmTkVOdllqbUJFb1AzUnl5MHBPT2R6V2lYeXZScjIydHZqUWU3ZSt0NTIyUDF2UDJ6eFp2clpjdG56Zlo1eWR0ZWxnM0FhWDZXajEwdkxlL3RQNW9QUXY3cHhsNzY3WCtvL2hXUXhxL2sxODdidmswdHNneDhucWc4NkhuczN1OVd0QjZQejYvT21QdmZLOWpOcjNPSW5waE5jci9aa1A2ejN3Um0yWkp2VllOaWMrQ1QzUTlpTndJUGNTMVFsOTc1THk4OG5tTld5ejFWLzYrSTkvUHBOZkdRcy9USHEzbjdaOHQzbG92V3o1Q1NBM2VtZ0FTdTdkZXRuajArUHY4ODJYTE1QNDh1dm50TkwrUWVpTjl6ZlY1cTFVYS96Ump0TjVzRE1uSHB0Y1pSQzhZdFp0WHJiODBQdFBtWE5PVVFPUkgxNk9KUitwOUJ1ZWtZOVQxUWRZVWtjOWozR0tsdi91M0ZIM2VXOC9MSHEzbjdaOHQzbG92V3o1Q1NIN1k4TkxGVzk3eHRkTjhzQjRqR2w2b2ZObWFWZTA1U2Z5YkZsSnZOb2JsWTlPclB0R0xSZTJtVmVzdmpjKzBLWDlyU3V4cVpLZ0hNUitrSHZMNm9xNDVXaTliUHNTNHhVSi9sQk1kai9iMzF2T3dSK3Q1KzJlTHQ5YkxsbzhRa2hzMnZIVHhYZzJ3bGVhRDEzaDNQcnZOSmJUZW03Nm1lWWFLZnlhUHRYcXpNU3dmbTE0a0U5cU5oblp6TFNYNzV0NjdIbTM4NStYeDI3bEs4ZFo2VnZtUXNTdmpsdXo1cFBGb2YyODl0UDAwUFhTODlXY1ZHbXQ5S2RucVFmUDJMYmdHN2ZXUzFpUE5OOU9mNlhuSG8vUE45SzMxdFBQZnNYK2E4U2huQnIxczhSei8rL2laakNYWFY2c252VlBwKytnWi84Ym5rZVdYNk0zR2tIelFoUUgvNVVaNC9JcS9STk5pSXpPS2tmaHJ0WGMyclN2blZ1c2RqVmRzMnZuczV0K3BSeHEvVzd2MjJ1ekVhNStibFhtajlaRDVMUEt2amxzODgybmVDMWJqMGY3ZWVrajdhWHJvK0d4cmwyaDlLZG5xUVlOdWVtbXhya2VyN3gxdm5ROWREektmUlM2TnByV2VWSDhXTDYyTjQvNjQ5M2cwdHRUVHhPOWVoNTM0V2UycjhidDZxTmZBWDVxUWhRR2JYZkI0WkNOcnhVZGp0OWpzZVcrR3BiNFdUUU9yNW9LMitiV3JwMjErUmNacnI5L09jNDdRUStXenlyOHlidkhLdDNwZUc0OCs3NjJIc3ArbWg0N1B0b2FKMXBlU3JSNDBiSHJsanIrMTZXV1ZCeDJIMHRQbVpjUExicXhwOWxqb1JUYWZOSE5FTkJsM21sMG16VTcxd29BTkwzaTg5K0llYlVkdllyWHhrZnB2VFlQVm1LajhvM3FrZXRyOEVmR1J6VFlQdlFyNVd6enlqV3BBeDZQOXZmVVE5dFAwMFBIWjFqSFIrbEt5MVlPR1RhL2M4VGMydlN4ejdNUmE2MG4xMmZEeUcydWJOMmc5VGZ4T3Mwd1RqOG8zZXJ3VEx4Mi8ydmliWGtSRDlNYkJlbU5RYmZOdW5WK3FwOG52M1h6YTlVZkhXK3RsemQ5UzdXOUZHby8yOTlhVDJyUG55KzZQanJmV3k1YnZOS3l2bjdTcG9xMW5saytxMytwWngydjlXOXI0bWI2MTNrcStqNkY5cHo1clBhbitMRjU2ZlRqKzkvSFRqRFhYWDZzbmpYL3oveG4vYW80emYyMjhKdDhibndjWEx4Mi81bVBUeXhicmhVbmtSdWJOaHZTZitXcjFwUHE3NC9ab25hLzNlRGQrUlEvcC94WmpPWGVFUHpyZVdpOXIvcG5OK205SW0xOGFqL2JYNkZuazAvaDc1OHZ1ajQ2MzFzdVdqeEJ5QjI5TkJvMy9yR0VpMVpmR1MvVnVHcTgwbXp6MXBQRm8vMUc4aGYvekVyUHEvelJqYmZ6U21FMHZHNndYZE5ZYkJxa2Q3UytOUjI4Z0xEZlQxdmxHVFFodC9Hd2pqZlQvRE03Tnh0TDVvUHpSOGRaNkdmTkx6MXY5cmU3bWp6NmZMVzdYM3p0ZmRuOTB2TFZldG55RWtQTmh3K3VlOFVwenhsTlBHbS9oMzR1WE5KT2svdCtzektjWHE0bGZIclBwaGNkNk1XZTlXWkRhMGY3U2VQVG13YUpKNE4yVVdQSFpqWC96eStMZmk0bjBSOGRiNjJYSTN6dUgwcmZPTDQxSCsrL29XZVpEaytRMm13QUFJQUJKUkVGVTFXQ1pMN3MvT3Q1YUwxcytRc2pac09GMXozaTFPZU9sSjQyMzhuK0xselRMdlB5ZnlXTnAvUEtZVFMrU2laWE5KRkxQWS9OY0taODBQcFAvWjNBdXdoK1ZiemJ1eFhpOTFxM3l0MVQ3MjVYR28vMjFkcTJlTm45MFBtLy9iUEhSK3RuelorZnRXM1FKMnVzcnpUL0w1NjNYeGt2OVovbTAvdDU2RmV5ZlpxenhiMk1RK3BMNGxrd05KKy94clBsa3JiZmFqSkhFVy92L2pDWE5zaFpyLys4YUVmRkw0OU9hWHVpRmtQZkNLdnRDem5MaHY3THBRdXA1TndXUStpczJaSHdWZittMXR2YnZQWmI2cjlhMUc2OGRXK1dmMmF6bnA4MHZqVWY3YSsxYVRhUVcrclBIOHJOc3h6OWJmTFIrOXZ5RWtCeThOUVV5K2FQamJ4cXZOSU1zOVhhYVg3djVwUHBJZjBsenpNdi9hY2JhK09kNXp2bmZHOUVMSU84RlZmWUZuUGNHUWJLWlJPaDVicDYxZXBLbUFpSytpdjluWXZmMlg0bVIrbHZXaUJoYjVKZWV0L3JiM2MwZmZWNXIxK3FpZE5DZlFkNmZhVktpNDZQMXMrY25oTVREaHRlNVkwbXp4a0pQMGx6YWpZOXVOclYzVWEzVTYrSC9GcXVKL3owK29lbUZYdng0TDZheUw5NjhOd2VybTBpVVhxVW13SnZlYXN4T2ZEWC82UHh2WStsclFQdWFRYi9tTXVUdm5VUHBXK2VYeHFQOXRYYXROa0lEL1Ruay9ia21KVG8rV2o5N2ZrSklMR3g0blR0ZWJlNVk2VW1iUzVwOGt1WWEyajg2ZjgvL21UeVd4djhlbjlEMEluVkFMMVE5Ti9NNzQ1Wm9QV204cGY5bmNHN0hINjIzbTkvSzN5dGVPNWJPZDNYY1V1MXZXUnFQOXIvTmZwby9PdDVhejF1Zi9BbjZlcjk5NjQ3TVA5UDMxbnU3UXdHWlQrdnZyWmZSL21uRzJmelI4YmVNMzVxRm5ubzcvbzhndm0zS2ZBWjJhMytKWG91MS8zZU5pUGpuZWM3N1RhOXFvQmZLbVRjU2I3NmFoWm4zcG5kMzNCNTM5TjRlVzhiUC9GZGlWL3lsYzVuNUkrWW05WmZNYzhjL0lsNDd0c29uOVVYUFQ1dFBHby8ydjhsK21qODYzbHJQVzU4UWNnZHZUWVZNL3VqNG04WnZqejMxdFA3UElINW1SK2hwOG5zMjI2VCtmelN1T3VPbGVEYTlZa0F2a0t0dElOQUwvdXpqRmtuOHFHbGdFVC96SDlrbC9wK0pYZW92MFZ1ZEx6S254ajhxWGp1MnlJZjJRK1czaWtlZnY4Vittajg2M2xyUFc1OFFjajVzZUowN2ZtdStlT29oL0ovblBYNTJweFZLYnpmL1NyT3BQZWZodjlyNFdvNW4wOHNmOU9LNDJ1WUJ2ZGpQUE5adSt0L2lKWHJTK0puL2lwN0VQMEpQK3B6TS9ORjYyZU16NUZ2MVFlVmJ5Vzhaai9hL3dYNmFQenJlV3M5Ym54QnlObXg0blR1ZTNmVmtyWWZ5ZndZK1BUdFNieWUveHU1VjM5TThic2ZMOFd4NkVTVG9oWHoxY1V2MitKbS9STzh6T0dlaHA3Vkg2NjNhWnZWWXgrL215LzYzVnYxdkUvMjNYTTBlcmFmMXp4WnZyVmN0ZjNYZXZoV1hvTDMrcy94U2ZhMmVOQjZkVDZzZnJSZGgvelRqYlA3bytGdkdiODFDYWZ3ajBQUDBselN6a0hxci9scjc5N2hGNjkvekdUVytwdkZzZXYxSnRvV21OY2lOd1p1dkpyN3krTzN4cnQ1Ty9Dei9TaXhDYjZWMnBKN1dMcTBOb2JmaUw2M0hPbjQzbi9YZjRNeVdMWjgwWHVPL28xZkpIcTJuOWM4V2I2MVhMVDhoSklhM3BrQW1mM1Q4VGVPM3g1cjRaNkxuN2EvUjI3R2o5VmJ6clRUUEhxRy9WRytrLzl2T3B0Yy9aRnRnV21POUlVREhWeHIzSG12MEpmR3ovQ083MUg4bE55cmZURTlyUithdzhwZldZeDBmcmY4MmxwNlB6dWQxM2lvdWl6MWFUK3VmTGQ1YXIxcCtRb2cvYkhpZE8zNXJwbWpqbjZldkYrRy9xN2ZiREVMclNacFA3Ym5lNHhWL3FWNVAveTg3bTE3NUZwZldXRzhHMFBHVnhtK2IvSjdQcnA0bS8wcDlFdjlxK1NUUFQrK2FJNTZUU0g5MGZMVCsyN2gzTG1zK2FmeU92MGF2Z2oxYVQrdWZMZDVhcjFwK1FvZ3ZiSGlkTys0MVU3VHhUMGN2eW45SGI5UWNtOW5SZWlqN00zbXMxZXZwLzNXT1RTOGlBYjBRejdhUVJXeCtJL1ZtL3Q1NmtueWZ3YmtLOWwwOWIzOTBmTFIrYjl5U1BaODBmdWJ2cmVkdGo5Yno5a2ZIVyt0NTYzc3ptOC9vVytjSXROZGZPeC8wOWRMcVNlUFIrYlQ2VWoxMGZSNzJUelBPNW8rT3YyWDgxaXkwakVmN2o1cGZXcjFaYzJ5MWVmWkd0UDNIQjFWdnEvYzIvc3RmOVVINDY3L2hDeGxFZnUvRnA4VGZZdU93cTdtcXRScS9xNGNjOXg1cnh1MFJWWmZHMzF0UFluL3pxV3J2UFphKzVxejkwZkhSK3IzeHpKWXRuOFlmL1ZsZzhkbUR0RWZyZWZ1ajQ2MzF2UFc5bWMwblc5TkxpL1Y4MFBwYVBXbDh0TC9XN3BsdkoxYXFaK21QanI5cC9QYllNaDd0MzN2ODVqK3o3K1picWNjcjE2N2RLdC9VZjJzaGNraXpDNlZsc2RpMTNEQWdOa2ZXbTB0TnJMYTVoTkxjMVVNLzl0YTcxWTdXOFBCSHgwZnJ2NDJsNTZQejdmcnZmaWFnOWJ6czBYcmUvdWg0YXoxdmZXOW04MkhUSzFhZlRhK2MrZEJ4M3VmUjhUZU5wWTBRYmJ4SDQyVlhZemZmcXYzR1p0ZlNZL0ZDNUxDR0YwTFBlM0h1YlVkdjByejFQRGZoRmsySGtkN00zMXZ2ZG52UFIvTWFzZlpIeDBmcnY0MTc1N0xtMi9IWHZPK2o5VHpzMFhyZS91aDRhejF2Zlc5bTgySFRLMWFmVGE5OCtUU2FVajBMZjNUOFRlTVRHMTQ5UFdSelROUHcycTNQMm02VmIvVDQ5NWkvNlVVeTQ3RVpSdWIzanAvNWUrdU43TnBtME9uMlhUMnRQem8rV3I4M2JzbVdUK3BmK2IxZ3h4NnRsOTBmSFIrdEg1MVBTM1M5NkNhU2REN1MvT2dtWXF0bkhSL3RyN1Y3NVBzMDQxRk9yWjZGUHpyK2xuRnJzNDVIKzYvWW4vK05melhIMW83SzE3UFA4a2ZidjhjdFd2dDNEVjEvTnIxMGVDOWt0YUEzQ3VqNGtaYkhKdlV6c0srTzI2TkYvTnRqU3oyVVhWdXJoZDFyN2l2MTdlcHAvZEh4MGZxOXNkVFhNaC9DWHhxdnFjY2luOFFlclpmZEh4MGZyUitkanhEeUQyK2JiS1FkWFEvYUh4MS8wL2p0c1dVODJoOXRmd2IrQ0R0YUQyMS9YbnlzN00rYlA1dGVlM2d2WUxXZ053am8rSm1lNTJZWVVZOWxmTyt4bFI3SzNoNTdqeVBzMFRXaDlMVCs2UGhvL2JjeDJtOVhCM1VlOFI0UUdiZHFqOWJMN28rT2o5YVB6a2NJWWNPTERhLzk4VnZ6d3pJZTdXOWhmenIrcU9hUFJ6TkphLy9tN2ZvaDdHKyt6L004SHphOTVIZ3ZYcldnTndmbytKbWU5N2c5SjRuL0RNNGg0dC9zVW4rSkh0cnVuVy9Gdm5PTmtQWm9QZXY0YVAyMzhhcVBaVDZrdnpSK3B4N0xmQ3YyYUwzcy91ajRhUDNvZklUY0RodGUyUGlieHIzbWgxVTgydC9LL2d4OEVIYTBYbFg3MDN2TXBoY1pnVjU0WngvUGtNWnI4MnYxdFhvaisyZHdybWRINjJuczN2bmF4MWI1dFA3bytHajkxWEZMdEw2Mm5sbTgxbTZkTDFyUE9uKzJlR3M5Yi8zYjBWN2Z0Mi9Ka2ZtbCtsbzlkSHgyZjYyOTlVSGJkK3FUNm1uOTBmRzNqTithaFpieE0vOWVjMlRrYjIzL3FXZldISlBhMFhyZjlwYnM5aCtmUDU3LzI1dGUyUlplM2hzSnFaWkUzM3ZUYXJGSi9RenN2WEY3WElsL2U2elJuK21oN0R1MW92Vlc4NDM4a1BrazlsbDl1M2F0UHpvK1duOTFQTE41NjJ2cjBlcEw4NlB0VmxvVy90clAzdWg0YXoxdmZVSnU0VzJUWFlsWi9kTDVhZjNSOGVoeGRQN1ZCdFJiQXdVZFAvTmZhWDVwOUNUMldYNkUzU3FmWlROdFZQdXUvVTMvZVo1N20xN1pQaUE4Tnc4clNEZFQwdmpzNHhuYXplWm40Zkd1L2t3UFpXK1B2Y2RlZWlQNzZKeEZ2aFc3ZDQ0ZGYzUjh0UDdLV0hyZVdsOWJqMWJmS203Vmp0YXg4dGQrQmtmSFcrdDU2eE55QTJ4NFlmM1o4Tm9majVvbEZ2RXovMUZ6WjlVZlpmZHNGcUgxdm5tYkg5TCs1aWV4OS9SL1A3Nng2Wlh0QThKcjA3Q0tkQk1samE4MmJzK04vRCtEYzZ2K28vaVova3dQYmMrdXQzck82M3ExOWxsOUNMdldIeDBmcmI4eTdwMkwwdGZXbzlXWDVrZmJVUnFXL3RyUDRlaDRhejF2ZlVKT2h3MHZySCsxaGxkMFBiMkdUM3ZPSW43bVAydnVvUFJXN0tQbUc5cWVYVzgxMzlONVBMUDM5SC83M05qMElqaXFmZUR1YkU0citWdmFQeS9ucFA2ZWVqdjVUN1JyL2RIeHEvb292ZDF4UzdSK3RIODF1N1cvOXJQUHV2N3FlbHF5MVlObTlDMDRBdW4xazlZejA5ZnFXY2RuOFA5TTdCSzlDUHVzL3BGZHFyZmlqNDVIajdQVjgrbllyT05uL3Q1NkkvdXMrWWEyYS9SYUxQUkc5bEVOSy9ZVi9YTC9lbVAwUWlaNm9TckZjdUgrRmhzOTN4YkVwbHk2Q2Jmd2Yzc2NZVit4emZ3OTlYYnlyOVpYeWE3MVI4ZXY2cVAwZHNjdDBmb3pHOUovUjgvVHZ1cXo0MnVSWHh1TC9tek5ycWNsV3oyRVpPRnRrNTdKcnRYVCtxUGp0ZU5aSFZrYVhqdjFTT05uL2tpOXQyYUsxQzZ0VDF2UGJ2MmpXcEI2UFR1aStmY00vSC9icXpTOW9oY3cwUXRVS1lnTmhTUStlcjVTUERlbld2L2VZMjk3ZTlUNlcrdHA4NC9zRnBvZWRxMC9PdDVhRHpGdWlkYjNPbThWaDdKYitWbnI3c2FoUDJPejYybkpWZzhoR1lodWFMSGhwY3YvNC9QOHp5OUR3MnUzSG1uOHpCK3BwMm0ralB4MjY3ZHFIbjAzaTU0SGszK21OMkxtMzdQUHRIL2JLelM5b2hjdjBZdFRLYWpOeEdwODlIeFgyTjFFZndiblBQemY3Ry9udmV6Vy90bnp6ODVWc0d2OTBmSFdlb2h4UzdUK1RBUGhyOUh6c0V0OUxUL0hkejREbzljVjJmVzBaS3VIa0dpaUcxcHNlT255dHo1WkdsNDc5VWpqWi81SXZiZm0wNjRkVWI4MG42Vi8xdnhQNS9GZjV5bzB2WWdmMWd2aDZNMXFDenBlcTUvSi9uazVKOVdUNm8vczF2N2VldDcyWGIzWldCdS9xb2ZTWHgyM1pOT1h4cy84dmZXazltaTk3UDdvZUd1OWF2bXpJYjBlczIvWXRjenFrZVp2OWJMSFIvdXY2SDBTMjkvcWwrcHAvZEh4Mm5FdnQxZiszdml0T1djWlAvTmZzVCtML3IzbTA2TzA3OVl2ellmMGI1blpwZjRXK1Q4enUraUQ4OWQvUXhZZTBZczNTLzhWMzVIUG0yMTNNN0NxdGJvWnN0NlVTc2Fmd1RsMC9KdXZ4dC9DdmpxM0ZkdHE3S3IraW9hVi8ycWRPOWN5eW83UW00MjE4U005Qy8zVmNVczJmV244ekg5bTArZ2g3RlphSi9pajQ2MzFxdVd2am5YVHl6cC90WGhML3hYZm1VK2tmU2RXcWlmeFI4ZWp4KzE1Ny95L0pvOHQ0MmYrTy9hZVAwcC8xUzZ0eDlOL2R5NDcxd2FSZjFsN2FTRVIxT3o2SVhyeFp1R3ZYZHhMTnl0U1BZbitqbDdVMkdOelAvT1YrcVB0VVEwZXJiNW4vZExyNS9YYzdkcFJlck94Tm40MUZxVy9NbTdKcGkrTm4vbnZudmV5bzNWTzhVZkhXK3RWeTE4ZE5yMTg0NjM4VVg1UmRuU2M5anc2L3VUeHJOR0FqcmRvUXMxOHJQTmJONU8wL3A3TkxrKzkzNCtuQzRuZ2h0Znp4Qy9lMFA1YVBmU21JbnJUNXptMjN0Ukw5YjJiSW0vK0szNnIvbEk5NjNwMjZsODVGL2tjU3UzV2V1ajRhUDIzY1VzMmZXbjh6SDhXZy80TWt0cFJHaWY1bytPdDlhcmxydzZiWHI3eEZ2NFN6WXhOTDQybVZHL0ZIeDEvOHZpRWhsY3ZYMVREYTdVZWIzL3JmRkY2ei9Qd043MklqT3dMVCtsbVR4dVAzc2g0YkJZdC9YY2FicXZ4aUh5Ui9sRjJhejEwZkxSK2oyejYwbmkwZnpYN2FmN29lR3M5YjMzeUo3UHJiZDBVYS9OTDgxV0x0L0QvVE93U3ZRajdyUDZSWGFxMzRvK09QM1hjMnF6alovNEkrL08vOGEvbWFKMi9sNjlYRDlLL3hTSis1ait5Uy8ybGVzL3pQSi9ibWw3VkZscVpGckp2c2RIWFU3UHAzWTEvMjN4cjlHZDZiL2EzeDZ0MmEvOFZqZDE0Ukw1SS8xbmRWblpyUFhSOHRINFBTLzJWOTFkdHZNWmZhOWRxb3pSMi9TMjFkL3pSOGRaNjN2cUVWT1Z0MDJ5cEYyM1g2bW45MGZFbmpkOGVXOGJQL0RQYnY1dFJQWHVVLzJndXlQaVpmOCsrNC8vczZOM1M5S3Eyd01xMmdKVnVEcVBSMWl1TlIyOXdWamVQczQycmRDT0o4UDhzSHFYeDZIemUvdG9ZaE4xYUR4MGZyZitHbGY3cWVXMzg3bm10SGZVZTZ2MWViSzI3NjQrT3Q5YnoxaWVrSW14NHlmVFk4TEliajVvWkZ2RXovOHgyeSthT3h2KzdPZlE4OC9vUjhUUC9FYXYrSzFxdmVqYzB2YW90cnJJdFhxV2J3Z2cwbTE1Si9HZHdia2QvcHRmYTMvdzFkbS8vMC9QTi9HZm5QT3pXZXVqNGFQMDNMUFJIT2RIeE8vNWF1MWJUU212VjMwSlQ0NCtPdDliejFpZWtHbXg0eWZUWThMSWI5NW90VnZFei84ejJ0MlpZeis3dEh4MXY1ZjkwSGsvMWJtaDZFVC9RbThHVnpaNEU5RVpFV3AvM1pzMXpvL2FaSEJIeEVuOXRmTFMvbFIybGg5TFhqaTAwMy9CK0w3T09uL2xyN2RYZjZ6emZPM2ZReGx2cmVlc1RIYlBuWitWYmRVMCtxWDYxK0JYL3o4U08xb3UwdjlVdjFkUDZvK05QR2I4MUF5M2paLzZaN2IxbTJOT3hJLzFiTXNhUC9OL2lKZjdmT1pmMTJQVENFcjJ3ODE1NGo3Uzh4N09hVnVKWC9OdWoxdi9OL3ZiWVUyL1hmOGRYR2kveDE4Wkw2OXp4MStqdDJqVjZGdnJhc1VaSDhyN2kvUjVtSFQvemw5aG43NmM3K2FTK2tYb2UvdWg0SzYwSWZWS1h0MDFsSmFUMW8rYzcwOVBhdmZONys2UGpLNC9mSGx2R3ovd2o3ZC9OcUo1ZHFxZlJIelhIc3NiMy9EMmFoYytiblUwdkRORWYyTjZMN1ptZTkxZ0srbnBKNnh2WlA1M0hYbnE3L3JOalQyODNmalZ1TjM3MUhNSi9SdzloMzlXejB0ZU9kMk5YLzM0OHh0cjgwdmlaLzZwZGVuN1ZYc1hQeXg4ZGo5YUowaWMxWWNQTE5qOGJYbU4vTnJ6K0hZK2FGUmJ4TS85SXU3UVpzNnFuYmZaOE4zT2VSNTR2SW43RVd6ekN2MnRqMDB0UDlBZTI5eUo3cGhjOWZ1UFRlZHlMNy9sL0puYXBmMnQvODUvWmtYcGFmMnM5Ny9qVmN4cC9qUjdDbnQzZmV0eDdUcUxxUWVTWHhzLzhWK3lTNnllMXIvcEU2bm42bytOUkdwSDZwQjVzZU5ubVo4TnI3TStHMTcvalVSUEhJbjdtSDJsL2ExNzE3Rks5SFgzR3kvMmZ6bVArcGhmNWcrd0xFTzNtYjZhbkJiRzVpOVFiK1g4bVJ3ODlTZnlibm1mOHpOOWJiL1E0ZzcvRWhoejNYbS9XK1VlNWQvV1EvdDU2VW51MG5yZC90dmhvZlRUUjljNis0WTZtdlQ2SWVyODF0WHJhK25iaXBmVkwvRmZxbWVscDdiTjYwUG05L2RIeFZjYTk1c0hUOGRmRzcvaEgyWHZOcTJkaVg5V1Q2bnZHejhnUUwvSC96dm1iN0UydjZJVUlPbisyamNETU45UDFSMjh5dGY2cmV1MXhacGY2OXg1YitDTjh0WHFTZU8yMXovamNhZlJHajZQOGQrTFI0OTc3bkhYK1VlNWRQYVMvdDU3VUhxMm4wZDZOUWNRaU5TSzBMYWhXYnlSdm03eE1hT3VUeGtmN2ErMVNaZzBXYVg2dG50WWZIWjk1dk5LTVFzWnIvVDN0Ty82aithd2NzOFJMcmtWa3ZOby9hOU1yK2dNVm5UL2I0bi9tSDMzOVo4enF0YjVlV2oxa2ZaL09ZN1QvN09pbHR4by8wN09Pbi9tdm5rUHByZGlqL0hmalR4aTNlT3ZOL0wzMXBQWm92VjNkcURnckhTOWRLNnJWR3dVYlhybjgyZkRTK2QvWThIcHJsanhmTmxROHd0L0xQbXZTOVB4NzgxazlSc2YveFBaWXVWN2U4U3IvakUydjZBOVVkUDVzaS82WmYvVDFmK1BUZWJ3emx1ck4vRWYyajlDTzhGL3gyL1cvWFU4YVAvTmZQWWZTVzdGNys2UGpLNDVidlBWbS90NTZVbnUwM282bU5sYVR6MUxMVXRPU2F2Vkd3SVpYTG44MnZIVCt0emE4dnM4OUx6NkllSlMvaDMzRjF2Ti9tNCswNFJRWm43MCthZnpVUDJQVGkrUmx0dGxCajZWbzliU2JKYTA5MHYvemNrN0tTRzlIWDZLM29xL1ZrODRQNlcrdHQ1dGY2NCtPcnpKdTJZbGZmYTN2K2t2cjhiUlgwOVBHYS9OVjA3TW1XNzF0UGJOdnRDUDRyaEZkSDJMKzJ2cWs4ZEgrV3J2VXQvVkIxK2Z0dnhyZmJxWlg5YUxHczJiV2pwNGtIdTF2YVo4MXkxYjluNDU5ZGtUR3o0alFsOFMvNlVuelQvM1o5TG9MelVJdjJ5YXg5ZEZ1R252KzdkSGFIdUcvWTBQRW9QVldZclY2dS9rUi9qdDZFdnR1ZnEwL09yN0t1RVg3SHJaaWsvcEw2L0cwVjlQVHhtdnpWZE96SkhPdGI1dXVURmpYRnoxL2FmNW9mNjFkNmp0cm1FZzF0WHBhLzFHOHRtSGtQVjVwZm1uMFp2Rm9mNDE5TnY4ZFBZMi90cjVSdktSV1QvM1ZlRVF6OEZueFo5UHJEdENMYysreEZLM2V6Ti9hN3VuLzZSeDM4bzcwZHZWWDlWYjFVWG9TLzVXNG5aeWFldHZIYUkwZGYzUjhoWEdMZFh5MFA5cGVUVThicjgxWFRjK0tySFZHTjN4bXNPR1Z5eDloLzJaVzIra05yOW4xeU5UZ2FzZWpac3J6WmRQb2VmcHI3TkxteWFyZXJqK3l1ZE1lUjJqclEraExlTk9UeGcxaDArdDgwSXZ5NlBFYm44N2pWYjFlL01mWjd1Mi9vb2ZRT1VWZnFyZDZEdldha3RZcjFWK3hhLzNSOFJYR0xkYngwZjVvZXpVOWJidzJYelU5Q3pMV0dOM3dtY0dHVnk1L2Evdk0vOFNHbDZXZVY4UHIrOXp6NHFQUjgvTFgyRWZOdjlZdTFkdnhueldVTlBHbjZlL3FQWjNIZngzWjlDS1ZzTjVjUk51OS9TVjZuNWR6bHZyU280ZStSazhhUC9QUFprZjU3OFpyZkQzR3ZYTWF2VWovM1pqVjJGVWZSQzI3L3ByM3dwMVlxL2ZlekpwSXF0UW4vWGJjaSsvcloxRWpVbjlIU3hvVDdXOXQ3L20zbTFOdGZxa2V5bjgyWHRXYmpWZno3ZXEvTmV1MCtTUjZNMytwdnNiZWEwWTlFN3RVYjlWL2RwelZwejErNjgrdzFsL0pwOUg3MWh3NmRQbjEzNUJGUXZUQ0RyblFYdkZCYnh3a201bWRlTTl4Ny9HcTMwcDhlNHkySS96Zkh1OGVkMjBJZllRV1d0OHpmdWJmZSt4cHQvQ1h4Ty9vUlkxNzV6UjZrZjY3TWF1eHF6NklXbmI5cFpyYVdFMCtTeTFMVFNUWjY4dmE4UHJHdWthay9vNldOQ2JhMzlvKzg5WG9TL1VzL0dkamlaODJYKyt4Wkl6T0o0M2YxVWZaVit1VDZ1MzZlK3VOcm9QR0J4bHJXY3ZRNzNVQkVOVHMrZ0dSMjNvaDZya1FSMitjdFBHZTQ1M043TzdqTEhhdHZ6WXVpMzYyZXJUNjB2aVp2ellHYWJmeWw5aDI5Q0xHTGQ1NmFIK3RmZVp2blYrYno5cy9XM3kwUGhydmVpczB1YjdKM3ZEeWpvLzJyMmJQN3IvVDJKSTAzVllhU0pvYTBmbWs4YnY2MmtiYVN1TkVvN2ZyNzYyWFBiOVZ2bVhkdno3Z2d4dGV6eE8vaVBOZU5IdHZZcXczWWNpeGRoT2JwU2xnMWZoWWlkK0p5NktmclI2dHZqUis1ajg3NTJIMzl2ZldzeGkzZU91aC9iWDJtYjkxZm0wK2IvOXM4ZEg2YUx6cVpjTUxxOCtHVjI1N2RuOUVRMnczZnJhSlI0KzErYlROcWpjZnBIM2wzS3FlMXQ5YkwzdCtxM3k5eDM4YytadGU1QnZ2eGFsMjh6UFR5MGExelpCRUg5VlF5bEtQdEJtRWprZjdvKzI3ZWxwOWxGN0VXT3FyMGZQdzE5b2xmL3VJUmhZeW43Yy9PaDZsRWFtUEptcjlVNlg1WlYydlZ2LzcrZHZSa09hWDV0djE3L25POUxMWWZ6WGpWVDByLzdhZVhuM1M4VzYrVm1zM2YyK3N6U2VOWDdILzZQMXFqaWg3TDc5VVQrc3YwV3RCNkd2eWEvSE85NTJ6QzV0ZWY0SmU5RmhzRkpEK3Mxakw2NkhaTU83b3pmeXQ3TzF4WnRmNnY4V3YxSVhRejZDRnJDZjZ1VUQ3SSt3SVBhMitSaS9EV09JbmVWK1d2b2NqL0xYMmxmZDVWSDUwUG05L2REeEtJMUlmalhlOWJ4dTB6RmpYaTlEWGFPekVTbU1rL2l1K001OUkrMHFEWlJhRDhsOXBicTNvN2VaYmJYNmhHMTZhZk5MNHQ4ZFo3RnIvMmZ4M2prL0hodExmelk5cXBubm5tK3F6NmZVUDZBOXg3ZUk4ZXZIc3ZRaEQ1OCsraVBSOGZqK2R4eWcrb0dQN09McWVXWDJhK0JVZHREL1NqdExUNnUvcVJZMTNZelI2MGY3WjdORjZXbjkwdkxXZXQzNDFzbCtQOWx0emRMMW8vWjBHbENZL3V1RWxyU2RidzJ0V3YzZkQ2N3VleitDY1JHODMzOHJZb3VHMW0wOGFQMnB1Uk50blRabVp2N2k1SWpoK0k2MEhuVi9MU3YzVytZYXc2ZVcvYUl4ZVpNL2lQUlpobjg3amxiRldiK2FQdExmSDNtT1UvNG9lUXNmcWVIcDlxK2VzL0JGMmF6MTAvQW5qRnV0NHRIODJlN1NlMWg4ZGI2M25yVTh3U0JzNjBmcm9CcFIzUG04OWk0WlhwTjVxUTZxbmlXdzR2ZVZiR2FQeXo1bzE2UGhSVXluYXZtSWIrWSthZnpOLzZkRmEzL3JvWGI4NEg1dGVSRUw3WVNFZG8vT2ovYVZZMTJONS9UNHY1NklaMWVkOXRLNVBxb2YybDlxOTlORHhXY2VyUGhvOVQzK3RmZVY5U0pzZm5jL2JIeDF2cmVldFQ3QjhieVlxNkV2MXRQblIrYnoxMFBidnYrKzNtRlc3VksvblB4dXY2dTNxVzQybHpiTWR2Vkg4am4rVWZkWXNtL24zNHA5RmYrbnhXeCtOUmIyZTliZHM1V1BUNjJ5UWkweUxUWjhrcDNUVHAvWHYyZHZqek83dHY2SzNZL002WnFoaFZBdGFQOUpmYXU4OWx0aFgvTkh4V2NlU2N4bzlMMyt0ZlJhTHlJL081KzJQanJmVzg5WW5XTjQyaUpuMXBYcmEvT2g4M25vV2RvMm1WRS9hNEJucHJUUzNkdlRSRGEvdng4OWsvRkhxdGZFUy94MDlpWDBsdjlZZkhiK3FiOVdNc3REMnFIL1VYQlBGcytsMUp0WUxZZTFZaTFRdjIwSStzdjVQNTRqT3MwdXZQdTlqK3hoZFgrK3hsNy9VanN5eGt4TVJuM0U4czJuZlc3Mzl0WGIwZTZQV250MGZIVyt0NTYxUHhzeStKVWMvUDIwK3JiNVVUNXNmbmM5Yno4TSttc05iQTBhaXQrTS9HN2RhYitjMCtxanhxUG5TRzJ2MWR2MW56WW1lM3FwOXQva2g5VWZIcnphT1VNeXVYL2I2VitZamdrMnY4N0JlOUZwdStsWnFXTkZEK24rZmE0Kzl4MUgrMnFOWG5pckhaOUhQU3gvdEw3WDNmQ1IyclQ4NlBzTzR4VnNQN2ErMXoveXQ4MnZ6ZWZ1ajQ2MzF2UFhKTzdNR1JmWjhVajF0Zm5RK2I3MXNkbS8vMVFaWUwwZVdodGYzdVdjeTF1cnQrSSthWXpPOUZmdE1mOWFRa2ZpajQ3MlAxZW8xbncrYlhpUVQwWXZyYkl0djczbytMNCtqamhsQVhnK3RQdHJmMjY3MVI4ZG5HRXQ5TlhvZS9scTc1RzkveFJmOWZwL05IeDF2cmVldFQ4WjhieDRxNXBQcWFmT2o4MzIvL2xjMFYvV3M3VDBmcWI1VWIxZC9OdjQ1cDYzSGN0eStWODRhV2hvOWpiKzBtZGJUNjlsbityUEdoOVIvRk4reW8yZDlITlZiRGNoOHNqVzl1QWdhazIxUnJFV3lZWlhHcitxL2JaNVg3RDE5cmIrMEh2VFJNMWVGV3F5MXBQRklmMGx0dS9vYVBZdjRqR09KMytvNXFTL0tYMnVmeFVoOXRUVm05MGZIVyt0NTY1TXhieHZNU3Zta2V0cjhGdmtrbWpOZmEvdk1aMGUvRjdQU25CcjVyOGFQR2tnU2ZhL20xNnpocGRGYmFWYU4vRFY2SzNadi8xNzhhSzZaanIxNkt4NS9VT2xrYVhweDRUTW0yMExZbXVpRmRyYnI1Vm5QSjhteGZUenp0Y0p5UHBwNHJiODJSdW9yMWJPTXp6TGVqZEhvUmZ0NzI2UDF2UDJyNjFYTG53M3B0K0RvNnpmTEw4Mm4xV3ZqdGZuUitWYWFSQ005YS90YlBaOW1yTTNmMC9zTXpxMzRyOGEzK1ZmcmlSaXZOTHgyOVZiaVovNjdlcjNtMkt5SlllMC9hcjQ4VDMvK21ZNG5BSnRMaHFZWEZ5MWp0TmVud3ZXVmJGeWw4U1A3UjJuditlMzZTK3M1L2ZpOGpFZlhLUHRSVzY4MGZ1WS9PN2RpbCtTWDZsbkVuekJ1c1k1SCszdmJvL1c4L2F2clZjdWZoVmtEcFZwK3JaNTNQTm8vMmo3elIrZnZOWng2R2pQL25YaEpQUkhqWG4yejVzNU1ielYrNXIrak4ycU90WFp2ZjI4OUhzZlh1WDBzUG1ab2VwRTRyQmRJcmI0MjMyMkwyOXZtMi9LWlBCNmRpejYrb2FsWEdvLzJieDlML1hmMWR1TTF2aDdqM1JpTlhyUy90ejFhejl1L3VsNjEvTm40dVI1UjMrNmo4MnYxdk9QUi9sNzJrYzlJRDExZmI5elRtUG52eGt2SHZYeTdZMjB6YkVkUEdqL3pYOVdiTmNkbWpReHJmNG1lRkVSK2JTT3BHdXJhMmZTU1liM0k4bHpFcld5YU5KcWFEZDJPM3N6Znl0NGVwZjZ6b3phKytuRjJMa09OdTdWYnZ4YlEvcTI5OTFoaVgvR1h4Ty9vUlkxWHovWGVLM2Yxb3YwOTdkRjYzdjdWOWFybHo4YmJock55ZnEyZWR6emEzOXErNnZQajl6UyttdnlyZWpPTm1YOHZIdEhjV3NrbmJYaXQxdE5yUm1uMHBQR2Y1bWh0OS9aZjFkdHRsbW56ZTljZGRmenNuS3dhQUFBZ0FFbEVRVlM1WHVxNjJmUmF3M29SNGIxSWFmTjV6MCtiNzdhRjdtM3ovZWJUT2M3czBjZTNXcEY2M3Y3dFk0U0dWRTlpMjlHTEdFdDlOWHJSL2g3MjdQblE4ZWpQaHRQV09yZUJ2cjdTYjlXbCtXZjZNejN2ZUc5L3RMM2xyUUhUbzkxODd1Ui9pNTNwamVwYjhlL0Z2MjJtUitQZGZLdmpVWE5tZGF6Vms4WkxteE5hdTdmL2FnTnBsZlo2UmplUmR1Ymd5ZHYxVXNHbTE1elRGb0dTVFJNaWgyWVR1S00zODBmYTI2UFVmM2JzUGVheHh2Rlo5TFBTUS91MzlwNlB4SzcxOTlhekdMZDQ2MFg3byszWjg2SGp0Zm1zOWJ6MUNZWjJnNTVOM3pzKzJsOXJuL212NkQ4REgybDlVcjBkL2RuNE8vOXNqTWpYRzgrYU02dGpyWjQwL3RNY3JlM2UvdWhqZFA2Mmpnd05PTmZyeGFZWEdkRysyYy9HaEdUaDQzd2MxWURTbCtpaC9kRjJyYiszbnNWNFp0TysvNkx6YS9ROTdObnpvZVBSbjcvV24rZGNMOVRpZTdPUlVkODdQdHBmYTUvNVcrZlg1dFA2cjQ1L3pyVmpxM3h0cmw1K2xCNHlmdFljUTl1Ui9pMHI4ZHJqS0w4blB6VjlQMFlmRVRVK0lLM2ZuTmIweXI2b3FyUklSVzdvZG5LdTZNMzhMZXp0VWVvL082TDFiajFteVluV2ovUkgyN1grYitQWmM1RnhQRHEvY203MFhybXFLZlZGeHlCaUxmVFErZER4Mm56V2V0NzZCTXZiQmppVHZuZDh0TC9XM3ZvK2piOWxmbWsrcmY5T2MrdnRYQzhub3RuVmpqK1QvRHZOSzFSOEJqdktmM1J0TEkrOS9CRkh5MW9RMmc5STU0L2pLVTJ2N0F1cDZndFQ2WmlRQ0Q1Zng4L0xPY3RqKy9pdEpxUyt0ei9hcnZVZmpXYzFaUm12K21qMGtQbDM5S1g1cFhhMEhqcWYxajlidkxWZXRmelpnSDRyL3NpdnJ6VC9USCttNXgydjlaZldJOVdUNVB1OCtGam1sK2JUK3MvR1BiM1BaTHliYjJXODB2RGExZFBFOTVwbDNuYXQvOXZyMWJzWmxRWExlVDdQKzV4WHI0blp0VHFoNlpWOTBWTnRrV214c2RQVXNLSTM4MGZaMjZQVWYzWkU2OTEyN0QzMnpKOUpIKzJQdG12OTM4WXJmMVBWeGkzWjRyVjJyWjQydjNVK3JYKzJlR3U5YXZtejBHNllxK2ZYNm5uSHoveTk5VmJzejhBSG5WK2FUK3MvRzYvb3pjYVNmQ3ZqWHI1WnMyZW1wNGtmTmN1ODdWcC9kRHlQNCtzNmVyeDY3czIrZlR5aDZVWHF3c1VxK2VFRE9yYVBQWG1yUVZJM1VoL3RqN1pyL2RIeEdjY3QyZUsxZHEyZU5yOTFQcTEvdG5ocnZXcjVzL0Z6UFV5K0lRL0lyOVh6anAvNWUrdGxzM3Y3ZSt0Wmp0djN1dDNtbHpSKzFpenp0bXY5Ui9FemR2VFJqYVFxZk5mOGRyM2Y3QzdjM3ZUaUl0QVh5WVpVR205bGI0OVMvMUU4UXUrVVkxWXR6OXhvZmJRLzJxNzE3ejJXeEZjWXoyeWU4VHY2MHZ4U08xb0xtVS9ybnkzZVdxOWEvbXk4YlhBcjU5ZnFlY2EzelFORVBUUC9TUHRzdm05MnFaN0VmelpHNjBVMXY5NmFCbGJ4TTM5dnU5YS9GNy9hSEpQcW80NnJkV1k2dnRYOExEenUyWHVJNnJxMTZjV0ZYeTZxMTAvMitId2RQeS9uTk1jb05QV3UxTDZycC9WSDI3WCtraHFxam52blBPTTErdEw4VWp0S0E1bFA2eCtkejFvdlc3N1RrRjQvOURmc3MvelNmSzFlNXZpUHdHZTFucGwvcEgwMjN6ZTdWRS9pUHh1ajlTTEd2V2FNVmZ6TTM5dXU5ZTgxWjNwOCsrenFJNDdQczE1ekZtYlhPMlF1TnphOXFpOEtzK1hmUWJJeGxjWWo3ZTFSNnI4YXY2dFgvZGg3Zk92eFdmU3owcHY1bysxYS8xNk1KTDdpdU1VNkh1MmZ6UjZ0aDQ3WDVyUFd5NWJ2VnI0M1ZCWHlaWTl2bXdmb2VsYnllOXBuODEyeFMvVkcvck14V2k5aS9HbU8xdkV6ZjIrNzFsOTZ0TmFYMXBHaEFZZWUxMmcrSTdhdXg0MU5MMEpJUEovTzR5Zys0S09tQmxTK2tkNk9QOUx1N1gvQ3VNVTZIdTJmelI2dGg0NUh2NDk2dnk5bitCeTRpZS9OWElWODJlT2wrbWgvYjN1MG5uU00xb3NZdHh0NTYvaVp2Nlc5UmVxL0VqODdTdlF0K2FucCsvSHNXQVhYZXRuMHlvMzNvaG5OYUVPS2lMZXd2MjJtSmY3bytGT1B2Y2NaNm9uVVJPZEQreVB0M3Y2bmpHYzJkTHpHWDJ1ZnhTTHlvL05wL2JXeG1ueVdXaG56M2M3MzVxNUN2c2o0dGptQTBKZjR6L0pIMkVmMVMvVzAvdHI2S293L3pkRTZmdVp2WmU4MW4xYjlWK05ueDFWOWo2T2tsa3gxcjlTNFUyOGJ2d1NiWGpuUkxrSzRjQ1FaK1h3ZFA4MjVDRWIxYUkvdDQ1MmFFUG1zL0xWMmIvOFR4cjF6VnZFNy9scTc1RzlHbXgrZFQrdS9HNE9JUldwRTZoTVo3Zk5oL1kyN05sOWsvRS9zS0VhcUwvR2Y1WSt3aitxWDZtbjl0ZlZWR1BlYU9WYnhNMyswdlgzdVAwTC9scFg0MlRFTGtycWZKK2NjdmdtcGpVMnZmR2dYaFJrWGxiT050alllWlYvWlNJLzgwZkduSFh1UFQ2M0hTaGVWRCswdnRYdjduenB1c1k2ZitXdnRNMy9yL05wODN2N1o0cVAxeVI3Zkc2WUsrYnpqMithQWhmN0lmNVkvZy8zVGpDVjZXbjl0ZlJYR24rWm9IVC96Ujl1MS91ajRxc2VuOHpqYjhRZHQvQXFmNTduM1gyOGtObkF4UzNwOE9vK3Q4ODJPbHZXODVkZzlhdk9oL1JIMldmNlJ2MVQveEhHTGRmek1YMnVYL2gxYTE1ZmRQMXQ4dEQ3UjhiMDVySkRQT3o3YXY1cmQyeDhkbjNIY2J2d3Q0MXM4N0tQNlZ2d2w4VE4yR3pHSUJvMlc3NXdaNmhuaFdnK2JYbmVCWG5ScU5xaFNQUS83aXY5S2MwQVNmOHV4OTlnakg5TFhzZzZFbHRTbThVZllaL2xuWTRuK3FlTVc2L2ladjhRK2U1K2VJWDBmM3RYSTdJK0tSV3BFNnBOOXZqZUxIcmtlUlQ3ditHai9hblp2ZjNSOHh2R25PVnJGejVwalZ2WmVmYXYrcS9HcnpiS2RXR1FkVmprOTZ1bnhWb05YUGZ6WEd5L0JlNUhKUlMxNW5uOWZCNS9tY1VTKzJkR2pKczJ4ZlN6TjE0dmY5VWZiVi9MUHh0cjRhdU1XNi9pWi80cDlGQ041ZmErZ3JUKzcvMjZNaDFhRVB0SFRQa2VXMzhELzVOck40UjBmN1YvTjd1MlBqczg0bmpXVHRQSHR0ZnNFMk4rYUZSTC9VZnlNSGYyVjQ2T29hWmZvZW1iYW50ZmlOMng2blkvSFFsT3kwZFRxZWRoNy9pc2JjMG44NmNmZTQxUHlSVnhQei9pWnY3ZDlOdGJHVngyM1dNZlAvTDMxWm5qclpmZjMxdlBXSnhpK04waFcrbzhpaDNkOHRIODF1N2MvT2o3aitOTWMwZkhaN0ZwLzZkRksvK2s4ampwNjFmTk5MN2ZuOVdEVDYzTGFEd2ZwbUpBZW44N2pVL0pGOERiSDNsRWFQL1BQWUplK0gybmYzN0tQVzZ6alovN2Vlak84OWJMN2UrdDU2eE1zMzV1L2pQcmU4ZEgrMWV6ZS91ajRiT01XaS9pMlVlQnBmNnRQNHI4U1B6dEs5Q1c4Tlh5bURScEQzdXJ4eUJWT2ROUHI5a1ZRNUNMWGVnTW1yZUZOVDl2STJORmZhUVpJNGlWNmxxeldoenIySHArU0wrcW85ZFg0WjdEUHh0cjRDbVBwZWF0NHJkMUsxMG9ucTc4Mnprb25TcC9vZVB1RzNqTFBycjUzZkxSL05idTNmeSsrOTNyTzBzeDZHOC91Z3RuUlc0bHZmYjNzdmZwVy9WZmpaOGRWZld0dHl6cmVjbGprYS9YZnhoN3ovT01ZMWZTNmZkSGp0UWhlMWRPT1NWNmlueXZML0ordjQ2YzVkeXJ0UEh2SDl2RXNmdWFmMGI3eXZxU0p6emFXbnJlSzE5cXRkSzEwc3ZwcjQ2eDBvdlFKaHAvbnllTnVBMDBlNy9oby8ycDJiLzllL09yNURPTmVzK0RwK0t6cXJjYlBtbU5vKzZ5K21YL0xTdnpzYUlXa2pzZWhKcS81UnRid0Z4Rk5yOXNYUGw0TDRWVTlxNDJaQk8zR0dLWGZIbGZ6OWVKMzlkQ3Mxb2MrV3VmdlBlYnhUMUQrMmV5enNUWSs2N2dsVy94cDl1eisyZUtqOWNrZXZhYUFkYjdkUE43eDBmN1Y3TjcrcTgwdnJaN2wrTk9jN3oyVzZxM0d6L3pSZHEwL09qN0w4ZWs4dHNqanFkL0Q3ZnBHLysrTmhKQXo4ZHc0ZVd5aVBzNUhCRkt0bWYvYk5lODlEek83TnYvS1dCdWZiZHlTTGY0MGUzYi9iUEhSK2tUSDkyYXhRajd2K0dqL2FuWnZmMjg5OUxoWG85ZDhaLzVvTzhLL2JXeEk0alBUUHUrV2M3TFdUd1diWG1PNFNNT0NibFJJOVJEK211YkVpbDZXNWdraXIrVjhyZlZIK1R5Zk8rL3JOUE9meFVyc3UvbEgvdWo0aUxIazNLNytqci8wZkJXN2xkK3V2ell1UzN6MmZPUWYyZzBQK25tWWJhaWsrYlQxU3VPai9WZjEybWFHbDcxWG43Zi9iRHpTYSs5SzJkR1hqR2QzMlZqcjdmZ2o3U2ovMXJZYVgrSDRkQjVuMWU4UmZSMy9PTExwOVE0WFgrUUVkbDdINk5lKzlkK1NwZjduNi9oNU9XZDViQi92SXRXYithL1d1ektma1g3UHZwTFRLdDU2alBhYlBkKzdlWGIxczltdC9IYjl0WEZaNHFQMWlZeWY1OFBxMi83ZTg3MmJUMXV2TkQ3YWYxVlBxN05yejNKK05oN3B2VzNjcGZvcjQxN2o2YTBPQzcxZGY1UmRtbS9GdnoyZWd2VjgwUHF6MTBNSzJQVDZHeTdJN01tK3NlLzVveG9Ubm8yVEhkRDVyZWRucWYvMjJQdjVpOUpEKzdmMkhmL1I4ekhUUjhSN2pHYzJwSDZFZnpaN3RON3A4ZG56M1VwdmsyK2wzeUxOcDYxWEdoL3R2NnZYODBQYlYrdjM5cCtOdi9YYXhoZENmelQrTk9kN2o2MzBkdjFSZG0vLzZzY2ZxdWozaUw2T3Y0OXNlaEZDS21LOU1mcDBIbnZ5Vm9PbUZta3MycisxZS91ajQ5Rmo2M3FrK21qL2JQWm92ZFBqcytlN25lL05Zd1Y5clo0MFB0cmZXMDlxeis2L29qZmFyR3YxVjU2LzcveldlbHAvNzllcjF2OFVaZzJsN1BxcFlOUExsdHNYY2RMR3djeGZhOWY2cjhSWFA2NmkxVVBVYVhuOXJmVjM2cERZVVBQYThaZllaL3Fyc2F2Nk8vRWU0OTQ1cE5hcS91eThWTCtLM1ZwUEcrK2RMNXQrOXZ4UmFEY3MydXMyeTQvV2wrcEo0N1A0dDgySVhUMHJlNisrQ1ArMmtmVVdQeHRMOUhmRzMwZHBmVm85dEwvVTd1MS93dkhwUE02aTMwTlRqemxzZXRsdzYrS0wxR2JsZFN0NWJlOXNqS1VnOVQ1ZngwOXpMb3EyanMrTGJVZHZOWDRuMzh5dnB6bDd2YlQyWHA1Vi9aWDRpTEYxM081NXFYNFZlN1RlNmZIWjgxVm45M3FoTmhxOS9HajlYVDFwZkJaL2xKK1ZQZFA1dDQxejZ6Y2JTL1NsNDdmeksvWDFHbCtyZXFNRzNvNi8xRDZyRisxL0V0OU5vZWZyTWZKOVZhTTFlejE0MTdNRW0xNTR1R0Q3Ry9SR1cydlgrdmZpcXg5WDBlcWg2MFhxdlQzT2V0VFdLWTJmK2ZjZVMreVMvQ05OUkh6RUdLV2gwVi9Sa09oWHMxdnJhZU85ODJYVHo1N2ZDKzBHUVh1ZFZwc3hLSDJwbmpRK3EzL1BiNmJuWmY4MFkwLy90dEcwRWo4YmovUjN4KzNqMVhwR0dwSjRsTC9VN3UxLzZ2SHBQRWJvYXZSNm9QVmdzT2xGQ0ttSTVjYW15cVlwMjJiYjJ6NGJhK09yalZ2UThWSjlyWjYzM1ZwUEcrK2RMNXQrOXZ6ZXRKdlgwL0pyOWFYeDFmeXoyU1A4UjV2bFdmeU92bWE4azc5Rm92Y1dxL0dYMnIzOTBiZzNaQlpxSVVyWTlOSVJ2Y2lLenQveTZUeEcrVXRCMU5NZXE5S2JqL1NvMVVmVjEzc2NQVC92WSsreFZmek0zOE0rOHQrSmwraDVqRkV4VXQvVnZ3SHQrU3IyN1A3b2VHczliLzFiUUY5SDZlWkttaCt0UDlOcjQ2WCtzM3hhZjIzOUdleHRvMmRGcjIyK1NQVTE4YlB4bTc1bXZOTW8rejd1NkkvaVYrN3kwZHBuK1pIKzZPUHovRDFYN3pwNlJPbGxxMmZyeUtiWEh0R0x0ZWo4cEE3STE4cWJsa1JmRzcrcWlkVEsvcmYyNlR5MmlwLzVXOXRIUHEzL1NyeEdEejIyMXBIR28vU3IyYTMxdFBHWjNqTWo5TFBuOThMcW0vL1Y2N2ViSDYzZjA1dmRvYUxOaC9MZnJUK1RmYlNSN2VsSnpyL3BhK0puNHplZG5mRnU0K3Z0dkVTL0Z6L3puOVd6YXAvbFIvbExtVFZnM3ZKL1gzZUxtbnIwWHBPYTkxMk5Yclo2dG1EVFMwNzBnaW82L3dyb2piU1czWHJhNDJwOE5ucnprUjYxK3VqNnRQSFc5WGtmdGZWSzQyZithSHZ2OGNoL0ZJL1FzeGhyWXpYNk0zK3AvZ24yN1A3b2VHczliLzFUUVY4MzZXWkRtaCt0djdLQjF2alA4bW45dGZWbnNMY05neDI5VHpPVzZrdmlaK01WZmNuNDA1eGZyYWQ5TE5YdnhjLzhVZlpaZnBTLzlMZzZGK24xc2pyMmlOTExWby80eUtZWElZVDhUY1dObVBkbTJic1pvZlgzMXN1V1g2cVA5cTlteis2UGpyZlc4OVluTXRyTmRYWjlxWjQyUHpxZnQ1NkZmYlI1bGVwcDlWZmlaMk9KL2tyK04wMUo0MHVqdjFNUDB1Nzk5eW5SN3pXd2V2bG4xOEdTeU56SHdhWVgwZkRwUFBiU2wrYlgxdnNXTHoxS2MybVB1MmoxcThTUGRCSFB0L2RSVzY4MGZ1YVB0dmNlai94SDhRZzl4TGgzYmpkV29vL3kxK2g1MktXK3UrL1pWdjdaNHFQMTBVVFZtMjFETTdzTzJuclIrcTNlTEY2Ylg1dXY5ZC9SbXpVaU5QbFc5TnRHRFZwUG83K3ExemFIa1BydFhTWnYrZDd1SUVMcHoveDM5Q1QybGZ4YWYrbXgxWCs3VnIxemIzYnJZNjlXNlh4MzY3ZUt0OVlid3FZWElibEFMcngzdExRYngwcnh1em15NDcwWjlteG05QjZQOUZiamQvUXN4bWcvNmZXMzlxOW16KzZQanJmVzg5YlBUcGI1UysvSWlOYWYzV0dDem8vSzF6WU5kdlRlZkxUNUpQcWpqU2hDYjBkZnF0ZTdMaWo5OW55ck8ycSs3T3FQbWptOXVCVzlWZnRNWDFvUGlwMjVySjZ6UXB0TFc3OUYvSTdQam04WE5yMElncFdOcUtXK05MKzIzcy9tY1RYZnJ2NWJ2aDIwK2xYaVYvVlJldGJIM21PcitKbS9oMzNrdnhNdjBiTVk3OFpvOU5IK0dqMFB1OVJYK241cTdaOHRQbG9malZlOVhwdW5WV2J6MXRhTDFtLzFWalpZbXZ6YWZMM21pa1J2MXNqUTVGdlJIeld5RUhvYS9WMjlUelBXNlBjYVVMMTh2WmhkL1pIUGlyMm50MnBmemEvMWx4NUg4MzBXN1crKzFrZHRQbTM5VnZIV2VsMytEeUZDQ0NHa1BPak51b2Y5MDR5MThSSTlpL0dzbnRHY3BQb3I4UkovaEo2bC9jMS9acGZxV2Zwbmk0L1dSK05kTDY4UFZ0ODdIdTIvb21lZFQ1TWZvYWZWMStnaDlEV2YzMXI5RmIyUkhmMzV1cEpmNjArSWlPcE5yOVArUUxUenNiNGVvdzJoUnp4YTM3cWVsWHp0MFRyMzdLalZ5eHEvT245MFBkYkh0eG9RZWlqL244ZWFlSWw5TnRiR1p4bTNXTWZQL0gvT2ZmK24xVVBhZjN4NjlWbnI3ZWdqOHlIaW8vV2wrYVgvUlZHbHpoODhYa2ZhZU8zZlNhVC9ySDdwL0hiZSt6WDVkL1MwL3Q1NmlQSDM4Zk5pMStnaDhrbjBJdnlseDdkY0VydEZQU3RvOWF6eWU4V3Y2aTNwVi8zZkd6Tjg4Q05CdlFoSWJhSVhrTm9GVk1aNHpUVkZMQ2dyc3Z1aE5yUDEvS1NMOHBsOU50YkdaeHUzV01mUC9MMzFwUFpvUGExL3R2aG9mVFJlOWU3Kzd4cFIxM1AwK3oxby9SMU5iWDNTL0dqL1dmM1MrVW55ZlFENU5YcGEvOWtZcmFjZHY1M3ZQWmJvb2ZLdDZrWDVvMERQRzVsYm12L05kL1ozb01udkVhK0plZld0ZUtkWHRRWFVqT3dMMWxuT25memFlTFMrZFQyOWZLak85MjYrM2Z6VjRsZm5qNjdIK3RpckZhV0g5Si9GN09pM2oyZGpiWHpHY1l0MS9Nei81OXozZjFvOXBQM0hwMWVmdGQ2T1BqSWZJajVhWDVwZitsL1dPcVB4ZU4xbzQ3Vi9GNUgrcy9xbDg5dDVyOWZrMzlIVCtudnJvY2J0NDgvRVoxVnZsRU9TVDJyMzl0ODk5bGkxZTlXem0xOGFyODN2RmIrcU45V3YyUFFpaEJDQ3gzclIzOGFnRmlLclkyMTh0bkdMZGZ5Sy95Z0cvWHp2MkNXdldiU2VWTjhpbjNheEdhbS9Xc09wWkxpKzMxalVnOVRicVMrVC84cjdxZVY3NXM3N3VWUlA2Kyt0aHh6dlBIK2ExMXZFZTBlbTl5dENybXQ2M2ZZSFdHMitzemRvNnpmdzZBOElEVjZkOUt6eFZ2bkUzeVE0NW50N3ZXcVBVcjJaLzZ6ZTFmaFZ1MWEveXJqRk9oN3RuODF1cmFlTjk4NlhUWCtGRERWNGtHMmU2SHFpOWFyNVI5cG5uL01yTWVqUE5tczlxL0hPMm1UbCtrdjhOWGJFV2xLaVgrM1lReHUvcW9meXp4WXYwcS82bTE1U3NpMFNyTGx0dmpjalhaQlk2M25IVythemlLM3d0NWx0UTQ1ZXhHcmpzNDFick9QUi90bnMxbnJhZU85ODJmU2xaS3RuRisxdlhxRkIxeE90VjgzZjJ5NzlqU3lKM282L3Q1N0hiM3p0K3MvaXZZbk9uNUczYXlLNVRpdStzNy9UMDMvemE2cHh3NTFlR1JZSG5wd3czMC9uOGFyZE9uODIwSjN5Nk02OU5ONHEzK3k0aXliZjZPOUJlK3c5M3ZXZjFTdU5YOUVmamJYeEdjY3QxdkZvLzJ4MmF6MXR2SGUrYlBwU3N0V2pJZHRjMFBWRTYxWHo5N1pINjNsL05ucU9wV3VUMmJwSzZvK3k3NjRscGZwVmp6MjA4YXQ2S1A5czhjdjZOelM5eUQ3WkZsbUVrRHBFTnlqUThkSGpHZGFiZ3BuL2pPaE5uSlRiR2tTRTNFNTBJOHNiNy9kd3RIKzF6M3dwMFovaDNwKzVoSmp5UjlQcjEzLzVBcjZjMVc4WkVIb2VhUE92Zk5OZ0Jicnp2NXJQS3g3MXpZQjNQcXR2ZWlRMVdPV1h2dDRsL2lqN0xQL3FXQnNmc1ZnZVBZY1pHbDZTK3J6dHF6NVdlb2hZNy9mb2JQcFNzdFdESU51Y3NxMURFSHFaR2wvUjc0dlM5M20wM29xLzVMTUxvYWNaN3p3ZjJyV1MxOXJzelQ2NjNpdHJWY24xOGo3dW90VkR4V2ZOaDg3L0IvOTVIamE3eUJTK1B2eEFiOHdrR3RvRm9zVUNLMU0rTGJmK0hYa3MzRWYrNlBqb2NZdTMzc3pmVzA5cWo5YlQrbWVMajlhM0JsVS82amR1b3E3bjdEZWRxdXRsK28ydWJ6NGcrNndleTkvc1d0SFQrTS9HYUQxTi9oV2tlbHAvdFAwR2RxN0I3SFhwK1J0YUdmT2g4Ly9GLzdIaFJWNFlOUlk4R2lOb1VJMmR0MDZ6eFh4bTN6Q2djM3B2bXFwK1U2RTlvdERrbHpUNlZ1TlgvYlgyV2Y0VmYzUzg5N2pGVzIvbTc2MG50VWZyYWYyenhVZnJXNE9zbjljaXQxNzAzM3IwZTEvMGUzMjJ6enJrV0xMdWt1aXRybDJzMTJZcmE5NFZmOG1hZVVjUGZkeEZxNGVLejVvUG5mODMvRTB2UWdnaE4yQzl5ZEl1d3RINXRYcGEvK3FiZkVJSXlZVDFlMjYxTHdHOFAzUFJSSCtHRTNJVmJIcmRoZmFiQ1BJbkZ0ODBXR0gxVFlXMWY1VnZNbmIxUFY4djJtL2FFTi9zU2V5Vy9xanJ0enZlcmNGS1h4cS9zem5TYnFpOE4yVFpObmpaNHFQMXJiR29uOWNrdDE3MDM3ejBjMjFYWStTcjBVZDhqbWo5c3plK0pQWHV2QjYwNnk2VS9XMXRLSm5QeXRvMHczT0xYcXRIN1gxMjhjN1gwMXU2WHY4Qkp5YzV5ZkRHUU9aNEw3TFJHMyswdjhRV2xVK2pUMkt3M21oWkw4TFIrdEo0clg4MmU3U2UxaDhkYjYyWExaODNXZWEzKzVzOHUvVkgvNGJYNm55bDhidisydC9nMHRobjlhem9lLzVtbDlSL05vNEdYVisyK2QyQzVMcXYrTTVlOTVhLzJiWHpHdkxPTjlKYnN2Rk9yL094YUJTUVAxbnQ5S08rQ1pDQ3p1ZTE2ZlArcHNQcStVQzlQbERmZEduMWQvMTM3WmIrNk1ZdkcxNjE3TkY2V245MHZMVmV0bnczVS8yNXpmNjNsZTI5Q1czUDdvLys3TlVpcVUrNnJsbUpqN0JMMXRRcjhWNTdKaW5vZXFQMlFMdDQ1K3ZwVGE4WG0xNkVFRUl5RXYzQkhiMHB0RzZZRVVJSUlWNUViNDVuK3Q1aktmd01KMFFCbTE3M2N1T2JwL1lPbVVwVSsxWTEremNocS9rOXY0bXkvbVpNODgwaitwdEVoTDhtUHR2aXUzZHVWVjhhYitFZmJZL1cwL3FqNDYzMXN1VWo5Wi9qN0g5ajJkNmpNdFF6aWtGOFRvMVkwZmNjUzljcDJuajB1a3hUejl2YVZMTk9SUit0eVBZZXBQWFg0bnE5K1p0ZWQ4TEY1Ym1nRzN2b0QxaWt2OFMybTI4bmgwYWYvRTMweGlaYncwdDdQYUlYVGRudHAvbFgxME9UdGI2bzMrUlp2UjZvK25yNXRMOHhadldiWGFoOHU3L3hoZGJMVU04SDZDOWxSZDk2TEFVNWY3S0d4VFgvMXR6Umw4WmIrMnV4enZlWFB1LzB1Zy92RFYxRzBJMmhiRVJ2WXJ6OGQ3K1pRVFZGb3I0cGFwSFVvMjMwSVJxTEdqdkNYeE52L2JmRmhsZXMvVFQvNm5wb010ZVh1YmJuOFcvK1o0LzNmbTlFNjBYWGcvYVhvdjNzMVl5bDZ4SnRQSG9kaHFwSHMyWmUwZE1lcmFqK1hvWEc3WHF6NlVVSUlZUVFRZ2docENyOFVwOFEwb1ZOTDFLWjArL1lpdVMwNnhuOUxYSUd2Ty80UWxPOWZtdXlmM3VvMVVQZm1UQWoyN2VwMGZQejFrT1R2YjdueVYvamFYZEFhT09qNy9ieUp2cE8ycFg0YW8wdnJtdGtlTS9YK2k2dzdIZFZSYTlUb1BBM3ZRZ2gzNXoyQWNvRkJUbWQ3QnM5clI2YlhUcWlydythNlB6V29PWm45WHNzdmZxeS9PYlhUN3ozYjRSRi9jYVhOK2o2TFo2dnoyUk15QXFqMXczaU5mV3Q0ZkVhbGVhejl2Zm13enU5eUFtd01ZSGx0R3VZYmRNWVRmVkdZUFg2a2JEaGhTVmJBeXZiZTFmMDMwdDAva3BrdjRQQVdqLzdleVB2K3RMNXorS3ozL0hGZFl5TXlQbnliaTliZnpmWTlDS0VFRUlJSVlRUVFnZ2h4OEdtRnlFRVFkck9QdWx5K2plRnA4OXZSclk1UjljVG5aL280UE1uSi9zZEJOWmtxd2ROOWJ2RmlEK3pkWkhXcnZWSHg1L09hZGZFZEQ1c2VoRkNOUEFEaVpCY2ZKNWNmNHZSOVVUbkp6cjQvT253dm43Wm5xOXM5YUNaemUvMCtSTnlLNmZ0djh6bnc2WVhJVVRMQ1crMk4zUGFCMmZMNmZQN0p0djhvdXVKems5MDhQbkR3YnUrem9aM2ZaRVJ2TVByWEU2N1BtYnpZZE9MRUVJSUlZUVFRZ2doaEJ3SG0xNkVFQzNaL2xsYVFrZ09vdDhib3ZNVEhYeitjUEJhbnMzcytlWHpUelQ4Nmp3bThmRDVXT1EvMFFVUVFrcno2L24zVnRUdng0UVE4anovTHNpaTNodWk4eE1kZlA1MGNFTjBObXgyRVhJbmJFUUs0WjFlaEJBRWZNTWxoSXlJZm8rSXprOTA4UG1UdzJ0Mk5teDRFVy9ZYU1rRm53TUJiSG9SUWdnaGhCQkNDQ0dFa09OZzA0c1EwbkxhTndmYStaeDJQVnFrMzl4RmY5T0hyTGY2YzZ1ZGo3Vy9Wcy83VGdicjE0UDM5YTUyZmJMbnIwVDB0Y3IyMnN2MjNoajkvRmdUL1Y2WC9mcHExMUhvZFJ0NlhXY3h2L1lZUmJiM051dDgyZXRiaHIvcFJRajU1clRmNk5MTzU3VHJRYzU3SHR2NVNIOER5ZHBmcTZlMW8rdngxdGZXWTNWOVdyeitwcUx6UnhPOTRXdkoxaWpXeG1menIwWjBzd3VoU2NnYjJScUQxdm15MXlmVzU1MWVoSkEzVGxzMFpMdGpJZ1BaUHdDMStVKyt3NnNGc2ZDUDNyenhyaStzUHpvK1dqOTdmZyt5elRIN2F5cmJlMkMyNXc5Tmh2ZTBhdGVZZDN5dHhiL2Q1Ulc5RHMyb2g4Nlh2VDRSYkhvUlFnaTVnV3FMWVNtbno0OFFRZ2pwd2M5QVFrZ1hOcjNJQ1ZTN1k4V2E2RGxsLzdZVUZaL2w5d1ZtYUw4cDgvNG0wZnZ2T2RNZFliUDgxZTk4eUc2MzF0UEdSNy8zUmV0bnoyOUp0cmxsZnkxRnY5ZForMmUzby8zUnI0ZkljWVU3dXJLdDAxYjBySThvc3IrM2FVbjdXY1hmOUNMa0xINDlzYjlCSmMxdjdXOFpMN0dST2tRL2oyMyt0L0h6K1AzR0U5by91MzFYcjhYNittcno3Y1pINisvbUoydFUyeUJsMzBDeTJhWDMxenpISzNyU0JwdTJBVWJxWWRXb3M0eEhOeHF6NVp2eFZ6MjgwNHRVSnZzYlFDVFI4NHRlR0hyRlczMFRoR0RsbXpCcHZNWS8yemVIby9qbzUzT2xudXFidmV6MjdQN1o0cVAxaVI0MnZITDdaN2RiK0ovVzhNclcrS2kyYnV2cFdSOVJaSC9QMHBMdGMvNlBldGowSW9RUVFwSi9XTCtNQ1NHRWtGT3hiamhvUDJONXh4Y2hoV0RUNjN6NEp1eVA5emNITS9odDZsbzg2dm54K3VacDVmVWwrZVp0Tlg3WDM4S084SjhoMGZOZUJGdC9hNDMycjJiUDdwOHRQbHFmN01OMVNXNy9hbmEwdnpRZStYcjIrTnNZMVQ5YjUwajl2ZXlqTmZXS2Y5U2VTWXZWbnNMS3YxcStYdnowZXZNM3ZlN2cxelAralJnU2c4Zno4SjFqSjU5M3ZMWC9LRjVpMjlFakdLVFhHUDJjek41UGQ4YVBva2F0dm9kL0JYc0wramZCcFBxci9sN3hNNnoxVWZtcmsyMERpSzRuV3ErYWYwYjdLRWJxdnhOZnJlR2x6Wm50UGVGV3BLOTdpZDVLdk5TL1dyNVIvSktOZDNyZGcrV0hBdm1Iek45Y1pPbkVaL0h2eGFPL21ZaytydFM0R28vd1I5a1Ivak1rZXRweDc5d3FXbjJQalV0MnU3V2VOajc2UFR4YVAzdCtEN0xOTWJwQmhkYXI1cC9SZm5MRHkrUHZiNVJUT24vdmRkbjN1YmUxb2NSL05UNGJWbnNKSzh4Zmc3Y0FBQ0FBU1VSQlZQOXErWHJ4UzllYlRhKzdxUENHUVFnaGIzaC9HTS8wTEJwZkdyVDYwZGVYRUVKSVhhSTN6S2Q5SnZFem1SQWdiSHFSNThIZklTSFI5d0NkSC8xTmhPU2JEZ1JhZlZTOHRULzZteGFyNTBQTDZ1dEgrODBiMm4vSDd1MmZmZHhpSFkvMnoyYTMxdFBHUjMrckdxMmZQYjhsMmVabTNiVDMxcXZtbjgzdTdhKzlucG5HczNXS3RUL0tQbG9qUy8xMzRxT1BxMWpwYWZObnphZk4veHYrcGhkNTQ5ZHp6KzlqUkNPNTFvam5aYVN4b28rTXQvYmZxYzlhajhpUlhtZXRmNFh4ODZ5L0xoSHhPLzdmUlB3RzJDei95QWVocDlIZjhVZkhyK3FoOUxQbnIwcjA5VURuOTk0d1pmRDNibUFoN1NzTkdxbS81QnJ2NkhtUFoxajdFejJJdjJPTm5qWi94bnphL0gvQk83M3VadlFDUXJ4cHFsK2d5ZksvNmFFNzE2ak8vMjQrNzNocmYrdm5KNUtWMTZQazlTUjlmU1A4ViszZS90bkh2WE5XOFR2K0dqMkVYZXFMMXRQR2VHL3V2ZldxNWE5STlEWEw5aHJNdWs3UitHUzJXM3p1YU4rbm96KzdSMk5wdldoL2pmMXQ3WWZ3WDQyUFBxNWlwYWZObnpXZk52OGZzT2xGdm9sZUlCRkN5QS9lRzQ1cTR4bm9lSzEvOU9kTHRnMDRJWVNNeU56UVdyR2ovZEViNW16akdkNWZuQkJ5RlAvMytYL0gvMUdjUHI4V2kvbEtPL0hXK2F6cjBYNFRZUTM2bTRKVmZXbThWVDd0L0tPK3ViSDRaZ241elZoUHo4cC9SYy9ULzRSeGkzWDh6TjliYjBhMlRSemFIeDF2clZjdGZ5V2lyMVcyMTE2MnYxWHI5NzVzOXVqUHFrcmozYlVPU2w5cW4rVkgrZStza1Myd3JrZXJaNVZmR3IrTDJmUDVuK2Q1bnAvRzE2Ly9IdnY3TkQ4WDdOVDV0ZHcyMzV2NDlkaitCdGdvWmtYdjIwZnF2MkxUemg5OS9mNS9lMitiSkRtUDh3Q3FOL2F3Yy84TGVIL001cnh1dFNTU0l2Z2htWWlZc0dVQ0lPM0t6TEpST2Yzc1hPT3ZnN3BtZmQyYmoxNTc5RytMbmx6OUcxcSt0eDhGYno5dlBscHY3U2Z0K1laWC8xc1JjZjNRUFZFUFZhZndiNnRyK1doOXRuVVBLWi9Tbyt0ZmdlWTZjTFFTZnlvNFJQZVg2bmV1bGJZL2liLys3NDMxcmEvcmdMd3g4TGgyVkQvcmVVYis4S1FaQk8xZkFuYjlwWHFyZnRyelIxOC9yaDk2eTVscDEwLzZmcER3dVhWdnZ0VzZoNFcvNUliQitpSEYyNCtDdDU4M0g2MjM5c3ZhODNiYzhIUDBmbTlFODIrcm8zODNhdlZaMXp2M0xwejdBdFM5MmFpKzZxL2w3OXdiVzN6ZVdkeXI3L2hMOWRyK1V2MHV0UDJYcUgvVHExQW9GQW9lOEw0NWx2S3RneTdyZWFnWk1nWmYxTHlhT3RWZldzL09IK21STjR3M0JDWmZodmUxdEhqOWFmeDI5Slo4emp3bjEwZm5wK1ZuK3gzdmZRK0J2dWRBMXd1RjFEZ3g5S28zWFR5MFNicFhFcy8xdDU0bkd1amsvTlMvUEtEL2NwSjkyKy8zeDZSNkxWOWE5K2FqMSsvKzcvOVo5dGYyRzNscCtKejZhbDVFWFR2ZlNmeVpCL2Y2Y0x5OGdaei9TL0MrYnVoK1dqK0VIc21Yem1QOVdZYXVjejZudFh6cFBLZXV0ZmN1MXZkbTBycVd2L0taQWVFdjZUZnFqZkwzbXMrcVAzcitYZi9uLzFVMmlzTHZCT3JmMGlrVTFuaWE3dC9vMHZwcCsxdnFPZHlkYTNRYnBOZUE0a3ZyM256a212T2FRcXpib0k5VS80Ykh2OEZGL1p0TjJqclZYMUxQenFjODN0anhxMy9UNng1NFh6OTBQOVFEa3FWR3dwYyt3SjlXSDlXMGZPazhwNjE3b1BYZWRTMC9BeER2VTZuVzgzUEVvajk2ZnJYbXhHOTZ2WEhpRytka1BKTjlMejNhMzNxZVRQQksxcTM2VyttMTgyZmZqczVoUjQvaVMrdmVmSXYxNDlEdjNXZW4zOGhMdytmVVYvTWk2dHI1VHVMUFBMalhoK1BsRGVUOFg0YjNkVVQzMC9vaDlFaStkQjdyenpaMG5mTzVyZVZMNXpseHJiMTNzYjQzazlhMS9KRmU4djdSYnJsQSszdk5aOVVmUGYrdS85UGErYUZYb1ZBb0ZQaVEvSUt4dU5tWDFDMzRxeHVtRTllcmM3YlFTL2daNjlUODB2ZEhKcjYxSDNxZTAvcWZCdS9yZGR2cjFlTDk2dTFuV1IvTkYvazdmdlQ3UGNQdmFPNTY1K2V0MVh2WHRmeENRWVVLdmVLQlNqa2pzWHFRek9odjVSZTkzUVhhWDZyWDlrZGZyK2lmbzhWMjlKcm5YQitKanVKTDYwZytOY09wNjkreDkvOHM5VHY4VFBVZlp6WS9weDdObCtxMS9hM25RZmVYL2k4THNwK1hkYjlzcjJzTHZyY2Zzczc1M0pUNmFmaXplYmp6WlZyUDVwOXh0SHJ2dXBhUDFsdHRaempWandzci9lNzVUSEhxditsMUczNC93TjEvTzBpckw5eUJwMkgvamE0ZDdvb3pxbW43NzV5emxWOUd2TTluOTl5a09vb3ZyV3Y0blBPbittVmN0OFovbnlIME8vdzNvdXM5NXczTytlMzRXZkc1ZW0xL3JuN1hUd3FyejJXcmViUEErL3pRL2JSKzNub09YK0tKOExPc2oycFNQd1IvNXNIaFJxOUh4MmY3Q1AxS1oxSFg4dEY2Qyt5OER6TDdhVDkzMEorREVHMTkweXNYVHZzZ2tIeW9adkQzOEl2ZTdnTHRMOVZyKzZPdlYvVFBFZmw2ZUpSNkpGOWExL0ovK3hwOXh2WHYyUHQvbHZvZGZxYjZqek9ibjFPUDVrdjEydjdXODZEN1MvK1hGZG5QMDdwZnR0ZTVCZC9iRDFubmZJNUsvVFQ4Zmc3cGZGblc3MjEvUGhiNmZtdGQxL0xSZXZSMmhsUDl1TERTNzU3UEV2Vk5yMEtoVUxnVFQ5TjlPK0wzeTBYNkRRL1VmNVdQbXAvaTcrZ2xmaFpyYXA3M3VvZlVuNk5IOHlQcjBYNWFmamE5dFo4MXNzMnJ1cGwzZ1BWOFduOXZQWnJ2N2JkVFgybXMvVGg2amQrTy8ycTkwMC9TWDZxUGVMMGcrV2g5NFlPbzBFc083WVBrRi9DK1JwenJKZVZMOVNqL2ZydnJaNDNadk5RVzdXODEzNjdlMmkvYnRrMzJPZHNtMUZIOG5mcHFmZzVmb3QveHMxalA1aG10VzNkYzZzL1JvL2taNmoyOC9iUjhhMzBQdEI4Rjc5K25YMzE0OGo1dmREK3BuN1kvdXArM0g3cnU1Y2M5dnV1SDhuOFkreWdkZXQrcnJ1V2o5ZFpiOUZ3elJQbFo2U2xzWDhjS3ZmYnd1NERad281Q1lmUVFpdFJLL0VkY3pYd0l2YlZmUnV6K3pLU3ZCK3JudlZOZmNUaDhTdCtVZnFoMWErTnIwODgzNCszNGUvSXoxSHQ0KzJuNVhucHJQMVEvTGJKKzdudWQveTZzNTBNOUVIbnAwWHh2djUzNlNvUHltL2x3dUx1Y1hTM0hTK0toOWQrWng2T3U1YVAxbGtEUEkzMGZXdnRaNkMwMGY2RkNMeDIrOE1Bc0FmcUJXZHZQd3IvZlpzVnNYbXFMOWtmTjF5Yjdtdk5FK21YZFNxLzNqOXRBZkVTOUtma3JQY0lQc1g3UDhRTm5Yb1MvQno5RHZZZTNuNVp2cmUrQjlxUGcvZnRVZlFOOUNieXZBN3FmMUUvYkg5M1AydzlkdC9aRDY3MzgrNjNXVCt0UDhiM3JXajVhajk3TzlyWG4xeVBLejBwUFFYVWRLL1FxRkFvbllQU1FuY2t2STM0Zjl0enpsRjRUeWg5ZHArWWI4VmQ2aEI5eVBlcFBCVnRhZjA5K3RucTBuNWFQMWx2N1pldjNkV2dmUHFMN1NmMVFEMXNvdnJjZnV1N2h0L0tnOUJ3L3BEL241eW54MFBydnpJT3NaMzkvV2tMNmN5ZzRvVUl2UEt3ZnByL3dzRTdoZlExRzE0T3F6L3o2TFZmUDlZdmVXcytmM1cvbUgvMXpzZGkyMXpsS3JzZG9mOGZmb3I2YXIrZHo5Qm8vaTNYcmpsUHp2by90K252eXM5UjdlUHRwK2RiNkhtZy9DdEorV21qblJjSDd2S1d3bmsvcjc2MUg4N2wrS041dVhYb2M1V2ZOUStrZXhqNUtoOTVIMWFXOFhUNWFqOXA2ellIMjEvck5nSjV2R3hWNjJhQi9LRGpOdjNBbm5zWjd3Tmw5WFkyMG1meTRQVTdDYi81KzI5cit1YTEwbEw5MWZjWHBQeGM1ZXFtZjVab3pINlhqK2tjY3oxS1A5dFB5cmZROTBINFVvajZIWVRmVWg4TDcvTkg5cEg3YS91aCtYRDhVYjdjdVBZNzA0eHpUK08xd0pHdXBWdW9oMVZ1OVJyajlVWHlPSGg2Y0VMMGZwNTdSbjZNY1BYSkdpRmVGWHJhd2ZxQSsvWUZkQ3NRRE04VWZoUWVhK2JKdHBlZUM4cy9pTjN1TlJQOWNFT2Z4M2pibDlhYjZ6Znc5Nm0zQjM5RkwvRHpXMUh6dlkyOUkvQ1Y2TkQrcTNzUGJUOHUzMXZkQSsxR1E5dE5DTzY4VnZLK0RGTmJ6YWYyOTlXaSt0bTdkTDlwUHVrYjdlYTM3cmJXZTRrdnIzdnlSbm5NTXRmWHFZOVZQNnpjRDhuelZxTkNyVUNoOEVVOGJoMThuNFIwMlBOMVc2M2RDZmJTbWdsSktML0ZIckRYejlKRDZqL1NlZk85NnRKK1duMDF2N1dlTmJQTkNiKzROWUQyZjF0OWJqK1pyNjliOW92MDQrcFduMUM5NlBjSXNvT0RvclgrZUZLejVNNzFKZURMcFpkMkg2cDNSTHhVcTlQb1hwejRBWjRZMFlMQU9KSGJub2JaVzg2TEJQUi9wRnUzdk1lOW8vNFJ0QTg5TitXV3JqL2l6Zlk1K3h4K3gzcDNualYzL2tkNkMzK3VpNmozdkIrNzU3ZnBwK2RuMDFuN2EvbExjY3BNZmZSN28vbG8vYnoyWGorSjUrY3pxMHVNb1AydGVwclYwZjFaRDhhVjFiNzYzbjdVdnA2K0ZYdyswSDhwZnZLM1FhNHpmQmNvZVhoUUtVanpOOW5XTjlyZWM5K2Y5ZnI5Ylh4OHAzak1pQWxhcFg3WjZJL2dyejVHZVdsUCt1K3ZXeHVjcW1VL3I3M1U4U3gzdDQ4WFBwcmYyMiswdlJhYlArVGQyejhjTDF2TnAvYjMxWEQ2SzUrVXpxMHVQby93a2VzNnhrOWFjYytkY0x5U2ZVL2ZtNy9naHR2MHhENkI3Y2Q5SEdqK2sveFlxOUZvajJ3UHdhWkErb0dzZjZEM21vYmFuZ0hzK2t2UGV1VjVlZnRuNjdjejEzalludjVhc3p1RzN4dGNqL0hmVzd6NC83TTZyOWJmaTk4aFMvMkUyLzZ3dTlkUHlzK210L2JUOXBYQy80WFpDOUhtaCsydjl2UFVVMzl2UHUyN3RoOWFmdXU2MzNueHAzWnZQOGN2b3RkTVQ1VGNDMmcvbHY3V3QwS3RRS0NEd05Hem85L1pEZTJmb3g4SHZ3eG9WcmtyOTN2d01kUzJmczE1ZFc0VC9lNTNOSDgyL3JlN056NmEzOWp1dGZ6WklIemF5OTlmNmVldTVENDllZnQ1MWF6KzBudU9QOUxTWUw1SXZyWHZ6dVg2b3JTZFdyNnZDQXYvY0xEei9jYm1CUVBhUWVxSDVPL1dWUnN1bjFqdWExWHFYaTloSDFaSDhMMjI1eHhEKzN1Y1RmWDFuKzE1K0ZOKzdydVZ6L2JqN2lMWDArSzUvRko5YnQvSzE4dkhpYTNVb3ZiWGZhZjFQUWRURGtGWGZxQkRNNnVFY3hjdGFseDZmMWJYK3UyR1NWZUJsNGN2MVIvT2xkVy8remR2WnZrVWZyL013UDUvL3A4WGdmVkpmaFBUODBkY0w5VXVoOEcyTVhoY1dyOVBSaDZBRnZINkpjTGI5UGhkYVA0cnZYZGZ5cFg2ckdYZjhWMnZwOFYzL0tENjNidVZyNWVQRjErcFFlbXUvMC9wblI5VDFzZW9iOWZxM2VuOTdmVjVGMVZHZjgxRy9MMGZIdGV2UmNjVDloTlIvaC84QTYxUi9CSCtsUHhtajYyeDVqdGJYai9yNW11Q2Z2NWc1ZmROck9ZT3hIczFIMTdWOGlkK3VGL3JiRmFodmQxaC91OFg2MnpnbmJ2OXM2bmI2alBZOStrVnMwVnFwUGxOZHkvZjIyMTMzOFBaRDg3MzlLSGo3ZWZQUmVtdS8wL3FmQ3UrSHY0aUhKVXQ5TlArMnVqZC9ONkJDKzgrQ2lpaC9Ebi9FUWRVNU5TbC9oM1BTZGhWODNkTFB0RS85bTE3Znh0UCt2cEdrMW9WQ0ZONnZSWS9YNWE5SDFIWjM1cWJ3ZStzejFMVjhiNzlzODBqOTBIeHZQd3JlZnQ1OHRON2E3N1QrcCtHaEtVZjEwL3BMOWRIODIrcmVmT25hMjcvbmVNL1A1ZmRiVkgzV1g4dm42ay9DNm5WeVF6ODNWT2gxUHl3Q2dsVUFzZE5QR21oUWZHNTlGQXdnK0JTc0F4T3ZyZmY1dE1sK2JmOEx6WFdoOU41MUxkL2JEN0h1NGUySDVudjdVZkQyOCthajlkWitwL1UvRmQ3WHk3cWZ4bjlISzlXZytiZlZ2Zm5TdGFXL2RIL1huK3RIOGIzcldqNWFuMlhyZlI3ZS9keCtSMVhvOVEzMER4a1cvbGJlaGR6dy9Obi9lcjFmejdlLzl0N25MQWtFZC9WdDA1OWJwL3diaUQ5YmMrZUxXUGZ3OWtQenZmMG9lUHQ1ODlGNmE3L1QrcDhHdHdjSnAzNDcvcHFacEZvMC83YTZOMSs2dHZhZkJRcGN6czc1U1B3b3ZsVjlGWHhJK1R2NnFDQkdNb2ZIVE43OVp2MU5VYUhYdHpCNjZOdlY5MTQ3M3RRRHM1Uy9VeDg5VE8veUtYRDhUdGxHbjA5MC80anpYRzBiU0QvalUvN2NPdVdQNHMvVzNQa2kxajI4L2RCOGJ6OEszbjdlZkxUZTJ1KzAvcWZDKzNwWjk1UDZhK2V4N2tmeGI2dDc4NlZyYS8vWnV0OTYrMUY4aXpybjJDNWZ3OVZvTEx3dDV4ajE4T2czZTcyWW9rS3ZnZ1pQKzc4YjBjSzM4UDdaUjd3T292dDc0QjBPUE1RV29WL3hLWDlPbmZKSDhyWHpSYXpSODBuOTBIeHZQd3JlZnQ1OHRON2E3N1QrcDhIMVljS2huOVJmTzQ5MVA0cC9XOTJiTDExYiszdjNsL3BSZktzNk4velFoaVdad3BpZGNNa1NvM211eEQ4M0QvVmZieFR6TGVvclRWOUQ2elZyenY2T1puZWZXMGZ5RVZ5SlgrUjJ0ditWL3BiYjJiNlZIczN2OTczNWFMM0h1b2UzSDVyUHFWdDRhcmhvUHcxL1Y0UFVXL3VkMXY4MFJEekFlRDBzV21wMnRSYjhMT0VFcW83a2oyclp3aWZKZWhSMGVQcFJmSFRkbTc4VGVGbjV6L2FqdHRubU1kbldONzF5NHZjRDJyM0IwK3JSZUZxZVdRbzQvSDZ1NzllYjU4OTYxVis3UmN5azdjK1pSYXBIOHh1elR2bWorTE0xZDc3SWRROXZQelNmVTM4Nnp1am5yYWxUL1djY2xKK0dMNTNIUW0vdHArM2Y0MnYzR2RUMThJVEZMQnJQSGExVVk4bW51S2ZWRWZ5VkI2Vkh6Mk8xN3JmZWZoVGZxdDRmUS9GWGVnbzcvcHl0WmlZVXNzM2pnbjl1RU9xYlhtSytkOTM3MndLYTlhekc0Vmp3KzdvMzM5dlBjenZiaitnZjdZV1lROHYxNUhQcWxEK1NyNTB2YXQzRDJ3L05QNjBlN1pkZGIrMm5SYlo1dkpEdFFRVTlqOVl2VTVCbHdUK3RqZzZidFBwTTRkY29mUEQwby9pV2RVNU55dC9oV0dnNXdWZkVOdHM4NXR2NnBsZkJFay83N28zbzEvRCtXVWY4M0g4OXRkdlc5dWYvZmJpaTV0RDA4K0JMNnBUL2JOMTdVL3pabWpOZjlMcUh0eCthZjFvOTJpKzczdHBQaTJ6eldPT2hLYTVBejZQMWsrcFA0NTlXMS9MUmVtcy95YnAvUUVmNmo3dzFmS3Q2RHhTZnE2ZkE5YmVlQTRIVjYreHEvSE56OElGdmVrazEwWDk5NXZ5MWZlVVIvZTJGMlRjckl2Wlh4N3o0MUJiRmlkak85ay9aYXVhZjdWdHRwZjNRZkhSOXRlYTh4Nm0xcHIvVmVuYk15OCtEbjZuTzVWajU3ZkN6NmEzOXRNZzJqeld5UGJCOExmaVNhcnlETDRUSHFyNmpsZnBGaGw4NzJ0M2dTaHBPN1hwcStONTFMUit0djJrNzI3OTYrOVZ2ZXYwdXdDMDNTTGVkVCtGTVBPMi9yOEgzNi9HWmJETkNNdi9vZkhiT2plcy82OGVkY3piZnJqKzZQbHZQZmg1Y3ZiYS81ZnA5ckMxcVZuNGUvSmFvL3ViOHdPR2kvSGI0MmZTVVh3L3Z6M3BxSGltc3I4OXBRSjlQdEorbVAwZUxua2ZpcC9VYTFUV2VVcisrSnUwdFhYT1B6ZWFZOFNSenpQWTFhK2tjRkQrcTNoK2I4ZEY2NmRZS3lEbTlaazZIZjM2aGYrU2JYaEo5dHJxV24ybjlaM0hNZzkvWHZmblNyYlUvY3J0Ynk3TFYvR3c4dEZLOXRPWmRwOWJSZW90MUQyKy9hTDUzUGRwUHk4K21qL2EzQm1yKzJ4NHNvb01xdEorMlB6S295dWluRFovUWZ0YmhseWI0Nm12YTRFdTdIdlhYOENQcmtocEt2eE40V1lWcG83QXFpOWN4MjY5KzA2dFFLTmppYWY5OWFPaTNyZHZQaXRuOHEvUGE2ZEdFZmZycnlOVkwrMXZVMy9qVDFYdSsxSitqMS9TM1dQZnc5b3ZtZTllai9iVDhiUHBvZjJ1Z3J1OHRRSjlQdEorMlA2Vkh6K1B0MTllai9iUjg5SHJWdjMvZzlwZ0gxWCtrelZEdk1lT2o5ZEt0QlZZLzIweHpwc2Mvdjh3UC9LYVgxZ1B4MTE2TmgvZGYzemwrR285ZExzY0R6VjhkOCtKTHQxYStIdHZaL2hlM3MvMHNlblJkNHFIMTMrMGZzZFpxTlg0Y0w0bi9iZy9QZXJTZmxwOU5IKzF2RGUzOHR6MWdSQWRWYUwvVGdpK3BKenFvMG5wSy9iUjhqaDRaZmxIQmsvVmEyNThLeTdMVk9jR09SV0FVMFcrMlgxdkI5cFp2ZXYxT0tPb0dpK29mUFo4VVQvdDdWbXB0M1IvTlB4Mm5udTl2N3ZmNzRmbm90blg3bzJ2a29aLzlITkQxZnJaZU4rTkwvYW4xcUg4VHJ2dlBRcW0rZGNkNkwrNzU5UDJsZmoyMC9oUS9RNzJIdHgvRjc1RmRUNEh5Ui9kRFF6cC9kbmlmRDdxZjFrK3F6OFRuY0NtT3ByNmpsZm9oK0RPUC9yaDJ6VGsyMjdkY2EvdVBmRExYWi96K0dGZS84cU9BNkRmYWFtWXF2UERQRGNhaDMvVFMrRVgvNWRpYkwvSGphdjh3T0p5MTFIK1h6NjE3ODdsYnRGL0VOc01Na2R2ZG1vWGVvKzdONS9wSjEvM3hYVC9ORERPZzlWSi9yWjkzUGRydmRuMzJmbDlGQlY5Mzg3UFZJL2lTOE13NkRQTUt1OTc3dS8yNXdWbVcrb292cVNFMVhzRlhiVGUydDN6VHEyQ0RwLzE5STlxdnJmdWgrYWZqcHZQOW5jdFh0N05yMGh6MUt6NjZqdUMvOFlmZ1MveWs2N2ZuRDFJLzZieWpkUSswWHVxdjlmT3VSL3ZkcnMvZTcydm9QOE5PNjZmMWsrcFA0MmVyZS9QUitwUFd6K0lZV2ovaVJ0Wm4vQjVjUGRlUHdtNC85QnlGRi82NXVhaHZlcWs5ZC81YXZOSm8rUno5cmg5blgrS3g0eS9aMzZsemFrZyt0VVg3MVRiSGRyWnZwYWY0NkxxV0w1bkJldDBmUi9udmFqUitIQStKLzJuMWFML2I5ZG43ZlEwVmZOM056MWJmOFZ0cE9IeUpmc2N2UTdpMXF1MzZjZlJVT09aZDEvSzkvV29idksxdmV2SHd1MkJXTjJSU2YrMDhUNmRGbjkvSXYyNW1DMS9BNzdVdTNiWTJmcDlJOVEzRVI5ZTEvUDVhOUQ1Y3ZYYjk3dit1SWZ6ZngzN0hWMnVxUCtYWGMzdSsxRi9xbDZIZVErclhROHVuNXNtbXB5RDl2YS90cDRYM2ZVcjArVXBoUGEvVzMxdVA1bnY3V2RSWEdtbE53dWZxWjU2VVg1YjFpamZiNS9weDlOUWMzblV0ZjZidmorMzYzYjV0VEY2SzMzWC8vSUt2YjNxcCtlaTZsby8rWnNCcXZmTk5pUjEvcnA3aVMrdmVmRysvMm1LMmFJMVVqK0NqNjFvK1dwOXhMZVZxL0NpKzFQK0dlblorTm4yMFB4cFI4Nlo0R0JDZ2dpOWIvcGVEcjFGZHkwZUhhWkZyYWZDMTQ2ZmhlOWUxL0pWZVV2dnF0aittdWI0dTIvcW0xN2Z4Tk95Tlh1K0g5aThVTXVQMzRmcW4vZDlybjd2VituSDRiL3doK0NNL1NyK3FTLzE2UGxxZmNmM0crL3o2ODBYNFVYeXAvdzMxN1B4cyttaC9OTHpuN1QvRHNzTjZYcTIvdHg3TjkvWkQxNlA5cEd1MG4rVjZGUjU0K0VuNEk2NWxYY3VmNlh2cyt0MituZTFMcjY4TC92bmxYdC8wVXZQUmRRUmY4NDBDNUpxenY2T1o2U24rVGwycTFmSzkvV3E3dDUzdGUvbFJmTzR4ai9lVmxzL1ZVMnZQeno0Sng4dVA0a3Y5YjZobjUyZlRSL3VqNFQxdmlnY0JBU3I0c3VWWDhJWGxqL1FyejB4QlY3K213aDJKQjlkdmx5L3gwTlMxZkxUK2E5dFpMZXYxclc5NmZRUy9IM2pXRzlDbjZXYlQ2cldROWtmUEczMytHdnhtUDMzN081Y1c1RWZ4KzJ0TitmWitsSjVibC9yMWZJNitFV3VKUDNMOVBqYWFiOGExOHV2MWZVM3FML1hMVU8rUm5kL0RXaS8xMC9xaiswdUJuamNhM3VkajNVL3JMOVZIODczOWR1b3JqWWRmZjJ5bTUvYWkvS1Q5dEg0UFkxK3lsdnJ0OHIzcVdqNWFQL083RWRKekhyMStYSy9YUHpjUTlVMHZOUjlkOStaN3JtYzFEbWRIajY1VC9WRjhiei92YllZWmtPY1E0VWZ4dFg1YWY2MGZWMCt0ZC8wUmE2cm03Y2Z4a1BpZlZyK05qOVpiKzUzVy8xUlU4S1hUUi9NcitKTHpKZnFUZzY5ZExkY1B6VWZYdFh5MGZ1VlgyNyszM0dQUWZ2Vk5yMElrbnFhN2tkWHF0WkQyUjg4YmZmNWEvRDZNL3JUL081ZFR0K2p6NGZpOThZZmdhLzBvL2FndTlaUHdWM3BxdmVPUFdML1J6eGZoTi9QWTlaZjRaYWpmeGtmcnJmMU82MzhhK3MrODAvdHAvYVg2YUw2M243UWU3V2V0MS9RYlBuQTd6elBxelowSHpiZXNqMnFyT3JYVjZtZCtoYjhSY3IzK3VYa0krS2JYY0E1SEx6VGZvbzc4Qzd6MDJ3UTczeUJZcmJrMXBPWVBxRTV4VjhkMitkUVc1ZU85UFhWdXIvT2gvTGpIVUg1U3J0UlA2a25WRVA0V2E2cW04YlBRUy8yMWZ0NzEyL2hvdmJYZmFmMVBRd1ZmT24wMHY0SXZPWjhUUm1uOHVETlRZUXBpclEyK1ZuNEl2bmZ3UmRVNUFaVkdiKzEzKzNhMkQvUE44azJ2MzJCMVF6T0c5UHBZWDgrbjg2Ylc2SDdlaU81UHdYSytuemQ2YXozM0RON25vL1Zyakg0ckhzcVBxMjl0ejIvRmI5MTZwYWZXSEgrcjlYdVcwWHp2WXp0K2FMM1VYK3VIcVBmY1ZWM3FsNUdQMWx2N1VmNFUwUDBMZjhQNitxTDl0WDVTZlRTZjQ2ZjEwTlIzdEZLL0daL0w3WTl4L1RpNkZVZnF4MTFMZEp4NTBIeXZPalVmZDR2U2MrZU4zbWJDNnZVRzhmM25oaVBvbTE1dmVQOWxFODMzcnFQLzhpL3g1MnIvTURpanRkYVA0blByTTc3VVg4dGYrV2owa2premUyWTlINjNmVGgzdEo2MmorTHY2WFgrck5aZWo4VVBxcGY1YVAwUmR5cFg0WmVTajlkWiszdjZGUFZUd2xadGZ3WmVNcndtK09Oekl0VGI0NHZocCtObnFuQUFJcFpmVUlnT3Y2Qm1vTUE3cWwrV2JYb1V6OGJTL2IxejdOZHJmRzlIOUtmemV6Rll6dnYwZjhEWUMzdWNqN2ZmR0gwTFA4YWY4TE91aitYYjVPM3BxdmZLM1dIUG1lMlBIRDZtWCttdjlFUFVSRitXWGtZL1dXL3Q1K3hkazZEOWpzL3RyL2FUNmFQNXRkVysrdDUvbGV2UkE3K2xIOFNWK0k2NjJ6am0yNjgvVjk5ajFzOTVtaGNWOHp6ODNHeC84cHBkVWcvZ0xzdWRmMkJIZlFOajE1K3dqUEdaNmlYYlhqOXNMeGRmcXN2aDdiMmY3V2ZweGorMjhqbmRmKzZnNmw0L1c3L3B6MXdpUGtXZG12ZFJmNnlldFIvdDU4OUY2YXo5di80SU1GWHpsNXQ5V2p3NitLTTlNUVZlL3BzS2FsV2JYVHh0OElUdzRRUmIzMks2L2xUNGk4TW84TDJxKy8rM1hONzMraTkrRlFkMkFVWDdhdXBZLzB2OGgxaHAvYVQrdG41YWZiWjRaVnp2bjI2UGZvdngzKzZPM3MvT3g3dGMyNXVQb0tIL0t6NnZlR1B6V3JiVjZhcjN5bDZ6Znh6VHp0TzdZRzk3NjNrdmp6L0ZEMW4rY056ejlQUGhvdmJXZnQzOEJDK3VmRDlwL3gwOHpBMGNyOVpmd0tXNUVYZU1wOWVQd1ozcHVMOG92Y2ozYlg2MjFmaFIvMXc5VjU4Nm45YmZTNy9iYndjNzFzWnlueCtyMXMrWHp6d1B0UjcvcEpkRjcvNlc1cjJ2NUt6MkhLL1gvdzZ5OTExeU5WRS94ZC8yNCtpZyt4NDl6ekdvYjNjTzZYd1EvVzUxYjArcFIvcHkxUnN2NWJQWFdJLzI5NjF5T2xaOEhINjIzOXZQMkw5aWdnaSs5dG9JdmZ0MHorT0p5TXdWZC9YcUh1K3VuRGI3UWZ1amdTOHBINnpYOU1uZ2g1NkZlcTF2NitxWlg0WTJuL1gxajJxK3orVXYxRkQvYlBGbyt4Ni85LzU1UHQvWEFxajk2NjlIL2pmY3g3bndVWCtKUCtlM1VxZjZyK3NvUHJVZjRjOVp2YU9aQitDUDBLNzdVMzd2KzVuQSt2OUIrSG55MDN0clAyNytBUmYrWm1kMWY2cWZ0VCttdDU5SDJSOWVqL2F6MUo2K2Z4VEdFWHVxdjlWdlZSN1ZWWGN0SDYzZjdhWkZ0bmg0SS8zLy9UYS9XV3ZTM3ZSQzlOUjdlZjFHVzFoRjh6VGNDTE5lYy9kVmFxcGYwM3FtdmpuSDl0SHhybitvLzkwRE9JL1dYYURsMXRNZU8vNjRmeW4rMGxuS1IvbEo5QkQ5YlBkcFB5MGZycmYyOC9RdFluUEFnby9HcjRBdGJqL2FMRHI0c1BIZURxcGwyMTM4bmlKTHkwY0VYVmRmeTBmcnMvYUxuMmZYLzMvN3lCaVFvL0VMMjNQR1NhRGhjOUUwOGtvOTRLRU91dFErNzBvZHR5UU80cEM0TkoxWjFMVjhhVkdqOFBMU0ltWGQvVnRiWGx0SkovVGwra2pyVmY3V3Y4ZGY0SWZ4bmErNngyV2N3eW4rSGkrS2ZWT2R5ZHJnZWZMUWU1UkhwWC9DRlJRZ1dIWHhwdFJJTmgzdDY4RVhWdklNdjZUeTdRWnBsMlBWZW8wS3pIZitkZ0VuS1I5V3AvaWcrV3I4NlR3MEgyVS9qZ2ZZWDZjZ2Jrb0RnQzkwditzWVZYZmZtUjY1M0hucWxEOTBTUHJjdURTbTRmcnQ4dEg1MW5wWWFoSmI3ODlENFdlaWwvbHEvZm4vWFQrdVA4dE53Uit0ZERkSmZxa2Z6VDZwek9UdGNEejVhai9LSTlDL0VvSUl2bmFhQ3IzdURxcytuRUFBQUlBQkpSRUZVTDRRWEozUkNCVjg3L3BJZ1NzcVBDc2EwWVFwS3J3bUl2UHZ0ZUtIOXhmejZONzBLbWZHMHYyK2MrN1ZVcitWTC9iVDkwUDEvYjM3VU9iejlIdUhXdXgrbnYvWjhwUG8zL2hCNmpqL2xwNm1QK25QOXRQNElQNDMvYUUzNWo5WnZJUHhYZmg3OGsrcHZEdWZ6aCtQbnlVZnIzeDVXNFpTMWY4RVgvV2Z1Ylg1U1BacnY3ZWRkejg2WHJxMzluOEgrNkZpRVA1b2ZXZWZVVnZ3UlY4TG4rbEh3N3JjN0Q5cGZwQ0Z2UnVxYlhtcStSZDN5TC9pSWJ6UWcxOXdhUjRQbXI0N3RhRmMrdTN5dHpzc3Z1cC9XWDZybkh0TzhCdEYxYno2WHUrc1hzZTdoN1lmbTMxYlB6cyttai9ZditDTERnNHVsWHdWZnR2WHMvTk9DTDY0RzVZL21aNm1qZ2k4cDM5c3Z1aC9hbit2M3YvMzZwdGVaK1AwZ3VUZVVVdjVJLzhkeHJZWFVEOTFmNm04NTc1dTdjNTQvVGI5RisxSGJXYjlkdjVsL2M5TDNzMU02eXAveTA5U2JNMytsYjAzdkY3Vit6LzZEMXEvMzl1VGZWcy9PejZhUDlpL0VBUDB6emVZbjFWdnlPVnlLazdrK3FtbjUwbm1rYSswOG12VnNmN1ZHKzZQNVdlcGFQblgrdTFzcnZ4RTA1OHNCeDEvcnQrU1JENnoxVFM4MTM3dXU1YS8wVXUzdStnK0RNMXBML1hiNTNEcmx6NjE3ODFmbnlUbmZIVCtOUmpPTDlHZUowcVA1Vm5WdlBsZS82eGUxbmgzVCtFWHliNnRuNTJmVFIvc1hZcEV0cUVMN1ZmRGxWNi9nYXorWTRuSlIvbFF3Sk9WbnEwY0ZaUkYrQ0M1NkZxMGZXYTl2ZWhVa2VOcmZON1BvTlhvK05GOEt5bjluM2liUVNQa3IvZE50MFg3VUZ1MDM4dGZPUituZitBUGdlOVc5K1J4OVUvaEZyUHQ1ZSt6NFNmUm8vbTMxN0h4TC9hNUhwSC9CRi8zUE02T254bTlISzlWSStCd3V4VG10cnVXajlkWitsdXRuY2N6RGorSm5ybzlxcXpySFM2TFg5dWY2VVVEN2NmMFJudE1hZVNNUzhFMnYxckEzU0JuK1lxdjVLL1NPVnZPTkFxMWVzK2JzUzlaU1A4a3NYblVwYjVlUDFuL05qOUp6ajBXKzFsYjdGbnkwL3NSMUQyczltbjliUFRzZnJVZjdSUGtYYkdFUmVsbjQ3dnA1NmJoOEZPKzBlZ1ZmdUhVRlgvdDFyc1k2K05McXYrTEgxYVg5cHRkdndGdHVsS2p6UVordjFpL2I5WC9hMzdOUWE2bWZsbTlaZjljNGMrL3krNjFXSCtYSDFjLzhtcEcrbjQzcVEvRzk2czJBMzdxMVZuL3F1b2UxSHMyL3JaNmRqOVlYQ2x4WXZzN1EzanQrbWhta1dnNWY0a2x4VDZzaithTWFwYmYyODF5UDlqMzlLSDdtK3V5OHVGdXUvNnpmcmg3dHQ0S0hId2RjYnNyL2VtTVA3NytFUnZQN092b3YyMXAvei9XdWR1YUI1bWVwSS9pY1l4SjlwSitrRi9XelIrbWwvbG8vZEIzRlIrdFBYZmV3MXFQNXQ5V3o4OUY2YXo5di80SXRyTVBWNk9CTDJ4L2R6OXN2VzcyQ0w5eTZnaSs3T2pyNDJxMVorYUY2YWNJeEtEL3JONzBLaGRiKyt5TDlJMWhML2JUODZQcUkzd1NhTi8vcHRscDloSjlFUC9LVDZ0LzRRK2c1L3BSZlpIMDAveTRmclQ5eDNjTmFqK2FmWEo5eEpINUlmMjRQcE43YXo5dS9nRVgvODhydXYrT25tVUdxNWZEUm5xZlZ2Zm5lZnBIclozSE13NC9pYStzampxU3U2VTl0ZC9rOXVIcTBIeGRXZmxBTmVlUHh3Vzk2N1dnay9KMi9TR3YraXMzeGsrZzVXcWxHc3ViV3BCb09YOUxMcXk3bDdmTFIrbXp6U1BYY1l6cy81eXl2clg1ZnkwZnJiMWozc05haithZlZyWGhhM1c0ZmxON2F6OXUvb01NWFFpOVBIWmRmd1pjdi8rdkIxNHl6NitjZGZHazlySU12YTc2MVgvUThYRDdidDc3cE5jYnZBbkZ2ektSOEtTai9uWG4vZEd1SmZzZGZzN2FlaCtKTC9UM3I3eHBuN2wxK3Y5WHF1WDVTZldQeXRmcCtOa3BIK1ZOK2tmV201S1AxdDZ4N1dPdlIvTlBxVXFEOUNvVlRZUDI2Ui90ci9IYTBVbzJFai9ZK3JlN045L2FMWE0vMjMydXRuNGEvVTUveHVYWFVmTnIrdS95Wlhqc3ZWeS9CNnVlbjRiTm5JUi9zUC9wTkw0MCsraS9aZlgzRkg5VW92Y1ovZC8ySHdSbXRwZjdTL2xvL3J6cUN6emttMFVzNFVyMWt0bDA5bXArMXJ1V2o5YmVzZTFqcjBmelQ2dForV3IxM1AyOC9iLytDRGw4S3ZYYjBwL0ZQcTFmd1piZm0xRTRKdnJSKzFzR1hOWCtsbDlSMjlUc3pXb1dCTEwvNnB0ZTM4VFRibTgvZVg3cTI3ay94cGY3WjZpTitFMmplL0tmYmF2VWNQNmxld3QvUnYvRUh3RCtscnVXajlUZXNlMWpySmZ5UlJ1b1hXWjl4TFAyay9wYjlkdlRXZnQ3K0JSbjZuMGQyZjYzZmpsNnFzZVJUWEk2WDFrTlRIOVc4K2RSYXF6OXAvU3lPV2VncHZxZmZxRWJWa1g1YS9remZ3MHEvQy9Ubkk4dnZDNkhYMDc1OVE2VTkvMTVQclMzdzdpR2RoelBmelArM3orMVA4YjNyNzIxajhuYjUwWHJyZm8xNWpNcy9vYTdsby9YYTlmdm42OUdQcys1aHJhZjRGTFIrMW5VcDBIN2Uvb1VDQXRhdlViUy8xbTlYTDlWWjhTbWVsODl1UGN0eGFxM1ZuN1IrRnNjczlCUi9WSmZ5dVhXdXhzcHZseCt0ejlhUDlQdEM2TlhhLzUzd1Y4TXY3ZmsvblhhMDF2aGJ6S09aaGRKTCswWFczelhPZGRubDk5dVpmc2FmNlp1UWI5V3Y5Nkxtb3ZpWjYwM0pSK3UxNjlIUHQzWEhQT2Vab1FJdjdMd1VLdkFxRlA0TDY5Y3AybC9ycDlGTHRSWjhpaVBwcWZYYXFhODAzbnhxcmRXZnRCN3RXK29wL214Znd1ZldLWDlydjEwK3FsOS96SUxQMFd2NHBOOVhRcThmM2c5QVg0VG0vSHZ0eUF0OWZmc0hWa25ReFptRjQ5OXZxWDRVUDZMK2UvTmJoMDN2N1V5L21uV2tsL0t0K3JYSlBtZWVFVDlydlNuNWFMMTJQZnY1OXFqQWE0M29RS3NDcjBMQkR0YXZWYlMvMXM5YmorWnI2OTc5K25wMlBscC8wbnEwYjZtbitCenRycCswSHUySDFrdHJTRDcxMnREeWgvV3ZoVjRGSFo0bUQ1WTgrMnZub2ZUU2ZvaDZXM0E0ZGNuMW9QeFcvS2ZiU3ZranZaUXY3ZmNHTnp6VCtHbjdhZjI1ZFMwZnJVY0VUS1B3NnczUGVSRDlwWHFLTC9FYmFaRDlLUCtaQjdLZk56K2IzdHFQOHUvaGVaOXhBNmpyZVZwL3JaKzMzb0pQY1NROXRWNDdkYW5HbTQvV243eCtGc2NzOUdpK1pYMVVvK3BTUHdsZk9zK00zOE9hUDlNak5mL1VXVGNTd2Y4RlIzUnZxWjhGbitKbzZsTHRpQy94My9HelhFdjN1WDVjUGNYbjFyVytWcnlzZk0xMVIxd2ZsSWJ6T2tPOVJsWTlkdmhvUGRlZldxODBQVHcvcXhEOXBYcUt6NjFMajNQcjNqNVNuaGMvbTk3YUwxdS8wMUdoVjZ6ZWlvOEt2aUpDcngxZEJWOXg2d3ErOUJydjRPc3JmSW8zcll0dUpJTENyK2liTlV1K3hRTUo4cUdJNDgvMXMzeDRsTzVMMXFNSFp3MmY0NmNKTW5iNkk0S1pESHowdVZ0ZXk1MStXdi9Wdm9hUDFrdjhxZldxZncvTHp5aUwvbEk5eFpmVUViOTdORnlPRjdLZk56K2IzdG92VzcvVFVhRlhyTjZTandpK29rS3ZIVzBGWDNGcktsaEE2OUY4eS9wc3JzZ0E2RVkrcFJYVnhUY1NBY0ZYOU0xYU5OLzZRY2Y2UVJEcEpYM0lsdFE0L2lpK3RaKzIvK3E2Y2tLYkNENHFBTEx5MC9hejZxL2xvL1c3L3RUYStuTk84N25vb2FmNDJycldUOXZmdXA4M1A1dmUyaTlidjlOUm9WZXNQcHAvVzcyQ3I3aDFCVi83ZFdzK1Yzc3FIMTZ2ZjlPcjRJbW4vWDN6cWwxYjk1ZnFLYjYxMzRqZkZocEovZW0yMmZnalBlVlArYjN4aCtCYjl4dnBxZm00ZFMwZnJkL3hiOFM2OSt1Qm5JODcvMjUvcVo3aWMveDZvUHRSL3BxNnRGOEdmalk5NWRjREhWSlIvU2ljRnBwcHo5Y2Exdk5wL2IzMTBYeU9uOWJEc2o2cVNmMjAvbWo5VGV0bmNjeENqK1pIMWtlMVZWM0tuK0VXUHJSK1F1ajF0TmdiRm1uLzIrZnQrZFRhQSsrZTB2azQ4M1A5Zi9zelBsWFgrcjIzamVCcDY2Znp1WFhxbUZlL05saFRmTFNmdFQ3Q3Z3YzY0S0w2U2Z0TDlWcElyeGNhMGYwTGhRaGtmMDFiejZmMTk5Wkg4N2wrSmcrU2dMcjArS3l1OVVmcmIxby9pMk1XZWpRL3NzN1ZvR2M0blErdm54QjZ0ZmIzQTg0Si9XK2Y5L2ZndVZwTC9ORGd6S2NKNnFSNmFWM2o5NjZOZUtoNnY5M2x0MG5kbXMrdGN3SXY2MzV0b0tQbVEvcjFmTFNldSs2UnphOENMeXlpK3hjS1Vjait1cmFlVCt2dnJZL21TL3kwWGhiMWxVYnFwL1ZINjI5YWovWXQ5V2grWkgwMk43WDE5dHZ0M3gvamZDWlJmSGo5bE5EcmgvY0QxZ245YjU2MzU0NjAxdWYvOXFmbWthNTMvZnV0dEk3dys3M1JQY0laS2hTaStLdHpzZVJ6NjZ0ejgralh1alYzUHBSZnowZnJwZXRSM3gyL0hoVjR5ZndxOENvVTdKRDl0VzA5bjliZld4L045L1pEMTYzOXN1bFBYby8yTGZWb2Z1WjZ0SittUC9XejRmUXlyNThXZWhWeTRmZndPVnQ3ZzVwSE82OVV6Nm0zRndmdFoxbC91dTBPZjFXMzVpUG1lMk1WK0dqcjBYN1dldS9BNm5mc0RldDVOZjJrZWc2L2g4WXZZNzNINlh4cmZRL3Q3M0ZyZnltb2VRcC93L3A2b2YyMWZsSjlOTi9iejZLdThlVDRTZjBsK3AzK042MmZ4VEVMUFpxZnVUNnFhZXJXL0Jrc1BpUFZuME5mREwyZUZodk1TRUhOS3owZmF6Nmx6Nzd1anlIMXYvM2ZHM1BGNmZrN2ZwNzFhRC92ODIzRU1WUzlDZm1ydXBhUDFrZjBvMkFSZUduNlNmVmF2dFN2VUNqY0IrdlBBTFMvMXMvaUFjMlM3KzFuVlVmcit1TlNmNjUrdC85TjYyZHh6RUtQNW1ldW96eXQrVjd6d2ViNFl1alYydDhQVENlQW1sZDZQdGI4a1Q1VHNOV3ZLU0Qxcy8xVlA0MmZWNzNmV3ZtMVNWM0tSOVZub1F5cTNvUjhUaUFrNWFQMXUrc2VGWGhoK1JWNEZRcUYxdXcvQjlEK1dqK3BQcHJ2N1dkWjM5RksvS1QrSEwybS8wM3IwYjZsSHMzUFhKK2RsN1MrNjdlYUZWWG44bUdmUDE4TnZYNTRQOENkQUdwZTZmbFk4MWZhYk92K21LWCs5d2FjaFNsdGNGemo1MUh2YTFaK3Eyc2o0YVBxczNOQjFadVFQOXJYOE5GNjdYbzBCMGRQb1FJdm1WK2hVTGdYMXA4RmFIK3RuMVFmemZmMnkxYjM1bnY3bmJRZTdWdnEwZnliNnhvLzZ0cWk2OUxYemxiL3I0ZGVCVi84SGxhenJMWHpvdldjZW50eDBINmErdE50TGZ4VzlmNkRieFhJek9wVVA2Mi9wcTZaUjh0SDY5R0JFaWV3NlY5ejF2TnArdTNvZTJqOE9mMnBmcGIxRVllcVMvMnk4eWw5ajJnL3FUOEZiZi9ib2IyKzJmcHIvYnoxRm55Sko4WFYxclVlTzFxcG41WlByZEYrSjYrZnhURUxQWm92OFJ0eE05ZDMvWHA0Zkthc05KRFByQXE5NUhnYTlvWUw3YWYxMS9LdHo4Y0M3NW1wOHhseHJmVHZlaU00Q0Q5a0hlM0hyYytPVVhXcW45WWZVZmZtby9YYU5hZS9GTmFCbkxRZldxKzlQbEkvNjNxaFVLQVIvUjVDOTlmNmVldXQrQ2dlNmdGMTF3ZXRzenBPcmRGK0o2K2Z4VEVMUFpvL3FpTThJdXZaNXVIT0s5MW5jeXYwMnNQN2dTdWpuOVovaDk4SE94SjlOb3pPUnhMc0lmV3ovVlUvalIrcTNtOS90V1pjbjRVa1ZKM3FwL1hYMUpzekg2Mlhya2VmSlNOVTRHVjdmYVIrRlhnVkNqa1EvVDVDOTlmNmVlc3QrUnd1eGRIV3RWNmEvbEkvTFo5YW8vMU9Yby8yTGZWby9teC94RCt0M2grTG5rZjZudTJQYzgvdnIvMEt2WFRvSDlDeStXbjlKZndSMS9wOHRCZzkwSTlxcTNXL3RkRC8zckFjUHNJUFVlOXJ6YWsrbTQycVUvMjAvcnYxNXN4SDY2WHJXZkN4K2pudG9BSXZHU3J3S2hUT1FmUjdDZDFmNitldGorWmIxN1YrNlBtOCtkNStKNjFIKzVaNk5KK2ozZldMckhOcTNuVnFQbVM5dFZhaFZ3R0wzOFBvcWVqbnA5YmUraEcvTFRoOUhlMjNxai9kTm51OS82RGtoRitVLzhwUFV2Zm1vL1c3L2Q3bzZ6MVcvT2g1by9VYy94NlcvWGJxUGJ6OW92azlwTDludmYyMC91aitCUjJzcnpmYVgrcW43Vy9kaitKcjYxeU9wdDlLNCtHbjVWTnJ0Ti9KNjJkeHpFSWZ6YmV1anpqU2VnK3RINnBPemJkYkgvWThNZlI2MmxuQmluUmVpcSt0YS8yMC9qZXRmL3VqWXhiNk43OHRmR1oxdE4rTjlka3hxVC9YYjFYMzVxUDFpSDV0d0ozVlIvQUl2RFQ5cmZWU2YybTlVQ2pjRCt2UEFMUy8xRS9iMzdxZnh3TWlramVyUzQrai9iVEhxVFhhNytUMXN6aG1vUi94VjNxRXYzWGR1a2ZFT1htYzM3VFBpYUZYYTM4L0pKMEE2YndVWDF2ZjhldURHS2wvbHFES1l0M0RVai9icDdnY3pvNGZ1dDdhditHR1ozMFd3a2o5dVg2Y1FNbWFqOWJ2cnRHSW5qZGFML1dYMWd1RndqZGcvVG1BOXBmNmFmdGI5NlA0MnJxVXErazNxbm42YWZuVUd1MTM4bnEwYjZtZjdjLzBDSC9yK295UHJsUDlyZXRJdjZuM3FhSFhEKzhIdEJNZ25aZmlhK3NTL3FnbThlKzV0Nno3cllmKzl3YmVEWGZRZnNoNkczQTg2N05acGY1Y3Y5RytKeCt0MTY1blFRdFZuL0d0MXRyKzFucXB2N1JlS0JTK0ErdlBBclMvMUUvYjM3b2Z4ZGZXdmZ0TkgwcUQvTFI4YjcrVDFxTjlTejJuaHZMZjhaUFVQZnRSNTI1ZHQvWnJyWjBmZWhWODhYdm9ST2xQWC9kQTZOdUxvOVZML2JWK2lIbCs2NmZiUnRUZldBVkFvN3JHejV1UDFpTUNwZjQxSTZsSHo4Zng2eEY1ZmJSK0VmVWUzbjRVdndjMUQ4WFg5cU9BOXBQNlU5RDIvenEwMXo5YlA2Mi9WSDhhMzl0dnA2N3hsUHBaOEtrMTJ1L2s5Yk00bGtFdjlaZndSMXhKM2F0ZkQrdDZ6NUh5T2ZWLy9MZHVKSjcvcExvQlFjeWk4WkJxMGZ5ZHVzYXpyMG45ZC9TWjEzOFd4eVI2N3I1VW8rbTE0N2RiOSs0bm1RZHhqVFB3cWJWV2oxelBQa080ZGF1MTlEalhEOVYvVjJmeGU4YXpIdTJIMW52MzgvWTdyZi9wcU5CTHB6K05mMExvWmFIelBzNE52bEIrSjY4dGdpdUozMDd3aGVMdmhtMVIvYXpycUgzcHoxNTNJNUVrL0VMT3NPTmxmVE5yK2JDd281VTh4R24wbVlLdDFYcjJFTDRUTnV6NmFjTWVqZCtJbzdsV252M1Exd0xoWjhHbjFscTl4WnI2N05qNWJOR3VxWnJHRDlHZnFxUDlNdFdqL2RCNjczN2VmcWYxUHgwVmV1bjBwL0ZQQ2IxMnRWSS9TejRuK0VMNm5ieVdoamdjdmNSdk42QkI4TFYxNzM1ZVlSNkN6MzBOUGVvYmlRVEJWL1ROWFRUZnU0NStrSk04aUdWZDd3UlZsbjZJc0VmSzN3bUVJdnRKNW9ud1EvR3BkY2JBSytPNmg3Y2Z4ZmYyeTFhUDlrUHJLL1RLMWY5MFZPaWwwNS9HUHluMDJxbG41M3Y3bmJSR0JsODdmcEp3eHBxdnJVZjJRNFJuN3Z6Nk43MEttZkcwdjI5MnM2M1I4NDc4Mm91ajFYUDhkL2xQdDVYV3ZmdjFINHgvR3QxdnhVZjdJZm5VZXVRbjBkKysvaDE3UTZydklmSGo4SHRvL0U2czk1RDY5ZER5cGZOUWZHMC9DbWcvcVQ4RmJmK0NEdGJYSCsydjlaUHFvL25lZmhIMWxTWURuMXFqL1U1ZVA0dGpIbjdSZkluZmlLdmhhK3N6U090b2ZzOFo4aXYwMHVOcHNoczZLVi9yWjkxUDJsK3ExODVqdmU2UGFmeCsrNzgzNjhoVG8xL1ZyZm5hdXBYZmlLUGhyK3JlZkcrL0c5Y1V0SHJLVDh2WHpsTW9GQXJXbnlGb2Y2MmZWQi9OOS9hTHFtYy96bjFRUi9tZHZINFd4eno4UnZ5VkhzSGY5ZE9jRTdJZTdjZnB0ZHl2MEF1RDl3T2pCVi9yWjlHdkQxNm8vbFR3czlMdnpHTWRkRm5OTTl2bitsUDZ2dDZNK1Z5L3A5dk8rbkg1WEw5WkNMVEw1d1JJMW54cWpmYTdkVTJoQXE5Q29mQUZXSCtPb1AyMWZsSjlOTi9iTDdJK3FtWGlVMnUwMzhucjBiNm4zMngvcGtmd2QvMjQxNEhpYy8zUTgzSDlkdml6OTlNL25BcTlzSGcvVUZyd3RYN0lmaU92bFg5ZmsrcWw4MWl2KzJOSS85OGJkUmJlYVBYdnVqV2Y2OWR6Wi8yNGZLN2ZiTlpkL21qZmswK3QwWDYzcmlsVTRGVW9GTDRDNjg4U3RML1dUNnFQNW52N1phdG41M3Y3bmJRZTdYdjZjV29vUHRyUHNyL2sycUg4Tkh5V3ZrS3ZnZ2EvaCtoZHZsU3Y5ZGV1dmZ1UC9OdUxnOVp6K084MXhaZjRQZDFXeTBmN2pmaHZTQUlrYTc2MzMyM3IzN0UzTXVzcHZyWStlajlMNnRyK25Ib1BxVjhQYjM0UGE3M1V6OXNmM2Y5clFGL3ZiUDIxL2xKOXRuN2VmaG5ySzAwR1ByVkcrNTI4ZmhiSEl2eWtlZ2wveFBYa2MvMTZvUDE2anBTL3BiOGg5SHFhYlhBU0RldDVLSDlwZnkxZnVvN0Fld2J0L0t2MWIvLzNaaDcxUk9wWC9KR2U4a2Y2WmV2ZkZob3ZQclZHKzMxaFRTR2IzaHBVUCs5NUNvVUNqZWozcEhWL3JiOVVuNjJmdDEvV2V2YmozQ0FBNVhmeStoRndQUHhHZWxRL3p4a3krbW4zdC9VM2hGNnQvZnVRbDgxUEMrdDVLSDlwL3gyK05CaVMrRnRqWjM1cDhEWGlXZWo3L1Vib1oveW4yODc4clBqVy9WdW42WDBzK1kxWW8vMitzcWFRVFcrTkNyd0toVE1SL2I2MDdxLzFsK3F6OWZQMnkxd2YxVEx4cVRYYTcrVDFiUCs5OXZRYjdhUDZjYzhEemJmcTN4L2pYaWNPaDlPYnBiOGw5UHJoL2NDWDBVOEw2M2tvZjJsL0NiL25VdXVkZWJUb0F3V3JvR3ZVcTdWNU9JUFd2L2tjL1lqZmMyZCtWbnpyL20zQTVlaTEvRWFzMFg1ZldWUElwcmRHQlY2RndybUlmbTlhOTlmNlMvWForbm43blZiUHp2ZjJPMm5OcVhuNmFmZ2N2U2Zmc3YvT3o4WmRmMXZvVlRnYnY0ZDI3am9hMG5tMTYxSC85dUlnOUNzL2lmN3B0dDc4L29PUEd3WngrZDc5bmduWHcrLzI5ZS9ZRzVuMUZKL2oxd1BkYitXLzQyZmRyNGMzdjRlMVh1cW45ZGYyUS9jdnJPRjlmYlg5MFBOSy9VN2ozMWhmYVRMd3FUWGE3NmIxc3pqbTRhZnRiOTFQd2g5eEVmd1JKTmZMV3Q5YXUrUGY5TXFHcDhsdTZLUjhyWisySHMzLzh2cTMvM3NqajhLcFhUM0hUNnJQd0I5eGtIekxmdFFhN2ZmRk5ZVnNlaTBvUDNTL1FxRndIcncvQTdUOTBQTksvVTdqMzFyUGZwejc0STd5dTJuOUNEZ1dmaHkrVnUvRjUxNnpYVDUzMzB2L3YzV0ZYamJvSDByUmZLMmZ0aDdCenhJOFJhOW4rMjNDcC9STjZDZlZaK0MvajZQNUZ2MGFzVWI3ZlhWTkladGVpd3E4Q29VQ0I5NmZBOXArNkhtbGZxZnhiNjZQYXBuNDFCcnRkOU42dHY5ZVcvcHgrRnE5MTN5Vy9ObnJOMHIvdjNXRlhyWjRQNkJhOExWKzJyb252K2QrZWYxN0E3OURrRjM5anA5VUg4MGZhVkY4ZEw5R3JORitYMTFUeUtiWG9nS3ZRcUhBaGZkbmdiWWZlbDZwMzJuOHI5V3o4NzM5VGw1emFwWitPOTVXL1RUelNhL1Z6clhOcEcrdFZlaFZPQXUvaC81YWovRjdjNi9DR1VzL3FkNmEvMTQvM1piRGYyTTMvT0xxbnduWHcrOXI2OSt4TjZSK1BTejdVM3h2djUxNkQzUy9IdGJ6VVh6cFBCUmYyaS9hajRLMG54VGErYkxEK3ZwSllUMlAxdDliYjkwUFBRK2luMldQSGEzVXo1dFByZEYrTjYrZnhiRUlQNmxlMDIrazVheDdTUGs5SjFyUFdrTnVESjcvcEx2QlFNK2o4ZHZSVWhxSnA5WnJWSmRxa0h6T1BGOWF6L2FqZUZLOUZSK3AzN2ttU1AydW4zYU45cmJ3M0psQmN0enFzd3gxM05zUFZiL05ENjNQZEEvajRZZEc5dm0wcU5BcnQvNkxvWmRsSDdRdXkzSHVnejdLNytZMUoveng5SlBxZDhLcnFIQ091KytsWjYraE53WVZmc0ZuUU55NFd6NjhhTU9wSFQ3cVlmV210VFRzc2ZhekRwOTJyNVgyV25CQ0tMUit4MCs3amdxZXZQck9hbDZCRjdlL3ByZUZIN0orbXg5YW4rSGV4ZE1QamV6emFWR2hWMjc5VjBNdnExNGFUNm1mTjU4VGZDSDlibDV6UWhGUFA2bCtKOVRaT1MrdFhub3VYbnB5RGI4eHFPQUwzai82NFFRZGlxRWZSQ1hjcjY3UllVWmsrTFFiK3FEMHUzNWF2WVlyV1Z2MlFIcFpCMVNXZ1JlQzcrMkhydC9taDlaSDM3ZDQrNkdSZlQ0dEt2VEtyZjl5NkdYUkw5clBtKy90ZDlPYVUvUDBrK3AzWm92U2p6eWk5S3gxL1p0ZUJVczhUWGJ6S2VWVCtxK3ZlL3plL0g4RWE2U2ZSdjkwMngzOUczOEkva3EvNDZmVlMveTA2NTE1T09zM0xPZWZuUStxdjlRUHpmZjJzNmozaVBicm9lVlQ4Mmo3b2Z0YisybjdTWUdlNzNaNFh5OTBQNjJmdHo2YXI2MTc5RnRwUFB5OCtkUWE3ZmVsOWJNNEZ1MDM4anBKUDROV2o1anBuM1dGWHZaNG11MWZIU24vNkRxYWo5YmZ2UDd0Lzk3NE8yRVgwaTlTLzF1UFBDTDlWbnJ0R24wK2lIVVBqOEJyQldzL05OL2JyMUFvM0Evdnp3eDBQNjJmdHo2YXI2MTc5Wk1lUi90NUgrY0dBeWkvTDYwZkJtZW1RZmx4UEU3U1c4MmpuV082cnRETEIvMURwcmQvZEIzQjc0TWRyZjRyNjM2L0VldlJOVVg2U2ZXLzlkTnRwZnAzNzVGdmxKOUZ3SVErSCswOE0xVGdKZU43K3hVS2hXL0ErM01EM1UvcjU2MlA1bXZybnYxR05VOC9iejYxUnZ0OWFUM2JYNjNSZmpQL0tQM3NXS1NmMld1Z1FpOWZ2QjlJSS95ajZ4citpS3ZSZjJrdENUK2VibXZoSjlHL2U3KzNVdjE3bnRGc1VYNmpmYzBhZlQ3YWVXYW93RXZHOS9ZckZBcmZnZmRuQjdxZjFzOWJIODNYMXIzN2NSNndQZjI4K2Q1K042OTN1Q2cvanIrbmZ1U0J1dFpvUDhpNlFxL0NTZmc5MUtQMHRhWkR6UGJpU05kSXY2ZmJJdnplUUlWRnUzNnJ3R1Vub0VHZUQyTGRBKzF2MlcvazZjbjM5b3VvOTVENjliRHVUL0dwZWJ6MTFuNVNmM1EvTkRUM0dTTmtPejh0ck04SDdhLzFrK3BQNDN2NzdkUTFuZ2cvSko4ekQ3cC9yZm5yWjNFc20vL0lhMmM5Z21ZK3lrKzczdEpXNkNYSDAvQTNSSjc5S0Q5MDNadVAxbjlwL2R2L2ZWaG93cVUrcU1ybTkxdVBQSzM4cUxYMStXUlk5OGplajRJMTM5dXZVQ2pnY2R0NzFQcDgwUDVhUDZuK05MNjMzMjRkclpQNm9mamM0K2orMXV2b0dTeThyT1pEK0k4ODBQTnAvSzEvTm1LZkNyMzIwRDkwbnRhUDhrUFUrMkRGbW8vV2YzWGQ3emZoZXZRTkMzU1lnL0I3enpicWcvUnJ4TnI2ZktqK1h1c2UyZnRScU1DclVDaHdjTnY3MVBwODBQNWFQNm4rTkw2M242YStvMFg2SWZpU2VkRDkwZXVvdnJNMTBuZTJqNW9QNFc5OTNseU94TS9pTmNmeXFOQkxoL2NENjRuOUtEOU5mVlN6NUtQMVgxNy9QaXd5aGxOOXFJT1lkelE3eXE4UmErdnpvZnA3clh0azcwZWhBcTlDb2NERmJlOVY2L05CKzJ2OXBQclQrTjUrM3ZWb3YreDZWQWdSMFhzVWZGaDRXczJYeVcrMXRyaTI3dk5VNkZXd3hPK2gzb3VQMWtlczIrdVl4eG81Zncva3ZFKzN0ZkIvQXhWK2NkYUlmcHIrSHVzZWx2MUdQUzMxRnZ3ZUdyOFQ2ajJrZmoycysxTjhhaDYwUHRwUDY0L3Vyd1Y2L21oRW53KzZmN1NmdHI5MVA0cXZyWHYzMjZtdk5CNSsxTU80bEkvdXIxMTc5MXV0bjhXeERHdkwrVWJlRnVzUk9PZWNaWjdXV250TWJpU2UvN2pmb0ZDd25HZkhXek1QUnl2eDEvcFIrbEZkcXBIMnQ5WmJyejM2elBheisxcjVjM3A0OTd0eDNjUHJ2V09sOXpwdXBjdFNqL2J6NXFQMXAvbWQxdjkwVk9pRjlhdlF5N2ZmYmwxNkhPM25GWHp0OXI4OStQTHFHVFdmZDlqSDdaTnRudit0VFc4a1BoSitXUWRZR28xSFFLWjVPTkdHVVNzUHRONGpEUENZWlJTMFdQVkFlbmtGUTVIWEtqcVF1aVh3bXRYUWVrLytqdDlKOVdnL2J6NWFmNXJmYWYxUFI0VmVXTDhLdlh6N2FlcWptcWVmUi9DbDZhOEp1aml6UklWUVhuMHp6QmNaZnEzVzJlYXh2NUg0UVBEbGZiT2I3ZUhCOG1ISTQ4RlZvajg5Rk9oRG5PZ1FKUE84a1dIYmplc2UyZnlsK21qK2JmVm9QMjgrV24rYTMybjlUMGVGWGxpL0NyMTgrNkhyMFg3bzRNdmE3OVRneTZ0WGh2bDJadm5TUEsyMStqZTlDcm54Tk4zTkxscHZzVzZMR2RIOVJ2N3YvaG5XV2VidFB6ai9FSHhrdnh2WFBUTDVqenpRL1NSOGFoNXRuWnJIdXY5c0JvMWZqK3o4SGxxOTFFL3FML1dUK2xQUTlpL29ZSDM5MGY1YVAyOTlOTi9iTDZLdThaVDZXZkNwdFZZZjdYL1MrbGtjaTFyM3lEWlBocG1lQ3IzMGVKcHZNSVBtVzgrUDd0L3pwZjdXK3AxK3F3YzhaTC9mL3E5ZnhyQXIyN3lqR2Q0L0w4bmFlMzd0dkJickh0SCtGS3o3U2VmUndydGZvVkE0SDlhZkdXaC9yWiszUHBydjdSZFZSK3U4ajBlb2JvTW9BQUFiUDBsRVFWUUhIOWIrSjYwZkJpZkRUQm5taVo3amYrc0t2VERvSHpxdDlXaSs5ZnpvL3I4Z1F1SlBCVU5hdlhUdDNXOFdLclhnOWV4Ykoxbm1SUVJlVWZPL2oybm1SNjM3MmREejlhakFLN1pmb1ZDNEE5YWZHMmgvclorM1BwcnY3UmRaMzlGSy9TejUxRnFyMTg3K3BmVnNQOE82UDVibE9vV3VLL1RDWXZZUWI2Vkg4NjNuUi9ZZmNWZjZ2b2JXUzllL1kyOVlCVjM5Mmp0OFdhMmZicHR0M3RHK1pOMTdlTTcvUnBiQWEzWkRWWUdYTFNyd0toUUt1N0QrN0VEN2EvMjg5ZEY4YjcvVDZ0bjVhUDNLandwWHZyYk9OTXQ3M1crajUwbXhydENyY0RMNm9FVEtSK3VsYTJ2LzdPc2VVZUdRSlB6YVdmZkh2T1ovUXpNL1ltMDluOVJQMDMva29lRnovSHBvem1lbTJmVWZjYlIxYWIvVCtCU282eVhWVThqbXI0VjB2dFBnZlQybHNKNVA2MythSHMzMzl1UDBzK3l4bzVWcXZQbG92YlZmclgzWEkwZzhPUDZXZXBPMXk0M0JCLzRMamtqdkhiMUV3K0ZTSE8rNk54K3RqL2JQdko3dDM3U09QRWV0MW5PK0NMOWRQdXE0bFU3cmkrWnA2N2Z4cmYyczc3bXkzZFAxeUQ2ZkZoVjZmVXYvaGRETHNvK1hyb0l2ZmIvb3NPaW10U1NFNHVvODlHWnIxeHVEajRSZmtUZXJpRUJMd3JXc2N4N0FrWHkwdm9JdS9qclRMT2gxZE9DRkNMSlE4OXdTZU0xcVVyN0dUMXMvN1hmRmJYeHJ2d3E5N2thRlh0L1NmeVgwc3VxbDhhemdDK3VYS2dUNXlIcFh5MzB2V2VuaGEvY2JndzhFWDlFM3E5NFBGeFY4N2EvUmZyWE91ODRRZUdsZW54VjRZZm5lZnVoNjluN1orZForRlhyZGpRcTl2cVgvVXVobDBjOTYvZ3ErY1A2WndxSXZyMWZCbFlmZVpGMy9wbGNoTTU0bXUzblY4dEY2cWIvV2o3TnVyMk8xOWx1L1AzZzkxb2o1MzdDWUQra3Y5YlBranpTV2ZoSDFIcEx6NC9UcmdaeHZoeStkaCtKVDBQcFJlcW1mMWgvZG53SjZ2dHNSZmIzUS9iViszdnJUK0J3L1NVOXR2MUhkd25PM253WGZPa3hBKzZVS1Ayb3Qvdm4wc05idnpFdHFLdlRDNDJtNkd6aXRIdTFQOGIzcjNueTAzdHFQMDA4Ymh0UTZ4L3AzekhMZHVocTYvNmlIcHgrYVR3SHRsdzJuejE4b2ZCSFI3MWwwZjYyZnQvNDBQdGNQeGR1dGUvdDZINWZPcncwK0xJSUpwTDlKVVBMaDlXemZTODlaaTNRVmV0bWdmMGoxMXFQOUtiNUh2UTl5clBrai9SdmFJQXJ0eCtsWDRkZGQ2L2V4MzNIa2V0WUwxYi8zUXZqMTNwNThDaFY0RlFxRmpJaCszNkw3YS8yODlhZnhKWDRjcnJhZkpFaEIxS1g5TFBuUytTVjZ6bXk3b1FUSzN6UWtxZld3NXEyZmVZaTlLL1N5UlI4K2VPdlIvaFRmc2o2cVdmS2xzMHJYYUQ5T3YxbmdFQjNlMUhwdi9ZWlY0TlZ6VVAxbnh6UitFajJhVDZFQ3IwS2hrQlhSNzExMGY2MmZ0LzQwdnJkZnR2cHQvSlVlRVZoSXVkYUJqbWV2V3R1dWV5ejVGWG9WVGdJVkhLSDVsQjRSUkNIOXFMREVvaDl5dmxyTDFtOUlBaUxPMnJxL2haOUVqK1o3KzFuV1J4eHRYZHBQeXFkdWhMUjg2VHdVbjRMV1QvSjdqK05IUWRvUDNWOEs3YnpXOEw0ZVdsalBpL2JYK25ucm8va1JmbG9QU2REQnFhc2V0aFB5MFhwcnY5dm11WDN0MVVQVXYwS3Y5cytEZVRaSTU3UG1hLzNROWV6OENMOVpXTkc2NDRoK3lQbHVYLytPSWRldHEzblBNNW9oMGsrcVIvTzkvZEQxUXFFUWo5UGVvOWJ6b3YyMWZ0NzZhSDZVbjlablZ2ZlNaZWVqOVI1K2xrRkpodmxPWDBmM1hmSXI5UG92K29mQ2JKRE9aODNYK2lIcWZiQ1NqVSt0ZTJpRHBkRjhxK1Bld1JkbnZ0dlg3Mk8vNDVyMXpOdHJudDRMNGRkN1crclJmRzgvZEwxUUtPVEFhZTlUNjNuUi9sby9iMzAwUDlKUDY4VUpKaVQxcllmdFEvaUlFTWZLRHhHS0lPYkpFdkprVzYrT2UvVW0rMWZvOVRmNmgvVnNrTTVuemRmNmFlcWpXaVkrdGRicVovTzlRWVVkbm12SmZMZXUzMEFGWGozSGE1N1pNWTJmcHg3TjkvWkQxd3VGUWg2YzlsNjFuaGZ0ci9YejFrZnpUL2VUUERSbjZCZkpSNFFXbm42SXdNUXlkUG5hdWtlcS9oVjZGVTRHRlNSRjh6bEJrRWJmaHhrSVA4MDNoNmcxWWo3a1BON3JOeVNCampiY3Nwakh3czlUaitaTC9FYWE2SG9QeWZtaCs5M0E3eUg1UFlMd2t6NVVTdWZUOWtQM2wwSTc3MjN3dmg3Vy9kRCtVajl0Zit0K0hMN0UwOXR2cDI3aHVhcmZ4ai9kNzdad3grSjhrTmNrdXYrUTczMmo4ZCt1LzNHL3daSEFZamFrNTQ2WFZFUHh2ZjJrOWV6OGJIcXUvMjArMXV2Wk1jOStrdGNPMnU4RVBaclByWHQvSmtycmFCNzZkMFoyUGxwL210OXAvYitPQ3Iyd2ZqZUVYcGw1dS9VS3ZuUjhhWmlZMGM4eS9Nb3d6Kzc4VWI3b2ZrdCs2STFHMHZETGNpYUV0OGJqNXZCTEd6aFFkWFNnSWVWN0J5b3IvNmh3NXVUd2ExV0xDaWtseHpSK252cEl2cVFlSFdweFByc2xuKzhWZXRucVQvTTdyZi9YVWFFWDF1K1cwSXZMOWZiVDFMTUhYMVJOeTBmTno1MHRpNS9ITjZNaTUwR0ZVaWp2NlA3RGV2aU5Sc0xneTNxZTZKdm5DcjcyZTBVL3BLUDEwZjZuejVOdFhpblgyczliSDhuL1dqM2FMenNmclQvTjc3VCtYMGVGWGxpL20wSXZEdC9iNzdUNnJjRVhsNXZaenlzTWk1b0gvYlBQM24vcFYvK21WK0VtUEUxMjgwengrN3JXWDlzUHJmOTlHUHlackszOXBXdk9QTWgrRnZONjlYdC8wUDhackQzOHZQV1IvSnZyTTQ2WFgwWitEMnQ5dEovV0g5MWZpK3dobS9mMTBNSjdYblEvclorM1BnTmY0cWtKZlZBZTN2Vm9QN1JlMis4MHY5UG40WEk4KzJuNmEvMWFhKzJwME90ZlVNRkN0TCszbnVKNyswbnIxbjdXODNqb1orRkg2NDZqL2FWcnpqeklmcHg1UmdISjdJTTRXeit0bjFUUDRXdjEwZnpiNmxLZy9RcUZMK0swOTVEM3ZPaCtXajl2ZlJZK2l1Zmw0MTJQOWtQckVmMGlndzlFVUdOOWpWSDlzdXU0UGxxL3Yrb1ZlbzNSUHlSbTgvZldVM3h2UDA2OUQwYlFmaVAvTjlCOEN6MFZGa244ZHZ5bGErOStuSG1vZ0dRMVozUS9yWjlVVC9HekJWalJnVk4wWFlvS3ZBb0ZERTU3SDNuUGkrNm45ZlBXWitKenVOcndCK25sWFkvMms0UkNDTDRrekpEMDUvUkIrcUZDSE85K3V6OGp6MzZhbnhQWGIxaXIwR3VOL3VFNm03KzNudUo3KzYzcW94clNUK3FsNVZ2b1p3SEZMTnl3OHQ4TmY3ejZ6ZFo5cjFIL1BrVEoxRS9ySjlWVDNwS0FKaHYvdHJvVUZYZ1ZDamljOWw3eW5oZmRUK3ZuclQrTnI2MTc5MFBYby8zWW9RQ0lMOUZyKzN2NzdZWkQxUy9HL3k5VTZGVzRHZElRVHVwM1l2RFZGaDdTL3B4d1NqUGZUaGpXOTlQNFNmb2h3eTJ2ZmxvL3FYN0ZIK2xQNHA5Y24zRzgvRTdrVS9vZTB2NVN2YldmMUo4Qzh2ZnlEdENoeVczd3ZqN1cvYlQrcCtrejhMVkJqM2UvNkdBSzdlZk56NmEvUFF6eXVGNlNuZ2cvODlkUTlJMUhhNjFsL0M4NDlyQ2VUK3V2MFV1MUhMN0VFK0VuclVmN2FmblIvV1orM09PN2Z0NXpSRnhIU1U5clA2bSsrT2ZWbzNtMzhLMzlzczF6ZXYvQ0doVjZuYTNQd2tjRlgxNzlvb01xdEY4RUh4Mk1hUFhlUVkxMytDVTl2dXNYTlFkVW4rckdvOEt2a0J0ank0Y0I3NEJNKzBCdjZaY2g2TklFS0JLLzNmQ2t3aS82dUNhWTJ2WGI0WjdDWDlXakF5bXZ3SXZMUmZ2ZHhMZjJ5emJQNmYwTGExVG9kYlkrRXg4UmZIbjJpdzZxSkhWdGFJVGtjN2xlZW11L3I0UmRYQzNTenl3QVMzZmpVY0dYKzgxeE5OL1RyNEl2WGIrdiszbk91eE51b2Yyayt0UDRxM3AwSU9VWmVFWDQzY2EzOXNzMnorbjlDMnRVNkhXMi9qUSs2aHRoWHYwcStPTHpzK210L2FMQ3IxdjlvUHI2TjcwS1g4TFRzRGZiVWorSzM5ZXB0VlMvMDYrOWp2VnJqdDlLZjVvZnh4L2w5LzdnanZLVDZrL2pyK3BTL21uMWFMOUlQa2REM1hoSmY0OUkrMVA2SG1nL3JUKzZQNFd2aDJqZUlaVVUyVU10dEYvMmtNdTZCNGRiUVZkc1AyOStOdjJKZnFzZTNuNWNUaFo5YTYwOUZYcmRCM1FRWTgzMzl0TUdROUYrMXZPTStMTndwSFhIcGZyVC9HYitmUjh2djkreDFYcmxKOVZiOU5QNEkvamVmdG5xMFg3ZS9FTGhSbVIvRDFUb1phdmY3V2ZWQjhXcjRNdTJYd1EvV3pDU1Bmekt4dVBxcmE2RGlsK2gxNTNvSDVLejg3MzlSa0ZQajlVM2dpTDhwUDRJUGhVT2FmV24rVWxmZDlaKzcyTy80LzNQbWpwdmlSN2RUK3ZQNGZkYWE3K1Q2dEYrM3Z4QzRWWmtmeDlVNkdXcjEvU3o2Q1h4dkQzNDBtclIvYUw0V20rMC90U3dpM3NNN1lmb0hhNnYwT3R1OUEvNzJmbWVmanZhU0QrcFA0SS9Dd2htWWNhdS9qUy8yUWZxYnRpMTY5ZHpSK2ZUaHpnYVBiSWZ3cDliOC9JN3FSN3Q1ODB2Rkc1Rzl2ZENoVjYyK216OVR2ZXI0TXVQYnhVV1JlbHJubHo2djFDaFYrSEx5QlRDY2ZnN1FWWmJhTkJCbWJZZko3enEvVlo4YTcvb2VVYmMzWDRjUGJLZnh6emVmaWZWTlg0Y3oyejhsVjZxUmV0M1BTejlLUDhlNkg1U1pBOTlic2Rwb1JiYVAwS3Y2V2tScWxYUWhhMUgrMlhuWjlObm00Znl6S2JuZXFyNDBUY3FROVIvd1JIdUwvV0w1bnY3U2V2UmZ0Yjl2ZWVmNmJYSHZlYlU2RmVlRmo4WFNUOEVQL3E5NHUxM1duMlhILzA3UXN2WDZsQjZ0SStWWDdaK2hWeklIa3BaKzBmcHZYUmNmZ1ZmMkhxMDMwNS9iZEFoNVVjSEt6TTk5N2lYUHV1Y3J2elVOeW9WZm9YZkNKL0d0NnhIUDJ6djlNOGNxRWowWHdpL1ZqWEwxNDVsTUNiMVJ2YmU5ZnRTWGNPUC9xelg4bmMxU0wyVmw0VmZ0bjZGWE1nZVNsbjdSK285dmlVbTRWZndaVmVYaGtab1ArOUFhMVd6MEV2NFdVTWs3bldKMWt2NHNBQXMvWTFLQlYvaE44T244U3Y0MnZmem52KzBmcWZyUGZrVmVPV3VGMStINk4vTDNuN1oraFZ5SVhzb1plMS9tdjQwZmdWZjYxcVc0R3RVOSthZjF1L3JlbGQrL1p0ZWhRSWZUMXZmM0V2cjFueXAzKy9EWXVhQjVuUDBVcjVsdjlQMW52ejNMNTVkZjIrL0w5V0wvemVrb1kxVzcrM1hBeDFTU1I5S0t5VExEZXVRS2JvL3dyK0NMbHQrQlYzcittMStwNFV2cCtzcER3NC8rMnZpSDM2RlhucFFRVU4yZjNUL2FQNXA5V3pCMSsvWUcxYjhQcndZNmFWOHkzNVcrdDVueGY4ajBKL0czNm1qL2I1Vy96cS9VQ2o4aStqMzBBbWhGOEtuZ3E5Y2ZxZlZMZnBKZ3hDMDMybEJES29mOTdoV0wvVzlpbCtoRndiOVErcHAvdWorMGZ3VDZxTnZKTDNCK1ViV2lyL2p0L3NOcWwwKzhyaEhQeXU5aEU4RmZpZnpwZlZSd0tIeHkxRHZ1UlY0MmZFTGhjSVkwZStqVTBJdmhGY0ZYN244SlAyOFF5ZXFqdFo2K21uNUZYYnRIOWYrWEZJRVdoeCtoVjVZOUEvZnAvbWorMGZ6TTllbFd2UXNJejRWWUZqeHFkQ0l3L2ZzaDlMMzJPSDNJZERKZkVsOUZuaEZoa2pJRUtvQ3J3cThDb1VvUkwrWFRncTlFSDRWZk9YeSsycndOYXBIKzJYbjM5N3ZLbjZGWG9WQ0hESUdYeFMvTFRUUmZJNGV5ZmZ1ZHp0ZlVsK0ZheGI5UE9vajdveXZyWCtkYjZuZjliRDA4L2FYOXU4UitjZTlHeEVkWW8zZ09WTzJrQXZoRVIxRVdmTXpCMTBXL2F6bmo1N25ObjdFZk5LdzgyYitxRTd5ajdpeE9PQy80TmpEZWw2dHY3YyttbjliL1RZL0ZOLzcrQ25YQmNXbk5GSytSVDNiZTFWYXo5N3ZOajVhai9heDh2UDJseUxiUEtjalkralZtdDljR1VNdmhFOTBNR1hOanc2aXZQdGxDNzRvallkZmVGREM1SHNmeng0S292a1F2Nk51TENyOGd2dFgrTFhmejZLWE5GRFExS01ERDB0K2hWKzJmS3JtK1RyMjh2YW9vengydUZ5KzVuZEc5T2UvdGQ3S3k4TFAyMStLYlBPY2pxeWhWMnMrczJVTnZSQmUwY0dVSjUvRFJmb2grbW5xa1NFWUlsRFMrRmtIY0tlR1hTdnVGL2tpditOdUxDcjRndnRYOExYZjc0dkJGOUt2K0dmeHZmMGs5ZWpBcWdJdnJQYmt3T3NFUDI5L0tiTE5jem95aDE2dDJjK1hPZlJDK0dVS3BxejVGWHpGMXFQOVR1dGZmQ3hmVXYrblZ2K21WNkd3ajZldGI4NjFkZXQrRm41dG9jbklmOWVMditaNyswbnE3MTl1SjliZm5OMjZ0SitVTCtudk1ZK0dqOWFmNXJmeXQrb2hBWFdqR3oxZk5tUVB0WHA0ekpzdG1FTDdaUXFpTXZDOS9iNVdqL1k3cmYvcGZFb2o1WS9xMXEvaGYvZ1ZlcDBQYVhBU3JZL21meTJJaXVpM2VvREt4bi9YKy9BbUs3L1g3ZkoveHlSOGpWL1Y3ZXZXZkttZjlUeGFQbHAvbWwvaERwejJtdkNhTjF0UWhmYUxEcHF5OFN2NHNxOXJQRE1HSlY3OVR6aytxMGRmZDBpL0NyM3VRUC9RbTEwZnplZldlMWgrZzJYMERhVlpiMFRkb3QrcDMvQTY3Zmlzdm5QZVZJQ0k5S3U2dk41enFWLzBFaitML3A3empMUVZlQlcraU5OZUY1N3paZ3VxMEg3V1FaTm5MdzVmNHVudGQzTWRIWkJGaHlRVmR2SHJwd1daMDNxRlhuZWhmL2pQcm8vbWUvdXQ2cGJlbzdwRlB5cEF5Y1JmMWFrUUtvcmZBL0ZOcjc3K2RHdWtYOVZsZFNuWDhsdFJ1NEdYVjJoVmdWZmh5emp0dGVFOWI3YWdDdTFYd1ZjZXY2cmY3WGRhLytoNXZmMlc5UXE5Q29VOHVDSDRvdnExaFdhSC82NUwrV2kvMCtiMTlxdTZyRDdpb3Z3cytudk9NOU5HNlUvenk5WlBDaXBNdmgybmhWeXRWZENGOXZNTXVqejZhUjl1cy90OXJYNmIzNG45TlRObjk5dXFIM2x6VVA4RlIvTiszdnBvdnJkZnR2b3Q4MGlQby8yaXI3dkZ6MG5qbWUxMWxYR0c3SjlsMmZuWjlLZjVaZXVueFduejd1TEUwS3UxQ3I3UWZoVjhuZVgzeFhwMFdNU3RvNDU3OWNsK1hUTytGcysrUWFqd3k3emZhZnJNRDVqUkQ4OFpnaTVwUUZMaFZ3NC9yVGJiYS8rVVdhUjhSTWpuemRkcWtiOVRFVjZXditNOTdoOU91NmQ2NCtUWnBUZzE5R3J0L09BTDdlMGRSR20xbnYyeWhWWm92NXZycDRRb1h3aTdNbjFESy9RYlg4ZmZKRlR3WmQ3dk5IMEZYL3o2N2ZPVVgydzkyendVVHB0SHlxM0F5OWFyQXE4NG5EejdEazRPdlZxcjRBdnRVY0hYdVg1Vmw5VlA3eGZkMzd0ZnF0ZFAvWnRlaFlJZm5yYStPZmV1WjV5bkxUU2NPdHJ2WGYrYTMyM3pVRGh0bmhFM3F2OE9mNlQxNm9mb1AvT3dDR0FRODNGN25CZ2dlVnlmYUZUUWxhdGZaRkFWb2MvVzczUy9xc3ZxcC9mYjhWdHBMSzVIaG5NMnJWOXhjMURmOWpMdmQ1bysyemRBMEg1ZiswWk9sdk9SSHZmV1pmczVSUFdVMUtYY3pOLzJPcUYvdG41b1ArdmY3YWY3VytQMCtTbFU4SldyMzJuQmxWYWZyZC9wZnB4KzZZS0RKSFhwOFd6OWpnK1FpSHEyZVZwcmw5MGdWUGhsM3U4MGZmWUh4c2g2eHRuUTUxUGhWNzU2NXRra0hHUy9TRDl2UGxLUCtQMFovVHN0MmorcUZ3b256bXlKMDBLeEcwSXdwR2VGWUxvZTF2TjdoRnhldlU2dGZ5M3NvalQxalM5Qi9ib2JoZ3ErelB1ZHBzLyswRmtCQks1ZS9hcHVXYi9OejV1UDFGZmdkVzR2RkU2YzJRTVZmUG4zcStETHR0OVhneStQZnJmVnExK3VlcXA1NnQvMEtoUytpNmV0SHh4T3EvOCszR1lhZFAzMmZsVmY0M1EvYno1Uy83NlJpZWlQMEVmN2ozcDU5VVBBOC9xY2dBcTdmUHRsODdzdDdJb09yNlQ4Q3J0aTY3ZjNzKzU1MnJ4YjlRcTk0a0U5MkdmcmQ1b2V6ZmYycTdxODNuL1FXZFg3TUNxcVg2LzdhdjNIc2F6ZjV1Zk5MMzB1LytoK1dwdzJyelZPdXhZVmZHSDlLdmlLNVhQOEpEMDlnclowd1FTbzd1MmI5VHJNNnRubWNhbFg2SlVEL1VOdDluNG9mWThzMzBpZytOTDVkL3hHMzJDcStycnUvUTBnNlhHcmZsWC9sL01ET29CRTk5UDY5Y2pHUi9mcllhMm4vTFFQZmVqNXN2V1RRbnBQRVQzdmFUanRlbG5QbTkzL2EvcG92bVgvREFHVVo2OEt1K3pxbGowenpndnpxdEFyRjU3MnJXOTlhZjFPNDB2OHRGNWZyRnNISHJNNkZWSlo5ZXZ4OWZxSXYrTFd0N1JzK2FmMU85MHZXejhwc3M5M0MwNjd4dG1ES1d2L3IrbWorZG43ZTg5ZjlkaCsxdlZzODVqMnF0Q3JVTWlMak1HU3RONFduTnZxMmViNVd2MzBmcmZ4VCt0M3VsKzJmbEprbis5MFZOaDFsdi9YOU5IODdQMHI3SXF0WjVzSFVjODRreW11dkxrNDhML2cyTU43Zm0wLzlMeFN2OVA0M243UmRlOStVWFZ2SGRvbmU1M0xpZXFINm5rVC83UitwL3RsNnlkRjl2bE9Sd1ZmWi9sL1RaK0JqL3ptaVpTUG1LL0NMNTk2MXJsdXFadjB1L29HbzhLdjhINjNQeUJsQzRPUVhoNkJ3YTMxQ3I5czYxS3VkeityM2g3ODAvcGwwOS91TDBXMmVRbzZaQXZOc29kVzJmMnloMXFlL2RDQkdJZVBuSy9DTHA5NjFyazA5ZWlacE56dGZ0ZmZrRlR3RmQ3djlvZXVDcjc0aUo0blc3MnVyNnlldmQ5cC9VL3ZsMDEvdTc4VTJlWXBZRkRCMTExK21ZT29pSDdad3FYc2ZsV3Z1cVl1NWFyNjFiL3BWU2pjaTZldEh6eXM2OW5teVZCdkwwNi9wdmdVdEg3WjY5bjduZGIvOUg3WjlMZjdTNUZ0bm9JT0ZYYmQ1WmM5ZlBMdWx5MU15dTVYZGR0NmhoazhBeThPMVAwK2NUTlMzL1lLNzNmN053NnlmWU1GN1hmYlBOSDFiRDZuekdIaGgvem1wSFYvRC81cC9iTHBiL2VYSXRzOEJSMHErTHJMTDNzUTVkMFBFVVJZK25INHA0VmZXZWFJcm52M2k2Nkg5UHZVRFVtRlgrSDlvaDlJc2oxZ29oKzRrWDdaQW9yVDZ5dk9LYUZUbGprcy9hS0Rxa3lmT2FYMzkvUDJseUxiUElYY2lBN0pUZ3ZGMFA2bjZUUDNpd2pFSlB4c0lVT0ZYWmg2aGhtUXJ6MlA4NTF5UDNjRFU4RlhlTC9vaDVac0Q1VVZmSDJuN3QzdnR2TzV6Uzg3di9TK2Z0NytVbVNicDNBR0t2aUs5VDlObjcyZmQvZ1UzZisyYi94a3IzdjMrMHpnMVZyOW0xNkZ3a2w0R3ZiQmcvTFQxcjM3L1Q3Z1pwem9lclo1VGp1ZjIveXk4MHZ2NitmdEwwVzJlUXE1VVdGWHJQOXArdXo5S3V6QzFyMzduZkNOTEtSWGhtK1FTV0hlNzVNM0wvVnRyL0IrMFgreHovYU5pdXpmU0tsK3RuWHZmcWovbXlLYWwvMTlZT1dabVY5Nlh6OXZmeW15elZQSWpRcStZdjFQMDJmdmh3Z1NyUGxSZmw0K3FIN1pydU50ODZiczkra2JtQXEvd3Z0Ris5MFVucUVmMkxNRkZJanppNjU3OTZ2d3k4YlB5enNqL3phOXRaKzNmL2IrVXB3MmIzWkVoMUJTUk0vci9VMkcwLzIrR0hKNWVIUDRGWGJscUtNOFVGNFp2L0hsZVgzK3d1ZHZLQ3I0Q3U4WDdWZkIxejQzVzhqajNlKzJlY3V2K0YvU1cvdDUrMmZ2TDhWcDg1NkM2Q0JKaXVoNXN3VkwyZjIrSEh4bDRKL3VsNjNmYWZOa205ZlNUOXk3L2sydlF1RWVQQTM3b0VENVNmdHAvU0w2dFFWSFcvZnU1ejNQYlg1ZjU5K210L2J6OXMvZVg0clQ1czJPNlBCSWl1aDVzNFZKMmYwcTdJcmxuKzZYclYrMmVWQWVTTC9vMTV3WUZYcWREM1RRNGQwdjJrL2IzN3FmZDlDVDNTOWkvdjZEdU9kcjY5YjllaDcxaXdYVlQ4cEh6U2YxK3lyL3A5SGNhSnl1dC9iejlzL2VYNHJUNXMyTzA2NWw5THpaZ3FYc2ZqdDZUVStQZnFmeVQrZmRIdUJFQjBhM3p6L2tWK2gxQjd6L0ltcjFGL1llWHQ4QTBQYTM3b2ZnL3lIcUZuNFN2clp1NFdmOWpTdXZmbWplN3V2ZGF6NHA3NnY4dCtZSDZXZHVObjBQdEY5MmYzVC9IdDdmdW9vT1BRbzZaUHY1V2MrVDNUOVRTSlk5SUR1VmZ6b3ZXM2lUYlI2VWg1VWZZdjVkTHNtdjBPc3VQTzNzYjMyaC9iMzFtZnR4dUdnL0NWOWJ0L0NqSHNpMWRldCtQYWh2QWtWOXc2dm43ODRuOWZzNmY2VFhQRlJFNjYzOWJ2T1hJdHM4aFRPUTdUV1RQWml5OXM4VWZPM29zL2M3alY5KzMrcG42WmM2OEdxdFFxOUM0VXRBaDVRUndWY1Q5TXptaC83bWpyY2Z1dDlwL1cvajM2YTM5cnZOWDRwczh4UnlvOEt1WFA0VmRoVy8vSEE5RVg0M1hETmtQM1BVelV0ck4vd1hISHQ0bjQ5MVA2Mi90ejU3UDRwL1cvL3l5K1czeTBmenZQaWVmVTc3ckVUcnJmMXU4NWNpMnp5RjNBaC95T21RUFppeTlzLzJFTHVqci9ETGhoOGRtR1R2WDM2NS9MYjRkUVB6UW9WZjZmdGxleUM2S1F5ejhFYjNQOTB2ZXhoVjRaY3QzN3VQVm51RDN0clAyejk3ZnlsT20vZDJaQXVwS0hqUG16M1V5dTZuMFZmWVpjUFBIbTdVTjc3dTgvUHkvb2RmTnh3ZEt2aEszeS9iUTFBRlgzbjdsMTh1UDJ0K2RQL1QrOTJtdC9iejlzL2VYNHJUNXYwS0t2aUs3WmN0cUVMN25hWXZ2bzUvVy8veXcvSGRYeHYvSDd6cDdCekNKb01xQUFBQUFFbEZUa1N1UW1DQyIvPjxpbWFnZSBpZD0iX0ltYWdlNiIgd2lkdGg9IjUzNHB4IiBoZWlnaHQ9IjEyMnB4IiB4bGluazpocmVmPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQWhZQUFBQjZDQVlBQUFEajdocmJBQUFBQ1hCSVdYTUFBQTdFQUFBT3hBR1ZLdzRiQUFBZ0FFbEVRVlI0bk8yOVhZNGtPN0t0WjVIMXMzL09PZmNIa2dETlFZQkdvMzVvOVBnYS9kRFFhQVJvRWhLa3EzdTZlKzlkVlJtaGg4aVYvdm1LWlhSNlpHYnRxdE51UUNBaTNPbWtrVFNhTFJxTjlGTjloL1NYUC96cHhQOS8vT3VmTHpQcHF1cjA5TG5nLzhQVDd6T3U2MTdaTmQ2N2hIdGVYbnFteXp2V1laYTZOaUQ5NVE5L092M3hyMysrUExXTDZ2NnVxdDVYMVpkYTZxUzgrUHYwbE81RFZUMCtwVDhIL2pzK0hwREh1NmZmNTZyNi9KVGZQZlVmOVcvWFArK2VlTG5VdXMvOSs0VHYwMGE2V2Q1UDluMjJlekVmOU5sVzNwMWNKaDVFWGRxVC9YNlA5Qm96YkVmMW9mcFZ6eVc1U0hVaDc2T3h4K2NmNmxaV2VZL1h1N0VxV2Z4UVYxazhQMTFUZXNybWpIeUp2TDRhYThwRHN2ZUk5Tzlya1ZHMjl5Znd3VHF5bkJQdVBkaDlMelBKc0o1am40bVB6N1hXRDByUGR2cjR4R2ZTSFQ2bVNNeXZrTzRjcnJGdXA3cTJpZGVKejdBK1crTTh5YWZLdTFUZjV5VG4xL1B0eHNDcDF2VTc0ek5MWGIxMWorMmsrN3orVUlzc1Z0VmlVelowRDl2cXJMd2YrdlRmSmswbzJCSHRBUVBKd09yaklJVFBPRkZnSGl6ZFMrcXlvci84NFUrblVkdm9YcFBtc1JaRkljTjdhajZQZFR1Z1owQUZGYXZTS2gvU1RKdVFIMUkzOEpsVy9hZlBsdEp3UStMcHRoUk5CMzdTdlpkUWtxbWtzUGZrNXdaSGZVaHdWaldXbDg2WWtEenRMRkJMSUpEM1VuOUp6cjA4S1ZjYXk4VEhRK1U2ZVIzY1dMekhSektmMm8xSy9rc3RZR2RMWnppdlB0NlN6dXBBcHNiSTU2cjZyZGFnaHZtclhxY25YaVViSDZ6dXJKKzNmZGZuYnR4cExEMXZKNytYNUpIdDdXVjNZSGcwbGhQdlZXdVE1LzNzWmFyZDc2RnV6RkRmTVkydXFVK2VRWUZuTUppMGV2MmZRZGhyS3JZM3A4NXdiczNXRzgrRnZvbElIU1hQS3JpVXQ0Z0kyd1hIRmR1cmtMZkhSUDM1bmRDeTN4K0JLeWNhSkxVRkZaVVVoYzl5OXhyc05KTWJLU3MrMDVXWGdPRE13S2NDOVB5OHoyY0I2cWdjejc5clMyK2ZrZEVucnk0ajlGU0lQdGRpRkRXT090RHB5a2lLemVYT254bmwwU2xsZithaHJyTnJBV1RsOGNINGxZejZPQkR3Y0MrYjZ4Si9ScDYra3ozTHRsSTZnbTZWVDRQS2VuVnlLNE92ZXJLL1J3QWpqUWUveHZGTW1manRLYzJIdW5vdldKYTNUemMrazhFbjRGSTdxZXhQZFF1OFJnWmNhYmYwRE9YZCtVMWpaL1MvQXkrcWo3Yy9iY1VldThCMlVobjhGdkcrMnBGeWRxNGFyd1E4ZVZGcDIxYjAzaTk4cS9SQ1Q0WElCVTBEdU96YWE5QUl6WTRHOXIzbHE2enpvSzFHU0RrWkZFZTRWZVBCbU1yanMxS3NmRjR5S0lYTmdieTFST0x1YnVjNTlUZnZVWEYwZzVoNXpOWTdLU0RLUWxvcTZNb2NYZXVlVGE1d3oyTWtJMndibDAxZlBxSWljK0MyVlNhOVkxS3lYSnBNWU1MNTFPOFpVQ0ZpM1ZnbmxmMWxNczkwTDRFZmpySGtwUk5QVlZlanJHVkdOOG8wcko5d3IrcTJqVHVaZGxDdGErZnE2eXorMk45YUpubW9LNmdVS1BxdEZwREpNcE1NSm1JWkxtY3VFOGs0Tzlna0QweS9WNGVwUEY3akJJTGxuaTE5TjA1VHZ2N01WbnVSeE10bzh1T1RIc21Ubm50K2xrdm5CQm40M2ZGMStTNkF4YjJlaW9hU01mb2FwRUd4WlV6MkNKS2UwemVWY3BmR3I5SElwWFJWZVlCczhlaDVKRU1oZmozdWdvQnZKdjZDaHNuNTdrQ2IvMDVsdklhTXNFKzlYMXdCemRKSVJueUdMZGQ3QjdpU29kRi9HaEhGVWVnWlB2Y1lyblhscEc4cFkzMDd3Q2o4WnorenpIZVZ2UWlKbUtmcWVVSWVWTTRKM0xpQjZvQWd5NmNIb2h2L0g1OCtsN3FDQzEzbnNnWU5Pdk5NYmQzRktWVEQ3eFoxZFpJMzVoM3lUbU5kN2ZwUUMzZ2pMMjd3RW05cDR1UDMvWm9iZitvWEw4TjVTSHlrQ1lQcjlwbkppSStUVGdlTnFOUFZYVm9mWSsvd1ViemJNKzJjMEQrMzgzY1hZN0dYbW9acEczOXlQV25VMkk2eVhmbTRxNWVmSVc5M2t2UGI4YzlaUVlxZlNQbU95dHppeDRObVZhN0hjSFRFWjBhME5kQzJCczVJR2MrUzkvTTkvWjBNZEZKcUtmK1UxdGVndlN6MkMrdmdNeHVmQVZVdHJ2aFI3SVZtNEI5cU1ackphT2phTzZUVnQ4Y0RNWTZwSXhrVjhhOThaTXkvMUMyQWVzRG5VbXRldXpxeXpkaWVJL29KZk5GbEw4QWhuaTVWOWNQVDU4UFRQZmYrT0hCTEFOdU5aaG9QblJIWGY3WFpiMCtmcW5YOGhjQ0c1OWZGUjZTMFZXdGcxWUVMbCsyUm5rdGdrR1V5LzNOeno4dnd0QjE0TzlWdFhwN0hscnhRTG1kQklYK3JMUVZrcTlaeXYzckc3YWo5djlGbjM0WEhvaU4zMGFUN2RxbERuMVUxNVFGeEJUNURybmpUczUyUWIrWHBsR2FLQ2RVblVyb1VBN0pWYnNyTDEvbVloNlA3ejNYYnJyTnQ3REVzaWNmVTd4cFlJMTVmbTl3QWZ3M2liSloxZDRDYmxKMnVjVWNBbjNNam52UUpaOVplQm8wTzR5eDhPWVRyd0Fua2FmWTdLNXRmYWcxQ1RyV2VxVG1vdWRSaTJCaDc0VzFhbGNkZVZlNTdWODRLMVBTZEtDSUdsZ3BjVlMyQms4cUhuaGRSQnlUWjkwbC9qRWl5b0tXUE5CbFIzZ3dPVER4NlczYUFsZGVUSjA3eVVzamY0OE1xUE1kdnB5Unp6cXRrbzh0TC85V0hiaE5tMjl6cnlMRzhaVmRZSHBkc1JzdU9CQmNUN0Yzei8rNDlGcjRiWW1OM1JFTHRWYlVHRmZyZEFJMXU0RGppWitlbjV6elBQZVFLSzVIemsvaElpRHZWajRhM213bDQyZnBtMENiTGVGZlhHUmVENFpLN2VJVDZPU3RLeUwyYnNaQTRZMDdQcERicDh0NUxyd2xrUmtDVGlpc1pFVmVTdmx4STVVeWlTL1hCZnZOYTFTMElVZjcwVWlXWlBkVzFqMlZzYVhUVjc1M25vdU9iN2RMdGNQSzhhQWpUK0R2Vm1oZWZOVE92MUE2WHF2cjFxUXdhYXJhUHl2cUNaeC9xT3V0a2pBWTlPK1RKS1kxOUdxeVJEcW5LM2xmZWR3K1ByZ3VBK21UQzgzS0FwM3ZuV29QZHNuVHY3RFBTZ2VRMzFVRjhkcnBGNWIyM3RKMitTSk9ZR1ozS2RKMGRvOHgyNlJ5YzAwdnhNZkRoWTNIRTIvUDNkd0VzdGp3SkNSUk1Mb0VNOHpXUFNLZDR2Q1Bab1p6WmpJREZhMURYNldrbVFlSDNtVkVhRUYxQTU1YWcrYXpRU1lwSkVleWpHWSszTjEzWU5HVEpNRGxmNUU5OUpBWFJrZmR4MVcxWk0vUlNXVWpQalFCa0I0cDg3Qk40TUUvS1J6S2FWSmhNUDVJVHBTT0lwRUZWZnI2MTFRMmFnQ1dWdXE0VEVLUitvK0VlamRlenBSdkZMN0ZOWmVERkEyWGN4NUo0TzZNTm1KL0sxaktOZ2p1MUhWVWVQL2JQRDdXQWJvOTlvTEYxOE9mZ2d2WDBkTW96OWZWb3JMaGNpVngyM05BVFdLWXpMRndYa0xhQ3ovMWFBcWJkRW92K3l6QkxYcno4a1Y3eXNlZEVtZUhZOFRZZy96NU9YU2M0VUpmTXVnMjcxTHJQRXEzNjdydFpDcGs4ckdPRzJJR1IzQU5pejFiZEFncmRTd1BoYTVFTHJuaEl2OVAvRWZtQW9OczZwVTJDblBpUnNoMEZ0cnFRVitXOThLZTZYUnZub09qb1hGY2xUSStKbDArak9mS21mQzFLZGZLMjY0eEMxVHBRa3ZteHYxenUyYSt6eTJYc0wvZEVzVTJwaUtuRTFTOHBEeG5MdEtTamI4bVg3blhnT3NrWTh4TnhPY1RyTHBBam5uenBnYy9wbXZPaU9wSW4vbjZvWlJubnQxcUFoc3JtTmxwdkcvRWpzQ0ZBd3JxK3d6TmNQaURQWmY4NWZyMTl2Vy9GazlybjBkS0tEemV3blE1eHNDQkR5WE1adEV4R2VTZi9JNERqN2U4NmdOY2xqeDVBN0huUnkzZXUyL0lmN0hubmw1VFNKVG51L2d1c01uN0hBN1hKK3hhNGVFNy9VaVA5VlNqRlVtekZWNlE4N05KTkkwMmNjRWlCSnpMMldVNDNFRkorcjJtY1pnUXZwZHZLa3pOR0NWOFhZT21EMFBsUTJYTFZ2cS9yMWprZUJKUm1QYWRhR3hVaWN1VXZSZWtEMnhYMXBkYUs5c2VudkgrcFc4QkVON0lITFNiRFBFdXNGL21jR3JnYi8wa2pzSkhTT0grdVFNa3JsYUdub1l5SUtDK2NSYk5OVmFiYVhRcnVvVzYzTWZLc0J2S2w5QjlRcmh0Ylg2Ky80RDc1ZWY5MFQzbGRhbG1Lb0x5K1I5ckM4ekpzK2kzanh6VFVKMVZyWTZpMkVHajVyYTZBNjFMTG1ORk1VL2twaUpKTFNKSjVqYmxmNmpZMndzZVRLUFYxQXJkSkh5U2c1b1kreVQzSGZESzJCRFQ2TDVuaTBwajZYcktVenRBWjZVbDZiOTdWN1Fta2FsTVpaSG1ST3FCRVR3cVgvNmhqT3R2aEhxelVKbnpPL3ljUXBiSXBZd3JJcFh4TFBrWTY2bGt1dmd0Z1Fabzl6bnYyK2VvUlhrb2o0bHFlaU1JNml1aDFoZjVhd0NMMTVSWVBuZEh4dEc1VWFPUTdoYkNWTncyN0J1VElBMEorMmY1Y3pxQlJjS1hoZ0ljRFh1NWl1YUpwZkh5UHR5dUJMV1dhNmtPaW9wblpPZUJLSWMxNE9EdmE0aW1CMFZPNHQ3VWNkcW8xd0JEeGNDYnZpNjYrTktyMWxJNnphVjJUTVJXZzlIZ0tCc3B4U2NQalB3cnBLTk1uNUNFWjRTRlhuSjFxRjR4NFV4MTF4b091cHpMOFEwUEFKUjA5SjhEQTh5Titma3IzcVJaZzhSSHB4TGVNeDY5MU85NmNmL0hBY1pLTUZ3ME93V1FuY3o1dVhZK2twWmdFVUZ6MjFTNGN0N3F2Y3I3Z2VjYk1PRkRTZndKY24wU0t1T3pGU1ZJaW5yeEtZNjEyVkRsZjdEblhPM3FlOXhPcDdrenZPb1R0UnpEbTQvTmR1SmJLK3o3T3NSRGhIUmVpYWFNOCthNkZoTUpUR1ZSNGV0YnpVcnBrR0ZPNmU4a0hHT3Z3bks5NVkyWU1ueXM0RHVaT2NXd1pIdDFqM3AxeExxUlBTb2N6bVU1QnVmTGpJTmJBbGNLV2t2YUJUc1hEZFgvMnZiZEpKNlBNODJ6UGJWRlNnQjJvRTZVbHEwNkJNZysveDQrNzE1M1laZzRPdkcxMTNmc3R6Y1llYTFuLzFYK2xwZkwzRXlkVmo1Uy9lR0M2VTkwdTBkRnpvRm5ydTFyendESmNMNlFkSjA0RTdGVzM4U0dVVWMwb1JUL1hZckFlNitxQlU3dlFpNmVsRTQ0WGprOEgzaVRLSE9WQzd3K2luQ1VYdjNzWDFQYXVXNXpZOXQwNEoyLzBoT2w4RGIzdmhJQ3ZrS2ZuUVI3MVRXOHB2VjhuL0JmUUpROCtacmVXSDA5MnovVXd2MG1VWjY5bm90VFBpdFZKOTN6c2orajc4VmpBS0VhbHZlTkZaSjVISWhmeWhQVDBQK1ZGSVpHQ0dNM0taNEJGTXZnSkJQbEFtTTFmK1NVZzFBMzhUdm5NNWt2cWhIYUVzbWtBcEhUU09xb0hBWjVxdmI2c3ZLVWdPYVBod1VzMFl2NnNFTDc2MkJYQ0NjK0w1OFN2VTVMM0JGeTd0azlncXdNUzNYODNCQ0ozblh2UUhPV2VJTkNWb0xkRFozZ1VjOEVsRXRhcm50TEl3T3BaOWwrcU8vdUp5d1hxVS9HaTYvK294YnZGdXFzK25qZEJWaHFURHJURXAyYkJuK3QyRmt2UUkyK0Y2cW5Belo5cWVZSFlQNTQrU2ErSkI0SXk2Zy8yS3dHQzJrcUFUOHVKREVCTmJld0JwZDA0Y0hseVlIRkNHclV2NDJyMFlybXF0VHlRSDhrVDAzaDdlRHlQeGpqN2lsNmxzK1hsWUlYWFNENnVSU3luQTMzK0RQTkxFNHNVY3lKeSs1SEs2R3pLcWFwTzM1WEh3bWhvTEFkTEh2cTlaV3c3UStxSzNodWZCc1JudUV5L05UUHdNamxJM1gyZURNMEQ3bTI1SmxrdUJkaVZKZmxPdkk3SVVUa0JRWmMrOFpZVVkyckhsSitNQkYyZ0FnOGFDdzlJNHpNV3RyT2VJVkI0ckt1TE9SMXBMQ0xvY0ZuZ3Q4dHJXdFpJL2Q0WnI4U0xYKy9BSy9OT1BMb0JVVHY3R3JyUGFGTi9Kc092UGxDN015OCs2M0VkTk1hcFBTWGpMdk5hMXFBaEU5Ky8xZkltVDhwRjBnV1VOZkhpQ3BveXhtZFp0c2NGc0J3WmMzLzJaM3ovWXM4UVlEc3dJb0JtZklzL3cvRlR0WGdIeEFQYndKOFQzeGRMNjNVUXNiOWQvdFJmZkxacWlYZWhwMHpmQkJOSkRsVm5sY0h6S2RKWkZlb1RqNzF4bmxoZTFXMlphZXlMbDlFRUpBRVl6elBkY3p2aStmRzVCRnhJcXpiOFhvSEZsaEhab29TaWVWMi9xVnkybnZjT0k0cGxURUFhTUZ2RzJvMXhTa2RlVDdXZWZhZTZKbkpESmQ0N1QwdWlOS0JjRVZEWlZQak41NzFkbUk4cjJjNUlzVjA0U0gyOVhRcGNoc1dObU5yRWQ2VlVxSlB6VHhxNWM1T2g4YnA1M2dsVStMT2RYUEY1L2ZmZENSNWZ3Yks0M09IM2VEQ1dnRmVhMmFlbEFza3c0eWM4dlN0Tm4yWFBHRGdIUlJYNDFoaFFmVGtiZmFpcmgwQ3ZOcWRoSTFoaEd6M2dXYjd4VkVzczVOUEJCZXZGTnVQNDVFNmFxclVYemR1RHo3a1IxdlBVWCs0TlVyNWVSalcvUjNxTzlYSER6bnpZaDJyTDkvYTh2cWxmTlluZ2NpU2ZjVmxpbVFsQU9zQ2JHWU1kbUVqVUFhK090c3BJK3RIYnQycGR2MDZIVlhQdlV2V2R4RmcwV3o1am1zbGd6b1RPOU5zYmk0TlEveDIxZCtSS21RRllGUHFxVzhGeE5PeENYTFVZUlJwYkxndHdRSGhkRTZrYzVwZjQyWk1mNjhYZEhKd3hKc0YyeFU5M0pPOWRLcmRSa2hrUEFQUTJVejlyTFZzS2srVVFGS2d1ZWlPbGxDdUJTbW9UOHVyOVQvZHZCd2FkYno2ZmxNTFdUTVAvdXlIMlpReXZSL29RdkRuQVMzWHp2dlArbEhIbityWWJsM1BkeXEwRFBvN2xzclJ1TkFraXVlT0FIaWtkcWUxNWN1eHA5dThBdzBudDQyMTBxaVdXd1FQc0pKK000ai9YRXNUcHl6bnMzeSsxNW9kdFZFaXZhKzlybVpYVEUzVEIvNlNuT29PYkRCdjdpNjlrZDMyWS92c0JaZ0tsRE5na1FISStSUWxjdUw0ZkdkL09YbTNwVHRleHpEZUJ5ZEgvcnV5T1QwOS9DdmVkdDZxOGJISXpLL3FtYUNkWWlBZGxQWkVqNXhuMEoySkRVakNsY0dRSTByYkVSM3cwOEh6R252alpvOEE1c0J4b2NEdFRWUmErRVhIYlVUVzgrald2azhwMGcwa0Q0TE4wNXNjMVZDNC8rQ3g2aHRMQTRScS9ESmNpNlQvVmJjQ2JGTGFpdjlsWENoVHpRMlptWlU0RC85RStCSktwWGIyY2U4cnUydERCc2RLcVBkUStuRm56VTdXTUJUNnJjWlIwRVBNZXJjVTc0Rk5aZlA0Y1BwUS9qV1Vla2EyODNYaWZhaDJiNCtkYThQMG9lcGI5d2JIUCtueXA5UmtZenVlUFZmVmZxdXAvcktyL1dsWC93OVB2LzFKVi83bXV5eDA4aEV2bC8xSlZmNi9yOHR4dnRkWkxITmZVTmFQMjlhUFRXUWZsbVpadEhBQnpQS3NkZlJjSHYvM2dLZWJ0NEoyQTdsSzk1KytoYnV2blFHSUVwbE9lbld5N01mYm5uTWc3eDU4REE2V3RXdWZmNWV0OTRPM3MrWGhlSGZDNDBTL2ZwTWNpQVlxSk15WTY4a2JqNzVGQlNoM0o1MzNQT2dYZGhWUUlXYytuSllvSzExeUlrMEFUN0hpUVdwcHBKdXJBZ2dPWHFuV2J1SEJ0SVhMV2llbkpwOGN6dUdKbVBwM255Y3NiSVd4WEhQNU1Va0FpNW5tcFpUeDlyalgvem1PYVNhUTZKQ1hDV2ErVXN3Ty9VOTIyamZlYmw4RnJtdUc2WExpTXVWeTUwV0VmZS9reXdyNnRUcytxcmJWVTRMc0MrTlpXbDFHZnVmS2VhTFRVcEhzQ1I3NXQ5UUhmYWIrL3hqLzdWVHNHQ3ZmVmYzcnVQWjRqV1BtNTFqcy9sUDZuV29KSmY2Z3JrR0NabjJvdEQ1MHVvUUVVLyt3emVndmQ4OEhuS0ErdUQ4citjK3o0OGlUQmh5OVRkdU5GdW9NZUpWOVdZaDNjZTlUcCtTMTlsdXlJbjhHeVJhbWQyQ2JVaWQ2dUNWQ001SjdYdWV6bHdhWWR1QmpsVzFWWFcvM05lU3k2dDZqTmdJckJpWmtpSHdpSmtqSlB5bGN1Y0xyM2ZRYm1zd01DRGplU0hhaEluNjQrVXRZMG5weEZkT1I1OHNPNmVEdjRBRlRaTWdZSkNQaUhaVHBnSVZMdkVQc1dhUEt5R1pEV0RSN1dML0hnei9HY0FLNkZ2ME0rSTRBN1U0L0VVOVY2R2VkZDNiN3AwcDhkS1l5cTdEV2kxOFFCbnZMaExMc3pZRjRYS1NpUFdlRjlqOEN2eW05TzllV2p4QXVObVVoOXh6WmtPaHBsQjZUY0NlU2VtdFFHZWtzcFBXOHE1MFBkSHNPdCs0OTFCUW0vMXRVRDhmOVcxZCtlZU5kNUZEbzlrUUhGS3B2QVJ4LzN1cGFsOThPa0pGUHl5TG51WXo1cC9ESi9BblRsNmZyTkFZckxKZS9UODhJRHJKSm5VLzFGUUVpK09uSTU4M3ZwZDlKVnpudTZyOSt1RTEwLzZyZTNjOUxQNUUvOXIzYlY3cU9xVzFub2FLaHpYK1N4Mkx0VXNZZVk1eDVQeGVSNUZWVmpCT3JDNFVpZDk0andDVERjS1BOWmo3VndmdmEycC9LUmdFamgrUmFyTGVyY1k0VnJTY0NKWUtrb25MK0U0Tk5NeWcyNHluQmpNZHRtZXNZTmk2K3RzazVWdDdMQ21ZZ3JVbmRyVXpGd2h1Q3lrSGdsSDUzeGQ0TkpJK0ZLYVl1U290THZaS2k3UG1CKy9LWmgwSFVDQlFKaEtuQmZQdk9nd2NLOUR1eXlIZzZXdkg5SU5KZ0VONmtPYVZMZ2RXUmdweDh6clR6Y2ZhNTYvbExMVW9ieWZsL3JKWnFIdW5vd1BsbmVTWjUwelYzczVGZjNOVEZpLzJrcmJxRU1CM2JKWUh2ZnFHMmR1S3dtRUtiZlBtYkYrK2RhUERyNjl2b2t6MUlIUHAxbkFwaXRzVVhRNlhuTUVuVUc1ZGY3MDl0MGl5L3ZiK2txbGVQZTlaUUh2MWUvWmJmdkJoYnVIWGdMY0NGNndYdENYRG03c3A5NWptaVlRcDEyU3JoYjJwOUxBOTVwYnp0S0dLUUVQaG5QczNta3o4VysvZmRvd0xpZ2RnRENoZGp6Y2tYUUdYMnZUMEw2VE5zdFIzbVpYcjY3VVJrN2NMYm5DVGhubGRLb2JrbVJ5TWhVTGFBMkdRblAxNDB4NzNIM0VvR3FLemszdEFRbG5PMFQ4RWlKZVZzUjdDbXY1TW8rMVZwcHM0MGN2QlRTc0YxWUorVk5vSEcyc2ozOWFLTGhkV1dkRk1EcG9FcG5UWENMSndHY3gvTHdmSkNQdFk3UDhPVlFCMDArbHJxeDUvMUpvSlBBbU9zTjhlUDlSTkQ0QWRkcGkvU01nSk9Xa1J4USsyOENCNEtocFBjZElMTS9FbEJsM1ViTEtBVEFJM0s1U2ZkbzhMdnh5anhjWHlYU2RjbWJsdk00cVZTL2NIbEt6M2I2dEtvV0cvM05MWVU0RFFJeTc2RVpRTkdsVlVOelpzcDRDaGwxRDE1aXZwNUhOd3VjSVIvNEtsK3UzV1RNTzNMbDdJT1FNMGVXWDAwWktqc3ROL2pnOW5adzBKSmNjNTFDYzdDVEJoK05rcTZsUVo3NlJXbDVBcVFNUnRYaUpxWUIrNERyYVZuRmFRdFVjRTNlRFlSQWhzcmtETmk5VVhRVEp5WEtZRUJYYWd4eUZNbFRKVU1uVi92SFdydk5lYUNTeG9xTXVtL2w1VGh6NDVBTUhRMDd5K2N5NVE5VzkwSStNdndPR2pxQTV0ZjVuQzlYTVFEWWxiTithK3gyaHpteFhUakd6N1c4Vk14anZDZ2JDZlFSTlBKQUtCcFJQVWR3eG1WRnRnYzlQUnduYktNUFNQZGpMVXRBYkRjQ0lPNDQ4YkhEOWhRUW9ieTRMblNkSTZJc3VONzNOdXpHN2l6UkcrZmU3Yzd1cUw4cTNFL2dPdWtZbDNlQ1Z2WTdRWFhaOHk3YmJRVmZoVjdocmFPdnRiUXlVdFpWMllDN01wOHg5RlJpcnV6OGVTcTJxZ3d1bkorUjhQcDlLV2NmNkh2SVFjOElkVE10cjFGQis4eHBSamtUVExqeTEzMDNoQS9OZHlxTGZIWnRub2o5eUdEQ0UzNG50NnJXMUxrbXZkV25xYzBkU0lpWExWNjVQT0pLMFkyQWZxcytBaWNpMzUzaGZlSFBTa0g5VUVzN2FWdW1iM05NUU50akZkeVk2bG0ySjEzb0JIYzhySTViUXgvcWRtenFIZ0ZPa3BVSFMrTnR3UmdKMWszUHBoZ0xqMDBpbUNSWXBOSFZVb1cvVUl4MWRBUHF3SkJ0d0RJSVJyajlXdTNrNDk5M0NIVUdtdW1WbGhNUjcxTjVkTG9KRTJOa1dCNlhuRWM2a1hWTllLNmEzK25lbHU1Vk9leHY3dy9LRVFFRnlZR25nMy9YazRrdnRuL1hUZzVJdThuUnlSKzZtOTdnaFdEVGVRMmVUWTJiQmx4NkxqV3NYK01nZk1RM2pYcjZLQzhxUHBhUitIZGVxWmlxRnVVbFZFL2dNZ09PU0NORHIwRXJJZmRCelBSVXpDVDNGSWdTd3ZZK09GdjZoOHFnSmcwMFh2TXlIQnlsK3JqaDFOWTN6bkNWejZuV1NvN0J0RldMUjhzRHh4ejQ2SnJmNzlwSWJmMWpMVkh4N2puakdqL3pKUkRqd1dEaW1XY2hhSjNiMTlmVlBnSlFTcXY4Zk1raHVmczV6bnc4cEhIczlVanRkS2tGSEdtY3FIMDg3d0pmN3JYaitSa0NTVlVMZ05LUjIvUzhVQjc0ck5xM2FnMDJhTkRsZlNEUGFsZUJDT1ZQTDQ5a3k0MjRTSWFUWTVmTGUwcmpSM0svcnl0QVpEdjRVdElKZWJIL0NCeXFicjFvQkFCVmEvM0kvblF2RFB0ZUg1MysrZkdwRGovWEdxRCthdlhpa2hUTEVSL3U1U09nb3k1VSttUTdrc0ZYZjM2b2E1c3lmb2E4c0YrVEhuT2VFeDlwclBqNFZ4OVF0M2JnTUgzZjBJdUFCWW1HL29Xdk0zK21tWHdHdXo4b0NFa3BKVXA1dWZJU3l1U2hTTzZ1VlhxUGR1L1dRSFhQalo4TFB2bVVncEp3K2xzVTl3UnVkcURLRmE4TGNScmdORFNlYjFyeW9KSnpBOExyWlhuN29QZHpFODUyUC9HWmpIc3lWZ1FKOUFMUVZhOXJuU0Y1aDN2cEZmRWk3eTlYU2tyajh2MVFpM2VrYWgwRDFNM296clUydkR4L1EyVnBDNk40cDF6NkZrRE8wdG0zajdVR3dTSkc4THZDZGtxZ0l5bHVmUlBnc3IrcTFxNS85WS9BR0htamtsVytxbWZWK2xYcDBnVlZpN0pXWFR4R2hXQmE0SlRMTnA5cmVUMzY1MXAyZkhDNWcvMnU1MzJKd29sZUdmR29OdmNZQnhtYnFrV3U5TlpVOTBpcURtVjVpSHc4KzFKVGV0YU5uK3VPYzYzelVSMisxTExjSmNEeTdvbDN0WjM2Z1lHalBpa2hmNzQwNEI0enRtUGhXcEpQQW5lZTJFcnc0R093QXpDZDd1akFnSU1vQnlrZlFucnEwbEgrcE5PckxJVjBXMFJUT24xMHJRTVByeFJQNFdpNWFneW1mRFkwVXZKQzhUUWNIT2hkSG54ZXFOVm50cWs4R2xJS2hOeUV1cDZXVnJZbzFUa1pkL0p4YVQ1TXk0SEZBVVczdTlyQjEvejllUUkxbFVQWE1aOTFGMzhhZ0tPKzhZSE5aM3hiSVdXTXlvWFgwdmEya1J3bW5wUm5xb2ZTY0kyZDRGVDNDWFNwZUwyTlpYUVljOENZQ3dkYkQvWU1GWkh5Zm84OHRMVlNXeTlaTG1mMExvK3AvVndXdlozb2JTRkFJdGlpcDAvMzN1RS9RUXBqWlJ3d1VBOHczWHRMUXg1UHlLdHFHY3RhUXBJbnlIV1lBODVPYmwxdlVJNlpKOXVGL2NGK0VYOXNYNEkxam9WTDNmYVpFOVA0RXF3L1Q1bHovY0EwQksvMC9GUXRja2NacG1jMXlaR1ArYlFNU0g0SzE5STNpYnE3YXQzZUJDek0wL3VUMzI1RC9QNUk1N2xNVUQrenpWbU90OE56KzczWkFWbStVK1ExWWpBbThuRkQ0QjN1djVtMjdMOExpcDZSY3F4YUZCRHpHT1ZQQmNzbERLTEpyVUdvKzNSSjZubDNNZThoYjFmbkp3MlFoRnhkc2FWNmRjWS9yVVhyV2JtRTJjNWY4Qno3ekJXNG8vV3Q1WStxMi9WV255VXFIK1h2eXpQTWl3UFhGZElXSHlrdmxaMSs4L2hqbDAxWEhHdzdseS9XUmIvMStta3VBN3BiblczR0dJTENiNDlwMkpyZGJpbEUvbWY3K3NUQzY4cWRJS29MUVhxUzJmZDFLdzhPaHF2V0JzNDlDaTRQNHZIWHAvUUNKVXI3Ry9oaU9TNnJ2clRuTXVUdDdPa0lQZ21ReE0rL1Z0Vi9yM1dRcFBMaStQUHhsc3BKei9FYW4zSHdWaWpiSjNFMGtPZGF2RDU2OWxPdHQrcFdlTDVxelVOcUs4bE1WVjZpY2VKejZsZDY3RlFYMTJWVmF6blQyQ3RMUjdsZ1BpTWlUeU43eURIb09pMmxIeXEyVFNKNDJBTWMzQnN4RzZ2UnZEcTk3RnFuZ0NqMFNqY1NoUFM4Wmc4LzFsb1phVGNHM1pDNjc0cExMdXRMTFcvQ0xEeERJZkg2ZUIzSVc2cmZxRzVkZjNWQWdtNUhOMFJNNDhyZDY2QzJFTGh5cGVoTFFoZmM1eUI2ai94bzNLbllxM0l3V1dvYjU3dVRKM3BiZlBCdXVTd3Z0U2cxR3ZsTDNaYVgybEgvdlZ6S0d2dEFJRmp0K2dsMWNOQ2gvaFh3OVFqN1M2MWZDaVlGblF3bDVWenRvcnhwSEhpd0ZQdGZmQ1VseWJGWWRSdmJWTGp2czJzM2ZBeFkvUG1wVGx6Nm9keHgrZU1qZUZKYnFtenBnUWQ4MDlpNVhBZ3dzNDdjamFNNityampVZ0NEWXQxenhyWjBjbDNqTTlFZmFqM0xmMWRWLzE3TGErTzU5Smp5RlhXL0V6L0ptRjVxclMva0FSVFB5cGZ4UDdyR2Q3a1FwUHhhMTNiVzhvN0xTaUsyRDh2dzE5a25ra3h5V2NYSFB3RnhlbDQ4cFBleVNDZFNaaEs0OEhIaW9JWHR6L040Q0pJVHNDejhQajI4eEpQUWJRVjFZUERIdi83NW9vL25jU2Vvb1BKS0g2L1RLWHlxNWtDRjBuRkEwNjNOV1J0L3UvQzV5NWh1UC9MbGhtSGt5dWQvdno4aWI4Tmt3THJuT3VDUkRDRjVZUnM2ZVo1c0g0SU5QcXRBdFJUWTFMbC9VMzM4bTJEUTI4Z0JWZG05MUFnL2YwMEFBQ0FBU1VSQlZKNU15OE5vVWh0MC9VYStPbVZCK2RSOWQzVkw5cmpMUUVaTVBDZ0d4TnRYOFJjS1h2VmRJZ1FnWnp3dmQrOFovMytycTNIU08xZTZhUCt5YTY1OENhakVDM25nbGx1T1M1L2wxaE1mekMrTkI3VVB2WXlQZG8yQVVVc2dsRS9tUng0SXp0Um1haS9sNmJzdTJHWmNKbkJYZWhvL25heFJycjg4dFl1TWVub0ZmWHFXNUtDRjFIbkwrRnduRC9SNktYOGE2a2Y3VnB2ODlQVC9ZK1crOXZva3Z0VFc2bHZLbEJ0dWZ1czNKMFUrR2FFc3NOemtKVTBmanVlUkhtZC84SG1PUmZVM0FVU1NKYy83ZERlb2VDM2FDU3lvMEVZMFFyNnJqaHQ1VDh3YncvSzFWMSt6RFk5MFQ5SGx2dXdrNVNGVVhYVzdmcWU4aUE1cFNLdTJqVTRhck9LTkxxNE9QWHNaTkZxZU53ZVk4a3BLMVlFZzA2YWdVNStCOFJuK3IxclBIamxRK0h4bm5QVTh5MUc5T0tOaFhjOTJUZm16THhuUXlBQzRFUUNrUXVac3dnUHp2QS9lMVhwMkp4NDlxRlF5NTZjVXVwR1RqUDhFWG41QlBlWEI0QnMveWJzRHJrN2V5cTU1SFIzQTZyZlhuL0xtU3k2K2MrcWgxck5ndG9YU1VNWVk0Nk8yWm52Skd5VnZqWUlHUHlHTmV5Z29tOVJQRHFBcXBGVTZMVmRRTmp3R0tMVVJyem1JVmx6SCs2cjZ0NmQwMGxuL3FOdXh5cjUzUFZaMXV6U1pkRFNKK1VtR0dCTkUzWFd4ZTJ6WDkzWDFNQXRJdksvcnNlZy8xdFZySWZCRUQ0enpJRDZvczlKU2RnY2dXUWZaQVQ5Z2tjOTNla1Y1Yy93VW5sRjkxVGVqSUY3bDYrUFFlZkp4VzVZK0FxK3Y5aEt5bWRNNUp3STIyU0NkMGFyS2plWnA5dkxBd2MzWmd4OUpLNFhqVWI1RWsrcjRCNlQvV092QU1hMEhjcEQ0Z0hMK1VpZDNxSmxibVp4L1QrOWVreEZpWlpwdW5TOFpscTJabGJjbG42Vmk0ajI2bmdtK1BCL253NE1jeVIrZjdXWndWTlJVckE3S2trTDFmTnlvSkFXbXRBUWhETTdzNUljQmVrcW5PdmxTeVpkYW9zYTFFNG1LTnNVbW5PM2J4NlIvcDM3bmY0NzdCQ284UHorS21yTENwUlNCZDlVaEFSenZMeTVQY05lUGV5VVZsNkx5Q1Z3Sk5yWU1hOWZubE1WTExXNy9idXlOaUVaYmJmQ2hya0NTUzNqeVhsQW1DOS9KSTZmOEUwRG16Ri9wV0Q4SFhoeXJBbFFhcDJwcm4rRG8yaWZjNjlxeUk5Y3BDUnlSZC9kZVUrOGxuZUZsTzZqdzl2RTBGL3QwK1NaWjZ2NC8xdHJENHJ3a2VwMWRJYk4wNzdJTFBBWlZXZGhJblRGOURhTHk1U2w1M0hMNkdLNUxHZjlVMXdDb2YzbjZyVmtObFZ2VklydzZZSWtDeVptVDZraWpsNGhHaDhoYjk1eUl5cmtiUUcyUUJOaHB5MGpvT3kxNThGNml6bHZDd2U3M3VZUEVYNUNXUUpUTFVWcHFJMytYV3ZPZ2Z0RnZQd25UeXoxdGZMdzhrZ01aS3M2MERrb2VOSE5YZ0o1dlA5VTlHVjZYTzNwR2tvd1VyaEhna0hjSEZ6TUcwWlU2bGI3UDhzL2hYZ2ZLdkUrWnQyOEw1STZUczEyalI1SkJyR2x5NUlhQS9kZ3RWNUkvOG5YR3RWbGdrY0Nnd0VyVmN0YUN2QytxcDQ4VlB3ZUZlb1J5NlZ1M3E5YXk0M0xrdkJMc1MwZHBsMUZhY3RIeUd5ZDhuQnlxM3AwdFNYSk5mY3h2L1ZiOS9NQXg2bm1Xd2Q4Q1lDeWZ1NHhHL2VxeFFZblMyQm1OdXc2a0poMTFxcXJUVi9OWTNFc2h0b0tVR3U3U1hHY2VVd011QUNFcWVGL1RZMXAzSjJubThtTmRRY1dscnRIVmwxb0FpdFl5dVhQZ29iSmhHRkdxT3dkMTFUSkQ3WXlPMHJ0N2NZL2lKKzh6QXQ2NXdVaytTM0JBd2Y1aG5hbHNOT3ZtV1JLRjlHblF1L2RKMThSdkIzUzlyU1EzckV1cVh4cXNQZ09SL0NVZzdXdk51cWIwNmxlOUwrQ0hXcFFSdlJnMEdLcUxkQVlCeUsvSTB3TVIyUmFkYkc3MXVWUEtLODNDUEYwQ3U1VDFoMW9PVVVwNUV5aVNOMTJUMTFIdHdKMGc2ck9QdGJqZUpRL0tQeG5hclRYdHduMENpcEczY0l2a0FaQW5pZ0NLNDBIeUlmMzJVMTBOK0FPZWNiMHRQdFhtdmcxYmFaSmMrQmgvVjh0MlVzV21PTUNuaDBEdlZsSDc2LzRlN3c1bFFRYWZZNHg5cURyNjdobm55K3RXdGZZaXVwMGVqU09mZkxqdVlCM1NtRW5sSkNBK1RQL1ZnTVVmLy9ybnkxNlBSUUFWQ1JpNHNTRjV1cHZ5SjE2djdzK3pBMVV1NzNVekJTa2JSWlQvVUZjbHB1QzFxclVDWXNCYnQ2U1REQS81MXpNK3k2YUh3T3VwNTZWWVBOMldFZGhxSitldmFqeXdPeVdUakMvejRveEpnejhCQUNwSlBWKzFkbWY3bWpGQkN3ZG5jdmxYclEvUjRxemRBVkZWZjRhRCtvUzhFS1FRTUxBc1gyZm5Xcks4T0hKM25tclpUcXJQRDhoUFNsTmVOQUlVZ3ExdXVjN0orMjRhOUlkMEk5M2krZnBZa1l4bytkSGQzYTVqMkdlY25YTHRYYytNWnFzK3MzWjluRHlSeVRpd2Z1bE5yT2w1a2JjTGx5cDQyaWNOb3V0bHRaMWljVGltT0RsUkhFdlZ1dDB1OWtsalRQL1pqZy9JVS9tbmRoS1B2OVhWWTZ6NnVEY3JBVVp2STVFTVBubFYyM0MzRk92Qk5qdlp0WkYrNUFUQmRSN2JJWGtFcTliZ2RaYW93eDJZaUNmZUoxL25yK3F4dVBNd0xPK0lzMTBYK2NEWGR3SUpIWUpqUnduaEpvTk4xTTBCNUlaRGFSL3JLdFIvcTBYWmNEM1hGUUVIMU1XdTZ6KzNBdWtlallicXdlaG96N01EUUo1ZWZLYm5ScUN2UWpvOTc4OTFMdXF0M3lMM0Vua2YrK3lCNXd5a2JYUDBlbHpxZG51ckZHTjZoa280eVNJcERYbzNhS3lIM3hlUkx3SUs5N2FvdnNwRG9FSmJRLzhHdnQvak9RSXQ4YTAyMUV5Vk0wWTNGTXJIZ2FhREk5Wm5SSjJzSlNXZDJsNWx5eUJXM1o3RTZMS1lybkY1cldwOUlxL09UNkJPb2JlaWNGMy9VeEFweSt2SVphOGo4cUwrNytTUGNSQSt2dVRpVjl0S3h5a29rc0NLSkxDYUFrQTluUnNzTjlqaVJXQlk0NXZnUi9MMXFSYVF6TGIzb0d6S28vSVplWTFWaDUrUVhrZUtLejNsUysxQzNlSGdRL2xTRjdNdGxLL0dyT3BCSGp0OTZYYVFZM3RHOS9LYWc0cm5zVCt6dytKVjZDOS8rTlBwZi84Ly80K2IzL3IydFAvYi8vSy9VbkRjUlYyMWJrQkh2TW53VldYQnFGb0xxZWNwOHZXdHRLWW1Tck1GSWY5UHRRUmxjb3VhRzN4SGlnSXZMRSt6cEo5cUhSd29oRTZQZzlkbjFCWnVER2tra3hKaW5qNFlQQzBWcmRZZ1daYzB5RG8rTzBDamdhdDA3bkVncVBDMlRpRFQxenVWam1Xbi9rczhleGxkbmNyU1ZxM2JKY2tuZ1l4SGhYZkE1bHpyd0dHNjZBbGVDYVFJTUU1SXgvOCtBVWhBd0dXdEc3ZXBuYnJydnI3UHRFelAzVFB5MmpCWTJrR1JrOHNUeHlSM2o5Q0FxUC9vQmVBT0hnZGpIWGdpalhTVWt6d3pmT05yMGpPRk90RDdwVHdrRzZvUHZSdmFBZk94Rm1QSFhTc2FlNy9WTFhoeEh2amZQWG55dHJrSDF0dERzaWs1MTJtYzZuT1d6MWd5dFFINVNEeXFIVC9pR1kwWDZoakcyNmwvSFZpNFhtQmEvYVozUmYzb3NUL2trZkxRalNQS0xQbHhjcDNyNEUxMEdTSGdsdTU1QzJsYWNwZzRtWk9NajNqdFpydmV1RFQ0V3lBajVjWEJyeGtLWjdZcXgxOWF4UHZLUTBKeHJ2VTZwc3AyQmNNODN1Rzc2anBvdWFSU3RYaEZ1cDByTTIzZ1N5Z2p0K3lXTExuUVVoSHJHbWNiV2pQVk0ycVBUdUJKRGl6VVZqSWlyRTlhYmpyYmM1d3BrVStsdnlCUFhxUHNzUzA1YzZsYUQvd0h1ODU4NkRWZ2V6S05RRUh5bHJCZnhaT1VMNVdxeS9TUHRTaGlCU1Z5MXFUbkhtdVpyY3B3VUhsUytTVmwxODJZMG4yL0xuNTVmRFlCcnMrNENXcXIxdWR0cEhaTCtvVkFRdm45K0hTZjQ3cHFDWHFVTE1rQVU2bC93clB5ZkxoSGs3TG1mZThHaWVsWjV4OXIwUm0vMUhyY3FUMjBwZjVYbE0reHk5T0hMN1VjR2xpMURrZy8xL0xxQXgxS3BRbVc2aUhaRXAxd1hXMm1OQm83aWxYN0JkYzduYTA2cVUwMVB1UlJrbmRCQUp1eXBQZ2gxbFg1SzYrZmF4bFRqSTNRaHdIOTdEUGw0MTRyanQ4RXZGV3V0b0N6ajF4bU9ZN2N3NnJ5Q1d6ZFZqakE3dXcwWlhSZjhPWnJIY3M5eUxQTGZ3UmdmTGJJZkRxbE1BMklMTDBQWWtlRWNrbTVFdmZmTHNodU1HODZLcFJmdFFRdVNablRoWnFFaER6NFRNWGJKN1VieWZ1dEF4ZEo2WjN0UDBFWDF5ckpGdzI5bnZOK2NkNjgzZW1PcGtGTkowQ1dQU3ZYYjlWYVFYZzV5Vlhyd0lBZUU2Y0VmaDI0NkpyYWk0WWhHVkhXdzhlTDBuT3BSM215VDlUR05CcGMxOVVPSjgwS09Udm45K3pZODdaTllOakhBMG5YVks5UHVLNitad3hCQ2lJYzZUdVd5enFxTGFxdWJhU3RtbHpxWU55RjJ0YmQ3ZW9qenBxVHZEdVB6TS9IRHZ0RSticTNpZDQ1eXAzTHk2UDkxMGZubzlDN3FvQk82U1RxUkJvMTFwTnlwMzRpQ0JOUTdZaXlvUmlROTNXVmc1K3E2ci9WSXZlTWk2R25hNlFIZGUxY0MyQVMwQlJvbzc3bitHUWRPU0c0MkhWUmtrdVdMNzZUN3ZCSmdwNm5QS1M2VmExNVNLQk52UG80dkcrNzZUMHZDSnM0ZFRNWmJEZElwQVFvU0VtUmp0S0xoNDdVaWNyRDE3M29TbFg1Uk1zSmpLalRKWXdmOEovTEEzeGVzMFo5UHRYdEd6YXJNcWp3Z2VNRHlOdmM2Myt5NTFMYTlKK3pPdThYYnRWMUYzUjZqblZNZ2srK1pPaFVaOTlTeVVOenRGMU44UVo2bzZOKy8xVFhXWklNRW9QUXZMN3VpaWVmWE5OUGdEY1pmaytibEwvU3BIN3N4aFhiVEc1cXlUWGJRdjBrM3JuMVRWdjU1RjNTTTNxRnV5dE9ieXZudmFOdTdLWnI3cVhqVEZEOTh5N2M3eVlmSGQvNkp0RFM3UEdYdWwzeVZKdW5yWm9xUnpyaGJIblQ1YSt5S1dNaTZoeWxZLzZxdC9TRzByekhSOEJTci9ObU94QlkwQVV2K2RGU3IvTFZQUTlTNXltaDhyS0piNElLZWhhMFpWOW5nL2k3TnBLdXAvSDc2U21mWDJvWjEyd2o1VU5QcjhiR09lUmJTTy9nWHdETEEzYlpsbWtaWnpSR1hGNzhCWlF1QzVJNTEvZk1pMTc0Qkg2Nk1aZnM4VE4vbzRIOHFqVGg3WEFGN0lpUjE2dDZvT0NEM2hYMEZnK2lFV0JSV2lsWXJwOTVHczVPaVJBZGVDaGRFbWJseGM1M2ZpaFlFbFJ1L2FNZzZUclhHUGZJZ3FOZGxsRzRUZ09meXVEQTl4MFAzdStxaytySXVCUkgyRXJqN3drUWNOTzdYYlROa29yTXQ2enhKVXdQZFZWS0NzeFRXbGNlQkU3a2krdldOQkpzajBRZG9PQXBlMTUycDVDb0FQVmJzN1lmYWxINHVrOHZqRnphZkRjT1FlMlB0UmlZZjZ2cmV5WCtqblJPUGxObFhidFprOHNGU2NCSC9IQTJubHo1cWlmN3N2TWtrUnpndXJ6SXdQcU9JL2FCZTRJb2V6U3dTUTl3WEhFc0ZKNWxleE5FQ1R5b1RmeWRHNFY3TkhoZTl4UFNTUzYxNDZMd2pJSlZLYk9NMjNEdkJUMitqM2ptUDlXeW8wNHlwZnlUcDVHOHFzNy91YTR5cWJIL2MxMDlGeXBMdXB4dG5RQnhHdGNDMHRRcEFwbzhHai9KbDQ5VkhxUll0ZWhxdGhYYmhxKzBwN3hka0ovaVlQaHVxZ3JQcUMwNkhVWjk0SGs4MjcwMzJ4VXlpcWtJTHhPak12RnJwTkVzb3JzK0F5aVkxaEYrbDc4UGVuWUNEU1NWdm9SRGJqbDFubEMrYjcwU0thK2tZSmplRFp6NG9ESko5M2s5dFlIendwblNZOGlEeE1Ia0hoZ2lkaXBZZC84U2dGQ3dPWHZ6ZHVNYXNIajlndWRPdFJ5YXcxa05CelRYU3hudDN5bmNia2JqK2JweWR2QllkZHNmVy9LZThoZXhibFZyUlYrMTdvUC9oRFJ5VzJ2bnlOOXFpWDZuRXZhWkY1ZVlYSm02ZkxrTE45VnZCdkJUSHZTTXhsNHltajVXRXBCSjVWSFdrejd5K0J2L3BtSHc0RnJxRDEzcmxtY0liRTZXM2tsaml0dURLUVBlRGtrdnNIeUJHbm14UkZ4aWxFN3paVThDUCtVbkhsVFh4MXJ2ZUdELy9hUFdMOERyWnZwVjYvWTgxeFZVMEVzczc5Si9yZ1ZncU14UnZsVnIvZ2txcGRjOTVxMmoxTTVKcnVpNWRVK1J4eFZSN3l0dmIzZFJDcDVOZ0o4ZzdXeWZxdlZFK2N2WDJHNDZNdEtKa25MMFFUeFN0SjdQNXR0VUcwb0tKblhLaUJkWEN1NGlmNmpsZ0N4WFByNnUyWDEzeWt0NVVDQUwzMjVNeFM5blVpUTNDQlRBTkZOd25oN3NPVmNvM3Rlak9zcTdrVnpZK2s4UGg5Yjh2YzVudTZkbkJVYlVmcWRhWnVneVNzNTdBbnJPbS9naE9DVndvSEYwbmpvUWNySDdhbDl1YVU0R1NtbGRmalZyNXFtTHFqK1ArMWE3RWxRd3R1SWZsYjBVU1pHT3hoQjU3Tkk1V0JieG1mU2g1OEk5WnAxc09TZ3NQSGV4NTBZek96Y2VuV0VjNlRudmUvSkQzcFZPL2ZaYjNRWjZleHU3M3ZLMFhBclVlTkIyVTc1TGhua3A3NGRhYjhsa2Y3QTg3dWdRYUpHK2ZGZnJNYm5WVHZRZzBmdjRycFlZRU5kTEhURG93S2M4ZisvcjZsWFJZV3Zrei9zK3lYY3ExOEV4eS81U1YwOEpKMHdDT2p6V1hrdEtoYlRVUVpUOVpMY1l5SjZXNVRTcHVQK0FyTkc3UDhMQlZoZTdMcG9CRzFRbVhBK0tTdVpPRUpGNG92SVlEZDdDUFo4MWRrc0VWZXVqY1YwQitJZmxKTVBiMWNGbk5BOTJyVE5lSFUyRHVYQ2RQRk9CUzhFUWNMamhGcjhhcEQ2YjhVQXlsY0UxWFgzVEJjNW5Mblc3VFpKR2dLNXk3M3VtSmRqd0dYUUh3aEpBY2NQclhwMnFCZGhTTWVrNWVteStoUHRlemducDFWYXMveG4zTlV1NjFMcjl5TmZabnZQNitMY2JvTEwweWVDUmZKeVEvd2U3NW1PVVlEcUJhdWZieStOL0gvTnVWQ2tYL3V5TVBsUTZ0cjBBRXE4NXorU1BNcXo3a3BIM2xsNzNCYndjWlBqWTloTnRlVSt6WnBWSDBFOUFMVy9YUjZUOVhHdWVmNnY4ZmhwU0IvWWU2dXE5a0tIVThzQWp2dFBZVUI3ZWg5SmRWUXVvU0xMU1hVdDJzWlBuWlBma1VmMTdYWmVqQkx3VVJLcDJKNGp3ZnZUNmtUK05IeTI3Q0tqNXUzaWVKeGNkQ2hyU0hjWTZOZDRXT2RMemU3Rmp4TnRmL3ZDblUvZmIrSG9tZ0pKazJFZi9OZU5KKzRGWmxnUkVRWmZxSEhaZVZ6N3ptTzAzNWl2RTZmRU9ISHdxendPS1NGMzlTVzU4bFY3R1hvcENwRmdJeFRJd3ZSdW5VNjJqckt2V1FZSnNRd1c2TXBoUCtURXVSdjNuNjlsNi90ZTZLakt1bDZaWm9idG1PM2xKYmxZYUhtNG5wang1UG00Z1JhcWZZa29TYjJlN2ZzWno5S0xwODFEWDJlZ1A0SXZiTlprdmw0c2tlNXpOcGZwVTNYcnoyS2QrZlVUSjBDU2dwdjVOQjJOMVJvVnB2Snl1Yi8zWnZicVF6NVBjQVBCVjRPblp4MXBrT1BGSDhOYnBTUUpQTit6c3N3U1c2TzNqYzR4RGt3SHpzcXFXWlJDQzVRNVVzR3dIZmVLRElGbjE4Ynk0RlpzZURaSW1RekxjV21KSmJlaGpmaVR2WHBma0tWRDk1WDBST1B5NUZvOHJ6MHp4azA5UHRjUUZFWXlUUnozTFNVdTN3ZUJMMVozbldHeFJpS0ZJTkJyNHZPOTVkVUswZGE4VGlPZG5Rd3pJRmtrQWZEQlRZWXQ4aVlHR2lRYmZEZm9KMTJWc1pEUzNsS2ZLNU12TU9ET2xLOUZCUktmSXFoWmgwa3lqQzBSa3U5QndpaVRvUEJxWHlvZDUwMDJxYXpUQ1ZXdGpTUGYwQ1dtNXZWUURRd2FZQVZFQ01JWDhrc0hodmFwMS8zYjk0MERiNWMwQkV3MDl5NlVTVjMvcnQzWm42TVZSRHM0cTVFT0ZKcVgwVUl1YjlWK3R2akpTVXFUazN3R3QrbGFCWnNrNHUyR2k0VkZNaDNnYkdSVFdrVHVLNk1WaW1ZWDBEdENZbHVsZVFnNElraEYyOGo1bW9HclZFamlZWnZLcFRjbUw3OTV4WGNtbEVvMUZHUkcxaDA0TTVkS0kwcE1FTXJWclFvZFYvVmFMMGRNSm1YN1dCUVBidDNRVnljZXMybEQ4eW12S0dDeWwvNWRhWkp5VEQ5MlhIbFRncy9qVXpoT0J1WXZsemVkOWFmYzVWc0hxNFcycHVrdUdmM3pLODRlbjMvOVByV05oR0JQajIzNEZzcVRUbWE5azVJZGE2d2ZwSmZXSjhwbWUrVTdUanZnRi8zVHBxbTRIeEJZbzZjb1k4bmJQd1Y5V0hoRnRBaFdPUkMvaG1xNVhyV2VGblNGaitmcG1YU1c0YWNzYTBhYnkzdnFRQjUvaE13OGFDUWNZaVUveCtsTXRNMk50ZVdUZGZZdVo4a3J0NGpNakFqN2U0d0ZaMnFMS2lIdk93RG40ZlJ1c2wwVWUvRGZid01FcHdaSXJlZzUybHNWOHBEemNmZXo4ZWZzNHlKUkMvNkdXclhwU3hGVlpEZ3ZQcWx4NXBMUlZrRytpOUhIajdaTEdqTGU1RTJXLzZ5ZVhHUWZ6bmM1STdUZERMaU1WZnFlMHZFWlNQeVZaWVgxbmVIYkFMSjBqQU9QdHBySFBIUjVLUDlyOVVMam51K2cwMXM2MWJIT2xaMEw1ZFI3QldWSmR1SXdqSTB0UG5HYnhqM1dWVys0TW95eXByWDU4NHZ1WEp4N2xnZlVBWFo5UXNBN3FVL0VpZ0NBdzVoTUE5ck9BaU41Q3kwbVIrbEYxclZxRE85KzE0cE1OcGVPNGwrZFNZT29qMG55WUFoWmNTdGhCcytsSHhqOHBQODk3cTV4a3VGdTY4eEN3eEk5LysyQmdmZDAxUitQRmRCZTczNVZQZ2ZObEFnN1NEcVFrZzh6LzVOZGQ3T0loS1VaWDd2VFNNTXE1a0w4UE9zNDZ4Wk52OSsyVU5kMzBWYmZ0VU9EUkZScmJMd0dVcXR4ZWZ0M1RzSThJYWpTTDBheEFhY3QreTlBU2pLcE42S2x3NnZoSjlaQ1NvN0tqRjJLVVA5ZWVmNnIxK1JoeXFTWVpUNFo0TkVFZ3NPSi8zNEhGTk16VHh3Sy9Sd0JtQkhDY1pveWc5M0ZYVnhwbHRhTzJGTDYzdEh2S2RyYy8yeWNCYU5FN1BGZVZkYTYzdGVRenhWajVqSHJMUytWbDhEK0pocGl6YytsTUFRZ0JhWUdjZjBFOTVaMG81UE5McmZYdXo2aEhHZStVS2RjRGlwVWgwTkhwdHI2elQxdmgxV2ZTbWIvV05kNUNYdWxUclU5Ni9hbXV1Ny9raVJ4NWdOZ3VHdThPRERsbTMxZlZUNisySzZRSnpIU1FNS0lPelcxUkVuZ3ZiM1VOYjFxTitROWVsNTU0RkxsQ2N4NzRuNkJqWkhBNnBaZDQ0ek91T0xuZWQ2bTFnSkFQdGtuWDlqNDRPcVhxK2ZuelZRczY5NzN2T21sUDE5eTlxdXV1YkppM0swTnZheG94bGNldFltb2ZWK0pueThzVjN4YTVESENXcE45L3EvVXVCWUllZlRPZnBJRFZabXdMNTBHL3ZkL1pabEpVT3ZTS0NveEEwSWx5SVRlNVFBK2oxVHR3UTVjNzVaWHQ0djJkeGlZTkpaOWxPNlIrUzIzRTYzc01ka3JuLzMzcyt0aDBraXpTMHlZajRUS2JsazJkRDljYmJDZWw4MzVTV1FxMHBBZFQvTEYrcVZ6bG96cDQzbHplbXdFVlR1dzcxVS95Nis5VFlsdWVhbm01bnJhL25tcFpYaVNRT3R1MW4ycDlWTHJYMStWVUhnLzFGVitxUmgzbm9JNzZ3Y2VFVG54bG44cFQrRitlMHZPRmcrU0hTOTJzbzE3azlrc3R5NW1NVTN2dXEybGdjY2Z5d0FoVWRMT0FtNEVlWHJlZW5rMUdMdVkxeUxkN2Q0bURCOC9YZVhGWEhkTWtFUEJvenpBZnJZbk56allZbUVuajUwcHF4cDA0TWthc1M2ZVVPeEJHaFVmdlFkVmlPTGo4d1NqMU5FaTlUSmJGc21Xb21KNzN2YzM4ZVNwK0I0NVVmTE9BV01TbEJjWEI4SVZOZnFxZlpnVytKNTE5NndHNnZPL2tZOGJkNndJV1VsNytLdTJVYnhxTGozVlZTQnhEQkdwVjYzeW84SHdKTC9IdXY5a0dqQVg0V090ekVFYWdZalF1T2gyVzhrbDVqUFRqeWRLNVFiblVvaGQ4S1VkdWVNKzdHNi9NUDRHQ0xlOG14NEwwR2NkcTJYMHYyOGYveUZaMHVpclJTTjdaaDVKSGJXZmw4ZjVha3RVN09mUUtoWCt2SlE2RXNxSzJIM2xRV1I4YThYOTlldmEvZ1FlMWpaYWRCTVoxM1UrWEZSQmdPLzVRaTlkQzc0aXBXcFp0MkZhdTM2Um5CTUlZYTZNNmlsWnhPbHNEWTVPNDdiVFpjWEdwaW9kak1ZM1RFQUNFNTl4dzN4aE1CdzBUVzJVOWY3ck9IdTI2SzRDRUF2MDNaeVkrRy9mOFlwMUFYUHZ6OHVnK2MxRGgrWEtRcHdIT09yakM2NTdqTStrYTB5dVFVZ2FXSDRFUUJqRW1wVU1BY01admxrZUVMMWNqdlFKNmx2RWNIbytTOHZOMkhJRTJBUVFlSGE2dGI0enJZRENlbnVYc2xFdGV2cVZNMTZub3RoU3p5eWZiVHNzMFZjc01oc3RoWGo4dTZXaWJtdXJNL3Z4YzI4Q0IvZXZHalAydDYzUlYwMWdTVUhDbTJzbDdONDZkM0hDTzJwbjY2bXovZVYzODYzL3lBTEJNenFJZmFqbFMzTWQ3bXVBNDBFcjE0WDIyT3oxQktlNnFxenVOUE8rL3EvVTIxSkZuYXdiZ0tSOHVOY2hJeTJ2eENlbkYxMytxQmVUL2ExMEJoV2JyNzJ0NVI1UHF3S1VRblhLcHBSNnZJNWM2WlBTVko4L2NLUEN0TVRjQ3ZteWZoMXFXTUgrcjYwRmdlbGZLNTFwT0VXYWYva3N0RXdtUE9SRi9mNnRsc3FDMlh5MlpUTWNlSkJyTitGbkJnYmRqTkZ2WWVtNmtzSk5oWHZIc3ZFL0drU1FrWHJVb1NCbUV0R2JsaW93eEN1eFlCd2tKY0pEY3dQTSszWHlKdDI2d010L1VKbDM3endoOEFpSE9qNDVZWmh0UmtWRTV1Y0lydSs4SzBKVWx0eHdxRWwzdVQrYnQ0TzhCZVhwQUYza2NrZktYNGFjQ090VVNnQ1ZqempYbzFJZFVjcjZVTU9MQkRZOWY1N1piS1Q0Q25xMzhDUjU0em9HK080T2NnQ3YvUytreHlGZjNPTVlvK3o3TGNpK2ZHN29aMmd0QytGdzNlVWk2d0QybWJFUC91RXdXOHRBMzYwKzVjMkE4b3g4RWJGTjlVcDI3Zm5hWm9NeVB5azhra01KeHlUelZSdDZXcWc5ZjkvNzNXdlNTdkJjaTZnZ0NDWldmK2tHL0paZC9xNnUzUXZreHo4ZTZIVzhqWGFOcjBxWHFGOFdMYUN1Nnh6djlYT3NsV1FHd2MxM0gvWCt2OVE0d0wvZTVEV2VFZjBVYllHTDM4NGttWGxoR1NrYWthandvYnNyYTRFc2Q2TURpb2JsT0plOW9PeEdORmZPbWtxaktTeWFzc3hBalp6czBpRlNjSE56T1h4S1lWSzZuN1JSUVIzNlBScHI1K1BHOW82V2NrejJ2MlpqS1lxUzU3cnZzU0NGd3pacURXUGM5K0pSdDdYeVN2NVBsbzhocUJVZ3BzcHRseTFXYjVFbDFaTDlxMWlUbHdHOVJra2ZLRXRPNHNhTUJjUGt2cEhXRHcxbWFucGN5ZHBEdFBMckI4WmZCU2ZHVEtBdHlLZXUvM010Y0puTUE2ZFFCN2U3NkZuVkFKaG5PMU03K0RNSEloN3JkQ255eHRHeVBVZDI5WDl3VFNtOWJEZmgwdmFIbjZaMlFUUEJZZUtXNTJITVgrODF5Tkw2VTVzZGFEb3ppTzBrKzE1b1B5ZTM3V2s0UzFmang0RytPRTdXbjJsYmpXWDNBQ1lHUHI2ckZ1UDlTNjEwZGxCSFg5eHlMeVE0Sk9NaWIrZVBUUjk0UDZUQjVaZjZ2V3ZRSjY4cCtUVHBlZFgrb3ZVc2gzSTQ1V2s2WXphZWpKdFpoZGE5NU15cC91OUdzbWh2b1RoemdhV2JNam1FWlZLeHVFRHR5bzhwNnVURk4vRkd3TytQR2RrdnIyd2s4S0cxWkdzNEN6bll2NWVHVSt0REJZZFh0RG9RWncrMERsc3RZeVczdlNwd25HWmI5Vmp0enRrZGVxS0NUekxoaVVINWF4K1RTd0tYV3N3NEhGc3hMU3BTelVkYVoyMDlGWFg5UjV2MitLN29PVUlwZlgyYVN3anZWRXZPZ21aVFBlc21uand2MXE5YU4xVjZNcVZCNUFuNEVOQUk5bDFyWGQ4WW9kc3ExQTd4Yk5Pb0hBdGdSTU9SNDFCSWZEK0h6TWM0ZEIvUW1PUStwREkxSlRXVDA0ZFpzejhOQmhmUVBQWkpNcjdvb3RvSDNPS1B1Z0lYQWdXSUVlR0x2cGRabnZGRG51RWRENENaNW9uMjhhQ3dyb0ZYYlVDLzRUcFBRaDFxMjJ2K2psck12SGlyM2lkcWUvZTBlYVMxQlZsM2I4R010c1J3NmcrYmY2dW90VWJwL3IvWHkwS25XNzVaSmRrNmZIM1Y5RjdEWVM5MjVFS05ZakJlUWR6QnBDNFZ2NWVVS3g0Vy9NL2djZ09xY1Zaa1dROElaQkpXeEd5anZWTHBMZllDUU53NGdwZkgvWFp2NGRTcGozcC9weHc0VThwNzNZWnBCYndFMTVjTm5PZE4yUU1xOTdRUm9wMXEvMTRCOUt5K0xMM054Y0hmR1dmVlMyWFJCU3VhMFBNTzYwSEF5VDNsMkhtb3hHT0pCMjA5OXE2NlR0LytvZlZNYTFrdi9lZCtYalBpR1lMbDh1M0xTc21IVk1qT1U0UkNJcUZvVXJwU2s5NkhMdzFaOFFHcDNOMElqY0ZLRC9FZGxPa2hUUHFudFpYVEtlT0g0bDZ6UmlJeTJOck9OMUc4ZjZycUdmNnFxL3cvUHVwZUJJSTY4aXlmOUovODA3dHBWcFBRYW4rL3FhaUI5ZkhNOEtaNUhjVnMvSXMybld0NlU2bUNINU8wc1hyMU4wbjhQeEk1Mm9KWnRvTzlxN2JHUTE1bWtNbFEvdG8zNDUrbkVXa0w1b1pZZElhci9xYTdBZ2dEMlpQZWx6L3pjQzVFdkMzK2s2LzFWaWVCaHcwT3hGOWx2a1J0NUgvalB5akI0WEtnNE5PaTRLNE9LdEp1Uk9uV0djcFNlNVd6TnJtbmswdTI5WndBQUlBQkpSRUZVS0dBalhoSjVIV2ZJMjNwdlA3SnZVanR4c010Z3B2WEtHZjY2MlIzWEk4KzFOdTVWYXlQRmZPbWhPRmtlVyszQSs1enA4Zk81bHBjSnJlUzJidHVBU3ZxQy9IVHZVODN4TmVLenU1L0dCaFZma21jZTluT3A1VndBemFZSUdramU3eXFiQWEvMGVHeUIzclM4eG5JU0FIWWRJVStUSDUvZTBUMjZ6a0ZxOHRSVnJlV1IzZ1BXUWQrYXdYZjFUbnJHKzFqNlJwNGpnUUNDQWk3MU1ZOVVEMzVUdjNKeUpTUG5kU09QOU54cUNVQ25hLzY5cnJQeXY5WGlDWkdlVC9wQVBITHl4alp3bThCbnFtN2ZRekthdUNtT2FldE1IcEhhUTdxQ08xbzBEdFJHSCtycW5YaW90VTdUaWFKYVNsVGJ5cnRTVC9ub05mTUtNdlhsNmd2eS9mUW13T0lKU0VUbHYvTUFLaXJWcmVlOGt0NHhTUkc3TjhYNVRzTGZvZG1Sd0xpd0phSXlUUWpaZWF4YXQwM3lwdkJaVjlacHB1Tmx1Rkhib2k1ZFVrN2tLUUUvRFpvdVVERzU5Qk40MEwxa0pQdzVMaHM4Mm05dUFmTlBtb1hNeUlYS3BIZUsvQ1hqMElFbDk1Um85aStGNDhjRHp4cTRkaXhiR3M4N0dUMmxQZGZpSnBhWFFXZGtTTWtyTGNlUHdJb3JlWlhQMkJRcVdlY2h0Wi9LU1RMSzMyNHdGZWNoOS9kcjA1WmVHejFIUGVIdEpnOUYxVnAyQ1FSOCtVRnlTSkRBcFMwQjg2cDFPNm5zSDZxWFg2K2plUExnMjhKOVArTDdIUEpRUGdJU3Y5YmlCZFNNbk9CUVhnTnZPd2RHenErM04zYzlWYTJYWUx1KzgvaXZMaTNMRktoUWZ5b1FuZlpBcDkwK1BLWDl4MU43L0szV083c0kyS2pyVG5VRkZTa3VSR09VZmZhbXIwMlBqVGVLbndCMUtIa1BxY0tPdmkvT2gvR3M4bnlXbXZMZUtyOXFRNWpDc2xEYXJ1VUdoSU9hYWVqR1pCdlNpRGwvZW5ZTFBLUittREUyUHVoRTdxWFltdTJscGFBWkpadnFUaDdJbXdZVS93dmhwekw0N2dxVjVjQ25NN0RwbmdhMWxIVFh2cGRhcjd1VHhMT0RFZWN6MFNsOGN4eU5ublgrcXRhRzRGS0xrcTVhQjgvUmdGQ3VmWlpIcnhYalcyaEVsSTQ4M0l6L3BoN0t4d0V1eXlud3gvZ1lQK1ROODcyWGZDd3p2NUY4dUdHVVh1RzJVaTBSZkVGYWZhZkoxV090UVFvQmxieGluTW5TMDhCKzg1aVByZzRqejArQkg2VVh2NXA5UzU4cXpvTGJXQ1VYT3RORXdFSnkrbEJydnRuSE5LWk9BczRxVy84NUpsUGRreGRxTkU3VGVQVEFXZGJsc2E2QVFuMmw5bjFmNjNaMkw0MWtTYURISjUySjMvZHZ0aFRpbExaM0RwSW5CVDFMeWZEZHpFREN0dE91c3pxRVBUdUQ2d1F3UGFQQm04cE12eDBvT0NxV1VCQk5kdURDQVpqejVyS1M2dDhOdEpRZm4wbDFvL0ljdFVjeUZONlBLWjJVQlYzWS9ybFpQcXQxMjd0bmcxNk4xTzhqdWFKM3dtTTBYSkc1c2ZmNzdtMmgwVTJVakZlNm44WktSKzYyNTNNTVVwVkg1ZSsxZUJzNDAzT2VucFZYTFMvWDAzVzJwUXduNnk0NTl2NTBTakxGZkt2V0JrM3ZadGl6VExlWDl1UXBQWklNR1lIVHBkWkdodW4xNlNhZnpPOFI2ZGpYQkJZTUFPUXVyYTE2akQ0Y0sreExONDVhN2hCZjlIQlE1K3JzaWFwMUcxV3R2VkZiK2p5QkJ2V0gyb1hiVVBtYzMzZEtBRG5wUjlkcEFoYUt2WEJQaW51R3hiZDBtazRTNWZJczQ4SEkyNWUzR0FCVGxJQkZjeGhXVlZZc1cybVNvUlI2VE40SUJ4YWpjdFRoYVhraktlam4vRUlkT2JQWUM2U0lIRWYzMDNKT2FxLzBuOWM3QTlVQmloRjUvL2hBS1B2Mi9GenBzOHdFRUoybmQ3V2NsYytnTmZMR1FGcmZUY0owTXp4dEtTUG13MW1tZXg5OGh0YjE3NmpNRVFBa2FPRTQ4bWVUOGUySWlvZ3VkaWt1dXJrVEQxNEc5OXJMdmV2dThGUTMxaUcxbCs2TlFEUGQrODR6ZGN1ZTlobVJlSkhoOXUyMG5iNmtrZUxrd3Njelo3U251aTVKVmExMXlpLzRyWGdGZ1hLTkgzL2huZW90RHdYamJielBYNE84SFZSdjhjcjRKZmRVVXBZdXRmYkNzUDg2ajUvcmNOYWZNbnlxSmVDU1FjWDBHT25BdkZOZGwyMzhiQnYxcVphZEVpQWdQd0x5cWp0NUk4L01QK21UZDNpR2JmMkkrM3IyVFpEMU5OSEFEa0JGVmFPOEo1OUpCaWtKaGpmNFNQa1NXQ1JqVTdWMFdBY3EzSmd5L1lvMmxvOGNQQ1ZlMHF4UnRBWFUrTzJ6dHBublIwVGVLZUJFelB5ZkRLYWo5d1JVbkNjTkJMN0MrMnhwaU1qVHJNanJPQU5LTzBwOVNubGduem5RT05VNE1Ld0RaYTc4bkkrdVgxUitBb0FWL2pNZktzMUxMZXZDbEt2RVEycDNub2N4c3hOakZ1QjE1T1c3eTU5TGFIdEIxd3pvOU9XaGxNWi91K3o0dUtWaGxjSGwrUlEweU9wNzhmRUIrWEFaUy9tNVlkTHVpRXN0SU9TbXZ5YVh5aE81RG1lOGt1cmtNVGRLb3duRVkxMVBucFEzVFZzK0U2QklvTFFERmtxdnljeFBUOWQwckxZTS9vZGFqdDArMTNJb2wrczE4ZjJ1MXNBamVad0VMbnhpSkI1OU9hTmJoblE3a1BUVGMxNWZiU2xrUkR2T3cxaUJpbzFuVldrdUFYUXp6ajJnWWt0QlVhbXNRSVhseFhYaUpJamx6dzBHR3V2Sno3a3krblJGbll6bWpJRzhWMG1uY2p1d3dHc3NrNFBHWGRBanNDVlNnRlhWYlR3Q0I2L1Nkbm5PbExWRnFlMDlwc1RCb1N1VFVaN2UvNlAyM2FvalFabnYrdGppZytVdzRMV1R4VTZ1WlFTMGUyWnJiQ2MrT2w1bnJydXg4VmlTVVY0ZGoxMGJFdENQWnZpcEhVVjB1L3Q0VTk0T1JpNjEzbVZESGhnWXJHV2djOGhINmRPUjhqZnRNOURsVzJPckE4UlZpNHgrc251cWs0QnAxYUlUNUNud1NjdW9iOTN3bHFVOTFkSWV2OVFWTkdoNVFYU3VhM3YrcmE2blhQcFI0S29QbDNERXQ5ZWRIaGdmUTZrT1NiZXdYdWw1bHlIMS84dmZGZktXTkVLczNka1lHMTZNUkdrMjE2VkxpbW9rWkYyK1hEOGJCdTBNbGs2WWJ1dStmaE5WYnMydWtxSHBBRWlpVVI4a0lMVUY4RnpZSFVna3IweTNWTVZaVE5xMlJ0ZW84a2s3UDA3MlBaS0plOGpiM29Id3FLeE9McFZmbXQxUUx2eS9TSXFhQjNuTkdGUzVnQlVUd1hNMTlzWlJpVCtTODg2K2M5bm9hQ3ZObHF6dkFURkt2L2VaUGFTODJSYjZUdWw4RjRpRENrK2Z4aGJ6b0c3ejAyL1BWWFh1RGxzMHp5N0J6cWl1SENNTWdKWm5VanpSNk1wQUU0eG9HKzRqN250OVhlZXFmbnJPZGEyM29mSkxlbTBrWndwRXBmM2dtVHNxdyszTGxrZVEvOWx2SGREbytEd3gwVGRMcytDaWk5bVl5V2VTOWdBTGY2WnEzWG51S3B3eDFxNzgrY3dJV0NUQjFlK1oyVlUzMHhueDZuejdmK1kzMnk5ZUQvZTJkWHdrSlNwRWY2cDhHcVZ2dDVNQlRMdHVtSzk3R1JKMVNubVVOdjFQb0xHYSsxMSt2TjRwa0txMTNGRWVIRlIwNWRiVGN6cFFTVE5EclMvZkF5eklsL1BNSFF0NlA0SXZkVGwxZGZlMjNacDRLTTJlL24wZTA2K3NzN3djbDcwMHByZ2JvaXA3WTdiS1VMOW9pVWpMWUp4cG42dmlXVUpWZFhOa2dmaVowVmNjM3d6Z2RLK1dnd2QvWGpKS0lKYkdtZEl6YmtJSGV2RThuSFBkSGxEWDhkK1ZVNmdYLzZ0c2JhUDFwUnUzTlc1TDlGSGVEc1pKU2UrNkxYblpTOGplaWp6MllrLzZOeVIxVHZJd2JEM2pBRUQ1K0ZKRnlsY2RUdmVXdTc1bUZKL3o0NE8wcTlPSU45WnBpenBqdktlczlJenk5UjBjeWkrbGRjUG82ZFUvZE9GMnV4UVNVSmdCRlRQdGxveDJKNE9wM1U2VlpTVGQ3d0NqdHlmZDRiUGpRTVFkTTk1WDkxQW5qd3l1N0JTa3QwbWFPRlJ0eXl4NW1abHNkSFR6ekIydlRKZ1pZMXM4RUZ6c3JZK245M05WNGc0bHZnQXl2QXlTeHU5RGplVlo1Qk92WkNoOWVZWWZ5bmMzYVhQZzQrZW1FT0E4Vk5aUFhWK2xTZDhXU09DOXMzMjhEQWVhVmN1QmFlNjE2dXBNSGwzL1h0N3lISXNoZGU4YTJibGJaSnIyNXRHOGs2UTFIaHZIbGxldE8zOFViT2ZwdFo2dC83N1c2cnNFWnFtcnkyaUc1c0xrNlR0RHZwZWYwVDJXSjRIdUJsMlhaeHBzWG84dmRqOE45bVNRWDR0bVp0YitQeW1COUV4S1czWHI3dlpacVBMcVFJelBYanovUzExblZBejhxK2FaUFpRTVNWcWY3dVJHdkRnZnN3Q1E2ZmZRVUlkMDF5WjJ6blh0bWRxRHh1bFU2MERORHBRbDZneGgxUnBNcXJ3YkwxV29sOUxTSU92Y2pkRmhaQWx3ZTV0MHk1cUpmOTMzZkRreDkvZDB5TUF6QUp6M1J4T2tidkxLLzBxbi9sS2Jqdm9zeVQ5QlBwZDdrMzZnVFNKL1hGcjZYRldYcitLeDZNNndHQm42R1JEUXZZdWtvM3RlbXZiSHYvNDV1ZXYyS0FRWFhnODRISkZIWVJORXVLSjMvam9CVGdnOVVScWNySVB6MFZFcUt3V1VqcDVOMStsVzVXeUk5N2I0R1ExZ2ZqcjNaV3FqTFJsellQU2FOR05NZUozMW0xbi81UkpTRGI2VHU1UjlJNWZ0YXhHTlkxVldzQTV5M2VDTWpQSE1lUGxxSkoyMDhVcUNEdFIzZFZIZmpJTGRaeW0xKzAzYmhmZ0tuL2w2ZlR3dXlLa0R3UG8vMHBsYmRVajYzSC9USS9OWTZ6ZjJKbjNuZGV4NDgzSWNtUGx1Rno2VGRFM3ljSENIbHJ3WDdpRlMzK2dJZmwzWHlaN1A3eWY2M1R3V1ZiMUJkdUF4QXdqY3czRHZtMWRuODk5Qkk4L0Yxak9udW4weGxhNzdqR0lFSlBaU0I0b1NueVBsdkZYSGJ0Qlh1SjdTYmExWGpnYVg3cWQyMnpMUWlhK1Jza3FEZWtUM0FvNlh6cTZUeDBNeXFHdVh1cDN0NjU2djdhWXlPY3NpdUk2NlFMOTNiQ3NmOWNYRjBoRGt6OHJ0bTFIM0p1ZXRkS0FFOUgxTWRnQ0s5NW5Ybm1jN252anNzMEZzRGlua3lhQWlHVFFIZzZNeVIrT1Z4TEtadCtTamFvazlxRnJpRzF5V0VoaFFYSkYyeHJDOExaNDdjbjJyUEZPL2kzOC95c0NEZURraDBKYllTOTIrWTRnQm9lL3dyZWVlendqNUtoNExIeUFOMm03VDc0bTVlRzFBTVpOL0d1aDJ6ZGZYTk1DNm1VY2hMZGV5YVVnZGpTZnFrUDI5MUFHT0xRQ3lsZGRvVUtXWngraWE1NS9vWkorVWIvb2svdmRRS2pmZHZ6ZGZ2N2FsVVAwNXprcGNONlQvM2RyeFZsOXlGdGZsTVRQdUNYeEdXeXBIZktWWXAyK1dOZ0JXZDgvN2JpUmpTZWJkYzFCVlkxMXJlbzM5M2xHYVRMRmZLWk9kWENjWmRCNVluNW50NnJyL01WejNmSjBYOXpMcittemdlWmZHNnkrUXdCMGg5Qzd5NCszZ0w5SmpJQ2o3aThzZjJnMm00Rnk5cTBUQnJnK3ZhWFJlblVaYlNMY00vQjFvLzRaR0EyY0hQeTY0QWdnak1GRjRUaEh1aFdkSGlqRE40Q3I4M2t0YmlOL0xHSUdkV2RyaU45V3htd0VuZEw5bkRUbVJHN0t1WEZkNG5WTHkvdWN6S1c5UE4wcytPK04xcjVObWtRbk1sYVhkQW9sZUR0ZG1xMjdYb2F1cTlSWnliREhnTUFWc2RqTHh6ZE9FcDVTenphcjFqb0dxOWU2SWtZdzZqZElNSjRaT2szRnprck8wUkV4NTFldy9qUjBhYkhvV3VqRkpuWkRhUmg0SEdWQWV5NzBsN3c5MVBleUtPNkJZdGo4L0k2T1VlWUVCZWhVdXRYNkhFTXRTMnpBbW8rb0tKRFFXQlI3OFVMVExVem8vL2x0Z1VYMzJmRkx4Tncwc1NQZTRDWGNFUGtYYUF5ejh1WUhId29GRk1zd0pNZXMzMS9CR3N6Z25GK0IwdjZQTzRPay9oWGcwWStRenM0TnBkSDhFTE5KelhvK1h6RkFUWU5oU1lPeURFU2owMzZ2OEc2VTg2dHZFTzVXR3Jybkx1U3E3ZmhPdnM4QkM3YUdaa2l1OTJlMm5HaE1LYnRhWTZGNm5UZDc5M293TU1OMUl4cjRXdWZ3SldQbHZMUzI0emhrQ2gxSEJXNkNpQzh4UDZheDhUYUI4WndMbGlzSHJsUGtFc1Bnc2lYcFZhWFUraE80cmI0RmZIVXZPMks0dWYvSEJZNjZadDJTZnA4NnkzS3BlVnZXdHVBWWRaODgrRjA5cXo0ZTZ2akw5NzdVKzlJejFFNTgranZWT25uTlYvVTkxZmVXOFhtWkczbGR4TWQ4dHNCRGR1Mnd5QzFUMjhoUEloYmdxNzZ0MzQ4am5hTGlWMXFPaVQvWnNNdHlqT200Wjc3STY4SjRMRjh0anZtNzhYTUh0QlJpZE1weFJrbTVBOTU1N3duYmU0b0g5djJXQS9Ua0hKYk1BVVAvOUdmSkJZRUgzYWRWWWdSTDhzdHd1eHNMbGtlWG92dHl2MFdzUjh1UDdRazYxZnY5RVYzNlgxeDVna1FEZm5ueGVTdHhad1RlOG5tcHRZTmpXZTdhT1R0WGpYbzl4SWp1elF2VktreFRKbDhkV2NZeTRUT3E2QTJpVzk3bldYamtaV1M2L3NFM0Z5NVplOWZGTG5lNDYwdk9ZMGNmZS81Nlh4c21wcXY1clhjZkhMN1hzbXVKU0VHT2ZTTytRei85Y3k0dk1mbm02cnZlcFVLKzgrMTJETi9mUVBWdE9SOGo1cldJeEdqNUhmSGV6VU4xemdlWUFZLzQrRUt2V0FqWlNpbnZhd21lNXpML3FGakFsUHRQOWwvUkhHcFJiQ25KUHhQdG94c3MwbnM2VjI0ejhwbWRaeG9vSGt4c3FMOCtIL2VPeWtwU1NLMW5tNGZlZDkwUnNIL0ZSdFE0d1l6NHo1MDl3bGpVNnMrSTFqS21ES1Y2N044OTdLRTFVcXBaWktOdEFZS04yOEhLVGJqUjVlNDB6aEo1a3VHcmhQK2t6MTRWRG5wOG9qWXVxeFpDeUxBZWtiRi8zQ0NUZDBla0k4VTRQV3pvREprMENFcVcrOWVCanlwNTQxenVSZnFpcmgrL1hXcmVKL252ZCtKS3gvN3VXSUUyVmt6dzl2OTg1RmkrbHR3N1NuQ2wvd3VYbmlxZ0t3cE9DV2pmT3plZ0VPaW1hTkd0TDE3Y29HYWh1RUNTWFh1SWhsVEU3b0xhdThkNHU1VDV4UGtDNjVrQXBHV255RkNsNFN6cnc5bnh2NHowNWliemZ2RzViaHJscno5SDlKTTgrTytVYXJmUFJnVVozN3o4SG0rM2N3VFVySHo2V3QvSitTLzJVUEVzT0trUStLZG1pelRHekovRGVxZk5xUE9rKzMza2h1bFF6cHBweDQ1NEI2a2ExRThFeURhcks5V1VGdGUwN3U4NW4wdVRPS2IyTjFIOXZVYklwN2dXaEowTEE0bDlyMmNueEViOC8xM2dKVXQ0TWVUbXExcnRBZkxuMDhhdnNDbmxOMnJ1ajVLMTVHZHltOGlUTjhPY2dZdXQ5Q21rbWxmTDAyU2lmbnlFZlpOMHNkM1ErUk1wenB0dzk1TFBhZTJkVi9seHFaeC9NblJKTTEvZnlOV3NvMlEramZMemZMclZlanZBVE5tZjZyMnVqcnY3ZVY3NUxKTlZaaGtFSzhWbFpUNDcvbDdaN1Z6OWVlNmFYNktUd0xOOHpWSlYzOEl4NEcxRnNGNTJHMlFWaGJ1bGs1bFBvYzg4VCtaenQ4MXlIMGNzbm03T0RFbW1zNmpmSFNmS3NLVDgvK1ZqUEozMmFRRHZyczhkak9rUGlnYUNLdTJxcWx2ZWxLUDF2ZFYzYStLWEdiU2J2aUdLWWVIUzRQQ0xzdDFZZ3YwbjZ2YjBVTzRuQ3hVWWZEdlF3U0dmcjdNcWFmS1IwL2pzcUZmRGpCaXNObEJIWVNQek9Lb0k5aHVCZVFERXlIcncyY3NVbWQzd3kzbFZqdzlueDhKenZQVzhFM2lpakF3QnZNZVlrTDN4RHFSVFdjSncweHVNNWJUSlVHd2RKSlRvMW56MHkreW9VakRrRFhOMllWSzNydFZMMm9na3djQmNRSHdYVWo5N2wxQ3l0REhYZ3hMWmJ5cEh5OEIwTlNTNUlTWTl4a3VmUGI0SE0xeDVUekVkZUEzcFVHSlQ2VU11N1NqN1hOWkR6MTdvQ0N3L3M5ZkhodXNxQkZtTmkzbGY5emdka3ZSVjlRd0FrR2RkMjBISjdMZFlkdDF5N25hSmxXYU9aNWxSYmdaODliVHNxZDVSbXlJZCtUMnpCMCs4THZqc2FnU3pOQUpSdXF6MTNlNm1hWlRYMlk2Zk10cWdET2NvM2xmRWFOR3B2enRqU092Y3FMbURqREF1V0U0M2xoSnlNK093TW5SdjBDdW02OHJka3NhcUdjVmR1QkJpRVIxbGZ0YzFXZVJWa2wwdStCQWl6U3g1YkFmUnBPUmpQYndMcEhjdGRNN0xOZmszalJ1YzBWT1gyOUhGMXI2ZDBpenBaVE9PYWIzV1ZEdnUxRmcvRXFaWjZPYzhPV0tVakpHc0tldVY3VmQ1VmZXY2VpKytNVnJPK05OUHFncUFjWUV5VWxhSytaMEhJTkExbWYwNmptYjEvT3RwTXQ2TjlsTjhzZVZxNkZSTnlkejYzNnVhenl4dGxqbng4bG5WRHMyM1FlTVAwZVFtbzZNb2ZLVll2dTlzcXVvdDJHSnFrTkt2NnZxM3dmMVR2TFRCenI5RlJtWnlSVTdHUGxrYWVhYU9kVm9CdUJxeDFYb2tHR0cwK1I1b0FscDBPRWozTDFPUlkyWm80Yk9VeG1xUzhGWEVzbldvOXB2WC9vUlpQeFdnSDF3OTE2N0h3dzhSMC9iSFdZK1p6VlYyK1ZxWC82YWdMVXJMamE2dUNrTjQ1NjNLa1Nkb3pLSVo4ZER6WjdJb3pTZjd1eWgrQm9FMmVtb09UV0dhYm4rZlp6QzQ1c0xqYzRYMDROUk90OWVCOGR0ZU9vdStWOStRVzZodlplcTBENHlhMzRaSnVlSmdJa2wzTndBYmpKODdtTjlxeEtwK0dXTFVkazVLZTZlNzdiOC92TG5BZnl2VHpLMWoyU3ZZbjJ1V1o3cFdYb0FmdTFqZWQxd094R3FMbitsa2NoNjZmdy9Pa1RoNTlvcmEzejBiZWpiZWcxTzVwdkhRVGlWTXRCMjhwN2tMUDhTZ0JlaTc0WC9UK0FCYS9BOW5BMkZUK2VLWTdmR3VWenhQNXdCc0NtTkVhNklqb0pyVnliNHhpeDBkbEEzSERTN2NMcHdFV3pDY2FxQjNLVXdOTGVlMlpzU1J5SG1kYytOSFFEdEt1OHA5OHJxVkpvOVRsTlZQK0hzWGRnWXRuaGJtanJteW5HVU9Rd0p2WElZR0xUUm0vZzFZR3RBYkFZdXU4bjN0UExTWllETUJ4SmJOSmg0M0ttdVJqQmJpcFd4MVFEUEx3SmFTcUxJOTcrNHl4Q2F2dHJGMTd2QUlsZTBCZ2NLcmJrMHRadGs3ZjlJQlc1UzNQQncvWllqN25xbnAvTElYOGZyUlNRRnRHdkpudEpVV212SWVINHFTMVRmL01WS0p4bDhhWlpPSWozSCtKd3FXaFNUUGFaNXJkV1lUQVZROHNWQm5PK3d6L01UMmo3N2RjeUFQeWdaNk9TSDR1ejU2THRHTVgxcERIRGZCNnoyendOWlN4eit6M2dBcm1rZEo1MjNoZE4rdXdNUTZkWHcrb1RyemROWW1ZQ2I0TWNodDFqUDhlbGJGQno3SnVRR1Z6SEFhNVRXUGhCcHp2NUUxSGIyc1pOYmJCenNNV1p5bnBKWjU3MFZIM3B1T3FmR2lleTF0VmZjZm5XSHpQOUpJQk5TR0kwNHIramNnSDZhdndNWEZtQ0lsdXUyZWgzNk5RSFZ5RXN5VzZQa2h1eUNxYk5Tb3dGLytUbDhUQjJ0REEyMHhSd1ZwU2NJK0ROdlFaNXFxc3JiYmZrTW1YR28rT1R6OFU2S2FjTnd6aTdneFJBaGd6czk2YmRBSGNiZ1Z2cHp4WHRDWC85ODZjTzY4Rjg1dnBqNDE2cnRLTmdqdnZxSWNNYndKRm1wM2Y4RWxlQjk0YVArTmhsaEl2VzNtNEI0SFA4OXJXVzZIOVdlb0Y1NE5qVVduT2g4ZmlHNkM5M29HR1hqcmJmMjE2c1FkaWRpbkdMdEhvdjBXYnhCbFo4Tmo0c2NGeEsyU1RmL0s2Sk1DMnhhZnoxS1hyeXI2aGlXQzd0d0syN3JyMmF6ZGdyd3VPZmdGMUlDRjVJMlprTDQ2UkhSNmltYnlyYXU0ZFNqTXhGek1lVFlLSXZSNVFQck9WWnFiOG5lV296UmpZZUxOVmQvSy9udVUyNnNocnc5N00yTzJlbzY3Z3N4OXFPVFZUYVJpWTd1OW80Zk5wTW5XeXovUDF3MlB4ZlZPYUdkL1FhOHpjbWpYVVZmNDJrN2laK1RMdG5yWDlPd3pFdlZzenQ0Z3pnbFp4RzNYZ1kyc0cyZzN3TGNYcDdkNGRnN3lMUnUzZUxOdThoaUh2OHZRMjJtdGt1aG5rUFROTDByMnoweWw2TFErTWo2YzlzVlNqZTZNNHFEMjh2WFNpdGJmOFJpY2x3NzZudkJzUFFVbzM0ZTF6ejV6NDJSci84bHJ5djU5WElWQ2g5NlFNZDU5WnZ2cGZ0WUNTVDJVM0R2ck9hTy95eVZ1V3ZXZHBKN2tSdDlKdHBRWDVESi9mbTJWMDFPeDJHVDI3NG1FMlFHMFE4OUNDazRiUForb0M4NW82ZVIzMnZCUGhhNU1VWTlVYVBLMzZQU2h1YjllOXl3dDBDN3NzZUg3UmtQQi9KOWQ3KzdsdTZ4K056MndzUlRLMk16ek5CR2JPbEgvdjh5K2xHVDF6enhpOHMxejNWaW9mdm1VMXBYZWdrUElpcVBpaHJxRGd0eVpmUGkrdnhtTXRoM0c5Zi9ybytjZkRZL0VmaERyays5YUQ4eVg1ZDBiMWhUelB1S0IzbFJFOE1iTjg3SXA2dHo1Y0dTbFg5TjFhdHFmZklDOUxDbU1yL1YzVUdQblcrRTBzdVp6dFAxLy9YQk41ZEtDcVN5dnlkMCs0TWQ4TkZweFN2dzZlM3dPT2huVHYyT3ZrY3crOTRzNkl1K2tPUURmTWkwdE1zM0ZLS1liRWZydnhkeGwwajRVL3o3RnpxV1Y1eEFQVC9Ubjk5K1VQTGZrOFAvKzdkK1JCLzdGb3p4TEhiSDczQnBYdEtXZXJmUDN1OG15MnIzbkE1ckFPVzJtVG9aa3hQSU55M2NQenJDZ2FYb2F6OFR0b2VsWTkwZjllbHhrai9HQnBSOCt6RGR3OTdRQW4wa1M5WHVJTm1nSklLZEJ5UkhzQi83M0E0aDdQelV2cDNzbk1iQjJmMGsxNUwwZThnZFRIZlBHWGlKNklRcHF0aVVJbk56cXUyOS82eWpyOStQU3RHSkxQdW44QWkzOWllb3ZJK2RjR0ZudnluTW4zTFJVWUZNbXpkMk13Kzk1bFJMWmMwenRBai9QZ2J2MFJUNTdQUzl0c3BkUmU0REpXWHFTdDVZelUvcHlCcFR4TzlybllwNldKbWZCcnQrMlFqNTNHOGViNVVmclg4bFo4amFXUVBmeDJ5MFNETVhlcTlWdG96eTlzRzhtY2xrSklCQjJucXZxWFd0NERzbldhYmZKNFBOUVM3S2t0cFpSN3BmbFl5M3RJUGoveDl2SFlGWExRcTlKTUZQaWVnZnd0dUVmdm9CdHZSWk9tYW0za2JtZ3JZTlpwVDl4S3JkZHVuODg5MlFnTUpVMkR5SzBBdDFjd0lsdlBzNTE1dGdmcjBLMHZKeHFlRlNIYUdnc2hZREFCblJFNVVHcnA5NHBaK0ZwaldPWHNuWWpzNWMvcjVNOERWREFHNk82MnQ1MG1CQldTRjRKY2JqUC9lWkR0alBmeGk5M25Fc29KYVQ2RGo2cXFkMGVNeFQ4eGZjMzRpNitoWEdicWM2ZWJmYnI4djlqNUZDK2xQVHRpN3V6UHZjOVFnV3pTVyt4azhQd3RMb1hreXd5YTBmazFQY3ZucWJCUGR0L1QzZkJ6WjcxWnptd2J2Nmg5dHp3WEx3M0dmS0VYcWszL1doT1hQVXREVGVCelZaYUJxc0Z4L1M4Z0FSWmZmdU5FUmRkMFFOZW5taWZsb3lXVWJxbmtYTmx6Y3FtcVg3L0gyZUJCM3ltOVpQMTFhMmJ4Mmdic2hRWmltRGRvbC92N1hsNDJkcCswWlV3dU83UUd5WG1ZNDNhT0p2THZ5bnVIKzVxQnZjcGJYVi9TUDhhVGZsZTlFRGlRUmt0bnN6dTkzbW95Y3MvdWszU3RrL1UzSHNkZnBWMmVhRFQyQkRxMFMrTkRYWmRERXJEb0FJT1hRVGxNU3pIdjZqYU80OTBCTEE3NmF2VFNuUit2dFhOa05rN2hMWURGUFY2Y3pzdnlDb2FzTFdzeVdMSnFFbGhNOGtLdlF2SWVQSmMzNlhseUpTekZ5ekxvM3QxMGpZL3U3OWpGY1VNdkNVNitaN2ZDRmc5YjdidDNpVzZMWGdyb1gwczNmQXZscFRhMXlkVXpLTEQrUDlVVlVDaTJRd0dWZTRHenl4T0RSUjBFMzV4TVdzZEx5QTc2MnZRV0FhUDM4bEUxTnFSZkl5SzlBeHF6Ni9LdkZTaTNSWU5kSWpmbDMybFFVNnhBVW9nendHSnJhWVRLZWJVRU1tT29aNzB4TDl3WnNRSkZpYTk3bC9YMmVnUmVLKytaTWw4Uy9Qa3Q2SlZabWh5RGU3eFdBczBmNjJyb2Y2amw5ZWg3anZEMnNqVldOQloxUmdZQk9sOXFkcXFxaHlQRzRxQ3ZTdC9LNEhjK1hqTGIvTnIwRnNzMHFZeXQ4aXVzTGMvbTN5aFdqeTF3eGJvNTB6WktidHdJS0tyVy9JOEFocS9OTjJYdnBqUWo5VEpuNHd0ZTRnRzU1emxSQjB6MjdyNTQ2K1dNMzRzQytPVnZqNVc0OGR4dGdGbys4L25wR3VNeHRwWStYTzdlMWRveklmcFE2NER2bTN3T2o4VkJCMzFsMnZKVzhONVhpUE80b1hzQzdsNHdPNmZCMTMvbk1Yb1dFaDhnOTByNHZmTHJHOTZLenYwOHBOZFlEbkU1ZWVFeTAyNitadk4wMmd1QXR3RGI5dzRzQUJvZDhKSXVkcDFBNDhaYmgzWjZ3T2V4MWtzVWVqWnRVYTFhdkJDbnVub2Z0S1R5SHI5L3EvWHI1VDliR2N6N3d3RXNEdnFxOUwyNUxMOFd2Y1pNN3lYbGt0NEtXQXhjL1ZWclpmcUFhME52UlVNcDczdUlock5kOW5uTjNUcHBtV212VERUOHZBb0ltQW1rN3ZMditCemNlNUZYYkphK2xrNUNuYXJ1bE1uQlpJVGVEWGtwNkdsSTVUMkUrK2RhUUlYT3NyalVlam5sWFYyQmhnN1A4dTJ2RHdld09PaWdnNzZxdTNubituTFZmaVc4K2V5RWQwTFAraExLYkl6RlhSNkNQWUJ0SnBqeUhrb2VrbVI4OXl3SnpYcm45SC9Xcy9ZYWN2c3RUSFptMjlJOW1lWUZPZFU0bm9KeEVmSkUwSnZ4aUhRSmRKeHc3V3dmcHB2ZmozN1FRUWNkOUJvMFV1U3ZHTFBRTGwzczNQa1N2UlIrN2JVREc3Y001cGFuYVdPSFROWEErM0pQZk1QV2pweTlSbk5VbHFmL0htbUg3RDNIU0d6MDc0cENXOUlicU5pT2d6MDBBQUFFWGtsRVFWUUpBWkZIdTgvWUNYa3VxcGF0cG9yZjBETmFQbmsrUE9zSTNqem9vSU8rS3MwRUg1STY5L3ZHekhiYWhUNHdhQ3RnTWpMeVlVdmdacjFHZE05eUEva0psNGR1OGE2T2R3Q0txdUF4dXNNUXhqUzh2d2YwZkVzZzVBM0E4NHgzVE9sME11ZVh1bzJSSUtnUVNHQVFxTGF3OG5Yc0lvR1RTOVhoc1Rqb29OK0YvaU5GdW44TnVtY0dMOXJqWVVnR2JrL2NRV2NnM3pvQXR3dndiT0phb2hHNlZ5WmZhaWkzUU1VSVpPMk5OWG1OZnVpQXlrc0J6SmJYcCtxbXJSNlE3cEgzbXp3N3dPbVVQSFZhT2hHQVNDZHVQdFB4cnBDRER2b2Q2STkvSGI5RDRxQ0Y3Z3hXcktwOWhtVHZiTjE1OE8ycWJ4Vm9lTTl6VC95Yy8valhQNjhPQXd0cGR2T3NaM1k4RzBIYnFQeVg5TTFyMFdzRzZVN2swWUlLbzlXcXcxLyswTDZiSmNVZGRmeDIxN25rY2JIUGlnNWdjZEJCQjMzemRJOUIzYnZrMHQyZk1TZ2pnL2hhczJUOHZlSEhlWlNCNmNwL0s4TThtZThRSktaWmQ2ckxQVHRqWHVwZGVjVmxqRlYrL2wzd0xnMWtTRWJkbnprWndLQjM0MTZncmQvMFZMUnRjY1JZSEhUUVFkOGN2V1JtdmlmdFRDRHBOK2habWdaRnIwR2puU0c2bjM0N1QzdDNldmoxOUh1VVQrRG5OVDBLTDZZUm1LZ1FzQmxJNlJ4YytKSlg4aXJjdEdjQ3AwMlovTTFsaytkeWp4aUxndzQ2Nkp1azJUWHlieTA0NzdYcHRYZWMzTXZEYkR6RzdIYlN2ZkV5OTlUUlkyVitUN0E0V0tKZ1VPV2x3Z21iVFQ0T210N1p0ODZaVU5xcFphWTdRRDJEU0tzT1lISFFRUWQ5RHpTeksrTnI4L1I3MEZzRkpON0R4MXRzdTMxTlVQRVNlazJaR2dBSzVxOXpJNTY5RUJ0QnJmUk1rSGc2NXVqTnZYRW55WjJnUW5SSkZ3ODY2S0NEdml2NmhwY3Izb3krVlNEMWt2TW5YaXNBOTF1a0VCOXpxZlU3UEhpR3hITkFwSHRZQmp0OEVraTU4WHpnTUMybWZmN2ZuSDB4YXZ0Mm1la0kzanpvb0lPK2EvcmVEYzllK2xick94TWtlcStYNDJ2VGEvTGtRWkJQLytsSllHRGtDZ2lFd0UwSEJ6ZWVoei8rOWMrUDFTK24rQTZUclJpT3UrZ0kzanpvb0lPK1Mvb1dEZEpiMDdmcXJYRGFzeFBsbnlGdUpnV2xNdGJrTDMvNFUzd21aRVVRMFMxejNBM3lBcTljY2htZVhVSDZweHVZQngxMDBFSGZLMzJQU3ovLzBVRENYcHFwLzB5L2ZzM2xvbWFuaXY3TFMrSmxQbnRQRG1CeDBFRUhIZlNkMEQrN2tmNWVhR3VMN2t2ejltdHZlQmlieDNMdy93RXNEanJvb0lNT091aHIwRnNEd0xjRUxsMTVsYy9JaUhRQWk0TU9PdWlnZ3c3NkR1bHJMWTJGSFNuK1VVRHF1YXBPeDY2UWd3NDY2S0NERHZvTzZXc3RpdzJPRlJld2VGZlhYYVluWFR6b29JTU9PdWlnZ3c1cXFUbEhRMkRpVk5lWGxGVlZYWTd0cGdjZGROQkJCeDEwMENiaEVDMWRpaThuT3p3V0J4MTAwRUVISFhUUUxucnlZTWhqY1M2ODkrU0lzVGpvb0lNT091aWdnKzRsbm5IeFdIVWM2WDNRUVFjZGROQkJCdzFvY0RnWGp5Ri9yS2ZZaXdOWUhIVFFRUWNkZE5CQkxRMTJuNXhTbWlQRzRxQ0REanJvb0lNT3VvdUNOK01JM2p6b29JTU9PdWlnZy9aUkFoVDFnamVpSG5UUVFRY2RkTkJCLytTVVlpLys4b2MvbmY1L0ROSEpHUndVQTdzQUFBQUFTVVZPUks1Q1lJST0iLz48aW1hZ2UgaWQ9Il9JbWFnZTgiIHdpZHRoPSI4MDFweCIgaGVpZ2h0PSIxNzlweCIgeGxpbms6aHJlZj0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUF5RUFBQUN6Q0FZQUFBQ2VxQk1tQUFBQUNYQklXWE1BQUE3RUFBQU94QUdWS3c0YkFBQWdBRWxFUVZSNG5PejllNUlqeDdIRUN3ZlFQVE9rZE02OXE1S1oxcU9GYUQwMDQ2YSthOGNrY1I3ZCtQNUFPK3RYRG8rc0xIUTNOU1FyekdBQXFySXlJMStSN3BHUE90VWhoeHp5WGNzLy92YjNVMVhWUDMvKzZUSzZmNGRzUFhjSllWeUhMbzVUZUo3L0ZjK2x5OWNoaHh4eXlDR0hIUExIbFh2Qnl5R0gvS2xsQVB3ZFpOOHJBdkZ2SVYxY1d3UWlrWWhSR2ltT00rS3FsLytLNjFSVnp4dnhicVhIZEovMTR5QTJoeHh5eUNHSEhQSjl5MEZDRHZsVFNFTWFUdmI3b2E0ZytWdXRnZlBGd3A5cUFkQ2QzQXVzOXdEL3Q1U1V0c3U5dWpCT2taRG5XcE9kdmZGUjEzTXRkZkx0NWRyRndsZTQvcXNjcE9XUVF3NDU1SkJEZmxzNVNNZ2h2MHZac1FUcFZGZVFLcUJLc0NrdnZBRHRBOEovcTZxbnlzdVAzb3VFVUYvcDk5cTRadlVabFNmTDdUV3pGcEp6cmN0dU5zNXVhZGk1Y2h3ejhhWjhTejl2TDVlcWc3QWNjc2doaHh4eXlGdklRVUlPK2EvSkJwRTQyZWRpbjVFNGVDVEJxRnBBcGo1SzQxeFZqeS9QUGxmVjF3M2RKSW1NdklZNDNPeWJ1RE9lUGZxTWxtWjUrYitGY0RaalZqY3U1VXE2cUE1MWZVUVNKU0tuQ3F2ZmFmYkcwMjUxUDRqS0lZY2Njc2doaDR6bElDR0h2SWxNRUlxSGw5K2FmU0NnVE4rY0VkaExRbEw2ajBpZkpJVHlXQXRaZWE1bFdaYjBJdWg4UkxpMGRPdXRpTU5yOW9iY3N6OGw3ZTJnUGpYNHYwZG1kU05CRk1GNHJ1c3NWUmVudm1kSWlOckdFLzV6bndxSlRab1JHbTNVdjhuYlFVNE9PZVNRUXc0NTVDb0hDVGxrSlpQTG5CaEc1RUlncmdObEJKRWRFQnNCTzNxckNRaG5UbS9pVEFnQnBpOTMwa3pJeDdvU0VJSGQwOHYzQS9UL1dBc2dKaEY1RFhFZzhWTGNyeVVoYjdHVWF4VDNtNExxZi83ODA4WGFJUGZxbk90YUR5c1NFcDdaSzZwWGtoZm15NWZ5ZVZ1a25DcVRsYXBCZlJ6azVKQkREam5ra0QrYkhDVGtEeTRCME9uN1pxMTdiUU42aXNKcStaTEF1Z05Ua29WSFhLZVhtbnNFQkRSZHA1RyszV1p1Z1hxQzJLcGxodU5iZVA0QmVTSTUrVm9MaVZLY3luYzNHN0pYdks1bVBQbXo4ZDB6ZTdRbFhaeDNrUjhCY2JSWko1QlZ0NGNHM0NOT2F0Vk9uS1JTSG5GdmEzbWE0cXJLTXpZenN0bzNjNUNVUXc0NTVKQkQvbWh5a0pEZm9kenA5ZTJlNlFnRGZ6L2JmZjBXWWZDTndSNm54LzFRaTVlZmV6SUlEam1yVUpVQk9Vbkl4ZjZUVkh5b0JkUko1N1R4bkY1M2l1SVRhZmtCK2RhTWlRUFVwR3Z5bXFkWkhmOTlyN3lHaEhUeGJNWGxNd0VwbmxWZEJ2TEI4RHo1U3ZYVnppWk05ZzJSU01WM3huWHVFeXFrOVlEZlc4c0N1WVJyU0NRSE9zY3lQTWpJSVljY2NzZ2hmeFI1M0E1eXlIdkpDL2h3c0hHdUJUUi9xcXIvMU8zK0JNa2VqM09hN1hDdzZ5RExDWWlMTDBucGxrYzVFU0V3NHoxNXZCbHVsRC9GN2FjdCtkNEFrbzB2cHJzdm5WSFlWTFlDclBUR2o4RDJyS1E0UmpOQmU4U0p6ajNQTTU2OTZmSmtza2pVQnNSaGFvbmJIY3V4RlBaakxZY1BkRE56MUVYWFoyWUkvZmRLU0NZYS9hZnFqTThkQk9XUVF3NDU1SkRma3h3azVKMWs0NzBVajdYMnpuK3U5WEltZWV3LzF3S1MwdXpDUGFBd0FldE9Sck1iZTVadytUVXV2Zko5SXBwaG9MNGpiL0lXVUhPaXhITHU5T1gxUk1MOGVGbWZIZkk0MHY5Tzc2NWM3eUVCL055elZJdzZhQVpwUmpveVdyWC81WVREOTRrUWVPOGdJcHlGcTFyWFcwZlN1eG1TTkR1bzM2UGxYU01ic2FxcldYSmh5OWgyUFh2SUlZY2Njc2dodjdVY3k3RjJTTmhma1FDbmc5SUV5T2dkNXA0Q2o5djNSeVRnMDhsYkxPZlpFcVV4QzFBVGdPTmVEZWFUeTJWR0JDeHRkbmRnNk11QVdsQ0xzQTdpdjlXNlB0UFNvcFBkYzIrMms1ZFJQYWEyczdmK3VUZUJ5NWtZMTFZY2t0RXNnT3N6c2l0djJoNEhTN2xjajlTLzVJVHhaVmxWNnlWMkkzR2I0R2wyUkw2TEt4TEdFWmxvOW4xcHlWbFYxYmQvL3Z6VHZYdFREam5ra0VNT09lUmQ1RTg5RTlJTTN2b3RJRnlWd1lqMkRqemhQejJzSXcrN2lFYzE0ZVQ5NTR4QkI1ci9XK0pnWitibGN3NEVIYkJ4dVE0SmlJUHZpLzFPUU0rSkFOUDAyUTEvbmdUZ3NkYWdVSit6WFhjQXlmeWw1VDFiRGdER3piUm1IQWRLVzBUT2p6cWVXVmFVNHR6U3RmdC83MUt3YVdsTzFhS2pvRHZ4U3JvOTRYcHFRMXVpOGxaY3JIKzE1NWs0bE42d252L3h0NytmTm1ZNTFONGVxdXJ4SDMvNys2Lzk1SmdkT2VTUVF3NDU1SHVRUDl4TXlJUkhkRWI0WGdEdEFmQzRIdkZmd0U1QUk3MkRRcklYQURpUXVpZU90eGFDYTRHNXRHeHNKQ0p4S21jdk13S3lOQ1BRTFZkeWo3YlBtREQ4Q0lpTGdJaGdmUTNQSis4Ni96c0k5U09HcVYrbkErTWlTZk5udTFtbXF2V21hb2tmcWR6TmNIQ21hcmd4L0RzVDZmNkFhNm9EWGZkM3dvaWNxYzdUYkVncVo5N3o5cHBtekRyeDQ2NnJhdmVlbHpSYnk2T05iK3J1SUNXSEhITElJWWY4TitTN0p5R0QyWW90MlZvMjBua2QzVU9md0IvM01ueW9CY0JVcmNHZHZQc3p1blhpUzN6MkVKRTlIdWl1Yk5QekloNmNvZG1yRjQvTzVYc2ZmSFloeFpuSWdPdnZTN3owbTZka2JaR1FEN1VzeGZJWDJIWExqNXpBNmw0M3M1UHlwM3RNWjBSRWt6N1NnV1hzY1pMNFhTcjNqOVQyT3AxSDRtbFB4ZkdLZDRDbzdIbllnY2lHcnV1ZVppOThscTFxM1M1Wm54MDVxYnJOMXlyZmd6ejU3TnE5a3ZyQ25xVmxsNE9ZSEhMSUlZY2M4dDd5bTVBUURiaURKUlA2UGZNeXVxcGJNSk5rRDBoUGdNc0JtUy9oSWNnVWVQbFVWYi9VN1F2bkhGamNTMEwyeERNQ1JTbXNIMHM3QXFkY3l1SkFka2Jjdzg0eVpGd3NSNThaU1NTRmVmNkFmQ2lzYjBvZjZVd2QwOGxrSHBiZkpBNGRhQjJsemJna3ZpVFBDVkhxRXlUTitwYVgvMUxyR1Q3Rm1XYVkvTC9YOXl5WjR2dFg1SjFuZkYwY1NUcjc0UDNaMnhuYkEwbkkxM1UwSzhMcTRhdjZtUzJtRTJYalNHS212eFgrclNUTjV2ai9nNWdjY3NnaGh4enlwdkltZTBMKzhiZS9FNVJXclQzbFZTOUE5UjkvKzd0N2sydndQM25FS1IwUmNSQXk0MUh2dk1Dalp4VG1XNjNCakY1Mjk2WFJ6K1B2MGtrNjNpUGM0TjFKQWgzdWVmZFpJQktIVHIrdWpoTHBFWEJMZ01qZldKM1NKRm5UZis2SDhMaTNkTlF6ZXlTMWxVdTRuc0pTbi9SL0s1N09LKzlodWRUSGljMEk1TElmY1diRjA2Ym9QdmRMNlRwdEJHY29aajMyWHQ5T1RDV2VMdHNaU1cvaE53K05JS0hrdDlMc2xoQnVTbkRLZExidVBXVkVRQXIvVDBIWFl5blhJWWNjY3NnaGQwc2M4UHpzZVcyQ0hPeTNTSUNTWWRPeWo2cGJUM2ZuVVIvTmlzeElCK1I0blhHZjdWb0NvMXBucjZVOXl2UEh1Z0txYjRqRFQ3bHltZkdJQzR6UGVQSDFuTkoyajNjSzYzWElGN2N4SEwzQldrYTFkMlpIUklaTGhDU3BuVERNYUZaQ1MyeDg1a1B4SmNEK210bWtiZ1prSzc1UityTnRmTThzQ3ErcmZGeUgwU3lHdjBNajZaQkluanNuZk0rRDJvTDYwVE4rZDVJSUNOdE1hamVja1JJUlN6TVg2bU5zKzhxamxyVTlJQjY5OExKdzcyWWZDVzFveWxDejVIVFdKdXlSenQ2UmZQQVFoUkZCOTNqMVVSMDhWeDBrNVpCRERqbmtrRjdjdTNWM1BNMy9FYkZ3YjNyeWRNK2s0d05sQWlKK0w4V1Y5RXJQYmVrbG5aNXFQZFAwV2hMaTRiY0FncC9XTlJLQlU1NzBsYno0bkFXcHluczV0cVFqclYzZEt5MHQ1ZkVOdGl3ZnpVSTkxUHFsaEE1K1o1Yi9lTG1QWm5TU1Z6MlJYUWVQZTJiS2tzeVNucXIxWHBpa1UvTDZwM3lST1BEYWsxMzMyUTZtNC9veEhTNXpHdVVwRVVRdkR4RUhPZ0tjc0VpNFIra3A2UEZZdDh1NnlzSnhvL3V2ejI0QjhUMXZURWRlOXA1dWxpU1JFcVpMNTAreTArekxxUS9QMnZXVjNQRmVsQzI1bDdUNTg5NitVNWxJM2pTdmh4eHl5Q0YvUkhrckVuSVRyLzIvRjJ6TmVJa2RGSFVBVmZINUxJeW5rMlliOWd3VUhKUVNTWEk5UEgwWHhwWFNHajIzRllhU0JsZ0hIUDZSTjdqcXRzeTNaZzRjQUhHek9IVkt6M09kL21PdFoxUUkwUFF0VW5XMjY2TzYzU3B2NW9VZThLM3c2VjVLbTNXZTJ2T3NoOXAvZXgxd2o0ank0QTZDNUVCZ2VVbzRDOFZaQlVraTR1eS9XMitpOStlMnlwREU0bFJMVzAwMjRnRmhSV0Nsank5QmRHSS9XdUpXVmZtbGluZnU5WGd2RXNML2ZsOWhVbnYyV1NhR25YR1dkSHJ0c1pFejhiem1lWjZ3eGxraXRRTzMrYStxRnljbTNqNE80bkxJSVlmOFVlUTlTVWdDVVZ2UDhIdjBqSHZ1MG1EWkFYZUNWWWIzZU5PZ3U1V1BEbmlQZ080c2thRE9WZHNnaElQa0huSGc2c3RzL05oWEFzdms5WFJDUnRCSjRqankvQ1l2cmNBeVh6aW50OURyTkN2UGV5SWhJM0VTNmUyQmVuWGw3Q1J1NUJYMmRwektaRytmSWlHb3VtMzNQTDZYUzVLNGlkL0pleUtvdXBmeTRNc1JuYUN6UGV5ZFdldEVCRXN6R0t4dnpsNUlQODUwaUh5UWxEM2lPVi9PbFE2dHVHa1BHeWQ5emRTcjI2MjlmVHZGMTdXdkpCMEo5MmYySGxTUjlCcWwvUjZTaUkvM25VUTRLanozYWwwM2lNanU4am1JeXlHSEhQSTlpcE1RUDliMExUdzhXOERLRFRrSHRlUWRINlhENTdvd2FXTzFlMTg3c0RRQ0NtOVJOcVA3RWg4UXUzZ0p1UGZxNU9EU0IxbDVtQVcydUFHY1htRW5peVJSSkRnT2drZEFnSEV6WGw4V292WDZhY1pyVk5aZDIvUnJybDkzclNQRFcyQ3pTNVB0ZGlRSlZIRy9nM1JJaHd4VVpTQTVBcWkrajBweG5Db1RsNnBjVG5jQjJPYmtQWkdRMU04NHk2R3dveU9qcGV2WHVwMUowYjNaRjVaMjdXcFV0eWY3bm1rRFd6SWkvcFN0ZktTNDNrSzNHUjNlVWpweTBkVkxad3QyNjVwbXhacVpzbVNmcTdrbTNUbU90bzZRZzZnY2NzZ2h2N1Z3ejRLREZTY2diK0hwU1VhYnZ4Mms2cHZHdEpQWjA0OU8xY2ZwQTBqU2J3c2t2S1pzWnA3dEJrTWZoR1pPN1VscE9wRG9nS2NEZklYM012TDJrd2lPNit2a3hjWGJRWnIxU0xNcmU4SFVLUDk3Z01rbzdSUm1wQ2YzN3N6RVMvQ2hNdktsUkQ3RDFzbkkrOXVSaDR2cDYvZWtaN28rSllHQWRQdGVGRGZURlVEakJ2TkhDNit3NllXYyt1M0VmT1MwNlByZGJQOGZ4ZFBKVmw5bnVIdGtxKzNlRzEvVi9UcmRrMmF5R1h2enRLZGVxbXJYa3J4a243ZkdvM1N5MjAxOG84TVRrcDRIYVRua2tFTmVLNmVxWHczTENQVDVJSDdQTWdER0w4T2VBSnRmbytkMkZpQjVtaFNlN3VTekNnU3pLUzczSW5kR2VBOHdHTTFzakVqVkZvQklYbkEvZVdxUG5reGJ2eE81Y0FMQ09OS0dabitHd3RPVnV2alBkWnZlUFlQalh1OHY2NDFDQXAvMmlLUTZUYk45cVp5MC8rVlM0L2FuWjFKL2NwMFZCL2VHakdUTEdaSFMreTNCaXRxWmYvUEVLNTVnUlpLc21STWRndURrOWdrZmx6TStJbDRkQWI2SG1QS2EwcXZhcnJPUnQzekczcVJ3WGZqM3FHYzZ3a2JwN0FiK2IveTg0cUM4S3I3SlBVTmRPeG1ONTVMV2pveE9kSnNoVEZzbndoMXl5Q0dIVksxSmlQNlBTQWdIV01rOVhpSTlsd2hITmZjVEFabnhWTHZRUzhyOHVpZVhnenk5NmlmNzNRSE9KR25RMTZiSDVNM2Y2d0gwUEx2TzJpK1JkR0Y2RGxiU1ZEN3ZqK3FwODNZbnd1VHBhM2tNUGRVQ2h4M0FHMTNyWkFzNE8vblM5Mnk5YjZYTno4MFJyN1VHMG56QjN3ejQ5Rm1PV1kvNEtFNCtOd09vWitKOUM3Q2ljdkwzOWtoa3V4S1JZeGx6aVZyaFc4dTBPbDA1RTFJaDNONDJtUndPSkV4Yko0a3BQTlB2d1B4ckhCNHB2bnNsdFFWM1JEQzlrNFhiTzNQaDQ5SHEyWTE5UEo0dWJibml2RnRlU1VMMHZhWDdwbE94SXlLVFpiTXBCMUU1NUpBL3IvakxDanNBUzJOL3F1c0dZTDFjckZ0cU1aSTB5SENnOXcydTNmTXpZVHg4T24xSm0zUGxBVDNobmpZNWQxNURuaFRFSldHbjZrR2Y2OWtObktuOFI1SUdVdjBYT0ZOYVcvWEdnWituVDdFTUhYQjE0QzBSa0VSR0diL3E0QU4rZjBVNHoyOUhrRHJaOGxJN2dVdmh0dXAxUkpEMVRWTE1VN2JTKzFCRVFEcWRVdnl1NTFiZGRKSUlTSmYrNkRsdkgxN2U5d3JMVW4zUzMybkRqOUl2L0Jhb1ovbHVsVFZsaGhETTVKRjU2WUQzbnRPeFp1dklDY3A3Z01PdUhTVTlVaDlLRG9FVTc2d3dyaHNDd3U4QjRPYlk5V3BRdmxPMkhEQWRXV1JaeSs3RStOS014bHNTaDltWmxiZEs3NUJERHZsK1pQVEdkQUlGQWN5bldydzkvaGJrMXhnSkd2RWs2ZnBvY0VxU0RCMDM3TW5yTG1IK1JrU0FhVHB3RUNoUHkxLzBlM1lKRE1uRTFySzBwS3NJRmsvNUdRRUFidloreGpYbWpXa3luT3MrSzB4Yi93a1N0QnlKc3psc2Y3UDdVVHhOa3BnWjc3V0hIYlVOdjM2MjMwNjRlWnd3eVo3U2ZMVHJTWnpVRTdRbXovR016QkpoMXlNQlJSS0RSQ2hIOFcybDVXMkhSSnB0dmt1SDlhcjRadk9kK3BQcU1vVVp4VE1DdEs3akZobWV1YzY2MmtOd3F2S2VvaEU1SHVtbGNON2V0aHdBYnc1U2VaVHlwTWYvWGgzMmtGUHZKMXZqYnlySFBjNmFWdDdwWk0yNzBqcEl5aUdIL0Q2bE82SjM1SjNVdXVtcVpYMzBIcTlaNTFYbTc4NW9wb0Z6Rk8rc0NBenluUUpWeS9LTHIwR25sRGJmcHN3WkVzNm1qRUJ0cDF2VmVCQk8zdTVFUWpTRGRhN3J1eEFjNk1ncjlsVFhONy9MOC82dHFqNjlQUE94Yms4STZxUURyZzU0cXZyTnhOb29MS0w0dGRidmsvQTRSMlZNajE5SDVCemNDWWc2OEdQWWREM1ZxZUxpWGhmV0wwa2YzOGJONTNYYVUxcStSeG50TVdGODNiMlJ6SUNtVTYzcnVldTdpYVIzY1h1Y2ZzLzdMNTBuOTlncXhjc1p2cjBBWFhFVWRObnpqSmVQRS9XcTNBNDZzRnJWMXdYYitVejk2aG12RHo2NzVUQkpjYzZTbGExNHV6NDQwdUV0WkErNTMwTW9rdTcrVEhJeStJYjB0SStOMTFmcGR3RC90eVFoT3lYVzhVRlVEam5rKzVOVFZUUW1XOGJsUXkwRDFXTXRnSFltdlV2NFR1bTZ4ejhaV2Y4L0FxRVUzeUN0WjBsR1RuWDc1dVFFQnZnczE2THI4NkdXOGtsRzNnbWYzMHNib0FsY1UxNDc4UCtoMW04ZS8xcTNBUHRETFROZTNIK2c1N2lCV2ZGMDB1bVI5SGNneExBTTN3SEo1RDMxQWZwanJaYzVkU2RvT1pud2VEUmJNYXBQWGlkSlZSa3lmOCsxamxQUCtkNHJFaGc5UjdMN3BaYjZHMjFnVDNWeUx4R1pBWHBkbUFTNnRod09iQS9wSHVPVWZpcVByVk9yT25rcjRMbzFpOWs5azlLVEkyaG1mMVNTcmo2NjhrL2lwSkQ5ZEphMGRiYVE5MGR0alhwVXpSM3cwQjBFTVV1dWs0eWNRak54YmJYTFVSc2NsWXUrdlYra2NDeURJWEQvemdqSUZvN2dpb1JWbXp5SXlTR0gvSGZsMTg0YU5wcDFIaFlCSG9Mc3ZSc2tHYStINlFhY3p0UGpCclRiaDNHeUQ0VURwVHlxQk5zQzR3bHdLNzZ6WFNPQTlkTjRYRWg2RWhGSjNySkVXa1lEMmFtV0Y3TEpJMHN3VGwyNittUWNwOXFlNGVsSUNNc2wzYnNITktjeWVrUllBbllDMUJuUzZtbG9abWFMSlBPYVNHclYwbzdVeHJnM1NmZThYRlZlZXViUm50VU1WU0ZjbWsyUitCS2hHYkl5SW40cC95TkpwREdsVVJhT0pNekRpT0FwRHMzNnBYZCtqTko3TDlsTGZxcldKTlBCTm9HK2hHV1ZRRDM3ZmdmY2tvN2RmVC9vZytPRHdxVURON3p2YmRrS1Q5ZkRrNWlQK3FXblBkc0dtUTYvN3lHQUtjN3VXWTVaWGw1SnJ5NmV0RFJZNFZQL2pTQjlabG5VYjBoUVp0UHh2WXBUQndjY0JPV1FROTVmYmpweFEwYTJqUEk5M3FNUkNkRmdzdVg5bW9tYlpJQXpGZFJkUkVOaGZja01QYW5KMkNkZGZIRHpRVCtCcWRGZURSY3RyZW9HNVk2RVBkUVZzRW8rMXkxSTk4SEtRU0RCUGZWMjhYS2ViVk1leDh4Z3czcmhyTTFqVmYyQ2U5eWNQeUtzSS8xNENzNklLRHNKOFgwZStpMWlJZDFFOEJqdWJQOUpZSjdyMmg1MFhlLysrRnJyZHBkQXJBTXlTdGUzdHZwa2VtWjBQOFdUeXRDRjVhVStYTFcwNDg0THY2ZjlkZnBSOXBEWVBlSDFqTWgvMVpKSHQwMmVob1AzcWpVUVRXVnpqeDMzK04xV2xPbkg1WmVkamZFNEdROGRHRzRubGI5a1I2bS96eTdObGdQSEo0YnA5dnpOeWd3SjZmVHJiRTZLcDJvOXRnN2wzdU41ZjBQeHNxRnRxN3ExZXl5alpPODg3aVNSbkIxeXlDSDN5YzNHOU9ESnVBenV6UktRV2MvajJiNlQxMmVQRVNRQllUeHVqSFNONEpUZVI1S1R6cHZrZXFiMEZCZVBudFdnT1FzQ3UxTnpaZ0MrOHZaTDNTNU4ycG9sb0JkSk0wT2V4MUU1ekxhQkZDYWx3ZlFadDdjaEFYSXVMZE45UHJ2VkxoMW9jSDlKMHN1dkovSHl1dGlIOFlsd0tELzA4bDlxbVFXcFd1OS9ZUHRuWHRuMnFFTloySzFyZm05VW5qT0UwdXZQbHlFU2lGSTRzNmVUKzBiOVlHOTdUSHFTSUc3dHdYRVF1RGR0a2F6VXp4SVE4LzdCNTlqMnQ4Q1k2ekJxMzJremZYTE0wS1oySkpQM1ZjWSsrOFUwZUovdHBNc0gwMlM1NkwrWHkweS92cGVBak9MdDZwaGxXT0Yza2oxMS9aWnlEL25lRStkTXZ2bGNLdE05aER6dHBWMWhpb09rSEhMSW5JeE94NHBpeHhYdUJaTnBzTng2aHI5OS9YeVNrZmVXSG1WZDU0eUx6OER3V1RmNnZvVExkVDNaczd6T3dWWGZlbjRMcUdsd0pTRHBDQU9GNGJqc2g2Q0ZubVJQZzNLdjhlYnpNd1BHNkY0Q2ttblBoSzVYNVdVaFRuQm1BS1duNzIzRDAzRHlVN1UrYnZkaVlSaG44aUp6ZWFDblNiS2lOc0c5VHJ5ZVNCUjFybkJkMTdwMjRlM2JwYk1IZnArNmV6MDloZXNPc0xiYTRXdEFndEo2ck52OVk3NW5TanJybS90V3ZQNUc1Y2w5YVlwSFlYenZVQ29MaG4rdzUwWU9oQ1NwMzNnZWZLOVpSenEyN0lkMFozdnc4bVgrRkxjdkNhT2NjWitrbG1YTk1xZGRwcDFJL1hhdnNEeTJ5c1RiQ3ErZnE2K1RVZHh4Q2RWdlBBc3lzaldVMFpqaGJkaUpONThmRWQ1WlhmM2FhaXo0eDkvK0hnbmZRVTRPT1dRdE15VGtWd1BCSXd0M1BMZDFyd01PZnBRc0I0N1pORHNBSmZITjR1NXRjOUxoWUwvN3p6UWRxRkpHK3lrNm5ha3J3NDJBWVNKSFZldGppQWxJdENmbXNkWW5ZUkhjRXhnNHlScVJGdWsvYS9SSGtnQ082K1poSlZ1ekdQeS9SVUpZSHc1OFdEZGVaOVNqUXZpVVZ0S3ZhZzFvRXdDODFIcldnMkF4NmVBYjViMnRVOWVraitkbDFDNVRYbE9iOFJkVyt2MlJkRURuM2phb3N0QjdiRlJtRHBLbHQ4TFFTKy90TnVuc3M2V0Y4Q0pCVlJtWU14NTN3RHhhK0szbHI0b254ZTIyWUF0TXE3OTRHWXpTWnptbCt5clRSNFJ4MjY1dzZXQ0lxb1hjcHJUVGQ5Y3Y3NVZWL3pKeU1DSW1idWM2bmZneXpWL0xaMFF1M3BCNHBERi95MzZNSk5sSS8rN3N5TWptZHpJS054cG5WbkdrK2p5SXlTRi9acmtoSVkzUjJRc2E2VlhTczV3ZVowZmtHbjBKdlZNNlhVcWtaR1M0M0V2bFlJeDYrYUE3TWt3RUZIdU5zcDZqaDE0NmNJa1FRVEUvaXFQcWxnZ2xJN3RsWUptMlBMZGN5bk91cWgvdC8rZksreDhJVnBPSHNrTDRCR1k3U2UwbDFYMENYZ0lVQW9HekEwVUNxU2tkYjFlZGg5c0pTaG80S2Q0ZVNTeDhLWm4vbGlTQXJyWWpjdmtOMTFQNkFtc25DelBTLzluQ09DRHdkamxxbjd6dkFOelRIdlZKeHBYQXo0aG9qa1R0U3VYNXNkWTJUc3NXQ1d3N0wvNG9qYTdmUGRleWIwajU2TjdtN21uUjRhQ2xmZnFmbnZOcnlYNVhyY2VUMUFiVFlRSVNyd2VTTnAvSll4NVlIb3hIYmYxVXk5TEZTeTJrMFhYd2ZRUnBiTkE5bHZ2VUp1Y0p1WGsrak1WZEdvbWcrTmpnOW9TMk9FcFllcDNTNkFoRjBvOWpiMmZuUnJLRlFVWkVyUXMzVzIrZVQ5cGwxNjBicC96NVMxWDdtb1JqU2RjaGZ3cTVhZndUaG1kR05HQjRXZzZlTlVBVGhOTkRwbmkrMVVKQ0NuSDQrbkEzckp4RjRTQ29NQnkwdTBIUUIvQVI4RTM1VlhqTkxqQnQ2cGdHWDhhMWRSUnVNcXdKWUNVQXk3eWM2d3FvL3ZmbC81ZTY3aUhSU1ZqU1RjZjlmcXYxSU8relM1UmtiTHZsVDkyZ05FT3d1R0c1YXU3MHRqU29KdktRNGlHeHJDYWNBd0JmUXNQMG5BQ2t0cWlQcjJQdjhxVjBkYnkyejRva1VxTjNramhaT1ZsNEI3OE9GbEo3N09wWCtlWjl4YjkzMmN2SlBvekxRY1RlK1BrOFQ1MlR6WHF1SzNuL1Z1dFpKZG9GbG0ycXZ3UVV2ZXk2WlVHcExaQXNzMHpZcnJvNEVxaGlmTW8zQ1JMenhIYk1Qczh4d2ROUjJYcS9Fc0ZqZVBWN0p6cGNXbldwNi91TzFHOFVEL2ZHcFR4MklKLy8vOXVTeWsvbHdiNnFNRDViTkJOL0F0TXp4Q2c5TjFvdWw5SWNwWlhDZVAxRW9CK3V6OVFsK3o3SFVCOUxHWFpQMlEzMU9NakpJWDhraVVEQVRzWWFnYTh1VGdKdWZuUmFqOEp4R3R3TmdyOXp3NWNCY2UyMUEzY0hUbnhXQUU5ZVN0ZWRIclZrWU9qeGRzTlRkV3RzbUIrbXdUWGVGSUlLaFdjNU1PL1NnZC9WL0hkOVJuS3Vxci9VZFVia3FhcitYZGU2OHowajdvVm5HU2N3MDZYZmJRaE5BMFJxbXgyb3BGNWJocHNrcEFOcER2U1laaHBrQ0g1NHZac3hTRzJubTVGZy9IeG5SRWR3cXRZblo2VUIwL05FY3NUMmxzcmF3V1MzdktoQ1dJL1RDWmpBNHQ3QlY3cC9mSG1XU3dzZDNGWmxNRHFLVzdxci9nWDZkSEtkdnovSit3dnRXdFZ0MnFkYUh3ZmR0Wk1FNHAyMHV0N244TjlCS1pkd2VmM1Q1bW8yaUFTQTlzTGJmRWR1K0orelI5UkJiY2ZMTFBYRlpKdjRyaDdGTTBOQ3ZQOTliNUpJRWV1SWRYYXAvTUxYVWR5ZG95WEZjYy9ZazlxdjE4R0lZR3dSb2xrU1FoMlNmdnp2WlpGMFN2RjNkbi9VTHpibElDZUgvQjVsdENmRUdYenlDSGw0Tnh3aUl4eFFudW82T05ON1RpUENUc3RsQWxyNndMUjhNeDd2K1dBNU1tZ2NySk94NlF5akF6N3FJYmswNFRRb3VrRjFnSnJpSW9HWkpSWjgzdlBwSU9WYzF6cWlKNUxoNlVYMDllQU9XbEplbkV5NERpbWN3ckx1MDNNSjBNME90RWtmejN0cUwzNmZaSmRMY0p5Y1VRamdmQzM3cVphK0lGREd1TDVDajFHNWMvYXRFNldwNTd2NENFellIcmZBUU5KcjFCYWVMTnc5QXkxblF1bVJud0VETTVMMkhxU2pjOWxlSEV4dnhVMzkrTnZ0MlRsY0c4VkxieTRkTzY1ejBrSGhPRHZoTTc1T1hoS1k5TDdtQk5rZE5pbE9DcDkxL1Vsc0daYjU3ZUo2TTlsNG4wWm5tMGRDVzVHVy9QbTRwYkY0SkIzdzl1V0ZhdXRiL1hORTlOd0dkT25yZTArZjdleDNTcXZUMFdYVXY1STlHNDNUSGVuWjFlWlNlenFJeVNIZnU4U084ZEtZK2JuVVhLZlRnQ1pEOVZockVQdTFya3Q3ZkkxM0d1d29CTGdDZG1ud1pSeDhSaVJBQTlwbzhQZk83OHVGWklBMVlDZXdrWXduWjNIU1FOdUJTTlpCa2kxQTZYcU03ak9NUExvLzFMWGVQdGQ2ZzYwSW9aYkxrVlFwYjkzcFdwMnc3anBDcUxTZERQanlqcjNTQVdSZkZ1ZDlnWjVhdGpmR3kvWk43emhCSDRGeWQvTFpMRGpwQmxxWERzVHB1ZFFYU0RyZEtjRDM2WFRpc3pCZHV2ck5zdGhicjJvcjh0SnI2U0Ryem9GM21mNTcwaVJBMDE0MjZzMzliMjVYSEF4N3ZGNFg3S2NFNTRuTXp1aDlxdHNaSTk3M2NpQnhTWEZ4OWliWkhiYjVqb1Njd3pOYjlzVEhycXIxa2MzdUVFdnRpdnAyeTBYZlU5aU9ab2dxbi9QeVVabnhFQVBGeVdWdEtTN0dXYldlcGF4YVpwRm1acG83OFJtV0xidmxZNFNQbzZObk8ySDZLUzk3NDNNUy85cDQza0xVQnFwZTZ2MGdLSWQ4RHpLYUNlRWdRZTloYXJneWRBUlhUL2lXY0dCeWd6RURrRGxMSUU5ekN1OXIrV1hVdVZ6SW4vT0JhMFNTUkxDK0JCMDdVdVVEaXh1cVVia21yMDhhSE45U25tc0JJdzc0cTI1bnByZ01wV3BkM25wbWl6Q3h6RHFEN2FCZjhYTEdJVWtDOEIxQVNpU0N6N21PckNjdGo5STlMZ0hpeklpZWMxM1NNcjJrdzBnY2hMak9KRHA3NG1BK3FDdkprK3VjK3BPTHR5K1daZmZNakRCT25yVEhzbVkrQ0hydjZlMGZWbVVBQUNBQVNVUkJWRiswbFdxVGJ2OTgyVk95RTEwK2RKOWwycjNucGVvMkQ2aytkSjNnM0E4TDZXeXh0d0U5ejN5NExSek4zaVl5NG1BNDFVa0NmU0tnVld1bkYvY2h1czFKZG9IdCtMZFlqcVcwVkFkYjc3eWhVRmZYbCtPbCt2N0labmJnK2EwSldUZGVwclM3YTU3WExxNGtqZy8yaUpObVhoK041d3puMXpzczhCYWkxU2ZucXRVeHdpdDlEM0p5eUc4cGJVZkZiRWdDd0tQNDZOa1FJQ041OExXb1RFZWtwZXZZK3FZM2hzQ0JPcmpIcTJwdGNEczk2Q0ZMZ0pnRHRrNlZjdVBGd2Q0OVNlbmRBTzdSU1VMOXFOczlhK1VwVzZDZFUveXNSOTNuRWFFS3o3aEhIa2ZYb1J0d21OKzAxMGoxeWxrcEJ6S2NwWEZ2dmV0RlBUdy9ET05MMFZobWZDY0g5OUlvYmE1SmQzbVBRWURscGFPWFJ5Qno5THp5N1cvdjluYWNDRjdhRitIZ21JREFDUXIxU2JyN3dFN3ZYMnFEdnArR1lWUDhuazZuQStQU3RSSFFTU0RHN1E1dGo5cE9sMytXODhXdW4rcDJtUnR0cG0vV0hvRkVGN2FUMUJiOG10ZDM2bTllMXV6ekNmQ3AzblVNTVIwQnJndDE3c2llTzY5K0M1REd3elgycEVzN1YzaFdNNEswUDFWck8rRGk3VTkxUmRseS9HenBuTVpKUG51eWU5NnV0c2JQVGdjZjI5bW1xbktiOGpqZGx2bHpNM2xQK1hxdjl0V1ZvZDlidGJtRGxCenluckwxbnBBOUhVcmk0T0ZMclExSzZtVHVEUmtaTlhVUUJ4dStiTWFYV1hBWmxnUFVORUI2ZkF5VHZDNHpIWnJoUFJ5UGZmUjhQZU8zZzVrWlEwL1pXZzdqMG9GazZVZTlmVTF5MWRpVGw4cXNDK09ES3BjOWNWQklCTVdYekkzYXRldmhTMXdVaGg3Zk5JQjl3MitGcHdlU0lKbGgzMVBVTHhMb21ubld2ZmdTdG9ja3ZPY0F0Q3FYZVhkL3BITUM3Wng5VFdFY3pHNzFqYTJ5NjhpUnhQdHVFcmNSL2huRlg1Vm5NcVF6NjE5bG8zczh0bm1tdjZaeVlGcGIrWlM0eDk1dGJ6WC9aK3FCTTJEcEdTL1BzNFZ6UjhONzlGRnY2NWZhdjVSVjRxUk9vcVZUSG5ZckxoOGJmUVp2Qm1qUDVDSFpFQWZwM1hONzB2RjRQWDJHNld5R0V5Qy9UNzFTMmhKdmF5bU5MWm14QjVLT1lLVjdpdmZoSDMvN2U5VkJTZzU1SjlrYUhINlZmL3p0N3lkdHBwdmNWTmROOVhaZ1JOZjVQaEJmVTB4eUlTSEllNmpydW1ZSHcwLzJ1K3AycVpEcm9XdS9ka1k4cDI5NjFEbUkrWklFTGszemZSTUtrN3d3WEJwQjRLdjE3Um9VRWloMGdDNXhFcExBNDE3d3A3QmNncVU4cFhnOTdpM3BCZ045NU5uL2dIdGFFcVZqVXJjODBFbWZSQlpaTjE1L3ozYVB6Nmc5c2oycFRidzNDV0gvcUZyUFRNMmt5ZWRWeCtuRmg3TmtNN1c1amh3ei9BeEJTSktlNmNETlZocnEzOTBNWkFJRnRJa2UxdnUvbDZYU2srMVQzRTZ1dlZ3N3UvdFl5M3VBZnJGd0R0ajkrWkV0VCtDS2VhRk5ZRHdwclErNHg3NVR0YzV2MTZmWlhtYzkvZnF2ZU5OK2xKSE9NL0h2ZlY2eVo2a1E3WEJLNjlTRW1TMmp2YnB2alNGcE5vSDNrdE9FdG11R0ZDV1M0RzAwMlVNZlIvWHRTd3JkTnJrZXFSL28vNGprSmRraTBXOHBJOEsvU3U4Z0pvZmNLM3VBWUZWdHZrR1ZIVldOZHN0NCt1Q3A5eGdrY0szd0JDd0VoWSsxdkwvQ2x4Wm9NQm9OWEFWZEhEQm9ZeDg5cXpybTF3bUlHNGJrWmVBZ3FzM2RYSTZtY0k4SXErZEYxRWl3S0Fua3pZb2IrNzNQVnMyUkVIK21reEZKVUZvYXJEaGdhU21HU01qTTJ1clJJT1lmdGFWVDlaczdmWURsSGlZUzFOR1NoaTNkdGtUZ1ZlVWtqK2dJOEhmeGtHQmZLdmZCcWx1QzN3M1FyRk8xYzk5RDRUSkRRa2FBeE1PUm5NMGMwVXNBTndMbDZUcWZQOWx2SjRhbnVpMGZCL0orekxnREdvclNlYXpyWVJPZkxWM1ptRDNIRkhmNTA3ZmlZYnZ2bHNWSlI0VlgzVWhISnlHU2tVM2hrc2d0dlhsTmFjK20xd250QmVONlQ4QzJOZE9keUgvU0t4RzBMWUxlNmFPNForeS9qNUU4aUViaSs3dG14UHRUR3FjN3pKRUlTNHEvSXlHdWc5Y1IyOXBidDVGN3h3MlBZMGhDa2h6RTVKQVoyVnFPZGEvczlSVFJPTkRMS25IUzRhY0hVVGpiY0VKNDM5TndDZCs4NXdaWm9GTkFseWRGTVE4RUVDUFBDTU54NXVRUnY4KzFmcm1jNTJXbW5KUG5wQU1BbDFvVHJiMEd6RDFITXdQWGF3aVRubGZkMEhOR3drblBaa3JQUVpRUFJFNUtCVktTVi9kay8wZUErSzI4bXd6SGV5b1BBVmlTNXIxZ2l1WG4rd29Tc09uMGRRTEN0cDltMGU0WlJOT2dtY0pJdG80cWRSbk5xbTJsN1cyTis5dlVadGtQT2Z1cFp6UVRXaUhjQ0NpeGJBbnV1VVIxYjNsdjlTWHBvdnJ0UUQzSm9QSTM4dWJQNk9qTGRqMk9zNFZsT0pYcDFpeUU5L2Qwbi9yTzl0MzNGUFpCQjhSZC9kMnJXOHAzaWpmbG4rTkhJaXQ3ZGZLMHZNMTM0NURmUzdvNmVVcU9CRG9wblZTbmxSQXowbzN2Q1Z2ZFU0ZXBUS1p3aHptc0wxVUhNVG5rVnU0aUlSdkxzU1FFR1ZzTW1zYkdwMWNsQWxFcEhnM211czRaQnNiUFp4T3daSnI2TC8yZjZrb0kwbFE5d3hOSStOS3JiZ1pIT3ZLK1BNUDBFRHVBN0R6RkhSQjJTWURQWHhJNU96ZzZrV1RlWjUrYnZaK1c1SEhOczVaemNIa1VpZU5NdWt3cnBjMnljYURDTmtSd3FOa3U2a0FnMy9VTnlRZ1FNVTRPZ0k5MWZVdTBMNkZLc2xWWFBrZ21FdSs2ZEo1b2xjMURyZVAxTlBZQTBHN3c3Y1RiLyt3QU9WdE9EajVKdE53K1NBOENaM2VtaUp3b0xPMVlWeGVGOE4wU1F2YVRxblg3SGNtSWdGQm9tN3Urb3BsTW5UcW9maWFieEJtYkxYSzVwYi9LekQzc2FSL0Z5Smt5MjhhNmZ2NGV4TU4xZHZGK3VzY1JNb29yaGQxRHZGd3ZIOE44M04zUzBjdllTVlpLejhkb3h0V1J0SzIyS0ZFN09PT3paZXUySk5uOHBLTmpwejN5VnNUbFZIV3prdVlnSm9kTUE3RWJhZmFHOERmWGo2ZTFwK3lJTW9hSnJLUUJsdUU0aGMvOUV4clFxcTVMc1hobVA0MkI0dUlnMFUzSmNzK0p2SWg2VVZ3SHRseC92bGVEWU5HOWJ0TC9JK0xYa2NCZlg4SnFpZGxzSi9iQmllbHArUkxmZjhKNHQ4RHZscmpSVDZCMUpDZjc4RG0ySFMzTDQ2bHNxcU12Q0pOMFMrWElwU0g2cnpTWnJvTkNIazlOa3NjOVMwODFOenZoNVRNenFOZExPaCtSNXVkYTNsT3l4L0N6dkdkMFVSMXczMElheE5YR0gycXBHNThOU2NSa3BPT1dia3IzVWd0WjVYc3gzZ29ZZHZxUU5IeW81WDBpSklrRUt1NmM2TjdGNG1URys3b0lxV1pYOVVaemtlTjc4NWhzTWRzSlNaVnNxK3I0RWZkcC8xVHZtbm1tWGJyVU92K3p4Q0NCenRST0ZkYmIvTXlTSmRlRnl4ZlQ4aUczWTN0c2VTY0ppSGZoSE1SMlJNQUpjL0xhSitMUTZUQXFOK3JrN1lsbDZUYlRDVDMxU24xYjRZVlQyTDh1TmE0TGJ4c3FFdy9qSkVUamd0SlR2OU96ZTJlcGt4T0ErZE8zNG5USDNSNlpkVXdrdlRwSlRvOUxWVDBmeE9UUEkzZVRFRXBEUkFRd0hHU3BjNllYZDNYcnJFOFdMdVZESkVTaUFWZGc4RFBpcDFIVGYxOGJMWkdPSWpTZmFobTQzSkJ3TUZjODBrMTUrRmpyRjlZcGZ1bi9GYjlwZUdWRVB0UjFReWtIdFdURTA0RElzaVNwYzRBdGp6MEJoRy93Zkl1MjQ4QjBCTng4d0dCWWdnaTJCUmwra1Q2dGQyYzc2c3FMeEZFQVR1RkVRdGwrT1RoenNCSEFWVi80VkdzZ0tQQjl6MXI4TFJIUS9WZ0wrZjAzOGpFYmgvOVcyL2IrNk9UT1NhTEtrU0I1QkR4OXlkdldBRDB6VUJMZ3F5OTYyYjhYQ2FFT0QzVnRDNWRhWGdUcUFJbTJWSEhTM25qWnM1eG9OMmpyUHRWeVVJYUl5TE9GbWZXT3AzeXhiM2FlYThXdmx5T3lYL2dMSlJrMzIwblhGcmJJQTNYek1BbEk2bG0yOWRuMjRUUGgvaXpyMThHOTd0OERGbW5iUitGVTUrbEllbSsvYXJQdVdEZzE0YmZxaU9sMVlaeUVlQnQxNTRhVG9DMGk1TGlCZFpEcXc1K3RXdHVvcnMzNnJKdVRCZC9qMG8yemFieE00M2tpYmI0aVplL1IvbnZhWWhvekpLNWZOK2I3QzYyUEdaTS9xTHdKQ2FsYUVSRjJUdStnYVlCS1U5NGpzT3NBVktMNFJENU8rUDBOSDkzekFjZkJwTitYRWY1UTYxa1h4Y3ROb2dSWGpMZHFlUVA1VXkxTEQ1d0VLTDJUM2RkMTc2RHUvWENQa0J0d3Bpc0Q5Ykd1NU1iQmo1NGppU3VFbVJud09rbDE2Y2FTYVhITnVDUjVrYVN6NmttYjB2MDBJVXBIYnZVdFVzRURCRlNXYWs5cFVGUzZlcEhqajRqdlM3MC9DZEZzbXVyOHM2VXpJbDlWNjRGQ1laK3JyM01mb0RtZ2kzeHBrTkVzbjBoaTZuTmJvRE9sdlJWV203TlBkU1ZsWGJ0K3JYUjI2dUVsL2Fwck9aQU1VTWNVeDhoWjQyMVA1UGVDLzF5cXlDVWFiTisrMlgwTHpQSStaNWhscTVJTmwvQjlIdEpSNVhHMlowWkEzdU5QYmNIQjBZaW9qRUR5VE50SWZhQ3phMmtXNkMzYjRVZy9DblgxZnN6N0l3S1E3T2c5ZVVoazBjZlY5TTR0SDVmME8rRUt0WGxmZ3R6Tk5pWWhnWFJDd0hMaFdGQjJQYlZ0SjRXcDdiQ012TS82RWthRm94NSszMlZyYkIrTkFlbDMwaitSeDZyc1pGazVGZi81ODAvM09rc08rWTdrVlJ2VHRTVExMck5SZDE0bzNWTWpQbGNQYkZJblNSMlVRUHhTaTZkUDhkTFR5cGtNR2JZUDBDTWQ2YW9CbkVaWTN1MWtzUGhmblY0ZGlFU0NYcEpMWFlHWjR1emVtcHNNTGROeVF1aEdtQU0rbHlSd0lPU3pQOWJhVUo4dERocFhQWlBFNnpmcG5xNUxwQ1B6UkgxOTRDYjQ1WUVDRGpZY2xLZnlaWDNST0JQRXVBNHNuNnIxMGcrUjJSOXFtWjE0VDJIL0VBRk9ZRUxmNmhkNmxqTmpMTGV1Ynp1WjFIM045UG1NaU1xRk9yd1hNV09mU3N0bHV2YTNONTN1UHdFVTI3SENzZnhsTjN3V29HcTdiTHlmT2xqeEpTbkpPOXFCRFBhRkx2eklZYUw3ejdVUThhcGJndFU5S3ozMHpYN0laN2RBVW5vZlIxZSs5N1RGbWRrVDJpayt0NGVJSk5zNnNzTXVhZFpLZFp6QVlocVQzNkt2anZSV3YyVjZiSWZzdjV3MUorSHVTQ3R4d29pQXVIM28yaGVKT1BXYTdidmV0bE9hYVJ3U25xQXdiMVdMY3piMXA2UmZSNEw0UGR2V1VqOXpYWDE4VmxoOUhxcnE4ZVdONzdJdnh4S3UzNm5jTmRoeStSVXIzbVpEMkhIU05MZDNwTUwvR1YwVDRLdGExcityNDMxRFdPMmxjTkFqejZnYWRWb1N3Q1UyOG1xVHREQ2ZEa3pkSStpRVFyOEo5UFFTdXhtUERBMFJqVi9aYjU0Y2RyYnk0RHJ4cXJYeC9JQm5GVTdYQktpNTEyQTA4SThNaFJ0Yjk0VG9XN3FsZGNHTXl3a2V3UjdqN3NyWERTMUJLOFh6eEtPQ3RSK2xYbjcvVU10eUdNWDNwY2J2TTdoWHBJT1d1bWltUytsM3l3MnExdVdtL3h6MHZLNlZ4MFJXM09GUXRZNjdFTitNTFdCNkREY0wydFRlRlRibDU3WFMyYXV6L2E1YXY5R2JIcitxV3llS2s3OHVUVy83c2luS0t4MFFtdDM3V21ONzA4MU1lQmdDd05FYSs0ZktiY0R6VWpYT2I2cjMwVGppbS9zVlB0bm5yZmc2bWRGZjRWUm1Dc05sdmZlMnh3N01wenk2WTRmQ0dXVkpPdUtiWk90azM3UDZKbkZRM1kyeFBnNTh3SFUvU3QvakppQi9TMXZBY3VDcGszdmo0RGVGZmNVeGhpL3hZeC94dmJNa3dIUjYzQ3lKR3VqaStqQ3MxNC9mbzYxTFdER0ZkWEp5YyswZ0piOFBlYThqZXBPd0UzaURuRzBzTkRJT0xtbkExYkUwYzBFajQyUkFIWkhycnJ0Wm1XKzRML0Q0R0o1aHA5WTF2dHREZVVrRG5mVDlodkEwWnRVOE53SmcwbytEN3pjOFE2RHdxZGF6TlFLdFBudWozeDhzcmkzZ3VGWFg5S0o3bS9HbFFWMDdjb0JLOGtIRHpEQWRhT1J6Tk42WDVsclZNbkNySEZrK1h4R1dNMk52Vlg0VTZjaGxkc29QbDd1a011VE1tQTl3aXRmTGpFVFJBVEh6TVBMb3YyYmcyR05IdnRZQ3lyditNMHVJWEZKYmNzQndDZDlLeHdkajZUY0NNQ25OcW5YN0pDQ2d6WkpEd1FmNWxPZFVaMHlQL1lLenorbVpydS91QllCZVp4MEFwbzZwN2FmNDlranFEODkyTDVVQlNhSEN2cFVPblhpWnljNlB3Q2J0TXNlNkx1NDlCRVNmcXR1MnIvL3VBT3JTSWJuZ1RMbUhZN243R0R1ajg1YmQ0alZmTHB5a0c3OTRqZmFDOWZETndzbVo2RVNmT2p6YmI0VjNjdWM2ZFRJaVNsMTQxdm1vTGJsZFNFN0VWVnArZ3V0QlNyNVBtZTF3VXpLWUNhbWFtNWFlRlJFSFRyZEt1RytBSFlwTHJId3cvdlR5ZWFncllPdmVzazNEOXBlcStrL2RMajN4QVZBRVIzc3VFc2dvZXpaNUQ4NzJuK0VwWHU0a2JGV0w0Zkg5Sy9xdHpicTZyczJqL3JKSGhXTSs2YzJuL3E0VDlXWTVkT0VVRjJjUFJLUlNuVExmTkZvK3VMa2tEMDdTbVNkZlNkamVwQ2M5bWxwaXA3Sld1MUFaK2xJWkwwZk83cjBHb0hoOU1MNFIrSE9BeERoWTVxbmZwM2E3RjZoME1rUGVadU9RdklhSWVQNnBuOXF1aVB2SHV0MlVQcVBYek1DdXRIaEtvUHF2Q01kenJmZk5NVjRuRUNSc1ZibmZzbTFvNDcyV1d6SCtrMzB6ZjI1SEZXNDI3K21heDBtSFVBY0tSLzJNejNRMm1McDJjWTNxUEQzejJuN2ZwZFhGenpaRVJ4MXQ3OTROenAxK0pPZHAzT0I5NmVEaDJQYTAzRFh0dVdLZEtjNUhDek1TbGNuTVNWclNYZEtCK280dyt6V08xeElmMjJpcmxTOWRseTN3VXd0OXB1WmM2L0pJYlpxNmQzYll4NGsweHFydUVnbStXRmltT1R1R3NLNGxUd2NwK1Q3a0xoSWlzcEVxOFI5Lyt6czdnTDVuT3VvZWNaTER3Y1hYUGNwUStscG9ObTRkWTFwMUJRWGFoTzFwWG1wWnhpSHY0VmZvVVBoTnNLbk8vME5WL1F2NmpKWTlzQU4yNExNemFEUldKRTRDSGlSQ0Nzc1R1YjdWc3V4S1J1emJpLzU2anZzYlRvVzFtZEJmdWtzbjZxSDdmcUpZQXJjOHBsTUR4dGZLUytZVXY4cWNlZTJJTUFjd1h2TjYwSFVOUUUvNFRXT3FRVXI1NSt5Y2UvVklQaTU0M2dFU3ZhcXZBU1A2Vmpwc0V5NXNYNmtzK0E0Ykx1K2hCL0pTdC8wL3RlY0UvR2RCZjNwK2J4bWxaN2JzWTlLWjdkZEJWZFg2VUF1M1M1MWV0S0dlN3VnWjJvQ3FiRzgrMXRJSHBlOVhDNk42bFcxSXRrdkxZUGt1bkhNdGpnbTJjZWxJTXRBdFYwa3pNeVBRNCtKMTZHWFIyZEE5NGdCSjRnQlo2WFk2VUkrM0ppSHBlYmUxS1g0dGEvTFRCcmxVZUVTMkVnRHY5Sk0rOU1yck9UcVZQRjBmejBXOFpadDRCSGNpd2dUMjNiNG9EODk5Vks1UGw3OU9aZ2hpMWUwS0VJazdlazRXVm80eDJsM3RDMVQ2ekwvamhLNmRPQmxTZWZzMTd3T09FZWxVSEpXaEw2T2NJWDgraHJyT2txZC8vdnpUbGkwKzVCM2tUWmRqdlpDVExWYjhGa1FrRGNZYStIUmQreDJxOGlrYUJIdjA4bmNlT3hwSHJwdmNBb2N5Vk5yNC9yOTFKVG4vcmd3S3BKTm1HblRONC9mZkk4OEVCOENVbHNKcGFaQUlDQUV5UWZPM1dwK3U1VUIyNU0zd3ZKeWE1NWdQdi84Yzd1bTZHMit0ZWQ4RFZwS2hZaDVaRnRKRFphSDB1T0ZWNEkxNW9MSDN1Rkw3dTRUdlBaTEFBSWtJMCt6aWQ3MDRtRENlTkoxUFVrVVN0TFhFYUN1Zkl6MzNTQmVQdDFtdkI0bi8xcURweXlTcSt0a2hmMzV2ZmFjNjl0bS9CT3JWYjlSUG5FeXpucEpIMlhYbEVjdmFMMFpib1dkNVBIQnFCNHlUSGwyZmhXRit2Unk2R1dSL3h1dVQ2WGRDY01abGJ4NW5LcWN1SFFlOFcrbDdQa2FTK3JubjJlTWlhWEx5bWNodDBtbFBIeVpRWmQzNStKSjBKOENXcE9PRUdkYmIzbWc4MG4zcW9CY1ljMTlYQ3AvYTRVaFNlK3l1cDNaQ0FzRVZJVzZIMWU5NStJM2JKMjh6RXNjUHlWYnhXcnJ2MkdHVVI0NHpXek53Si90T3VJTms5eEVPOUYvYjNERmI4djZTR3ZsZDByeEJuWVBacUdPL1J0UXd1YXpBcHhtbGcrdEI3MXd5UGc2eW5oQUhXWG0zdklwSEFPcDRWaDNSK3YrcnRZZUcrZUhVTi9kbmRNdUowcUJGSU9TNmwzMzdraTJDQTVWcG1sWHhEZXFLTHhuN3F2V1JySkpFRVBnTTY4Mk5XZkpjbk93NWxtTTNHOUlaUE9wQzQ2ZDR1YlR0Yk05cWxvalNEVkRVVjJYZERjeGJzeUdKeEhRRVJ1blErTHFIajNseVhRaENUbmcrQWMxRVRMWkFscE9VV1VCK0QwbnI0aEVBVnZxdVR3SkVPblpXN2NVMzhyS05KQSt0MmxwNkh4SER1cTZqUFBDMy8zZEhndEwvVU5jbFZUcXg3MnRkblNmcG5VRmFBcVBuNmFCUi9oMXNPRUFmQVhETjJLaTh0bXloNG5LZ25FNkY4MmVyMW4xaTFOZjhvL0FjazZvVzBNUzJrSUFqOVpodHgxMCtQRDYvNXYzYWRmTHlrTTE3dFBDY1ZYL3RPTTl4UzdQTVB0c2lmVHlmQk04ZEdFNGt4RUZ2TjZ2QnZpbGJwNWtpTGVGT2RjSG5uQXlNMmxhWHZoTjY2WnowVkZxY3JhZmppMk1OeHpFbklza3hSd2NGeCtTRWFiYkdjOCtEUDgrOEt4MC9tQ1k5NTNGSXZENGN6L2t6eDB6Sk84bWJrUkFLQ0FuWHppZEQrRnBodzlRNmF4OWdIdkV0WUZDMVBwRW9HZXVxZGNmejAwRm9sQlBnMURNT1R2OWExMlZOLzFmWFBTVytIT214Rm1EUEZ4dlMyRXM2andIem5nWjVCM2RhanZaYzYvMHdLWDRPRGhmN3ZlWFZUNERPamRiSVVDYXk2SU9tNTVQNTlRR3Q3Tm1SdUFFa2FSRGdVaHRST3BvVmthNUpFdUJJNElQR2ZrdFBDZCtSMG9FREFqV1ZtMEFuTnpkV1NOK2ZUWUM4bTRWS0JNbTloUVNNcVV4bWlGajZQeXNFMXovVTBqZFlGejRycDJPWHRVZUtYc2JDTXlrZkN2T2gxdS9QK0ZxM0Rvc1JnUFpyRHBSRkZOVW52RzM4OFBKUlB0Vys5WEpOSG4ydU90UGIzemtMNkc5aTkvNUtPK0VEdjc5L3g4dThhdzlkT1NnODEvNHpQSCt6RDIyQkhEcTV1QnlZUks1cTJaZWc4dmFESHNwK2orcHpwaDg0QUZPNFBTUkU0VlJQT3JSRXkxQjFmN1MwZUUrLzQzak9zZFdkaWlRcDB2OWIzWTduS2Y1VUxzLzJmNnNzK0Yvak5mdm94Y0p6NXB6Z25tbDA1SS9pV0lMaCtieHNWdFh0MHJsdVBQZit3SEozQWtJNzc4Nm92ZU81eHp1eWErcFR5bS9uVEVpU3NCMkppT01FNW8zTGpYL0ZZTWNzeWR2SXU1QVFsMmFXeFBYWVc2RXlSQVMxQW9jRWZvLzQ1aURCdGMwY3JQV2NneU1aUmhsZGRRYXRuMDVHV004SmpLcGhDK1Q5WXMrZGF6SDBsN3B1ZnRkbTloT3VuOEp6UGpEVFNKQXMrTDBIKy8yNWJvL3FkQUFqajZjZlRleEdwQ01KT3FZMkRUSXVCQ3FzcDlHTUFBMG5uOXRLYXpUd3MrNmxGMEVXQnhvQ3BhMlppNVF1alMzcmJHWVdSTzFkOWNrK3dkUFdYRzhhWXZjV00rL2U3dFRtZkZEMXdjZnptdTV4RGJpTWZrZWV1bXRKN3JVdjBrbjd1VmdtN2hnZ2NkSngzNy9VN1Y2SWtkNjBNenpMWDV2WE8vTGlPak0rRHRvS0krY0lqK1NtVGZpRS9OSlJ3bncrMXdKMEdCL0RFWGhVcmUySjlDZkFFWEZYbkRyTWd3NFBsbjJTVVYycmYxU3R5YkU3WlJJNDc0VEVSUzhHZFpDdWVMN1V1ajg2NkZNNFBrZnhjbVQ0a1Y0Y003eC9NcDRPQ0hNY3E3cDFyRGl4SnNnY3RWRlBUMjNmYlNnOTN1ZTYxVWRqVVFMQW5nNTFkQnZsWlpSMDU1Z3E4ZGwyaHVlc2tiK2Z6QWsybit1SVpTSTBISjhKcnRYTzBsSC9ITTk5OXJzalI5MTR6aGVncGpHMjYrOGNDMFpwTWkzbG5lbnRHUWNZbDU4RVJvZk0yYjRUeGxtbGU1Q1MrK1EzSVNGSlJzVGtuei8vZEprZ0xwenVGbml1V3NDNkdyWUdMczB1cUJFbFk1V0FrYTRUR0JEUWtheFU1VTVLby94YzZ3NUZiNE1Nd3FkYVRrMVMzQjlyZWFtZGc3MTBIQ2JMeVJtL25pT0kvSUN3LzY2MVFYWER4cnlKaUJHY2RGNHhHajJDczI1WlZXZTB1bGtCejU4YmFFK3JHM1NUZE41UmZUL1liNTE4eFFGMXhrZ0o4RHZwMkNJaEdneElPRm52NlFDRlJFWjBYV1d2dHFHeVM0WTZrVThIQUY2K3ZFOXZzbVlRT2dCTFlkeXpKTS83NnlpOEFJUUdXWUlrOVU4bjY5MkcyQzFoLzFmN0ZqQVlPVG82a0Vld1JtQ2g4dlNsTHVkYTl4MENLNlhqYlZqUDhKQUtUeThKMnpmYmtQVHlqZTFQOW16VmVzOVZ5ciszVVpXZHlJMElnZXJZOTc1SnRzaWpudWZTVzg2NHE4K296V2pqUHNlQ1pMYzlUdzhJMnkzTlM2RGJ5VWhYSi80TUFiT2U1ZXdVN2IzSGU3WjduaGRQVSsyQjR6bkhQNVdOMm92S2cyUHFWajl6TytSbE90cGprSjdsOVJTMmFrMld2TDc1SGpCUHcvRUNoZVRKbitPemJxdUVXWmdHdnhtSDcvc2FqVjFjN2FFd0xNczBIak12dk9mdHlMRVNaVFVyTWRDUDhWTWY1cnNyWi83bS9yNnA4ZndnSlhQeVh5TWhMbjdpMWdZSlVjUFVPbUVheENTZjZ2WVVDKzk0SWhmZHdDYVFKNk9ZTm8wVDRDVFF5blI5Y0pTeFlxZithMTMzanZDMEtqMUROczlPMGVudUF3TkpXdFV5clN5eXc2bHRHbjdsUjNGWHJZM09GZ2xSSGhYT2piOGJLUzlURGt6K25JTWFyMlBtMzh2cW5yN2dBd0IxMElaRko0ZGJob2tBMkQyZVBqUEZkdlpjMTdyVGdNY1RqNnI2alpOTVYzV3NneFJFTUhrQ0dNRWFCOVd0dk5IZ3N6NU80Zi9XbEw3RUI3V09sQ1FnTmlvSENRRjcxVUxVcFllLzNKTXpSZ1JISFJIemRBbkFCVjZUdlJpMVpkMmpIV0ViY0pEdGJZejE2b0RQU2FqaTlsT3VPZ2ROMlhPMFl3Uk90R2tpWWo1ajQvbDIrOER5WUI0MWs2dTZPZFhhWnBHNHAvYkUrRklaUDlpMzJyS0FOWWxhQjc2OG5IejJtUTZjVlBkZFBGVnpkdWhVMXpIelZPczlMSnlsR0JHQUdSS1NRS0U3Q2xtM2ZPN1R5Ky9VSGhYbmpMMFFTU0FKY1hzeUt0TnUvTkJ6SkFKVnk1SGNzcW5zdjkwNFBUdWUrMzJSWWVFR2tUcnE1dVNCNVViaTE3VlAycXlxMi8xL1ZXdDc0N2JIWmF1K21PN1dlTTZ3VmJmdExVa2lkTEpCZnJUeDN2RzhxbzRYS0NiNWJraElrZ0VSY2FDV21LekN5YUNxOGJnM1FCM2poN291UFhEang3am93YTlhR21qeXpLc3pqd1poRGtJeXducGZ5YjlyV1VMMmZ5Ritla1FTY1BOeTBDRGlaS2hxTVNUdXhhWEJVamozU2xHNmFWOTJiaGxsNnV3REtZbFBBaDFiQURJQkVRZkxlMG5JS0UwQ1U3WW50YmMwQ3pFU3p6ZDFwcTRraHM5MXJUKzFkYjNyaGYxanE5eE90ZXdOb3FlcDYxOHVNd2FaQTY1LzJEWlRmeHJWUGROUEE0K3VhYm1NNzFWeG9rSXc3MjFUNWZ4THJaZlZwSUdSZXJoNG16czExM1dnZ3dnbWRVbjdSUmpISitUSjI2RVRCZTgvQWxFU0FtQ0p3ckMrdHVxSmFWQmZwY2tUN1RpVDZIM2EwMkhZYnBhT1JFODJTTUxET3hLNXFWcW56NDNuUGh0TlQ2dG1QN2gvVExJMWE2UTBrbmRjWmVMN0x0a082Um5uczF0dFV1L1pVRGdSV0Q4QTVoNFNrdXlZK3BXZWMyY2g0eVZCa2g0RTMxWExNZTRzSzVkdWRzanRoK3VkN3ZsekpBTGNtNmRWRzc1ZnltM2hsak5QZGVxNlZDMXRuRE05SE0vNTBmTnV3NnJ5NXUvUmVNNTY4L0RFVzdvMk00UFZpZXMrZ3d0Y090TENjcFcrT29JODdmMloxZlhYZnZIUG4zKzZOOTkvT1BtdVNZaUxrWklWd3h3OHBrMmVEanpvclpZSCtWVHJEZXRWUzJOVEIrSTdIOWk1SE9qUm1IVGlEWjRrNEs5MUJUbm5XaTgxYzY4ZUFYQzMxSWpwZWRyUGRRWE1pcTlxOGZCeUdsN1BYR294VEZ5VGU2bGxVRWpwU2M1MVczY0VHWHcybGFFYk9CbzVONllKdUhzY1NjOEVSRHBoL2F0TUJCcXJidHVURDJaZGZGVzNNeC9KcXk3QXBzM1F6NVhiNzJ5YVdnNG93TW9YVXFZeVMrVmJ1TmZsMXdkRGViejkrU1RwdWdNV3YwNXZwQWJsNUxGTGhGTHRuVE1EZk5FZ1FSRGI2Nmo5T0FEamRaYXQrdVNuV3BOTTlVTzFyK1FSSm5qbGtoRE9zSGhlZGMzclJ2MDdTUUkwSStsQUgvWHU0cHNkK0gxR05PVlQvOVZmTmJ2TlU0TFlydGdmYWE5T3RYam5PVU5PSjVuUDVMRHRKZUNtYjg2UU15Nk9QeHpUK0R6dElkUGFBbEJxNDZ4LzVaZjd4ZEtzaFFQWnJqMjRYalBQQ0F6UzBjSys2ZnMvcTVZeHlXZVBXQS9lQnp0eTR2b24zWmwvdGpVNVA2cldoSUJ4c2I5VzNSSjdDc2M0L3k4Q3FYN2tSOGFmTGJ6cTA1ZFcrVDRienlkeEVYVk1CSkwyeE1mVzBSamk2VEdkd3YrUlRmRnlUbkV3SEoyMUdnL1ZuajdYK3JDZ0xVbjV2aG5QblBISnNBQUFJQUJKUkVGVS84d3pKTDhyRXBKa1l1K0lRRWZWMm1zcDRxR3AwWE10M21zWkNiNC9oR3VrdmRQUmE4ek9LVWxlU29YaHQ3d1hYQXFseHVyVC90d2NUK0RrZ3dMRjlaYlIxb3NhZGJxTjBwZXhva2VVZzQvcklxTEhmUEtiZXFTcFZ3L0xHU2Jwa1RhRGV6ekpZQ1VqUlVOSnc2encvdUZ6WmMvcXZ3Q3E5SlRCb201Slp6MmZBSVEvUjBPbXR2TUJjYWk5ekI1TDdPQ0YrdnY2NENRZWwrSWJuUXpHWjdnblJQMXRMNUQxT1AyNnd2UFVHQWNlaklQbDZNc21sRWNmb0pQM2ZkVCtYRGUySjU4cEZRRGs0TVZ2cjZORThrNFdscnFtOWxXMWZnbGhOOXRLOEpUMmQxRzI2cFhsNHVCL2ovalNVZjBtQVRnaG5FQys2aldsVHlMRE9pWUE5bE92dUZTbEEvUmNidVkyaVRQVUR2NjlYQlNXTXlUTWN3ZitrdER1YzNsY1ZVNWI0clo5cSs0Nm05VGQrNkdXL0JCYzgxUkpoVmRmZjhLSDQ0bVRRYVdaeHFlUi9tbDhrdzdKcHJuOXJscTN5VzRNb25pNHF2VXNrT3BPT0lhT0Jkb1huM1ZpbWFpdGRRVGViWmlQdmE2bjl5ZmFVQzhQNXQrbHF4dldSWXB2cjBOTzlvR0hrcVJacktRSDQvTXk0VDJHLzdWOC9reWs1SGRQUXBLRUdSTUg2V3BjN0l5bnF2cWZsM0R5TGhhK0JkREw0cUh3K0U0SC9CMElaamdOaExxWHZEVHMxQkoyR3ZkT2VWa2tBNmdsT0JyQXZpQ01Ca0NST1c0WUpEaHhNTlRwS24xOU1LUUJjeThPeFdlQ25tdTlscGpoZkFNODlhSXUrazRlblJFZ0psRmpuWCtDbm1rSkN3MVRHZ2o5bmdORXowUFZtbFN6M2ZqTEdqbllFVVNsL1Q1YVQ4ekJPK2xKZlJoUG1ybHhVYmt6bjU1VzZtdDdTQWp2K2RwZUQwUHZkZFY2LzFKcVE5NmZ1bG03cEs5Ny9QMzZBNzQxRzlyRjc4SytwNzVMKzlBTnlHNlhQdUszejdpTStrV3FpOW1CbGVScEN6U01ubWU2SGJCVWUyVmJ2dFExMytwTEJJb3BQTzBNMjRuc0hIWDVXT3MySloxU2UxUy9KSkE2MWRxVHJ2TGhYaUxwekxTN1dVYUdTVzFCc3pDTWcrTlQxUUoyMlFjNjIrbHBkWGJaN1FiTE92VkpFVUdXbFdhbnVHeUxlN2kyMnBaamhnUW1VMXQzME8xNUdvM25EdHA5T1pTSFl6a3A3enhoVGlTa2NPMEJZZGpHVlhkOHI0OFRGS2JQc21kYmRGM1pqci9hUGJlMStrN09rck5kVDJNTGJURkpvRDU4dnJPOXJydG1TbFUyM1ZKZTZscDIvMkxmREpmYWtOcnlsei82MHEwL0pBbHhhV1pMNkwzU0lQTFhsLzlhY3FWVEpYaGNKZ0V6WnovMG00TWRCM1FINTFXM2cxVUM1eTdjc016NGVYcURBKy9VQ1RSb1ZhMm4rdDBUcUtsZExka2lLRlU2YVM4SUpSa0pBazU5MHdENDJtUGxKeGtNTGJmekUyNThzRXhHaTJGOWtDRndUMFNQY1RGUDJ0UXRRL2c1UEtOMlY1VkpDdHVsendqUmFMRU9HWjhQSERUQUR2QjRqS1F2OFZOOE03TVRIQWhIWlBSaTF6MWVIL3c3UU9KcE0vNVJuMmZiVGVsNy9iQ05kbTNJNjlKblVGTGRxWDFRSnpvRFB0VDE1YWJhVjhUbGpsMGVwWnMrMnRRc0crVWU0UkdKcVpmbi8rZmxHZmNDM2pNNHpoQ0tybDNzRVFLUUxtM2EzNnExeDE5TEVoT2hVTG15SGNsZWRUT0haenpqeTE1OHR0VHo0RFBPMUYvUGNmYlNuUkQweG5zL1RvNHV0dkhIV291SFo5L21HRVRkS0FTc2pKTnhkV0NXL2NidlUxZTFkYzdpcVc1NFZINVpQTjN2dlRJaUlSNG5uVFo4amdjOHpOaGV0aE9XajllVlNLV0FOZmQ5a0JDblRlYUtZelNlS3k5cFBLZFRpNlJBdUVQeCtIanU2WTZ3eHRtK0thbk5wUEdjR0tscXZiL21YT3QzcWZrenA4cGxwdkVrdFh1RjhXOFN3MS9yNkk4MlMvS25JQ0ZKWG9pSjlvUklOTzJtQnFZVFNRajBDZVI0OG9tV1VaR1VWSzFuUmpxdnRzSlJPZ1BPWjJtMGZjcmNnVnlLeTcwWm5xWUdTMjJZcjFyVzRiTHorbHZxVTVvK1dFbEhHaFkrcHhrWW5pcVQ0bGU5K0g2WVpCUTZBT25lQ1JwdnY2OThNeTAzeXB4bGswSGxrYTZlZGpJcWJDOEpoTHV4SkFsV085SGc2MlJNY1ZGdnRYZlZBL2NuZGQ3dlJBcTgzam5icUhTOEhrY0R2ZytrVytKQW4wSkE1WHI0TXh3QU9tRENOc0hUeEVqc3RnWk1wcU9QK3JJY0FLb2JIL3lvaCtkWDNrN05oQ2tkdmpSUGt2S2w4aEFCb1c2Zmd3NEVFYU04YjVHZUJBYnVGWmFMTzVFU3dHVmY1NHhaMWJvZFB0WmFQNFVodVZDNzRheUU5d1dmdGU1bURxU2JsNnRzbjhMNDNnZTFTNlZQRDdlM2RXL25FanJxbkZSVFArYnYyY0o2WHBRR1oyK3FidlBZbFFYeng5L3NjMVhyNVZocXV3eFBja1k5dkx4VDM5aVNCTXc5VDJrbTFNY2JIODg3OGJqUzJLTDYwU21ZSW1oZmF6MUdrSVNNOHNhMk9ack5WdDFvUE9TN3lGTDdvRk9zNnJhOTZmY1dScEtNTUpEaVNYRXhmdy80dnRTQ1NVYk9aVThydGRra2pqTnBMeGpYSDRLUS9HbEppTXNMS2VIcEhPcFk5RWhVNVRKN1FEamZ5T3RlaVFTNjNHTjNxbXkwdXVkMXp3Y0tTVWNLL0RjQk96dGYxVUpDWkVRa3o1VUJkaWVLbCtDQUFJemVZWDlqTlBPanVCeG9zSzQ2QUU1eE10WU5uQTVVUjRDMGFnR1E5SExUNDhuME84OEpmM1BtS2hsTlA0dWV4TmU5ZnFQMndMTDBzdXRtQXBKd2NQSWxXZ25NZE9TbUE2ZGJhVzhOUEpMT0ErMTZiQW4zbXB6cTJsL1Vkamt6UmIxOC9mN0p3cDNyT2pzcklxRVg5eVV5eVJtc3Axb081Q0F4RUFueGZWdXNEN1l4Z3R6L2Zmbi9yMXBJQ091RVN6dzBZOU9SN0ZTZUR0amNQckVmenM3QWVEMTYyMkhiUzBTT3A1R3hYekUrUHNObHBHbG0xcGR5S2R3M2U0NE9MTFpCbnpHb1dwYlNzajk5UXpqcHBIdE9Qbm1DVXRWdFcrQlNxN0l3ekRmMUVpSHlQazdTWGRYWHhjaWhwVEpKWG1qbFJYMlE3WVhqR2RQb2JJUWY4dEdOejhrZWVidWpKRHRUMEpFNmNZTjBOK1pYM2ViRDJ6dEpGOGRYNGh1T0YzeFo4WXl0WmJ5Y0lXUzVmNmpGUm42cFpYV0FDOXNIYlJQVHFycGRwbmF5TUluRXVCMXhlOWZsajNoRWRTTHk1bm5vWnVtOGJsbG1MQytGOTcxa1BrNjZVK1YzdTduOUlDR052SkFTR1hDdHRhOWF2N2lOeGsvZ1BHMWFjcSsyTjhnRWRqcXcyNG1EcSs0NUI2WXUzbGs1d0h6RWIwNXgwMUF6bngzWWNCTHlyVzROQ3RjaWN6Q2dqaEo2VHBnM2R1VGtTVlFZR3FUazJVaURqaHNGSHlqMXJYd0liUGplbGEwbFdUNjRrTFJRVjA3MU9sanhHWlV0SW5HeWo0VGwxd0Y5WHFjSFNjK1BpQWpqY0xtSGhIaGNIcS9hTCtOWE9PbzhJL1FHVnEzZjE1SUdKUTVBWGIrWERqKysvUGNad2FwMVcyTWJWOWx6bWRDcDFrNFM5aFhwbldZcFQzVzFlenJHWEcyWmVTVUFwRjMwQWRabGk1QW9IK3dudmlaYjhhVDZUVUtna21ZQUVvaDBaNEhxaDMyRTRMWHExaUZReUFmdHJBaUw5MUVmQTZpUENNVEYvdnRtZE5rZ0hnL3Nka05DSGRqK3ZDeTgzS1FIQ1UrYURTSEFMRnpqRE1USTg1L0FOZHMvQWFXM1I1WER4YTV6Tm9aNnFzeFNXK3RzRVBYek1BNSt0OFoxZDQ0cFg1NWVzcFdPTXhpVzQ3bHNBOXNLeDFwNjQwZDJrRFplYmRCQnRVNk4xSGlmWmhJVWxnNFZ6Z2JJcWNJbGYyenZaZm1SK0l4Q0doODZ3c1Z4VU8xQ3VxWERPcnB4dzJkQ2RDM3RKNk50VVQxUW4yVDdidVQzUWtvT0VqSXBMNlJFZ3pHOUJ4eE0wbnJ0UkRBb3lTdVV3Rjk2M2owRTlQS2t6czAwM1VqNW9NZjFrQnFjdEw3OHVhN0E2SmVYc053bzJZRkw2c3JsYXdUSzNwbmxQWkhId1U5Ym91RkplWkQrTXJCT0VEdFBvK1JVdC9IUmFLWHJqUHRTNnlWQXZsNmNZTmZYZTN0Y0JKWTZzMStEcDhKNHZtZ3N1N29ZQ2NGRlZmYVlVMUpiRjJsUFpHYmthV04rMG14Rkp3NldFb25qb0p2ZVB1MTU2NjZuUVo0Z0w1RlZodTM2ZklwVE92c3N4c1dlbFdpV1JYM3RYTXVCRS9SUzBnNXc1dU5VNi9lSzZOcW5XdTl4a2swOERhNzVIcFF0VzBhUzREYXU2cGFJallUdFNMb1JTQWpJVlBYQWQ2czlFSUR4bEN5MU1hOG5yLzh1ZlNmdmJFdnV5T0dTTU9tbTlEVURkckV3VHFyMFRRKzI0bUk3SVVGMXNzS1prK1RoOVQ1eXN0OWI0TnpydzhzMTJSclZ1ZllsQ0FCTDM2cDFPMVZjcVozTmp1ZCt6WFhlYXNQcWk4cUQyMHEzOTVSVWhteWpuR25UN0FTUC92Wmw1YW45U1ZpMmRFQ3dEeWpkajNWMVpPamxpYjZNdXhCV2FiTmVOWjQ2a1pST1BzdkdEOXVlbDVFN0tEazJlMThuUVdJOStuaWVpQVB0ck5JbENhRnRkZ2NBeThIYmp0Zkh4WDkvejRUa0lDR3ZFR3g0ZHdQRGEyek1IY2oxQnN1cE9qM25qTjlCREkzV2FGQ2w5NDd4T3dIUTUxTHJLZisvMUhvVzVBdWVrMzd1aldNbmZjQTN5eVJOcnlwYzFWcFA3M1RTT1hucENXWjRuWVo0TlBDNVo4VUhTdGVYMXp5ZWpyaDRYU2FRejdhaXV1RTdhNVFQZVd0b3NCeG9qMGlJdDl1a0c4TjUyZm1zaTN1TEdjN2pZM3RKc21WSXZUOXlZT0pncUhJVDBQWTZIZFVqMDVnQlRhT3kxbjMyUjZiRE1xemFQaHFTejZwZCtLRWFYUjlTT1gycWE1LytVRmNudzNNdGpoZVZsWUNjeWxWOVdVUmFZSzlxUGRQRXZTVWpEeXQxN21aUnZGMm0rMHJYeXpaNWY5UFNFTVhqY2FVdzZuZWNkZkQycC84RVdRUkFQaE5CMjVmS3dmdm5wWmE2SWdrZytKSHRwc2Zhd1pyblMzSHoyNWVhc3IwOTFqTGpSa0JiMWZjRHR4dXpJbHNuNFZJMDJteTlCRmhFWHVTYzd6M1JFcHVSMTkvYmcvZWoxRlk0STNtcDlXbGRmRGFONXgwUlNIWTZ6VUtkTEl6YWlIVDhoRENYV3A5K3lmSGNWeE5JajBkOENubjZodWVvSjQrYjd2YWVlTHRPNHduYll4cWZ2V3o1bTh2V2FSdTlQcG1XdDhzTzB6R2RSQTdZUmxTZUtwdTBKSmVZaVhXYkhBaGJlUDVVVlpmdjdiU3RnNFM4Z3hnNThZYWNRR3ZYQ1RtNE8wbHdZT2dldDlTcG1LNTNaTzk4UE83d2JCOTVTTmxwT05Eb1JERVpYQm9Rbm1EQ3dUbXR2U1VSY2lQc2VkTDMxaURtbmdvQ1ZJL1RkYUYwQk0rTllicm5Sb2FTN2hHZ001eDdlUVZBSkR3dHJXdURaYi9aUG1pc21UNEJFa0htTEVsd0lzQjBmU004ZFJ6VlBYVjZzR3ZLZzhCUjFmcWxoYXliclZrWERpQU1OeUpPWFYyN2VCdWo1MSs2emRwczFxR3ZnL2RCVE9HMGlWa2ZBWkl2dVBhWFdzcnNvYTdMczFUZTZ1c0NHdXJ2ZkdIczA4c3p2N3c4azlvTmJZL1AvcVE4VWthZ2dJUmd6K3lhZXlYNVRUMUkvbFhXQkJBRUlmcXZ1RldtMGljNVNaSTMzT1BXekNOblI4cWU1WkxpQ25FN21PYU1pRVQxS2h2djVmQU5IK3JIK3U0Y1BGVzVYbWdIU2F3STRKUlh4Y0grNnVQeVExMDk4eUlpdjFUZXErRGxrb0FyNDNjYnE3VG9UUEJ4MGRNNzFhMTlUNlNIZWZNd2pJZnA4eHFYOExFZVdKNnkxVlhyRGVXYTNUZ2p2bnA1VnVYb3k5WnAwOXdPTVYvSjdpZmI1K041UnhyOFdlL0hiUDhzTjhkWi92dzlnTjRkWTI0YkZDLzN4VmJkcnFUdzcyNXNTSFpTYVZ6KzI3TWtCd241RFFSTHVXaThrb0doY0dxUm5UVTFLRGJBclU2anVFa2NPQkFvM1VmOGx3NDYxdStYV2dZYXhTMVBpZUx5Z1pNREJqdWFnOXNPSk04Q1hJWjFnT3V5eDRENHdEd2FKRWRoS2x6dnlCUGpTdmxUUFhKdE9KYy9pU3gyeENqcHJuUkdKNVJ3ME5YdmRHb1RKUUVDOWdFT1RqUExiVmkzekIrbjY3a1JVdUQ0RzU3NThlV2UzZ2toWURhYWpXRTVjYkRxQnRSN0piMlkwQ1VOUEE1b0h1eC84dm9Ub0ZldDM0bWtNam5WUXR6T3RTekxsQmVjK3hwT0NDTXZzTnBsMVpXRS9GK3R5VlhLd3doTUVFaXBIRG9DNjNXbE5FZDlsT2s1OFN5a3k3N2dnQ2lCU2NYcHl5Z0pCRHZTa3VKTmV1ZzlSWDRRaHNkSFhkTDR3ekhoWk5lMDNLNXFmVFN3TCtIVVVsb2ZjNVEyeDBUWHhjTjVPVkM2L3FIbjNmWnBqUHRVeXlFUy82cWx6RHFQZTFrY0NVQW1mUWpTMVcrNmRzcG5abXlLcnlyd3NsWWZwTzBTeUgyb0sySHdaVnJxeXo3N1FmdklwWjdLRisweDgrbVlaeXRmQ2Mvb3VvOVZLYzZPc0xHdVpqQVRiVkVpNnFsL2RaSUlFOU5VdlRGTlg4N3RaSEZrdjlqdU82ZlpLdS8vRFVKeWtKRC9naGdwNFd5QU4zRDlkc1Bia1pET0NMSWgwaHZEd1pscHkzdjNROTBPZkpkYUR6cFZhMitmQXpnWkxvazZtanF3ZDZRT2RNeUMwbVI0SE1CejhIQmhPWFFrYmlRRUZTTkQyc1h0QUdUMFBKOVR1aG9VNkdtaXdkd2lQUHIyWlhBdUdvVFVwcHlFc0wzNFFNNzJ6elFWNXNtdWUxbDQzL0I0cVFlWE5IQTVSdFcxZldzdDlCZkVOU0pVWGxmMEpzNFNrUkhCb1JQZ1ZHc2ltUVlPaWdNbi90ZDNSL0FJTkxVa3EycTlmRWZBUlY1NzdkblNraitGRmJnaktlR3lHWUU5WDRKSlBXZ1R2Y3lWaG5zVW4ycE5ocmpVUm5WMXFWdDd1eVdwdlRwSjkzWlF1RTlpVE5JbW9RT0grK1FLejNXZVdwWHpVOTNPSUxudDViTVMzOHl1L0hWZ2pIMVRaYXJ5MVQyMUNaYTlpQkgzRDU3eG5OTG12Z3lsNDB1L2xEL2xoOTllVjJrbVYrSFBkU1hXT25CRko4Y1JqRE9Pc3V0cGZQRjltUjNvZFVDYmhNK2s4T3FYcCtyMy9WVXQ3WUl2M1dOOSsrRVpQQVdLUzZvSzExUkhMQXVtK1d6ZkVnZmlsSlEveHpGZTVxUHhmS3VQRTZSN25QcXZOcG9PS0VqNmUxMDZRV1A4STZFOUpoSHNDTWhvVE9HM2RPbkMvdG9QZnl0Q2NwQ1E3MFJBVEtweXZmZ0FsS1NiWFhHRDdwM0tCeHlGMDJBaXc2VzE0UDVNSWlFK0VEUCtaQ3kyeElGcXV0OFJHSkl3RG5vSkpHK2xQUkkzR0I3bnlBZzVvZGp5eHFmNDZLR1crQUNpNzg1ZytzQlg0UmtIaFRLV3FuZVdiVGNZK2JPc0N6ZXVyRHZwbVRhV0prUFBQSEZRazdlVElPcGNpeWQwcSt4VkZpUTVXKzJvTnU2ZjZ2WkZseVQ4MGpucHA3em9JQWNmU0xkSWt2S2xvN2paNzcwdTJRWjRVQUxUVXh6UzZ4UEM4bjBXdmdZL3RSM1dPKzFUMWJxZmVYc1ZjRlViOGxOM1pvaUl0M2ZwUUxMUC8xeXVRckR0YmRQN24vVHdQT3QzMHBkT2dPZGFYbGdvc3VoN1UwN2h2NmZQTlBXdCtwU3o0VnV0bjZXWG5hQ1FiWll6Wnl3TDZzUC9MQXZ1SS9SMlRKdjBXTXZ5S3VYMXFaYit3UGVrVUhlMkM1SCtMUSs0ejI3cEdlYUQ1TTdMZW1SakZCZkpDMjBqNDVQKy9vNFkxNWVISmtnL3JtWmcrRVJDdHBidTNVc0FHTlp0bHRzcUozTU1wM2JHK0dZY1FvbUk2TGNjQzdRWFhaenN6MDQ4MVI5R0RnRXZEMTNqL3AxazQwYmxuTnJkTExGWVlhUDNKQ1FIQ2ZtT3hmYVdiQUZYR3NZRTRoendjY0JrV0JvM2JVaC9xUFd5bGFyczVkR2dQTm9ZbjJTUFo2RHF0ak5YalVrSWY2Y3lkY0tRK2tVaUU3cE9RQ1laRFRJelpFZnhkdldlU0ZUVjJ1TjhzVEJwbHNvSFZBSyt3bk9kUjB0ci9RVVFFa0E5MVcwN2MwRHJRRTJBaDFQVVBsQkkvOUhBb0xndXRYaGpCVWgrclBVN0JlVFJud0dtMUQwTmxxa3RiclVIRGpwTWgwUkE2YkV1Qlg0SWhoVXY2MjhFdk5rT2RJS04wdVBzQXA5bE90NnZTQjUvcUt2dDBHWjNoZnRTQytuelB1ZDZPZ0R4c1BvbW9OUTFPbE5PdFNaWTNrZVlIbit6cjZRK295VTlBdjRPbEdrcnU3UzhYalRqYzZuK2ZSVktXM2Fhc3crSzB3Rjc4cVk2cU9SdmxTbjdDTUVWNC9OWkhyZFZMQTg5eS9aTHNPZmppMGhsbXFuOFZOZisvTkdlRTJsNXF1VTlPNzRVaXZhSGRkVkpBbzRNNzBTWE1nTUV2ZHdUYWZNd3NyVmRPOUhzcFA1L3JUVko5NzBiK3ZCOUdJeTNHeXY5ZmlmY3E4WWxYbHVZSjgxQ3NTMnk3ZEFHYmVuSDU3MXNxOWJrZHpiUGlpT1ZtOWVQejJMcld3VGN5Nk1ibDZ2VzdaTFg5SnlUbDlSMm1RN2plUE1sV3djSitSMUpPSTFyTkVnbm8wb0RJOFBzVS9FU1gwY3FvMVYxTzhncXZiMWVSc3BXV0hiU1dYSlRkZHZCcXBZQjJ3ZEYvV1k1ZGthakxIelZZclFFaHJvakNEMitUdDh1RElFUTkrWFE0S3F1SlFrWXNhMmM3WGtSQzlXOUQ4NGtJVExNZW9ZR2xHUkM0TVFITkcrN0RtUTliOG9QMjNnM2FEbUlPZGZ5c2szdkM0cDNwdDBTaUtaQjM4RjZCMnc4bi9UaWt0ajVER1lhOExTUmthU0ZnL3lNOTVVem9FcmJEOGJ3ZHVBZ3dQUDBvYTRiMmxrdU90NDd4YjBGZERvUUlIMW9pNnJXTC9Ma01zTjBNby9iUzg4em5TRWlqTFFuYXUrMGdleDNYVjZVSHNQeEhVTUVhcTZmYkRWZkZpbGRudTJUU0pDWE0yYytVci9rZmdIcHBiYkRjazd0elcyNDkwL1dQZmZOVUk4bjNGYyt0YmZEajBoV2Y5RHgxR3AzcVkyNVBab1JQVWRRN2ZiTHh4bTNhOTE0cmo3UEdWdk9KS2x2YVRtWlNMMHZaNjFhK2pYMzZ2ak1JTXRUY1hNbXhJa0NkYTNLZWU5RWJUdVJ5cTJ5Vi92a0xEZ1BPV0hiWWIrVk9ENUpJRi9scno3T1dWd3ZCM2RpTWc2T3h4MHU0b3htV2k1TDdPWjU2QnlFUHVhd3pTUzd4NzdmMlFlR3Ezb2pRbktRa04rNUdERnhvNU1hdEh2Sy9maFdkaHpmSE91ekVkME1RZ0s2V3pKTFFtWkJJaVV4ZlM3bjZNQ3JHMVdQcTJwZExpcHpnbThOMERPYnJUM3QwWDJDbHBQZFMwc0ZxcFo2Y1FQa3hNRm5NTG9CaFNUMUc1NlgwQmg2TzBzYk0vbGIrWEN2RmdlTVdiTEF1dVJlQlQzUDkySE1pSU0xYjBPZVp1b0RHalI5elhVSzczWHFNNEhzbDl5cm9QcExUb05PbEphQUR3RkkxYnBQYzNEMHN0TUFlYXJsQkIyRi8xcnJQR3BHMWozclczb3FIWXJQVkJCNFN3L04zc25EMjlreFBzODYvV0JoT0xoTG1JK3VEM2xkZTV0eEVNTmxkdFNUamcrbDUwY2tNNC9KRGpDZFMvaGZ0VjU2eUhEcTN3NUdDODl1a1YrMk84M1Mrek0vMU9KRUlDaVdidjV1R2dGcEVpUE8vaWZ5NjJNRloyQzliWHIvVnZvRTkwNGVQVjFQWDhKNE9MYXd2WXE0S1YyUnJRVEFUeGFPeEZGbDVyUEFIR002ZXkzeFZSaGJSTVJmK3BmNlJpZG4rMzFCZkdtV3pFbUc2akhaWjdYcGMxM3RCWmVVaW9SMFFMN0RFZXdMS1F4bk81THVvL0U4bGJPWEQ1Y3hKZ0krMHBYbGxyQlBWYjF1dWRaQlF2NWdFbzRIVGdDTzYwZ2RuUGdBcElITnZjNWs0b1h3aVVHN2dYS0E3K0dUYkFIemtTVEF3QTYvRlc5blhIU1BjVmF0dmRFU1gzdjdHZzhDQVhyU0pSbHAzVTkxOW9qN1ZYbWEzSVZITFROT1RqOFRBQ2crQWswMy9wNi9OR2pmUzBCVkpnS2luTjJoampQeEpTOFQyemJyNDJ6L0dRY0JRUUloS1U0WFh4Yms5MGhBWnZOSGdKQkFMUFh4L3VRSEkyaEFaMXZnZXhyY0UwcmJNaVBKTGhDOHNmNjV0NERMVEo2YmVBclhmTFpRSUorZ25HK2o5OEUrZ1R2RnF6QUVTeXhmRVF6M1JoTzRzeTJPWm5lWXAwUTJsQjlmbHVHNlZxMlhxNlQ5RnV6RDFNVUJvZkpBb2VOTCtxbHRzaHhjUjdhamM2M2JzL0xQVThPMitwMzNYMitiYVpidEFiOXBSeWx1MjZpSDhpcGl4YmU3ZTN3Q3k1OXEvU1p5MmphZnZXTTdrOVBzMmVJK0k0eTM1UWU3NTIzVng3Z0V2dWtrcUxxdGc1RjRtK0FzZ3FlWGdIVWFnNTJvc013K1d2ZzBlek1hbzd6ZitYWFZkWWVsemhiVzgrTGpLWThLVi8wckRNdW8wOFhMTDVHUTFqN3ZKU1FIQ2ZrVFNGakc1WWJWTzZZYlg0YVZjZVdHMmE3UmVjUDI5cGFZdjlLNVY3WTZ2Q1FOc2lNOUhPaVgvZGMzWjQ4OFRRSUVINHozaUJ2TWREOTVNcFd1R3huM25wOHFENXlNajhRbDViWHE5dVNkNUVWa25MeTJOUzA4S3h5a3BOUG5XdWQxeHZQdThWSHY3bmxmRnVUM2ZKRDNhZjZSRHFrOVZ5MTE0VE1uQ1FoMHd2Snk0T1g2ZGJwdzlvL2xSV0g3OEZPRlptZER2QzBUbExOZC9vandQN3g4LzFJTGNYQUFRQ0VvazN6RWIrWDFDLzZYNVlkeDA3R2p2aWJkQ1J5U2JYVm5VSEpHTU8yVDNUK0gzL0lnOC8waGJnUFlYNWdPblE0RU9RelRlWExkNXVnYXY1VUc4NXlJVEdyYkJLbWNuU2JRM2hLM1VhN2J5Y0t3Zm1rZldLOHV2dG1lK242d3NOU2ZhZnBtZkNjNUpJd1MyWEhPRU0zTTJIZjlPYlZaQjhzdU0yTllWVStJV2VidXpQRzJ1c2U1SWVFSmdON2VPZ2NTeGR0c0VvNEZmRTZTeURERit5aG5MUFY4NTFDa2JtNVBwK1dmUC85MEFjN2NSVVFPRXZJbkZEUVdaOThTQnc3Y3dFWndVYzN6a2xINzRrRHREZlplRXNKQjBqdGMwaVVCME5UUlovb0p3OU1MU3k5RThvWk5lUmNtOUhCdlJRS0hMcHlTSnhDVDBVb2VrQlIzWjdnSWNwSTNQcEhjSks5dEQxdzduTWpRWHFHWHM4c1B5OUtCbHV1b3VHYmJMUHN2KzZUU2RjRHNIc0t0TnVkdE4zblBuSWhJT1BNaGJ5R1hDUWtzYVdrSmo1WFZkWjR3dFZjNENKUDhmc1IxdlNWYUczbTVOMDV0bFFNLzl5WW9EZTNCMEdFZC96YWRPYURUZGo3VVFtQ1U1b2U2QlRPYXJlRjdiZlI4Vlc3RDdNY09tSjNnRStScGlhTENDWFNsazc2a0I5OGo5V3dmNWRYYnJ3TXlBcTlFQWprT2lhaDYzanFRUjlEdkc0enBHT21BZEhLQ0pMQkluWlVXWjlhOG5oeFlwMlZXMnVPajlxcVhpRDdYTXRQQlBOQnA0Q1NDeEVaNitoSTFuMWxLZHFJakJXeFRuZU1vdGNlTzFERXRMbFB5QXdYTzlzMittMGlpa3hQZWMxMWR6ek0rNm1QcW0zelcyOVFXb0IrTjBZbE1NZDVrZjUxd3VoTmhGcXZ0c3JzaUhDUWh2TDRsQndrNXBLcHVHcEE2TFkycU9yaldTZEpiTnZKbUpLTXRZOVV4NzN2Qmh5OUw4STZjQnI5a0FKTWVORnh1WlAzYXljSkxSaVJrVklhejBwRUdqODlCbzY5aEhxM1I1U0N3VmUvY0k1T21ncjNOZVZuZFN6NFlOd0gxVzgxRU1mN3V1cmM3TDY4RWdpN1Z0MW5HN3lTQnozWURWaHFFQ0pZOEQ2ZkJjNk8yVHRBa084RUREcndmY3VuS3VkYWtZSGFHS29FTDl4enFaS0J6WFdkRkJMSUwzenhZZ2VDTlFLdHFXWWN2dlQvWE1ydEdNa2o3cGp6cjdmSHl5dXVheXVheHJrQlRPbmtjeVhuajljM3ZKR28zK2hZcEVobDZNQjJZZC9aTDdqRklJUEZzejBrSW5xdld0b0g1OFRic2RlcDdIMGpRZk1sU043UG54TUxMcHZEZis3SURjYzFhNkNDT3NueEp0dzc4cHBrUXRqM2wwMmRPUm1PTTdrdnZqd2p6WE11c29JN1pWdi9qYy9yTkdVNDl6N0oxTU15OHNTeEhiWlYyUVVUL1ZFdDdaRCs0MU8zU3NNNld1VjVzVDN4dU5HdnQ4Zm1NbEtlZEhKd2o0bEVXUjlmSFhYaFBiVWZMRmtXV3ZCMitxWEFtNUZpT2RjaWJ5VXVqMHFBczQ4VU82WUMxQTNVSnpOT29WcjBOT0pTSFRnTlU4bjVRejVTRzk0bWsreFpBNS9YdTNwNThKa0tUOUV1NmR2RVJBSEpnODcwclNZK2tneE9iYzExUFJPSjdOL3o5RmRURkpRMkVTWi91WHZMOGNibk1hMGxPSjA0MnZOMUpDRWE4L0xyWnVhNGRlSHNlRVJFZmNGTjc5eG1zMUZlb00vczBQWmp1SlhkQ1JIQ252cXZyc2kyZGVKbTU2QjQzelo5cU9jYTFhdjEyYlAzWE00WG5DTFQwTFB2UWYyb1o2TFh2aVVDUFpjY2xOZ3JMZHN6eTEzL0c0ZVNHa2dBL2dTM3pTbEJPOHNpWkYrYVROci9xOXVBVDk2Q3IzTG12NFlSbmVKSVV2ZkNlcHBlTDd5Vml2dWlsVGt1V1dENEp3THN0OHJHSlplZXpLVG9DbHdUSXk0ZjFXclhPbTllbjE5TTVQTU04SkpKSWtWMVNIeE1wNTRiK3I3VWNZNng3YVJiVWlUVUpvUDc3dmhUR2NRcng4RHJ0eUY5ZTd2OVN0eWRUTWUyMDNDaUJmcWFYQ1AyV09PbXB5czZkSkU0V2t1MzE4dHJDSDJ6YlBBSHRXNjBKeUZ1TWRha05ya2pIUFV1eURoSnl5TFQ4NDI5L3AzZEdMenB5WXpqeW1oYkM4WGZYV1BkMG5FUnV0anlwSTNEN0dsMFV4eFpRNG4wUDJ4RWFOK0I3ZFhRanFITFM3eEVKOFRnNk1pYWdkYTZxLzYzMUc3SzdaVW9FWTl3c25MejlJNTBZdHk4NzhWT1o5Z3crV3pMYnByMitHZFpQYkhOQ3dPZXFidlgzUVVJRE5NTW5jSkIwWnR1WWJWZSsxNEhBbGFTUzhUcWc0RE84VDluVGJ3bjhwSi9lVzFLMUROVFNoOGZ1bnV2YWJrbXFOSlBCTXY2UDVWTTJrUnVKRTBGayt4UXM2MXFqQUFBZ0FFbEVRVlNnRnBCOXJ2VVJxZW9QN0o4ZGlPTi92KzhrUjJYRSttTjl5YXVxWldkK29JTzNFZGE5MjRObkMwdDlmU2tYZFdOOWY2aDFmeFloNFJ2VmVZeTEyeGdKU2FLWFJ4TGFFN1pKNWxWbDVNUk16L3R6dnZRbjllWHV2ei83VUxmaXRsWkVYN04xUDlRQ1dQVnVJTytyYmk4NDNpZjlPdHVuNTFnZnVwN3NqbVlMMDZiNXd2T01mMlFYV081VnQzWERiK2JwWXI4OUxwS3VQWGhEUk12TDRkbit6d2p0aUVpNTlPSnBjSzhaNjBqNHZCLy9LdmZNaUJ3azVKQzc1YVd4cFk3a2c5K1dPQmlUM0FQOFV6eCtMWGtYZU4wQmNtZWs5dXJHYjQ5ekMyaHhRUGZwN3BsMEplN05VeDE2bkFrQXpxWWxzdnBqTFMrbzB5RGl5MHowbXdaZkJvNnpOTG8rMGlPQk1BSEdiMDJZdDVSVXgxNkdQb2dSc1BKYUI2QlNXMlNmYzVMalMyTDh1YTVmaks1MTR2WkFkZXJBcFNNM3lZR1ErbXJTYVRTV09lam5rY0VpQU1sMkNRUUoyTXJiemVWbEhKQ2xseE9vUlByVXZna3V1UWxaNFA5UzY2VW85TXAzcHk2ZDdMdHFuWGJ5eUhONWkvcUxRTWNqN2hQVStESkxYU09SVTl0T2UxbllOMDhJbi9xUDhzSit3bGx2RVRiT1JKRFUrRGpsN2RITGlPa3JqSU5RSjZjaVdweE44TFM4ajZaMG5jUjF6emlwSVpsVXVYcmNIM0MvYWludnY5YmE3bkx2Q2R0YTE1L2RsaWVuaWMrSXNwOHozMVVMWVVyOTA5czE2OG1YV0xFZktNNnFkVnZwSkpGVGxqZFhFamdCUHRkdC9qd1ByQ3VXNjR4OVl6bFZyZmYzK2l6bHhmN2ZJMDV5a2sxYnlTd0plZHdPY3NnaFdWNGEyYW9UdnhBVEIxNHpRaVBtbmZlZWVOeHdKNTFtQUxhVGhIczc4Z3h3N3J4SXZEOURRTnhUUTNIQzRjLzV3TXZyVzBJRHl4T0lPSzNQRGNzZEdCZkFJRENaVGQvL2EvYmpQY2xIbDc1Zjc5b2J3WG9hMEt2VzdUY04zQ28veHNYbFVBeWZCblR2Ti9lVWsreUJ0enZxTXhwb3Qwam1TQ2Z2M3dtb1NEUzdVYldBUjRYN3BaWXlFd0JpMi9sU3R4NUhMcjNoMGRXK3BKRGs2NHh2MWJIMnBQZ3lrWlFlMzIwekFyVmVsd1F2YkI4S2t6YmJjZ25WcDdydWYwa0FqdTJKd0Y5a1RtR2U3ZU0yeXBkUnNUOG9UWHIwVDdVK2R0ZDE4cmg5UEpnaEJsNkd6TnZIV3V6VlgxK3UvYXZXWU4zN1dOS3R1K2JTOVZjNk13clh2SzY1bEt4cXZTZnBZeTAybTBSRjN3bDRwbjVKVWtBaWtVZzVkYUh0b08xaUdtazJMWlZicDZ2YXAvNlAybzIzUDdaSmIvK01OODJDTVZ6VnVrK1BRTDNQTHA3c1hzSTJXMHNQOTloM2tTWGlqOTFqUkRkRHNoY29IbkxJYnZGVEUweVMxMGZmczQyODYxeWU3c2o0cDdRSUFxdm13ZkFlMldNWWtoZW9DK01EcFM5dmNnOHV2V2hmOFQycm05SldlZWtFSWhHU3F2WEF6TElVU2VIejBrY3ZpTm9qbllHOGg0amNTMTdTYzk2ZVhGaXZQdkNrZ2J0cTNCNDZVTzdYVTd2ZUFrb3piZFgzWTNSTERaTGVUbzYycE10cmlsY2ZBVGFlbHFVMTFId0puTHltOGdoWDNaNHNlQW5YOVQ0VWJsWjNFRVFDbE9yZHZjOEVsbFc1VER1YjZ1SmtoK1JJY1ZPZkgxK3VmOFo5Z2h6V3QwNGpJK2s2MWJWYytkSzNRcmkwQkU5bDRHVGIrOUtsMXVsNTNmRHdEZDd2MmxuWGhyanNxR3BaSHZhWFdpL3grM2ZkdmpodzVQemg5MGhHdGw5a3o4bGxBdmhlamovVWVyL0ljMTJYR1dvbVcvWFR6UndvSFpFT3pSSW9mRnJXbFVTelNtcUgzaVlTQ1NDeGxxUzlMQ0paNnZkOEEzcFp1TFRDbytwMjVvTDl3MjFhUjlwOGpFNXRsdUZVcHl6WFo5eFRHbnp2a2NLS29GZVQxeTFoMlhvN1RUTnRtK0lrNUpnSk9lVGRKVTNMTmNRa0djK1pScDQ4QWJvdWNiQS9BLzU5d0orUnZSNkNXWERQNzlGejlGcWN3N2VURWNZbklGYTFBS2M5UUZBRHcva2xubzkxTlZTLzFIcjVsL1Rrb09nNlBsY2VhR2JBd3FnKzc1RTlSTVRib2ZSemtFeWRFckFZMWUvSXUrcVMrb2IzclVzSW0rNG5vTy9mRk5hM0E0a1JjZHJUNWx4Ry9ZL1hmUTI3eWpYTjFuQ2pPdHRvSVd6VjhrWnZlWk9UcDlQcmpzc1RuUkNTREVobi9TWVk3UExyNE4zdElaZEtLZXczQzZNOFA5WVZsSEttellrUDYxZGtqcWVOdVNkZXB4L3BtaFBsbEFienJQUzRYTE1EV2NxcjlqTDYvaXZGbWRwblI4VDU0a1RhSzgzSzBNNTYyYWM2UzNVMXNnTmVWZ3BQNHFkcnpBZEJMOXZkcWE0RVJNVGpMN1djbXJYSHB0S0dpSFJLbndTMC9iL3F5dHUvUkdNTTAvZi8rdTNsN2pQakkxSDlrUWo1Z1RlWFJ0ZVJEU094MERPZHJkVVNNaDNack44cUE3Y3I2ZytLeDArUXV4ZWY3TUZqVS9LUHYvMzk5TStmZjdyTVZNUWhoN3k3dkpBU0dzUTlzZ2NrOGhrYTVwRXhaZmk3T3FFVHNZM1pvU1R1TmVuRXo1aDNyNUhpS3NUVjdaYzQyWE96aEpMZU5RMWl6L2dtQUhEd1JiTENkY2dPL2lpemRiTEhpQ3BQM1FreFcybWt0RTcyY1pEbEF5WUh5eFIrUnFjT1FQbnpIVm5wNHZHK0lmMUdVLy9ldmpiTDAxK0N0U0V6ZzZ6YWtjQzNaanZrbWY5YzY2T2xxeGJQN0RjTHEzYXJkcXc5STc3OFJPQ2RKOFZSSHdLRWpsVGZZMzg4UHY5UGNrUGI0dXZaV1c5dW83Mzk4Q0FFT25DOFBidTMvRFBDZS90T3kyL0t3cWErVVJhV0ozWXB2enlVb0NNY0V1cnVlZENCQmJKZG1qM2cwdE9rRzlQME12SzI0dnE1em1yYmVwWjZYdXczQ2R1NXJ1MzJoMXIyakhBWjdWTmQyN0FmRGR5Tm1RLzRycm85UVpPNiswd0NuMVBhSjRSbG5sTzdadGx4ckZBWWQzYjVYb21MaGVYMWpoUlZyY24ybHNoV2lCQnpieGQxRVFINW9hNnprT3FuR3JPOS82cWNmNm4xb1EzcEZMdWhCTHNyblgyODJqTVd4YmdQRW5MSWR5c1R5N2lxZW9BemtoVHY2TG5relpxV0hUTkJJNWtoYURLYzlEQVNLRWs0VU1rN2xEd3dLd085dGRITThxUUIycjI0WFBiRjZYMHVUem5qbnA4MkpMMWRFdUMvcDc2NHhwYnBkY2E3cThjdXJPcG9DendSakhpODkrUnJSczlSbUVSQ1JpU2RZQ0RwMHVWalZXL2RpN0FHc21VejJQNjA4VlVFb1dvNXBVcWc1d0gvQlRMMUVRQ2xwMWNPQUhtVEZWYnYvK2hPMGVucXV5b0RyejB5SXNZdW5MMXhmWHdXcENySHgvWGpKQ0djVWVMeUR1MUo0RklTcHNIVHdSU1hMNHZ5d3l0Y2I0WlZuZkxrTWVubElEOFJNQUx0NTdvQ3hPZGFWcGJ3blJ2Y3FEeERJcVR2eVhSTDQ1djNOU2VaQXJrZm9iTUlCbTI3K3NDbnF2cWZXZ2pVWXkyQVZtQzJXMklrOFRJaTJOZDk1cHV6OWdXOUNLdzVobmhmWUR0bDJYby9JNkZRbW5RVVZNaVg5NEZSbSsvRzUxUnZyQXVPY1I1R1M5TkVRcGczenFDUytGY3RwMUhxdnZLWWpqRytrY2JtY3R6cWJNbW9UZHpjVnpySGNxeER2bHRwWmc4U0dCb1pCdzlMNlR6ckhuN3Z6TXltM0FHdXFzYjVjMCtQREhrYVlEbWdwMlVRTjJudGZRR1JwYXZCaFBINklQRmN5NUdSTXI1ZmEvR1F5b2k2OFh0TFJ3cTljaXJMMFg0VUh3Qm5DSUlJVlRmd2VkaVphL2RLR2t5OFBGTjZzOHNUOTVBMjNsdnBwR2w3L2Q0UkorTWh1SmJvLytkYTF5Vm5RVlQvSDJ0Tmh0VStWQlk2Q2U3THkrL1BkVzNQLzZuMWNpYzk1ellsZVhYdmNiQ01KSUVHTHp2dmsrd1BWY3Z5bXBGT1BzTkpJWGluTTRKbFMyKzlMOGQwZlJodnQxL0I2NTFFeXIzbFRnbzZvTXMyb3FVeFgyb2hzVHhacWhBUDMwN3ZST0JpMzB5TG0vQTdJc0wrN0FjQk1ENENmZ0xnejdWc3NwZmRaVHFwVGZKKzBvMmswa0ZzMWZya05Uck5MclVtSkV5RDR4dnpQWnFOWUJsd0xKckJEelA0SXRueDFFNUgxM21QUkVWMXFUYk8xUUVzaTZvMStXQjgweGltc2JHc242NE5idVhuVWxYUHg4YjBRLzVRZ2c2VG1Ma0xCODYwenRYQjJKc0FQbitaVHdmbzc1Z2RrVGdCR1owWlQ0TXE0OVI1akZaZWt4MUx5bnd3VHlBM0dld1BkUjJrOVNLdEwzVWREUDBsVlRmbHB5bmVuY3QzWEFpQTlPMUhIVkxmR3dQYjVJMmlldEx2a1dkeGhoRE1pb093MFgwZmFGSytIY0FTWEJCb2J4R3pqZ0JGRXJ6UjV2amJ3U1IxZDZDbTlMaTB5dnVRWnVpNHBsenRoZThOK1lqcmVnZkpxYTdleWVkYVFFSUN3TlN4SXd3ZG1IZ3pleFhpSmVFUzBVb3pENG5VK1BPZjhKeXVuV3J4dmwvcWVzS1U5bGI0M2hjdXE1TDRNcUdVaC9UZExiUHNBRGJ6VTlCRkpOUGJ1L1NSdmgvcU90TWdEN3c4MmdUMkpFelB0WDZ4SlpjMXBiSldIQVQxbXIzVGNySFB0U1pIbFArcFpVbWhkUHRQcldlcHRzVEw2bHpMVEl6UElMSWZQdGVhRk9sZWw4OUNIampqNWdSVHo3Tk1LS3hQempyTk9nQjRQeEUwZjk3YlQ3S1JkTVE5MU5XWndYZzRMai9iYzArMW51bWlMbE16SVVHODM2UTJlS21LeTdoK0pZci8vUG1uNkNRNFNNZ2hmeWlaQk1iSnNMa0JvUkY4bFNRQU5TSWlkeTVCNFlEdW5sWWFDaDk0WndGaXQwNjBBN1NYOEp0THRKSXhsQmRPcDh3SWlQRGRCRGZTdmJHMUVXOEh2a3lDQXdNbDVaT2U4SXQ5dXJUZEN6WjZab3M0N0pHWndUUUJpSzA4VWJvWmt1NzV0d2JORHVDZE1GMXE4YndTdUxoM3NlejdZNjBCb2ZaMmNEOEFBZW5Kbm4rdUsvalR6SjdQcm5WQXk1ZEZrYlIyK1grdk1sVSt0WnlIcEkyU2dKaktYTjg4ZGV4ckxlLzRFTWptTEpUUFl2aE13YVh5Q3hTcGkrdkRlMTIvUytDVU92RDN4N285T1VyUGNsK1JBUGovMUxVZC9LY1dja0xTK29BNENjNVY5Mnk3TEFlVm5jcVcrbXY1SWVOak9RbnNWbDFKb01yMGwxcG1lRHovUHRPZXlsTHBQdFZDYnA1cU9jSmQ5U1dpeHVWWFRpU21IQmExOUJNU1haV3ZiOVJXK0FTd1oyVFdybnI0RGwvSWp1am9jTFVGSHpORk9KaW5xdlhzb1YvbmQ5SkpkZUR0bUhsMCswb0M2VmpuOUhKdFNGNFBFbkxJSDE1MmVzWjlHdnhkWk0veUpwNnZQVmlPUWhMaUE1VU1RcmVtZHdyc1d2b2tPM3NNTm9GZmQ5OVBEdmwxWU5xNUw0VUExSTBwQnloNnlFaE10dktWd01yTU01U1pzcnZubVJUSEh0MFNvZGdDblA3dFlWOUY2cHYyN3dNa3I1UDhPaEdoSnpHQkdJbmErSWRheURFM21PdG9VdzNJSkRrU0FiNXZ0Y3lJU09kdWdQYlpTUzVyR1JIV1diTG9JTXpqMVgzMUVlV1JnTGpUbmZFUVZNa2p6bmNBNmJqZmJ3aXZPT1I4b1BQaWhHL1gxNi92TFNmbW1VdnVCUFRZbnRJK0UrNWRVWm54T0ZpSmxwcnkvUnh5dm9pWS9WRFh0bEsxdHR2VWxUTkNUbnFlOEovQU5DM1I1ZjdCLzMxNTVrc3RiZmFYV3RjUDYwaHBPOGpWZFpWRDFiS2s4VkxyWTdFVkw1ZmZjaXhqZko1dXFuZUcwVkhiVmNzc0VJVjJqallpa1lPeWV6TUVoUEZ1dFUybG8xbXJUN1VRT003QWlweHdwY0NUeGZGUTZ4VUVycnZycFhUVDdCenJseXRJT0p2MWEvL1l1M1Q3SUNHSC9DbGxRRXhrL082WnRuUnBnZDhkZXl5MlpuazRPS1IxMkdtNUFIV2NBakd2WE82azV6cnk0cURJano3OE5mek9ZNTlGTEJRUHdXalZyZmRuYjkxd2dIbHJrTTM0U1haZW5kNUFTQmFaem1pd2RRSlE5c3hlRCtPOTRvTzkzMHVBL2hSKyt6cjBzOFdqTVBySWswd1FTSUJFOFBldldrQVh5NVpoMHJJUjZlUFhxRlBxMng0UEFiWjA5R1ZWRE1zbFVDSUdvL2JnQUVieDhJaFJBVktCS3kxVms5ZWV6Z2ZPTXZIdDJRbHN6WUM4cWx2OWFRTkZtRlNYWEJLcU9HU2ZPTHRBdlFUcXpyV1FDQjNock5QU3BMdG1DWFNZZ1RhVWY2a2VaSHM3clZySXRjcmk0MHVjMUo5TGp2Uk53TThscVNKSmZKYUhDMVF0N1VMbHh5V04xRkhMYkIzUWNnWk12eGwvSVd4eU9IajVlTDBLMFBzcFZGNEdqTmZiRU50dm1zVlB4TVRUa0l5V2d4WFMrYUdXbVNuMUM0MVJlby9MMTFwV0NraDN6VEtxWGFpL2V2L29uRGRsWVZUdVQvalBkcTV3TjdNaHMzS1FrRU1PZVpFWEFPalQyNjhCVFMyd24vWG83OWlINFVZNnBiOEZKRzkwZmFPVHZTZzhNYXNqSVJxYzlMdlZlN0IwYmVTRjRvQ3JBY3c5WkZPa3pNTHZhaXVqTmhCbWRLcHVnZkZidE5Fa1R0eElCaS8yT2Rrei9OM3A5MTVFaEdYbUEybnkycE9BczUxSXVCUklwSlhBaFI3Ymo3VitRYWRtREQ3WFFuWjVLZys5bDM1TWFLZXJrNlVVUnJwVytDM1JiSTIzTVFKdGxSdkJWd0p5RWk5amtqZWxKUUQ3RitSRmE5aFZaaGVFNWRIaERqb3ZpTStkR2hlRVMzcEswbjNWMFdOVi9iOHZPdjI3bG4wUjBrZGw4Nm1XbVFLQ2I4NGVYVjd1Q3lEKzVTVWVna3ZsUjJYeVVPdTN3SCtvZFRzaEVGVDc0NUttU3kya1IvcjV5K3JZbHJrSldzdWw5QnhQY1hxd1o4NTFleEpUSXJSYVhxVGxhNTlxbVptNDFFS1UzR1lvZis3WTZKYkJlbnRYdW1rR3ovdUxqLzBLYzdiZnZud3pwVXVkK2R2M2Fvakl1bnlxOWJKa0hYaWc5Sjl3bldPbFp0OFVUdTEyUk5DM1NJZ2ZyTUd5L3ZCeTcrbWZQLyswOTZYQ01mRkREam5rUmU0RTI1MVhaU1d2bkFsSjRLa0RKajc5UHRKM1NyZFVMbmU4enlFWlFnSVhQOUx4cllRelhScGNmU0RSUVBzV3MyRlJadXZmNnB5ZjBjQ2J3UGlzdUhlUVMxT3F4bDV3QVJNQktZVjNQZDZMaEZDUGRPMWkvOVVPR040SkZNTnpSa0JocXhidmZ0V3RCMTNMU3pSZ2EwblN0NWQ3S3F2WitwU2t2T2k2azIyUFN5QkY5NVZuZjE4UWx4TVI4SFIxVDVEajdZYzZWVjMzSFR6VXN2bVp6MUducDFvdmNVc2cybWQwVXQweGZlNmI2SllQYVFtWnlrUjVKNW1TemdUK0pBYSsxSWQ3UHdUR2xUNUpEc21BTDUzcVpybEp5TGpuaHNReExhRlRmclQwUnkrWXJWcU81MVU2ZkQrTzE2ZTNDeTkveGFGOWYzOTUwVlZFNUV1dFNSZmpVRm15ZjNBcDBJaDBxaXdWRjJjVVhBVHluWWhyUEdKNlNVOUtJaUZlbHlwN0hmSE10cTgyb2xrY2tsSE9SckxQY2piMlM2MDNxSGNFaFBxbGZsTzFudjF5VzFOMUpTRGQwc3hOT1k3b1BlU1FSaVpuSVh5Z2Z6WFlTck1nbG5ZeUZFNUU2SlVhNlRGTlBwTHdtWFFLbUpmWnl6V1BacXNNbld5OVJtUm9CUVJwZ0dsY05jaU4xcjYvcXpSMW5zaW1oOXRiVmxzQTNUMkg2ZmZabnVQTUNPV3VOdllHSjhkNUhhWnk2bWJkQ0dDOHJBbG1IWGdxVHJXaEx3anpYTmYxOTcvVXN0Rjdob0IwZldHMEx0NkY3ZnFEcGVza05EMjdWYS9lTnR4ckxJRDk3MXFEVithTmdKK2dUOFNFN2MzWHZucyszQkdUOUtkbm5VdkMrSEZBUzNDZmlKLzBKTkg0c2E2QVg4dG9CTzU1OHBVL1M3djBXT3YrU0svOGo3VzgxTTVmL2pocUZ5UUIzR3Z3c2FyK24xbzJwMHZTbUxKbGQwNjFKbmNFdE9rVU5OZDMxTDVHYlRMdGhVbWdtKzJKTTJza3RSZmM5ejZUOUhQUVRwS2g5dllKMXovV2VwbWVuQlFmYXQzV3ZjOFU0bFNZTHdnenNyblV6NFhFOTF6ci9GeXE2dHM5bUNFcGNNZ2hoOXdwOTRLakRsaTl3WnZWSmU2dEdPcXlOL0p1dWRpZXNIZWNaRFVscjNqTDlpT3VWUzJEMkp1U2tEdG1RU2k4NW9PaEQwejNEQkErWUNvZEg2QVZ2eTlWOEwwTzduVnNkWG9sMmFCMElLVURSLzVNVlo3QlVSaHREQlVBNWZLMVV5MG4veERBYUdtRU5wcFdYV2NETHJWK0c3V0xreHJwbHZyRWJEL3gvUzN1M1dSZGt3UUlpSGJMV1Z3U3dHRTdJWUZnUENObmp6NWVMbDUyWjN5VENKTEVQMXQ0eHZtQXNIcU9SS1Z3TDYyM2QzRE1mUmFhQmZsV3k1NExoWG11cFkwd3J5VDYzdTVFa0g2c3BlMzlxOVlISWx4cURWNlQwK0ZqTFh0MXBKUGVkYU9YYmVyWnJlVklMcG9GK1ZUWGRsKzE5QU41N1RVVDBpMUg1RGZyeTBrQ1oyTlZCcHAxNms1KzRsanpiTmNZdC9jVkVtUXVYMDMzcFJ0dHFQYXNjR21iN210RzVMbldNNmhwUnBMOTZya3lNYS93MzhzMWtWV0dlYWdyK1hpek1mRWdJWWNjOG9ZeU9WdlN5czdqWm5mSlczZ3RKSHRJeUd4OFd5RDBMZDRGTW5nYnJCK3RXclVNSUQ3Z3prb0VhY3hIOStCRy90STk2cmRYenk1K3hrTVBvSU1yM2lmbzRRQk04SGRUSHE3QWpub2VlVjYzN2hOa2pMeXAvaHlYcDFIazRaZkhuUHNGSExocHFRVTNzSGNreE10dHhzTTVJd1J5Q1h4eEw0ZUFxWWNoU0MvYzAzZnl4T3Q2MVhvR2dQbjBtYlM5ZVZYOWRqT2FDVGlmYS9GTWM4TjAxVktuMHBzbkNLWDhuV3FwMzVPRmxXZWJZSkY2Q1RENy9qbFBqOHZDVGkrNi8xaFhBdks1bGxPaGZDOVBhdE1rYlFxam8zcS92dWlrcFZuVWQyYkpxdUwvVk5kbFdIb2YxSCtxNnYvcTlvQUc1dE5Cc3ZmVFpNY0Z4SG0wdXdqMUkrNlZoV2NmY0tJcFlYOU1KMjJwWCtzK2RkQWVJZTd2VWIycGpuU2FsOXFRWmtPa3Q0aFVSeWoxZjlaR3NGdzlyemNrcEh2WHgydmtJQ0dISFBMT3NoZEl2YUZIK0UySngyOGxNek5FVzgvc21hRjVFWUVHZXJ3U09FeUFhU1EzNGU3WmN4UGlvNHhBK0d2cjM5TWpTS0ZYMGdHVGZuY2VzN2NvRDc4K0tvY2tHdGdkL0hUaVhsZ1NHQzdoRUZEaHJJY0RlSzVwNzhyS04rV20vUTRNSzVuSkMvTkRFT3Fra2NjTzA3TXNvSjZJcG51TFU3cHZUYWdvSk12OHpYUVNlRlk3Rmlqa0hnV1ZnMGhtMmx0QUlLK3lZMW9pTlZ4UzVYVXFIWHk1R2UrcmpWVXROa3U2YUVtUGxtT2x6ZDVKU0ViMWZjYUhzeStLVitJMlViL1pQd1MyLzFMWFpZaFZWZjlmWFlrSWw3eDFEZ0VucGQ1WDJPNThqNUR1LzFpMzlhZDlQOXlEeEh5eHJMMHZKbktpamZCVlN4dDZzakNjWGRUc2syYVp0TDlNN2NXWEplcWRMZXczbXpZVytvL3VNWityZnYyZU9PSWdJWWNjOGwrUTVqU24yTkZIcEdSMldkZnZUYlptQ2tiUDhmK08yUWFlK2tLUVZUVVBVbDJpMGI4RGROUHJ6UCt2cXVNN1p0MGNYTHIzVkRJQ3k1THA4bWowbXlWakRPdGdTYUJBQSs0c2NLYzNOT25DemNLSzIwL1U0YUEvU3RmYjBLVnUwMU5kK0xJamoyZFVQbHpxdzNoRmx0US92dFVhWEZmZGJuNWx1YnE0Ri90Tmx6b2lmYVh6WUw5VjVyNEpXcy9waFhvK1E4SDlzNXJ4cWxxM0tlYVpaVURDUm5MaHB6V1JPSG1kTU0xenJkOHhvdmVMaUxBOFdmelVzeFAyQ1pFTjVwM0xMS3R1QWJndjAvUzZGYm5UYk0zL3ZZVFRjalRxNXpNaFRwQzYva3I3cEhBTW94a0drVUROV3ZEOUlTVGpuQjBnRWRjOXprYndDR3B0dnY5V3k3Nm5RbHlxVCtsVUZwK09hMVpmMDdJOTlqZWZqV0tldlF6NC94ekNVMWJQL2hZNDRpQWhoeHp5SGNqV01pU0dtVm5PODJlVEVVbWJmS1liN0RpUTdTbnZUUzg5NjNWaTlxdTdkMWNiNk1wbDRsMDBMQStDckJsaTFKTHNMWDAzU0FobklmYUllMDMzUE9kNUY5alZtbi9weFNOSWZVK0NlMWdKZUFRMDBoNGNrbEhHNlI3MjJhVXlEbmdkQkxxWE9TM0g4WFl4UTBLMjlQSjJ4amhHL1lIN09RVG1WSGJ5TW5NSmtNVDNHRkI4dWFaNzVmbCtEWUZVMWIrZTAwRVlPdFpVWlpjMkdtc0Q5Nm1XRGV6Y2tLL2pXNzhpRHRYZkNkZGMxNUY0bnlJSjVWdnRsV2NKVCtPU2NMbVJ5dUpjMTdmRmE1L0pmeERHOXdicHV1ck5qd21YdnB5aFNYbjFjdVZ5SituaEpKb253a2tQa25BSmwzcGRFRGVQdGRhcFoyb0xpa05rZzBkUjY1N3FsMFJPK1R6aHYzVHVqcGQzNTVYL2J1MzFiNGt0RGhKeXlDSGZxUkI0SGNTamx4a0NOeEUrZWZrZCtOd0Rjdm44dlpJQU9BZnBOdjd1aExJdW9RMFM0c0RRaVljUCtDNHRFWnVSaVhxYklSSk9IdlQvMTJlN3Z0YTh1NlZxOFV3TGlQQStRU0lCdmhPUngxcVRGK1hIbjlOOUxuOFRjZEhKUnF5UFVidWxEdHdmNHNzOUNHclNMSWZLN3oxbU5mYUtreEFuVG54bmhOZDlJaGlGZXp3cW1KdWZXVzlPNHJTNXVPdXpQbU1nNGY0Q3pvUkliK255QmRlazAyc0ppUDZURUNWZ3JyaDFMUFV2U0pQa1dBUk5wNEpwR1pTV1Jva1UrbElvNnNFK3dmWXU4U1BCS1l5TE14QjZWNG42R1pkcGNka2JTWjNuWFhycFdjMzJlTjZVUGw5QXFWa1F6bUpWcmZjU2lVU1Q4Snp3SEdkRldHY0s2MGY4RnNMY3pGai9OL0RGUVVJT09lU1EzN1hNem9MY09kTWcrUzJOczRQOWtVeVREMTNmU256alZDNTZKeDNzYnVsOU53a0pPbm42ZTJSSURuZk1FaEhFNiszVThsWUtQUEtGZE9rZEc5d3dLeklqcjdLQWlXK0Nsandnakh0ckNZaDlsa0wxcC8vbnV2WDBLanozUk1qalRBODU5NFdNNmlITmpQaTFidlprcnhDd3FtemRzMTZWMzdRdVNXU1JlelVVSjQ5ZDVyTUV5MXBXSThMQlpYUFNNNVVObitFc2w1NVJtZ1RIU245UDMwaDk2Ly9mM3JubVJuSWtTZGlLTDdHbG1jRmdyeUJkUWdjUW9QUG9JRHdQQVI1QWx4QjBnc1V1ZGtZOTNXeXlXUHVqeXBpV1ZoNzVxQWRaSk8wRENpem1JMTZaN0hZTGQ0L1EwRFhmSDRYdm5CcnQzNk1USWhxdXBGNGk5U1pwU0pMdVowR3E4ZWQ5NmgzaDJMUFBubHZpT1VFNlZsZm9qNzE2SzdpYUY0V0QvZzFDeXRDL0g0YWMwV04wamY0K0hreFU1enVwSVhaUDZNTENkTnpaRmgwRGxrZUJvMlBpb1h3cVZIbWZUaDZ0Z0pjSnUyb1JFUkpDZUJHTzRjazU0RExITzR1UWdWM2I1K0wzdTJFeGlYM0cyRVArR20zek5rMHhKSnNHNW82TENBeU56WkF4VzQzeDVQWTB4b1JHcVJvWEtpQjg5Uis5WDQzTkM2eU5HQlVRbkNHdWx2QlY0NWRHaHliWnVvZkNaMHA1bnliREx0RVhNUm9DQkhUR3I0N3hsQnlnS1V3VklXN3c2MCtXNDk0Yno5RUE2aENnb1RwcG1HcXVqKzgxVkQxbkdvQ2MrZVk0cTFGZHZjTnFnQk1WSnI3eUZoa1RoZjUzNDdQbit2N3BTbkQwWHJodzVleitOYlozVDZkSGdEa2xrTEpvaExlVzVxM2FwV0pFaFpGNktqeFhRMWVXZ3ZTQmRlanpZNysreC9wdjhRSEF2NlNQL202eERmU0E4bjROdy9KUUtyNUgraDd3SFhpd1kvcithbmlmNXFkNDZLVjcwZHliK2l6U0Q3blU3cTZjalY4U1FnaW5pUnVNTXcxd254RjNBNkl5S0NhM1pRZUcyakNKZmRzd1VWQU50V251OGJtbzBkQXExNDJGb2Jic0toejlQaG9DTk9KcFRPZ01mTXRRWnB1VzhsbWgzdzhWSE83aDRJZEd0UnNsaStJbmpaUUZPZzhPalZjS0Vnb3FiWnZucU9qM2ZabFRobnR5cXVlaDQ2NWpxK0V4L0RuMHZrQ3VBN3JaN2NvSVhCWWZOZVJkQ0FGdEFhSTVMT3dUeDl4WEp0Tlpmdzh2cS9xZzM4ZkduVzJtV0tDeFRNUDhDdXNWcjc3YmZQOEIyN2thdnFQOEN0Mk83SzFRUG4xL0YxaUxuSCtneTZYUU1kVlFMaGZOOUFSb1BUcE9GSmFjQlBqN3BnOVZLSlAyUWNVSHIvT1ZzSmg0cndudC91K0JYcWZQV0o4MVY5b0MrdSt3aXpPMjhSSGQzaXZ1OFZ2ZTNOMGVkSytQZmNpTzZTR0VnN0hIeG9RN283UDJWZjBEU2Q5RC8vbnVaRlFkYTUrWHFlTjVLRy9Uakg0Y1NsdzBLZXBYZ1RaMTloeDJyZDQ3cHd4dGcvNm5yMGFEeHFvUHpValRtTkYyZkVVLzFFVHZkU05LKytJSnJKbzN3bko4RXpVYVJPNWwwU1Jmbi9uVjJXUmVjeXdxSTFtUFZVSk54MXU5RFpCckthVFVhRmVEME44Tm5lMVdzZW41SDFxV3ZoK2FiK0RQb0NXaXRUeTJWejBBTkpCMThRTytTL3JlK0hmSHhSSHhHWHg2TFNpMDJLOEYxb1k3c0RiY3I3RGVwNFI5ZlpBeVdJK0crR24rUlRVV0tqSjE3S3ZWNWppMnJWVzh0TDk2L2dIOTNJc3Y2SVREVi9TZkpiQzlMTEo3TWgrd0RxM3lWYi9VMndMMGMxSTRWdG8yRlZJYVZnajBSYmp1ZGVKNU5iMzM0QlJ6U3VNSkNTRWNoTEVFOFdQK0EzanM4b2Y0N1pkZkY3c0lEaGRLVTY0N05pN21wUDdXNTZXcEROTFdkZDYrNm5mM0V1emFGcDBGNTZ5bTdtdzhOdE5PWTRnaFBpeHpMR2RCRFdZM3VEUU9uUHNSOEhjMWNOaE90cFZMdjNLNVVaOTVWcEZ5aVBlZ1ZZNExEUGVBMFVCbExMNG0xMnNaVlo0QTBNMkEreXd5Zjlmd3VwV1Y0Y3ZmdWlpczJxaEdOekE4ZHY2dTBHdkY5MHp6TGxSd3VzSE1zb2JlUGZjbXNlL3FrZEhFZE8zN0R3RCt1VGwvajZvaWwrOEFBQ0FBU1VSQlZPN2Q1MElOTEUrZkEwT3dQRS9COGVkeWovWGVJaFFaN24ycS90NjhiQjl6M3MrL1BYNW5ib3ZtbmZBWjhtK0pocit1R1BaWjd0VTYrSk4vNTB0MEszTnB1LzN2WFVWbGxXQ3U3NmxQWHZUNmVZb0NCSWdJQ1NFY21WMk45RjE1VFRIaTdXaTFoY2YxR2hjbFUrNmYwbzVkZUEzaE00TmpDS0ZEbGFQaE9ScFdWUmsvYUJ5bkVGQ0R6dzBwNHJQL2VnMkZ4Q2QwcXdIOVRlNnIycWVKc3JyU0Z0QWx6bGZ0T0JSZXBvYXc4THg3TGhqT29nS2lCWTFHR3JWcWJLdEFVYmpvZ0FzZ05hNTFESG1PQW9iZUNrM21IeE1HclhGd2tYR0piYU5UKzZJSnloVjZibUg5MURZeUZNc044cS9vUEFlZnNkNFhnNTRBRFVsVTFGaFdvVmM5T3hWZFZWNlVsazJEM3Y4K2ZGRUI3eHQvcDlqa2U4NzlQdmlkdVNMODIyRFpxODN2WHpiajRWNFFmUjdxaWRQM2htTlZoWDZoMFgrMlZaL0hKVHBCc2dCZWQ0SnVDZ25IQ2lHOEc0YU05cGNRUXZ1R1E4MjU5eGloWDJPaTV5WEY1QnRpeUVzQmpCdWJIaFB2TSsyNk1sSmxwQUg5WEEwdjl3bjlWYmMwZ1ppR2pON2pzL3hxTEkwWitXTjRPRXlGajFzclgwQzlRRFRBNk1XcFpvTzFEU3U1RCtpV2wvWDcySC9hU3BwZjBHcXp6bENya2YrRWJwbGFiYiszemR2cGVSOG9qai9aZWQycmd0ZDUySk1McjdOTiszZ05sNHF0akYvK1R2R2hvVnFlSitRaW14NEdUZGpuL2pxZUYwRTBMRXpEb1RpRzFmTndENCtIMytseDFxM2lrVjZkYTZuL1NhN1RjZmQzeHZ1TlRYdVprSzU5SFBOMmVwbnNLOGVNNy9FVk9xL00vYW5rZkl3UkVSSkMySXZLQTlES0RYa3RwaHJQYzhXS1h6K2x2OGNZRXgvejE5cFQ1aVZ6Z1E1QVpmRE5wWFZQWlVCVWRmdlBvV01hbDY5bHMrMHVSSUF1eG4yRmJqWlhWeXZTMWEvdXBjN0t1Tk44aHJuNGJIQmx5RHREQXNMRnpBcHJBOHdUdWRYYm8rWFNjTk9FZTk3amh2a25yTWZ1QzhiZkV4VWcvRnh2N3YrS3RjRitpZlZZdXlITXRqK2kvdzVVUnJuUHJOUFRvZ3NKTE5EUE8vRDNnKzNranVzczV4cWRnY3MyZTY0QnNMMGExVkQrRS90SVdKNkdIcXFBYXduSWFxVXRSUVdXQ2owTkoxUkJ3ZXQxOVN1MmoyMjVSeWMrTmQrTDlmSERNZFozaVcxUnJ3azlMUjVlcFZSanNMQnorbThCMzRXdk4zZTMzL0NHT09YL0lFSUlKODdjalFKZmswb3NWSWI3UG9iemtBQjRDV0h3RWtKa3pqT2ZJLzZPMFo0SmJNM01qN1hsUU1MS1oybDk5cFN6MEx5V3M1eTYvS2NheEpxOHErMC9zL01NemVKcU96VEdXK0ZYT3B1K2tudTFyVzVJVlludEdnNmorUUJUbjd2MjFjZGZaLzh2MEI4ZmJaK09OUTNCS3Z5RjEzRjNiNHFDUjNRR3FTZGJvL2graFhYNERrUGkvaHY5VUI2Z1N5NW4vczFYNld0cmZ4anR0NFkyOGI1djhqdTlROW8yanIxdWtMbll0Slhpa00vNEhOdlBxelhqUHlRZzFIT2c3Vi9ZZWFDL2twYVh3VFpUUFBKNE5VNHNUL2M4VWR6VEFxeWY5eWM1eHJGZ20vUzU2M3VsZjdjVXQ3NGltUGIzWE03NXA5VkdvcytkOVM5djdtN3ZpMnRQbm9pUUVNSkJPYmF4ZlV3dnkxdkxwM2dOcG00T09YVHQySDE2Lzl6eDlQZER5OWkzUFZQTG1BaU5SR0E3VE9UTXpxbkJ3YjFITkJTRTV4YllOc3BvOERDc2E0VnVGUitHR3AyaE16WjF4aFpXRHcxQm9CLzNyaUUvS29nMHNmc0NuUUd2TTlsdU9BNTVqbmg5WmZocjhuVGxMVkhVTU9VTU5qMFJLdXkrUi9jOHZxSHpLdWlZVng0QTdyMXlMVDhCNEg4M1pXZy9tSE5DNC9Vek9oRlNKVGl6WGhXeXJSbDFUYXIzY0N6UC83aVEvZ0g5Y2ZXOU51aXhVYU5jeDdOcWozdlozQk9rNzJ4TGhPZytLVVA1SVY2bi8rNzFBK3Z4dU42MGhSc0gwcHRXaVNnVnJSdy9KdVRyWWcvNmQ2bDlWWStiL3YzcmU4ampMdDZlUFlvM2Q3ZVBlTU5FaElRUTNnd3ZFZWExcjVINTNrVUltUnFHTmtlMHZCUlZDT0d1OTFaTTlBajVrcW82bThydnVnb1AwTi92d0kweE5XejRjZThCalNxV2VZNitVYWlpUWcwblBhOGhKMm84K1l5dnJqTEZGYlowNDdlS0tRTEVqNnVuaGFzMGpZVjZVZVN4WDdyQkpMMVFOTnovaGs0NHVkR3R4ampRZVUyK1EyZlVYbStPL1EvV25nNFZTN3hXazRxL1lDMUVYSVI0LzlrR0hRODMzaW11ZE9kdWZiYmFGdzNaMHB3Tm9BdjFvckZOSWF6aGZKZG9lN2xjS1B0eGZWOWJPUks4djBVbFdvYXVVUzhkMzFlS0xkMi94TDBvS2hCMEhEbHBzRUIvdGJtcVBlckowT2ZCOTRDZUZCVjZXdWZxNXU1V244K2JKU0lraFBCbWVLbGNoMTJGeUVjUklNclVaL0lhZVNwamRlNGlhc2ZlalZaWnhYMHRZVUpEaEVZeEUxcnBSZkRFWEtJR0hiMGQzTVBoSy9vaExIclBBdHRHNmNxdWRhL0NoVnp2c2UxcTROTVlmMEszZEdtVjdLeGxPeTJQaGhyUWF0UzV5SEh2aWh2ZjlGUndYd2lHVC9sdTZFQVhucU5DVFBOcktHSW9Iajlodll3dHNGNDU2di9RRjQyZjBBK1Arb1J1WmFsdjZKNDU1Qjd0dStNZUlQZFNxSEd2NDhCM0RxajM0ZUE0L1lCK2NqN0Z6VVhqWHNVRnJaL1RkdnY1bGpFLzVmelFlOVY2OTczOTZqbFJqNDJlVisrYUNpclBwMUZQQ0NjQnRBNFZRL3piWXJuTDl5SStTQlVuRjBJSUo4ZEhXT2IzclhLSU1LZGpNRmJudnN0WDdycWEyWVlxN0VSRE5JQXVyRWVYOFBUZDJHRmxjQ1liNkF4cG5lM1ZFQS85N3ArcW5heFA5MFJ4SWNReTZaWDRONEMvckgzTzBEaTY0ZTJ6NlR4R2o4dVlFYXI5NEJqb1VzaVBtL1p5NWFlL052MzR2UG1jWVMxYTZNRmczZ3c5RzN3MkRHUDZodlVZZk5uY3k3MVhydEJ0bE1jMlBHek9mWS90SkdqdmU4dFFYeFhmUFlSTXVVWW5sQ2lrZ0U3WXFXZEwzd01lWDJGN1NlbXEzZHArendjQit1OGtoUndYVTlCcnVZb1g4NXNxSWFGOUhQT2VxTGh3RDBiMXN5V0NsdkpSWWE1OVZ2RU91NDUxY0I4VnZrUDBUajI4TndFQ3hCTVNRZ2dsbFdFZGNSS2NBM3BUYUtRd1A0QXo3SndOcnd4Sm42blg4eXhQRTJYbmhycTBqQzYvcjVyWjFod1VoZ1JWczhqVjcwTnRjbWdjYyt4OHN6Z3Zxd3BCNG5FYWZpck9hUFF5bCtNS25kaWdWMHJ6YVhSVE95M3JYdXFocDRUQ2hjS0c1LytOempOVGVSWG16dnkzM2pkQ1R3aERnUHdhQ2lXS3BIOXMydmR2OU44ckZEKzEvdXBkOFhiU004V3dwSy9vRytVTWNUdkQycnYwQmUyVncvaWMzTkQzTnJrb25Xb2J0OFpheTNZeDR2Y3Y1THBLUkQyKzUvOTNLcVVkUWdnZm50Ly8vQU0vLy9qVHM0SDUrNTkvdkhhVHdnbkNkK1RuSDM5YVRIMUhlRThCalVFYXlOVUdiRTRWa3FYZUMvVnVWT0U0TG1TVXVST1Y3cEhSR2ViV1RQeVlVZXF6M0k2SFJZM2xnN2kzaVdGajNIV2RaYmdnMGZheVBWeXRUUHZocytxYTBBNTBZa2xuemIraDgzclJJK0w3aVZRZUVKMWwxMk5WbjRHK0I0TDNVS2pxQm56NlB1aDFGRkFVQmhwdVZMMkhWUnNxdEg4TWRlTktZdXB0MHcwZnYyQTdYRTI5ZmtQdlFmVmUrZlV0VWE2aGJTMkd4RGJIMXY4T3ZlN2x6ZDN0OHIzL3Z4TlBTQWdoTkRpMS9VN0MrNkdSSTZLZUVBMjlxbWJEcDZCMVZONkt5b3ZpOXlrdElUR1ZhaFdrRm1yb2s5WU8zQ3pQRGJ3aFBFeUczZzRhdWJyTUwzL3FQaXNVRDhSbnZLdlpkUW9laWszdUY4STlLTGhTbG5vQTFETlJDUkJkN2hYeWZleDVYc28xbjlEM3V0Q2p3M1kveUQxUDZEYndveGVrNVczd3RtbzRJTENkRXVBcmM0MzFRNSs1UGlOOVQ1OVEveDNvK3o5MXpIaThKVEphOTFWL04rNXhlWDVmUHRML054RWhJWVFRd2l0UUNCRWFwelNrZEtuUFE3TkFmMG5SS1FZWU1DOWNSYTlYUWVIaFphMzJBZjFFM2twZ1ZCNkNxcXhWNDFvYXgvcFI3NFlhekJkeVhuTTVxdjVVM2lYV1JhRnhLZmYvQS8yVmtiNmlYdWxMUFJTYU04UnpibEM3QWF3aVkySG5WZVJkb2I5c3IvYUYrUzZ0dmp2c004VzE3bytpWW8yN2xPOGp1S3RjWjAwYWQxSGY4dUFNZVpTR2hPN1kzMDU1L1Z2WjRmelFaTWYwRUVJSTRUU29sZ1U5eHF5b0d0UkRTK2JxOHNCazd1U2xYbDl0ZWpkMGo0ZXFITW80MVJueUtoeEhOMmxVdy9NQjZ5VHVLNnp6RVpqWFViV3JkWXpHTmowTVQraFdwcnJmbFBrVnRVSHNRb3JsVWR3d1ZJcGVuR3A1Vi8yb2w4WkQ1cDZ3RG5ueXNRSDZlU0N0Qlk3Y2k2UUxKbmorRTZSK1gxRnFGM1RzVkZ5cXQyYksrNmZvQ214ajNzbEtnTGFPNzdVNHhsc25JaVNFRUVJNEhUZ1RQQ2UwYUM2Y3dSK2FkZFk5UDJEWGpjWGI4L3BXNk1wWW4yamN1aUhkdW5hc0xBK1JJaDZxdzJPYWc4QXl6dVgzZTNTSjk5Nk95dlBnUXNySGo3a045SVQ0TlI0NnA0WS9FK1JwSlA5elV4NVhKQnNhdDBxQXNTNjJZOHI0OGo3OW5jK1F4ci91T3E3aWlmZjU2bHF0RUNwZHBjdmZLZjJiNFJpcDZCdnpFbmw0bEhyUXB1YWE2SGQ5WHZ6OStmMzZ5T0tEUklTRUVFSUlMMHhqaFN3MWpvNFpucUZHb0tMR21JWkI2UXd5ei9reExkdkwyc1hZY21OeUgxZ1d3MzhlR3VXMlp1RFZNNklyTmRHd2JvWHhUQkZPREZXaWNjcFZzajZqRzJQMWR2aG1rYXlUSzVDcHQ2RzFYNGZucTNqYnBzendldzVNNjMzVmQvcFJ2cXZYUTBPN1dLYlhONldOTHRLcXRyWkVjU1ZBOUx5L0d5cHlIRTJnNTdPanZmMDE0cU1qT1NFaGhCRENIa3pkUFg3b1BzT05zR01hTFo0WG9OOXBQUGtzY3BXRTdPTER2N2V1YmNiSld6dkdETSt4c2RTZDZOVTd3aVJ6RjF0NnIrYXlhRjZJaW9SV3UxcG9tSmp1eDZFaGF4b2l4WENyZjZBVFE3cUtGME82MkI0dW4xdjF4WjlueTV2aDdhMEVqWTZObCtXaFkzNy9PZFpKOGR4UFpXaTMrNmwvQTVWWFEzK3YranpVYjRYUGlNK3I4dDRzNURyZHpQSHA1dTcyQWFGSFJFZ0lJWVN3SS92dUo5TVFJaG9HUXZZUklwVkJPSFk5MEErbjJVVU1qYlYvYU1iZHYzdDRWMVZPZFI4OU9tN282OHcyOThpb3ZBSmFGZzFNb0M4V3ZNNmhsYUljbG5rdXY2dW5Tc2Y5RE90d3EydDBpeFlBM2NwYVhONzNDY0MvMEYrOWk5ZHArRk9yZmVvRlk1c28wdHlBVjhQY3ZSMnc3ejVXM3dINDIrYjNMK2h5WWR4ak1lZTlhLzA5ZVZ1QTdUd2g5Wng0T0JXdjFRMHErUXhhNzhrVDFrdnR4dlBSSUNJa2hCQkMySU5kUFNIVi9ZYm5Bb0RmV2MrRTNlcFpoczVZNzVMNE8yVGN1WWVoZGQ0Wkdxc0Yrc2J2WE5TVG94NE1laEIwazBNVkptNG9zMDg2K3cxcmsvZDdqZ2dCK3J1U2F4bmEvek9zZDFML08vcGVENkNmci9JRndQK2c4eXJvNmw3c2c0b0ZyWXU0Q0ZVUGpZZmg2V3B1RkVBdDBRTDBEZnRQbTg4UzYwVC9wWnpUbkpTNUlvVFBTd1VkeTNGQnJ0K3JFRGFPbVk2eGUwQjRiODliR1BFeFRrUklDQ0dFOEVxTWlBamZVSGd3cWJXeDl3Z05jUnE0dWhuZkZDcXZqRUxEemNXU3h1VzN2QmN0a2JLcmJhTDNlZjRFdzdFZTBPVlBQS0hiQVYzRG03d3ZXcTV2WUZpSnhEbUdjL1hNMUZEbjcvU0NjRldwYS9RTmFzN00vNFcxRVBIZHp5bHl1RnY3UGZvNUxWVklrZmFWcy85VlNCWHpZN1F0clpYUVBMeU1JbEhGSWNQTHVCTjlhNW5pQ2cwNzB5V1BXL2V5djh6TDhmQXFpaG5OQVZGaG93TC9FcHVOSmlOQXBwSEU5QkJDQ09HMHFNS241aHJtT3ZQTi8rdXJVSm1wN1duaHF4eEJmaDh5eHF1WjkxM2FWQm5GTk5yL2pyV2h5MFQwZjhsNUZYaStGSy9XY1ladFR3R3duWmpzZlozU3ArclphaG5xc2JsQ1A1RWIwaGZ1elA2QVRoQndCM1MybGNmcElYRlBrNFlTOGIzaDUxN0tZWnNlNUhxMjFmdGRQWDhkWjRvTUZRNnNaNGx0ejVDV01lWmQwNlR3MWpVcXVDanV2cUlmNnNZeWh2WkRvZGZtNGFQdTk3RXJFU0VoaEJEQ2FlQUdVMlhRTEFDc2Z2dmwxNFhPdHBvWFJBMU1HblJQOHBuYnBqRkI0VWFkaDd1MHZBdWVLekRGY0IveUhBRHI4QjdOQStFMS8wRzNDaE5uN1ZzclhDazBrcjB2UE1mMlZ3SkUyNmIzdHA3QmtBZm1HL3E3ckt1WGhIMzRDMTE0bElza05jcTFmYnhPdlVaWFVxZmV6L0s0Q3RlNW5kTjZsSmFJcmp3SzM2SExiZEdRckxGM3NDcTc5VjdwT0xOKzFuV090WmZKODRhNDFLK0g3SDNvZlQ3MkpTSWtoQkJDT0EwMFpsME5SYjhHd0ZwNDNOemRya2FXKzFYamNTZ1p1V0txNGFlQ3g0OTV5SkFManlsbGF3aVAzbE9ORVhjei95ZTY4QmpPMnRPbzF0bHRlZ2s4aEVqcjEvMUNMdVM3bHVNaFI1ckk3RUxFNjNBMGZ3ZFNKK3ZoVFAwRHVoQ3pyNXVmNnVsWXlmV3NYK3VnWU9GN3diQWtZTDFFTUQxSUMyeS9PeFJ6dnJFbTM0TktCTGhuNDh6T01TeE9qWDhkcjMyTWZmZDB1V2hmWWkyQTFCUEVNTVluckVWc1QxeEZmT3pQcm5HWElZUVFRdGlEa1lUMDF2NFlXemtIQTBKRTh3bW1HdjFWR1VQSDFUQjN3ODVudXIzdHJWQWRmcTltc04zb2QrSDJYMWp2YXE1ZW9LOVlld200bTdpV3B5dUFWVXYwcW9qUTNCb2ErcnBVcjk5Ym9XTlE5ZTlTNm1nbFoxOXZQcnAveUJkMHdrQ1QwWFdzZU8wQ2E0UDdlL1FGeU5ubStHZDBZb0JDaDJXb0lOUCtxUEhPNTE3dHJWR0ZnTFc4UmZzS0Q2VjZIaHE2eDdHL3dub01nQzQwNnhHU1N4WHhjVGdpUWtJSUlZUVRRY1JFeXhNQ0ZNYlpRR2pXTGxUR2NmVzc1Z2lvNGVpejR4Nk8xUklpUGl1dWhyb2FyRVBoVDlkWUc1ZmZvNThMOHg5MGhucExBTGhIWTRIKy9pSlg2Q2N3ODZNaFZoNXk1YUtrTW1CMW1kdEw2Ujl6UE9pdFlEN0lOZm9DZzk0ZUZ3b3FTTFEvK3AzQ1NyMGRERTk2d1BaZUkvcXN2V3hma2NySFV6MGZpbnROZGhYTUxmUmRVa0d1NDZINUtOZFllNVFvV2hjQWNITjNxd251NFFBa0hDdUVFRUo0WVVaeU9vQnRRMnhSbkFNd0dCYWlIb0twSzJMeGVnMkI4bEFqSHRmWjdLR1FKSjBCOS8wNHZOOXVxT280YURuQXRsZGpoZlVNUGowZ0YrZ25XVFBVeUQwWG5waXRZODR3SGZXQW5CVmxxRGRBeDl6NzRlVnIzOXpZcDloaERndkg3eTkwNFVJYVpzZjJjcytRYzNRaVk0WCtHS29IaVo0VW9DK3cySjlxdkNvdlJXV2theC9WYzlONkY0K1IyRjE1M05TVHBlUENQVmcwL3lQTDdSNkplRUpDQ0NHRVY2SVNJd1BoVlVCalJ0Mk5wTTM5TGtLMjdodW9RemVzcXp3SExHdGwxeXE2Q1IvTFZRTldWMFpTY2VNaFQyNjg4aDRLR2oydUgyN2l4ekpVdE5ENHJQYVE4TldqTkVTSy9kRFFKNDZSRy9oYXZuc0oyRStPd1lXYzAyVnZlZCtqM0UrQnhVVDdiekorOUtady93MFZLeG82eG1kemhTNy9nMlVURDVtcWhFZjFQaTJLNDM1TXZTbzZUc2RFNjlSM2ovZ3p5a2FEUnlZaUpJUVFRamhCR3Z0K3pER0sxSkFHNW5sRE5BbGNEV1kxUkt1OGxXckcvVktPZVQ2SHozeXJKNlRLWjlCd29NcXJvdjJsZ0tDQlRTT1Q0VTAwc3A5bnZORVhJMENYTitDaFdTcGl0RzU2VFdqUWEvOTBETmsyOTdwdzgwVDF0dkQ2ZTNUR004ZGlaUisyK1Flc2x5am1mVi9RN2FET3ZBZUttOC9vdkJnYVhxZWkwY1hJQXYwNmxaWXcwWE83Q3VSOVVVK2Y5a3VQeC9QeFFrU0VoQkJDQ0NmS0h2a2RibHdCN2RuczZqNmlZZ0wydlJWV3BKNklsdEZKQTVEZUJCVWZmbzE2RjlSTFVobjVYaGZEaVo3UWJZNUg4ZkFnZGZseXV4UUpXcjd2T2w4SktPWVVVQ1E5eWpsZXozSytrM2JRYThIMmF1aFl0VlR0QmZyR3UzbzRydERseEp4am5kdEFvVUV2eVVLT1ZXRnRMcjdVWTZRaGFmbys3U0tRS1F4M1diMXRGNFk4akt2czgvR3lKQ2NraEJCQ2VKKzBQQlhQRktGZkxpeDhwdi9KenZNN0RkZVdKOE56UFRqekQvUlhYS29FaDlhclA5MExvdEJRMXJLZTBIa0R0TjJhZitGZUlBM2Q4ZHdSUlRlSHBManhFREVWWmJ5TzlldGVMbDZHaDZxdHBEejNCckdNQzZ6RkJrTzZ1T0xURXQxZUkzcXZlN0EwWEluNUpRdDB5L2F5UGU2dG1pTWlMdEFKUXk0ejdDdHFUY0ZENE1id2RpUGk0M1dJQ0FraGhCRGVGMjVJNjA4QWsvWTRHRHZ2K1FLTDRyZ25yM3VaSG5La2Ric25BM2F0ZTNSYWhyQ0tKalZ3bVhmQmZBb2E0THhXZHlPSGZQY2xhaUgzcURlQzE2dFhnZmM5b3U5cDRFZnJxb1RoeGVaZURhWHljQ3oyZ1R1bWM0bGkzWGp3SGwxT2llYVR1TkFpS281VTBESFV6cGNwSGtNOUlHT2VPYjJIK1BqTXFiY256Qk4yOWJva0hDdUVFRUk0VVhZTXgxS3ZneHRaNVlackUrb1pDbVBSa0NsTlJIZGhvRHVZNnhLdVhyWWE1eDcyTTVUWFVua2ZnUDdlRmVyOW9KSHVxMGZSNElhMThWek9WL2tvRFBYU0pISWRJeFZsUTNrUVdyZjNUeFAzZlV6WVg0WmhjV1VzVFY1bldCcS9MNHY3SzQrQ2U2djAydForSmtONDJGNDFwb3FQcC81a3U4YnFmbjRHOFh5Y0J1ZmpsNFFRUWdqaE5majl6ei93ODQ4L3pSVWlsVkhmTEg5R1BXcDhPdTRGcUdieTFTdFJHWUdlWDFEVjFmSitlRHQ5TlN1L2wrMXh3ZWJoU1VTTmNCVXpMSi9uZmJmdk0yd2I4TlZ5eHQ0UEZ6anN6eVg2NFZLVjhVMHZEUE5ObUhQQ2ZnejFzL1Y4MlJmUDNhbUUwUlJVUUZWN2lveWhBdE5GVS9XZUxnRGc1dTUyK2Z1ZmY4VDdjU0lrSEN1RUVFSTRZV1o0SzRqbmNRQWpCdDVFVDhpUWdjcHJhRng2S0pVYTM1NEU3dCsxM0NGQk1kVG1WWEV0OTg5WW9lKzFxUHJpYmRHOU9sUkUwVHZDL0l5cUhIcGJQTnlwTlh1dnh5dXZnNCtKaXhnVmZlcUZVazlQVmMrWWNWNkpOdTNqVk9PK3VuOE83Z25SZDR6UFZzUFZrdk54b2xSSmF5R0VFRUk0TVRSK2ZXSXNleFcrVkJydUUzTkVwb2JiVkxQaWJBZG52YjFNRnlNK1U4NXlmY1BDRmlvWWZPOFJodjRzN1pqV1g2SHQ0VFZNcnI2VWE3UU4zcWVoc0RhdFI5RzlSaWg0dEQ0Zmo0WGRwNkZtTHBURzNnMFhzay8yNFFwZ0xhL1VNYWplRFI0SFpLV3RtN3ZiaEY2ZE1Na0pDU0dFRU40d0xTOUdZOVBES1RQZUxYUUd2akpnV2RkUStKRWE0eDVPNU8zU25BSCtEdlNONjFZN2dmNnNQYjl6MVNuVy9XajNUQkZqT2hOL2hYNkMreExiWWtQcjg5bjdzVkFzbmxNQnhuMU9nUFpTd2Y1c0tGdzA5OElOZUIwRG42VDJPcW8yVHVtTE0rZmFvVEswL1dmSVJvTnZnb2lRRUVJSTRZMmpZcU15dnZiWWI0U29aNEZVUW9DckhtbXl0ODlZVnd3SkNzNytxN0hwM2dzOXA4Wm9GWlkxbEpzeTFNN0thL0FkdWxXcmxtaUhKV203dk4xRDlmQmU3bnpPOC9ScStCNGZYbzhLZzB0MGUzNm9SMmRLU05aUUlyM1d6MnZjZzlMcWt5YjdQeFRYVFdVQllIRnpkN3ZMRXIvaGxVaGllZ2doaFBERytmM1BQNTZUeTVsczd1ZDNTSEIzMUdOUkdheTZoS3NhdGxYSXpCelVrNkNHODVCblJ2ZXk0SEs4TFFGU3JWZzFGRGJsNTdROVk2RlhReDZEbGdoZ1ArblJPRWMvMlp6MzYyYUhXajVYeWJyYW5HTVplbDlWdDN0emhzYUYxL2luVlJaWDc2S3dtaUpVQjBuWTFkc2pucEFRUWdqaERWTjVPVnFoS0FmeWlBeFJlUjkyVFVEV09xdWQyelhVeXowaGJnVDdUdXNMMU1MQjYxV3F1bG0yaGtoVm9rdjNJUEc2eHNaRmMxcTAzWnJmb2YyOVJPY2xVYS9RSmZyUFFnMS9YOTNMeDlzRllJWFdwWjRiZW9qMFdlbkdpM3Z0bEo2d3E3ZExWc2NLSVlRUTNpQUhFQlNUa2Z5U2xxSHVvVTV1NE84RERXQVZPQzF2QkwrcktOQWNEdmVXdUdCUy9EanIxWHdKR3RacVVMdjRjUS9DSEFHaTExQkU2T2FBTHNCMEx4Sit2OEE2Yk95YlhLdEw5bXFJbHU3TDRrSnk3Rm02TjBkWDAvTHdMQlVsT3hIeDhmYUpKeVNFRUVKNFE0eUpqekhqYks1NG1aaGpNaFJLTk50WWJDeEwzQW9QY3E4RXFVSzBGbmJkMkF5LzE2TWVBcDNCNTh3K3hRL1BuVmtabGVFOU5qNnMrd0w5elJXci9BZjJUOE95Z0M2Qi9nbHJNYUlpNUZ6dVV3R2lTZlpUY2tLOHZib2g1RnpoMVNUaTQvMlFuSkFRUWdqaGpiQ3ZBQUV3S3pla1ZkNkJja3lhNkNhS1JWMXE0UHBzZmVWeFdCWFhlRGdXQnU1dGhaYTVjT0UrSkJmb2k0R2h2SXVwUmoyRmh5YjhBN1duUWIwaEZCaE1ubGN2aXZaanlNdTFhNjZGQ2p3dGI4cDdzeFZTZDNOM3U2cnluY0xiSmZ1RWhCQkNDRytFUTh3Q1R5M2p0V2FjcTNybG1Bb0lOY1pkS0xSbTdqVVhRc084OUtQbE9TM0Rlb1V1UjRQbkx0QlBpTmN3S2RqOWJuUlhvc3Y3cGIrclo0ZWhUcHIvd21OVmlOVVNYYUo3dFovTExtSnpMR3lMNVZZZU5lYVRYQUk0dTdtN1hjWDc4VDVKT0ZZSUlZVHdCbkd2eUJ4RGJXaHZrWDNhc0M5RDlXL3FjdVBjUTV4YStSMTZqK1pQcVBIdlJyNkdJYlhLOVhwVmVGd0N1TWUySU5LNnhzclRmdnI1TTd2dWVaTSt1WWVlR0EreGNxcGNGNkFMNFhLdno5ZzRWNHpsM2pCNS9oekF3ODNkN2YyTXNzTWJKSW5wSVlRUXdodmt0V2VIcHdpUXhvYUpaTXNvYmUxM0lzYzF0RW5EaElaeVZQUzdHdWpFRTdLQmZvNEhCVU1sZUtwd0xvWmtlZjN1eldBOWJFTmxuTGRDb2hoaXhmcDRqUDFnWFkvb3dzTmFZVlVxUUtwTkNabTQvb2h0ZHNyNVFUMEp6alovZnUxM083d015UWtKSVlRUVBoaXRuSTdXUGlOenlyaTV1MTM5L09OUEN4cVNqZHlSb2ZDajUvSi8rK1hYUlpFUHdwKytrdE9RRWUvM1YzVzJRcU80b1o2M2w1NEdYcU5oVnpUWTNRdWk0Vk1VQjU2cjRuV29ONFppNFJ6Ylk4ZHlWRHhkb2R2WWNDajVYdXZ4UEJnWGFIcFB4ZEE1dllhc0FPRG03bmI1KzU5L1BDYnY0K09RY0t3UVFnamhBL0xiTDc4dURqWGp6TExvc2ZCeUc2dGNWY2J2VkR4QnUyTE14dkdWcXp3MHk0M3BwZnhrdlZ4ZFNzT3Jub3A3MVJzQ3JNVUJ3Nk44NDBIZXF3bm02b1hodVZZNEZzODlvdHVjY01vZUgxVzRWUlh5cHVlOVBOMHdjZElTdlBGNmZGd2lRa0lJSVlSd2NGeVlHRDdyUDFlSWJNMmtqMXlqMTFZZUdJWTNxUUd0bmdkTk92ZGQyN1VQYnN5clZ3TG83eFQraExVQWVTajY0T0ZSdmlLVy8yU0N1VytjQ0xTWHlHMk5vWHRCVnNVMWZyKzJXMFdMbC92Y3IreHdIaEtPRlVJSUlZU0Q4L09QUDNrb2xlS2VCMkIrYnNGUWFOWFFNYTlQbDc4Rk9xT2RuZ1ZOMHE2OEFwV0hvVEsrVjNZOWR6WFhkbW1ZbHE1bXhXc29ZTmdlelRGaGVOaTUzS3R0cllRRysrL0hmSnpjTTlJcVI5c1B1KzdaUXhQdlJ3Q1NtQjVDQ0NHRWw2WGxvWmlMZWlKYUJ2WlErWDd2dythbkxuYzdkRy9sWGFqcXBhanhGYXBhQnIyR21qM2F0ZXFob1NoaDJCWER0MVE0dFVLaVZGajQwcjNlSHhVZ2xSZEYyd0owRTl3ci9kemMzVmFKN2VFRGszMUNRZ2doaEhCd0JtYTczU1BRV2paMkNtcmN0K29CdHIwdW5rK3hzazlWemhLZEtHQ1ovTmxLWEhlUjRVbm12TzljZm1xZWlJb0RDZzF0azRvU2pxWG1wanozeFo1SDFYYy83Z3dsL2pONS94TzJFKzZUOXhGSzRna0pJWVFRd212UU0xUVBXT1pZUGU3RkFQcGk1cXc0NXJ1TWUzMjh6bjhDOVpMQ1FKZG5jaTdYZVVLM3R0bnpXSFFwWVBWK3dPdWlDT0RQMzM3NVZVK1BoY08xdkNMOGVTSGZ2MjNhc2tUQ3JzSUlTVXdQSVlRUXd0RVlTRXduaHpCVVcvYU1pZ0VYSWEzOGtHcnZqcFpZcWp3ZWxkaHhrYU01dVM1UU5NRmRRNlhPR3Q5NUxjT3llbTF0Q1lFNSs3ZllPZlg4MEFPaW5wZUhKSjJIS1VTRWhCQkNDT0dvRkFhdmV3MmNTY25xeGVwYlEyS2t1cVlTS0pvcjBTcERhZVdsVkRranV1ZUk1bjVvZUZWbHdMdnh2MExmdzZMNUl6M0UrN0hRMzRrdTFUeXlBYVdHa0tuMzQySFRobVU4SDJFT0VTRWhoQkJDT0JvTkFRSU1oMGNOTW5FZkVxWEtaNml1MWJZTnJYZzFob2RrVVRTY1lidi9MbGIwdUJyK3pCdlJ4SFpQZkg5bUgwR3dHVThQTmFQbmcxNGNob0JGZklTZFNFNUlDQ0dFRUk1RzRhM1EwS2RENTRRNExmSFJIamxwWGdBQUFrdEpSRUZVOHNKTXlZdVlVMjhWOWxVSkRkajVpbVZ4YmUvN0ljVEFnTmRLMjNHR3RmaFlJb1FkaVFnSklZUVF3bXVnZVJLVGpPY0pSbmJMSTZKaW9QSkFlQm16MmpVQkZ4MVZxRlpWRjhlSUlWZTZDbGN2aVgxZkFWS0lqeXFFN1JGclQ4aDl2QjloWHlKQ1FnZ2hoSEJVR3JrYlEwYnNyZ0pBUFF0VlRzZFEzb1plTjV1QjNlRTlMR3V1d0trUzZuVkR4YjJabUF2Q1hjNlRkQjRPUW5KQ1FnZ2hoSEJVUmxaaXFrS1NCaG5JQ1ptVTBJNXQrNmVWSEwrMXlsVFZsOG9yTUdMWXorVlpDTWd4L3I0YTgwcG84bm5yUEw5WC9ZelhJeHlEZUVKQ0NDR0VjRlFHdkFUQVljT3g1bmdYSnUyUHNZc0JQbFdBNkxpTXJGQlZlVkMyZGtOdnJZREZjMVA2d3VzaVBNS3hpU2NraEJCQ0NFZG54MzBwdHRoaDM0dWR5eHlqWmRnUHRXV3FFSmhRL2FCNDAzcUd4SW5WdDhBRXowb0loeUFpSklRUVFnZ3Z3aUZDbE1abStYZXA0NUJKM1dQdDJNZXpZaDZscGdpWld3ZVg1TTBtZytFbGlRZ0pJWVFRd290eExJL0ZydVVlZWxuYmwvQWlqUFYxeWppTmJXSVl3ckdKQ0FraGhCRENxMEpQeHI1aFRDeHJuN2FjdWpGK0FBSHk3RUU1OWI2RzkwMFMwME1JSVlUd3F0QVlIZ3RsbXBwY1BWYlBrQ0cvYngzSDVnQTVNY243Q0NkQlJFZ0lJWVFRVG9vcXFYb2ZjVERtWlhrUFRCMmI3SEllVG9WMy9RY1pRZ2doaEk5TEsxZGppaUNKcHlDRTR4SVJFa0lJSVlSM3gxQ3krQnl2U01SSUNNZmg3TFViRUVJSUlZUndhSVk4SDVxREVwRVJ3dXNRVDBnSUlZUVFQanlIV0prcmhEQ2RlRUpDQ0NHRUVCcEVnSVFRUWdnaGhCQ093bnRmUFN1RVUrUC9BUUxNUDlBVWVQbmdBQUFBQUVsRlRrU3VRbUNDIi8+PGltYWdlIGlkPSJfSW1hZ2U5IiB3aWR0aD0iMTkyMHB4IiBoZWlnaHQ9IjM2MnB4IiB4bGluazpocmVmPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQjRBQUFBRnFDQVlBQUFEN3JVY1lBQUFBQ1hCSVdYTUFBQTdFQUFBT3hBR1ZLdzRiQUFBZ0FFbEVRVlI0bk95OVczTmthWGFlOTJRQ0NTU0FBcXFxcS9vODAzUGtjSVpIbWFSb1NpSWhXVlJJWWN1Mnd1RlFLQnpoUTVUL0FhNXdXWkdYdU1KUFNQOEFoOFBoQ05vT1dwYkpORU9rWkE1RkRUbERUYytwcDZkN3VzNVZRT0d3a1VkZnJQWG10M0pqWnlLQlFuVlZkWDl2QkFKQTV0N2YvczU3Ny9XdWQ2MGFHUmtaR1JrWkdSa1pHUm5QRloydDdaci9XUU5HbTdzN285TDNEZjl1QWVqN3h3My91d2JVL1hleHVic3ovRlFxbmZHcElNd05BTXB6SXlNakl5TWpJeU1qSXlNakl5TWpJK084V0h6UkZjakl5TWpJeU1qSXlNaDQyZERaMnE1ZEpoRVh5anBWcGhPQU5XQUlEUHozZ3YrR1JBenJ1SXpQRURaM2QwWmxFamdqSXlNakl5TWpJeU1qSXlNakl5UGpXWkFORFJrWkdSa1pHUmtaR1o5TFZKRzhnWXdGNERMVnR0TklaYjltSFNOODYvNXhIU09ERy83M0VrWWVGNWdxZUFUVVZMOHFBakVyU2MrSHJNVE55TWpJeU1qSXlNakl5TWpJeU1qNHJLQis5aUVaR1JrWkdSa1pHUmtabnkxMHRyWVhnTVhPMXZaaVoydDd5VCtUMG5ZQmUwNnVkN2EyRnk1TG5Sa0p4YzdXZHQzcndPYnV6bWh6ZDJmZzMrdVlvZjhkbGNNaWlpa2RLMHpVTTZ0S0x3UTVBTlJpL3ozdnZsVDU4WGNldjR5TWpJeU1qSXlNakl5TWpJeU1qSXNpRThBWkdSa1pHUmtaR1JlQUNKb3lTZk9zeEkwVGc1bjRjY1IrUGsrL3pISHNJb2xBWFF6cTNBR0phTlhQczQ1bnc0bmt4VkN2RVNuRTh4aXU2QjBDUTY5UEgrZ0JYZis4aGhIVFl6WHhEUFZ2SmhIUGoxcnBCM2orYW1DVlgvNmRrZkc4a0owTU1qSXlNakl5TWpJeU1qSXlQdHM0ZHc3Z290MWFhTjY2UFhnZWxjbkl5TWpJeU1qSWVKa2c0M2lKYUt1VGxKbVJ6QnZqR2NrYjVYcnRWdFNuRG94S1N0SXpjOVdXMnpFdkxwb0hkOWIxS2dpSEdxSC9LczZwTTZtQ25lZjZDMENqczdXOUNCeE5DZU04d3A2RkY0R1RFdkhXRGVYVUxpa01kR1Y0NFJsOVhQUHhIbTd1N3ZTQnZ2Ky80SFduczdXdGN2VnNQc0lkUER0YjI4UExERi85ZVlEbjR0VzZybEpZZityMWVaSFh6L2hjb081emZqenY4N3pMeU1qSXlNakl5TWpJeU1qNGJPRGNCSEFtZnpNeU1qSXlNakplRlpUSnRYTVNreUtFNHVjaTRHQXlWTy9FT2M5YWIxeTVXYXI3c2wvN2hFVDR6WFc5aTlicE9SSUI5YzNkbllFSWJhWVE2ZUd6dXBPZzgwSkVmY3l0T3pFZk5uZDN4aVR2NXU1TzVmUHR0TS9QZzZEb3JacVBkWkpLZDFEVjM2WFBCdGdjV1BTMmFlN3A3d2tIaGM3V2RpWVJTempMcVNHVDVobWZGL2o5RFpManlDSzJIL1V1WSsvTHlNakl5TWpJeU1qSXlNakllTEhJSVo4eU1qSXlNakl5UGxNSUtsMWhKRktuU2tFYlBoOFRaNXU3TzhOUXp0QU41U0xlSWdrTUhwNzNlUk50cm1hdEFmMFhRZW9GOWVuNCtpRm5Ma3doTVAwNDFYMVFKdGd1cWpLZW83N0wyRmlLNkczNlYvMXprc25QVWdmbCtLMGtVMEtmMW9CZVJiOHVZbk5MODFmenIrSG45RW5Fci9wUWZ3LzgvT0htN2s0dmxEbWU0NkVPV2ZXWGtmRXA0M250ZmZOZXUvUlJrN1NYbjJ6dTd2USs1U3BsWkdSa1pHUmtaR1JrWkdSa1hETE9yUURPeU1qSXlNakl5SGlScU1wOVdqS2l4L3lkQTB3SnFlT21xZnZxOGJ6TzFuWVBXTWFNNGtQL2YwQlNTalg4UjBieWZqQ29OekF5NzFKSnhubkx1d3hTd1lsTEVlSkRVcmhrRWV0cWR5U0FkVndWUmpxdXM3VTlWdk1HQXZUU3lZYk4zWjBUL1IzSXp5SFdqdWRPQUFlbmdsbEtPczJaWWNVY2hsVGZycmNoa3JzYWkzamVLSHl2L01IRDBNODZSK0dreDlmS2F1R01qRThIa1h4OUVTUndjRzZLZThBaWFZK2NKNldBN3BrNTFQeExqampmOGg2ZmtaR1JrWkdSa1pHUjhmbENWZ0JuWkdSa1pHUmtQSGNFOG1wQ1pYdUJjaFNtc3VlcTNBYVdvN1ZiT202c3ZDd1JaMUhSTzFZK0JzSXpIcnVLa2JsRGpFZzc4WjlGNElyL2pJQ0hHSUc1aXBIR2RlQVFPSHdCaHYxRnJEOHVUS2g2WDZ3eStaeDRoUFhERXRaLzNYQzhWS1p6aldjRmdkL0FsTUdEZUl4ZnE3YTV1MU04UTF0RS9HcmVqSUJpMXJoY0lvRytpTFd0b0pvRVhzQWNEQWFZeXZmVU1UNUhyMkR6RG13TUJreU9qVUpjYTMwTktCSEtZZDFvamc5SVJNK0YxbUpHUnNiRjhESVFjcjV2UTRvMG9JZ0JJeXh2K3NpUDBSNFdJd2pFRVBRalN2dDN4c3VGc3RvN2s4QVpHUmtaR1JrWkdSa1pueDlrQlhCR1JrWkd4aXVEb3QyS0tyNVI4OWJ0a1g5Rzg5YnRiTkI2ZFZESFZMbm5DanNiUXpLSGoydVl3ckZNS2taU0t5cWQ2bjc4T0d5dS95M2xwTWpDSnJEdTV6ekdDTjYrRzhYN0pBSk5CblA4LzFXZ1N3am5lOW1ZRmJMM1BLcmp6dGIyQ21iY2Yxb3FTNnJmcUJJVHNYaFN2dTZzYStvYW03czcrK0hqZW1kck81SUl1bDdFa3RkTml1R0xPQXZVTVBLMGpvM2ZNWk9odTZ2T3VZck5pYUxzVkhCT2pMQjVJTUpXSkVzUG0xc3g3N0hVdkdVQ0hGTGZyMklrY0QvMlJjbXdIK2V4U0dnUndScXo2T2h3d3VsK3o4akllQTRvUjZ0NDBTUmMyTGY3Zms4YlludVduS0pxd0pwLzNzQ2NtNkx6U0h3ZVV3U0JUQUsvaEhqUmN5MGpJeU1qSXlNakl5TWo0OFVoSzRBek1qSXlQbWNvMnEwR01HemV1djNLR2VxYzdGMGloVFlka3lqTlc3Y3prZkVwWWg2VjVEU1ZreFNqVENFeHA1WHRhdDhsekFEZGs3RTU1RVhWbkJoZnM2UUFoWlNIdGw4MnlQdi9JblMvQUt6NGVmY3dzcXhIVWtMVk1ZUDRFQ1pDSkY4RDdqMnZITE5PNnQzRVZLeDd6MUJPRFhnZDY4dkRLcFZ0R0w4Rlp1VDNQZU1hWDhERzVmSG03azRSVkdjYUQ1R2pEYXlQQno1dVVsSVBzYkcrQ0FHOFNuSjI3TTZqSk81c2JWL3orbmFma1FDT1paYkRxNjVqOHlqT25TR3A3Zkg0SHFsL2RFNTVQWWtrSGxhUXczSVdHSG9PNUdVdjc1QlBJVzkxUmthRzRVWG0rNTBGM3lkV3NmMmdWL3BPOXpnNTB3eEo5MEZCOStRUkx5Zy9mVVpHUmtaR1JrWkdSa1pHUmtZMTZtY2ZrcEdSa1pIeFdVRFJidFdMZHVzS1NYMzJxcUlXZmpkSUtzS01DNkFjR25CZXpHUGtuVWJ1a3RTUUN5RVBLWjJ0N2JxclBhZVZMVkoxRlZqdGJHM1hRbmpuQlN4Y2NGbGRKWElzcW5SanlPZTY2ckM1dXpQYTNOMVI3dDRqek1oZFlDcW9xOWg4VzhLSVlUQzFWQTBqMVJhQjY4dzVGNzN1ZGZYL09jWkJmYmQ0MGJHRGNmK004OGhXbGVYSHFHOVg0bGpOaVJyV2o4ZVk2bHBoUmtVb1FDSkJwWEpkOW11ZllDVDNTWm44RGVOK0ZrNndNUko1UHcrTzhieTVjeDUvSnJ3ZnBScXYrVFhxWGpmTm9UcVdlN3FPelMrUjF6bzNrdEhqT1J2R1pNS2hKNUJOVXZ0QzZ1cyt6MUdobnBHUk1ZbVhuUHlOWWVFbjRQdHZEOXMvRC8zM0FMdlh5bmxuQ2R1M0c2U29EYlVMM0M4eU1qSXlNakl5TWpJeU1qSXlMaG41eFN3akl5UGpGWUZDSFYvZ3ZKV2kzWG9OSTZjYXdNa3JySmFWZ1hHRmxNOFNYbTFDKzRYaWVSdWxTK3JhU0lhTkNJcEZKMlFiVkJDb3BYTUxqQXdiT0dFckl2TUVJeG1YTUlOMFJDOFlzYU5hVjhSd3M3TzF2VlFpRlI4QSsxaCszMk5TZUdqbHdWM0NsSndLTWR6dzg3ckF0YzdXOXBVNVNNb1lhbk9DMUp4QmN2YTlibzh2WWV6MnNQYWRUTHVtajA4WE9LNGdZaGRtR2ZrM2QzZUdtN3M3NnI5cm1PTDRHa1p1cm9YZmE2U3hXQWpuVDdUUDYzY0ZlQTI0MHRuYWJnUkZNYVZqbDBqNWRmdlRRcE42bWZHYUo1dTdPOFZsSzdpOUxTSmZwWjViSXlseXh3NEovbmZNV2EwMU13eWs3cUpDZ2VQektJNVA2THUrNThIVzNEM0NRbjVyM1UyTTkxbmsrck00SFdSa2ZCN3hzcEsvamliMlBOWDNLQUdOenRiMnRiZ253bmcvNlpMdWhmVVF5VU5PUFQyU2s5YUNINVAzaTR5TWpJeU1qSXlNakl5TWpCZUkvRktXa1pHUjhZSlJ0RnUxZWZMWEZ1MVdvM25yOXJ3cU5oSEdpeGhSZFExNGhJY1RiZDY2ZlhMUityNG9GTzNXQXE3OEJKNlExR3pEblAvMzVZWVRWUXRNRWxybHZLLzZiaWhTMUg4djRJcmJ6ZDJkZ3pPdW96ay9DQVJYM1Qvcmxjam9HQnBYWkhEUHJ6TXFsYm5xOVJ0Z1J2RHIvdmNHeWZqOUNDT0VUNEFiR01uM21PU3NzRWNLV1Q0T1Z4M3FKSVA3VUgzbHhGME5NOUkzTVBMdXF0Zm5ZNmFFMEQ0UHZIOUVObzVEcWxmbG1hMEk0MzNWL3owVlFqcU1YdzBMV1MyRm1jSTZxdzhnNWI4ZFlFVHpLZkxWNjNrVjYwdVJEcHBEWFZjTTYxZzVFNGowTEVyOUhCWElBS3RuemEzTFJNaE52SUsxNHltVHhJbkMzSGVaZEpLUTJuMmNrM2tHc1YzSFZYcCtuaHdVeHVjRU5mNm85TmtzOWY0WUx6R3BsWkdSY1FaOGo0aE9WMzFzWDFyRG5FVDJTOGNySi9CQ09FZFJIZVJncGYxSWUrd3c3eE1aR1JrWkdSa1pHUmtaR1JrdkRwa0F6c2pJdURES3hHWFJidFZmWVdYcGMwZUZnbGZFeTNDZWZxdm83eVdBNXEzYnAvSlVCdkpYcEk0SXVCT2c5bW1Na3hPMmwwYk9lbm5YTU1QaWswejZQaHRtRVQzUDRUcDFraXBYcE4yWTZDUXBIRVZTOVp3OHJKUEl6enB3VU01Uk9PV2FJbjBIL2x2NVphZm1Kd3prbHVvUTg3T0t0RlJlWVlYb1hjRVVuSGV3dGJ6azE1SHlkQjhqaVVmQWdkZGwxY3M3d29uSm9PUmNKT1dzRmNsWkI5N3o2M3dFdk9YSEh2bnZVNGI2T2ZwSFJLTGFwdllOdy8vOUV1RzdRRERtZXo3bXE2ckw1dTdPc1gvZXhOYnBDZkRFMjNlZHBPNWR4SWpOTWVIdWZTNUNWd3F6cXV0ZjgzK1B3M2s2UnptbFJaWXVrWWlLWTYvSElrYlNON0N4VVoxNjg4eXJzeERJOUFVbVExM1hJbEViaUpRVnI4TWhhYTVDVWdxWGMvckdjT2I2WEcwY2xraGM1UkErSWR4cktzb2JPejlNSTVOTGJSelBuVXpzWkdTOGVpZzUvU3lVZml0SCthbDdyZStmaW5nUkkyajBTUHZNT01TOEh6Tzg3R2dLR1JrWkdSa1pHUmtaR1JrWkdmT2pNbXhlUmtiR1p3dE9uTW5BTGtVb0dDRlJBd1lYSk5QcVRqUXVlYm4xb3QzYXk4VGNKTHlQb21wTHhqTVJCY2RGdTlVRm1OVjNKZkkza2pmVGp1K0Y0NGZoLzVIS0tGK3ZhTGV1azhpSUM1TzNSYnZWeEFpckkrYk12Um5yRThueVVBZTE5M2hhL1RQbVF6blVNRHcvSWppb1FHVXNqdVJqajhudzNlTmN2T0gvSVdHdkVnRlZEa2RjUWdNallZOUl4T0pNY2l2VVU5ZGR3QXpadWw1VXpZdWNsZXIxTlZLKzJUVnNmZDkxZGZGZVNYMjY0bVYzZ1laL3RvUVJrdmo1L1hDTkhpbHZiQTlURlRkSlN0amxxaENqSXBXbmZMN3FaVHdoalluQ0VQZEtaR1VkVzhzYXI0SDNWNit6dGYzSS80NEtWU25FVm9GZVoydjdrRVR1SzRUM2diZFovYTB4R3Y5ZHJyY3JXZmRJWktYVTRZMVMvZVFRMHlPRmsxN3ViRzJma0FodU9SOGNWYWlhYTdQSVlDZi9SZTRPS3RhTjVyYm0rUklXcnJrZ0ViQTFFa21pK29zVUYzazg4dk82cGJrK3p0VVo1bXlEVW81Z1hVTWgwcWVFb1pYenhabkVyK0RYak8xVXY3ek1ZVzR6TWpLWWNNZ2E1NUxINzExaEh6K2dPcTFHakdBaHNqamVQd3BTbnZQNGs1R1JrWkdSa1pHUmtaR1JrZkdDa0FuZ2pNODlBdEUwVlJWWmxYdjFWU0dlblB4OUIxTk9QY0Z5TUM1aHhNajNjTU5OMFc2ZG13UnUzcm85Q0gwamc1RklrM25yVi9PeW5xay9SUWErVEtSZzBXN0pDQzlqbTVSYWl4Z0oxTUR6cHAwVmtybmNUOTdXVThmRTcrTjNaL1dKbDc5QUNtMWI0UFBDejUrYklOQWwvWGMvOU1NcFF0bS9rL0p4dVdpM3JnRDNwcXpGRzlnOFhtRXlMMnZHK1ZGbGxIMHVmUmxJVlJGeTR6MjNLc3d3d1dIQWxVTVQrMGxuYTF2aG1LVTRGUkVhVmUvNGVmMUF2cDVwaUhaeXEwOGkwUFJUbm85U1MrbWFNWVR5RXJBb0VqV1NZcHU3TzEwblRhVm8zc0FVVlNkZXhsV01RSzFoZVg3VkZ4K0VhejBrcWJRYXVNbzI5TThDdHMrdllNUmZIeU9qdFlhWC9Eb0tNL3pJeTE0bTVYR01mVExzYkczSDBNMFJTekgwY3lBSDQ1Z3RNRG4yaDA3bUZwUkl4TE1JeExLU3pOczA4RGt4TGl1UW9ocHpqWlZJNkFHbnlkODYzdmVkcmUyanpkMmRVNUVWdkcvSFpWZUVqUjV0N3U3MFEvaHJPZnpJNldyZ1JIUjBmcWlSU0g1SXhIQTVUTFhhTVE3VFhRNEpYWnJqbzlMNTljN1c5cWs4d1oydDdhbXErR2tJNHp5QlR5dXFRRVpHeG9VUjcydHlQaEVKTEF5QWpjN1c5cUdjWVh4dEsrSUZKUEkzUm5FNExFVWhLS2Q1eU1qSXlNakl5TWpJeU1qSXlQaVVrUW5nakhPamFMY1VWckJzbUJ3Q28vUGtLSjNqV3RHSUszSnhtV1R3ckdHcWx5NUdvcDJYcENJb0R1TTFKd2l6Q3VWbHJXaTM0cm1MSkxWaitmaVhJU3p5RWtZQ3Y0MHAxUVlZb1REdzd6YUFRZEZ1SFdIRzUxTmtzTGR4VUdxYlFxVWVoOC9QRmVydEVvamZCcTRrSzlxdG52L3U0NG9ta2NMejFpR092NU9UWVBPNjNCOWpFc3VQSDFaODMyUlNhYkUwNWFjQi9HUkdHOWR3STUyMzdZbGZyMDlTdU9IWE82NG9ZbXE3dlkzcjJCaDJpM2JyTHBORWllYjRTRzEwcDRMNnRMWHVvYWxQbU16M3VlRGY2VENSSWlLaDlQOXJ3UDBwUlA2NkgvTUVPSGtKMXRWTGp6a0lHYzNqNTkyWFVrd0tkV0RvWVlTSDRidWxjUHdwZUh1a2p0WC9TNkdNTVNsS2llQ2JFZnA1bkh0M2MzZEhCTm5RUXdncm4zQjVycCtRaUYrUm00Vi9QZ1JHbmEzdGhhcVF1cHU3TzBWbmE3dUhPVFBvR3FQd3Z3aG5PVkdJSFB5Szk4dUhUcUJLTVZyR3lNOWQ4ZTlWVjlWRkRoNURMUGNzcEh0cGxhS1ZTSWFXY3Z0T2hCUDJ2anZBOWl0ZFc5Y3RDSVNBWCtkU2lNTE4zWjJqenRaMkk0eVRvaXhJY2F4N1ZRM1B4VHhGdVJzSi9hcnJESndNMS81WS9uNVUrcTE1Rk1NNzY5cUR6dGIyY0hOMzV5U1FLd3A5M1lXazRnN0VibFNveDhnSTJtTmpLR2VwNVNOeFBiWE81MFZGUHUxaG1CY1pHUmt2R1FJcEM3WWZhSDh1UjFzWVl2ZlFDS1ZqMEw3ZUk5MnZ0QjlkOGZ1U3lHVGRXOC85YnBhUmtaR1JrWkdSa1pHUmtaRnhPZmpNRThCQjFWYVpZek9RT0ZHcEI2ZEQrTW5UdVErdmp2cnpzaENJc0N2K3MwWXlxSUwxMFNQZ29HaTNobFFyL2NaaFB3TXBOLzUveXFXWE1lSnlEVE5VTjRGM1NjYUdCLzc3QkNPTkJzRCtSWWloVUllb0dKcDJYQ1FNVjRBdituay93WWhVTU1OSUZ4Z1Y3ZFppODlidFR6MEhsby9iS2padk43RCt1MDh5NG9DMVpSa2pUaDVqUnVpVm90MzZHUllLV0d0bzBjdGN4SEpROWpHbFpsa0I5V2xqbVVTaXlJQ3VVS3c5S1ZoSlpHWWMxeEZPNXNPa1dzcm5jVlF3aUFqVnZKVkJYWVFVNGR4SUpJaWdYdkdmU1B4S2VmRm0wVzdkYWQ2NmZWd3FRL2txMzhQV2w1U0J4MFc3MVhXSGg3NGZYL2UybkZjQnZRQjhEZml4K3N6cnVVRlNHb3I0RmFraTBuYWFzOGNDTnNmV01iTGxxYmRWS2oyRm5mMEh3SWZZUE90aXFzU2ZFL2FJVWxzV3ZFNTdMMkk5dlFvb0U3NVY1RTdKQ0R6Q2xJelBVLzByY21qb3hHY05KOEdjQUY0bXFSNFBtU1FWYTBEZGliZWExelVxTTBVQUgzcEk0bjFzL3A3bkhqQWtxZkhMbjllb0RwODd4SWhGT1YySUJCYngrUlM0M3RuYUhtSDdxa2paRFQvK0tiWlByZnIzUjlnNlZJamlycGV2RU9vM3ZGMEgzaStMd0p2NG12RXd3VEVQc0FoZWxTRkNVWkVJUkZhUFNEa2RwK2JCVmM3SWtycUxRRlNPbjdXd3NWd21HZjNyWHZjalArZTVPQnVVNnE3OVdUbVcrOWplMVQ4anorMkNIek0xSW9OL2R6SVAwZW45SnFjVlNBNE82ck5tWjJ0YmRWUU96VmkvK0Z3eThqVTBkdHJ3ODJJSTFnWVdkbnQ4bi9LMjF5amwvNTFSNXpMSlBEUFhyOGpzY0c3ZGllM1AxWE55UnNZcmd1aEFPOFRmVStaY3J3cFAzOFh1MWJwL24vaVBuQlZyMkQxbW5ESUFVc1NDNTNVUHlNakl5TWpJeU1qSXlNakl5RGlOQzN2cFAyOVY0NnlRb2Vjb1k1bVVKdzhzdjE2WkFKTGliSlZFeHNTWFk2bGlUakNqN1QwUzJTUEY2eXYzSWhzSXFtbHpRT1NnRElxcm1KSDRLcVpTa3NvcUh2OWR6SkI5ZjRZeVVJb2NxVlZxUUwrc21BVVdYWTI0Z28zaEtqWUdONERmOTBPZllPUVIvdmt5Wm1UK0FmQ1hYdTZwRUk3VEVFSUlUMVY5eG1OSkJ0ZGZCMzRMTTNUOFMyeWVMQUcvUzFLaWlVQzhDM3d2RW4zUEUwVzdwWEc3UWxLWDNmTy91eGlac0lhTjV5cG1vTzlqQk84UjhFT3NuZGV3dFhIZ1pkV3dzZjc1ODJxTEszdnJ6VnUzVDhxNVlVc09CRzlpZmF1OGswMlNNYXBIVWd2R1VIUUtjNnJ3bkdWVkJLUjFMblY1V1NYY0lDbXVqaXFVMFZLSnJXTjd6SFdTc1V5a2NJT1VnKzB1cHNyK2tKVGpVUVRVTlZLNDJDZCszYWRBRWZxbEFYd1ZjNHA0UE0rKzVIUDliZUR2QUgvY3ZIWDdmdEZ1M2ZCcnZvVVIvUGY4MkFYdlk1RlV0ZWF0MjM5WlVlWUNOa2UrU3NyZGVoY0xTZHNBN2pSdjNkNzNZemU5dlUreCtWVEh4cndiK2xsak5NRFcrZFBtcmRzRkdaVUl4TTljQnQwWG5iZXpzN1d0OVNBSHEyNUZUdFk2UnNvTnkvWDE3NXQrWGlRNTV5YTh6cWhmREZFT0tiL2hTamhNQk5pYWY5N0hIRzAyc0hGNDR1TnlFNC9Bc0xtNzg4UFNOWmFCYjVESTJXUE1lV0xmMi9jTEpCWHZ4MHlTckkrOXFGNVFaV3BmVVI1aGtZVWlKTmV3UGFsT0l0Mzd3SDRWK2RuWjJyN3AxenYyT2wzSDFxMzJ5MjRnaDVlOHp2cnUyUHZoMHFLRHpJUHp6bTN2czZ2NC9lME1vbml1NjJQOWV4WHJnd0d3dkxtNzh6UWNFKzhWaTVUV1FKV0MveXdTSllTL1hzUlYzYVNvRGhNRWVGQnpMNUFJWnQxSEM3L08zTTQyNGRwYXIvVk05bVJrdkR6d2U0Q2NFL1ZPZGxDUmptSFYvejBLKzVIT0haYjNoWkQvWGU5UWZjd0JKNWFyOThaQjNoY3lNakl5TWpJeU1qSXlNakkrSGRTY1lEdDNLTTFwS3JNUTluUWRNNFJLMWRYd3o5L0dESTBmQTM4WkNMY21wcUo4MDQvdGtaUm9iL3RQSHlPbGpqRFM0Qzh4TXFCS2FicnExMTNBREc5SHBOQ29Zd081SC9jdGpCUmJBLzQyaytIL2VzQmZBVC9EakdIS1diZnVkUjZTRkRwU3lnMTRCdUs2akJpK2RrWTQyMXJ6MXUxaDFiaFU1Q0dWZ2krKy9Fc1ZwRkNzTWc0MHNER0lKT0dxbng5RHo5WXdaZDZmQVkrYXQyNC9wZ0pGdTdXT0s1aGltOEwzQytIelFRZzN2ZVRYL1VYZ2Q3QjVkUmNqdTBRQXZJNFJaVStCUC9YZlA4UENGcDlweUMzYUxSbHBwZktldVNiQ1hQL2JHQW04QW53SFV3R3ZBUCs0ZE1vSlprQS9CRDRDL20vLys3a3B5dDBKNGpvMkwvOFRURDE5ajVUdlVTSGd0RDU3M29aUHNQRUVXMGMzTVRMakNPdjNMall1ajg3S1hYdkJlbC9CeUw0RmpBUXBzQkRGVXFKSzlkY0F2dVJ0a2RKQWF1QVkybTdnUDBkK0NZVU5sM09EMWtqRWtYOS9nczNaS21lQ2NlallVTGM2U1UzNEd0Wi9yMlA5cHpYWENIOXI3ZjBGMXU5UHZiMHkycGNKcHlHbWlnZWJxdzlJWVdpLzVmMzJQZVlZR3llTi8zdXY1NzhGdm8wNU0reDcvZTVqcFBRSVcvL2Y4Tjhud1BYbXJkdC9NS1BjZDcxT2ovMzRKVHgwWVBQVzdiNkh0ZjRHOENQZ1lFYUVocWdzWEtCRXhtZE00a1VUdXVlRkc1UjFYeHB5bXZ6U2VqNnVNaGlITU0xZFAzOEpXeGNpYkUvT0NQMWNkK1Z3SlZIVjJkcldmVjczR1lVMWIvbzFhOWg2ZWMwL1c4Q002WGRMNWRTd3ZlQTZSdFIrRkw1YnhmYUl0N3orKzlqKzh3QnpwcmlPN1hFUC9lZDFiRS9xa2ZZbUdkMmxJRjRoN2U4d0dlRkErODhHU1pFc0ZYTVBJNEhMWk1CYnBHZ0hlOWcrSTBKM3dlc3JOZG1BNUNoVXhCekJMeHJLeVZ0RmFqb0J2SUdOejlOVEoxL3NlaldzTHpRZnU2VG5yRDdwdnJLTzladHlYbC9ZZWNIYnVJNk54NkdJV054aElEaEs2QjRxSjVzZU5nOUU0blpmcGIwa0l5TmpQZ1RuRkRucUZOb1QzU2xMemtHUHNlZlJ1VUxGTzhHcloxb0k5KzJ3QncyeFBUWVR3QmtaR1JrWkdSa1pHUmtaR1o4Q0ZqRWk0WDdSYmgzTkUxSXpHT1Fibm04VFVyaE9HUlIvR3lPTWZsNDZYV1NOd3FCK0o0VEtmUTE3eWZ3QlJvcGR4NHhtTWt5dSsrZEwvcmtJa0tPaTNmb0pLYnllNnRmMDZ4MWcrVEpQaGRSenNuRVpJemUvQ253Wk0ycXFuQzVHSU81aDRWZjE4cnNPL0NySmNIcEFVaHVlNENTMTUxUHR6a3V1TzNFa1Ezak1YemRXNjNwWVd0VlBXQUNHbmh2MHhFUGVqc0ozYjNoWlVrVEg4TFBSK0tmclJ2V0lGTUNSdUZJOW8ycXk3LzN3TG5DbGFMZWVRR1Z1MVJXU0VpWitydmJJa0wvZzVPV2FsNzJHR2IzZjhYUFYzOHZZdkRud2RvTE5vV09TV3VwTW80WDMvVmN3NC9vRExJeHovNHl4MHp5VGNyYmhkZHpENW44WnkvNTdEU095K3hoWi9GSFJicDF5WkRpanJqVW55T004cUpWSXlISG9WZUEzTUFlTFB0WlBJNit2Y3NncVpLcEN1RDNBVlZ1a1VLUkxHRGs1OEhPT0w1SnplWTcydlFIOFBaSjZGMndkL29kU3lQWUZyTytsakx2bjlXOWk0M0hpOVJZeGM0Z1JtaXBUdWFVMXo3UU9OQTdMSkVYeFBULy9hVGhHRGgrTFRNNnh4WER1RjBnUkJyUW5hWTNMU0ZiMytuN1AvNVlCSHBJanljaXZyL1Z5Rjl1cjNnRys3c2RLVWZnQmlRdzdDdzNTbnZlT3QrOFhNU2VBbjNxZHIySHo0NWU5ZnQvRCt2WGRhV0hjbTdkdTk0cDI2NmVsOWQvMzltamUxckhRMWdla1BLUVRDRzNYdkw0MHg1clBLbDRHd3VhY1lSNUhUc0QyNFZUOVJmN0hlNDBNeVpEdWo2UE4zWjEreWFndEVtMVdmeWhFN2dLdzFObmFQcWxRdjBiVnFsUzFLeVRWcHNMMkt2U3psTFFUY0pWbEFkenhjNks2V2ZmZkhrYisxa2tSQXo3dzcvYjgrMFdTTTF1WHBQb2R1UEZkVVFZMi9KaDlVbDVpM2Z1dmtFSnVQL1cvNWFneHdrTDRMdUVxVHEvN0hXQWhrQVJTT0YveDZ5eDVlY1htN3M3anp0YjIvc3N3Rnl1d0FqUTZXOXY5emQyZGN2cUNEVndOZDFrWDg3NVRlYnFmeEhHSEZFNWZ1ZXNuMGhGTWczSlh4N0RjeW1IZDJkbys0dlFhbElPaW9HYzk3ZU9MSkNkSE9RYSswRkQ3RmJtUDV3MVZtNUdSTVFYaG5qRjI5b0R4ZXJ0T2N1cnBZNDVMUzc2UEhaTlNIUlFWVVJLR2Nxank2OFQ5UjgrK0E4SjlOVVRaS05jdkl5TWpJeU1qSXlNakl5TWo0eEt3aUJGMk12RHN1K0pTcEZvNTl5SWtnOUZiL244ZldQVHp2b0lwdXByKzNkdisrMFBzNVhJTkkyQmU5NzhYL2UvL0NGT3VnUkZ3ZjRJUlVIZElaQk1ZcWZZdVJ2WTJNTlZsdzYvenh5VGlSQ0ZJRHpDajZTd2o5RTMvZnMydnRlYy9YOFlNcHc4eHNrVnRCek4wWHZjK2tKcnlpeVRWNGFHWGNSL1lLOXF0Z3FUNktJZWFGWkdsOE1VeFIyZzV4SEk4TitZcUJuZ2ZDd2ZiRGFUTUdrYTRmNWxKQWxmOW9seXVVa0RHc05kUkVhbS9EL3ljdjhhVnRSaTU5YWIzdzU3WFR3YUNvYytMWVNqbkttWndGckVUdzJ2S2NGN0hTSzE3MlB4NDZyK2p5blBQKy9rVGtrRnozWC9MUUIvRFU0NFI4a0tyRHFzWXlmVTZOazRiZnU0ZHFsV2ZJbGdWbHZZSGZxd1VVYi9rWlQ0a2tXdktGYW0vcFJCZEFwb0tpVnR4RFVnNUdvK2NjQjFoYTI2RnBOd3RnRU4zRUJoNSt6V25yZ0svUmpJdVF5SjFwYUorR3lNQTlySHhqZXQvNFAzeGFTa3ZOYThlWStNcmd2OGExci9SYVdFRlUzdUx1S2o1OGUvNmR6cjNpRFFmNUFqeEdqWlhicEJVZmJIUE4wamswMnRZLzcxUDJnL2srTklIYnZwNFNKbW51VjBMNVNtSDlSb3A5K2NpcnB4djNycDlGQWp1SnJEVXZIVjdyOXc1ZnMxajc1c0gyUHJld01JNC80bVhyYkRYWjBFcTNaR1g5UlFqZjc5THl0dTc0bVcvaDgyYkQwblJHVVJnRHp3dHdOaW9WekZYQnBnVHl6STJKeDlnNnQ5N1UvTDlua0ltZjgrSHF2Q3hsMVh1ZWNOTFR3bGxLMlczaUxKYVZPSTZrZFhGY3hRSDRuY1JKejQ5LzlqaHdKTUFBQ0FBU1VSQlZHazNsS0c5WUNaUjVQVlpKamtZNkY0OGdXRGdIamlwdHNFa01hMVE3WElHZVFpTXFoVEZtN3M3UlFpNVc4ZnVuYXVZZzlrOUwvc0I5bndCNlQ3MVUreitkZzI3Rnh6Njl5TmcxZnRBamxWeTdsSzlkQzhZa2ZaSlJWbDU2dGNZYnU3dWpFUDVkN2EyUlI3TGtVWjlHNDM5WmVjcWtZdmpzWWh0RDJydVMxZCtuV00reGpGZUtIMm5aNlJMV1MreFRxVTFFSFBIeXdtb3l6blZ0bDdXT01TM25DNDZXOXN4SjI4c1QvZWt1aDhmRmVQeE9VbU9ZZUR6bUpTdmUyWS91ME9EbE1QbmNnNnJJb3hLT1piSHprYXo4Z3ZQMnZPcTZ2Kzg5c2lNakpjRmMreVBlbWZxK2pwL1RJb3FzMHJLKzZ0M2pYbzRSem5wdGI4UDhmRE9uYTN0QmQ4VEZNMGdwbVBSbnF2bjluNElSWitWd1JrWkdSa1pHUmtaR1JrWkdaY0k1VHQ3SFhpbmFMZnVZZXJBZmN6Z0tJUGdOUkxoSzJYZ0NhYWFsZEpSQ3MwUHZJd2VadFQ2dWY4dDBtUWZKNzJ3Rjh0SS9vS1JNZjhNSXhuK2hKVGI3aDVtV0xwR0luM0J5SW9ma0VLbWdpa0NWMGhLbXFFcmpRWGx3Sk1oN2hOdm4xUTNCOEFmaE84S1Fram5vdDNxWWlxNGYrL0gvaTRwelBXQzk4MEQvejhhYTJVY2s4Rk5vV0tYU1VSTFZBbEdBK1UwQXZnSkZxSmE2cUN4YXE1b3Q5NEcvajZUcEs2dStSZ2JrMlBnTjcwL0JCbmREa2pFMkxxMzVRUUxWZnVZWkVpKzd1Y29GT2MxYi84SnlkdGI1VnpIak4weVRxcytNUXp4QmthaUZ0Nm1kV3dzaDk1UFgvVzZQUEdmUjloY2VoLzRwcGZ6bTFnK1hqaHRUSWdHL0RXTXZJZEVPcTU1ZVlla01NaGxxSjNySkNYVkhaTDZWK1Q5SjloYy9jaVBxWG1kKzlnY0Y3azZnUXBWOU51WVVyL3JmZkFWak55L2pxMlp2OEhXd3I2WHVlSDErQ3BKSVNyRHlqMi81aFBTK3Z3aFp1eGZ3SWptY1orNTZ2TFNsYjZoZkpHSWVMMi9pTzBkVXR5ZVlPUGR4Zm9jclA5R1dQdWZrTUtQYWx3VkVyekF4bEI5TDVYYUViYmVibnFaTXBaSEVsamxSUVdTRkhaRFRPV3Z2THhmdzhpY091YjQ4YUVmVTJCanMrRHRVcjVPT1JwY0FmNE5OazlpaUhlUnVKWHc4UkRaOGwydng0ZmVWb1VjWFNhRnZENEZkODdvQWYrNzkvVWRyL05IV0pqbWtVZDVXTUx1QjB0K3padllmcWR3L29OUXA2bndFUFZMd0grTWtjbC9oam1TdkZ1MFc0ZnpSS0RJbUVSRlB0d3hTZUpLd09kQ2FweFZybjgvajZLbjZwanlaLzNTOFhLOFVUdTdwZVBuM2F1dWtBeld4MWlvM0xOeTFIYXhkU21DVkNITys5Z2EydmZmSTZEWjJkcWV5SS91N2F0MXRyYlhTUG14cFZidWsrN0poOTYrT3lKbW5YeStUbm9HZW9LdGNUbTduYmdLV3FvdDdXVXk0Szk1dmZaSWUrRWgxVXB0Ulh3WUswdjlPaWNlSHZUQURmekhwT2dSdXNldmRyYTJxOEoxeThHdElEMFRQUlBDL0I4cjJHWWgxTGxXTVc5NjNuZmRTd3FqSHNuWWNrN05pRVZNU1hldTZ6bFpJc2VEOGRycGJHM1hRNTdOcUVZZk83NTF0clloUFh0QnlUblIxNUJJNHFnQ25taFRCYUlUNFNuRVBNTVZYNCt2SDY0N2JsODhaaHFKVy9WWnFmOXIvbnRjUnNYK09VWW1oVE0rQzVnMWp6ZDNkdzdjeWFvWFBodEh3WERWNzNnLzhUMjBUNG9RRko4NzZ2Ni9uSitHaFB1TDErTXdsRjEyeU9tZjQvNmRrWkdSa1pHUmtaR1JrWkdSTVNla0FHNWd4ajdsZ0x2VHZIVjdIQUxQeWRNR1JzWjB3M0ZOakhCNHp3OWQ4ODgvd0F4ZDF6RlNBWXhjZTBUS0Q5ZkV3aWhIOGpmaVBZd2MvZzRwbk84N0dCSFJJeEhBSWc4aldiT0NHYXdVQ2xadDFZdWxRaUFla1ZTbVQvenpEekV5NXNRL0d5c0xuWmhaeDBLaFhpR1IyZGZETlpxWVVYWXhuS3U2WGZVMlBNRU10bDhqRWIweExPeXBrSGRNS2hQMTNTRkdIajJBVStHV2wwbWhad25ueFBZL3hjaXFleVRTVGJrRUJ4Z1JOUEQyTFBseEJVWjBkVW01Qis5NWVTS2ZtcGdhV2NTbzZpU2wxbFZTeU1NclhrOFp3bjhYSXpRZmtVTDRpbmgrNnNkOUFTT2gzc2NJcExyWFgrclBCN2pDZkFxcHBNK1V5L2o3WHZaZmtJaUZWYUJidEZzTFU0aXRCVkl1MUFGSkhiMEcvTmpMbEtKSUJPVkhYamZsU1R5bUZEclgrMm5CUHgvRS96RnkrNHZlWHh1a25OakhKQ0ord0dtbkNranpjRUNhbXgrUlZQYjZUaDc1WTF5MjZqSW9zQnVZczhoYnBMMURJZCtsOHY4V1JsZ29mTFpVY0dEelgyTTVEdGZ0aWx5d2VicUhFVFJ5UG5nVG0xdkgvcDJ1SVFKbVJGSnF5eWdlMStNNk5qK1BTRXJySmlrZmFFRUtwYjN2MTFHKzVKcC9keWVVL1JaR3drL01NVy9MZVZRUVVvTXBYL2ZYZ1o4VjdkWmRrZ05MdWJ3aHRuNFdtcmR1ajhrUWoxalE4RkR5TlcvcngzNzhWN0YrM0FDdW5pZDN2SS83TzlqZWZwTzBGMTRGL3RPaTNmcmpLaVY4eG5STUkxVmZCZUlpS0JCclRyaWRPWmRLWVN0amRJbnpYcnVzTE5TZWVOYjF1NTJ0YmUzbmNpTFRYaUNIcVJqeFFqL3JXRHNmazZLSEtCZjhvUk8zZGVCZUNMSDh3MUw3bEM4MlBsZXNZZmZIRWJBZkZLWWlSSy80MzlyYit5VGx2dmFjQ1dXbks3WUd3Tk13SmdvRGY0MTAzeGxzN3U0Y2Q3YTI3NUtpSmVoWjVacVR3SkVBRjhFWEk1czhLeFpDdnR0cHpsb1RtRVh5S3lSMFoydTc2U0d3bjRaKzBmMThMckkyNUwyTUVWbVVKZ1F2YXducngzT1RIbUVOeUJsSVVIaHA5Zk5UMWNmVjhVSWs3U01CWEU2WG9uSHRuN1ZHZlgxVXRpZjB3N1J6eTIxWUpqMlRqcDNFNG5FaWxGWC8wT2RqbGJXcmhRZFNNQlAyeHlsRWYzenVub29wRVEweWdaenhxZU84RGl0UzVUTDVQcW41dTBaSUxlRGxscDFsaHFYUDVOeXNmVVRwRkU0NWRKWEs2WHRVaVVVc0xQK3o1RDBmcjcyODdqSXlNakl5TWpJeU1qSXlNaWF4aUJudVZqRWlVTG5sSXZsYnc0aU03K01raVJOQ3ZhTGQrakgyY3ZkalV2N1Q2eGloSW9QaDczbFJNdlMvNXNmK3poejErNWIvN0pQQ3BkNW4wb0NvdjV1azBNUEtaMWVFNDBRS1NmMHJJK2dxUmtRc1lVVE1QVDlXUmxhZDh4NUd2bjNSejdrNm85NTFVbzY5dTZRdzFsLzA2MzZBRVlGZng4aWtFVW1ST05WQUZqRHc0ejhnRVZROWhWQjE1ZS9mSllXYWJZWnpsWVB3THZZQ2Z4OExvZnZubUVGNlNNb1ovSlJFYVAyVkh5dmxrRWplTHFZMlBnaGtVS1VoM1JXQUQwa0s3bDhtNVhKVytNeEYvMzhqL05aWURMeU8zd0grRVlsUWt3ZjVZNEthcTlUdVdJL0RFR3IzN2hTQzkwUTVtZjIzcnErd29XOTQvL1JJNUh3VEk4cVUvMVVxK0tlWWdmb3g4R2dPUWpVcXZTRXBQYVc4VjZqclBrYmdLVHoyTjdGMUp2STNHbmY2bUdPRFFubExIZDhya2VSbnFxZ3VBVkxSeW9COUJTTUVqMGprKzVkSXpnUjcySDd5eS83M1ZaSnkrU2ZBMDBoRUJoWHRNVFlmYm1EN2tvaVhJU2xFdThaVHl1QVJpZGc1SUttSklhMDFHYzc3SkpYY2ZVeEZyWkRUVXJuRmZJNC9JMFFTY0h4WTdwenpFdTQrUDcrR2hZTCt1ZGZyT2piZm5uajdLZHF0QjVpNlcrV1BDSTRHQVZLY0QwbjdhTi9MZW9ydFkrdWt0VG92WkZ3OEpLbEgzaUQxMGRlTGR1djdtUHE0cjdhZGgyVCt2T01WTTN3cXJLeEluTGtSMUkvblFpQ2g1Q3lrWjRFYVRqWXBCT1cwdm5UbGFMZUNOSTE1RENNSkp5ZXFQcmEzWFNIZHl3WkJpVGpoOURHRkZGUytYa2k1eXlFUnZJcWlJYUpYUkpvY2tCVEZRSHV0Y2hiWGdnRmRLU0gwUEFDVDRkNFBRMTlLd2FWajE4STFGa3JFaEo3UHppVGFaNkdUY2xZcW5LaHkwMThteHVHZ0E1VGplUnptZWs0c2tOSjZ4SlFrZlMvemVNcDVVK0Z6VkhNcmhreFdKQmVSTzJWQ011YmRqQkV0UlBJVVVYRWZRcXJQVFRKTkk3TVZRbnpPUFdxQXpSUFZWM090VE42UHlkb1M0UzVIaExIcTE4bXNja2oyVXhFSVNrVDFMUEpLSWV2TC9WSitma1AxZXNYMjU0eFhBTDRYMUgxdERVdmZWZVhoaGNtb0V3MXN6OWY3alBhcXg4d1BPZlRLZ1hMcS9iTU1YMGQ5a3FQSnVSSHVYVklnajNoRkhPRXlNakl5TWpJeU1qSXlNakkrRGNqQTlRUE1JUGcrRmFIMFBLL2pLZFZFTU13ZkE4ZEZ1L1VVZTVIOExjeGdDSk5FM250Y0RCdmg3OS9FdzZVNmxqQlNSeXFJQlpLS3NGeFBxVkNQL05ncldMam9aWXhFRzJMdFA4YUlsRFV2K3did0s1eFB1WElmSXlxZmtJeWtHMzdkQWd0eHZPQi8zOE1JV0NtamY1dEV6RmRCeHQ2dlkyVGZJeXlYNWlOWGEvOHRqQ1I3d21rU2RCOGJtMjlnWWF4RitwK1FsTXRkekZDcC9IOWR6S2gxRW82WDRSaVk3T016Y09CdHU0YVJma3RUanJ0UG1vZkt6L3dZRzdNaE5sZWpXbG5obHhXcXZBZThWN1JiNzVPY0ZzYncvMmVHb1hUQ1dvcnlHNlF3NU1wZnJUbXVlU2NGcVVKWDY1cksxYm8vRDdsWFZpMDNiOTBlRk8zV2dkZWhpNDIzY2dzclQ2NXlQYjRiVHBVaGNvaU4rMGZoODhjOGc0THVvbkExcy9BbVJscHFyalV3aHdBWnBQcGVWeWwrbGE5M254UWl1anVGd0QvRzVvSkNzeXNxZ1BhOHEzNXRuU3V5V1NTL0NIeUZpeFl4L1RPc0g3WFhyV0JqdStpL0lSbmx4L05PSWVqbkdmOFEvdnVVT253S2FwaERSdytiR3lMV1AvSFA5a2h6TWhxbmErVjE2MlR5dDdEOXNBNTgyNy9TT3IyTDdZVjE3NHZ6WUlTcDlLUytWaDd4bTZRSUFCUDNuMHordnB5NERESWpuRC9UNlduYXRaNHhWT1FvaFB3RkR6WGIyZHBXanU0RG5LaDA1V2NNT1IzRFdRb2lra1c2S2E5cjMxVk85MG4zNG9mWStqeWN0dytkWUZaMEVlMmhTNlJuaTFWc2pjdFJxRXRTbUlvOFUvU1ZLeVJ5VE9jcWZZT2NNZVQ0RlFrMXNEMnU2V1ZBSXRJWE5uZDNEanRiMjNxK0dIbGQrMUtDZWIrZFMrSHY1QVpNRWdwU05UL3hNby9DOFEyZ0hrT1lYaEFIWGs0Y255NndXQTRkSGE0OVRoOVFDbHVPZjY3N0dhUTl1bmZlZFJTVXZ3MENZZXVmTi8yN0k5SnoyeXhFSjRCUlJiMTFUQXdEZldHYzFWYUZqbFVJNnZDNVFsa3ZkTGEyRjhMYXIyeWZxNTFIcFB0OUpTazc0OXdGakRpdTYzOWRVd1N4MTNQa2VVNGhPU05XS2FuaDdQRFphdXRNQWpxVFdoa2xqSE40SzNyRFpzb3gzeVNsSW9rNGhESDVHbE9lNkx0emthZGhEeHFuTGdwaG9NZUl6anZ4Tzc5V3VZNXpJU3J4ZlIzcW5qSHcvMnVrSE1UWkVTTWpJeU1qSXlNakl5TWo0M09KUll5azNNUElyUk5NVFNmUzRrejFsVlNuTUZiZUZSanh1REhydklDbzdpMmo3M1hyWWtaWkVUbkN0ekhpN3diMjBxZGNucStSRkhobFk1MWVka1VvL2hRalE5ZUJYeVNwTW43a243MUJDajliaFI0aFB4Sm0zTzBEZitsdEd4TlVSYnYxYmEvYlYwZ0VUY09QL1FoN1dmOENSckxNNnI4bHpNQW5nK01OVWdqbU81Z3FVc2E2K3hocERqWXVQL0Y2UGNUNjlpa3BMT015TmhiTEpFVzRETUx5Q2xkZTFXTXN0L0tUY3lvV1paanNlcjNYU1lwcGtYcXZZd1Q4dnRkQlNrcThYVmV4dnBPS1VQbDRaUWoraHlRaSs5OEJ5MFc3ZGFkNTYvWkZqTUthL3dwRE9DRGxNSlpxdE9sMUVtbWduS2hhUi9yL1RETExDYmlxWStVaEg5VkhoNlFRMENJMzcyRmhlb1VSOE5mWW5QbzV5WGorQ1hBY3dpYkx5RHU0N0pEUGdwTy9VaTdkOUxwSVRTK25EaW5hWmhtYk43QjUwOFRhZDY5MG5iRUN6Y3VXVW5jWkp5dEkrNERXN3BoMEplV21ibUo5L0RPc2o2V0VQZkhQcFNBY1lYT2lSMUo3MVlGQjBXNHBQR3dNQVQxUjExTG85bC9HaU9zdll6bWZ2NCt0eFNNOEwyKzVNM3gvMlFQMmdySzk1KzI5aXVkUnJqaTNWclJiYTZTOXBPbjkralUvVnlHcyt3VFNCWnRMQmJEaGVZVHJXTGoxcWZtR0EvYXdzVjdGNXNBTmJEeWZZT3A1T2Vka3pNQ0xObUplOHJWSEpBWHF6RkRRYnVDdXpRcmpPd3Zsa0pRZXdyZ2JQaHZoamp4ZUh6bEZhVy9vZHJhMnEwZzdrYXVRVkxBTFdGaExIYU55NUZRVmlidEZ6RWhkRlRwM0Fic24zaURkRDdXblFBcnJmeDJMS05CelkvZ0llOGJSZmlkRnNwNGZwUDVTNmdDUjEzMmdHK3B5azVRN1hudktBTnRqbEtNOXRtT0ZSRDZ1QVdzZURucWUvU0cyK3dvcE5IY2tCNVFiZGxRNnZ1N1hVMGpyQ3hFS2tFS05sejdUYzh0WktKL1hkeFh0c3Y5b2JrQ0ZZK1VzaEJEZjhWN2FVNTM5T2xKRkh6TkpvbGFwQVJYSllreGV4M1hvZnl2S1JjM0xtRnZkZDg2Mk5ZREZ6dFoyWCtzN0tQdGlOSjRhazgrRE1KbS9PUDd1ZVoyalVyK0drV1JUOTVsU21Pa0pGVEdUcEhtc1V3ejVYaWF3NC8xL2F0OTVYZU96aU9vK2RwYnhkUjM3Sk5iN2xTRzJYdlE5N0ZWRFZjang4TDlTQ0t6NnNjclJYbzRRc0lHUnIzRXY3Z0dQdzNwNEZ1Y1pSY2ZSUGIweDYxN2QyZHBXWkltNW5hSEtpT2R0N3U0b1BVU014RkhEeU9EeFBUT3NvWmw3V2RoL1lxUUI3U1Y1L21aa1pHUmtaR1JrWkdSa3ZESll4UEtlSG1FdmdRcTdLZFhkTzA1QW5DS0ZuS2lLb1F5RkVVYTZ3ZG1LM3c4eEFyYUJHUld2WVdTSGxIUlNBa0lpTVdFeS8rOWJ3SzlqSWFXandnK00zUDVYbmhOMGxSVHU3anBHeFA0SGIvYytpZFRzWWlGT3Ywb0tGMTJRUXRFV0pPSzRpeEVYcjJPRTZnTW1jNnBOS0UrZElIL2tkWDROZTlFK0lhbnJWb0hmSUlWdG5JWWU2Y1UyR25aUFNJcWN1NlFjeFQyTTVQNEJGc3BaWk5ZNFhLNkhjdTY2MGxUaEt0WHV0ekJ5WEFTWVFnOUw1WFFJYzRkcjFUd2JBSDlFQ3Z1OGhNMkJyMkpHM01MN3IrZE9CVEtNUVZJMng3eFRxeGg1OVEvRHRVVDZiZmk1SDV4UnQxTUlUZzBLU1NpalhBOGp5bFNtMm5ScXJjemhSRkVtZlY5MzBsZ2gyU0FwZnhld2RhZTVDbVp3RjJrb1BNSFcwNCt3OWFnUWJTTFZxMEptS2dUYjJIQlp0RnR5cnJnZisyUldlMlpna2RSUElrQVUwbDExMHhvRm13OEtpem9LbjRPTjV4dkFBKysvYUREZHdGVHdDZ2NPYVQwcEIvTU5iSDRvRkRXaERCbGc3NFJ6UkxRdllmTk0veS82T2RvRFY3RzEvUm8yUng5aGhPY040RjdSYnFrdFdyT05vdDFTRHVkbGJBd1ZzdnBHNktNaHNGUzBXNk9ZcjdlTTRIUnc1SFVzbUVMcXU3SmNhenlHeG4rZmxCTmM0L1V1aVFpNEd2cnZXOTYrWWRGdUhaOHhOeFJxOTBNc3hQY0tSaTcxL0pvUFpyVXRJK0V5RFk4djJwQlpJajFINWZxVTZxYjkva0lFOEt6cmk5ekN5VnduMUtTYUg1Tk9VOVRJdWk4Q25IZ29YaEUreWhsK2pPMU5VZ0xYTzF2YkJiYWZMR0hrOGtFZ3Z4YXhmVVRQWTlyL0ZEYS9qemtkNlRsQWh2dUZ6dGEyVk13RGpMZ1ZhZnFHMTBOUkRXSUVEdTE5TUVsT0QwbjNvbWhZUDlVZlRuYnJtVURoUUpYTGRXN0VmSTRZWVZGVzR1cDVMcGFyZlZWL2Y5clFPRlE1c0NnNmlPbzNWeDdoQ3NqQlNFVDl4UHJkM04wNThUbTdRbnAyeGI4YkJyVmZWTjBWQ252dVh5MlQxb0hxRG1uTTUxYlRWa0VoM3lzSTJERTU2dlVVV1M1Q1NmZk1rVHRoU0lGYkk0VWJyK3I3bXA4anRUd2tSNjl5M1U3dGhlWFExWnNoVkhzZ202VENIQk80Z1NnYXF5SzlMVEY4K2pBU1NxRU0xVHVxZ1hXTmVMMklDZWVXeTBSY2o2SFBuL2srOUtMdlBhOEN5bjAvNDFCOXR3U3NkcmEyRDJNa0JMOG55Y25pdUhTUHZaUklLejQzamxSbVoydDdRajIvR2ZJSkI0ZWg2RFJ4R1hYb2g3TGxlTkV2S1lTMVZzYjc2TFQyaExxQ2tkcUtuQlQzMDdIVHlUbkdLeU1qSXlNakl5TWpJeU1qNDFQRElrWmM2bVZvRlROUS9oMHN2REFZc1hxdmFMZitEVWFBeWlBYTgyS080V0Z6MzhmVVhMK0tHZnFuRWNIdmtFallkekNGNHA3WDR3Z2poTDVPSW56TCtMV0s5cFMvMy9OeVZYN01NeXZpK3luMjBueWRaQlJxWXNTR3lONzNNREx0QTB6VkcxK1lZMGpxczZBUXdrOHdJOTAxalBRVTBTYmk5aTZKaEZuSERMNkZ0d0hNTUx4T0lweFZ0b2pLSnlUQzlpNW05SDJxYXdlaWFHekloVEdCVlBoM05henYzL1NmNzNwLzNmWERGVlpXNnM2MW90MDZPVU5wS3dOV0grL0hFUEpXNFNHYmhIREpUc0pLNmFzK2tFSjZIU09rM2lUbEU1WTZTUXJPaDhCWGluWkxoazMxV2MzRG01K0ZDUzk2Sjg2ZWtzamZCY3pJZm5pQi9LME5yNGVNclZMNDNDQVI0UTlKeXVQckpKV3M1cERDR1crUWpCbnZZMzN5UGphSEZYNVNSdFFxSXJlUEVYbDFINWNHUnZ5OVgxS3AxaTVJQW8rODcycFlmeW5zcU5hUDlxT2V0MGZxcnhQLy9FdWt1WTZmL3czTXFXRVBNeGkvaWFub1JYTHZrL0kwaTBUdVljNFFYeVVSU25FZms1cjNPMzdOdmw4ZkV0RjdRaUpndW1FOUhXQmsvQmY4dTFYTVFRVlNOSU1oS1pUckNzbDU0UUdXYS8zWFNjYTg2Tmh4SGFnWDdkYTljcGp3TXNMNG5LVzZHNGZrdy9wS0lldnZlQnRFSXJ6aDlaWnFHNi9qQ1VsQnZFamFEMlRVazJwZG9kc1ZXaHN2NTVILy9mQ0NDdjNQQldRb3Z5ekRlNFRLZlZtTWxXZlVZK1ljdVVnN0tsU0cvV0N3SG5nSTQySHAySmxRbUdBM0VFdWhlNFR0SDRwNDBzUHU0MXAvU3lRRnBCeHg5akFuQ2FsUEMyenZXTUg2NGhHMnoraytyb2drTlQvbVVJU1YxNlVBRHFTRTdteHRINUtVcE5vSDkwb3FTdTE5WUNUMUkreGVvN0M4RWRwUEZKRmpwdkxYKzFNcEZaNUdvc0NKaEtVS0JWa1BHNk1KVXRuUFVmalNpZThDSVRCVCtmbU1LRHNTaWNSWCtORm5EcUZNNm5QbEtCNWk4Mm5zaE9uRWk1eVQ2cDJ0N1JpMnZMTHRKZUpVaXU2WTExb09oMzFzanA0N2RMV1hLUWV2V21kcis2aEN2YWY2NmI1UkpqWEhxbHR2bCtvbW9xZUtSQnFGdlZNT0RZTXBlK21DcXdPSHBicE5hNnZ1Y1JwNzFibHFYWlFkR2NaRVZLaWIxcjBjeXlKcExZSjhGSTZOdUl6NVZZbUtlMFJsaU9xZ1VKK1o2OW5KeURyVzl1N0xjdTk1bVZIdW83S2kzOGZvQUh0T1ZCU0diamkvNjkrWHd6czNMcnFlcDlTekhOcDVWazd3QW5PV3FJcDhVY2RTQzV3M1NrTE1KYXkvVmFkQjZmZGNLTjMvRlZGRFVTN0dVY1ZLMTZhenRmMWNvaVZrWkdSa1pHUmtaR1JrWkdTY0Z6SXl5S0R3ZTFoTzNCaG0rWWIvdkl2bGpQMHhSaEljTXlWL3FCTjJ4eGd4czA5U3dIMjlkT2dpOEUwdjc2ZGU1amRKaFBGeHFTNFh3ZS81NzM5RklvTWF3UGVidDI3M1hXbXBrTStibUpvWGpMejVDNjk3QWR4djNycDlod3ZBeVpDYkdGRW4zTWVNcE90WXYwZ0IrVDd3TjVneFp3VWpNYVcwRXpGMWsyUWtPdlJ5bFpmdmRjd2d2RTRLWlh2UGovMDFQLytkb3QzNnJyZEw2dVd4b1VBRVh4akg3L3ZQbXYvVS9ScmprTFpPN0IxN0hlWWhja1lpMFoyc0dnVlM5VEVsNHNxUFBmSDY5Y1AxbFVmNU4wbEc2UU5zN2lqazR0RDdyT0Y5OFhOZ2VNNzhvdVY4ckFOc0RGZEovWEp3VmlFaFJHOVVsY1Z5bDBKNVBVeDUvWDBzUlBnQjVqRHhFMi9QYjJQeklrSTVtdTlnZlhtM3BLb1VTVENoUFBhMkRmeXpodmZ4T3E3NDFwencraS82dXBrM1IrMzQyanFmcE1oOTRuVTZ4dGJEQ3JZSGlPQ1g0dWdOSnZlcVQ3QjV1T2UvditCMS9VWC8rd0cyVjYyUndyTXUreldrWm5zZjIrL1dtUXlwdXVybGdzM0ZMcVpHVjdqc3gzN05mbG14NnV2Z0FTazNzeFRJVWowclg3U2NFSll3a25rSm01ZjNzREVHVzl0L2pjM3ZSV3l0WGdIV1BhUzU2dmdzR0FJSHBiVXc4RGJ1WStyaG9VZUMrQXFUNUsvQ1hLNm9YVTZBUy9Fa3h3bmxWWmNocndiOEVOdnp2MFJ5Vk1tb2dOUmlUbzdVd21mbnl0TTNDNitLa1hJV2VSY1VmaGRSQjR2b09sVitDSVVyQmU1VU5lc1VBbHIzTWpsWExXSjcrWFhzdmkwSEZaSEFOZURJRGVSZGJDOVNIc2Q5LzE3NTNHVzRGK0c4em1TTzRBSUxENnA5Vjg1QXNXMTc0ZmkzTVVMZ1hsQlNYZkV5anpkM2QwNDJkM2VlK0RuMVVxamNPaW1sd3hEYnczdk1YdHU2aDQrSm8xZzNLdkpDT2lId3BLcXd6ZW01ZnhleGU0R2NkcDRIdEQ3akdoVnhlanpqdkxrUTFLWUs3Njk3WWROVnYzcTJIZnJZOVlCR0lDL3F6TWhoSEk3Uk9NaEJTOUZnUktUS21XeXNqanZIL3JGQUlxNnJjdUpHVldETjJ4SlZqTHAvS2tkdlZDUkhJalVxbnVQL0NuYzlWanlYNnFEekZicDlFQWtvS2Z0ZGFTM2lXWXJyVTA0SlRuaURoVlNmSUpTOUxxTkFoc0xrWHFEOVNBNnJ5c01zSmI2SUtCSERjVXpxb2N3YWN6ZytSSFU0SmRKY2F1dnk5eFhGaUJDYlN2eUY0OVF1S2F5bmtmS2ZhMVQxUlZESWo5K0wvTmloTzhGVXZqZFg3WSt6OW9QbmpUUEkzVVZzSFpZZEo2WWlySC9OTGMzNTZORFVkNkoyQlhPTU9wNVdmc1hlVml2OXJmV3BzUHZ4bWtQY29XU3pJcVE4bC9qOGxwR1JrWkdSa1pHUmtaR1JjUlpxcm9vY1ljVElKcWFpYk00NFp4LzQ5eGhSOGRPemxHaXVETVhML0QxT3EzYUY3MkNremJjd0E4ZFo0YVBQaTRmQS80SVpzdXJBa1JOYUlsblhnSCtDRWRWZDRQOEFmaGp5OTlhQ3lxOEdzMFBoK2pIS1cvdzFqTHk1aGhrZkR6Qnk1d3FtRmx6SERJUk5qT3o3RVVZZXlUQzY2dDhkK085cm1LRjJ6ZHYxZFpLYStpbEpEYkpNeXF0NUhTTmJmb0s5cUo3ZzRiZGo3czdZTmg4N3ZlVFdNS0w1Qk04ZFc1Ry9WQ0VsdStja0JpZXVqUnUxcHBWUnBVQXQycTNmOTJzM1NTclBJZkNIbUNIcUcvN2RnK2F0MngrY3QyNHo2bHpIK3FXSHphbXBSalkvVnNUNnpIRFp2aTdsSFBBVzhQOWlmYi9xMStyNWQ3OUhNdlpJUWYwOVRLMTlCQlF6K25GY24vQ1pqS3N5Ukc3NC80K2QzSXpoMDg0ZER0cXZxVHpUTjdHNXV1WnQyQ0NGZlJleHZVOGlneFY2OFJCVDhCNTRIWDlFQ292OUxyYkhQTUlJWHEyWEprYUsxN0ExSXNYckc4QS9Kb1doazBMOEtmQUhwSnpYSDJndm1OWjNwZS9HdWMwb2haQjFxSjN2WUhOekVmaS9zTDFIQ3FKNHpncTI1citPellPL3dCVG5VdzFvWG84RmJDMmRNc2FHOVhibU9CYnQxdHVZazhVdmtnaUNBbk9zV2NiNlR1UnZGK3UvQjRTUTJxWCtrNkY0emV2M3ZFaVp6eHpPUTdpOGFnWjFKMHhHVG1EVm1TUWl4cmlzOWxTRmF3eGs3NGpUcWozVlVYTlorL0VhaWFBNURBcGdrVFJ5UU5HOTZRVGJzelpJenlSS2FUQWtxZXJsSENIRmI4dzFyT3VmYkthdzBSdlkvV2lFN1lFblhvNCtPeUFaclpWR1FTa05UckI3anNneGhZQ1hROHh4NktNNkZjcXRPRGRMWTdhT2tYa0hwYkNaQzE0UGhlcy9wV3g4MmVkdU1PaVAxV2JCYVdBWjY2ZkxJSURyRlVyMFpZQk56M2ZzWktJaVp3d3h3amZtMDEyY1JicjQvSkU2ZmNuYjFOM2MzWGtTanFsajVQOHpPZTFVMWNkSjFVaUlEckQ1UFVGaWgySk9rWjlNa3FJcVQ4cHBIYXQ1MitBMFdSVEpVLzNlTDMybi9sSGRsN3llSTI5RE05UnBpSVg4cm56ZTgvMGtra25hUnhwTVBwT29EUXN3U2R4Rm9wdEVESXNzMS93OFJWQ0g4eFVGSUliRWplY1BxbFNhRmVYb3ZqNVBibFdSNCtvalBhOW9EZlZLeDcvMGU4RmxvbnlmOXpIV21nU2JVd29wcm4ybU11OTVKNFJobnVmNUlhcUxwL1Y5M0k5bWxDSEhDRGxNeEJRbzhkM3lVcFN5NGQ0eWRnckIxdFJWYkY0ZmxkWk5qZVNFTlZKOVNZNVk0SkUzZkcxSDU4YTRiaFZ4cXZ5Y3IzbXR1b3p6STFNZEJqOGpJeU1qSXlNakl5TWpJK081UUVZQ0tUK3VZaTgxRDJlY3M0R1JFTDhFdkZ1MFcxZWNSSzFFODlidGdSditqekRTNGc4d01pdUdUZjRFQy9sNjArdlN4WWlGYjVNTUw4K0tHMWgrM1d2ZWhqV3Y5enVrRUlRLzhMcjhuOEFQSW1GeHdaQzNxNWlhOGJjdzhuV0VHVklIcE5ETWV5Umw4bjNWalpUbjcwMXNYQTVKTDVQN21FcjQzMkdFOFo4QmZ3NzhXNHhJL3l1TUZGTkk3UytRVkhwNEd6OXg4bWhzTUhCU1ppSDhQV3pldWkzbDQ5RExPbVkyK1NmaThOeVE2dGpuekt6K1huS0NOT0xQTUhMN1kwejUrVGNZRWRwMWxlYjNNSUw4NDR2VWJVYWQxUytIWnltS2c5TDJoM2tFU1FBQUlBQkpSRUZVekx6QVdEOUtJZjROYkwxZEl4RnZ4OWo4K1VOTVRmbER6REhqQTZ5Tis1eEJ4TWY2Rk8zV2F0RnVLVFJwWCtPQUthMGUrVEZqWTJKUWlKOXJyTDNkQldhZ1BtU1M0SVJKZzJ6ZnJ5K0RwTnF5NFgyeGh1MHJlNWd6dzBOc0RYMkFyWjFmOHJMMnNiWHdDSnNiSDJOazhHT1M0bDVHTlNtVTFra0s2Qk1zOUhJa1RLYzZLSGdianpCbDdjRFhrQXhNT2tkcVFLbjZma1NLcWxBMGI5M3VCWFh4R3JZUGpMeDlLOTVQVE90L0h5czVReXhVSGVPWUlOYUtkcXZtWWVHckVOV0ZNUnpsVFd4TTlqQkhrL2VBNitvajc0OVIwVzR0UkFjVG4xL0hUT2FRenpnRDV6R1VUaUhqWG1aSVZRNkpGR1Z6ZDJjaTNPczg3U2twMmlxaGNpdkN2UTZvTUVxWHlMNGFLUzk4SkU3V3BQeHpvM3ZmRGIwSzRhelFrVXFuOEJoem1CQWhPZ2hscitDaDMwa2trS0t5aUZEZUNHMDlKSVduNzVIMnN6VnMvZDcwdjJXRWora2pycElVcTNwRzBScXRZM2tsNjRHSVdIR0RlSnhmaTZXeHFYbi83bnM1dUpwd0dQcFpaTEw2Y2JGcVhGNVdlRDBqd1JpSlNEaERrVDduWEI3M2MxQjNTdW5XN0d4dEw0Vnk0dS9ZZjR1bC95dXZRVnFEQ3RrZnk5YjRYVWJFaGtoYXFteXBqY2Z6cjBTU2xOc2tBa1lFcGNaQjU4aXhRWHVIeU1reVNST1ZxMlVzWUlTMzJ0MzNNUmN4TFlKVUtrTzFJYmJ4MUJpSHNSeGdTdjQrdGpkby9jYjc5b21yTitWa3VSakdTMnA1N1I5TGZyNzZRYVR5clAyd0ZvNWJKcW0vOWQzY2M5U3YyWmcxcjczL3V2N1QwejVKMnEvcTVlUG5xY09yRHA4VEMwNldsdHNiKzZZOEpqRzM5Q21VaU9JTi96MnREb3JrSU9lU3luMzRMUExTdis4eGVUK1A5MFdsUWxHbytwbmpHOVQwc3pEeWRSb2pLK25lSzBjS2xhZm5DNjBaT1MvR2UrTUM3ckRxOVJ0aWF6WGVIK1dzS1RXMnlwQlRoYTRCS1FWVjNldWc4UjcvUDBjYk16SXlNakl5TWpJeU1qSXl6bzJhRXdoWC9PZTNNQktsaVpFblZjVHVRMHo5Q3luRWFSLzQrQ3dWbDVNU0c1anFUcm52d0FnUWhhNTlDeU1TRk1iNGJVNkh1VDBQampIQ1IrR24veEF6dXVwRmNNbmJJMVZQRXlOZ0tqMnA1MFVJKy95ckdMbjlHRlBFUFNRUld3V1c3M01EVStaSXNhTVF4emRJUnBnckdHa2xVazVHTFJrWG96RlhMNzk2Z1ZVTzRSdGV4ajZtNGgycm0xWHZPWlNBcDFTL0lUVHcyRGhlRG8xN1dmRHIvQkkycmo4TmJhaVRjbDhwUEhUL1ZWVVdldjdkMzhIbXp4cEdjUDQxTm5kRklraGxxdHpIRFd5c0ZYb2RtSXRzbHVKWUt2TlQ1T1paeXQrTDVBWDJNbjhGaXp3d3pZbmtJV2FBV1dGUzZmTVk2dzhSdmlPc243NkloWFVXdWF1UXB5TlhyZDhnT1ZPb1BlOEMvMFdwRHU5amF5VWFjKzlqb2VDbnFYNlg4YlZYcGN3dDJxMUc4OWJ0WGxUS2U1M2Y4WHJLOEMyRmtRZ2NHVVpIMlA3NERXeVAvQ3YvYmp3ZVJidWxuT0svN3VjL0JQNDRxdnhWM3hrcS9scDV6dmhZaVZUL2JXd2N2b09SUnN1aHJsZEl1ZFQvUDJ6dlhjV2lJSHpYei92eE9jT3ZaOHpBRElYT0t4VnFNQmhrUlpoV3FhQmlsSWlGMHJHNlZ3NmtHcDVENlJTVlVlTy93N1drd0lQMHZCSUpJNUVzdXZldVlPdmhpRVRxeE91ZHFwTzNleFY3WGxDWmQvMzNOZjk1Z3UzTmk5aCtVV0RQRXoxc2ZDTUJFTlZWVW5TdWtjSkk2N21oSU4xRFJPb3FsL0F4ZGgrVkNsQ2gzM1crQ0FTRmVOYStyT2NRS1JpN0JIS3NzN1hkS0N0UXExVERaNFhrN0tSUXhWQ2gwbjVlbURXbm5BQVRlYTQ5dmgvK0I4OXBLU1ZaVUlyUEtsZEtNem5YcWQxU25pLzdkZVJRcGJ6RHA5VFpYazR0em5uVnc2K2pNS1lxWnhtYng1ZmxpRGtWUHFaTjBud0NtenY5MGpHUkdEM1Z6aWxseDlEVGc2QnMxT2ZLVGR6ak5MbTJBRHdKKzh5WVRBM3FhcTBmblQvQzdvVWpMQ0pBVlk1VFBYTU5ObmQzVGoybmRyYTI5VHlpNXhTRnI5WnpSbEd4bHl3eHFYaFdkQTc4bk1PcWVSYjJvT2kwSUtjMTlVSGYrNjFCYWMxSnplMy95dkhzY0hONlNQYXE2K3NaUitOMGFYbHBQdzFNVzhQelJ1d0lLbTdOcjVPd0w0cE1sQ3E4aDBkazhQdWUwZ3M5bWJVZWZPeXUrSFhHY3pwOHIzdEZsNkM4UHcvQ1BxUDZkcWZ0YzhGeFNXM3VoNzFKOTV5VFRRc1BIdS9WNCtnZ3BXdEhWWDZEU2RXLzlqZmR3NjZRQ0Z6ZHQwN0MvNUNpZUJXeEhiR3RVKzduY3FMUS9WTjdzd2p2ZU44Y2gwelBpdUNNakl5TWpJeU1qSXlNak9lRlJUZkU3L3ZQL3daakV1RGZZSVRodnlpZGM0aTlFTzFoTDUwZlltRjF6M3h4OFJDeVR6RGo2TWNrSmN3dy9MeUZFYjVQTUdKbW83cTB1ZkJ0djFiTXZmdVBNY1hmR3ZDbndJZE9nSFM5M1YyTUdEK1QwSkxLcm5ucjlpa0ZtNU1yOXpHMTg1K1FDT2QxL09VZGUrbjdOa2FxZk5ucnBMQ01BK0IvSlJtYjEvejhRNUxCTHhKMVVUbEYvS3hvdDJTOE8vYWZrMHRRTnhOSVg2bEI0ZUk1R01kbGlsQU9DdE5va0Z2SEZNMC9LcDA2d2w3ZWo1aFVnTHlxR0dLS1pwR0QzL2JQcGV5OGlSRUNOMGs1SldYd2sxR3ppZVZsM2FzZzlHUjRnR1N3Vkg3S1VkRnVLVXg0Tk1ZdVZoSDdLcXRvdDZhcVlxZEE0WmRuZWIzZndPYnNrYmZuQ0NNK2ZnTDhqTWs4ZVJ0Ky9BRkdqajZCVS9NN2hqVVV1ZFBIMVA5cm1LUElBSnRuUC9McnlSQzc0dGZwK2J5TUtpeUZHTCtEN1NYN1htNlhaRWp2ZTI1bHNIRlRmbHpOVnpsdURFUFo2dE0rUU5GdTdXR09JdmVwbnVNS1g3Zmk3YjlMY3ZSWko0VzdYeWphclkrQVlkRnU5YlVmS0I5M1JibHJXQTVnN1RQM3ZXKys2TmRVcnNnVkVsbXg2dGQ4QTl2TDcySkd0ejAvUCtNU01NMjQ3TWJoVDdzNnp3SVphZlVzY0twdHdTQStrZHN2RUFoalltTE9NSmNOTitKT3UyY29IY1lKU2Iyai9hWlBJcUJrbU82RjR5YWN5R1MwcnJpR1NEd1p3ZmZ4bktHZHJlMm5mc3hUMGw3MXdEL3JsZ2pyNjM3ZFBWS2VWTzNqQ2tXdlBmOFkyNXU2ZnR4SytGNVJEM1FmMTcxVmFRbnc0K0tlckZRaVhXemRqMVhVbUxvcmhyNmNRRmw5N2Fxb0tzTjZ6WC9Ma0s4OVdCRWw0ckV6dzVOZUJFN0lMWGEydGcrbmxLMW5OVUg5Tjg0M1MzbyttbkJ3S0pFaThmNVVKZ1lHUHZjVlhsWDlJR0ozMU5uYXJ0ekQxYmVZbWswSzBhaXEwNzFlSkZTWEZKWGkwbEZ5c0ZnaTNRdkIxMVBaZ2NJSlNIU2VpTnlTQTBHdFluelVSM1VzNzJkMFdKUktVZXRGNTRyTVYzanRxT0pidzhaQ3pvWk5VaWp6ZmY5OTRIVXVFL0dhdDh0KzdsTFZmTjMwc09FKzM3VS9ESERuenlsdEZua2w4aTArTzNkbjdJbmowTXNrUnhHZEp6V2psS24xemNud3pOcTN0TDYxWnlvVStRUm1FS0xEelpRSFdQMmlTQXd2eGZQOExHZXJXZmViMGh4ZG9EcmtjZHdmWXhodlN2MHljWjhqa2NJblp6bER1UFBKUGhabG9hcFBkWC9vUGdQNUc2UHA2SDdlOWV1WDcrZmFCeUhaQWlJeFBDYUVTMjJiUnY3SytlQVlmNTcyNDVSemV3TzdQOG5wdkVHNnQvZEpUam5hSThZUktpamxzdGM0Vm5SRGpMeWovVjVPYVhMbVZGdTA3MEJwenk0NUZNVStlMldjSWpJeU1qSXlNakl5TWpJeVhoNVVodnAwNGswcWtML0JqUGNmWTRiRmg4QS94ZFMvMXpEQzQ3ekcvSEkrcTBGUXNDbjg5RU9NRkwwSXZvTVpKVmN4Y3ZWRzZmdGZ3RlNERTJSV0lERWhLZSttd2dudHM1VENNY3poS0h5bWw5M0M2eXJEemhKRytOMGs5YzJ3YUxkNjNvNEJ3WUE0RDF4MUtBVmd0eW9mS016T2F4clFLTm90bXJkdWQ0UHlWOWVKaXVTNVViUmJhMWovdk83LzMvSC9EMFJjQmlKWWMrZCtCWWw5NE1kT0plOHZvbFN0T3Q4VnVtcjdrRENITHdNK3R4NWlvYjNYbVRTcXY0Zk40Uk5zZlI2VGpJN0tUU2NsTE1EUGluYnJrQlFPZVkra2dJMEdqbFhNQWVNbkpBLzJZNUloWitSazRiUzVWdzdQV0FtZk15dlkycHduNU5rSzhCRzJYbitPRVp0NzJIaEw0YUtjd3ZMd1B5bmw3TloxWHZjNmJuamJIcEx5MXk1aDVPbzZwbUw5S2tZQ3k2ajFkZURYaW5icmZlQ1h2VTd2WThiZ2QvMmNyNU1JMm4xc24xbkgrdmtvT0RWc1lPcnVQcVpram1UN0tGeXozTmVGWC9kd3lqcitBamFPOXpESGw1dGV0cUlOOUxIOUJsTHVzNmRGdTNXWEtYUFk2eXVDKzc3M3lYMy8rYVovdnVlSHgzRGRhMWdFaDNmd1VMWGV4emVLZHV2QlphNlhseFZuS1JyUFU4NUZ5bmdWaklXQi9CaGhCdDlUOTkxeVAyNm04TUg0LzhQTzF2WjVvMDZJS0t1WDFiKzZoaE82Y3M0NElhWE1BTSs5R3d6emtJaVVvNkJValNxNnhjN1dkc3hwdW9UdEhYdDRaSkxOM1ozam9IVFc5ZGV4L2ZzUnJtQXFrYi9hLzFRL0ViWjEwbDRwZFYyZFJEQ1hTVi90ZzdIT2VsYURaTnp1WSt2N3hQOWZDV1dJVk5OZXBsQ2ZCVWFheVNHbW1FSlluTHFQQkhWY2phU2lHa3c1OWlwbThEKzRMT0lvcXVuTDE2dW9lNDNwNU9RSlRKQ3hVa21YMnpsVytsVVFnNk5RbndFcFIyWGZ2NjlhUHlLZGhpSi93NXFKYTZvcm9yTkM3VGFoV2c2Zkx4SlUzdk9nazlUK2NYMUVGV2dkME5wYUNOOUw4VDhSRnJxenRSMzN1ckl5TmM0ZGtXcHkwdER6NUhCemQrZUprL3lSYkZVWTdKaExlQ2w4dnhiS0g5Y3pPb1dVMmgzcm94RHZ4MkUvR085em5aUkxHSktpWE9rbFl0a0wyQjQyY21LMjhIRmRKaW4xRlg1K0d0U240N0dOODg2ZERrU0NMV3BlZTMyVngxeDVVdmVaakU0MGdhcDVVcHJqZWpjNjE1eWFCNWR3UDE3RTV0dUVPcmxLQmFvMmxZbDZiRXlHZmgrb0pNS3gvaXl2K3o3UXIzQVc2R0Y3L0x6dlhzTXA1YWlzbnJleHdmbFZxWElta3VOSTMvK2VnSmM5Q252V3FiblgyZG91OE5EUTB4ekJTaGc3SEpHVXgvRTRPV1hFME5SeWxGQ2Y5MHIzR2ptb0hIdWRvcVBETXNraFNBNWdJcUhsTktYOHgrT0lCa3c2ZEIrUmNsNlhsZEhhVCtJOWJ1SzVKeU1qNCtYQlJkL1RNakl5TWpJeU1qSStMU3g2dnNkUkJaa2daY0Qzc0plVU94aXA5RnYrK2R2Kyt6ZUFnNkxkK25DV1FkOUptSFhNV0xDQXZSVHVjZnFGNXJGL3Q4TDBzTERUOEJBalhMNlBFVmszbVZUL0Nvc1lnZjBncWszOU94bmZicmlLcjg1MHNvV3F6MTBaREVtbE1WWnYrTytiV0R0bGxIMUllcUdVS21lSXFlV2VGdTFXcjNucjlyRXJpbnRZaU5aUnVOWlZrcXA0SFgrUmJkNjZQVFlFTm0vZFB2VVM3dWZIWEVmNnJGY09EK3ZYa1pIb2kwVzc5VEVwSk9FdzVDSWRCV0pZaFBKVUEwTFJicjJPT1JLY2tOU3Q3Mkh6NU4rRytvc0lQc2FJcDZuRy9qT0lwYkZYL1hrUWlPNkZvdDBhWWdUZ0JqWlhqb0NmRiszV25lYXQyM09Gdkp0MW5WRC9BcHZQYThCLzQzWHZraHdhUnRoYytxbi92NEt0eTArd25OTkxHQm40TmthYUxtS0VzWWdFa2ZnYTEyc2tFbFg1ZFgrQXpjdGZBUDY4YWl5OXZuUDFhUWlWL0RVbTEvZERVZ2hHRWIyL0diNC9Kb1Z6Zm9LcDRPSjExL3h2S2FISDlTdzVLcnpyMTlqdzR3OHhvdmFKMTJtSnBPcjlCWXpRbFVGVG9hZ2JHTm43aVYvdkFDTkZmNG1VTy9pSVJMS2ZZSVMwNmlTMThwdit2OXJ4RVdtTkxZWHp4MmpldXQwdjJxMUhGWDM2TnJaMi9nRkp5ZFFnNWZ4OFJGTHBpUnk2N24zZDhPK243WEhEb3QzNkNhYmtiWG9mZkFuYmR4NWl6a0VpcUJUbVRpcnFHeVJubW5XL3ppcHdyV2kzOXFmdHE1OFZCQ1A1TTVkVC91eGxNelk4YTMzY0NEemVQNE1oVm9wYm1HTGtqc1NLRXlGVjRXL3I4Zk5BOERZd2Rkc3Bjb3ZKTUtTRFRnb2xleFRJWDZtMXRHLzB3M1YwVHg5aGEwZmhPK05lSUtldUU1THlxTkd4RUpoZFArZWFIMytFN1Rmak9kVkpZVDBKL1NVanVGSUVIR0Q3cHd6UUsyNWdoeFIxSkRxZWlLanMrelZHMkhxUFVST0dmdTY2bjZkbmpDY2tweUh0NlNjaVJQMnpKbWJjUDZoU3dsVjhwbm9wTjZiNjc3Q2tSb3pmeGZEZGxmQTVwcEMyVS9jaW55dktZVHh0amtkSEFFSDVjNldBaS9YUmZJMWttc2pGZ21xVllGU1FqakJpb29xUXJaUHk0a0s2SjB3Y1A0WGNHY1o2eldxZnI0ZGxqSEEvbm5mOSsxd1FxYWo3Zys1TFVvNnF6bU5WNHJTeXlwK0ZQVGVTOXVOdzZVN1VpRUJmd05hYm5wZVBTQVI4VEwrZ05BZDcySnpYK2xMZHBEcXNuRWRlcDZaZjk4VG5iZmw1VVNwM1NFNTQ2cWRwRVFUa3hGY1hhZWZISzUvd0loWGhsTFcvYnFaOHFURi9jQ1IvOWU2bTlWVEhDTVI5S3NqYXpUbkRQazlEeFI1OG1WQXU3VlAzaUxOUTJ1c1YrbHNxelJpR1B4THlzYzgxZmoyWTNFZkNPbExZYmQzelR0M3ZLaHhDcXBTcHA1VG5vUTBiNGY4aWpsZEpwYXgzeWFOeU9UTVFuWFNWRDFmWGFvVHZHMWdmSGMxWXY5ckhxcUpwbkhKRzhYV3R0QWJMMkpvK0RQTnlwSHRlY0hiUm1qemV0REQ0dWgvRTBOUXhqL0VLS2YyUzBpZDB3L2N4M0hxOG55LzZuaVBuazZqd1ZuUU90VTExaU02Z1phZVdjOC9makl5TXk4VVV4OVJaeDhhb0dxK0VnMjVHUmtaR1JrYkdad3N5SkZWQk9XbnZZeThwcndPL3hxUnErTmcvL3p0WVR0OUtGTzNXQ3ZBL0F2OGN5eC81WHdQL0xhWWsvaUxKdUFuSmtQbXJaOVQ5SVVabS9SbndyL0N3aWY2NXdoQ3VNVnVkWEs5UWhOWXd0ZHQvNmZYOEg0Qk5WM3llaWFBTWxkcG1uQy9NMGZXNjZ1Vk5MOFJTQkx6dDlkN0hYakMvZ2hIMUl2OUdtQkt6WHJSYk43RVF1djhkOEo5aHBNeGJ3RDhDZnQvNy9TeGM5L1BleE1iaGk4Qk5iOGRyUmJ0MXRXaTNycEFjQWdhay9JVFJJTFdFS3c2Y2JGdjA4cTRYN2RiMUtYMjFoQkZVRDdHWDdDZlluR3N5UGZTM0NNQkl0RStGT3poRVRDVmpvcHBaL3hmdDFsclJicjJKOWM4cXlRajZObVlRWDhWSXduOEIvRmRGdTdWWUxxZFUzclQxQmxTUzExS2Z5WENnWEk3NkdYbmQvZ253K3hnSitmdGVweTd3bDFqL0htS0VwY0psM2xSZmhHc2VZT3JmSTB4SitnV005UHNDS1lmVlplQUVjOUxvQUgrQXJkOC93OGp1ZncvOFN5eC83UDhFL0JBenVJb0Ezc2ZDb2Nhd3lUTFVQc1htcGh3bEltUUVmdUpsL1JUNEM2eFBucEx5QXNmSUJQanY2eGlSdVlMMTBaOTZIZDl2M3JyZGQwZUxENzFOUC9PZm53TS9KbzNkU3RGdUxSWHRWaE5ibzMrTEZDTHVHcmFQWGlVcGs1Uzc3QlFxNW9nVVUrK1J3ai9IL1VwaFd6OGdoZE91ay9LUUgvcDVTMHpISTFJNC9RMXMvbi9OKytVZC8xeTU1Um9rd2tzR2ZCbVplMzY5YzBVeGVKVngwWmY4czRqamw4MTRjTkg2bEpSbXRjN1dkajBRaFFxVE9zVEl0TW81dW1saGRMVS9UY3dyTjZpdUFhdWRsQ2RZaU1SaXZaUEN2SjVxazUrcnZJU2pRTHcyUXhram5BZ05oTUVLS1Irb2lCcU5iWUh0Ri92WUducmJyeUdpYzBES2Z6NGtoZjF0ZHJhMkY3MitON0U5NU1ETDJ5UGxGQmVwczA3YUcvU3NvWDRkaHVOMGoxc2xrU1VycEVnQ0NnMTk0blV1bUx3WFJaSjdoS2tDeTNsYTVlUXpLUFZ2VkQvV3d6eUk1OFY2RjV1bGZNSmUzaEZHME0rTTRPSll3ZWJHUnNYY21NQm1LVlJ6QlVUU3FUMXlDc0EvWHl5MVI4OTlHc2ZvT0xnNGhmeGRJTXhCVG9jbGplR3hWenRiMnl0K1RlVjhqbldiMms2Y01OUTQrT2Y5Q25KUGMxeEV4ZHp3OGRHenNod001UXdoQmZtQWxFcGhxaHJSOXcwNXJqVkNPOVNIS251c1dDYmRZK3ZoOXdMbUtLSjdsQ0ptYUk2TDVKWVRocDQ5OXYyNEUyeHZxT3FMT2paMmNyaUlkVjhJeEU0TVFTMHlhT3hJUmlMbzR4Z3FmL2N5S1ZYRndtWUtDOTN3YTlSMVRTOTNLY3dwNVNRdXo0M3llMkxNWDZveGV1a1JuSVJFK0YvRU1hdkdaUGhsOVZtOGhnallzZkxYOTlBcjJMcnVsZmN0MGxxT1pIeTl2RTY5ck9YeWZhcUVGV0J0eWhyWHZVV0s5dFdLWTFTZnNRTFg3elVydnI5TWhiZnR5UGQ4cmFtR255Y0hTcTBaU0FyMWNqbFJRVjdPR2IrSTllVmFaMnU3V1RwVjl6SDlUTlEzN3VHK1graVpWVTRoNnlRbkZLVjdVRFFQelo4MTdCbFllMEljcHk2Mk54eVRIR2tWaVdQOEhFTjZINUZLdnhIdWR6Rzl3VGh2T1drL1VEajJxbnRrUmtiR3A0RGdwTEk0NjNrcVFPdFhQN1ZwYTlmMzNQSFBwVlU2SXlNakl5TWo0M09QK0NJMmdlYXQyME1uTnFRTS9FYkZZVEkwdkFmODNhTGRtaUR0blBEYUFQNDJSaFRjSUJrcUZqR1M2cDhCLzNuUmJsMTN3dkkzL0xPM21ZNGZBbjhFL0QvQXY4YkNzSDZNRVF0M3NSZWtteGlwc2xaZHhGaUp0bDYwVzQxQXpMMEIvQzcyZ3ZlYTEvTXRZS05vdDY1TUkvY0M0a3U4REZraWdXU01PU0FadUliWVM2cHkvRDNCK3Z1cVgzOE42MStST3Rjd0V2MmZZa1RmdDdBWFNMM0kzOFFNRXRjeEFuY1dxUVBwaGZjOUwrOTNNTUpQMTlRTDdDS015U2NaRXVzWU9hMlg3clh3czBFaTk5ZUtkbXVsZ3Z6c1lXUDUySDhPc1hINUhqYStwK0RYbDFJU0o4THJWY1RybExHYWFxeUt4SnFmK3hybTNQQXV5U05maHM2Yi92bTNTSFAxUFd5dUxNUnJGKzNXbDRwMjZ4OWgvZnNMUHRmbDZEQVBSS0RKY0wvUHBCRk9SZ0xWWC9uOXVoalIrVzMvZVI5VHpoNWk4MnhjeCthdDJ6MXNERVQwRFRCaStaOTd2WCtGNmM0aWM4UDNsYUhuRWo3QWlOS1BNZEwyRTYvM0JqYUhCOEIzTVZMNEIvNzlQVkwrYkJuTnBKUVJUdVh6Yk42NnJkRG0zL04rK0EvTlc3Y2ZORy9kN3JrS1ZjbzZoYTdUZW8xR1pKRUw4dVNQeWdpUjJuL3FkZjRJMkhmVnI5Uk1yL21QRk83NE5hNWorOTVYTVdYNVcvN1pOYVlZNk9KYzliLzNzUEdPaWluVjZ5azJYKzU0SFcrUXlPWTliRDdKNFdPV1lmR2gvM3hJVWtNMVNRcnBkYSt6VkJWeWdPbGg0L3VRbEpmNDZGVUtBZjFwdjRTWHZNVmZHVHhyUDdseE5wSkt1cGZxM2hrSk5obkQ2K0g4ZmdWeHBubW8vVHNpem5kZFp3S2hUU0tPRGwxNUpLY2NHWGpCak1XUndMbkNwSFBITVI0eXZtTUszemV3OWQ3QTFzOEthZS9UTTRIQy9CNlJuTURLSVpHVm5rTnJFZjliOXdjUlhpSm15K29pS2RsaVAraC9yZlZGcjUrZWErUjBVNFJyOWpaM2Q3cE9BQnlXU1ZnWjREZDNkNTRTUW9QNkdGNE5CTDhNNFJwZkdjcTE1ODhpTUtQeTlTd28xK21aYXVHejROZnNoVGtvWWpFNkppeVY1cE5JK1dWU0tGS05VUldrT090dldvN1lVWWtNMGpPbHhub1ErbnhNU0hIRzNyS1o4bTZPODYrS3FLdzRYRTRCOWM3VzlwbkVXc25KbzhzazRkc2pxYkYxSDQrZlRhdXYrcXVPRWJoUllUT2lwQ29QNVV0eEtzY0NHWFN2RUVoVUhSL0tVTGxTK2trUnFERTlSWlJ0cHJEUVplSityRm92N1YxNkpqa0E5alozZHc0MmQzZTAxbFp4a3EvVWR0Vk41RlRFaXArbjYraGRCU2IzeGhHVEJHa01PMzNrUHdVcGh5cGVsOVZBWkw5MDhEYnJPVDdXdlJLZHJlMGx2NzlFbGRkSlNhR3MrVnNQeDVRSlhvWElYMmJTK1NmV2JSajJ6VGhQRmlyV25PYnBOSnpnampmZWprZ2lLQlQ0VSt4Wi8wbFZBVUVWSGtuYkNXZm1NMGhvWVVSeURvNXJSbk52WERlZk8xZEVNdnVlVlpVbW9FeW9xajR4NmtWMHZwbEFlRjRRZWF6N3F1N25jcmdZQVRHTmdPNjFjdUtvK2JsTjRFYkgwakNzK28vSVcvM1dlN1BhTDBkeGxhMzdiNHp1SUNmSldqZ3Zrc0NxMHdSSmxFbWpqSXhuUjRtRVBmVzg2WHY5cWZlS0dXdFA5NStSUDZPT0k3ejQzaGNkQkdjU3haa2N6c2pJeU1qSXlMZ285Q0k4S3RxdGFhRjZwVkM3VnZGZHhKY0JpbmJyWDVPVUdsY3hJdU9kY054NzRlOFBTUy9RRy81N0Z2RXIzQUYrSHNJYTd4ZnQxcDlqWk4wdmVEbGY5KyttS1VsL0dTTzFlOWhMWEsxb3QzNk1HV3RGbmtGU1RyeUdrUmczTUJLdEVpSEhwenpzOWJLbThpSlJGME0xbm1DS09xR0x2YURMZVB1NmYvNUxtTkVZRW1HbDhHektBL3ZJeTVPeWIxWklOZVVlZmN2TGVCTWpBay84T211WVlmbUgzamE5MU9xbFZIOUhRa2g1RFZjeHNrZGhyU2VNbXFXY3dZWFV1akYwOVJSRTQ1WU14ZThDWGM4ZjNBdUUzMFJaNXlDZFZLN21wMTdBbDBrS1NFR0dkTTJic3FwY1licmY4Zk0rQUk2S2R1dmZUUXVQSFhJTjEwaEd3QlZTV0Q4WjQwUWVhRHlHMlBndCtUbHlMamdPYlZLNHhRbDRlR0VaTE5RdUtXeXZrbklDWHdvOHRQQWhOazhYdmI3NDM5L0U1czhUVENHMzUvVVdZYXY2VWJSYk1zQ0tMRDJpRkRZdFhGTnpzUW94MzZmMlJsMUhQOWV4TmZJSUdHaWN3amdPS0lXcjgzYnVrWXhITXV3T1Eva040Tzh4U1VoOUQzaFF0RnZmQm9ZeFhISndNRkE0Nld2ZVIzK0VqZjgxYkU4Kzh2OC93ZlpOdGVrYlhzODdKQ2VVQnFaVTdwTENnVC9Cd2xjLzlEcC90Mmkzdms4eWZIOFpDMzlkeC9iSVBWTFk1OGNZdWErMS93VnNqenFZTnU5ZlZseTIyclp6ZHJqa3o5U0x2VWluYVFxK2lGSW9UZDFUcXRadE5KcWVGVVpTaE9Vd0tEMUZORWRTUnFGdkZicHhCVFBhSC92MWU1RWM2MWdZVkVIaFdnbmZRMUx2eWVEYnhQWUJoV2Z0WWtTeDJyRUVORFl0ZDJDZFJMNk1NQktxRzhvZFlFNDArcjRXcmlQSElmMkc1RFEwRE1kM1NhVHFDWk1PTnZpeGgxNUh0VVAzRVpIVFF6OHZxa3pINUhQVnVBZmpWOWx3cjdZTjhUblQ4WHlRSklYMVhIUHBMSGpZVUpFZ0l5ZWdHNjRBblJ0T3hKVkROc3VKU00rQlVsbzNPbHZiTXVaRE12U0o4T3lIY21NT1lkM24reVZTWXFsam9WeEhQamMwUG1QVmF5elAvN3hJMzQxRFMzdFo0N1hsWXlUVmVweHZWVkI0OEs2dkphMDF6ZGxJM3M2YjF4U1NzK1UwbGJEbWxneTYyaitVRDF0clFzVGdpSlNIdUR6ZjlDeWtaK0J4QkJ6L3Z0L1oyaDVXcU5EM1F0dFVweVpHTEpiRDA3TzV1MVBNdUZmb0dhV0xyVTg1elVoTkxRTnhQTGZXOFh6bklob0RFYS8ra05Qc1hqaDM0SFdNSWZyalhxTTlWZmx0bjg2N1B1ZTRGMTRtQnB1N080ZWF1NEhFckcrZURpVS93QndBb3VPQVNOVkZkL1RvdXlQUFltZHIrM0Ywc2lnN0pUQkp1RS9rQ1M1ak00VW9qbEdXTkMrNnpDQ0FLOVRGQzFqRWlHUC9idDQxcFhxUG5VNUk2MkhWeXp6WW5CSHkyL2RYaFRpV2MySjhqNG5QVm9yMlVlbmNFeHlCTkwvNzJQeGRJKzJsU2prd3hKMTdmTi9VT3R6QTlzdW5wUGNFT1hZTU9sdmJlK0dTVXVxcUxVUGZ0MFg0eEFoRXVtOXJ2QlRLWCt1eHZwbENUS3Z0ZWk0NUlVVXRHUGo0eHYxOUZQNk83OTRUQkhnSjlZNmxiVGdyYWtWR1JvYWpSS2pxdWEyR1BSdjJOa3ZPS09YN2N5ZWxiem1WY2lFNG8xVWhPbjRNZkI5UVhlUWdFKzhwdFhqOEJadWJrWkdSa1pHUjhUbUV3dlRxaGVhVGltTVdnTzlnYXM1Zm5GR1c4bkpLRGFyUXFWL0JqQlBIMkFOVmZISDlZMUlPcnFtNXMwcjRLMUlZdEFpcEl0L0JWS1Y5VWlqVkkvL3VZNnk5WGR3UWd4R3IxMGloVVorU3lGdXdoNnd2WXdUWS80emx1eTBUZk1BNEpQRVN5Yk80UzFManlxRDRDVzVjVmU1VXo2ZjdKZXlsdWlDcGZSNWhSdGRqakl5NWdTa2dEMGc1VFBYelI2VHdqeUtVNXpIQVBQTGp2K04xK3lhSjZKVDY5dzFnejRrMm1NeDlKakpTb2ZzMG5zckYraHBHNE9sbGVPckw2QnpFcjQ2VCtsY3Z3aWRZUHczODkvMmkzWHBZUlRKTkc3c0tqTEF4VTA3cUdqWkc3L252ZU53UUc3TWZZT3VnZk4yN3dGOWpEZ1JYc1g1VkRycHBiUnpGMzA0Q2ZwTms0SmRCcFF6TjNTZVlvVVdoeWdvU09UbWEwUWN5VkhVeEI0MFRiTjcxc0x5dHhTVXJOMFdjajdDNXVJR3RGK1d1YlpEeUlCZFkyUGFvc2xmL3kraHpqSkhFbWlPTHdHQ08vT1NycERta3ZVcDlKdVZlM3orL1QxTFhMUlR0MWpET3RmSWNDMlN0MW85eWtLK1RsQVRsTUl0RGJMLzlNaFpLK3FCb3Qzb2tKWVdNUDI5amU5aFQwdjU5Z0NtUTczcS9YZmRyM2ZlakdaODhBQUFnQUVsRVFWUTJmWXpOajZQUTkvaDNQV3k4WDhNY1VvNHdJanBpaERtRlhQYysreUttcXI3bjUvOE1UdWYrTHRxdGp6QWkrM052a0pyVEtIZHAvWFJlSS91ekdPVkxpaWxockZRNXE5eGc5STRFNUFLbG5LaHVmQi9NS0M4U0pDSjc0L1BIV0drVERmdVk2bFFLU2htQWxpbmRVenNwM0tjTU5pZXhMdjc5ZmpndnF1MUVMaC80NTAzU00wS0RwTURUT2xjNDdDT3ZveHh4dExlb2Zzb1pIQjJZUkRhdWtpSWM2RndSSFNLamp6ZFRidU5WTnlJcmJVQ1RGQVVoRXBWSFRLcUdvNUZxS1p4ekNwMFVWck5MaWxRZ1kvdVlxUER4RVZGNEtlUnZLRnVFWm5RWXFNd2JQUU9qY1A3UUNiWlJJT3BqR004WTVsOXpUUGN2N2UyUkJCMWZnNUlTMXZ2cHBMUXVSajV1V25QL1AzdnYraU5iZXAzMy9hcjZWdDNuOUxuT2pYTW5OYUpFU2lSMXMwelpVdG1SRFFleFlRUklJdVJURUJ3a2YwQmFDZEl5OHVHZ3YvazRTTTRmRUFUOUpVQStKVUVTeFlFbDI0RTNGU2tTYlpxaUpISklEbTh6UTg3TXVmZTl1cTc1c05hejM3WGYycnU2K3B3em95RlZDMmgwZDlXK3ZQdmQ3M1U5NjNsV0JKb2tUenZYV2tzV2dMTFNHVWtWakNDVS82eDNNd25IbGhZQ0p0cm5HWCtLSkZFOUJYajc1M28za2pkV0VNT0VCQVlMeUJXZ28yZlRPVEdYcWZyTWhDVC9ybmxaZmFsU2xyb3hzVWpTOUpMN1BjcmZvLys1NU96Q250b1ZjRmhzYmE4STdBdU1YaHpJenU4MUpDbVhWTjVQTitWRzFiaTBRV3FISlJnNVhmTWxZQi9YSkFJbnkzekVaN1cxandLZzhycGVEbjhyWUxVTWNvejlSSUFnelh0U2djZHFJNGNON3c0U20xUDlkK0tnNVhKaE9YQUhBZHpzK2ZjS0tLbnJTM1BQcFc0ZC85RmVMZFpMcFYxbS95c2dSUUdzVXJNUkt4aXFBWXRURnA1TDQ1dnFiQlVMS0lodDQ0UVFBTkx3SEV2aE9LbE9DUkRXZVZMb1VQb0NCWkFOU09QN0JqYmZqTEpuMTdoYzdwV3l1dEthV1dPRmdwRTFmbWc5SFlQTTJ0bi9DakpSZ05zS3RnNllGQ20vdS9LaVN4bWhSWFhmcmFDTFVxa29BNi9pM0w2d2hTM3NEQXZyK2RnSG8zOGlYL3Zua3ZJYVYxclluTjJyRzUvRFhEUU04ODFBZ1ZrNkxweGJOeDVXMW9selBOZkhMbVhRd2hhMnNJVXRiR0VMKzh1eFpkS0c3bFZuZmoyS1RETVNDS1lJOHpmQ2QwT01mUUx3QjZSY3J0cjBEREZRK0FRRENEYUJMMkNiU2JGV0pITzR4bnlBWmMrdmViRzN1ek5VV1RzM2JoNzFkbmZlOCtzUE1kbllaMG1nR3hoQWR4WGJTTzFqY3NmWFNjN1VaL3pZZXlRbmlFQ2x5SVRVSmpBVnlwaVRpZ1F1Ti91a1BMNGJHSkR6dnRmUHFMZTcwNWJVZG05MzV6c2tscFBBUVVrc2p2eThFK3g5cldLZ3k1RmYveHRZN2xaSXpvWldCRXBuZ0M3OXpvMmJwODdFZklDQmZ0cG8zdmM2L0FRSkpMK0xiYnJsQUJBRFNSdk9peGhJS21mQnVsL2pJUTVpNWVEWTR3SkM0YnhKYjNmbkczN3ZpeGhRK3JYZTdzNStmdTF6M3VzRWVKUEVMbjBlazN5T3pGQzEyWFdNVmY1bndNQVpuMzIvM3hMV3BucFlYYXhock1vUnpGY0huUnMzdnd0OE4rU1lscHpmcjJMU3dXcC8veHI0WlZLQXdNOWpnTncvN2R5NHVhLzcxZDNEUDVmejR5dis4UWRZdi8yaGYvNEM5WUVpajJzSzFGRE9ia2hnNW1VdnV4eEhWMGg1TGVXY1VRUTlCR2RIZU1aVllOVkI0eE5TYmtzNWpjUVl1Qkt1SlVkcEQrdXpKMTRtQWJhbmZ2eEZ2ODc3VkFHT2xyK242R2djK2ZzKzhZQVA1Zm1XL1VwV0oySnZkN0QzKzIwU2sxWkF5d2g3UDVJRlA4SGV1emFza2x6V09OSWlNWW43WGs5eXVFVlFmVVJTSDdnQWJHaXM2dTN1aUtYeHRwZnhsekNnZW9BQndPODJzWHV6ZWVYSHdqNk16Zk04anRzNngrL2pncktaWS9CRHRSbmxtelE0c3lzVzJLQmpCemZreUcxbHg5VUJLams0R0tVME5UOHB5RUx6ZEY3WGtxY2NPaURWSitYTlhjSWNyUUpxNVBCUlh1c2NiSXRzSUVtMHI1UEduMDJTTkx1Q1MwWWtkakNoM0dJV3lvRXRocWZrclUreE9qNXg4RTlBbDhZS01XaWpnNzJOTWR4T25hVlZNcWtkaEJCYldQV2kzT3VqY0V4a2U3YXlhNmorem1LRHRoMElxTHhydi81U3NiVTlWOXQ1Q2libm44Q3VkWXpsZHRSTmJPeFdIU0FjbklBNXNDbFcyTUNmY1ZnNHk5aVAwM3BQNzB5QWZ4MW9ObW00ZHgyN09ySUhKZDBjZ1lxNUxRQWptaXRMaGlxQllUYnZPL0pnaVR5WUl3SVk1Mld0dGJHQWlkTVF5TEhxMXhtRVkrUXdIWHNaMUIrVVFrT2diWlJEVnlEbzJBSE52dDlqNk9VZGh1dlhCcU1VS1hmNDBGbVllbGFsQVZHWm1wNTVBMWpyWnF6MEdxYW5QcC9LUWV4bGxzS0s2a2NCSDVQQWJzU1BtMnJuV2IvVTlYUDVjWUY5K1BWWGNtRDdvekt4c1VoanBzWndLZURFQUpOVFA2Y1NhS1ErbjMybTYycE0xbnBVMThxZk5jb0xpNVd0K2hjak53ZEdaN0hZTzlqN09jM21HN1cxRHZaZW8rcUQ5aUZUYlNaN3Jpdis5NTVmLzZHZnI3UUVrT2FXZm5jRys5ZXRRMkx0SHZtNEZQdFhMSGU3RytTMWF6Nkw2MStOWnhwZm8vSk9mTVl5d01ZRHhwU0NvWTMxdjBteHRiM3ZkYmlFamZtYTYzS0duY1lQemJkaTdzYWdrVGJXZjVTV1JzRmRDbDZLNEpMV0pYRXRFSmw5RXgrbmRPK29mSlRQdWFVOHRBTGphdXE0ellJUnZMQy93bFl6TCtackVPMFpOTVpOamVjZWpIVWRDOGJjQyt2Z2EzN0lpR3E2aU56V3NQbThJcjgvWjZCaExIZXVXRkViR0xubzd3dGIyTUlXdHJDRkxTeWFtQ1RQWWhLNkxlRE4zdTdPUTF4R2x5VC9keGNEc2Y0Q0E4SytnSUZDRi94N01WMGdSY1Nma3ZLSzlrZzVMY1h1ZTlHLzM4Y1dUNXRaK1k0d2NMR0RBWjZQU1BsQlR6RFEraDV3NUtERHYvWHozc0tBa1pmOC8zZXhqZDBRQXk1K0ZnTlZCQXdMekh6WnorMWhvT2ZFeS9hK1AwT1o3eTVJOU1waExRZVpHTHdDd0R2QTUvMzZGN0NjckdMNHhvWFpqekRRU3puaG5xZWFKMmhNa3F4YXh4ektkL3pjS1VuVjN1N09abTkzNXlBQWtFMVIrQzJjRWVxZzJTa3BMNTRZa0c5ajcwazVBRi8zNTdwUEFyVHAzTGc1Nk8zdTNNZmU0NTN3L0pJUVc4WnlCcCtFdWlPckI1Vi9pa1U1Q3lSMUVGdk85c3ZBMzhZQTB5V013VGc4ait4c2xLZjJldEhtdkE3OGpSdHlCVEpJZG15RUJSMjhSZ0xwN29Ycm5CZVVsaFAzSkY0aldNeGZKYnNDZEhxN093ZGtnUUhBaXNzaXc3UXpZWXk5ZTBXK2w3bk9ucUpOU0N6ekR0YStsSWY0RGpidURFaXNnK2c0RWJ0UElNZEIrRTRtY1BjU1Z2Ky83UGRxWStPQzVKaWZ4Y2FiTmluWTVSMHNrRVRzbU92WW1QSXN4bzVWNVA0YUZvUUJsSkxQY3ZBZVkzVWVHVFQzdkZ5cldEK1huS1RHSVRtaVZkK2Y5N0k4WkpwSnB4ekljbFFxb0FiU09QU3UvNi8zV3JhTktGM3RET014VnY4VGJMeDl5Y3ZYOXI2azlpMVpjWlhuQmErZlZtOTM1eDMvckhXZVB2ZHh0YWU5Z1g3YzYzMlU1MzFVejV3N3NHbFFpYWc1WDZ5NUtMVzI1TmRVenRQS2RkMlJLcWVzN2xQSHBDb1p3ZTZ3bm1COVdjNWVBVEVDQWxZZExCV1RUTjhwQ0dlSU9XYkh4ZGIyTVRiUFA0ZU5Td0tZMUsva3JJL2drQUkwTkkrdWh1T2x1dEVqeVhQcWVPVTRqV0NHZ3N2SytVdk1nd0FjeXpSbWlhbW9zVlhzMWhiVjhXVFY2N2tFd3JxSlRkeGtBdDlLcTNuWE9iTk96N09FeVRYM2VFSUxETkV4eHQ0UUV5eW1ydGpFV0h0N1RhekdibUFUMTdBQWMvWm9MZ05keS93TjlWem4wSzhGSHIxdTRtZFMrWm1MTlpLWjVsck5TWHJXV2FsRkt1WE1IWk0xNVJYNzlEejVtM1d0WVdGeXlmRWVaYUNEc3dEamM2ODVFQlRYYlpCQU9MSHF0TDZTUTFoMUdoM0R1dWFzZVU3UEpuVUJ5YjlHZWZhZWwzVUZaKzRIZ0hlQUFhblhzVnpBdFJMaHN6N0x2aGZRMWNMNmE0OHFJRG5NMzFjQUxkZmRTYTVubUdKeWs5YU9jVTN6a1ZsZ1dJMUordys5MDFMeHhOdE5HYmpyOVhJSlNzbi9FK3laTC9wMVk4Q3lXS0JMMkhxSklqQ3lBYjcwMjl0TGs0a0J4ejRuS01CRWdSOG5ZZXpTTmFQMFo1dnB3QUROUVhYQlM1QUNnblFjcERSR0YzMXNIbmg1ODNZUzJhWGwrTzJmeFh6dHgxNDJCVUZJcGwrZ2FwUUsxendUbVcxMS9WdXFGekZvWTQwMG4rUk04bUdZejNYOUdMQWtHK1BNZWIvM3NiL0hLeVFGSlFWaXF0MEk3QjVnNndQdG9UY0lZN2JYL2FsZjd3TFZ0REc2ZGd3UXJtTTNxeDBKQ0ZiZDkwbjFxK3YwL2I1NUlFSzBrajBlMWlHNjU2UnUzbDRBUkF2N1NUU05iOW42S2ZhSHRnZWkxYkZ1WjYxQnBLaXdqSTNYaDZTK3ZZeU50WnJQTlo3MHd2aWxkZmRsVERtaW9oUnkzdjRZNW1aOFB6U09mWHpSdnhlMnNJVXRiR0VMVzFnMGJYZ2tnM3dSQXo1ZkFkNXcrZFRuZ2M5aHp2MFhTRkZ1NnhnYldMbFFJL0MwaklGZUYwaE90Q0cyMGZvQjVnQzltNVdsQS94bStQLzdHTGo0ZGY5YlFNY3pHTk5TRHJwUEFLLzBkbmRleGhaQlgrM2N1SG1JZ1N4dlk4empkLzMvRGdiYy9EUUdvSDdkeS9JZThIc1krSHZQeS9ZSWMzSWMrMzBIQVJSc1k0Q0luS1hhT0VzbVZvNmlEbFhHOUNjdzhQa3pYdGFWM3U3T2tvTkZBbGZXTWVmd1MvNCtKbjV2NWZRVmtQb0EyTy9jdUxtWE0rc0MrM0hkUVp0OGt4anRhbTkzWjhXUFc4SVpncDBiTjRlZEd6ZVBNSkQvWHVmR1RUMzN5MWc3K0tTWE16S1Y4UEo5RDgvMVNaSlF2a3FTOXIyYzVSS2Vzc2RoQlR2SWRnZDczNmRZWGY4dDRPK1QyS1V6cllrZGl5M2E5MGlnbDhvWGoyOWpiV3NENjAvWGVyczc2eGhMOG92Kyt4QUQrKytRV1c5M0o3YXBXdk4zRXgxUTkveGFENEIvUTVJMmoyV2I0TUVFRVpEek9sN3Q3ZTZzKy92UThRSWE3M3Y3ZXRTNWNiUHZ1VzQvTEJhbjJzc0FhL3NUa2lTb3BOVVBzSDU1MTh0NEh6Z083VlYxSTBlM0dEcW5KQ2E5Sk5tdll2MVJMTmRuc2JGTmp0RUR2MDlrVFYzeXNyMkFCVUc4Nk9XNlZ2UGVSaGhnOEN3R3Z1ZkF5ckUvOHoxc2pKQ2pWTTRtTVFnRUpIOEs3OGVoYnlnWVJGTDdIYXB5MTlFeFZqbytaN1R4VWs3Ty94OTZQVDkwZVhZNWZwVmpld0I4Q1F1OCtSNjI2ZjFwa3NyQ2o3MDl5ZWI1RE9EcnFWK2oyTnB1UFkxN252ZCtaOTNUajJuNzMrMGk1ZUNGeElnQ1NrbTFmamZKWWpaWjNmaGJmbFlreWRwb0FqN0V3RnpDK3RaYWVJNElITFc5REpMQ1ZOOVlEZ3cremZWRGQvREl5YU5uSEpQbXdDaW5xbnk1VW1EcGtCai9HOWpZY1lra2d6OG1PWlpPU0NrM0h1SDV5RWxwRzlyaFhrdkYxdmFsSWttS1N1WTlnZ2ZsOFFIQWpFNXBBVDJTZkZYZEtsaE53Tm5VT3hHd1dteHRYMng0SjZmZEpOZlowdS9ZWm1aWUMzUGlOZWJEbk1lQ3MweXNyaUVHYW1pY0ZsdFVvRko4dnFXOC9mdi95d0ZFRnVDaU5SYmQyN2NHL2o1RzNkdTNUaHd3VVFET2xOUWdnVm50bjZzOGJld2Q1MzFRYzVZa1VITkFPSytENVJuMXJYVnZiUzduV2UvSzYyQzU0ZDFISzhHTXh4bkRja0MrZS90V0x3T2hJQUd0SXl3Z0l3ODJFZnRIL1hNZlczTXJxTFBDR3BWNUc1alZWaFZFb0hYWWl2ZXpFd3dFUEhLbnJjYW5Ob2xkQ21tTkRTYkxybjdTQWE3NDcvanNaODFaQXI1ajRJeldmMUl1eVUxck1EMkR4ajVKNjBaMlk4bFM5ZWY3eUJ6US9oNnVZbU1ucFA0VXg3cXlyWFNUdEh6TVA2czVJQUxsUzZRQVJiRmFsLzIzNm5KWWJHMjN2dlRiMiszLzk3LzhuZVhmK085dnhVQVoxZkVWdjBZRWZ5RUJwYkdjRzhEVmJId2JrSEpuMTVseXVLK29YZml4QTF6QndmdnJCbUdONXZmWUpFamd6ekFGWTZvZFhBcnRYMk95UUZLcDU1UjViaHRNZGJnYytuK2NiK3ZTM1N4blB5ditEQnMrZDZ2ZTQzd3VGblFNc2x3dGtodzdKSitGRkVnVU9LV0E3RDJxZlRKS2hXdmZyNkJ3QVVWcVAvcGZmVkRyZ0dOc3JORnZCUkZyUElqeitVV2Z6eWMrUnduYzF2eThMQ0NwbXhRUmxxQ1V1OWZjUGhWVXRMQ0Z6Yko1MS93ZlZWbmk3L2k1MW5SaEhUdHArS2xienl6N1Q5TXpIbEVOMUZ6ejlZZklMa2MrN2tzNi93SlYvMVAwYVd5RSs2NWhRVHFQczNjdWZSNWhINk9mV3RNWStYRjVuMDBXeS9keEwrdkNGcmF3aFMxc1lUOE90b3lCSUs5akc5azlFdFB0UlF5WWVOSC9mOTEvMTlsTEdBQWhCOG1tbndjR2RtbVRjdXovMzhNV1JNY2tVS0hqMzczcTV6M3c4NzZMQWJsdjRQSlVmcjgzc0FYWHV0OXZ3Ni8zVm05MzUyMi83a05za2RVanNmcWV3WUN5cjVNY3JsZXdUU3BlbHJ0KzMwOWh6b1FENExxRFpKSTQwMGF5aFMzeXhKb1ZRRHIyejM4dXE2dGZ3eFpybjhJQXJPOWppOG5QK3ZkSC92M3pYc1l5bjJtUWtQMFJOT2R4ZFhidElWV3B4OUlDMk5jR2ZoMWpTNy9wOVZleW0zVXQvMHdnbWZJb2RUQ3c1K3VkR3pjUEJYRDU4WktYMVFaVGp0Um5zQTN2R3hob2VRSThtRk1DV1F6bGVjRGhEN0EyOWhyV0xsL3pleC9NT3NsQjhDWW1oOWp5aDFoYml3eVJ1SkgrQXZaOGNoWi9INnNuc0dkVy9zUlNqcy92L1Roc3lTTy8vcnNreCtVeldGdVVBdzZzVFYvREFpb3E5eVMxMjhza29LT0hzZXJQbFNmd01VMXNFYWtJS0dmM0sxaGJ1NGlOT3dyTU9KbmovZWRNTm8xSjE3QzZHdmp2aDZSY3lTc2tZUDhLVmxkWHNJQ1JWVkwrNXpIbVhCVG84VHJXSHI1Q1lFbGc5Zjh5OEUweWxveVgvOUJsb3ZGemY0a1VUUE9PbDFmNXpWcll1UEZybUxUNTk3Q2dsUUhXdnIrQXRlMC9ENUw0WmRSL1hqbDFBTEMzZlcxcVY4THZVenlvd0puTjBYRU1CdnpLQ1hySHk2MDh6RDhXa2NmQldmbFV5eXZuYjg3bU93OWo2ekhLOURnTXZ6T3RybzZDYzN1ZU1zVy95M0h1RExaZjQzUDRlYVA4TTNlNlNISlI3S3NJV29xSnB6SU13MmNDL1dJK3J6YlduZ1dDeFZ6Z2VCa09Bc05vNGc2Y3EzNU9uSWVqS2EyR0dJVTliRnpaSk0yWEhXejhlMGhpSGwwaGdJcmgyaG9uUjNpNkFXY21TUjBnQW9qcm1KTll1VkRycEdRak9DVG50K1JLVndLN0tEcWFWZ2lNMlNJeGptTmVOYjBqU0d4Yk1WaGJmbDFKVmM2Y0Q3dEo2dkt4cmRqYXZ1VGw3UVZtWE1tNmMyQk82NTE5QWdqcTcva0N4cncrQ2F4eHlXZVh6MEtha3lvQVZQWThVOUxJNFhvbDg2eElNdW02cnQ1RFpMSUkxSkpDeGxyVGZVUC95Qm4xOGY0eFYzdzhWL05UcTNEbWZYYUlXSzdxRjdVZ3NnZDhETTh4cHN4dEF0cUtJTDN0ZFIwREx5SDFjNW5xZHNuUG1XSThlOTFkd3NhYm93Wm11UHE0MXBlbFJEclY5V1lNTmxOYjFMdlp4K1htUXgwTEhKTHkwTHoxa2N0QlI5Q3ZqdEVMMDJQNEJBZDNDOHZWTFRVQ1hVZmo1OFRiMUZsU3dVL0xOT1pvTGRzbnFTVkVGamRRelEzc3YvZjgrTDZYWCtEZEVRbndGVGk4aVRGMDcrdDZYL3B0QTFMSGswbVAxTi9XL0tkRlVwbkpMZlpqeVJGTE9ubkYxd2kxa3QvUkZHRGtmVis1N0NNNDJmTHJYdkxqSG9iVGU2UTVUMnp3T292ampRSm54QzdWbkJiTHBQRnlWcm43WHA2NEZ1cVJRTkN4ancvam9ocU1FOHVrZnF5QXFUWndITUFZcVdvb3BaTjhFZ01DMElvRFBJRnBLK0FlZkE5Wk00YnBPcEJTT1YwaXRiMCtDVURXT0tNQXpnb0RzVWhxRkFLTld0aDhQZzdYcUp2UHRaYVpHc1BEc2RyN2x5QllrZElEbEdWZ1lRdHJ0aVhTT201VzZvSVAyMXJlTjB1RkFTK1Qra2dlQUthNVZlTjl2Mll2dG9UNUY4dDFkTTE5cFpLbGVhWmNLMUlka3lha0ZGZER2NzdXZ0hza2dvd3NCaHVkT2RiTFFsQ3BucUVTM05HMDV3ekg1SUZ3dFZMWkg5WStlUTRyaVF3Znh2cHdZUXRiMk1JV3RyQy9hcmFNQVpGeWdvMUpVbjhUYkNGMENRTXF2NDA1SXQrb3ZaS0JGOHI1KzRML0x5QzJqVFBUUEJlbjhteWRrSEx4L0Vja1Z2QmJHTER3anJQTUJyM2RuWCtHZ2NvL3dNQ1k2MTZlNzJFYmNjazl2K2JQOVE2Si9UYkdIQ2c5NEo4RFBTK0xRTE5qdjhhbW43T0hBVGZhOE4vRmdEVkZ2R3VSSm9CRStmV3VBMytEQk9RMDFUa1ljUFE2bGovenovMzhaL3hlRHpEbXNpU1RSeGd6VjZCc0xnTTdaUkZNZEhCSGY2OWdtMW14SXpjd1lPeXpXTDNmYjJCNTlyMXNPdThYdlE1YUlZOW9icGV4amV3eDlxNzMvTmxPc2ZkMUY4OTUxZHZkcVFWMkE0Z3NhL214T2V0WnJJazJpVjJyNS80bTFYeXJUU1pwOFVvNXZLMGNlL20vamZXQjZHVEk3UUtwalgvU1A5c0h2b281M2tiNXM1NEZsdFdBNUFJdHhKS1ZIUEVBYS90NnIyS0lQb2NGRkVTVFEwd2JEekhJK2tEUG4xbU92ZEtCN1gzeWFaazJMd0tHeEQ3dStQMCtpZldydTNpL25lT2FMVnhHTVZ6M21NUlllT0RIdmVUMytSbnNuYjdseHoySDFlMW5TZTh4Mmx0K2ZRVkV2T25IcWIydVl1RHZpNlE2cndCekFZU1ZrK2N0N0oyOTc4ZTlTbjEwL3VkSkcxTTViaFVJY0c3QVBwUTN5dlRKSVhTU0J5WFVCQVZJM1dIZC83Nkg1YmYrc1hFaWZaZ2Iyam93NVVPKzF4TmZQemdwWXFSOGRBSm8zQ2dEQmh5NGFnSzJ6Z1I4SFp4Wkl1WHFPL2NtMzUwM3F5UVowMWdYR2c4ZVVZM0dWM0NhSFBSUlVtMHBmQWZXejJJZm1RQ1BHaHp6NnB0eUhCODU0Q3FuMFJCM0xuazVSKzdnbFJLQzJQZ0N0SSt3dVVrc05BV2lLY0R0bERSV1hjR2tZZzhLazNmdFVlK1kwdGc3aWM0OE9ZY0NLN0VFK1VqZ2gwQXRnVDhsSUJtdUlaYWMya1ZrSnl5SE1yU3BBb1BuellWV2E5Nm0ybGlibXJwbVlSSjg2M3FHSXNrQjVtQnFaSGJuVnRaTFlKdkVmS0VDdi9WKzRyR1JKVjZiUHpZQTBaTmlhenM2N2lMNEs5YWQzdDhTMWVBMDlEd3o2a3RCamJVMkE0eVBMTHVwNEpNQUhsL3llbWdWVzl1UDZ0NUhmTmFtY3N3S2xqbkx1aWJuM3Nyck5ENUxYcTRpeWFKUEJmTzRUYWlteklqbnJwR0NJcWFjelRYbG14UW1KeG5yUUgyb2h3V2F4SHNvL1VTakZIZVJtSTBEakcxZlZ3YjEzeEZXQjNYN2l4Z0FNTUZZVGxFbS8wSE5PV0tlTHhkYjIyYysvM2xOWTBtM0t1RTVMTGEyNytNZ21JUFRzZHg5cWdDWitwSGsraVdwRDRudHI2QzNIZ213NjJQN3hjbzgxV294bW95cmJIMm14OXN4MWc5V0ZWVGc1Um1valJWSlpqdU90d3ErVmE3eGNzeW9jYzVMY1dKWWJHMWZ3OTZGdnRPY3AzeTRtOWc4Y2t3S1JGb3F0cllmMXMxdDNkdTM5c1A5OXJNK05YUlE1cm9mSThVa2xWdnBCbXI3Y2MyY0xUbm1YcmVxV0tFVVU1clBOUTRwUU9zaWFUNlRFc0t5bjZNMEVNY2tKU1V4ZHZlWTdpZHhYWFhCbitNa3ZBLzVOT0s3Vk83ZVBrbDk2QUpKYWwxenB6NFRFMTBCMDJWS0NTLzdwR3Z5MWFla05oUk5iYlh2MXltRGJSUncxVTE1enlHTjFYWHl0eDlhVU9UQ1B2NDI2OTE3ZjVxUWdpbVdpcFJEK3lNMWI5dDUwRmtNNkJybFFWdGhYYXJ4dEs1OWw0RVUyYmxTYjlqSEFrc09hODdOeTdjUDdJY3lTajNpa1ByNVhQdURXaXZxWmZieis4YWcxMXc2UHo4R2JKd2M1OTgzRktGVm1QckFoNlVFTjJYbktOdkNGcmF3aFMxc1lRdWJ3K1FjT01XQWh3TU1QTnZEcEgvL0NBTXd2dTMvLytrWjE3dU9NZmZFeHBXVWNwbC8xYVZEeHhqRFVBRHRwN0VOMkE4dzBQaWJ3S01zYitaOUVvUHpnQ1IxS3dtVlowZ3kwODk1V2FLamQ0d0JTSkZCS0JuVFBnWTg2Zm9xLzE5Z3dNbzF2NmJBNUU4Q2Z3MWpkajZMYlppZm9TcUozV1M5OEhNUCtGZCtuNitSUU91eDE4T2p5b25OMHEzTk45dmQwUWFhM3U1T2xKd1JzKy9iR050Wnp1M2FoWHpueHMxQjU4Yk5JNWZYZmh2NHY0Ri9pc2xEanlQZzA5dmRhZlYyZDU3RkFMQVgvSjZYZ0QxL3A1TG5IcEdpN1BOeXR4MnNscU5VMGZETG1MVDFTbTkzWjlrbHRPVm8yc0RhMnNqYjFnOHh0dmVYT3pkdTNzL3JVSkxMZm8xbEwrTmFCTXpEODA4dzF1VTNNY1ltSk1ab2ZDOGpiQ0gvcDFpZitqYldodjRFWXlZUE1CQjc1cnYwTWwzcTdlNXNoRHpUNVhkZUgySitERWw1b0pVYitrK3d2TFJ5WUpZZ2dMOGZNU1hXdmQ3RVdBTjdaNS9DQU5DMThIa1QwRCtYNWMvcy84ZUlkSUV1UzFpZmV3Tmp3c3Q1Y3FHM3U3UHE3MzYxdDd0VCs2NkNLVWpqS3RZV1g4VEEzdWN3WnUrdkFMOUJDbXA1dzMrVVIxclhpTmJHQU9UM01kRDJMV3hzV3VydDdsekNBaVArTHZEWC9kNlNrV3huWlZXZTcrZXhzYXFQS1NBb0dBV2FKZG9VYVBNanYvKy9BTDQzTCtpYUhWZkhZbGRmV2p1cm5ZWnJpZW5RKzBuSSsvdFIyandiMnFjZDlWek1rTklLRys2eVRZUXlTbXBSWTdHYzNmTThRN3VZTFpVcUo2akd1NVZpYTN1bE1JblZPcW5kdXV1Tm9EYnZsYUx6NWFqVlBlUW82Wk9pL1NPTFRCSDhZaFVzWTJQREJqV1I4NkVNQW9Xa1VQSWkxdGVmSmFYSHVFSTFnRWpyR2dHL3g5ZzQweVBsRUl0cklJR3ZBaS91a0lKZTVKQlgvc1N5bk4zYnQ0Njd0MjlKeGk0Kzc0WTc3eVVYR2VXZlIrRkhxaEY1KzRseWxISXV5OGtXMjRnQWtXSDM5cTNoMDNJbXhiWlFtUHlwZ0lIckRXMTlndFd4bU5ETFJaVXRQdE1jSEhtRXM4d0lhNEZpYTN1dDJOcVdna01FbkZSdkcxVFowU1U0ZmtZZkVkQVkxMnBhSTBuMlZPOU1iV0daQm9EWm4yTUtlSTk5eThjS3lTTG1jc2NSaEc0YUE4UW1QQ1NsU05GOVdzWFc5bW9SWkE5bmpYVTFUSmExd3VSczU3S2FnQnl4K3NjRTZkck1CdFN6Nm5TOUl5eVhYejd2YVMxVEJwZDRtV2MrWDNZZnNXbzNNZWR4cGV6ZDI3Y09jeWQzWnFvYkJVZld5cGJIOHM0b240SlFEa2xnVmFYY1huWXhHQ1YxVzF0M3VUM0dIS2ZBeFlwMUxZVkFuSzhtcExFbUtqeEFDaFlVUTF0U3hSc2tPWDBGK2ZiOTJZKzd0MjhkWVB2VmQyTzVmLzIvdXpYNWpkdTM3djlHMVRtdnZxaUFVVWtWWDVuQnROTFlCQjZZV1d4dGIvbzFCdjRza3lMSnIxL0E1RU9qZFBpS1gwdDdPNDFSSTJ3Tks2QlVaYnlBdmJlQlAzT2RGSDFaemxDbTNBUmNxcCt2WTNQVVpVd3VlaFBZakdYMTUxakx5bytYY1pDQkdQbDhGTk1RS1hqdGdEUlhhaDh3SUkwL0NnN3FZSHQzemVkMTZ6RXBia3o4T25wL2wvM25vcDkvbWVwOHZvL041eE5TRU1jalVrQ0lnc0FFM0Fwd3VraFNSVks3VWRtVU5pRE81MGRZdTlRNG9ERm5vMGlxQjB0RlVtdFFvQktrdVJsNCt1dk1oZjE0V1pGVU1XYk5BK3VrY1VRQkRlWDVQcC9QdFlhcXVmKzVVbnJVOU5VQlNXV2hVN09XRXJCN1dnZGErMXIwRG5DblpsMnFZUG5MUE5sOHJoUjUrWHcrOUxYNXJFQnVCZkpJdHY2c1BqdXJiQXAyT25PL0hvSUs1MzZ2NXgxTFpxeExLdGRjakZFTFc5akNGcmF3aFQyWnRVbTVkcFdyNXk3R3FuMFRBNisrRFB3WnR1RTV4VUNsYUNmWW91Z0thWk4xakFFVSt5U2d0Mkxoc3c0bWJYcE1BbDJHR09zM24rZ2w0L29jdG1sN0JWdEk0V1Urd0VDUjc1Q2NrUk1TeUxqaElLaktVRW9yT3hCOGp3UUVLMmZTUHVhNGxiTlZEdDFmQWY0ZWxsLzJQd1QrQVNiRk9zdkdtTlBnT3hpdy9zZFlmV29EK0RWczhmaytua3VFSUtuNG1QWlRHT0Q0T2duRWpzeWRONzA4M3lDVEpXNHlCM3g3blJzM2p4dGtndHNZMFBaSkRFajh0Tzdyb0s2Y21ISkFyTmFBVit2QWY0RGw4ZjJrbC8xNWtoU3pIT3d2a3NCL3ZUZVZjd2dVQW4vOXM0bURxNjhCL3dYMjd2NGVCdWkvaExXdjJnV210NU83R0dQNy93VCtOd3hvbFQwa3RTR3h6ZDdEK3MvN3BNMzNPcGIvZWRuejcwWlE4NElEMmgyc2ZmOGNMci91WVBXNmwvV24vTG1YTVVheDJyTGU2VjJNUmY1OXJBMmZCQm50eUNvUjIxTzVwOTdHMnNJM3ZENTdIclF4d2NEMUo1R0ZYdkxuWEhFQXVrVUNZVmF4M05qL0FQZzdXTHVSZys4OS8vMUpqT0gvSWltLzdqTTE5OUZHcFkyMW1aL0JtUG0vUWxJTGVNV1B1MzJQYXBrQUFDQUFTVVJCVkJUTzArWnNuWlNUdDg3a3lIblh5L1V6MkR2NXp6SHc5OU1ZS1B4blVqREFJL1M5N2JXeHNlNEZEUHk5ajdXYlB0WWZyb1I3aVlHdHpkb3A5ajZWci9LWXFyTnJidk55Uk9sSC9SK0Jxd3NlSERITDVHVFY3NytTOXVPNE9WVjVneU1aS0owUmlvVFhzYkY5UUdJbWphS3pSSUJ0emUyV3NYNCtaZTZZN3dlbmpKeVZjdGF1WWc3dEVzUWdPV04xalJFcEYyOTh2bVdzNzhoeEcvc1RHSXNzU3RucCtkYXd0Y01oMXIvRWxCTkRORjRqTWlla0lpTFFPVEtFSHBLY3RiMXV5cm03U2xwREtTaEg5WHNTbnFtUHJRM2tXRklaMnVINmt0S2ZzcXg5VHJCNVJrRGtpdit0Q0grVlhjNitLRDJzdkl2eGVpVlRNZ0RKTVoraUhOZGpCNitlNmxpUk9mU2lST2dwTlVvZDNkdTM5cnUzYjJrc1ZkdVJYT2tzRURaZW81U3E5cjhsRDc1QkJveDJVODVHT2QzTG9JUzgvZFdOSS9GZUpEQW50akZkUTgraU5pcUdjMjJ1WHIrWCtsSjB3b250RVpsaUs1aGpWWGw5SXh1NXljU2lsL3h5Q1ZnR3dIREp5OUxHZ0lzejgrRDUvVGU4ekhYUHRWTFU1dzZ0bU5kVEx3TU95KzltQlNrVXhtUWNOWHl2bEJDVndBQU1PT3NVVzl2ci9qUExxVG9LNTgvVkpyUHlINUtDSE1RT0YvaW9PbFpBUm9zYXNOYmJ3enEyTnBIcytXVnFuTUgrSHBST1JPdjBqVG43VTlPODBmUnNGV2U1MStsbWRnMkJmUEgrTWRqakN0YUdldmk0aW8yQkYwbHFET0I1bTcyTktJZjZzSnVCNzMvNFgvMk8zbk9jUzJNUXpOaXZmWm0waHlrdEFEQnJKQWFzUUR6dG5UcGhyb2x6MXNTLzAvRXh6Njl5eFF2OFVKOFUyS3QyZG9Mdmdidk8xQTJBYlZ3TExKSFl3NVgxb1pmcHZ0L3ZoR3JibFp6K0tsWEFlbzJVWDFuWE9TVmp1aFZKT1NHT3M1cGJ0YzVlcGlwTnEzTHIzc2ZZdXgyVEFpUzBMNDVTcW0wdng0ZzAvNWNBbVI5MlRHTHNsc3pjYkQ3ZkpFbE1LeUJDNDRVQUs5V2Jnc3cxbjJ1ZDN6aitoUGN5SnJVYmxWR0JHS3FiR0lSVmpydWt3S055N0NmMG1SL0h0ZTNDWnB2V0F6Nlh0MFBmaXUyN3pnYlkrTFZPRGN1V3RKWVVvSHRoenZtODlJMDB6T2ROdWNCTEMydVZBNlladHRwbjlHaVFXUGI3VG8zcmJnL0pXUFBGMXZZNmNMblkydDRvdHJZdis4K3MvYkw2ZDFOdzkwenJtanJISWE1VTUzMnk0M05mSHBpbmRXSEZBa2l2TVduVi82OHRUeGlqTlVjMEhwdFo3YnBzeHJOVkFsdEMyOHozR0hYcmpyaVBuWnBURjJQWHdoYTJzSVV0YkdISkJLWU5zSTJRTmhySzQ3Tk0ydUFzWTRERk85amk3ZzFzazZlOHdKL0FOb1I3VkdVTXArUnJNMGJqaXhqUWZBVURacTZUOG9HT2U3czdSMzd1ZFF5c2VZRWt2U3F3VFU1UUxReVU3N2VEZ1dlWE1HRDFPV0RmYytqdVl3emdjb0dZeVNack15Wm43aU92bzgrUkdNS1htTTZMUEF6ZlJWTjlmSVdVazFXT2dTVy96Zzl3d0M0QTVPTUExTFQ5N3lGQkVyck9Bc2owd090Z0Uxc1VTejUyN0lDZy9oNExjSjhuSisrTSsycmpLSGJ2RmV3OXZFbktDM2FJMWFjMi9RTEZsR2QwMDh1c1hGVXJHTk94ek9uaTcycmMyOTI1UjNVeEwxbHVsV1VjbjhjL3U0S3h0dyt3ZDNWTTJwd2ZRRFVQY202aHJsN0IycTgyMHdMeVBpQzFRZlduQWNrSktvZDBkTEJEVlE1NWdvR3gxN0cyY2tJQ0orK1RKRVRyWkl3ZWtYS1VQY0xraUwvWTI5MjVRMXJFSDVLY1VRSi9UNzNkSFh0ZGZTL0tQVCtKcksrL1g4bFNYL1o2dW9jQnVLOWlmZjlWUC94SHdML0crdllGckExZndmcStJdTdmdzBEMVRpWkJIamNjQWs5ZkpqSDZvcHhwdE9oa1hhbjVQdHBETFBEa2VlQ0xOZDhmWS9WK0J5cDV0SFVQMWNPS1A4TmQ3RjN1a2VUNEl6QXIwRUFLQjJvekxiLyt1Um0zWG1mckdNQS9DcC9KSVNhNXczV3NUOVJKUE1yRWxHeDBWSDBjcmNhSk90YzVNNDV2MVVXVlA0WHJmaWo1aVhWZi9SOEFJdDFMVEY4eG93VDA2Smgrdy9QT1lzYWVXU1kzOVZYZFM0QWpmbC9sOEl6UGtVdHZ4dkpFeHZLRXhMeFoxZm5oL3FOd1RwOGdvMWFZL04yeGY1WTdrVnJGMXZheWY2NGdLeWtvM0EzWHFxc0hCZEhwK2pwMlhLUjhzckpMR0tqeVFmZjJyVjc0ZnBXVWczdktDZVYxZExFd3FXQkp1Qjc3ZDJKQWxYWG9iVUtCZEtvckhTUHdWNnpwQVZXbnNjRGxKWXd4VjlaVkFGbG50bmwzOWluQTRMejk2aFJiNy9WSWtudTE1bVVieURGR0NtUjhYTk5ZTFNkY0RpcE9DcE1RbldMTmhvQ0FWbDQvd1VHdkFMcDIrRHNDSGhPQ0pIUTR0M3kzUlpENTluTUU4TGY5V21MaUx4VXVzMWlZTEcyNS9xVHFqSnZGTUI0QkQ3eHYxQVVtUkZibUpwNVNwZGphWHFucFk3RXVPbjdzbElSaHFJZTV4czJ6MnRlTXR0cjIrcWxqRXlrbmFpeWYzcC8yVm1DQWNDNzlISzl4VEpLMm44dUt4TmpSMktWMnBUV28rck91T2NiNnpFbk5zeW9ZQmFwczVybzEwZ1dxakZNOTl5VmMwVWh0c2FZdE5MYWhzOHpic3dMblNpVUNFaWluWE41NlpxVk5LZWNZYi9OaWhtcjhGbEFhUWNnVlFvcUJXT1pXQzQwaEc4WFc5a0Y0eGhpVUtGQitVTk51bEt0Vyt5UkpGT3Y5WFBDL3k5eVVmbzBEdjY4QVZKVjlrelFlaVZsNnZkamEvaEVwejdFVUp3NjdtYXhwNlBmNW5DV0dxcFJmeU00YmtmS0V4Z0NpdkUrdUY1WWp1cWUxUndEQld6WDNsY1g2MUR5bVFOSks0RTI0aHNhdWN1NzJ1WE9BclNuS090VjZ3c2NnQWNORDBoeDRRUElQNU9rbXdPcjFvcGREZTMvTjUzWEhMaGRiMjNSdjN6b0o4L2tLS1hkN0UraHhDV3U3KzhCUTR3aldUblJPR2RSUm1DUzY1bWg5SCtmdEdHQ1VCMEpwVGxrby9QeVlXTU1hSXJKU1kvb0dBYmV6K2gzZDI3ZE9mZnhZN1dZeXhENWVuSVo3WFNZRnBoeDNiOTg2bWI1aUN2ekMxMHNOYlV4cm5aa1dBaWthdi9lNW9PNFl5YkhYQWNBVFRGVk9xVUpVSmltcGFRMjhXbXh0M3d0bHllKzl4em5YbUZxTGtkYkMyby9FZEI5YWw2bXM4ZjlvQ2pLRk5DYlgxcXZQS2ZFNjJnc29YVnB0S2dZZCs0VDdWbzIxVVFGQis3N0tucThtMkdlcTNwK2dIQXRiMk1JV3RyQ0YvVVNaRnZkaTdBcFF5aGNVRXd5bytCWC8vTHNOMTFzaFNZVGQ5Lyt2QU5kY3puYXR0N3Z6TXZCTEdPdnljOWhHNmw4Qy93ejRBejlmVEpRTkxBZnVPaWFwZWhrREJpOWd6b1Mvd0J5cjJ2UTg4dnYyL0RwWFNOSlRZdjZBZ1MrdmgrZXZNN0VlSDJJTXp0ZUEvOFRyNEpmOXVxY1lDMURSN205akFPNmZZZ3hLTFhaUHZQNitod0VwZTM2ZWdQVld1SjRpa3lYVnE0VjVCd09kbnZXL04zdTdPN2xjRm41ZUc5dDhTZ0pSQzdQTG1GTTBncHVLUnBRcDcvQzVJdVpDV2JYeC9qN0dhUDZ5UHl2KzNTYnAvYjZJTVROL0VXTjh2dWJQZElvQnZtS2I5NzNjMnRRdU9SdFdHd0k5endBRDJwWURFRjArUjVBY0htTUwrZC9IWk02LzZqL2Z3cVNVcDNMMFpzKzZncjB2QWJPNngxVXZ3OXZZKzc1RGtQenlZenFralU0ZXNWbXlkMGlSNGZjeFFQUWh5V0gxdnBmL0Rrem5FL2JqTG1OTTJzK1RwSXZXU0dDZU5tN1BZa0IyeCt1MXJLK25tZXRYc3UvWU03K012ZTlmQmY1alRBSGcxWEQ0UFl5Vi9nNFdIS0lBQ2FrVTlMRzZsclArT1N3QVJmMUJyR1p0SHFKMGtUWk1lZnRXMjJoajQ4ZkRHWS96VTlqNFZRZis2dDI5aHJYdldBZDZ4MzFTZ0lpY1NoMHZ3eldzRGJ4SFlocC9DUnVEZmtCU0pOREcvVndibTlCUHdlWFNRL20wOFQzR252OEQvMzNXV0JEbDZuNXNyRHN0enpWbGVlUncwL0h1YUduYVJKODVsajZKNC90Sm9wc2JnRitveWlsRzVxQWMwYWNOWUk1a0NxZWVSd3lxV2VVSkxBVGRTMEVjQ2pJbzY5Z1pXSElJckdCT2lLbU5mOWZZcGoyYytlUG5xZS9VOWFGbHJEMGZrK1h1ZEFmV2FRTXdOUUZpYnEwVGtueW94dHNtQm9QNm5sSWRqREFtaE9UMktFeFNXSktkY25aREd1K1ZUM0JDV252ZzU0ckZ0MHBpdjBYVDJxL2k3UGMycmZlbSt0QjZSNEZNSmVPRFZKK2xzNzNoZWFkeURvWjJLRUJhRExaejl3MS9QKzlqYTYzM0drRDMwb0tEVFFEQ1kxc0lBQmhSZFU3Rll5YWhuN1NMVE00OGZ1N2wweHF3Wkd4UkJlTHlzYWNTNUtUM1NDWnpHdTRweG5jWmZPVG5sR05rTnpETy9Uc2RQOWM4TkdPOGtIeXcxcUxxNTdtMDVGcGhUSmM0Zi9kekozUzhYOU05bjViNW1OYm9sUFl5eE84RlR2YjgvVmNDQkFxWHZLKzVSaVdJd285dFovK0wwWFdCdE43TFpSVjEveEVPOXBKWXZXV0FYbmFPZ21zMUp6d0NhdlBETWcxVWFVMWI3bFgwelBQT3JmTllhSnY2S1QvdkpyV0JEbFhWQ0RuNzkwSTdPU1h0UWFYMlVPYWZMWXdOK3d4d0xaYi9LLy9OUDFyNjh1LzhvOWF2L2JmL1dQT1ZBTVIyc2JXdFFPRlc5L2F0bm8rbFRSTExGMG01YVBWKzcyTjF1RTRLeG1vVkxwbFpwQnl2R3FQRllGWTk2TmtoeVNkZklzMGZMV3hkMmJUbVBlbmV2bFhKaSt0L0gzVnYzN3AveHRpNmpyV3RjdXloR2t4V0JzQjZHejhoc0xienZ1WC9TN1pkNzZwVWxtZ293eXJtSTFDd2JHeG5TdEV5QldUNTlXSnVkODJQQTFKS25iV0dkcXRuMDU1dGhNMjdKY1BaZ3pGaUtnbU5kd0pveE41dGthMnRBMkFXNTRlNHB1MlI5cEpSY1VIQlF2cGM0NVBHZjdXblBJZDh1Wjkra3ZYbXdzNjJwMVcvQ3ZMS3JoZlhCR3FqQ2txTVFWMHo5MGJlenBybTNUaXZyWkFDR0NwcEhncGp6VzZFK1Z4TTlhYnI1bEx3VDJKVDg0L2ZvNUVkN00vY3o4cWc5YjNHcEI3VmRVdlRmSDZTUDB2Tm1sejFwRURzaTJUenE3KzNQbUUvRm9MakxtQnplYWQ2MVhKTkxuK0g5alIxNzd1dUxWYldabUV2VmJHbkFMcHEvWnpQQWJwdURBS0tpZzFUODREUHcwME01OFdZdHJDRkxXeGhDL3NyWlMyWHdoVkFGWjJBRTJjNktpL1FLeGpvOFRWc0lmZVptdXZ0WTJDRjVJdTE0UHY3VE9mR0hRTC9GNWE3c2g4QXU1Y3g4T1FIZmx3ZlkydCtFZmovTUZEbENHTUkzdW5jdURrUzhKZ3hlTnNZU05URG1JT1AvUGNodHRFOTdkeTRXYnZROVBQRmZMcUN5UkIvRVZzby9SQURuQzVoZ09FZmt0aUEya1NmK0xtdmsrUnk1SXo4SWNteC9vcGZmeGtENHY0RktSbzdNbW9VdVM3ZzlJakVmcEREb3g4a2ZuT1dpQ0tKbFM5MlVsTlhrUEloSFdINWVzKzEyQTVnOVFiSjRTQ242cjZYNVFVTXRIOFpBL1UzL1g1dlltM2h1K0Y2a2dDKzZuV2xQTkQzU0htQlQ0QkJZUGpxZWVWRVhOSDNvVzZVNTBwT3pOTE9Zcm02SE82WTlENHVZbXo0UFgrdUVYQTNZN3hMcWt3NW95TEFGNTNraWtxTlRLd1dpVVcyaWpub1BzQ2xtUnZLS05ub255SXQ4a2ZBLzRCSlFZOUNYYnlJU1NzTFhOeDdFcWJ2V2VZUzdIOE42MDhWZ0I1NzltOWpmVnZzYkxIQWxXdnNnQ1Q3dklmVng0dFlYWDNGUDVNODNSN0dMUDR0VXFRcnpIYnc3M3NadmduOHU2VDg1NWV4UG5xV3pMc2s4UWRZTy9pZnN1Y1h5UHRwRE1DUDhyQ3JXSERNYy83c0Y3RHhxaUF4Mlo3ek12NmdUbHIvUE5iYjNXay9yWHk5VDZJYThKTnVOVkgzSDlaOThtai9NeG5PUlpKSUZ2QWl0bC9PQnBCVDVMRlp6dk5ha1hMUHRtaG16T2JuVERIMEFxZzNoUHA2OEh0SnlrNkFTSWZrcEs3TE95cjIvQ0FIdFAwN2dSM1I0U3duL0pnTVZQYnpWckZ4VFFGNFlsY3RrWlFRVnNNMXdjYUJaUXhjMEpvQ2JQMTFXTk1XQkM0YzFEblN2QzRpVTdHeHpRWkFXUUZiYWtPSC9yZUE2bjNxR1ZJVUppODhGa3NzdGl1dkQrWFBuV3NkSWtmOVBPMmw1bHc1MDB1cDdTZHA1MnA3M2NRMHl4bTMrZkZUMzhkeG8waDVzY1grVU45VW54MW54eS83MzNVUzViUGU2Y3orblY4ak9EZHJnZTd6V3BGWWpPTnV4a2IwNzFwNC82bnI4eDlYVTFrRGEwVktNSEppNm0rQmNuTElrNDh4ZmoweGVZL0N1eENRcTNWdEc1ZlFuZlZ1dmExY3A4clVmTkJOYkhUSjJMWndPZW1HNjJpdGVna2JzOVQyTm9DcjNkdTMzcGxSUDB1UDAyL2p2ZFZQc2o0VTkxQmlxeDc1c2F0WW5aeG0xNUo2VGdjYmYrNkh6NS9GMW1JZFlIUmh2WDEvYWFuRllEaFpHWTRtdzEvN0ovOTRGSTdWWHU2SzMvdUQ0S1JmeGVlMkFNSVBTSW9iU2svU3g5YXhIYi9PTVNtOUFLVDlETjNidDQ1RGtKQ0FVcVVOdWV4bFVCM3JHa29GbzdsMlp0OC9iMy9MMm83RzEwZWg3TFZ6VE4yYUtRQ1RKYkJkTTQ4dTQ0Qno5L2F0US8vL0VyWnZHTUUwUU9EdjRpSUc5QitIei9WZUZGUVY4L0ZPU0N5NlhrMmJrd1IwREN6UXV1YUlKTk5jMWdOSnVVUDdQZTFUQm9SK0h1NmhnT2lqaHZsY3FTL3c0MmF5ZDcwZWRJN0sxaWYxbndtdXZ0SjBqWVhOYjNFdURlTlVWRjlwaGJHOUZ0dzZxMC9POGIwQ0J6UnVLWFhGZ0pBUzQzSE41Nmxuc1haekovdE9RYys5VUFjZkNWdnpTZThWMXE1NmI4K1NGQlgyc0hXd3hnNEZnQXlnbWdJalhHOEZXeTlHRlFLcFFXamNiSk9wNmN4NE5wMG52OGRlMXBhMEY5aHZXbDhYU1lsaEZac2pOQ1l0QSt2ZDI3ZjJ6cXFmV2VWOEhOTTZoaFNRcG1DV21lODBCUEhrKzR3S0NlUEhaVDI1c0lVdGJHRUxXOWlUbUhMaUhPTDVKS05Vcm9OcG55RUJMbG9vSE9jWGNsdkI4bUYrRXdNNVBvVUJGcmxNc3U3OU1pYkpmSjhFSEg3ZTc1bXo2OFFHZlF0ajBzcGhNZ3JNT2xSMi95N205TGxJWXZZZHpDR2YvQndHUElNQlRPOWhBTk1EREFSNmlSU3BHd0hKQ1VueTl3SEppZHZ6SHkwS1h3WituU1RwK296ZjczMi90MWpVa0J6S3lzUDhTUXdVdllZdFBCOENYKzd0N2h6NjlVWWtVRlRSL3VYQ01udFdiZXdFR0wvSDQ3TmdkQTFGcTMvR24rY2h0Z20vQ3Z3R0tkK1lOdER2WWUvMVRnWWt5ZG45UG1rRHZ4YnVNeUU1ZGRRMlM0bEN2MDY1MkhZUWVCMXpodHdsT1dnazlhbU4rSlI1UUVBN3NHSjd2ZDJkMDg2Tm13ZGUvbGttOXRvSC9oelhTWnZzRVJhOE1PcnQ3a1M1TjBudjZEMlVrWjdoT1NzYmNYK1hLeGlqV29FRnkrSDhOckRhMjkwNUpRVjR2RStTN0J0K0JDRGVnTFFweXFQMjVTeTc1RDl2WSs5MzA3KzdTd0lXd1ByUUwyT09rQk9zdjMzRHJ5L1o1SmhEZTU0MmZjbXZPZkd5U09MN09nYmExcG11TDhmclcxNkdJN0Z0UTcycTdlNTdlUytROHBlOVNzcTl1MEhLeVQ3eTUydVRjbncramMzVlU0dDZYWUMvOVJZaWl5WHArbFEyeFpsenFDWG1SL3k4WVNOYzJTVDdPYVhzbXFLaDNURXRWc29vT21pZUJxQmRCL29GVStET1ZJQk9rODBveXhvcFFyelcrYUxqaXExdE9hSnFBZVBnTEZBTzlVNnh0YjNYdlgxckdKd2xIZEljdGEvN0ZZbXhzNHl4RCtUdzdaRUNld2JZbkMvcFBPVXJ2T2IzbGZON3o5K1BWRklVUktKQW93NXdHTzRwRU9BWUF6enlITW50YnNoajZ1OW1EWlB3bkFLcjNRUjB4ekZjWStZQk5RRldEVTU5T2RBbWhVbGdscURYTE9kbER2WUdRSHBZQk9uamM1aVVQTFNPYTlPOHpwMXB3VG0vWEd4dGo3b216eWxuWE83QWxhTnNhdTJSOVkwSzQ2WXdLYys2OFVUWEdlTU14RkNuTTRORHVnMU1qbmg4ZG85U2tpK09SZG4xem1YKzNtdnpRK2R0NGpIQUtLMzFSalNNUGNIQnFDQzhwakhxUFBkVjNtU2xTVkJRM2pyR3Jod1VTYUpiNzBDZ1M2MWtKbG4rV0MvM0ptbGRmRXFTaVZ6Ryt1V28yTnArbE5lYmoxOEgvdThHMDBFM1VYVmdvNXZKZUhyWnIvcS9Xa3RLc1dYaTM4MUtJUUUyL2dxOGZ2ZzRkZTZBUXU0Y0YyaW9QbjBTMms5ZHZ0ZXh0Mm1WUGU2YlZMNEpOalpjUE8xUE5sZFhPUnFQSjVOV2k5aVhWSC9Ed2lRL1M4bHJCMFV1QUtmRjFuYlB5eWdGcUFGSnhsOU85N0hmNzRUUUhvdVVoMWR6Q1NUR3A5YU0yaFBzWSs5V2ErVlQwdDcwRWtuRlpRcGdJdldIeGpWTVljeG9DUG5xdmQycnpWOW1Hc2ljeFRCc2V2K2FlOVgyYzJsL2xYZXRNTW5ab2IvTHlqV0x4SkliK1BPM01iYWNGRTRVUEtZOHZnSlJqdno4cUtvMENlY2RZL1Zjc3N0SmUxMEYrS28vYVgrdWREeXI0YnhZTjVIaFZnYVI0WE5Xelh5KzFBM3FCd0U0SHplTnJVVlNYdEVjcGYybDhrU3J2R2NHR0g2VVFONUhiWThUQk5Ga05kZkovOC83V3p1dWtmSnkxVjF6eHZwSkFKcXVxM0dsUjNXc2ltbFR6cDJLbzJ2QlJ6OXNLTWRwTE9OakJwY29jQ2JLTXNkam9rejhLZ1pxMS9hQmM5eDNGVk9BNkdQQkxNb3h2d2I4cUJ2U1ovZ3BDclJab2prVlNWMVFoUmkvTGFyamFybldyZHZQK0I3bW1CUWNsQWRneWljMElaRWw0dk9WUVVVa0g5UUdLUmlrbEgrZVlXdEZTaXZ6NkRIbmN3V3Q1R05ock51eTdHZTgwNms1Sjh4dCtyeVNObVZoQzF2WXdoYTJzSjlVVzhaWWFBZFFTaDRESlZnbVIrUUdWWG5qUGdhUzFOa0FZM2wrZ1pvOGRKazlpd0dwUFd6eitSRDRmN0JONnFza09kV3ZrNlNXSVlIRnRYSXhYbmJKemx6RkFOVjNnUGRuc1g2aGtnZnpDeGdnZTlmTHR1ZlhFQU5WRGcvbENEN0VuQjU3SktlQm1EeHRLSFB1RHB6eC9BN0dwbjRIYy9DZVlzNWYzVXZncURaZllnd3NZV3pqejRWaXI1T0FyalVzaC9DOEM2NWZ4eGFhUDhKWW9IczA1dzVwdE1BaWh1VGsrcnovdkljdGxDTnIvQkNUK1JXNHEwWHl1b05tZllEQVF0NzMrMGcyZTBDS3NpeFpYbk93bHZza3R2WUpWbDlYdlJ5am1uelZLeGlUOWpKdzJOdmRlWWd4ejg4RVN3TWJ1ZCs1Y2ZOSWRkUGIzVkVFdk9TWEQzdTdPKzloYmFsRGNrZ284dktoQTg4REIyd0Y1S3FleEpKKzFlLzNFR091M2lYbGxyeEdpaGcvd2VyNWZhek43Rk9OT1A5UXpNdTdDdnljZjVRRHdHQjk2QmRJN0tZUjlseGlMeXo3OThvRkxGdjN6eTloN2UwZHYvWURUTjc3MlA5L0RRT080d2FZVUE2MTQxL0cydGh6ZnQ4WHFLK2pNbGMzNmYyOWdkV3hKTmd2T3VnK0prbTdLZSs2SEVrOTdEMThoUlNFOFYxU2Z1WXgxdDViekdCL245UE83T01MWnU5VHN3aENQbkY5NXVCdi92bFo1MldmNWM2SGRwSHkxRVdubjhDNlJnYUlOdFZ6YlBpWHNWeFpQUWRBU2dkV0FHRXJtL0h6QXMvdWlEa2k1ZW5LSFpWaTNHa3NXQzQ4MzJGZS9pSXhvcld1S0NYWU15ZjVoRFJ1UlRBaWdzT1FaRGpmSThuanhRQ2dFMUxxQ2pubUZBeXo1L2NVY0tneElySUo1YlJSRGtpTkx4U2VXelVBbFpYZ01BZEFKRWNkODRmR3FINDlzNlE5RmRpajd3OElEaWpTK3FSc1A4RlJKdWJSa2p2Uzk1dEFVUytIZ05xSkhEYmVaZ1RzMVo2VHQ2VUFwT2k3aVFPcmRmUFNYQllDQWJSR1VidWV5cU1wMENsclAzWFhWREJFbE9hdUEydmozS1R2YStmMEdOQXhqMlYxVjZuUHJMN0xlZFhIa0hQbmdadDFmRU5ReG5MdUNNMmRoMFZpcDVaamdRTkUrYjFpVGxNcDhaelpGdndkVGJyVHNvNjZud0FXMWZtWVVEZmRsT3RiZlVUdG9ZUDE3YndlRkZTby95ZkYxallrNTJpWlg1aXFWUHdxMlo0cEFLZkRibUJBQmp2QzFwQlNJOGh0aFFSdUtiaE5BWTQ2cDNIZkZZSkE0bk9meXpSbjVIT1pBNEFLOUd4MUEzc3FPTHExQmxzcHRyWWZkRTJtK2JSb3puMkxmNzQzR2s5ZVdHcTNUc2JqMXZKd01CNnFYMlJqcGNaMXdya0MrYlR2RWR0VXdjTEhYcWF5bjljQW1KRGtQM1hNS1FZc0M3U1J6TERtQkVodFVkS2lCNFNBZ2N3MFIvYnFBSlpRRmpHbVQ0dXQ3YnNrQ2RKSEpMbHI3ZWRqdjVoNlowM204NUxXd0pLVmp1V0lxVlRBUUFqbDk4M3ZvWDFXRHNpb3JjaWt0aUNBVnlZZlJKdFVmNWRKYlZnL211K0dKRkJGUWNxUnlhWjc2L2NSYWMyZ3VWQVM1cEJ5aUxlS3JlMVZCY2VRNXR2U3ZONTBUdG0vc2psUlpkWGZoSHNwNVVNTDZ5UGowSThxL1RYTWZ6RVlxRllCSk5ySEhUUXVNcWJnVTdoV1paMFMxaC94blVRQVVWYVpzK01jWEpqTTdieDFtQWZ1NlIyVWMxZ0lNTkZhYzFoc2JaL08yMS96TXM3enVjK2phMHd6M2xjSUlLK1hWZnZuQzFnL3VKZU5rUzBTTTFmQTVSNXo1TjR0dHJiRjNxOWozbStRZ21mVTNvLzlKODduOGxWRnFlSjFha0RnYmtxcEVhME0zTUNDTnpSSGlMZ3o5amx2S3FpUXRQYXBBNXhqYXIrNmdGaXRJVFQzYVB4V096aGhSbzdsTUFab0wvTzQvV1ZxTGU5am1jcFN5NGdualdVdGZPeVpzVjZPNDljRVg3Yy96VUNQaFMxc1lRdGIyTUkrYmlhNW45cWNwODVLL0NZR1VnMnh4Wk55NDcyRmdiZnI0WlIxYklIU0JBN245aXFlcHdMNGtqTVNZNzVVTFo0dVl3Q3c1S28ydlF6SE5RdzdsWDNzNE4yTEdMdjJCQVBFR2kwQWRwdll3bkhkeXloWjEyUGdLdzdHM1FsZ3NaeStIMGlXMWIrVEU3QUVDOFB2bzk3dXpsZjkzRU5zTTZwOHNYZHhlV04vQi9qL2ZReU1qT0F2WHE0My9QeHZ6eXNOMjl2ZCtTeVdoeFhnczM2ZDd3Ri9qZ0grNXpFdEd1VVFqdUQvSjVpV0FIK0E1elh0M0xnNTlQcVN3MUsvbHlSVEd3Qm1zYTVqcnE1TEdJQTlqNDF4aHBKZlZ5RHdxMWo5N2VGQU1OWTJYOEprZWEvNXVkOER2dG5iM1htYmhuNFRiQTBERzA5NnV6dDNTYUQyQkVxSjYyZEpqblBKUWtOeWJzVGNXUXB1YUdGOTRua3NhR0NNNWRIdFkwRUYzOFBxVjlMWFVjcDFncjJuaXlUMldHU2VQQmJyNlN6ek1tOWdRS29zM3h5b2JIMnMzcjlBbFFYY0pRVjExTmsxckY2ZThXdThnOVh0MXpDbjVFVk16aDJtSGVNNXNDR1FZWXk5STIyWTh4eDNrT28xUG8rY2E2OWdmWE1GZXkrL1JOckUvWkgvbG5UVUIzNE41V01maDJ0T1NHUGxvTGU3TTJ6SzBleDlaWTB6Z09JelZCRFVSc2E5M1ozREJRajhWT3lwQjFqVU9DY2V5NGtXblZJTzNFVHdhRGs0R21hQ0lRMGI3VHFUQXpUV1NkczM5eVVESVpSUC9iRlZOTE5TSzgvVFRUbFdCWUJXdmljNS95Vnoxc2FCeW1Kcit5UnpkSTJ4dVZ4ajZUSFZISzl5b2lueXZ1SmtkY0QxZld3Y3Uwb0NlT1ZnMmZjeUtxaEZyQUtCcTdxdW5Od0NWU05icmkrMmhkZlhrQVFNajBoQWEzUmtTeGtpTjYyRElBRlF5d0drMGp3YUFVLzgya012ZzNJT1V5VG1VYjQyV1E0L2VzZWRZbXY3MU05YndRSDVJakU0QlNaVVdPL2RJSjlYWTdNQ0YxcHluSWJnZzhleUFFVDNNU2JXZnQxeG9UMFBBbmhYZDV5Y2pQT01IV1c3Qy8zNHJMTE81ZWlhQWZqT0ttc0pBTXhSOXNjMUFTU3hIQUo3eFh6WHM0clpKK1o2WFp1SS9TR0NJclVXZ0t3VzFvNld1dE81RWRYdUsydUViaWJsR0lBYWdZSnRiRXhjelFIdW1qSUlmTko0TWZIUEJGNzFTWUJpUERmbUZUL0JnMFN5Y3ZVZDFHc0s3T21UQUt2U0llM3RUd0RrV3JHMWZiL3VmSDgzc1Y4dkZ4WW9WVGNIS0lCbVNxSTlQejU4TGtCTjE5RjRFMW1YQXVmV2ZLd2ExVnh2Z0xPMjhYWXptVEFjajdreW1Vd0dvekVkNEVEalI1R1lXam56YTB5UTVNUkEwMzFzTEJpSHNVR3NVY2tHNTg4RW9mMFdWUW4vZFZMZ2tQYWhDb0lTQTNtLzYvTFdNMnpJMlFEZWhHb1FxWUpWSkFmZXh2WXBrWG0zNW1Wc0Y4WktuN2xuOVg0MUNtM3JJUC9lbnluMjE0dGVwbkd4dFgyWTlTR3g5emI4ZjRFYUZVQ2xNUGIySVZrUWxQZUo5N0ErcGtCdlBiZFkzSDBTdTFxQWlPcExjdCtRQUtJaGxwNmhEQ3IxZFpmbTh4Z0VwUGVvL1pLc29nd1FUR3pKRm1rdHRCcm1jOVZKQkcrMFoxUVpkTDh5MElIcHRaNENPUWpsV1BJNVVaL0Z0QVpsNE56SEhIQnBZZXZTUnZBd3pwRk5hL0VBVUVITk9ya21tR3BTZDJ6ZDlYM3NtQUtCOHprKzFydldaQTNyQUkwL0VaQmVkUkI0L0NHQlpKZVlacVMyOVhteHRiMGYxbWtpVjJnZHJiMTB0Rk5TWUkwQ2ZRNW9NTC9YaTloWUFuQmNiRzIvbXdWS1RMRHhRdEx4Yld3K3F0eTdtK1Q5ZGU0SzFoZm1tYyt2a3RZcEFwWWo4RnpyaXlpU01rR3I4T0RhL0JnZjM1cVl5REVBdEUwSVVndHJuZWhQcWp1LzRLQ3Z3Z0FBSUFCSlJFRlVURUdDajNQZUpwdGs2aWRNTTMwYlZTRDh1Q24xRHFyQmMza0FUcE5wWEMzZmI1RUNNeU9RWHJsWFU5a1d0ckNGTFd4aEMvdHhzSmhQcDhudVl5eGhNQkJQam94dllvdVU5ZXo0Tjg1WkJ1VkdmY1Zac2Y4K0puR2NYM09BNWR6dFlKdXJ1eVN3cXVVQWt4WUFNZ0V0ZTlnQzhuSjRsb3I1K1JkSm9GOEVMUFdNdnduYzdlM3V2Tk81Y1hQc0FHS1BrSzlWakRuL3Jzd2pXTWVrNjl5NDJmZnZoaGpiVDV1eEFRNVErcUZpS1QwTC9JMjg2SDcvVCtDZ1QyOTM1eHQxZ0UzSSs3cUVBY2w1UHRNTmpKMzVQUEM3dmQyZGV3UWdvSWxWM052ZHVlaDFkbzBreWZOYTNiSEIrdUY1NDdYTERZK1h0OVBiM1pFejY0S2Y4eEwyVGdXOFgrbnQ3bnhBa24yZVpZcXFsc1Q1TXJiZ2Y4WEw5S2U5M1owRFVzN1huOEZBWE5ubk1JQnhIWGpYd2JGY2lsbDFmTld2c2VmM2VJakpBaDk2SGIzaXp5U24xb24vcUc3YUdBTjF3L3VHcERuYmZ2NzNTZmtXanpHd1ZPelIwbXFBd3JFem1hOTZYWFF3WjhpaEE0dU5tNU1uTkxGVzNxTEtCbzlnMDNjd1o5SkxXSjNwUFYvQTZ2MHNaL0lTOERvcGgvQkxtQ3gwWktUa0c2YzRicFFPQ2Yvc2tNVEdoclNaMFBFeFYxWS9uRHZ4YzY3N3oxV3NqdTlneWdLcldJN2hBZmJlL3R6TFcrYjBKdlVOcVRHcys3VTJzWGQxSDJPSDUvMVNrZEdTQXB6YlFpNTJnVVc1bFA3Q3ptZXQ3Tyt6TnFSUGVxOVdrZVRjem1NVFB6YzZoZ1FpZlJqNW5CVEZIZVdXNVRDWnNnQ1MxUVZnbEJhZEZBNFVON1hiZUo4WXJGVE81ZG54bWl2a1pOSjFPNFd4akNUQjNDTGw4Ulg0MHZObkdMbERlWWlONCs4SXRDeTJ0aCtSZ0NMSkx2Wkpjc290ek1uOGdPUjhLWjBuS21UR0NEa2xBVm9kYlB4c1lmT1FuUEZOVW01Nk43RWVORi9MQVJYYmhOWklSMWk3aVNrTUpoaW8wNnA1SDNwbXpabERxcUNIUUMxSVRHbU52VU4zY3MzamhLeDFMZ1dIckp4Y3EvNHNrMkpyKzhqZldlbjBtU2ZJd3V1K2psMmFIeE9CRmMyQmVVQ0hKRjVIaGNsSno3cG16dnhxN0xQbmRkN09lZXk4UVBYVE5NbmtSbHVoNmlDVTgzNkUxV001UitjT3ZXNWl4b3RKR0lOZjZreUJDMlVBV2JGVmxkMzI4VUY5dXN5bFdYZXhibUk0amFtdU82YXNTTkt1SFZ6RnljOVJmajg1UXhYZ2NsTFQvOFlOZitmbGFnenM2VFl6alFSc2FReGF4b0pVVnZ5OHVDN2RKL1h2YTlpN3VaZlYreFZTZlR5STVTMHlodGdadGtiS1hYNUVXbXV0NElGM1BnN2tVcUZEa2dPOGZLNmxwZFpnT0pvYysvM0ZjTlU1Sld2THdUYUJhMHZlcmxRSGc2ek5STkJpZzhBdWE3TDQ3S0hOYVJ6dStYTmU5ZnMvbktkUHozdU16elZYL0xwRFhJcWZwSHFSZzhnS2VveXk3Rk5XSk1iZHF0L2pSQUJRZHFqV0JmazRxalZYdm01UTN4SjdUL1BnWm1HUzBXTHNybUp0UkhMUFl3ZXNKMTFqbHo4Z0tTd2RkRDF2dWIvcnNaZGQ2d0F4Zi9YT0pZK3ROV0ZGMVVKMUcrcFk2M21WWGV1TkNaNFhuZG5yOU53L29qSXFHRUx6Y0J6RCsvN01LOW4zdFVFYWJ2a2NvRGF2ZFl6ZVRRU0x0ZFk4dDJKRWJoa1FHL2Q3dzN3T24yYys5Ky9yMUFBZXg5Wkpha0RIV2JCQmkycVF6V24yL2lzS0lFVksxM0plTlk5eFBLK3VQeFdCeWUwV0E2VExNc3g3ejNQWW81cHJhMzVyZWRuYVdIQ2R4bG9GbjJqY0J1OWozZHUzSGpySStEdytOeGFXdHFWSmtXS1RhdDlTRU0reFgyL3M0OE1hNW9QY3hOWm90WUJxTjdHcEZiRFpxVHN1UE5leVgvT0lsQ3M4cXZURTRQUTZhZVU0L2ozMm5xMWgzNlQrV3U0VnV5bDRLMWVTMmlPTjdaditmSHRaZTVlQ3dsU0t1bk1DclRGWVJYczNmWmFyL0VTTGZxYzRMcFcvYTg2SmUreEt2L3VZQjdBc2JHRUxXOWpDRmxiYU1nWW8zTy90N3RTeXhUbzNicDVBSmEvdTV6SGc2WFBVNS9ZOXI0bmQ4am9tNFpxRHY3TFArTEh2NHh2d0NCbzZZMjBqSFA4YXhqWTh4dVJ3bC93NWxuT1o0QUI2U0NMMzhvenkvbDNnZjNYZ0Z5L3pBRnNNOXJHNjFFYXBCSEJtWEU4QVR4L2JSTXFoMVhJZ1V0YzV3amJ2UFJJUWVvSXRqTnNZQS9aYitDYk5XY002TjI3cUJQajFnUzlqNEdhK2ViZ08vRTFNanZZUXE4ZGxUUDY3WXIzZG5RdkF2ME55enFqdXZvNUpTdU9mZlQ2Y2RvSXRFUHZBaGQ3dVRsTk81akgycnNXWXVvZlY5VU4vL3V0ZVovdDZSbi91MmpwM0VPMVZEUGgrRlF0dWVOR3Zmd1VENFJRNWYrcjMrNFdhY24wQ1kzSStDM3pkZ2Jnb1dkbHlWdk1qYkVQenJoLzdhZXhkdlljRlVPeVJKTmF1a1BLc2ZKUGtQUGhWTCtzM01kQitIL2dTOXI2MWViOUNBZ2NVelNnR1ROT21WY0RDcXhqbzJzTUE5Q2NDZXJ3ZkxwRnlVTXM2V0owKzlQTC9zVC9mWjRDZjl6TC9JZkFteWRFbTU4a0tWbitROGkxM3dtZDE5Z3pHYWgrU3hvV1kyenBmL01jK01BQUtFalAvRmY5Y1Rvem5TWG51SURrdTVkaFJkREJZTzduby8zZEp6RjV0VUZiOW1kL0JnT0VQc0hkWnRpVWZuNTdIZ2hIVUo1N0QyWVM5M1ozdkJlV0JDMWg3Ym1IQklKTnp2bE50UWxmQ1o1M2U3czU0RG5uMWhVMWJ2aUgvc0NPSEJXQ2V5d0xnMjg1WUJjcHY5MVJOVHVNYUIxZzdSTTdubStyYTNMemhYSUV4Wlo3QW9pYm5YWkh5YlE1SUVzZGlSMGtLTlcvclVjcFJtMytOM1hMcXFGK3JqME5WOG5JSmMzQWVNdTB3RXVQK0ZCdWJOWDZzWW1PUWdLTlRiT3pYdUZpeWhQSTY4YzkwL3drMlh0VDJZWGVjVGVSVTY5NitkZXdPOTlnVzVFd1orN1ZVcGdnS2k1MHNwN0xxV3VrcjhqSU9BakNpdmlMSGtHUmxkV3pmajVXVXJVQ3VNeDJ6WnppUzVOUXB3UnIvZk5uZjhUb0cyUFQ4T2VhNTM4dzFuOXByYUo4Q2hYSjJ1eHorK29sNW1wY0k3MndlQ3c2cmRtQTZuRHUzM3d5THdFdjgvME94Ym1JOUNlQ3RjMTZLRWRQM3VsS1pOTTlKVm5BZ1o3aTMvWkpkZkFaZ1Bzbit6bzlUbXdWZjMyZXNFdTAvSXZDanVTTG05MXoyNy9UWjJKOHRza2tsZTMrQnRMNFV3N2ZPU2ExY29tTHFDeHlWMmxMZnkzV3U5bEdZaE9ZcXlTa2JKZkdueGlBdi85Q0JVem5uWTE1MmdWNXk5T1pTejNQM0FWSmd5b2svMTFRZ1NUN25oY0FpS1ZMcE9rc252Zkh5Y0RRcCsyR1lpd1M4YWo3UStLSkF6c2hFeTl0TVRDMFNBNDhxOHVaTkFKYVBsV05zN3VpcFBUbGdLUkRxYVFhaURiRzEvYkdYVVhXd2d1MUwxaHpBR25hTlFTc2daWjJhSUhSLzN3SmhwTTZ4Q3ZTS2FZYWo1a0s5MXhpVW9UazdWNGRRWU9NSlNXRkN3SS9HZi8wZHIzMFMycU1ZN3hWWjlEQ1BhRDUvUkFvNlVDQm5EUFo2UkhYTkhWbTVwWVV4UWZQNUZLTS9sQ0dmejN0RlZjWTREellSZXpxeTRSUTBDd240MGI1RkRNRzhqQldKVnRMN2crazBCc05RajNWQXpPTmF5OGNSdFFXVldZRVpxOWo4SjZXT3A3V3ZpWDFLNmczbDJrd0FMNmw5bG94OUgzY3ZZWDJoRGdTZHBieWh0WkxHN1NOZkowMGFnaVVxZ1FWMTEreW13S1c0TGxPYi9kRG1kRzgvUzhYVzluS1k1MDZ5T3J6aWZ4OTNMWUJTNWR2RXh1WSsxdS8yOExWOFlRb1dMK0g5dUtoSzlFZUxRTGZtbXJ4OXhFRElCOEQ5aGoxR0RDeFQzNDBwQ1BKQXFBbTJkMzlBZGZ4WFFOb1IxZHp0ZFhQZUJCdnJsdlNjcERtbkRBZy9MMWhabUpxUDF2dDVxcFU2OXE3bWMrMUJXcVFnSGtqOVlJd0ZQZVRubjJlOW9XdEVFa211RGxMM3ZIckhHbjhtNGY5S0lFcFkvNVZCV3VFYSt2MWhCWFl2YkdFTFc5akNGdlpVYlJrREZZNHhFS0l1djVOc0ZRUE9KTTE2NlNtVjRaSmZjeDR3K2ZNWUFQd09RUklyeVBWMnNFM1JzNWdrN2pyR052d1J4cnliaXZwendFVFNqcEJrVnB0c0F3TmZCRlMvaEFHakQ2bEt0c3BXbk1FNmRLQjN6Zjh1Rnd0ZWZzbmNxaXdYc00zcEFEanljOThHL2hjdjMxWHNuZWkrUHlESlJHcWpwZ2g4bFdjUWZrc2VWL2w2ODN6TmlvUmN4VURINTFYV0lHSGN3dHFQMkp4Znc0SUQzc2NXMzlyZzU3YnV6L0FTQnB3dk9aTzJYTkFHVUY2eW5ER1BvSjVIYktyUFlBenFFVFNDdnkwTXpQME0xdWFlOFI5dEFyL2hkU0pIMVhIbnhzMjkzdTdPN3dML2tHbTIrd29KR1B3NnRtakg3NjhOZzloV1N4aUkvb3gvL2lhMlNGZGRmWllFYk85amRTK204ZXNrZ0hpUGFyVDZNdFllWHlmSnBBc2txSE5FbHVidDZkVFBPUVhPQ3hST21iZHRPVGdlaHMrMUNWSGJQdkJuZUlRQm50L0Mydi9iblJzM1QvMzRnVDh2V0R1UnZZL1Y2d3QrN2hVU2d6cTNBUWJ5WC9SejFMZmxISXFnNzF0WTNkNGw1ZnBlOC9QRnZ0YW03MitTbkxvYUJ3Vit5T0dwY1dDVnRQR1M0MC90V09EVGMxai8xUmdrSi9VU05pNWV4Z0kxTG1OQkN0ZXhkbktIYVdhSTJQRjdXTzdwODI3VzFXNVV0dEtSNytEK1BDejdoVld0RXBGOUJwandOTzYxRkZrazU3R0dqWGNwa2Z1NGhhcHpWTmZjcTRVNXFTWFQycEtUemgxWlk0eEJWbGQvQ2hqUnZDRW5XOG5vQ2Vlc1lYM3ROQnl2OXpPb0F4TWNxTlRZSmphQVdFNmFPNk9EYzBCZ2RmazlKQWVwSFBDS2dtOWhmVnN5bG5KRUhQbDFPbFNkcjNKTVh5WXdqR2VaQXdJL0lxd0hNb2Z3RXVha0w4R2s0SXhieTU1RktocHlCc21SSWduSk9BN21nRlpkMlRUZXFFeHlVa1ZuV2NrOElMR1RKOTF6NXFPcnU3ZTNzYmplaUdXVkZMY2NReXJIdWU5YnVJeHBkdDhWZDlhT21HWS9SWWViNmxNV1plL09hNUU1Qm1lelhPYzF6WEdhWDUvNC9jeGpEdDdrNjlkb1VsTlJqdWs0Nzh1aG5lZGtITHV6VXV6Wk1UWHNPaDhYOHZYSGFoSHlaUHE3VnBCRFhiQ0dBaHJxZ0twb1doTkVnTzIwNW5wanJDMnAzWnpPbUhQV1NmbFVOUmFwbjVWcys4TFl1RFBsVDBtU2xYcldPQlllbkFVNitIZkR3dks4Q3ZDNzRLQ042a2FLVG5FTWk0enY1UURFMWpyNXU1NG50NmtNYnBGTnE3SW9PRlRCUXF2QWNEQ2NYTUh5Qmthd0ZxK1BpeGhUUzBERmlWK3ZUM0RnMTlTSjFITFV0bUx3VENWQUt5dG5USjh3eGtEL21OTlFhaEJEa3VKRys3ejkxUHRiSzdaeHBuTlZ0MG5CQmNxcE9TaU1zUmZCY1NrL1JCTmdxcjZxWUtKTmJBM1E3NlpBc1F1aytUeUNpZUFCRGpVQkZ5Y2s5cndDSTZUa29VQ0RjZmc1d29BT2xWUHpPWVhsalJZWXYwbTFqdGV4TmpBaTdlZWoycEFDT2pVR3dCeHBlRUl3Vk4xOFhxNkJJZ0RwWTFyZGZONm02aWVBS2lONGhUUVBEVWxneTZ6NVBKYXBEWlhjc2kwUFlvanp1YzU5NGtBa2YwN2ROd2VYeGZxT0FWWGwrdU04RnVkek56SDN4YXpPMStDYWQvWDlNUHN1bitQcjdobmJ0dXF1UXdvZzBQaHowSjJkRW1NZTY1R0FPcjM3cVlES0Q4SEd1R29BVE8wWklqQzlvVFdVZjYyZ0c4MS9zWDRIMkg1NUhSdUxCdXEzOGNiZDI3Y09Da3VMb0RuL0JQaEVZZExURC8yWUdHUTFwVURqL2VzQ052WTBTaTI3clhsWjRwNGxXaG1NRWRiSnM5cXExdVl4Z0NZR2NXajljRENycjRYMUJWUnoyRSs4TE9WYTZJejVmT1Q3TDYyak5KWkVCY0J5THM3bm85akhtdFl3anpObWhNQVR3ck5wYmIvaXg4UjlnUlNvcEpvWjl6VjV2Mnk2Wnh6bkZqNlVoUzFzWVF0YjJGK2FMV1BnMGZjeHhtd3RBT3k1U3Y4OWtyeXpGbHpLSDdRSC9KNS8vcDloTEwwZkFGK2NzeHpuWVJML0p2QS9VNDErYTJHc3pKY3hGbDBFcDEvSEZoNy9GZ09hY2xPdWp4RkpEdXhQTWZibkNvbWxLUHNoSnBQOEJnbUUrUTZKdFJkejNXaXpzUWJnak41cndEMW4xQWxVdVladEhBWHdqWUc5em8yYnVaTkNFZm4zc0lYc0tyNnBySkg1VmU1Z0xSYTF3UlRnSFoyZDBYR0hQOHM5TEYvcVJheGRpSW1JUDBzTHErY09Cc1JkOTdML0JkVjNzNXI5TDN1REJPQUM5SHU3T3pHQ1R3dWtLMWdkSzdwVnpDTkl1YXcyTUlENkVaWVhXdWZIemVYTFdEM2Z4OERpVTZ5TlNwWUxraE9wWEZBNkNQd2xqTDE3emN2VDlqbzVJTEcxTnIwY1BYL1Ayc3oxL0R3dE5sVVhGNEZmeE5wUTMrdmlGSFBxdjRneFIrVjR1SWNCZjJza2g0bEFqQmN4RnU5S3FDdUI5dTNlN3M0eUZuQXd0VWoyejQ0RXR0ZkpsTTlqZmc4eGZKZTlQQWZPUHRYbVljWExmTVdmNGRSWjBpTU1ZSTM1c2NlZUh4c3MwQ0tPRDNMUUhHSHY4U1dxN0hKRnlEN0FtTVVYc1hkMGlMVVZ0UjB0K3QvMmEzMExxN3NqcXFDR0hBVGFXSzlnQVNXWFNYMWV6b3dUa21OUW16bXg0WlEzN2dvSkRCZUw2N05ldHAveFozb1Q2OSt2a2FUSkIxZzdlRUJxTXhVMldnZ2tPZXpjdVBtNG0zOEJZWEptYWtNa2x1T2d0N3VUczdzWGxsbTIyUnMxZlJjL2t4UHhDVGFIZW5keWNNMTA2dVpSNmsyV2Y1ODcxdWNzczV6b1RaTERwWU9TRkppa09YVGRIWm45NE9UTUhkL3FjekZQYnh4cis0WGw1NFZxSGxrNW1TZFU1NTM0dkRGSUxBZnBSdUczQWp2VTkwdXBNS3BqaWE2N2pzMWJLcWZLcjdIbmhNUlUxbmtuN2xUUk9MT0NzYUwyc1RHalR3Q1pnaU5VVHJVVkw1ZnlFN2F3c2ZHRUFDWVZpYkY4M2V1cFh4aGpXeUR2SU5SaGRCQ3I3dU43aWdCRXBhM2pqdklBTHBVQVl1YlFGa2lnTWZPMDI1RHo4N3dtaDdVN2I4VU1FK05yRkg2TGpmdTRvR1lPUWdqVW1HVDFydmVsZHFyMVdnbmFob0NFS1R1alAxWWM3dG5uVDJTQjlmRmhCcmcwM1h0V1c1RDBzaVNUMVg3VjVoUTBrNWM3c3NkbXZmTStDUlJzS2w4NWRzWHhNN3h2T0VQZXZwdHlCRU5pMTFiT0NVQnN6SG1yUHRPdk9WWnNVQVZyNkxjQVhOV0JKS3liYkkwa20zMUtXbS9oMTlEYWU2WjVXYlhHanlEY0FNdFptL2NodlZjRnp5ajNvYVQxVjZrQ2QzWDNiQUdYL0x5WU0zckp6KzlqNjdhT2wrTUlXNjkzc0xsbGt3VENhQzBzOFBPU2wra3VLZEJBZ1V3QzQwNUlhOEpXK09tUjl0b2RQeTRDWExFdWx2eGVvOEx5MXcvaWZmRGN4dGc3UFFqbnRvRnJIdmpUZDJCWGJQUlpmV29OQTJEdU5UamxsYU5UT1RKLzVGK3RZb0d0cDkzYnR4NTQvYmFMSUcvdjVlMlEybXdNK21tVGNrcEwrU21tWVJHVHRWekgxb0RrVXRyU05hTnBUVEFPeDVSQVNpaG51WGNPMTFjK2JhMGpWQzd0QlUvRC8xb1RpQjJ1ZGZZRUMxbzdKREdQWTkzRStWeitCUVhLeFpRUWZRSllGK1p6K1VaR29iMjNxUFovV1F5T2kvUERyUGw4bFNyNEZ0bTMrbHRsaVg2SHdkTU1GZ3BCUWRyZlIxVzJ1TjVybEIrZncvS3hDTDgyRGU4cnFyZ3NZZTFlN1ZQQmZqbVlXQUt3M3AvemVWck0zenc0clAwazg3Q2ZPL1kxczhyL2tRQlhmbzlaKzlkamJBelFmbjRkbTFzZWtkclhlbEZsRVlQdDJSWGNNU3QxeUIxU2dMamFVQ1VWUXpjcDVFeUJsS1NBamlWbTU5b2RoSGF6anJVTDljTVlvTGNhcjFNVDZCTk5iU3l1SzhwOHZxU3hyRlNVYUxDNDUxY0tLSzF4bHYyWkcvZHlvYXlhbHhWTXBqRm1RQmFZNDZaOWs5WWNVc1dSK3NWY2UxYWZWNmFDR3NQYUs2NHZ0SGVKQVNQYVE3ZkNaeHF2SmtXbUxCWDdlM2QyZm15TmhRc1FlR0VMVzlqQ0Z2YVhacTNlN3M1L2pXMEkzd1YrSHdObXlvbkpBY3Jmd2tBZE1LYmNOekdtbkJacFdpQzBNY0JWMGE4L2k0RWFINGI5ajlqa2ZRMERmU01JcEdoYmJjcFY3bjhGUE1yWXQ1OGp5VFc5aHdGN1lvRmV4OEJmWGZ0dC82MjZ1SStCNTkvSEZxVUhKQWxuTVpKWE1iYmlCc2tCOGk2Mm9HdGg5U1B3OUIzZ1hwNVRObG9BWWJYUWJXVGtPWk55S25kdnlGSGJCdjVUZitaTkVnUDFreVEyZGVsazdOeTQrVS84bXBFTnVRbjhPZ2FRZ2pGcDM4T0Fja252UG9lQlhOcWdQL0xmWDhmQWMwakFKbDQzWWt5dmt6YmlMY3hoL2h3cFlsWk9remV4ZDNqUmo5ZmkrRG1zamV4NW1TVHRKekJkaStWbFo1KzIvRm1iNmpSdXBJOUpqbUk1NHdXQ1RraE84aGY5bmk5ai9lUFk3Ni8yT2NUYTFwMVE3OG9kKzdaZit6dWtIREtTLzE3MTUrdGk3KzJQTVlic1A4VEFRa215aVNuNmlPcUd0ejJycmRVOHV5TDVyNUEyc3UrVFdIRUNBejZOQlFXc1lHMWVEckdlMThVcGNMY213Q0hlUyszc0MxalFoK3ozU05MaUZ6Q0E5QXRZVzNzYmEzOWlJdjhxU2Y0dzJoQnJlOGVrTnZFQnFWNjBhUkY0ckEzZEVRbG83MkJqd3d0WTNYK2YxQzkrZ1dxME55U0duSUFNeWNkcU14UWRUWDMvL3RqTGRzbkxvVUNCUFN6UW9vOXRhaCtTd09DL2hRV3dQSGhja0xhM3U5UHg1NWNqU2M2cFBsQ2JLbUJoMDZiTmZkTkdydzRJZnB4TlllNk13OGVVZWE0bFIzSk5GSHRsQXh1UGF6cm5qUHRFZWNQU2F1NHJSMEVFQkZjd2gzR1V2eDFuejN6Vmp4TjdMRHBmSkpVYm5RanRyckhOMUEvbEZNckJlam1ZaGw2RzNLR2dITzVqckw4cTJFVzUvZUx4RzM2ZEk2L0hGWklzc3dCYWdRRWFHNWF3L3EzSSsvaE9ybU5qMUJnTERMbE1jdkFMeUJnRkIrMG5TQ3k5K3lSQVdBdzExYitZeW5JWVNXVkFEbml0QzJKdWNNbDBRcEoyZytSY0dXTk03Z2hlU01GaWpEbUR4QkM2RU02Ums2WVZRTFJsNW1TaStQdGJJOG05empwVzRGbGtkUXVBeU5uTWoyM2hHVXFweitCQWo2emZDRDVHbG5uTDIyNDh2cFRwemZwcUs3dCtPNXlUQnpLVVpYbU1aMnJ4R0V6Q2o4Sjh2SWp6Y1I2b0NSbm9WYVFjckFJbjVnbzI4SHZwV3ZsWUlrbHBCWVJGNWxJTGU2KzFEdU1Bcml5UkhNVXEvd2EydGhMelVJRWpJMjhuYTFqT3hPUHNlbHB6YkpDWXBnY2tKYUUyTnFhc1lPdkoydnljb1d6UlNkNG5TVldxSFQ4NEs1aklQOU4xMUZZYmM3bUhJQklwRW9pMUpVYXpGQ1EwZDB6TlhiRWZxVitGL2hLRDlWNGtNY253WjVLaXpBa0diR3A4MWQ1RWU4SWxMNCtrdGZld2RXUUxEOWIwOC9Rc0FtbmxQRC9vM3I2Vk0yeGorUVZTU0dGR2JVVFB0ZzRjTytpd1FtSXpEL0E5VS9mMnJTTnZ2NFJ6YStmNVltdDdreFQwcUxZa2dEdXlwMS9FNWlhdDlaY3doYTZEN3UxYmg4SFJmNXFOWDlmOW1wcDdCSmJpejlQcTNyNTFFdDdSc29NeTYrSFpqc2pXUWY2OTltN0hXVmxiL3AzMkQvdWt3Rld0SzJRS1JPMTczV2srMTl5cEFDMzF4UWlrSGxJUFRsOGlCZjFvRDZCOXBCUXZZdUNkbE1vMHJ1bjRYdmYycmROUU4rb2JxanNCalZxamJGQmw1VUVWc01GLzYva1ZsS0g1WEdXTzY1YTRYbHVuQ3FEb0dYVC9KYzQzbnpjcEgrVEhhbHpTT2dvU0VCem44eWVhczRvVWdDaVdiRXhqb2pGZmV6OEJjWkZscm1DUkphenRqckIycS9WcXlkaW5xckNodFdhZHl0b2hpVUZiRzRBNnEvNzhtVmE2emJseS85S3NNTldjWjBqeThscHZxdzFxSEkwNXVhK1NsUDN1WW4xL252YW04WGdZNTJhdncrZXcvbjVFOG9PTXNUWDlHdFlQN3paY2R3a2JkNlZvRVlIZks2UTVlSjAwUHlpSDlRcld4aXJNV1FVdGtRZ0NtcGZpMmtXQk5aWDgwelhsRTFrRTBweXF1bFU1cHdEY091RFR5eXUvbWVienhuWlZwQ0JnelN2eWJlaitGVm4xaHZscDVyNDJqQTBhWDJWeG5hMzFpNTVaQWE4YVExVFhJOStiNUlISGtNYitHQkFEMCtvQUMxdll3aGEyc0lWOVpLYkpiaE1ETS9hQnZkN3V6dGRKb002clZNSGZmNE1CZkUzNUp6NGdMZXJYL2R4MVVzN1JhMCtwN0w5RnZRejFlOWlpc0ljNWhRZllBdUlyVkNPZkJlYjlkZi9zaDlpaWNvd0JUTnFZUnptbUg1RmtmRSt3M01LdllSc29BWXgzc1dmL0tmLzhwNWxtT0grSmxQZm5rMWg5L1JCajdzM2NqQVR3WlJJWnVRMDJ5Y0I4TVR6TEtHcC8zdTk3dWNFQTFuc1lzN0p5ZldkNmxwSFYyRUxva0dwYitBd0djdjZRNUpRZmtCekZYd2YrekQrUFVaNENKclU1WGZIZ2d3a0d6ZzY4RFB2WXdudUN2V2ZsVjVLRThoRXBONUx5dDI1aXpFcUI4M0t1eGlqZ1pXY09nN0duYTRGMS8yem9rdFY5TDVNYy9hZWhMc1lZTTN2YzI5MTUxOHV5NmZXQ2wzR0R4TERDZjkveDUzcm8xL3BwcjhkbnNmYjRFaWx2bTVnSTcvbnozUFZqTmpDR3RmSVBYOEtDQy9iOVdTOWlpL3Q3bkMvNldRNkZRMUt1U2prbmxyMXUrcjNkblcrUmN1OHFTdmRSNThiTmZtOTM1d2ZVc0ZGeTgzcUxlYkh3NTMwSDY1TnFVNitFNy84TXE3OExXRC85SWNrQmM4WHJRM25FRDdITmtENGYrVDNsa0xwRVl1WS82L2UrUStxemlrS2VZQnRMc1RVK1JZaDZweXF0cmloZmJYRHdZK1hZMDlnb1o4SSs5bjZQL0Q1SDRUNFgvVm1ld2RyRVJXdzgrbGsvWjUvWmpKMWFjeG52VDJQdDkwY2t4L0lBRDhvNDd6Vi8wcTFwRXhvQm1Ca21zR0FtU0R3dmlPekh6WHp2MGVrdUI1NllDQUVZeUIza3VzK2t5WEhnRy9mRzd3azVuMGpTb2xDTjFJNzNqd0JBT1U2NWM2MTBUbnE1eGI0ZlJMREF5MTRCTHJwQnZ0Q0JuVVp3eHdHQkU2amttTksxY3pCTlFKMkNrMGJZR0tNeFRJNDZ5ZGkxc2Z5ZEkzZitqbkIxQkd6TVY3Q0lWQzd1VVIwM0gyTGptd0t0NUJTOGhvT2V4ZGIyblc3S3RhYzY2L3Q5anFteVQ4VzhVdm1QL0JqTmw1R1pXZ2FnS2VJZFo2Q1I1Z1E1UkNCSVRnWkgvNURrdUJ1RmZxUjdsVG5MTUVhTDJ1M011U016T2ZEakdxVFd1bFhtU1Q4QUs3WEExMU13T1lPWENtTndRZFhScmpxV1kxbm5LRi94VWpnMmI5LzZPeSszMW0zeHZMbHl2SG9iYXRVNXpMMFBuZ3NZTHpJWjJZWmp6blJXaDJzMVBVYzcrN3NWZnV1Nk9lTXhBbUZ6UDFjM3lTN241VlBmay9OUUFST1JEVGpyUGxHNlZPMUNxamhpQXdwdzFQcCt1ZGphMWo0anlxbExzVVpnMUtFZmN4UkE0a2xoS2dPUFF2bFczQ0YrR2gyNDNTVExxZm9VRUNUZ0ZQOTl1VEFwelJqSXMxeVlTa0tVbEZUZmt6TlY0MU1IZTA4VitVbi9YQUdHbWdkMDMyRzRueFNFMWdwaldCNTFiNWM1TWdlRjVaTGU5T2VVVTE3QTFMRFkybjVJR3NQbFBPNkY1OVRZMk1QV1h3ZmhXVFN1WHZJZmpXMGpiSHdaQk9kOUNTVDU4enpxVmhsbWtFQ21aV3p0ZDBKaWsycGRxbUJYZ2Z0RHI2c29PWDdpWmRYWUhJRnlNWXFQYXZxVndBbU44N3JIU21IeW9qSDRLcDdUd2VhVUk3L2Z1TERjNnBHeE9BblhIWFVEMHl5ZnovMTNuelMyOXdRTU42ekpUbnlzalVDa1RQTTVwSGNnSUVVQk93cjBWWDllSlRGdzhib2NZbk53REFyYjlPLzFmaFNnRnVla0kxSlFWcHdIRk5pQnZ3dk41ekVZWEh2Q3VQNFNRS2l5Q2xSU2U0M2pJaVJsRGMzbmVxY2FBK1BZMlEvenVkcU14cklScHVBUjM0SEtFUE0wTC9tWWU1NDlxQUp6dE01b05MKzN4aW14TFdldXR4L1R5dXY2MzZ1RktheEFDblNMd1JoS1o2WDlkRHY4TFo5TURQWTREV3Z6R0ZnbllDbXkxa3YyTjlVMmxKZDM0dlBBU2tOZ3lkUStRbVB5alBYL3FuOC9DOXliSzNqVXI1VXo3R1dSa2FueFRQT1oxdFVLWklwS0Y2ZDQ0UCtzL1ZTMlY1Qk1mVzV0a205RC9oUUZqR3UrbkJVMGRwRzBibGZmVUlDUWdnWGswMUxRNVpMUDU1WEFVcDhETHZsZVN1UFBLaUdvTWh5cllKVzJuN2RDVllGSEZuMXhxeVRTUkZ6VHJ4V21DcVQ1dWUxbG5NVDdkaFBUV1NwSktzc2ExaGZ6ZTZ1UHg3UnZhc2RSRFVGckVvSGo4WjdhWXl6SDgrSzhVU1FKZmNMMTVkL1VXa1o5YmtEWXA0YTVlcFcwVmlyWGs2Ry81dVAwclAyeDZpVVA2QzREc2VKK1A3YlRPWU02UG5KbG5vVXRiR0VMVzlqSDB3UTh5bjRCK052Kzh6SUp0SHFJTVJCL3IzUGo1Zzg2TjI2V3VTVURJS0RGN1FCYktCeGhZUEFma2RpTnRSSE1UOEh1QS84UytOK0JQOFRrY3QvQlFMOHZBLyt5YytQbUhTLzNHRXJ3Vnd1Yk5yWWd1NFlCY2h1a0JkNW11TStMbUdNV2JFSDJXVXg2K2pPWTNQVnpKQWtxeWZQV3lWdi9LaWJ4KzNNWWdIWG81VDFUVWlXVW5jNk5tNU5aZ0V3Ry9yYUJkZ0FyOFdlN2hrbmxmaG9EYnVOR0pBY3ZScDFidGZTeUFBQWdBRWxFUVZRYk4vV2plL2VwMWhGWTNUeUgxZU1BQTVqZnd0N05tOWdpOVQ0SnhEd2hBY2xpeFZ3alJRSEdEZUlKQnRBclorOEJjRi9sNmR5NGVkcTVjZk5SNThiTlBhek52WWN4MXJYWmx2VGZWZXpkUElPeE9GOGxNYmJyY3JIa2RSczM3dHFBbjNadTNCeDJidHdzY3owNWlDMDIrQUh3UFl5aCtYV1NVMXI1a3QvMm4vZElqamRGd244Q2EyL0tYL3dxS1VKemp3VHdSc25sRGhhZzhEb0dZazc4bkJleHdJZVhaejFqelRPTDhmdGU1OGJOK3hvSE9qZHVqbU45cUo5MWJ0dzg5REk5MFBkZVA2ZXoyaTJVeWdONlAzalpsY05TaS9vQk5pNzlFR1AzZjRDMTI4dFl2MW9Ddm9yVjkrOWpET212WXUvZ0FZazkwOExVRUFROFhNVUNJUVMwdm9RQnhTOWpiZjFUV0orNVRucTNQNC8xNTh1a1RVdWR5UWtpZXdjTENQbTk3TGcyMW1lKzV0Lzljd3pnL2hPc0g3Mkw5YUVIWHE2ZnhjYWdpOWg0OUd6RC9XdXR0N3VqdHJxTzV6dkQyTDV5aFAyVkJYOEx5MWsyY3p3b0d1UllaMjI0ZkVNNkY3ZzA2L3I1UnJEcDJIQk8zUWEwM0VCMmI5L0syYlV3SDBoVUFyczE5OVJZMS9LTnVzYmhRWGJkTXI4WExoOVo0OFJvWVJKdkczcFdkeEkveXNCZmpZTXpwVlhuc0RGSmxpeWFncHZraUp1UTVqVEpLNHJkRy9Pb3libTZDVHpqa2VNOVVsUitHZWxPNm90Nmx2eisxMGxTcEtmWW5LY0FIVWthUTNKc0tKTCtPY3dCRzUxZGN2b2NBZys3dDIvMXU3ZHZLZHBlVHFpclZKMGpaZnNnTVZTaUhMWWk5bXRCdys3dFd6Mi96d1FIQVVnT04wbEpDalRyNU5lWXcvUTh3MkpyZTdWSURMY3o3VHo5ODV3V0F3WWdPWndnOWFFb1VSZjc1cWhyOHE2cS95WC83a3duZWhncm9oVDVtUTRwcUxBazIwMWpZVjVQN21TY1ZkOFJ6SzY3cCtSMHp4cDd4VmJaS09wekFhczk1aUJHQkFUeTRBQ3B0OEIwdjR2M1hpa1NZN1hSdkk1elVFZmp3UUFiTDJibC90VDdocFMzVitWcVk4NWV0UXM1SnlkWUh6L0NBSmtsT1UzRE5lWDgzYWQrelJJRGM2UjhjcW5ZMnE0b3EvanpTV0k0Qm92RU1hS0RTMjJIY3V1ODB2d2RYdmI3WGNMR2VyR2E2c1lBcFU4WllmT0Z4cm8rMXI1V0EyQ21OZjQxQW5NdUJoVDVjYzloWTJwc2U0ZWtkYVAyUGdKOTlTd1BzRUJNN1FIMG5LY2tNQkJzUGE4QW0rWEM1RW9WQUNUMm5zWnFBUVZBUmJKZTVaaVFRSldvU0tSNVNZcERtbk8weGpzTzQwaytmc1R4cGE1ZEtHM0FPZ2xFVnYzRWRueVh0S2ZleE9hUHcyeXNXTUtWaFlxdDdSWC83aEcydmkzQkYzOUhNYUJxeWpKZ3VNa2lRS3ByUjBCYjRNMElhMXNIcE9BSTdWRnpJRTUxcS9uNGhKVE9TUURna0FUU1F6VTRWUDl2a0ZpZFk3KzMxaGJsK0pHQnZPQnN3bTQxK0VjQkJnTXYveURNdGRyN3hMMTdYTDlGaFFRRk4rdThQTDlxZWIvdTdWdEgzZHUzQkFwcHJ0QzRvT0E4QlQva3VkUG5NWUZDNDQvUmZLNjFqK3BlS1FjZzVRNWZKNjJOOUE3VkhoUmdVUVlHZDdNQUcvK3pERnJ5WjFGYlZPb3lCWFFjYXczZnNDNVFPK3BnNCtOVUhXb2ZvUCs5NzJtT25WcmorMmZyR1BqZE5KK3ZrUHhqalZZWXcvY1RKS1czL0Q2bm1JL2toTVMyMVRNb1FQMStDRkNZWU9PU1pMWm50YnNMeGRiMmxWbmw4MnRxYklDVUttWGZ5N1NIK1VrZXpiaUU1cWd4U1ZWTi9xNGxiRDVYWHhYZ1BjSDYrQ2xVVXFURXRDdmFwOVg2RWpNUThTTFdCalk4TUNoL3ZxaVNwekszd28rQ0YyUWFLM0xHdVZUVDlIT2hTTXBMZFdPNTV2SUp0bCtNZFpYdnc5UW5tc2FDR0x4V2FYZGh2NlBqSWdzN2xxVkhrbURYWEJIN3ZBSVJGSXdSZzVuR0pNYnlCRnYvMUsxUm81VnI0akJXVC9VcDdmWFAydTluMTUzMzJJVXRiR0VMVzloUHNDMWpDNVdYL1A4alVrNGxzV2lYTWNEdHl3N29SRnVTekRCcHd1NlFuSlozc0VYUUNRWlFyR0FMdDFYT2wvYzN0eFBnZHpINVpFbmN2bzlONWxySVNMSjBBb245R2lSOEZibW5EZG5MR05BdE51ODliS0VZRjRzdlV0MjA1UXhrT1p0N1ZObkN1YTFoaTJVeC92YUFjVjJlMW1oUGtLTlZnRzZVVEY3RG1JeHlkbHlqNmhpYnNnWkc3TGkzdS9NV2lTVXVpNHRmYmFLUHNRVzdjdVRHcURsRnFvdHh1TzduVmZMWGRtN2NIUFYyZC9iSTJNME4xc2ZhbTV4VmNzSkRBdmpWWnE2UVFPbFZZTFczdTNQczk2dXRkd2ZNb3JNbEJqZ283NWtBNEd0WWV4QXI5eEFESWljazV2S1JHT0M5M1owSEdGaTVqRWtjcTkxcDhUbkJRRDZCeDJPU0hLaGs2QzZSSEJvL2o0SExGekYyZXN5L1BMZWRSekxhang5bXVhTlgvUE96MktsL0J5dHpmRzR3WVBjZEVzQXh3QUJSTWNua1VCeGdkWDNYNzFmMy90N0Mzb1h5WVNvaWROT3Y5dzJTczJ3SmF4L1h2RXdYUXBsYUpDYjNWQjZuQnZ1Mlgrc1BnQjk2UC9vV1NVcTloYjNmdi9DeWlFMnQ5Ny9uWmJwS0dzTVVnUE04OE91OTNaMy9ZMVl1WUg4dlYwbjk0aVcvejVleC9qVnVxcnVGSmZOTjlaa1J0ck8rbjhGWW1XSVJ6eEhKbXdNeE0rK2JIMTlYaGxuZkJ5dFpTZzNQTXZJTmEyTjUvUE1qUlpOVFpYN0tJaGhhNXlpVGFYNlplOU1iN3RzU0tOU3RZWjM2Smo0R2MwUm1SR1JBaUpuVjB2TjNVMzY2aS80YzY5M2J0L2JEYy9ROE9oMlNYT0FSS1orakFQcDFVcjUzdlVmbEFiNkRPUXJ6M0xvQ201dnFmMWJ1TllHU2NnNk41R0QwWnhPRFNXeHlyUi9uVWlJSXpzcVluMVY5UUhLUjU3SnVrdlNWREdwZkxJanpYdXRwV1RkajZUdHpRODZyT0tmSThWK3lHYlByRFB6Y21mbE44MmZONzMrV0JhZVJaRWhuMWwxZ0xVUlFyYzRHSkFkZmZnMnRCNVZuVDB5VnV1dEZSbnBlRGdGWTQzQXNwRDVhRyt6WHJlYlpuZ1ZBdHpBQWp4b1FPVGZsRVJmNEcyVU5jNmZwS2xWWlZMMWpNVThGWms5d1JwTS83MFZTZlp5R01tbU5MZEJaVERRNXlhZFlXK0hla3YzWHVsUGdaeXl2MUFNMGZrWkhhbVEvaThuU3dabXZOZlYwa1dyYkthVzRTWTd2RmE4ZktSRDBTS3huc1lEcm1KQUgyTHFyTGNEZHI3Zmh6NlExdklLRGp6Tm5yS1RYci9qMUh2aHppQVd0OTNuWjYwMXIwcUhmKzlDZlQrOSs2UC8zdkkyWERNZnUvOC9lbXdSSmxtWG5lYjhQRWVFUmtXTmxqVDJoSi9RRW9BRTBTUmdBSTV3VUpaRTBiU2pUUmh0QnNwUjIwaXBXc1V5TFphNXlxd1hOWWlsS0pqTVphUVl6YXJBMjZZRVVtcGdiVGFBSG9MdXF1cnFyS2lzcmg1ZzlQSHpRNHB6djNmT3V2K2Z1RVpsVklycjltSVZGaFB0Nzk5MTczNzNubm5QK00xaWtKOFp3YU0zbm1xakF0aXpTZUZKNHFtOGxaK3hKUDZXS0o2dERXd1k0TGVOc2ZLSUU1bGZXcHovdjJPZXQxYlQyL1N4N3FBU0FuVXZxRlR1N01RVXJ3RmRIRHB6anFGSURKakcyaFZrZ3dyalpNNmNPYk5WbC9jRGhtWDBWMDlsSFFQdFVDVnlKK2lzNlFWdjI3aDh5UGwrYkZ6NGZJMzkvTFZsVUt2VmQ0VFd4WGZUZ3NWSzJqaGpObnArSGRieXhLVlZ5ZEVhUlhIL2l2SFQrZDY0RVNFNExpMm9sM2U1Q0N2TlhtZTl3bmwvYU1ROStVYVRTRHRTOC9sak9jODdUdUM3OTJlZlpkNlNxaHU5UTBnZXdpSDBZKzAyYTNVcXE0WEJOUEZOeGRKajRPWFdvSmM1bUo4NDhJc1liZGZwd2xrZUhrbW5HRStsSG93T1RnN3JYZkd6dy82YTFDUitzbk0xRlNnMk0vQUsvSGN2c1BDMTV5WUlhbVFlWmVrdUx6L09OWW1mM1JwVEpHNGpvM0czWk9VQ0d3NVlzc3cvN0gyZUx5UE53RHFGTVFjd2NSMnIxbHN3V1VaWWpDWHgySXVPajNJczlqZmZSK0U3REdvM0FiaTUvTU5keHZkWHg0cFpmVDdhR09oc21NZ25QQXJBZUs1Mm5uY0I3NEErYk10Q1M1K2NPQ1ZKYUE2MStOVXNHZXRJNHlOY3pXUi9DTzRLZkRzTm4xRWVYVWxSL1hPOFhxZ2FwSUNOMVpYSkt5V01McnhuczhrQzVOdGxmRVZ6T2dPYjRVM0hNRHVmL3Bjb3hyV2hGSzFyUmlsYlVsYVdLSGNvT3NpT1pjUG9qR1hoeVV5WllmYnNCc0VIeDRaQkVHT3Q2dE9CWTBwbW5mWDFEQmt4TU5Sc3hlaG42RTBsLzNydDc3L0ZnZisvQzI1cktnSXlYSlIzMTd0NzdvWU1iUno2R3JxUlBEUGIzL3JIMzlkUi9EbVRSd3FSWkpDM1BEUi8zVkFiNmZESE0xeng2TEs4N0pBT2s4UUwrbWt5WWVVOEdwci90YlgzTisvQzJwSTNCL2w0RXpLamxKSVdJRy8rdUlrVE1Jd2ZvZjBVcE5mZUp6SGp4aTdMM0FTMGEyenc2Q244VG1mdU9iRTF0S2RWSGJ2dHppU3FuZG1uYlAvdXN0M0htUDNqWTUxUUI5WnM2NVlBL2RZMHgyRXNtQ0o3SWxCRUU1dytVNnFWMFpWSEI3Y0grM3BrLzY0Sm5oZWp4Vi95NlIvTEl0Y0grSGdaMERFRUlpYVNpNXYrQkRBVDhpYy9SV3dxR0JnZWVuOGdpNkQ4cld3TS9sWUgxZDJRS0J5QXVhWUcrcEFUNHNpZDVyOXV5Q0ZHaU10NlhPVGw4NUpTOW81RTgycmJKNGNIbmR5dGMveTNaT0I3S1Urc3BHVVh3VEpmYzZDa2I0OU5GRGhWS3RXMmlranVVcmN1b2FFNWtpdDBYbFBpTnN1ZVdTb2VhRGZJb0JFZVNDaG1mZVJqNkdRRmd5ZmJLajJTT0FxYysvdGVVdkpuWC9KNGZ5S0tQYWVlR3pGbmwxd2I3ZTMvWnUzc3Y3czlJbjFGYTh5MTViYnJMZ3Z3LzY5UUFVRlFVdHhlZ2dFVlAzdEpRVHR1dXhGYWUzd1FZMS9TemxvS2lMTTJtN0t0dGJ3R1ZVWXZGem01dHBFV0RnYUNPMkN2ck1xL3BRWmpyY1dFcE90ZGw4MGE2TkNrcC9vM0FSaE81RVNPQ25FM1hFVDBCd0Vra1J4Tmg1RG5ycHhxNDdEY01FeFhLRE1Xa2RLTkc0S21EcmFTYkkvcURmZHhrRU1CcHB1ZjNYQ3QyZG8reTUxM3JQN2gvVUhOdjlIYkh5Tkh4ZFVtOVU5SjJSaU1VUnBsTmVhMnNPZk0wUXdEbUFBS1h1VGNqK0RMUnhFME9FYXc1VXJNdXUxNXJLUnFGNXprOStEd0N0bkJtbC9XQW0vcFJCNkRsUnVyb1FIRkZnMUhKSXhiTlI1RlNqUU44eGJUeWJjMm1iMjNpcmJHbTRscFRuNHVVaGwxS3h0dVk3bS9rWUdxOGhwOUZNaTlyYnQ1MXNiMjU1UDNKMDlPWFBDMThqb05xS1V2NHZBL2Q0QnZUb0VabkJzQlgrcjRXZUFnOEN6NkJZMEhIMTh2Y3ZlWDg0YW5jeWJDZjZsUFNObWx0bVFmZTNZR01iN1hsZ0VOaDZlNXh2cXlUUVVsckh3SGtDQWpmVktxdmVoaXV3U2tJUS9ta3NEcXBYU1dIVkJ5VTQvdmFsTW5VUTZYbzIyZEtnT0NXYkM0dmxHcDFTcW5XNHFuUDBkRDM4VXZleDl0S2N6MlM2WDg0R2N2bmhiU2FBRDg0MFhDdTVPY1hobXFpSzZkS2U0d2F3SndaR3c0K1NpbFMrVWxzYkI1ZlVuSTRIRHJJbG9QQVV5MlgxUXVRWWx2SndUS201R2Nka0o1N1MzYTJUV1RSMzRBOVJMb3Z5N3VJRmw3VG5KcXhidnlubGljTzVFM2pRamNoTlRWMU45dEtkYThydkNyd0lkNFpqcWFzOFpHZjV3RExaZFlkWlliL1FQQW13SGw0WDNRWTRSbDFRQmJ2aERPbUt3TlQxNVVjdStDOThLZ0xlU3Jsd2pJQTVQeG5JV1huK2FVZGtBTnhkaXc2enp0S2poYlBGZjBiempGNFoxNWFoTDlqMWdTY0VMcEt2Q05tbDFDNGZ5empENUdpZkl0K3NPNTdvbnh2aS9oM1JvQld3enI1SVNQMlR4bDVyWFIyOWdwTFNZNFRZRzFiUllvZUp2cWJFbDExMStKSWhKeDVzOWpaZmRSUDBjeG5oVVhvc25lWVU3SkdBRkxYRWVmcDJoeSt4LzVzTGVDTm5NbVBpcDNkRDhPOU9GZEdPWmVJL3BMbitYbDZvdVRjaldORmRBcUl3Umc0bXNXVXhWdEtVYnBsNW8zQ1VqRFBsZE5jRHpueWZsWGVuVDlqVTlYeU5zaitwMHFaTXdZeS9vY2o2bGpCZVNFUTViTHlhR0hlMDVZL3R4MzBBK1NLdGxKNjUybGhUazdZZWJnT1dSTkNGaUROTTd3R2ViaVVrV3JtcVhSMkNycmF1cEpEMkZRMng0d1Yyem5QakJsUU9MYzRIK3IyYWNmN1ZMZk9hRWYwTzVNVFMvbHhTVnIzKzhacWRxWmMwWXBXdEtJVi9Sd1FobzJIL3ZlL2xRRU1LTXN0V2JyWDJrUEdRU3FNa3h5Q0hVblhCL3Q3eDdLSVJvUWgwbDI5dWtTLzNsRzF0aWYwTi80RG9QSEkrMHFVNVZjazNSenM3NzBqTzNnUkVqOHQ2Ui9JZ0U4cHBYcjYwTDgva29Fb0NObEVFYjRxUzVXN2lJajhpL1YycEZTajlTMVZqUjNYdkU4WHNybkh5SFRoZ0MxS0puTlhLdnIrZDIrd3YzYzJEL3owZHJveTBPclhaRURpdS82c0QyVUMxTHVTL2hNbDBJd2FKSXlKbEdWUFplQjIzWE1RdmdGTy8wcjIvdmovU01rb3ZDWnpCUGljVWtUd20wcktOaldUMy9JK2JxcEJFUS9SM0hQSjEyNGx6ZHhnZis4a3R1dnplQkMrdi9EdlB5V2I3NWNrSFE3MjkzNGttNnRQeWFKeVQyWHI4VkJKSUVWUXBzNGlob0U3U2dJMEtiVllmNU02ME0zN2RUalkzL3ZmWkd2N3A3SjFHcFgycVpLenhxZVZqRzA1NGVUUWx1MmJhSEQ0Mk1qSFZMdHVmYzJ5eG44bzJ5ZHZLQUgxSDhyZTB6aXMvWGxnNjZLK2xIeHRzTDgzbEh2Wkt3RWxySnR6MmR6ZFZqVUZIZEgwS0JUczQza3BJVEVhVG1TUnYzbE56Mi9LOWtGTSs3Y3BNOXlkKysrSDFLSU8vZjlUcFlpVWwyVFJ2SnVTUHVmcjlpUnpZRUNKQjRUQ0FXaWxGQVJxQWt3Y1lPa1VGdm0xbEJLMndKZ3dkdTlnQU1GVzhCck82MUpWdklBWFBaTXhOSHczN2FlYXVoZzlyZ3A2NVVyNGxRQzdvSFNqT05meERKVGZDRHFJNjVyR3ZJREsxTGo5K3JUVGNXN3d1aWZDZFdiT2loU2wwbFBWTUhKTGlXZXdyK3VJbE12VUFJK3A3azc3SVEyZEd6VzJaQWJaU2wrOEg5dEtmS25sYmVOb2R1YkdxSnN5NDloWkR0VDJVOFFYS1htNzRYZTcyTms5OE9jMlJZRjB2ZTFHWXlVT0NmMFV0ZHVSZ2RTamZuMmR1cVhKKzNiaXo3am0rN2JPTVFaK2prSHVVb0IxelhNajJEbVBXT1BJVGF6dlN4bXRBK2liMXhITERkaVhJY0NFcGUvTElob2FlVkFEMFVjaTB1WUJCZkFKbkNMYlNwbGtJSjRMV0JDakFrdmpJZk9VR1dEcjZ1TkZhcFJuRmxHL0poSWJNTGF3YUpPbTlKMnNqWGEyTm5KUWlKU3lNWG8zOHN5UjNCblg5MlhGOGFPd2VyaUFCZFFYeHBFVHVxNXFOZ2FpT09YM2pmc1A3ai8xOWtqNWlHdzFuSE9HbmZrWXRsVjlUMFNTNXVjTGdGYnVnRWRHSytya2tua3FsajRpaXhScG9ROVZyYnNab3p1Zkt1bEc5QWR3R0VlY3h6SitUNVlubkZuZmtQRjczaUZBNTZrU2lGR0NQVFhya1hFU0dROFlBM0ZPa080WlEvNTVQTStLbmQydW53bGpKUWVBdWpXT3c4eEVxYmJqMHJKQmNBN29LVVd5MGVjb3owd2NSQ0RpdFhRV1VlS0phNm9IUXVjUklCbGxxZksrY2RaTWxaeU9OOEs0OC9IMGxMSnVISVYyN2lqeEFWSmoxeEhweDNsbU8veFFyNU4yeVZneEExd1hLUjI2bElBNW5FSndOcHZLMTJ4aGFiVXI3OWZYTm1BTyswbEtnQVNBZjlPNUMvOUUxNTBobkhPQ3N3aWdZYVd1ODFYSSszWU11RmpzN0U0YVpBVE9jL2JWbGM5eitFRVI2bERYN2RGK3lnYlFsdkVTQWg0QVhpNGpYOGZNTFZJMTZweXhYZFk1RHFlVFd1ZXJtak5GcXRZVTVuZnA0TFZnWDhiK2poZkljcVFsUnJmdVNycGVXRjF4NWhzd2oydHV5N002S0RsMWM5NWdqNUdTdmp2UGlRUlpaMmxlRTY2YktnUkRGTlVvVlZLNVYrNXo0SzhNbk1tYXh2NkFUUkNlQUcva3JJdE9WOWRrdkhyWVQzWFk2US8xeFprbmJMSVJaQ1FyRVZtUHlHZ0lUeTVsY2QvUDBZRjFuaTJHckpDQXgvR2R4SFVWN3huS2RPL1lMbVBGS1FGUXR1UW5RWDVDTnN6TERKWDdKZ0RFT0tzQ3NpTjdUd3FMQkdaZHNEYVJuYWlyamxNSVRsc1J3TTdQNlh4dVNtY1MrRWtZUjlSek83Nm1LZzZoOEtSd2Y1TU9IMlhWdHZQTUs4bXVXVDlYTnFNVnJXaEZLL3BiUmdoRWovem5QU1dCZjAwV1RidElXQ1ZGNFZSMklMYjg5K3VTUGh6czd6MlcxY3o4b2hhRHZ6LzI1LzlBcHNqRU5OSGZWUUpRdHdmN2UyTlZEY1FZSWppbzhXRGRrRVhIeGJvZVJLYmU5bXYvbml3UzgxMGw0OUU3TXZCMEdmcUQwRjg4dmc2VWF2Z2NLWUd1MzFDS0tQNGpmMjRVM3FrWDAvWHJSektBTUlJM2QyVEE0RUFwbGRpUWRNV3ExakI5U1FaU2ZpOERqQThIKzN2dmVsOE9aWUxOcDN3Y1R5WDlzVktLbTJOSko5NDJBTmpFNStwQ0ZrMzZiVy8zN1JERjNKSE4rNGxNR2YyTWorbWFrdFBBcjhzRXZRK1ZsQndBTUFUZmlvQlJVMy82VXJURWZhUXFPNUwwZFJsZ1BWYUtzTDJRN1pYdlNEcU5kYVZyb2wzbGEvWFBaUE4xS0h0WEdMV1c2ZThIRGxyamdVc0s5Vml2K2l1eWVyL3p4dlpNS1RYNjJoSjcrMk1sVDRQYzl0OG5TbUFtWTNyMlVVV25adW50aCs0RUlILzJvWXcvRXNHTzBzRTZ5VUZnd0NHVTl6STlvZitQUVN3SElLSWpDdnVzckowcWo2QnBTTVhPbnZ1cFVucm9iVm1VK29ta1o0UDlQVktRWGZnY1B3MXRrL3F1c2I3YXp5azFlYW92RmZWVmN3OXJncWpKa2x5QkE2UWd3bkp1S3E4bG4xblhiK3FJUlcvbnBWUHlOUmg5WWxwU0lwcVhpallzUXNwbnBmT3czRXRCdVkwR3FHajQ0dG1qQURoMWlvWkk1QWJDeU53RStBRG00Y0FUNTVlc0RwRUFEUTc3MVlpNThzeFdnekVxQUdZWVgrQ0YxNVVNRTlINGlIRzVKVE9Ncm9WbkVEMU1YM0VZSWswaHZJOG92UWdXdEdVR0JWS1NuaWg1dzNNK255OWgxQnhJcytrR01aTDFVKzNqYm5obmdCUkxweXRlZ2dCYWF0c014cU5PRG9LL0NDcXFLVDhyejFXS2xqNlZabXRmWDRKYVVwazZqK2V5WHk5OWZ2Ym5SR3ZWT0tkTWlwM2RtZFIwZWVUQ0FtZVlpYSt6dWZ6VjEzOHMwY0wxRlVOcVA2VU5aZTlKeWVpWnB5R09QS1BsLytlQVZNejZFRUd5NXlMZnMwVDh6ak9tWXZTUCs1UzVpR2tPNlM4QUFySWo4eFBCaVVwcS9zeFpBTjY2SmRzM204WE83bUUvMVRXTzcrbFV5Y0V0WCtjWVFxbWpxK3g1T0pJT2xReW5aSkxpRElqcEpNczU5MzE3Vk5QbWdSTDQydzczNVFCeVRIZDVFZFl0cWV5SlBPTDhIaXFWOEpIUGpmb1A3ci9yN1YvNGZWTVpyMldkWUVDRzE1NHJ5Wk41U3RnS0ZTbktsNGhDZUNUajR6d2g3ZVYxZjJibFhISStqc0Y0S3BVcFdjdTk0TitkcVFyYUxoVXQ3bjJsTG5kSFNjWWMrM2pQWlZHdmxDYVMwbm5DdFRoaDRwVFlsZ0h0T1NCUU4wZlFwdXc4YndLY1l2VDlVVEMycjh2cVhEL0oxaExuT1RXbkZjYkZtWEpjZHhZV0tVcDRLanRQanpJSGkvdzhaeTl2K0Z3UitZMWVFVE1BaklxVTNqWTZlMGhKRjRuOWtKL25zV3hENUprenNtbWtzRFlxanRYZVB2b0RnUUdkd2h5NHlCcXl0TjY3SktGVDFaNFYvWlFDL1lXYzV6bndJcHR6N0RUeHVwanA0YW44UE0vbGNkcXBBZm5qZGZEMjZNUWovM3NaMlNzZlF5bHJORDAvWEV1WkNVQXFaQlQyc1dTeXhqeDlaQ0xQcUxDQXY3V1YwZ1ZIaDY3U29kcnZCL2lIVHh3cThacmovb1A3WkRrWUs5VW9MN1BXS0VYdDR6QVUxenBPZnk5aWpkNldwZWNmcXRuSmsrZTBGVkpFaC9PY1BSUFBZaHg3NEVtOHoxT2x1dldkbXZjYTF4VE9ZUmN5cHd6NFZ2d0JXQzNUSEdleUVuMUhWc3ZYTU5IK1EvNE9aeUpsWXJicjdvMDZWa2FjQzJWMmhQemVNTlpwK0luRStSL25CQ0ErQXN6clN1OWtGSFR4RFNVK0crL0I1Z3lQWFVadjRkNlc3ek5xY3BOdEI3bUhQczFFdURmb2p6R1RBeFF6UHJSbCsrQXlkb1E0Vi9IdkZhMW9SU3RhMGQ4eWFnMzI5LzVqR2ZENTJJRW1qQjEzL0xOR1JTQkVtVzdMRGtYU2FOMlJDVC92eWc2cmY2TEY2ZGErSndNUk1RSjhVZExmQ2Q5L1U4bUw3cUUvcDZjVXBVc2Q0Nm1rNzhzQTQyc3l3MmRkRkMrcFhpY3l6K3pub1gvcHZ4RTJTVk1MOENPWjROS1Y5RHVTUGl0TC8vdFhNbTl4NXJpbDVJVityaFQ1R0JYNE5Sa3dqZkNLTitkN3ZidjNobDVqbGZGZ1RGSHY3cjNhZEwrRC9iMDczdDkxR1VCN1N3WWlQVlVTRkVqVHZDWHB0eVY5MWNmNUJ6TFFmbFAydmc1azZibEhIaG44ZVZtYTYzZGtDc0F0SllQVFZBbm9YZmZ2aWFMZVVnSll6eFFBOEt2UVlIOFBKVEVLZzlFVFBRSUxHSUlZODh1eWVyUTNsQndVM3BhQjNnTXAxVXI5S0NtbVRCN3M3MUhIOXplVTB2KzhvYVFJSUNoS2Fid3RTZitIYk05TUpMM1Z1M3Z2ZzQrNjMxZWx3ZjdlUDVTQjc0OWx0WkJIa243d3ZQVm9pYkJmRmtnT1BPNFYyYnI4Z3ZjTFpReGpKVXJyRTluOC8waTJkbjhxaTh6ZTlEWnUrblgvU3BhbWVoaWV0UzNiSTJzeW9QbVpVbFRIQnpKK2NFUEdsMnZYbk8vbkw4bjQ0cmxzL2tqM1BWYW9xZTNyaUxvMjdJVnU3KzY5anoweS9HOGJCVEIzYVlBeEFBa29UNDBwVmNPMUVXeUkzMTBLQUE2R0JaNC80LzE3U2NDMjQ5ZldHVHZqT051cTFySnM2aU9SSzNpMXc3TmpmVXVpRnZocDlWTzBLQUJDZEF6REk3djIrWm5YdEx6OVM2WFRjMFViNC9sSjloM1J2MGMxaGtQNStJajR3NmpMMklsOHUvRCtEOTBJL0pyZlIrWVQ2Z3NTbmNUL09NUWRLcDJ6UEpmYWphUXhPMVlDaVZxcVNlc1lQY3ZEMmkrTkw4L2pCUjdlQThhK1dBT04rbDVMcC9LZTh4eFM4WjByMVBwcTZzL3pQbS9KUHBVQWVGakRHT0NJWUNpanV1TjdpUDk3Y3hHMGc4cTk0dmZWUmJZdHZlOTU1c2N4UC9sWTY1NWZwUFNEMFNnMVdMUmVmTjlLZ1RlRWRhM1FIc0NmbE1DL3FSeVkrcmpXeVR6eU9VRG1BNUJpTGVDZ3huakw5SWhLKzE1eUhwTzF5MzVocjhjTUZTZDlyeGRlV0VwT25rMUVqV1R2SVU5NUhkZnVocElSV2pLZDhWRG1NRE1Ob05kRjROT3ZoV2M5N1hzZDN6bHpVNTUvL3ZjTkpXTTU5WWc3TXIyTGRNN0hTdEhuT0cyODZ2Y2RLUm1la2RVWWMxZEp6a0xmWmQ1ditYM3czc2RLR1dkS250NFBrWkZGaWtTSzV4NXBwUS9EL3gxdmwyd3V2UDlOVmV0R05zM1JobEtLMXRPYXM0cU1DUHcrV2dEQ2RtVjZFL3JJUUttdTg0Y09oSzBwT1NHaHk2N0w5RTRNMWRlVTBvZlNEMERXMmd3ZHF2S0JNdTNzSlhqYk5ma2M5eC9jZnk5cmYxMDJwMGU1UTR2L2liTVU1UlN3WlhBMkV5M0xlYjZtcEE4RGFKQW1Gd0FZQjZoeUx5ZzVBRVFBbU9nMGJBS2NKYVVNVlROWHlCN3gzSm5xT2ZnYXNwKzNTemFrUVRqZk5pU3J5WHFWOXJObmJTaWxubTJNNnZ3b3p5dUFyYXhQRXdkT2tXY0FobkRTT3dvOEVMNDlERHdQd0syaUF5aTlmOVpLVjltNGk1VHltcjIzOEYzR01TeWpXMXgxUHVQYW1QUDg2N0k5RVoyTERwdjRmRmpMZC96M2szNDFnd3pwcGdIOXJ2bXRJMVhCNW5kMCtRd0RpOFo2SmJrNHlEUlFkUGhnSHJiOU4yTWo4cm5VZTJyT2M5WlduZFBFYVQ4NXFXNkg3NklzVVpFUmFzN3pydExhazFJR2cwSGQ5ZjRaZ1RsVDJWcStiSW1ZcmpMSDBxQTM0REJUMlFlQkQ2RmZRVGdJUUMybGxONHg5YmFVTWlIQm13ZEtjZ3JmRGZOK1pmcW1sSnlPV2JPOGQzVGhlS1l0Y2xDT2M3TGhiWnozWjNrL2E0UXh6ajBmTTkyYnRZYmVFc2VYMnh4WDBjRXJXdEdLVnZRZktIVmxpdWlSUFBMWFUrdEtYdDl1c0wvWENMNTVGTmxVZHRBY0tnbWxwTUZZVjdYT2JCTjlYd2J5b0hDOUhMNDdrd0hEMy9YMnJ5c1pMMStSOUY5a2JiVmswWkJma1IxVUQ3UHZJMkNEd2ZTeHF0SEdseVZxQ0tHOFJ5RUdBUUlsNEJXLzlsZGxRUEFmS29HdHAwb1JPU2h5VWxLODhaaStwbVFBd0pBemNkQ1Zlck1kV2VUdnZQUWprcWZVOWI3OXRaS0hPdEVEMUxyOURhWElaY25tN2gvSlFORlRwWHBSZHdiN2V3ZVMrcktJVklRakZLQWoyZG9nRlF3S0xiOEJxMjc2V0M4TlJya1RBL01sbVVKLzAvOSs1UDBCV0dQTjRxbCtucVVHL3NEbmhYcGRieXJWTHU3SW5DakdxcVlsdm14LzI5Ni9HOTZIQTBsNWltL3FQM2RsQU45WFplc0FaUkNEU04yN1pwenZLYVhXbTVlbWVKaytyNmtoZGZVTG9ndWxHcjlmbFRrRE5FWnVYWUttTXI2R2tzQXM4VTBBQUNBQVNVUkJWSVh6QWNwMU9TYWZiL2JBaFF6Y0hjcHFhZ09lNElCQkpFUFhyNE9YZlVKbVBPekplTXd6YndQRGJLUytqRytSNWkrbXFhZC9MVmxtaGYrOVliMTFaR3VwbzdTWEhzcUEzL3g2REcvUnEveWplcDgvVTRSWDhCWHV3WU8rVmFPWTVTbGphOThGU3VReWhwaUc3M05sdUt6SGVRbUZyVFFZTmR3VFFlNUZiZUo4MHdtL1crRUhSeVFBMGxJeHpwNGZnYUxvTFYrSmVQQitkMlNSYkNkU0pXM2ZaV21tQm5DWTB4Z2xVVkl3OVBVa2pRdUxwcUEyTDBaOFBMVkhzcHB2SXpmMEhzdGtvRzJsRWdPUi8yQnN4NkRMM3ppbWtQMEVHYTJNSVBGK056a0dZQUFZTnEzOVlGeVFqMldaR25OeHpVK0tuZDN6dUFjeVVPNTVxZUx3VlhnS05COWZtU3IxWXpZa1Q1VzgvcVBqMXJ3SWgzbjdqWGZBTlZOZk43V3A2dU03SzFJOTUwYUh0cUltbGZOekdJUm5nT2ZNb0w0bWxhbndLd2JxUUFNbFdZeklpYWFVcExHZlphUmphQmRnUmNvY1RaUkFSNTdmazZWT2Y2NDEwV1FVdnlSRmdDRCtKa0lQR1liMVg2YlduV2R3ZFJDRGlKWk5WVE04eEgxTmxnR2Nid0N0WXVUMWRUbjRXdXpzNHZSNlF5a3pDdkpRTit6L2thK0h5QThleVhqYUdGQ2dDRmtLR3NZUno5UTh6VFh2ODBEVmlMTlJZVFgzeUZoVWdzYitjMDIyOXA3NTM4aHJBSEdBbDhkaHpvbHdQY3FNNG1kK1Q2OUlOWHVscXU3Rzd3aG04QmtSYXhYRHJ4Sll0SWhpbWFFSU9NWDY1T2hJeTBTN3M5WUFMZUhoQUJCazVxSVVVN2tldy9WVDJmd1NvUWRRc3g3YWlBU1lTcVRocUxCTUNrdFRrV3FWamhWcXNRYVFhUjZZekhrK0tTeXFtbnJNQUFTUmg2ejd2c0pCbTNsaS9nSGJwMHAybEtpTEFEeTBaV3VHZFRKUnF1MUlOcGs2bVE2blZpazVNTmJXa2xmMVBKOXhFc2twazFzQnFFc254cXpORjBITVc5ZGxKQnc2MXIyL2x6clBMd3ZjMVp5VkkzbmFiYVVzVHF4bDNtazh3MlljUEZVOXd6blhJbWpETzJnYUczdVZkVkxLb0RWNlI4d1lVWmFNS1JvaUErUDVXOU1XRHBRUjRJc1pUN1psVWZ5bEEwbk5lVTVhWXNiUUZBbGE5dDNseHNjS1dSMHlweDU0SnM2VjdmREQvTjZVOUt4cDNNdFNjUHhZMnVta2h1Q0RPZWhXbnFuaG1raHp3VUdmODFIZ2MxRy9pdnlVZVlwOHBSTDk2eUJuVDhabnNGZkc4bGdBeDZYc0RsL0t1a1gyd1ZJV3Vjd2U3RGM3SXVHVVZjcHN2bDdSQ1psVHhzOTRHVHNaVStEWk9Oend2TE13TjhPc0g5ekhlUm5IbnhPOE9wN3ZVZTZNbWVVYWJRSVp4YXhKNk14bEgvdzhqekxpSW9xeWI1U0JXNWtPQlgrTCszOW0zQitsUTg2S1ZyU2lGYTFvT1dwNXhOaVJQRExNd1NqcWNGeVhHUTZmTFFLM1F2MU9CSmZ0OFB0ek1rSHNLN0pEZ2tQL0hSbTQrMVRTZ1VlT3RtV0EzYWNsL2FiTVFQQjd2YnYzdnUvUFFZRHJTZnB2dFR5UTlXT2xPclpiU3ZVYmZpQTdzSDVWOVhXSGx5RVVWTWtFZzdjay9ZVU1nSWtlOFZ1Uy92dnMza01aU0VQVU1PbG1SNzI3OTU2RWlHejU3MXRLRWJoRStGRkhjRTMyN241VE5vZmZrdGM4NmQyOTExVERGOEZIc29POUoybmc2YVE3c25uNkhYL21NblFzaTNyOHN2Ly9uaXg2OGNENy82NU1nYmt1RS9adnl0S0ZyOG5leDAvOUdwVDVNaDFOdmdaclVpNXJzTDkzWFNsTk0wb3VxYkNwcHpoV3FsTThOeVcwei85dnlNRDZiNnNLcW0vTGpmaVNEbnQzNzEwYVFCanM3MkVzWXI4QUdqd2pPblN3djdjaGUrOUVjMzNlci9teWJQNmk4WkxvcjV6T0pQMXpKYUNpZTluK2VvVHFoa0lxNmVlTnlKM3pySnRLUnJUUCt6TWZ5UlhhWmFLdTY5YUhmMDdVM3FkazcrNDFwWHJVSTltN25QcjZsMnp1cnltbFJQKzdzb2pyRDcwL1JBM2dYZndER2I4WisrZGZVbnJIUTVuVHg1L0tVakZQdlU5M0pQMnVFaDlCbUk1cHNDUFE5Yzk3ZCs4ZDVlUDBxTjYvNzllOTZmMFlOTXhEUnlwcnVaZUsrRWYxVGxjMG56NHF4U2d6c3FEdzhuY0V4U3BwM3A3em1XVms0NUxYRTJsSFJEcEd5dEtvVWFRMGlpakRqS0dTTGplTUY2VjBKZ0k0Z0g3Y2QrR0dwQTJaQVhsaGhJcTN3UmtETDkxV1NoVjUzTS9xekFaRitZYVNJZnRJS2QyamxKelVla3JHdndQWjJYVk41aUEza1BRSWtDVE1CY2FIRFNWRDRhWXNZaTlHbVpicGxSZXR1VHJQL1RuemNWMzJibmorNFJYQndZNlNJZis1OTBYdytvOHBnNGRLSVBxbVBIM3FWZHArVHFNaGtkY1liWG1mNTJvMjhsYWVILzVGUG82VTEwQnJhbWZ1bmcxcloyR2Zya3BGU2hXSWdYYWVrVS9Gem01MzN2ZCtUUVF3eHc3cUtUeURPdWl4eHJhVUhLNHd4RVlnWnFSUUgvTTUzMzlkRkV2bk1tdlJ4M2hkczhaTlFLYWN2K1JHeTdvMk4yVHpSUXJheU5laU1SZ0hXQXlVWlJyY0FQamNEczgvbHMwZHpxV2w0VjdTNC81c0pvVTFTV3NCOEMwTnhEN3VONVNjZlMvbHlGU2t1cTR0SlVkbUtlbENVam9qTUdwajdJWnZkSlFNd3ROd0x4a2FEcFZLK3d4bGtiN1RJdFc5WmZ3bHVKYS9tM0J1dEdReVAwNjFaSjNpdk1BQXl4bEtWTy96OGs4aXg4N3pkYW9zRTRpL0g5N3JnUkxnUzlUYUIyRWNSRjNEaDhuQWRCQ2NNM0NHUW02dnJMOXd6WFdsRWt5bkNsRisvUWYzbnkwNVJzcFk0UkJ3UXlrenhubmY2MW1IZTVBQmVKZUFmWEVzZ1A4eFF1cmMrOWhUQW9oSlB4dXZpODV2elB1YVptdFVSNkJtMFhuUmxoYVhHQWd5VWtzcHk4TEJzakpkMWxiSG4zbVJPZmxjaVh6Y01mdURaTy8rVERaWFpCSzVsSlBtc3JMT2d2dkozQUdRei9sOEtnZWxGN1NCVFF2UWxQWWtXOVBQbEVvRjFBSFk4S0c1MlZPSzVOZzNJeCtFZHVUUHFUaDhScGtqYzZMSy8rK0U4NE45WEF1T0lxTXRrcjE5ZnQ1UWV0L3dVMEQzcVd5dTd5ang4SW5TbnI0bTIydlhsVEo4WUhlTHprS1hKaC9ETlI5akxCT3pjRnhaTyt5OWVEYmluQU9QWUowTXRVUnRhWitmU1Q5bEhNSmVjWkxwVHgyWm5ZbHo1Q3g3cDR3Ukc4V1pFdDhsYzVIOHVwTWFYdDJXcllzbXB4Tmt0WFBwY3UraVNKbVVjR2FOY2tya3E2VWVIT1FJaFh1bjRWb3A4VzhjZDBvSGhYNjF4am56VTlvdG04WVE5aER6aU1OSEJNOXo0SFdzNTNNdTRObVY3Q3F4VHcxOVpWL0ZXdURzOXhoeFg2ZWZ6OVVwVm1Ed2lsYTBvaFY5L05TVkNUN1VLbjFWS2NWVVdTZHFHVUFnQURKbDJpZlNyY3BBeWpWWnpWdEFxdGNsZlQrbVFIVkNnSlpNVVh4Vm9kWlM3KzQ5K2lxWkllR21EQ1RoLzJOWmhGNU9KN0kwMDlUbVJYRW5EZTVFVndlQW85Rm9VNWErOWEva0FwdURTZXNOL1ZwVHF0ZjdvU3pLOXJxc0R1a3p1VUx2NzJEc2RUdVBaUUxZaFZJOUlvdzlIU1VRa2Vpa1F6VVR3b1prYzNBYTNuZExWajk1V2ZCWDNxOHZoLytmeU9iOXFVeW9KQUlZUmZwTXBqQ3o3azU5REtUN3BpOWRqemFmdUtOQ1N4NFZHMUxhZG1WZzNmdEt4Zy9HOVV3cDB2bzFtWUhpY2UvdXZVV3BKV25uVE5MRHNQNHd0T0VWZUdtRmNiQy9GK3RjQTM2MG1BTUhmcWV5ZGZuTE1xZUNuOHJXMWkxSlAvVGZwSndqNWVkdnlPYjBobElOdForb0NqaGV5dER0Yy9zSkdhQW8xVWVVdmtnNjd0MjlkK0E4NUMwbHA1UTFTZTJzUnU4NEI0UUQ3NmtiSjdXeXhqS0Y1WFVaanpyUHZpT3E0bFRKRURLUXJlbTNaWHZ2cGd5UWVVbXBEaWlLUUV3L2hmS0xnaEw3MmdsOW1IcWIyN0ozU1gwcGxBckd2YUZVUTdnMTJOOER1RzM3R0E2OEwyc0xVanBQcFJYb2V4VjYwY3JMTXRFSXovSE1xTlJ5dHBjcC94UWlkWUpYNzZWQWlFZ0JiRnoyK2dvZjlxaVdtUGFRT285dFdaVFlzRWdwOWxETUlReDRZMjhuR2xISy9razZDWWJ0NkJtdndpSjB4c0h3VVFLU29SbjJNN3dIWng0TURadUYxZGFpalRYWk9hZHdEUUFKVWJtQUM0QTJDdU1uY25pZ2tJYXpScmtlZS8vYk1zTlFDVUwzVTdSUFhlMis2ektEVGVWZE5IanUxeEVHY002eUdhQ3dXQkN0RjZqazNTOW9qeEdoUmR1bGM0Q1NzU21QS0cra0d0RDllU2pPQldlSGxDTEM1enBxNVFaWVZRMWNNU0ptRXErdEdlZFVGcjFVdSs5OS9jMnR2MWxqS0N4bFNYaEN1QWJ3TmM0NzBRVGQwRzRqWUxDa2daOXNNMjFaMUFJR05JQWRvdmJLeUFiWjJzWHhCT1BtdWhMUGJId25SVXExU0hSSWJseXZqQ2R6NHVEN1MvRmQ1NDNIU3BFOThIT2lRM3NLYVI1citoeEJoNG1TTTJtNzJOazk2VCs0ZjFMczdCNnFCaHpwcDh3RUdJWFh3bnp5L2crVUhCeFpoNk5pWi9jRG1leURIbEkzci9CeURLV2IzbWZxRS9JdVg1WVo4V2Y0L1J3YXlXVDdsL3o1dy82RCsyYytIN2U4UDVRS0lyVW1OVkRKVUVURURYMkwwWGZvTUFETk55U2QrNXJpUERpUWdab2xvT2Y4T1BKUGVDdVIxbHN5blhhaTVDQTRWTXBHZ2J5S29YcmtSdHh5UFRidDgyQU1ueW9CaFJmU2JHM1lPWHppc2FyOFp1cnp1U0hwQStjRnorVFpjZm9QN2g4V2xuNFpBQ0ZHYW5mQ2U3bVF0RkY0dEdkNDVzamIyd3J6RHlEUjh2ZUZreGZPUUIzTmd1TmtCWnY0dThIQlY3SjFIZFBWVXVlWS9SQWp0bG1YZWNSWmVXNzBVK1FVZkJxK2xNOHBhWnBiTXBta0JKTENlVjRoZjRjYnFnRkIrNm5XNXlLS3dBT3lTWDZlZDdSY2ZWM2FXTm9wY0FIRkNGRjRSMHhCTzVMeDlTWkFveTRTVnJvYzc1aWhmc29rRTZNSDBmbHV5WFMyNHdYTmpIeWQ1dGtvU0tmT3V4MFhPN3VEQUg0UzhjMzZsQ3hDdk5PdlQ2RWNBWjI2Y1FBNFJzQ0lzd3I1TEVZWWN1YVZJSCt4c3d2ZkpqMDU4OXQwYmk5VDZ1T1dVaWFBRFZuOTdyRk1ieWFESGM1YjhOK1Qvb1A3eDc2UFR2MWVVazIzNVpubUduUXdTa0NkeThEbVBKdlFPdXZmNSsxRVZTZTg5Y3VBdjk3T3hIbFdMM3pNZWNyWVoxTGhoejdGdFlNdTFmUHZCaTdiSE5UdEQ1Y2x6cFRrcG03TmVYNmlXZWZhU2JHemV5VGp3Ymx1RkducTEwWUFOTm92SlhkaTdUKzRQN2lrenNzKzJWRFNaV09hKzZuUy9pcDVlZEF0NFhIMG0zbHNxY3IvaVBSdSs5eFVIRzh6UUgwbVcxY1llM1JXcHYxWUxwSHhjSjZ3OTlBRm80NWFLeWNIdVdrcWw5LzZXWFlWYU00OG4yZmZqZjM4aTN5ZHZZNStEdCtMODZsczNoZnFYRFY2eFNxMTlJcFd0S0lWUFNkRkFYVkxCbEJ5NkE5a05TcWZKeHBvNnZjZnl4UzZ4eklGL1VqU2oydkFYOG1FRktKSDNsSktMVzJkMnQ4akZlNmFMTkx1LzVFQnk3OHZpeHh0aWdoK1hRbk1PZW5kdmZlb2QvZmUrdzRjVFdVUm9iVlJzb0hPWlVEaUgwcjZYeVQ5YSsvREU3LzNUSmFxK28vbE5XSURzTkprTk1JUXNPbDkzSktCcmwrWEFaWFJJRWc3ZUZTL3B4U0ZRT3JhVSsvam40WXhOU3BjdmJ2M3ByMjc5eWIrazBmWmJrcjZ4dndwcWFWOHpkQ0hJeG5BUEhKUWFxQ2tESDFHVnZQNVA1TjBWOUkvazBmOStnOUtWY2NqVWEvTERFNXJnLzI5ZFY4VFc3SzUvSFhaL0gxRkJweCtUZ2FzdnlaVEVnNWxjelNYU0FIY3UzdnZ6M3AzNy8ycjN0MTdwZmQzNys2OWNlL3V2V1BaSGptNDRqNkphWDJHUGs5UFpZYXMxMlNLem11eWQvMm0veDcyN3Q0N2thMzE3OHVpa2orVTdhK2Z5dGJkMjVMK2pXeHZQSlNsc0g1SDBrdUQvYjFyRVRTL0JIVzhiYno3WG9RU1gwc08zazZrMHJIa1FNWTNqcFhTOE4xVVdnTTNCL3Q3WC9aMTBIVm5pN2JNYWFEbGJiWUcrM3R0LzM5VEJxb1RNZkNlYkM3eHJ1YlpDTi9uc2oyT2M4c1RHUkQrUk9aQVFxVEhnVkw2S295aE1aSVBROFhuWlI3TWF6N1dMZG43Zk5Pbm9PTjkrcjlrZk8wbk1qN3pYVmx0NFljS0JqTDJybzl0TEt2Ti9SM1p1cGluZUU0K2p2clZLN29hOVIvY240bGthbEo4NnNEV1RGbmluSmN5WTZSL2p5RXRnalByQVJpNEVrVmdZNWsrUThFUWVwSjlucWNobkNvWlNMa21ydW11YkJ3dGYyWW45c25iT2xPS1dzWElzUzBEY0xsMlE5S1dHOW9peFd3UUdLK1p5NHB4MlkwdUFESzV3eHhlOUp3SmVKb2pONUdxK3FscTluVmhhZnZLTVdaOXk2KzdYdXpzM2dpZkVUMFlVMG5QZlhjNUZTbjZsNHdpaC8zWlNENTRYYS9wM1JjN3UrV2F1NnlTUDI4OUtVWGpJUE1Da2tWZ1dES3dZTmx4czYrV2RuU29JMSt2akpXVXFHWC9NQ0F0MFJSZ0F1c3JSbzZVSHZzK3ZrNnhzN3RXN094MnMvSE9QZHZyZUZMOEx2UVRFTFRqOXpTMXlicU5SckxjMk5oZGN2eE5STG1QNkVBbHBYMDJrYTE3NXEvaUlPSDlKNUkySDN2WmQ5OWJPS294M3RMWks4NU5QcDRNRUw3U21leDlQRmZpN1VmOUIvY3hSaDZyUVRjcVVqcjZub3lIM1ZCVmZsbno5dWU5UitZTVowU2NZYTdKRExrWC9RZjNUL3NQN284em5uZ21rMzBPSkQyc0E1TGM0RTQ5UGVwK2J2b3pjQm9keVF5UEU5bjdpRVpVakxBeis3cHZLV0lIM2dZQXFwUWlPWWRLYVUweHdFb0pBRG4xTVdDNDVSMEE5SnlFK1IvNDUrekZVNWtNV2FheTlybUJUNjc1bWdKOElWVTI2L21hMG5vbEE5U2tidzQ4bkRQUitZaGE4RkRUdTV6NjNPUThaRnBZVkhndGVWODdmbThlaVFybzgyNTIyd2V5ODB4S3ZJK1U3dEJReGlmYXNyVjVROGEvMnNYTzdtWThML3pNd2NuN3B0S2V2aVhwZGpnYmlVaStGcDZEMDJkSHBvTlZIRWVVN1g5ZnF6a0FFeDFFeHVGL2VEcHJnN09STWpkNXZjNjY4NXkrNU5kdEZnYnVsNTk1MzhzeVNFM3J2NG5DV1Exb2N0Ui9jUCs0LzJBR05MMGxhVHZyWTJ4bmE5bnpQT2VKQzNoK1BpY1JUSXBSd1IyWCtYSitXOWNYenAybDU2bU9mTjl3cnJBUGFUL3U2Y2I3dmIvYlNnQXJjdXBFaWEvaUNNT2VlRW5TOVNDamtsV2dGcHlIbjNOdTE4eDNkRmpZa01sM01aTkdxU3NVS2RQRHVqOS8zWUZuenZPS28yUmMzMWwvbHBINVBnemppdmF0QXhrL1BaUUJ0amhTUHBQeldKN2hQUEl3ekJGajZZUjlSK1lLN0hCbGltT2ZMOVpnWmYwRHNJWC9sd0cxWjhqWFVZeTRKR1BObWY4MG5lZllITWc2UWVZMktPby9UZk1kZVJlbEJiYTgzYTd6OTVsSVZEK2pUK1I4TGdmTGVXWTRIM0RhaUE0ZDZDMmxmcnFzL09kemowNlZPNnhNcEVwMmtHbDQxeTMvYmhUNkhPVnA5REg2elZtVnA4NGVhUFpNd0xFNlBvdlBvN3pOOC9nUmZWSlZMbUh0a1dWQTRiczY0anlQemlIMHBaRVBSWjR3WjUxVWJOcStKdUEzTS9QczEweUs2dGtXblQxbjNuUGtNMHJ5OWd6L1dOR0tWclNpRlMxUExZOCs2OHFpUFArUkRMeDhXNTVhcFFHa25hSEIvbDY3Q1V3QWhGa215bXl3di9lR3BGK1RDVzJiTWtIdW9IZjMzcjkyc0dSREZqVjVKb3RJZktnVVZkcnk3LzRqbVdLQ0p6dUszTy9MVXZpZXlnOXZCMDVRcm45WjBpZGxBaVlwWnRaa1lNeUZrbmY1Qi9KSVdZK00vSUpTcldOU09yK1gxUkpkbHdudC80MnFIbDQvbFFrTkx5a3BpVDBmejdka0lQaXdkL2ZlTU5TQS9ZSk1JSGl6RG5qMDhlaDV3UjFQUy92ZlBVOGJrbjVQQmtCT3BOazZ1VDZtNnpKUTdQTXlqL0ExU1k5NmQrLzlpNW8rc1FaaVNpd0UydGVWaEhTTTZvZitlMHRtaE1FenRQVGFicGhENXZvamkzVDFPcnBkbWFHQ09vM1ViR3pMOWdEUkowUzdIV1RyYWxPMmRvaXNQNVh0NVZPbGRmN1lyenVRdllOTEt5U0QvVDFxWEgvVWtiOGE3TzkxOG5jUytKUms3LysyVWhUNWJWbmE4MjhwR1krZUtSa0ptQWRxbksvTDlqbUtCc2E2anN4cFkyYmZFSEV1bFduaGFKT2FtaHN5ZnZTYTkyRXFBOHkzWlB6c0pYL09tdi8rUDJWOGd2VjhMRXN6L2lYWjN2NEwvMndvcTZXTjF5OUF6Zit0QmdBM3BLNldqL201VS9xdTZEODhBakFKaHIxR0F3b2dTMVMrNUY3SFFjR0d6OFQ2UVZPdXVVci9wQmZucllzQ0dEeU5KMXFRcnM4VjNFNy93ZjN6SXFVOUk0cjJMTXdINmRha3RLOWJTa0FyOVZtblNwSDNwRkVteFN3QU12MDU3NGZvVzk2QlRFYUJYOU4rVElITkdTV0ZHbnBaTzZTeHU1Q2RlYTk0VzZmKy9FSDJyakdrYkN0RkliL25jMG0wVzBlV2duVllwSlJmNC80U1VaYUZwVE1sYmR4SkhaQVRqTXB0aFRTeDJUVkVaTStNdTJZT2lMNkthUjlyNy9OMmlRNlRrckVKbml5bE5LNlNxclZ3QXppNUZOVmR2NmdOZ05rd2xvbnNuWmJHcWRnV2YyZjdONmRvSkJuM1UzcGw5alpSNGpOUnF0NTI3VHVvMjl2QlFLTXdqbkhkV21nWXU1U01SbXZoLzlZeWJZUzI1bVl1S0xKSUNReldTZ0NBWk85L0puTkdCTGlDb1hXaUJNQlJPNDdvOGpJNklodHJTMWZrcS9Nb3JJTXk3WHY0N2tiL3dmMlpiRURPSTltWFVnSWJUNVJGSEY2aUQraGRFeGtmWFByOUxXaVhmWXg4ditXZlBjMzJCN3lhRk1WMWthNXhiMFJIRHNaUE5DZ0FRZG1lcXFDZ2xQWXNaeWVSdXFYUnVFaVI0VHdESGtRcVlNNE8wdWlmSzRFKzhYbm9UR3N5bVI1aitiWlNPbVhLTDAzOU15a0IxS09yOERhTXhmUE9nM3h2TFdpUGFHbEtHeERkT0JNMUgrNGgrdTlEMlp5OXJPVFkvYmh2S1lZN1N1QXZ4blAwd2lPbExHUHdxRWZlL0hXbE5VWGZJSGp4NHd5UTRGM3c3cWpObTBmZ29Udk1sQm53dHFpRGVlSHpER0FESUZLYnh0OEJlWjZGUElPRFJFdWVnclZJam54TGxmandkbG1UZ3pvZUVBRGdsbXovTlkxcnpmc3hseWNyMVY4bXBUa1I5MDNqWm81aTlCenpQMVhhS3pOblhOTTZ6YysxSUxPMWxhWFhYclRXQTdpQmN3M3lCbnoyckViMnBuM0FSNXdIR0ZmTVVFV0dxSFdaVHNwNGozTFEwZWVydGtac0VVb2hxQnExejNrMlZYcVBGLzJRQmoyVHlhTnpEUFd2bVIvMkUrbUxsMHBMSDNqK01Ic25VR21uQ2VEV3BzOGRNdlpRZGdiTlJGNERsZ2UrUWNUL3VZL2hsbExtQ3B3MUt2SkltS2Z6WmZiV1pjbm5kVVBWckNRZFdlYUVrNXJyR1FmenhObEZKcUZMbGY0cVV2UXNaOXJGaXhxbjh6cGtKdXl0WGIyWXNnV1JSMHRWZ0ZuaHU5S1JrM0dGUFptRHM1TnNIY1lJWVlqeWM4eDcvQnNuYS9qTUpEeXJwUVQwbHZKQnY1cENuZlpqbjNLK2RLa3NSb3YwckdYZlExRk44NDhOZGxIN1hiK0hqRjZsODNJbU0rZlpFRW81UGJiM291WHBGYTFvUlN2NldTV2lhYmNsL1ZjeUlWSXlJT1Y3a2o2OERJam9nRlpMSWRYc1pjbHJXUDZDRERDNUpRTnF6bnQzNyszNzk2UmRHdmozcDNLRHJLY0cvZ1ZKdjYza0NYakxtNTdJQUpXL1ZyWE9EaEhHdDVSU3l4d29lUUIvb0tSVVV6OTJHdWZGd2JHWC9WN3FXNVYxazBQRThyYWsvMUkyenh6MGYrTjkrSUwzNDRtU1IvZWZLb0ZjQ0JFWUFrWlhxVGw3R1hJZzZaL0pvbWVYb1IvSlFOdzNaVkczVHlUOXI3TDNNNmxiRXo0M1BiL3ZWNVRxUkEwbC9RdTV3QllpSEZ0S0JteVUwbTNabktONG9LeWpGRkxydHc0c3EzVmNJSVh3UncyZStSeWpiRE1HZ0lYemJKMlZhWjdDZkFDR1QyVnJiQ1RwSC92dnQyV1JxbWYrM1ZCZTYvc0svVnpUeHdEK3pubCtSK1ljZ0NQRk05aytwWjcwWi8zU0Q1V01DQU1sTUxheS9nTDRqbGQrYWFSWm90NDVoaU04TU5tSG16Snc1N3BzelQrVFJSb0RESk82Nzk5TCtuMS9oeWpZWXlXUU9LYzNsQlM2Mi83TWZ5dm5ZVTE4b0trRzhvcitkbEpVeGpCd0I4T3lsSUZXODlwUk1IZ0hwYmNSbUtnRGpaZDRCc2FoR2VEcUVrcGxUTGtZUVNJTU4zVkFZNTBSRHg2SmNiY2w0eDhYU2c1aUdIRk9pNTFkRE95bG81Q1NZZzhvMTVVWlE2TFJGdU9jWk8vbkxJQ1ZSSWNSd1JHakNqRUFZdlFIa0Q1VmplRlJ5ZkQ2VE1ZYlhsVUNEUjRyZWVzZkswVVpUNVhTeTNNZERpMFlVeC8yVXkxa2VSdG5pd0NjQUFBUCt3L3VIeFVweldaWEtZcXVYR2ZQYTNUdythWU1SaG1CMTJUY0N1QXpRQjl6aGVNZ1A2eVRpN0R1NFBPalJXQjRjTXJBZURNTmJiUVhHZC9jVU04NWp5TkFHUldRdFpmUFVaMUhQTWFTMmozYkFGUkhJTGVSRjlSOFhra2Rxd1MrTFZvNzhJcnllUmwvdTR3UkNtTnNwZGJ2Z3ZVR1lNTStKTFhldk5JSjNFZTJFVUMzNkV3QUVOek9ETWJvQTFQbkhTMTVyY1JseGppblAvSDl0MlYxY3dmKzNZekJ1RWdSbFpRSndjbU1kcDQ4ajBHdHFLbHRmSVUyWnRML3FXcTB2UzJQZGxhV3B0REJ3cHQrN1hzeWZzdTZpbzRRN2JCV29xTVBQUGhReVpEN3NwSmphWFJDSmZVbzd4RERObno5UkNyckw1SnVIM2w5Sk9OTk9QQzhvaFNCZktSVVE1Wm9RT2FCdjlFQktCbHpwSlRGb3FVczlYYzQvNldxMDFQRm1TcnNTeHlwY1ZJNnl2aFFTMHNZb1FPUVFkcGF6dUdSYkIyTysxbU5YYitQUFFhdkpzSjFKSk9aaVdxbVBOTE5NRGVEdnFWK3ZhTjZwMkhBWS9ieW1iZlI4ejV4ZnJXVW5HazVmOUV4aUpSbExPeDdRT0ZCbUx1QlVrUjVuQmRra09qTXhEc2FLdkVWMnVkK2dHeldTKzdNZHVScm5iWFlsWjNSaTNneUFPdWtuMUxuTXM4eHVsbWF3N3RZUTR0NFFKR3lFSXk4ZjVOaVRuMzNjSjVIL1FuZ0RvcE9VV1ZrWDVEVjhtd3lUZjFpL1VlWllGMlcybmR1T3VjaTFSaEhKNFYzU1dFZEZKWTVRa3ByQjlDMXRGOG83Y1VOSlY0UjU1VzV6dXVINHhBd1ZRMFE3MnVqQWlRRjhKNTEzNVBOOTRYY0NXTE9tSG1YT0VaTmxNN1hHVDR6ajN4ZWJubS9uOUxmZVhKVVVTM0J3TmpMMnV0ejdnTnNYcGZ4YXdCZ0tka1ZObVhuNnJOd0h3NG5GeTc3c2paUG52UDhMT1dzSWptcElwUE02RC9obXNpRFdML1RPaWVPUy9abklXQjR5ZmJxbkJnNUU4NXIxakZucVpSS01kUTZiR1E2STNzT25zemE0ZXlNa2J5OEw4QmZaTkNZUFVoS1lEcXlLbWNVdkJsbks3S1dUTU56ZUVhVVk2WmhQTzN3ZzlQWFZPbE1xQUR3TlhJZkRvcDFhYWQ1WnVta0ZKMUZMcU9mNTd5OVNEV1EyWGUxenArNUxwU0I3VG5RQysrRnhnNklsK1Zid3JVNGk3NlE5Ym1pRmExb1JUL0xSTnFOWDFBQ2Z5VURMUDc2c28zMTd0Njc4T2k5S3dzOXZidjNqZ2Y3ZXovdy9ueE9wbkRIQTQ0NktLUTdKa1ZLeDhGalVyQ2hvTHlucEJpUW5wV29EOUxyY2doellBTkl2aWJwbStGNUUvOXVOTmpmdTNEQWVVMDJYK3RLYVdyTFF6MzBtMmdmMHAwUmpmcU90L20rVWhUb2dVeVpQUXR0bEZGRjhzUHlvd1I0SEZ5Y3lGTGpMZ0tBLzBabWlMa2xpMWpHNHh6Qm9oYjhEWFJMVmpmNE05bm52eVY3L3g4Tzl2ZCtwQlROSzFtZFc0VHdOWm5EQWxHdkNITWxlRHpuMmJYZitidHQxMzMzSW9tMDNZUDl2Yk41L1F3UnlWdVNUcnlHTCs4b2puZEROaDluc3ZVN2tLM0wyN0sxZGF3NUtSN2o4d0xJakVKejVyVzNyK3pnc2VpWlNxRExHN0xJOTRmKzlhYWszL1cvRVF3UmtMOHA2VmVWNmlsL1YxWW4rVWMxRWVkdGY4WXRtYUh0VElrZmRDVmREUGIzRG1VUi9yWHo1TzhNQWZ6TTIvMlNqQStnWUpCMjZrQkpNWGhadG9aL2t2V0x2NTgwUk1qL09BT3ZveUYwYTdDL04xTUQyZnNaSFZCUUtFb0hncnF4cmVqRjBtVUJUKzZwdXo3N3JHSkkwdXg1TTZNTVp4U1ZVTnFmRysybmxNNThWT3pzemtTa1JJV3duMUk0eCs5TFJibXdPbFFvNlYzdloxNlhkbDJXaHZtb2I2bTlvdEcwVEZkZFErVmNGQ2xLTHdLekdOUngzdURNWDFOS0p6MVNpdWppdm5VbGd6M0dvcmEvcjVIM0tSb0ZGUDVIVHVrcHBmSWNLaG52aVRTTGlqK3BtWWZ5bEpGRjhqby9sMGNjRkR1N2c5QWVaeS95SE5HTk9LK05sZExCM3BMeEtkS1RUbVhwdW1LNitrbjRqTG1GeW5maVFQZDVlRWM5SmJCMVM5TEUzM2xkVGRSdVA5V2thZ1FxRlp3UC9Qb2pKVENIZDFaTGZnMXpJS1ZJaHJoT09IOTRCOGdhakowMHBNdWtRYzdCMkR6eVlJYUNrWW5uc1U2UkoyTzlQaHlXV3BxVkVXT0U3OXlJcndad2wzdHJ4MWtIOU1UMXJ0bklrMldvOHJ5NFJxNWdSRzNKM2xVWkJlUDhxbWw5RUYyQmt3ZEEwMXp5TlVXR2xtandadDh3cnR3WXgvcUs2NEhVTWxFTWR3QUFJQUJKUkVGVTlCZFhHRytrQ01LUENvdjRaeDNsQm1DQW9nMDNhQStMT1U1QWw2WG5CYlNkMW9wVUw1ZTVvVit4M21KdUVBV0FuY3I0SWxsMTRuNGdvOHBKT09QR1NyVjNxV01YM3ljZ01oSGVnT2psZnZQcllqUW80Tit6SWpuR1VMK1h2dUk4UEZGeUJBWFFROVlseThSanBjd1R2RnZPenBqK0ZmNVY4bGIvSDJNcmtlTHkrOCt6ZGRxUjhXNTBxcEhzZklkbk1uOGRtYjZLUWZlYUxBWHMwMndOVVNhQmxONW5mbjFiRFhwSmNKYTRjRDdUVTNJQXhuR0IycEViU2hrdzRJMmtpbVNmY2dZUzRVMEVOdUFEL1A5TUtkcHY1SUFvL0IyZGkvT2NkOFNjeHVkRUFFSkt3QlJqNS8xekhrMEtxOTNLT21jOXhYV2c4RHdBUXRZWmNnRG5CbWMzYlhYOHVYa3BDeWtBa24zTG1CSmxQSnluSXBoSFpHWHU0TGZXdDRndUhHbHF6NTk0bHZvY242cDY1c3c3dHlaK1BVNTNPTk5GK1NzSFU5Z1B6R0dubUhPZSsxZ20yVDFRZFBhb3BTSkY3VVg1R1g3U2xVUk5heWs1RURISDdIL1dGQTUvMklaS2VTTDBIYjA0NzhOTi83ZU1Qcy9BTjV5UXluY2kyd3VzUzg2cUMxWHJrdGVOT1RxTlJLQXF5dmFYUFZjbzQzTEgrOVVxZG5hZnFEbEtGTkFYbTkrUkF0OXFvaUNuUzJaSG5NaDRiWFFjR1N2VlFXYmRSQ0FQMnBhVmVqaThLaURGT2c3djVGd0p5T2YvU0RnUGR2dVc2V05VN095V2UrSXFmY2o2ODl6QVdwRXlOODA0RW1melg2ZGJScm1hOU1TNVV5UnJ0cFMvUXIvUkU4aUV4VHJsTTNTL21IMEdlWjY5eFROYUFUakZNWXZub0J1V2JZVDc4NHc5NWRuTkdSMzRUZzZRbDNhKzdEeG5IT2kwOEwrY1A1VU9XRXI4dTN4R21MOVdzYk5iNm1sRlN1R2ZnN2xkMlJvLzc0ZTA1OTcvdW5JcHNSOVI5MGRQakhhTUhLeU8vRGM2eEV6RDlmelBlQzZWdFdsRksxclJpbjZlcUN2em9MMGpBeVl3R3I2dHF1QzNOQzJLbUF4QVZ0ZnJ3TmExY1RIWTM2TTIwb1drendTd0UrL1lvYVFqQityd09CeklvbENmeUlRakZPam9kVFgyUHA0Tjl2ZU9KZjNucXRiZmt3eUkvSDBsTDY2eWEwb1Jwa1JQWDBqNm9VSjBKR21OQi90N0hPSVk3cnArN1EzWlFmMVE1bG40VlVtZlV2STZmdHY3UkIwdCtuK21CRkpYRHJ1UGdHai9vYVIvS1FQamYxSEpZQkJwWFFsOGV5SjdCeS81M3lnODg0U0JyNmtlWlA1Ti8vMUZHYmgySWh2L3l6S0FVRW9wdmFWVWh5eDY2alhTdkxUbFRoK2I4TEFFSUFkNGNrMGVVYVdxZDNBMHVsNlhyYU5OR2JDT3AvcWhwTGNHKzN0dktrV2psZldBQTdCNDNmL0htRko2dE9vRnpvay9EK01FQnBuck1vWDFpNUwrWnJDLzk4ajdWMGJWK2U4b0VLN0psR0xXNEVPWm8wWExBZXM0dnhpS1dOK2tneWJTZzBpOW1kUktXYjhCbHNheXVmNHRKU1Vkd09YUFpQdmdzVkxkemlQdkh6U1M4Y0s2Tk9SdDFZTzEwU2hKOU1nOFQvUTEyVjRpUmFBRyszc2Z5S0xEVDFkZzhQSjBXYVdpNmRwNTdkU0JNdmxuMGFpV0djVWp0V1hLM0RSWHRHazMvbDRBYXNWSUljbU1aN25ockNNenVNNnJGVW5rVy95ZTFHSTVUV1ZHbmpwandMeUl4bmc5UUFCSzVGQXBiUjZmWVJ5T3l1ZkFQNSs0VWw0cTZ6NGZVaktHa25aeHdIdnBwMVNNR0dDSU1NUGpuQnBtbkZXajBCNXlCOFlRREFRWTNHa1grV2txNHpFbzZOYzFHelUyY2dNSDZUWkpqMWVDSGFGL0dNT1pMNEJ2REpUSWNFT2xEQ1YxQnFKSitBMWZ6R3Nkc21aYVVxVU9iRTRkR1orZHlCMi9Nc1B5dG14Tm50WTRFc1QxWFN0ekJvTVE3eVNPSlJyaDJUUDhYNDQ3OUIwalVxdlkyUjI1Z1J0alhwbFdybUdQY0I3aVpCQ0JxZHhZbHFjb2hhSnp4MVhBVTM1eXczN0ZhQmVOeUpvMTFGUUE5bmswaDM4dHBHQklpOGE1YUt5amJlYStDZGl1QUUzTDlDY1lDK0VkVXNvb2dBRU9vOVlhaGpIZmgrVThCbEFKdzJPZVhySXJBMW9XNldJNDlQTCtKdjBIOTArS1p2NE9NQnJCOW84bGVxSkkwVDQ5V2Izd0dUQ2xTSkZVcDdKb3U3cjZ3SFZSVFVTcm90T2hSMHJKOEFnUUMwak11dUUrbmhYUG1tR3hzM3ZnbjBjZWcweUpRWmpvRlA3SEFSbEhnWnN5T1JDQVp5aVRWNW1ENDlBZnpwMElXTUtQNmRkSmtWSnAwcCtXMGxuRjNvVmlwQTFqckl2WUlXMHI2NjgwWWdlRFBNYmJhUHk5cG5xbk5OTFcxdkdWb1pLeHZSdEFxWFZWUVViU0xVc0pTRDlUQXFMWDVPc2xtenNjcnFPVE44WndBR1RhUkE5NUV0YlhoYVF0TjR4UEhkZ2hpbGxLNS9tMnFnNEpyZkEvZXdzUWpyME5SYWVSb1lPaUxhWElXODZscVZLbUJQWnczUE14b292ekdubUhOUlhCNlJLZ0xIWjJud1crbFBPQ3VJNjRKd2VoMXBTY05ocDFjT2ZGVzk2ZjQveDVEdlMzZmI3elNNQjQ3alpsYVlnQWV1NThoZDVVZ2diRnppN25WM1JjWWYzaWVLMEFkbkNlNDdBOHpmb2Z6OUVJdmpOL0F3VXcxZVdKRzBwN2dWVGx2Ry9PcnJQc3ZrVjJqZ2lLNVR5ckxRTUorUXord1Q3Qk9WRktOb1JGMlJ5aUxIdnBNejA0UkhBZWJpZzVuN0NXSnpLOWVzMUJzVUcyUnBCN3Q1VDQxc0lzRklIZjlGUUY5YTRyWlprYmVQOXV5ZVM3cDc1UEsvdkc1ZXpyM3NaeGVBWXk5Tm1pczdaSWRWNWpsb1hUT2VmNXpCZy9UZ0FzNkVpMVRnSkJYcnFRWlEybzYyOWRpbkprUEtucStKS1ByM1NzQy9wcTIyV3RHZm5ZNVRDZW0vY2w2Z0R3U1dUd2laS2pNTmtFcVBVTjN5bjFWdWZSc1QrNXJOeFJkVXlqTUdaazExYS9PZW9YL3BEM256VU1ZZmZxaEhtTzgxZnk5MnkrT25Md1BKdnZxYXBPcVpHaW5oQ3plSFZVellBUk02NUlzeGswb2pOeVM4a0p0OHlFRWV3VHVkNVdPZ240bUZaMnJoV3RhRVVyY3VyS2dMV2JzbFRIS0JwcmtrNTZkKys5Q0E5dVNXVnE1eTlJK3JxTWtmOWtzTC8zQjdLYW05TndYVzQ4K1lIM0pSNFFlRTlQQi90N1JPdCt4Y2Z3UFZuYTFSTlpWTzFFeVFON0pJdmVQUXZBMzFzeW9ITFQ3N250ZjkrU3BTUitOVHozaDdMb3duZVVJZ1lITlNsWTEyUlIxUzJaWXMremlQQjlYNllrSXhqZVVacDdsTTluU21rY3oyU2Vud2dPazk3ZGUrUEIvbDRyMU1RbGhkdHRtWkk5Wkc0RDBEWlJQYUJVUnkxL3htTi85b21zUGpRRzgwLzRQSC9TKzNyTHI2RXU0WWYrK3hWSmcyek9KVlVBd08vTHdPVVloUjdwUGRtY3Zxb0U4a0ZmbE5kRFZvcHVRcUdmU0dvN0VDOVZ3Y1kxNzhQWkhLZUZucWY3dlZDS0JrUGdJWlVvOWFlWHFuRjlWZkozY1NGVGZEcXl0UjQ5K1BoTkN1Sm9GTmlTemNsMTcvT2hwSWZlWDJwZ0k4ejJaTy8xbW16ZUQ1VnFzOVRXbkwwc2hiVGZ0MVN0aDRrQjgwQUduaDZHNnlmaG1weGVWb29LNE4zSHlJWnBXQVBSY0RYeCsrNzRlTC90bjM5QktkMWI3RGZSSGxQdlB5QU1IbzhiNGZKdFNYOWYxY2lSOTVWNG02U3lKdkU0akRPbXlrTHBqUHlSYTBnWnVDWnpOdGxTVGNwK3Y3NHY2UnRLVVNHUFpITzh5RGxqUlJrdEFtY1hnYWxON2J3b3l2cFRlc2ZXQUtOUVZMN205UWxnQzROakhZaUNzMGk3Mk5tdE15Qk81U25abzFMb1JvMUtoSVhQNDdpaHorc3l3eFhQUXptWHBBMVgrREZrNHp5QzhTR21DWXhScWlqTG5BK1ZkTDl1TERqTFFKczZzREQyZjFTak5GLzQzTkcvd3lLbEdZUi9rSW95QjlBbXNqMVBKRnNFRXMrRDBaR3o3MHlKTDFGaVlPcHREQlRxcWdYaVRDRVZIdWM5R1ZmZ3Z3QzNUZlZXejVWNE1VNXdPWkNQeC9xTWtTNENwVXBBRWV1bmlXWWN2NHFReWpDK3YvQ2ROTXNEUzZBai9JK0JZZFN2cHRRY0t4bWNPa1h5MGk4QmdQQ2NtTjRzZXZ4SDQwV3NROHplWkMvRXZzZEl6NHFCdzQxYUl6VkVOczJqZm9wQXkybUdyd1Z3aWI5TDV4QmxEaHFzelJjSk1BWVFNZkt3bUo0VUlDNkNNWFZ6VXNrWXMrenpmY3o1ZW93UktLeVBLSXV4ZCtQY3hFZ0dIQ3NnalBKYjd0eFEyNy9RQm9UaHNCWTQ5ZjVmRkI1RnY4eDR3N1BpTzJkTVJQc3Rpb3FEWDZCalRTVzlWT3pzUHFwNUw4emJiZG5lR2toTHBaU0c1d09TMXFZNDlMRlRieFJROEdVWkx5VTkvaXVTQmc3NEFhSndWbkdlNEN3RUVCelRSYmJEL3hoNW8rTU9vT1ZGK0UzL3k2dzBTandLM1dNcWw0K2RlQWUwaC81Y3ljWVJ6bG1lZmFaMDd1VHZicUNxdzg5RmFBUFFGMTI4L0Y2bW0zUXlRS3dqQnpYakF3S0lTalJ2VDFJdnJNdmIvcHdQL1paVEpaQVY0L3NUNzhNTnBmclFFVHpEUUY4NlVSUTd1d0JhOElOUnNiTjdyS1FqY3ZaQnlENGRWUUdPYzFXQjg2UGdhRUowTURWRTgvT2NmbUowajN3OGdwRHhUSWVmU0lsUHdMZnFuT0pZTzZ6VmVHNmN5ZlFlS1lERHhjN3V1S2FkR0kzS1hOU2xhTVVSRG5BZ0FqanNXK1F1K3RkRUVaem1HWXlGckE0NUgrVythYmlmdFFCeG5rZVFiMTIrVHZ3Y0EzaEQzOGVCb3hQT2MzVElpUUpJNC9JY2JaTmVuUDNHWG9yWjNTUjdEemlSa0VVQ1hqT1JyZkZCRFMrZko5dExWV2Z4V2lmTElEZEVlWGZvUUJXT0ZNT2EvZHpwVjFNUWwrZUFnbHl5TFBtOGJpc0JWVGh1SE1ubWNsczJUNGRLVWI1UGE4WkZvQVJBLzZKbnF1OU9lbkxaT0x4andPQ3BQNXZhd0xuZEpiWVhuYW9vd3dJQkFMZUxuZDNqSnZtc0J1QnJ5YUl0YStzNCt4aEd4Yzd1WWQxM2l3ZzlKZWdRYzZQM2ErN2o3Sk5TUnFPY09CT0o0aTdUS0MvUlJkYlRQSm1XZDg3K2h4OU5YRmViaHYvaDRYRk5zMCtqczJVOHgvTnhSSnQwL0E2bkVrQmJuc045K1Y2TnZDWi9SbmxlRjFXbndlaUl4ZHhFWjJacGRsK1VtVkNpM2haMDFCSmNMNm9SeGdPWjdKN0w4M1huaEpReWFTSFBkc0w4a3lrSEdZZ3pVSnJsMWRHNWtuRXlqNVVhd2Q3WGViTDd5czYxb2hXdGFFV0J1cXBHenIwckU3S29aOXNZQlhjWkd1enZ2U3JwbjhwUzBzS0lOMlMxTUZ0Wit0dFB5cUpOSHltQVFpSHFEZ1VYaG45TmxnNlllakN2ZVJ0VEg4OWZ5b1RubDVWU3ZaNDRzTWxoY3NmSC9Ya1pFTGt1NlpleVlYUmwwWlR2Uy9xcFV1MjVpb0RwMGNpL0xBUFZINGJ2VDVXaWFhN0pGTnJia2w2WGdaZ0ltVGVWMG1IZFZqTFdVaHZvVTVKdWVmVHlzWkp5S05uaCtwcjNjU0RwZUxDL041UUpYQUJpNzJxKzBnWDFQQUtVZC9WWXMwWmNvcFF3VXIzaFk3d2hBNFVaSTJtY01TaWcyTkR2cHpMdzdXdWFCWGhwZHg1MUpYM0p4L2hROXI0UktxSVgzNFpTRlBPWi81d005dmRJRFhuc0VlVUFpTC9nendaWWZ5UlRBQjdLbEpEcjN0OFRTVS9xUU80WFJaNXEvSTZTQThWM1pldVFzVjZUemVmcjNzODNsSVFwMWdoZTc5dVNOZ2Y3ZThQZTNYc1RIek1PRWhleXlOQmJZWjdHU3FEeTNKcEpTNHdEUVBxejNwZFB5dmJHaVd5OWZPRDlpUFdTVUM3d3FvVVFERCtydEw2N3NqMHdrZlRuZmo4R3NXaTBHY2lNZTBRclBBNS92eVRwVndmN2U0V1MwUVFIaEtsc3ZYYVU2ck05a3ZRZHY0OGExbElDclFFNlB1TjllMWVXb2xwU3BUWTFCcTF6QjRiWmY1RlF6bDczZm5SbGdIMUwwcGNHKzN2ZlVsVngySlNCdjBTYUhQanozNUk1MW53c0VUOC9pNFN5N0dCbmZFOHo2YW11MGk3M3ovR21ubEdlYXp4MHBRYmxCN0FuS3BPNWtoZitqd2F6Smk5dGxPZVdUT2tyKzhBNGNxTmRUVjhoRExBekVSNzlGRTNMT28vcnZXTDBjWVB6Y2VFMTIyU2U5MFRjd1J0SDRYNzQwNmtiUXZOSWEyVnRNLzVoWml5aFptemR1RFlLaTVMR0FESXFVaDFuakg4ejc5MmZWNXVkb0VpMVk2bTdTNFlINW5IREFWQ2NtT0o5NjBxMUNhY3lBMEFFSk03bFlMRWI1cWt6ZGlaYjYyUkZLY2NiRlBKRnNrWmRqVm5PWCtRbHpyR0ptZ0hnVTgxNnZFTTVPRWJxc2J4dVp3UmU4M2Fpa1dVY3Y4K01kY2h4R042amt3MVJSekVDRDZNNkJuN09xUWhtVjJyejVZWXIrbDZrcU9TVzZzR0FoUlI0ajJRUk5tVmE4anJEWXcwZ1RHUVprUmNWdmxqenZBaElYZFl4SmthRjBINEVDSWVSaDlVNFk5RHZpVkw2NDBZSzRFT1o3cTRPY1BHMUZkZGNuTlBjaUJhZHh1aG5CRzNqV3FtVnY4SitnWmNCYUVpMkxpYjlCbUQyaW9EOHRneWtRemFDLzA2TG5kMG5kYzhxTEJYMURiL21xUklnQmFoVlJ4TWxFSTI1R3RXc0s1NkIwWkw5V1hmV2xOR1p2SGUvdHlPVGVXTWtNRkdkTnlUZGNJQVFNS0liMm1zcjhTbm1Id2VZVzByT0sxS0tSS1ZHOU5pZlJYMU4ycVJ2QUcyQW85SDRYS2FDZE1BR1lEMm11bzFPTldWTjFjSWlMT0U1Z3pBZk9XREhlUlRQOHpoT2FodkgvVXVHakVnM3ZUOEF1WEUvQXBCd2ZyVmxjajQ4dndRVCtsYVA5dFRIdVMzcHdNL1BtTG85NnFScmZpMVI0R2V4bjdHRGZVdWJDaytpQkJQelFSM1NmUDl0eVBoa1BNL0hmcTVLNGJ5cU9jL0w5WmVUbjZtUmp6QVhqR3U5U0NtYUk0Z0IrQmpCLzdvTUE5UmhQbEdLTE1jWll0M0J3QktnY1o1NjFzUkRuVGpqOHYyTXd6V08xRkVlYlRyUE9YY3FiZlZUOXBVS0ZlYVFGYU5GbzJ6WTBldzhsODVWeUtXcW5rK3NEL2dCY3hPZHVMaW41TGMrendDRVJQUEdNeDZRaHNnMWJGa25TcklJYVZFWjA3cXNmdTB3bi84bCtEZnZ2Q1hwbWdPRTlPVzhxUzNmQXpnTWI4bkF4MUc0SnRwdm9LNlNnelJPTVpleEY3Qk9tS2VwUXAxbTU3OG5ycmVjS1pVMXFaQ3YxZkVTNTNsYnhrTklteDdiNEN3ZUtEbWNSSDA4eW1yUkdlb2xwUXdOT0F4c0tqbEZTT204V011ZjY4OEVDRzhwT2NiQUQrUzhwdWs4djRyTVYvSXdWYytYYWRIZ2RPYjhyZWQvVTRhQlo4L2pEeEhRWTIvVmpvVzFqcjdXcEFkblowOEphaXJJUUFyT21rbzhqbWZIREZmczJ3Z0dTK2xkUjhkWUhNTFFmVGcvUzc0ZDVPbFN6dW1uTk0rY3Bjek5OSXc1QXFneDVYRTh6L1BJMnVpWWxXZjZRcWFBTjNLZU0yYkdOMVBhcVlIbndzZG5nUDZ3WDhrK2dPMFZoNnlvVXcrZDk1YVpyOEx6ME05NVovUjFUU1pueitWL0dUK3JmTGZnSEZ2UmlsYTBvcDk1NmlwRnpxMHBnWU12cTFwNC9kSVU2bmx1eXRJczMxVFYwNGRVcS9uaC96bC8vbEIydUx5bTVOVUVVUHVxOS8wN1NyVjMzNUtCWVYvek5pUVRVUEFJN3ZoWUFWbUlOdjJIcW5wM3phTkhNbkRzbXBMbjgxb1dZZm9yTWtDbUp6TVczSlQwMkFIdWkxQlhGdS9ybUg2S3cyN2J4M3pENStCREdWZzFsZ0dkbi9ScjM1ZWxpMFpJUEZYeTZpWDlOUURzbVgvZkcrenZJZWlwZC9mZVVDcUJhd1NGci9vemZ1RFBRUENsdldzeTBQb1haZS80a2Q5M29CUTFPZlhuZmtYMlRralBQWkNsYlViQkl1TG9UUi96YjJrMnpmUjMvVHZxRUgxR3MvU09qeEdsWUNKWnRMUFBPZS8vMHpKbFBvSndyL3A5UFFlcFd6SURSRnYyRGpkbFJnb1VvcC80NzRleTk3dkZISHZxOHVtaVZPaVhJZDlMMjk2bjYwcjc0aE95aVBjMTc4ZkUrL3NUMlRzanJUYUNGQ0JtVElFc3FZeGVIc3ZxRWJlVWFsbkxyMzFmQzd4cGx5Ri9IMmV5L1lveVVIckllNy9qM0xFbWI4djJRL1FZaEo0cUdRb2xVOEp3OXBCU1pBUnByZUFIWTluK3dXdDJRN1kybmlpbG1rTVpmMTIyQjMvczdUd09HUkttZy8yOUgwcjY3ZEFuaE8xelZldlJ0U1I5YmJDLzkyTlZNeHRJU1hFZSsxd1I1ZDlpN3BTVW1RdlpIajJUcmM5M1pFRDRKM3krbmlvcFhFOWthL1NQZlg1LzZzOStZV3YwNTVINktmVlFIVWd2dWNlMm1qMWw1N1VyWmVCeUJKcVdhUzhZSmViVkxKM0U2L1A3dzc5UkNhdDhGL3FGMGgyTit4aUtTWmxWcTN6VjlLOXlyYy96aGt4QmpRb3gvU0sxVko3K056cUxFWDFNZitPMUdQRmlLc2pUOEQwR28wNC9wYWRzOTFQSzV4d2NpdzRuY1o3d2dDYlZLRVEvaVJDTzg0dWhhdFQzdW9rMVJMUVlSdVZvTkpiY3FPTnR2YVNVTFFQbnNBMFpVRDd0VzUzZXM4S2lHL08xZzRFSXd5WnozNUxWYXo3dmg0aTdKbkxqUUl5RWpvUmNFQjNPTUNDMHcyY2w1WWJ3OFBsVUdXRHVjM0RMMnlTN0NrYlJrWHkvaGo1TzNCaFRNZElFdzhvNFhGTStOd0N5L0tZdDVqQ2VweFZEYkFCYmNpTjRYZTJ6M01HamRDREJzSFZGb0M5R0xDeDFmd0NCaVlwU3Y3a21lQzB3NnQrVno1N0Q2d0Q2YUdNbTRpZTd0eHZtYXF6WnRiMG1qMWJJRGF4Rml1eXBlM2M1b2E5Z3ZLelU1S3k1UGpjRXRqSWVoV3plTkE4eDlYTTBHSFBQc3ZwTkxibXhsOGgzVW1zU29jcDg4RzYzVkkxTUJXeEVwOEVvT0ZLU2RZWks2WFZMbnVqQTNyRk0zNWg2SDJaNFN3UXNmZDJRNG41U21NUEtKT3pYV25LRDY0ZEtEb2xFUEVhRC83YU1iMHhrT2c5OHFqVDI4Ny9QRldCUksveGNrem5IdG1RNnc5aC9EcjBQZ01YVE9CZmVkekl3RUdIRk95OTVmUC9CL1JodFZqRVdxN3Ivb3RNVDQ0T2lQc3FaR1BjWXh1d0tiOHY2bXYvZmthMXI2cjJ2eVVEMVFUK2xLUy9MSy9semgvMEg5eitJNzYzWTJiMnV0TVpQWkE0QjlKZTF3WnFQQUVCUHdTRWtQRys5LytEK1laRWkyQWJPSzBuMURVK2JBWnQ4VG52Kzc2YXE1emxsTFVxd0w5eFhPckUzbkg5UzFmNVN0My9qbWdiQWpZYjByc3hJM3BZQmZhZEZ0ZnhBN3B3U2dVcjR6WlpzVGt1Wm80a1g4dzc2OVNuWjRjdFJKb3JSZ25VZ1h1T1prOCtaNzdOdFZTUFJZeVQ4aGV3c1pNN0hjWTM2bWlqcmcwcGxQZENLYk96L0ExckoyNHJsUVdMYWVIRmRlRjRsRWplc0h4d2RUOE56ZUZkeG5pUnp2R2xyaVJUQ1R2QVhkRUg0d0RqeXhBYm5CT2IzM1B1Q284UFFaZURjQ1E3QXVweUhzSGM1TzJjQXBxeXZQR3VxREpqRm1jSC9uY3A0OGJyTU1lRklWUkNPUGI5ZVdLUnRmcDR6OTJRQWFzcVNnZFBqaHRKNWZxSXNiUy9qVmVMUFV0cFBSSmJqTklCOWE5RjUzbFkxN1RhODhYblA4eWpYTWcvUm1TdnVQV3d6OGY3MWNBLzlLV1VxcVN5SkV4MEdrR3R4NnB3cWkrSU03WmVBWlpDNzVqcXk1ZFJQMlZub0o4QWlEcHJSWmdzUVA4MStKQzBzZVVLMkpoVUc5SFBOb0ovS0FIR2U1K3NlWjBsNHc0d3MzSFErMU5nZDhyYnJkRGJPUEhnZittTGtmY3ZxNTIzWk8ya0hIcmdobTJmNmpNMkxmVER0aHhUbS9pek95UWpHUjFrajduZGtMS25HR2RMbnBOMVBLYlRMekFoTGpHZEZLMXJSaW42dWlFZ3l2SS9YbEtKYmw0a1NyU1dQVnZ3bHBZalFXdzJYbmdKQStuMXRKYVY0S2s4SHBTU1VBS2lNbENKLy8wRFNIOG9BSHdDa0E5bWh2TzZmdis5ajdNcUFzZzN2MnpkME9XSHFtVDhiSWVaVU5tY0EwNi9KaER1Kys0US90eE5TRGNjMFRBZCszWmRsMGFZanBmU3NZeG1JODY1Zk8vUm5IY3BTMVBhVWdLL0hTbldQbmlwRittRm9PVllTQWdDK0FWU2YrUDhZY3E5TCtuVy83N015TVBpSGt2NWFTUkQ5aEF3TVEwbjlqcy9OUUFsZ2U4UEhjczNieEREeFVDN2taeldUcVpINmlneEVqL1JWemFlUnQ5c0piVWVCQ0lNQzlaUkp4MHQwOUV0S0tZWitvdVNCZmlxYmY4REpxV3orVGtKcTdXZXlPYjhsVCtQOUVRRnJHTEV4akwvdi8xK1RyZkczbGVveEhzcmUyWi9LMXNyVXgvWTEvLzROR1pEWjhyMGFJNUFrTjhvRmNISTgyTjk3K3FLaVJiMmRFMGthN08vOWUzODJrYk9UOEZ6V3g0V1A3WWRLYTdvblc0Y29WVnpmVW9yS3ZpV3ZGNmxrRENMVit4UFpQUEV1WHdwZDNKWjBTR3Izd2Y3ZXlOdUpnSGlkWVA2MlB4UFA4SkdNUHgzSTFqQUdrTGRWbnlLcGpHRHo5M0pOQ2RTUGhzZ0xwU3dCZDN3dVJqSlFmY3ZiZVZkSmlmNk90L1U5SC90b0ZmbjdZaWhYWUFFNmdrRUVwV29wRUhpZWtkcHBIaEJRMTc4ckt6cFJFWFRsdVZKN0xHdWI4ZUs1enZvc2xlbTZ2dFFCVkQ0SHVlRTBSbHhCS0hkakI1M3FBRmZPbzBIb2UvVGdSa0ZGM29DL2RHUUc2ak9sOUgra3R1S3MzSEFqR0x4Z0d1YXJGb3gwbzhTNmd2THNYNU9xdVM0OUlLbk0yajVPQUFZTTY4eExITXMwM0lleWpBT1hmQ3d2SzBWcTVGR3dsZkVFd2xEQUhHQ01CR3hjYUtCeGtJTm9uVHB3ZGt2SnE1NklOWXloZ014WHlrUVJERjQ0Mi9DdWNWVEkxelRFNTlId2g4RWR3MUtyWDAwYlhob1dzLzBTamNBWWZ5b0c3N0F1NG5YTE9JQk1OZXR3c29pbmxOUlAwVkRNU2U2TTBQWHJHdDl6NElremdHOU52MW1ycGZFcDlMa2xOYWU0cEs4WXNvT0JiMXpIVjFTTnFnWjRpSHBPS2UvVURBdFpkeUlIa2hlOGc3YVBCOEJMY3NOdllaSDRBRGdSL09XNWNZMUdjS1ppdkEzUHczaUliQ0MvQjJlVEt6dnV1VkdUK3BkUFZFM3hHZGNrNXhMQVo3dnZFV3VoSC9CdUFEekorTk1OSmIwcXA0R2NSd1NlUjNhRk9BZjhUV2tXK25TaXFuRzBzbzRjRkJyM1V4VHRqNVdNNHdEcUplOVh5a0x6dXY5Tkpxa2JDdlh3d240RndJbnZHTjBMNThJTFdjYUpHS0hUS2p4Tlkxai9BMS9YQUZTVk5NVUxqT01Bc0dOM3lDQml1RHdydk0veFBTRy81QTRLSllpVEdYUGJxcWxqN1orZHFKb0NHa04wVHhiVng5bkkyVTlrWG5TQTY4cmViVmVoOUk1L0JsQUJPSTFEVnh6L1M3TDAzZ2RLNjI1Y1dBVGNwdXhzUFBYdjJWTVhmWXZJaW1saDVmMmFPSy9zK2Z4MXcvallmeDFWSXdlbGNIWVd3VUV3bk9kRW9BSDRLUHQ3ckFTdUlmdExpV2ZFWjBYK1hlZE13N053UUd0TE92YXg0YVEvbDV4SGtGcTFrdGJXK1ZYcDdCL084Nm5jK2F3d0o2R3JudWRSZDR4Z0k3cFdYTHNBWE94QkFFdldETTY2MHhvZXhua1RvOUhqZVI2ZEVuSE9xRGl6U0tra1NGakx2T2Y4M2RCdmFnSFRQdUJna3lOZ2haeFBIS2thQVJuWHhFeWtlazBicFBLT01ucDBlSWtBT2ZJeXdCMEVQMlNmbEhLUkhLanhOWGNHU0JUbWFSVGZSMmlQYUV5Q09wNHBjOXBVa0xVeUl1VzJaS0Q2eVp6enZIU01LTnhKeWZ0OVU3WldEcDBmSXUraGMrQll1Q1k3TDFoak9MbmpsSkNYdW9FdlI3bDhvQmQzbnEvSitNZWhFakNmMjh0S2ZsOERyTEZtT0NmSy9vZDFqYTB6Sjg3UXlOZmIvVm41RHJDZGN3S0h3andDUHRmNU92Szk1R3YvTkxzdU9ybEUwSmQwN3NoYThNTklFZXlPN2VFTVI3djBOZktGVGhFaVZyRVR5RzBGUVhhTk12NDhHMDFMS2N2T3hOOU5CSVdqOHpodHh2T3dvb3YwYXpKaVJQMnlYODEyRmJNWTBFZWNoaUl3aXgxc3JCUVZuenUwTStaaCtEeVdibUZmZGNLMThyKzNYUDgrVjhyT0VNOVJNbGxVSXZYbnpHa3B6NndBNGhXdGFFVS82OVFhN08vOXJveFJBMkQ5c1F3b2VDcHBmRm1nd0VHeEw4cWljSWxLL0lKL1hSNU9NcWI4UDBvNnk0REEzNUZGZUZMajlEV1pVUGw3U3Q2U3I4cWk3WTVsZ1BWakdhQkRUVTRVRGc2Q0NCSmRrMFdCL2wyWlFqaVB6dnkrdDJUejh4a1pxUFp0VlVFWStYTitVV1pVdmFhVXl2aGNCbHk5cDVRU21laWZnZmY1TXpMUTgwSVd5VWRLbGZjVTZqWjRlMnN5d1BpcnNoVGFiM283Ui83Y3RwSXd2K1pqN0NsRnV3S29iMGpxOXU3ZWU4UmdIWFFheTFKaHYrTHR2dVQ5K3BQZTNYc25JWVh2YlNYRjY2M2UzWHZubmpvWlQvOWJTc0lQeXZSSVZwZTRvbXdNOXZkYURzS3QrYmorVTUvUFA1R0IwSFZwb1hQNm4zMmVpR0lmaDNXRmtzczdaRXgvcVpSKzdRbjNlVDl2S2tVVEQ1ZlpCNHhqaWI1ZW1ud01uNVpGVkE5bDc1NjBWQ2hlRTU5SDFndkMrS25NYVBWbDJScjlRRkxSdTN2djBOOFp0Yy9rMXoyVVJiaStFSkNRR3NQemdIRy9aaXJWMTFJZTdPK3R5OTRiVVZ2WEpQMGQyYnY2b21hQnNaYWtiOHIyeFVNbFo1Q09qT2RVK2pMWTMvdEYyWm9uZXY5N3ZidjMvbDMyZkl4MUkwbFQ1c2YzeE12ZU42THRMMlFBOHhOUHNjMGFIRGV0a2NIKzNpL0o5dDRqSlVYdnJkN2RlMDhhcnU4b3BTcS9VSEp3ZURjOGQwMW02T3JJM3VrcTZ2ZGpvaUpGQm1CMGlRYVVKdUF6ZW8vUEEwNy9mMWRVTXJBRzRBNlBheHkxaGdzVVdkb3doUy90QUFBZ0FFbEVRVlJxNTNOUm85eGZPcHJSamVRVkEyT1JVblRGV25wanBYMUM5Z01pWUloRWpRWmdvdnJoV3hqL01kNlFaYUV0QTU5alBUeEF0QXRYZHFVVUhUYVdHWjN6Nk9NeXFpMzBCOE1GdFFsem93VmpaSnlQWldjcGhsNDgzeWN5STN4cDNDeFNDc295MGlRWUdOcWFINWs1bDRxZDNadGhMS2Y5YW8zT21BWVVReXBSUFVSdFZpSlBMdE9QMEQ1eUlTa3JoOEVJQXdDMEpqTk9Eb3VVemd4QWJpcUxCc2VnelZ4WG9sRG05YTJvcG0wRHZKKzMzMXVhQldUTGlMWkx6a09kMFMwK2k0ajYrS3pTeU5KdnFFTTM1M2tZa21MMFUwc3BrbzI5SXA1YmhCVHZZWjVqSkZIZFBBRlE5bVR2SWtaUnNrZWdTY1lYQUd6T2F3eGVFUUR1OU9zajNiZ2VrSklJQ0l4dzBVQUh6d0FNaXVrL1dac3hjaU5HYkU2VnBlL01RSXB0SldQZjhXWGZWVFlXU245TVpITGtSQ2I3MDI4TW9FVGE0WWhhUnZkbi9SbjNxNmwyWDFJeThCNWs4NDREeXppMGhWUHdTQTRjWm5OQW5VajJFNUdjSmRDV2phOXlqdGFjUTR5eExkTWRBR1N1eWZnQUFQTnQvNS9vNGJIcy9ManBUUUZzbnN0MGE4QzdiYVYwME5FSkJDTnJTOUpHLzhIOXVyVC9GVkNraVFkRTNxR1F0YUxtbWp6cU5FWjU4VU1xNVlvaE56UHF5dHU2Q1B1NDFaK1ZmOVkxUHdvMmoxWmozaVZiMTdTTjR4YlJWc2V5OVlGK2Y2cmsvRHhRaWl5RS8wcW05d0F1QTk1RTV3dnFWU1BiSEliekFwQUNoM0Q0WjR3K3l4MmRZcFlyNW1XcUZMVktSZysrajN3RFdRU0hhOVpKek1ZeHlzNXpaSlVJM2lOcmx2djRzbWQ2QU1Kb2F4REg2bklFd0ZYTWhoUU44eGQxYTJuSjU2L0w5aER2aHJrYUtBRUhnRUZFNkowcHJSZWliOWtieUdsbHBvSjRaaTA0TXdHQjZBT0FSKzUwd3JWRXZ5RlBTT21NcUgwbk5lY28rMjB6bHhtek9lckt6b3lZRlFEK09uT2UwSGJUdTRDbjl4L2NmK3IvczNlUSt3RzNPUmZHU21kYlJ5bmFHWWVkcDNWelc2UUl3VmRrYSt0WitHNWI2ZnlRVE44K0NIemhobEw2N0NnSDRPQ1B2TnpxUDdoUDVycTZzV0l2SzUzVWxjNUU5bU5iNmV6Ymx2RVAwa2ZmVW5JNFJhL0hLWVQ3RjUzbk9IY2N2WUR6blBuaTNJR24waGQrNHlqUlZ0QmYvUXhtN3Nxc0hPSDhSZWV0cEk4T2N1V2tYd1dNMFNmcXNxNndkZ0dVY3dmTHk0NC9ab0NBRDBuVkVnN3c0Uml4ejJjNWlEcUd6L3BZdUkvdm84MmJ6MHNIaUt4dnBYTlg3R3ZkR0JqL2dtdWlzelF5YkFYY1YzREdXNlNyWkx5anJpWndWdzFSM1hWOTkvOUxIU3RySi9iendzOS83UCtzZit4eDdDdUZlN3FoSGZiY05QekVWUDdqbW5XNkFvRlh0S0lWL1V4VFZ3Wm8zcEdsNWYyTXZLNW9TRzhLME5DV1JZNDFNc1VRd2JzdUE5Uyt5MWRLeWhpSEtkRzRGNFA5dmVqNS9uMmwraTlkR1hoelRkSi9MVk9vditmM3ZTcUxaSHdxcTdrcm1YRHhvYVEvVWtyUkpiL3VvVXpnSWVKbEVmaDdLT2xiTW9YL2lmZm5IeWpWUktIZTdLR25hcDM2ZURlOWY3OHBTeWMybElGdUdBOEFxN2VWQklJUFpGSE1YUi9Qb2FyQ0llQVgzazcvVGdib1BsTVY2S1MrUy9RODI1TDBMRnlESXJpdUxGVmJpSGg4VnhaZGVTNTdINGVTYmd6MjkwNjluUk92VHdxd3g3TUFJdkh5UTFsRzhPdEkydkRhczlQd1hJQy9pOEgrSG9EK3E3TDNEcGdmdlVucjZMYlAvZXZlM3g5Ums5ZUJ1c2xnZis5SUJwaWZlSnVrZjZ4VDZvajJYanBDL0tNQ2Y1MUlyZlJ0VlQxSm8xZGNTd1pNamdiN2UzaTNNcjZoTEJMMFJOS3Z5bXJjL3I5K0RZNEl2eUNMTEQ2TzRPYnpqQ3NBbjNOQm0zbGdzd09zTjJYT0FTZ1pkNVJTWDVlWHFwbysvRGRsNi94ZDJiNzZHOWw3alJFbzBJWk15VHp4NjkvTXZoL0ZiQVhlcjJoQStiUnMzVDZWemVPSmtpTkh1UWFieHVqMERablMrcHJNRWVRdGhWUjBPVG5mT1pNNWlyeXFaRWlPRGhhQUhWR2dYdEhIUVAxVXg2Zlc2S3o2OTRIeFI2cDYyT1p0ejAxcFdVZDFodGlyWEJPdXcyQWNGWGVVTWI1dkZSWWxnNGYvakJIQXgwTTZNdlU5T2k1LzVtV0EzM0RQc05qWmJVZmpYYjhhaFFJZ0tGV2p4VnBLRVVVOUpUQXlHcktrcW1GV1NrcG5qRGplTHN4VEcyUGVSYkd6MnlwUzlFb0VBcVY2UG5HaTVGQTNVa3BGR2lONE9kczVzMUIrOFpERzBJUHhLaHBNYzM3SU90d3VMRzFiYVJpYXArQXZTYWVoTHh0RnFtVW9KWU1vWHUzTUQ0YmlhSVRZbEVkRnp3UGtHaWdhM1dlaXBBSm93bHFQbnU1RXlKYlVUOUZnbmNMU0pBTDZBUkxVcFpMTEhaWWFqUTdlcC9MLzNBQ3pyTEhDalZTbDhTMDN1b1ZuMWExQjVORkw3Y01pUlRhMGxMSWpsQUJ3MW40K3BueXRMZUo1R0dkbjBzSDNVMjNBamxTdGFSemVNV3N0M2tmcVFnRGl1ZFJQVWRReDRoZ0RablRTd0lERnZvb1J3Zmw1blk4YmczTDV6RENPY2ROOWJrUWIxYjMzQnFMZUtvQVdQSWRNTktTUUg0UTlXSEh3ZEVCb0JzQlU0cFZsK3NQQ25FTkdNc2VUTVdkSHVBZUgyRHJRRUFNdU9pYjh1eEpaQXdIeUJBTjJSOUtkWW1mM3FHOHA4TGtIM253azA2Y0E3em5qNEtYd1RMSXRTR0U5S3IyejZMUUpNRXVHSnltdFFjN0tpeHFESytsTGU0WFhYVzR3QksvTEFPUWovNmlKZCtOTUtDV0FqUFViamRneFN3YU9NUnZPTDg3RE9oekpvanRKQ1RuTnptRFdVUzFsUEhMcTkwd2xIZm5ZdTByQUlTazR0NVVjZWlYVEE2TWpPR3Z3dW44SEwyZDlUOFAxckRGa2c0ZEs2NUFzWWdQbkthUlhKZ05LZE42SWdFQWtkQlY0YWdRUFNTdCtUWmx1NTMvVGp3MmxkUkovbXM3emxteTl4RlRNVFdVWWxxSitpb3E5N20zMmltcVVKRFlMSE5mUTQ5RlZJdmk3SlRzL3gwMWdaZzFGZmhkbHNWZzdOSlpkNEo1NC92T2UyTmZJN2hOWjJtUE9icUw2aU5yTXMzUHdIcVVFTE02OCszQSs4RC9SL01pV0Z5NjNFcFVZejhTOHZSdHlwNHhpWi9kNjJPZVI4ck1JWXAzVUF2OXp3Ri9Bc25ZQWJBQW9JL2pOdTJIK0xoUjRXUVBZazlORUtXdlhjZllkSmM5d1Zqek8rb3pEUVVWZThmVndwQVRNenBWbnZLL3gvQWZZUnMvQldRQW5UY2JQbUhNN1V2NHVrSWRtem5NblBzK2RVSkdCWTFtY1JYU21GQVJDVk9hNXR6RjJRSTRNRzZ6UlBNdlZRTTBaek9MZWF2bWVIaWs1QTFYV3M2clpTK3FJOHpJSFUrdk91akpTMmY4ditXOE9Yb2IrUm5tdnBWbjVMNmFIbHhKdmovSTlkWHZKOUNLbGM1L3JvZHIxRnM2UGJ1RjFseHZPOHpVRkI4UTVjbi9rYWFWOGxWRmJ5WUZvSW91MHgrNmVBL0prZHBtaXgwYVpKT3p2UnFvRFZ2MmM2QUl3eDNhS1ZNKys2L01hWlVHY3M4QVNrTWVZNytnc0dma0xOb2JvK0xudU9tZ2NTK1RydEtQNC9ZcFd0S0lWL1cybXJpeTE3OXV5ZytDcEhQaWc3cVJUV3dZc0xXSjhlRlZ1ZWp1SHNzUG5scExSRHlNcllQRlR2NmJ0d05VTkdXTS9sRVYvbnNnQWtaZGtoOEViU25XSmptVEFCNTdVTFJrUStLcWtRZ2tnNnloRjgzRFEva2dXYmRkRWYrVjlvL1pwUndhMEVKMTM0T01jQmpBVW84T1pETlM5SmdPRmpyMWZ0MlFDKzBzeUFlcUd0MG0wSUhXeEtrRDdZSDlQUGxjVEdjQjk2bTJPUXlyaUN2Q2JSYjkrY3JDL2QrelAvUjJaQXR1VmREVFkzL3VmaUFvTVlOOVFCbjVIWTk5cHZDYlVqQzBwMURtT1hsZFNFb1F2Wk1EeTJtQi83MG5EZW5vaUF5by9MZW5QWldzVGc4UG5sZXJhNXZRcnNyVXhrcTJMMXlWOVo3Qy85eWhFUFdJOCtvbVNSLzdZSXlWYmNkNFltMGQrVGdmN2UwTlp4SFNqa0RQWTMxdWI5LzF6MGtDMkZoRnNZcVJBNmJudmE1SFBXUmNJTW9EeFA1YUJuVDFaUlBaNHNMLzN2bXpOZGlMUWVSWHcxK2N5VjNLdUxEVDVHaitTdmJzdkt6a0VrR0ljbzBJRWY2ZEtTdW1uWkE0WXQyWE9JVVQxeGY1dXk5Yk5YL2p2Q3ZEZkFGREhLSjlqLzdudzU3d3VNeHFWRWREeWQ5WVE0YndtNDNOanBYclRVcVlZMXRCRUJtb1BaZXVmZW1CdGZ5NWVzMFE1cnVoanBEclFNb0E1ZFVhWGNWQWltd3d3ZUdUWGVnQTNlUVUzOVNlaldETzM3dGtWUlVxSk4wc3BXb1o3WTVxNDJCL1NIK1pSZkkzcDdlS1ltc2JzNDhzL3grdDVoaSs3OGpsVzRpRXhzblpEeWNCNm9TUnp4UFNCOFhvTVRXdjlhaDFHS2NrKzBUaEhoQTlHdjdiUEUybUo4NzVPQzZ1SFNRM2lhR1RHcUJWQmFWSk40ekdOUnpUOGdQZHlLbFAyOC9uaHZDWjZqM3ZxZ0p4TGtmY2ZXV3lxVUp2VkZmTm9rRDVUQUhXS2FoUU9CdGZMbkMwUmFLY05BTkhTZ0k2Uk5nTmRpT2pCT0Z5bWFmWFBTL25MLzQrR28zTGQ5bFBFS3dhTEVnQ2MxL0hMN1BNaWl5Ykkyc2xyZnMxRU5zM2hXNWVLRWd0R1hveW10Znh2RVY4Szh6V1JxdldQYS9vVGdmc1lGVGQyb0d3bVBTRmpVNG9XZzNlTmdqRU9VTEExaDk5Z1FNTVJpeWdyOWxjRUNlZ0hScTVvUk1UUURPL0N3WU01cURNaUF0QUJIRlNNalE2UUVhVlNCeFRNVUQ4NU1XSGtCaGlEUjhNZnhwb0Q2RFZRQk52R1NzNHdYUm1vaUc1WTdpRmZKOGR4cjRheEU0SEdYSGVWSEdlUGxRelN5SWtWT1ZCcGpkYWRTZWlraDBwT3Fad0pSSDUxSlQzMk5ZR3grNm1xNTh2WW54OVRYdCtXdlE5S201ekoxaUVHMlE3OXlwd25Xa29PdHhVSzE5MlFHVzg3T1M4SWM0aE96SHZtM2pnUDhLbnluQXg3TXBacEdvYnJ0MlRyK21ITlBpRTFla3NoazBJMjd3Q0lzYi9YbGFMdEt0UzNXc0xuTWoyYjljRDZqKytkdGJZdVd3UEgvbDA4ZjRuMjYwbDZyMStORURxVXllcnZoY2R2S08yN3VEYkpCcFQzbFpUWG5PZklGaEZBaEdJMmpBaVdSQjBMZmpHVVpqTTA5Rk1LWXJKcnlPZG5MdEE2NzR3SmhLeEJOR20zU0xVdnovclZTR1RBWUg1WVQxS1NoUzU3bmt0VlEzMEVnT0xuZVFSc25QK1JUQ1lGL0txVEFRQ2p1a3JybisraW96T2dhbVBFblA4OTlEYm9IeEhheUJNNEw4S3plN0pvMW54KzJDTnJSWXFhSElWMldHczVUVFdiU244dStUcTlyclIzV0k4bENCOEEweG53SkxRRHY3eVFPL3VFOXFNc3hMd2diNjNMN0ZmcnNuMTcwSDl3ZjBaZkNPZjVrWjloMkNZSC9aUnVta3dNcmFoVDFZeVhyR09VVmJ1aEZEVk9WRG45UFBmUHNEMmN5MnhhRzBveS83SFNudUhlSm4yTDlQVHdsYnJ6dkt2bHovTlJrV3BNUndlVjZPQ0lJOHBsYlZreFd3U09zL0Nsamp5YlVKU0pGd0NISGU4dmE0dTFYUUxzUWQ2SzJVZ1Vyby9Bc1pUMktYb2NaeDdYNGJTQS9GZVdJWEE1NkZ3cDQwT3AreUc3K2VkYk1uNGQrVnVzdVZ4SlpaM3hxZG9hMmVFODMyRGNEZGZsZGovbXBTNElBQmxSa3VKN2FkTldQemxzVFl2aytGR1hqYVFkM3UyTUEza212OGZQWStSMWhjSzd4d2tyM2h1ZHNLTU9IZTNPMFRFdjZ1ZDUvOUh2WXlZcTFrbnVkTEFDZjFlMG9oWDlURkI1R0RoWU1BTjBEUGIzMnN1bWd2V29RNkpRWWhUaEoyV0FVMXNHMnFBUUFEcWZPc2pUbGtYNUlXQzlySFRvVWF2NHNWS1VzWlFPOGp5OTIwTi9EdlZ2bjhpaWh6dVN2aTVURWo4aEUxTHE2SnQrZmF6ZlF5M2pHeklnNmszL0dVdHFoZkd1eTZKKy81NlA0N0dxQWdFcDFOb3lVTzlOcFVpL3JwSlNQMVdxTi9WTE11UERIOHNQcXQ3ZGUyZit2UEpncjNsLzM1QUJRMy9rZmZpOHJCYnN5LzdzUDFDcVIvV21QL3U2ai9WcDcrNjlJNTRSM3RHR3pDR2cwZUF6Mk4vYlZES0FJVUJQL0xsRGVack5tdjYyWk9BdnhwTlBLYVhtZXVyeit2V201eXFsK2QzeU9mMDNzbWpLNDVBU0Y4QVBUK3RYL084ajVqVHJUL3ZqU3AxNzJZamJ3ZjdlTlNVd0lnb3JHMHJwenVUWDRJRHdvV3hPSDB1NmlOSCtMNEpZankreXpxeS90Ni9MVXJlZktLV2krNnFDTjZhcVh1QW9UVEY2L01lUy9relNEekluaXk4cE9RZE1KVjNyM2IwWERUeDFmY0xwUkRJK1FwKzYzcS8zbGZoUFRDbCtFT2ZHeDdZbTZYOVFNZ3crbERtcHZMZW9IOTVHUy9aT3QyU0FNSHRBL3N6VEYvMmVmOTVvU1dQWTNQdWx1WjcxWlFUc3ZHdnB4eHhsQzhWdmFiQW1NeXlqZk5XbGVTcU5NYXJ1dVhqMlJzQkFzajBSYTRWRlFDYTJQNU91T1h4WEc2MVlONFpnVENJeVlhU2FGSGZaYzF1cTFpRWl6UmtPVVhsZG9walNMUm81aGczOTMxWnlTSnZJNUJmcUZwS1JZOVJmSXZMRjF3bTFmRWs1U29RZTdZMWt2RjVLN3d1RkZsQ1lGSktqT2lPYVA2c3lwMHYwYlYyMkpodHJ5aldNaDJpOHBuN2c2RFFNYXorbXUxeTR6Z05JaEl3NjhmYW9NVWU2MmFYNlhtUnBJdWVBZ2pOcG1uTUErQ3A4cFlrZmhYMDZFekhrZmVhOGpNYWdSVFZFcjVRYXpaOVhwZ0JkeHRoY00wOVNBZ1ptVW9ETDEyZTRWa3BqdzRtakJOcVYxU0pyNkFOQUNVNHRnSDNzdFUyWm9mcTQ1cjZPekpBSHNBTkFpcUVUb3lXR1RQcTRLQjF1ZFBUcytWeWN4bmxRU2lOZkdsMlZlRUpNNjc2VWNkZjN4VFVsZ3loNzd0RG41blVmMTRmTHR0blEvckczU3dRd0JqdjR3Ym5tN0pNaXBBcjIvM0V3Qmp3RnRMNmpORDlyUG83VGZqWDFhelNNd3VkcFIwcmc1TG9zRGVxVHVEZUNJZlYxdjQ1YWtCMGZKMmZ6aFo4TDExUUZGSTRpSC9Sck52M2V1bFNoOGN5ajMrc0tVWG45Qi9lUGNuQ2xTRkZIMGJrQUFCelFRYW82TGJEK1RwU2lpNGlnUFZlVlA1T3g0amdEVUR1eWxMWEg5TG5CbUIwZERnQ1VhZlBESm43bDh5VjVoRzZSMHNFaUQ1OG9BYnhEN3plUjNRTWxNTC9yMXg3VXpQbHQyWHZGT1FvZG12ZTRJWHZIQzRHWklxWERaZytmZWxzYnFvSnNkVFYrSS9oRTVyUkdQdElrTTg2NUZoQm5YbzNVL0Q2TTh4dDlUL2RlY3cxMmdVR1FkNUVYTDNPZXg3U3NFNzkzV0tSU0Q1TmxaS3JRNzNVbDNqMERDZ1krbXp0SElBUGlvSlJISEM2VGVXZkdFU0xJeXFSVVBzcjJFclhINFVkUlJuL1dyNEpNVWhXVXBWOUwyelpjTHI0alcvUFAraWw3UXFtNzFJd3JPaUxCUnpoVFJuMVBJeDJ1eDU2Uk93TzA5UCt4OTJiTmthWG5tZGlUQzRBRVVGdFhiK3h1ZHJPYmJGR2t4RTNraU5LTTVQUklNNWJ0a1dZODRUWHNzQ05jRWZZUHdGVmRWdUN5cnVyQzRTdEhHTDd5alVjUkh0dWFrQ1pteE5BWlNVTko1bUsyMkJJM2NlMjF1cm9LcUFJeWdkeDg4YjdQZVovem5lK2NUS0NxVzAwT3ZnZ0VnTXl6Zk91N1BlOWl0aHFDZ0FTajdpSmtneVlnOWJMM2c4N1Z6Q0p3aUFCMTU4TWtGWFFSNVFzT2gxRUtoSHlVYWVSSksrQ2ZiY01kU1ZRK1NPVW4yZk1sdlNVNEpmUEdsTXBzdERHUVp2UWhKV2FXdFNKcTlLYkFGaDB6K04xb0ZScVJlVDdsUFdhM1lEMWc2azVsWlBnUytTdm41S3ZBSzhFOXRlMVFacWpVcUU5NE1zZmJrV3NJSkhiaDBiVU43eWZZUDVYclNYUHBPRWk2UTNzY2RSYk5Oa003K1hHNmJwazlvdkt2eXNEamxHK0tIa1dkRkFoK29XZEdRZTkwL1FtV0FxaG1lL0t6RCtSbGtMWGg4bElVSlFqc2E2SUJGT09tL1ZCRW1hU3B6QXZsY2NvZzZraWo0NmNzeDdtWjVQUTdmeDdwS0JEeUd1V2hEaEs2ZnQ3TzIzazdiei9OcldTZUxXRE5ZcnkzMjgrQkJ3NDZNQUtJUm8xYWZVMFltRUZCaTk3c2dJT2VBc1N3enNZeEFqRFpoZ2w0ck9PNUR3TnVQK3YzcU9mc0dKRktpVjd1OTJGZTRDOGc2cE5zd3dUSnRyVEN0d0VjSi9OeTE4R2FYNEdsbmQ2R2dZc0VhOWsyWVVJeUFkS0wvcjU3TUsvaE1ReVV2UW9ENWE0QytEWWlldkRBeC82RVgvY1NURUQ5cmovM05kaTZFQ3pzQUkwUjJxOGlBRmNhbzVnMjhpSml6aWxjVUlCN0ZzQ0RUR1FzL05vblBLcjRHQUwyQTZVemdlNkJpVVFaMzlHSTIweFRyNjZYQVB3bUFxUy9nMnJLMzF5N0tIOHpGZmZ6QUw3anFhMjMvUCtQK3JoZmh3SGlod0MrTXQ3YmZVWEhrb3QwZmk4Ykk3cFBBUUlmdzlhVENnTWp0WUJxM1lzdUxETCtBVXlKdU9JL2gwaFNnVDlzMm1lLzkxRjd5aTFnYS9VZDJKbGdtbklGZk5WVGxNYlN0TDBBZDI3d3ZjaDdEbUZuNjlmOCt3bUFmOWJVR2QrL2pMWmhHaVVnd0pabllOSHFDMFFONno3c1BQNDVKSjJWUjQxUHhudTczMFprT0tBVHhzRDd1VXFhdGhtTVBwWWVzdDZYOFRuNGUvYjJzTUF2bjRFV2ozaHBTK3Q1OHJ0aGtoWld2eS95S1Z4WGFZMW5sOC8xOTZjS0lIbWdBc1RjZ3hWbHYwbUpXbUswVElHc21zSEozekVUWlo5ZTdLM0dodHg3WGNGT0ZVdlMxZ1hxWUE2VjV4cGZLeUlxNHhoUitvSDFOT2R1V0RwR1JCYTJBcTV1TUgwQW96OVViZ215NmRwUSthVXhRdXRYMGRqWlJDZlowaWhDR21Gb3lLRWhUYk1OVEl0TXhObVM4YlR5V1Y5blRkVjZBUUV1ckdJczVqclJhQU5VOTRWR0FaeW1WWXdrdWI3NHVWRVBlZkE5L2huVFJwL3F6RGFObStlZ3FiK29weSt2ZWVZRDJUUFdnZTNSU3JSeWsvRlgza0dqZUZOa2d4cmpGUHpWYURqcUdDbmRBYXJSaUdvZ1pPUUErOEh6dVFhakV3bzRwQWI3Q2N3aFlWWlVvK1kyRWVkSkRiUDZuaE4vUHNHSkNhcjFWSGtOa21lMDBuNy9mT3FHT003WE5tSk51WWZMcUE2RWdaSkFEcU5RVjIwYVlhZkdzVFZVbzU5V2tpOW9iQjFHZE5vVXBoZnhleHJ6dHhDT0dyWElvYUx1Uk5TRlJlSVF3R1BXQUJvS05mMnNwb3psYzlqSXV4ajkzRXMrNTltNkFBZVlPRDg4eTJJSTVqdEtZQWpDRS8zN0U1aCtxOWt5YUtqbjJKaGhLa2VuZVNhNWJ4aE56Yk15ZzZkZHpkeXJoblRPaStyMEJPSTFJb3E4ajVGQmN3Q0hBc0RyM3QzM2E5TDl6RWh0OEJsRjR2emw0MkcwR3ZmZURKRjZ2STFXSGlYeXhxS3dxRjJORktKREJ2K240M0FKSEVMMlFxYVJuL0Q4SFNEU2paS2ZyK1JBNWVNSFluN1pENzJIK3djSVdzYjl6UGxaTlJ1RzBsQkdiMU9lMlVMVmdhUUVXZ3BMNTczMCtiSnVqV3ZrODBIbkZRV2xWZ0thQlRSWGZxN1J1dXFnZDVyR2ZRL0VlZGQrTXhLUTRJQUN3anh2ZmU1ZjNwTStKMjJrN1puUDZkaEJSK0wwT1hUWVZ4bTVnMGk1cTd5ZXprbDBVdWg3WDQvbFBjc2M2OGhUS281eXdyOVRwdzNsYjdUZEhNUDBiZkpFK0wxcSsrSGZPaTdXbytkNDVyRDl1Z0dqTlJkOGJkNGRWbE84RXZpbE0rZ0ZSTmFDTlVTTjhFb3JJb1g1Qk1aM21kMXdqSEFZSVgzVUFBL09ieTVOYnRuOC8wbGhXU2tHZmozSFJkbGNtOHBCbE1OejVhemFXdW9Jb0E0azVkeXVLb3VtZ0tYdkk2MEJ6ci9wTkZXZWk3Ym5BR1YybldrUlRsbVUzenJ5TnhCbmd2eXIxRm5TdVZmNVc5WkdIZndxYXlRQWNrN1dZeVM1eXI0ejJQcFRIaTB6ZDhqWUdCM2Z4RnVVN3FRMHFFM1dXbmlmWnRRbmlvaGtWY2ZsVk81aE92T0Y3TWxhMzVxQWNVaDJINyt1cER1SmJsVEtjUDY3ak5CZG9wL25NbWpReVVmblVSMzM2Q1JCUnorZHowb1Rtc2VzTGtEd2xMSjBsZTZoWlR4SzUrOWhiVWZuN2J5ZHQvUDJYclFhTVpSMHBSRFFyZytVZFN4NUhSVkNwb3hjZzZYVHJhV0hrQlRGSk1oemYvNkp2NDhLLzJPd0NMODNFZWx1NmZFMmd3azdGLzNuVTdBb1hHMnZ3SXdKejhBVXNxL0JRSy9uWUpHalAwRUllNXYrM2VQSXQvOEZYdDgzR2N1TEFQNHBqRkhjQWZDN01PR3pJOERtSjJEZTMrdUk5STlYWVdEeGp4QlJLRXh0UFlBQncvZDhIbm93eFhMYngvRzg5Sk9SeVNQWW1yUXlGNC9LL284Qi9OLyszdCtDQVVzMFR2M3ZpUG85ZHhHQ3kxUGU5eU40Mm00SEoybVV1UUFUNkM4aHZOTmZSVEJoMXY0QTZrQjZXMzlwVkg0T3dHK2phc1Fib1pybWQxbDdGK1k0UUNHZk5hbS9nSHdxNmU4QytDTlk1UE1qaTE1OUwxc3UrdHZQWmlvY1UybGcxUE5sMkp5c0RhN2RTRk9XdnU5dEdlanNOT2dDb3RaekIzWjIxbUEwQTZpQ1VQemRKR1JQWVJIdjM0VFgwb2J0dWMvNk8wYXdXdHNITU9XT3FVaFBwRloyRnpaL3grTzkzUUhNa2VBWUZxbDhFYUVRcW9jdzZjYi9ocXJoZGhOR0QzNFpSdS9vWE1IbzkrL0E5dk1BNXV6eC9XUit1TDdIZzJvbUFxd0lIcCszOTdBcEFIeGFvR2ZGWjhPZmZTWmxRL3FYTlZhc3FQU2tLUXJCLzl1ZWR4YUFQZU1wbmZQWWJnT21kTXpxbFZ3Q1VqVGVvcDRsWkl4UW9tbllBTUlyZno5NW5rWWIwS1AvZnRxdklpS0xDQVE4YURNY0Y1R21sdktNanArcEp3a1drUmFSZndNUlhaU05ldlgrYk1BVTlHTTNGbDlFR0x5MkVHbnZDUndRSU92NWVKc01pV2R1Ym1UYzhqR2R4bUNjQXNCcGRFL05hT0dmcnlFTUsyV2tvY3pQU2R1WnBvRmhtRVN1eXQ2dFJDK3UyczU0YmxMWm9HSW9rKzhwcDVlR0lUa1BHa1ZJb0lCRzdoUWNwdXhmcTJjdUJod2dETlpwOUM4ZFBHdDB4UHVxeGlmcUYwRFZ3SldDRVJ4YmFRd2Jlc1JsVVkwc29HR01obk0yZnRjZFZpTTE2V0I1NG51RlVZYVVRMmdrcG1FUWlLaEVCUmNuM3Fkc0pnUlVBVTZtbFZUUWwrT21NWkxwYVRrbngwaEFzcWJtNzdzaTQxZVFpdU5ZS2ZxM3FHWXVHQTJUeUR5aHg2U3JQVWg2MEtSUFR5QUFvd2YrYkdhOTRUNjlnZ0FqQ0tKMllEcExGMGFubFJZd0NwalJtMHhSREFqdjlzK29uMDBSVG5mcCtkVTVvZ3hJK3FNZ0RXazBBV3M2NDA0UUViVmNjemF1UVJkVjRFdlBGWG54QXZWc0d3UXJjenlJWXliQU5wVm45Ukg3VzNsbDMrZW5OTmczN2E4R1hsM1MzZ1o2cWZSN2t1NEplVVk1SjZobUFLSkJlQTNoSkV3UTRjRC9aZzFmMGdVQ0EyK2pIbjEwRWJidUJMWDJVMkNqaU1oakd1QmJJKytMaUp4bG41Vk8wM21kVWNBS3lnTUJsTkdwTFBzZTBuZGZKMGFKdzUrL0JxTUxHaGwzRVFHVTg3dythbjVPWnhJZ2lSWnZ1RjVwQkJEbnFjSkRkVTltM3NjVTY3cHZhYmVvUmVZbDk1TUdqNVJYQ1cyZ3ZIQ3FqQnA2YnBiSnJuSS9uZmZoYzhCTWEzUTB1U3pmRTh6a0QrWEJZejEzQ05tS21STzA1QUpsM0dseVBybFh5TWNZYWN0MVdUaGQzZmJ2bURtbGRQaEEwQnZLcGVyVVJSNjJoVGhQa0hjY0lYVHVCWURYL1owWEVjNkNCejV1T3UrUXBqRWJ6bUpZVFZmZWhlM0xZOThmanlNY00zamVLSE1jK0xNdWVmL3BuRWxkZm4yWXlRWlFSTVFvblc2VVZyRi8vSnNwNm5rOTUzcXEvVzVydms2MG43Q2xBT05LMGI4K1A4eUNObTZRVjdoK0pTRGFvS2ZSempjZFJ2MXdBc0RzcXpwVmtTZVJWcEpQcVVOd1UxcnhHZzhxSWlVNWFXMHRFNWVlU1FGV3VROVNKd2pLd3lxSHp0SStTVi9Mc2pBWmVVZmZ0UURxa2FoTlBEZlI2OWZrYnlEMjFsVDYzc21NOVN4NlJvVitrVDdtcmtFREFOeWluelBqVDhvSDJOUzVrZ0ZoYWdjOVRQZ0VaZWd4NG15TUcyUU02Z0l6TktUclR2cGZhK2VBOEhrN2IrZnRnOUFxaE5NQmc4ZGhRTVF6NDczZFB4dGN1L0d1MStidEM4Z0FCTE9sRW5FUHdOelRvaDRCRVRYcXY2ZitqbEtoZHFEcWVRQWZoeEhxRVN6dDZWMEFyMlVBWjhDRW95TUFmd2tES1dsUTBGUkpYL0pyNkYxK0ZjWVVua09ranlYbzNOUnFYc2JqdmQzbkFmd1RoSmZRVlZqdDJhOEMyUEQ1bzhINEwyRFJoaVB2NDh6N01rSUlvbi9qOC8xUnYvWUpHR0Q1blAvUWMxRWpkNTRHOEkxVHBDUytBZ081T05lc2I3b0ZBN2pHTUREMHR0ekRsTTFNWmFKck9YRXdidVkvVnhCZW9VeEJPWUNsYm1aRTBJL1R1V3hxRGpLZndNRDlqZVRyVmNEZkE1Z1EvZ04vN3hUbUVQQU9nSS9Bb3FkZkIvQXgxTUhCWjJGenZUSGUyejNKZ1ArOTl5c1Y5Q3BOYXUxV1VtbHJId1VnbmlNTThwb0NVMU8zL3EyMUZTS09xY3dTcUJqQjZrTmZnVGwzTUFVYkk4V1kxbTA5OHh3SzVpL0Rvc3hQRUttS2FIanJBL2djckNZd3ZhL3ZJakhDRGE3ZFNDTi8vd0hDNDVET0psUkt1Wi9MdlRYZTIyVUt2YWY5dnR2KzdtZGgrM2NFTzB2UElaVERYSXJTRGl6U3Q1ekhjK0QzZzdGb3JTY0FBQ0FBU1VSQlZOTmNlVG0xOEs4SzNKSjdWYkU3VS8rVzNOL3ovdGRTUTB1cmdFbHBLM2FxS2FDU2Q2L1VXc0F5TlFwUm9WZWx0cFZ1U3gvV1lON25URms5ODc5cCtGTHZmSUkxTkZETllQem5Db0Nqd2lLSWFmaS9Md3JzQWpHZnFSR0FnSEVIRmtWNE9JeDBXWHpuQWxXalJ5WDlvRCtMaGpWR3hESFZweG9ENXlud3F3WVBueE0xTE5Fb1RyQmlCazhIVmtTVU5nMUNwSk9iQ0Zuc1ZLMXByWDBQSGk1YlV4MlA5SjJHMFM2QWJ1RzFsTjNnTzBmVTBWTWpTdzhvbzdPNU5qVG1hZW1GdHBiMnRWZFlsRlFPT0ZxcHBZRHBHVnJOaVFJQmltaS8xSWliR3BrSVJwRDNkZ3JQU2lEWE5ZMlA3NnE4UThaSEExeVp2cTZ3YUtWRjBsY3RnY0Y5Um5CVXp3elBpZEs2amorWGN2dG9XSTBlWXIxV3Btb3VEWnJEZXJweXlxZnJmdmFWOTBQK0hpVGZuY2k5TkF4MmlwM3JnOFFnemV3OEJLV1p0bzhHY0Q2WDR5S0lRWG1QQnJkdGhIeFNhNG14VGtGNmpxRTBlc0pxM2s2YzNuYVhHS0wxT1hTTzFiYUdTRnQvQkhIdVNQWjVWMzV2RkZhWGVsUkVyVUNOL0dCV2xDZjl1M3NJd0k5UmFqUWljcjRXUU5UcEt5SlZKek1WRUVUbjc1bjBzNHk0STBCU1JEUXc2OU5laHNtVUJKMjBSaURuaUZHb1BFOFRvSlppbXJRK05XeFA1TzhtdytvYUltSzZ4ekdvbkZKNHpYUHZSOWZIbzhEWU9pS0NrR1BOUlNtV2tiRGVYK1hUcFhOTmNrdXZxTlliVDNYMU50cXYrK09DaklIR2ZZNmZ1Z0d2T1VaRUFyTkUwQUZNZjd4VDdGeW5ZOU1sQUxlSEVia0xSQjNJU2pZSStaNTdkZXFmYXlTeThuT2x1ZVU2eTVyU0tWUjVQK25ackFtRTRUeG01bGw1ZXNXUnlXVWZYay82cXM0S3Ayb0t2T3JuVGoreWtWNlpaM0J0K1g2TkRPd0tpS0w4dkF0VWF2THlMRk51STRCWG51Y1ZocVBsUWpvSW1zK2ZSckJKV3VVY0krU1M5UDR1OHZJL0hhVDROOWRGYWJkRzAvS3MwNW1FTmp6bHo1VDV0SDVybWxGSWF5eVQvcEF2VU00a3ZWZ1VPOWNwTzUzQTV2NFpSRGFYZHhCQUt1MFIyd2dnV3gybUdLWEh0ZDFDOERuYW1qaUh2V0xuK2hNd09zdDM5T1RaUnpBNlhJS1RHWDYrQmFNTlhUOTNTdHVZL2huK0RKWmVZTWtGQm5LVTlwYkMwbEFmeUw1aEJnSHFFRHpUZllUZGovS0FPcnFsZ05lYTA4b21wdy9kZjF4VGJici9tSks5aDVDTGx6VTZzcWZ2WlJwN0lFbUQzTkI0aGxrZmZwRjhSK0NOSlFzZy83UC9DcnBxcG85VVArNFdFU1dyK29wR3d2SzlVRjB0b1VFRWpxY0lta0pBbUhTZWZWL0lkeXZUVDMvdk1oMkJNczlFNVRmVjY0V1d6NEZzNmFpK3owc0ZFRzU2WVFyeSttYzFuVTE0ZjgwNUI3RTJUZk5SNmdoQ3IrRjdnMDQ4NUpYY2c1UlpxZTl4bmFZdzJyYnQ1MWxsUCtyWjdHdFRWaWFsdVpRaEs3WU4veTZsN1NYWTdlZXhNai9ub1BCNU8yL243ZjF1cFNEZ1FCRVZvdnN3UWVZWkFYNEJBeng1RFpXV0NZRDF3YlViSXdkRDZMMVdFUWlreGpDSjdyTUEvbjFZOU42SC9lY1FCb3Erbm9uQVREM2JqeEYxYzludXdrQ1QrM0NReFlHV1YyRVJ4ZmY4SGZmODNoOGdCT0VEaEJCdzRQZVhSTm5CM1grTWFqUlFCeFl4ZUFuR21GNUVSQnJQWVJHbDc4SWkvcjZQYXFxdnVjL1h1NGhJV3hvWVdhOEVNTUdTYzA2dnlrWmo2bmh2dHp2ZTIzMXF2TGY3NmZIZTdncytsazFZMU91SHZKL3F0VDZGUlU2L0JnT1FtQkw0RUNFb3AyME9ZNlQ3Q0NHY1h0RnJzTFg5SE1JN2VtVURwKy9EbDJENzRTeU5RdVpkbU9mMmE5N1B1OTdYbC95YUF2WDlRd1ZBR1RuN1JVK3l4bjQ3TVA2K3RjRzFHd3ZmNDQzekt5bkNHYTMvTkd4dW1ZSzBGckgvQVcxVWxxN0ExdTBBUmdQZUF2QmxXRzNzT3dnQVdLTmkyQ2lBYzA1bzJPTWVWaWNUSUxJSE1DMWFSVWpOZ05ZakFOOURSQWdTVEg2QU9Mc0E4SVk0d3JBMjh3disvbmRSalRxa0VZdHA1TGNnV1F2VW9RWjFoNGJ6OWdGcVp4SHkvWjV5WGQyWTBpdDJybmRwV0tHUzEvYjhOa1Z1eGJhQUtTOTltSEpVZTU0WU5yb3Q3MXQ1bi9yNCtzbXphT0NwWEllcWNrbEhOWHJoWittakc3d1oyZGt0b2had1Jla2MzcnJKdWtHSENBTWhEVXA4eHdoaHlMcUxvQ0dqNGEyYkI3STJEN3cvckp1SVl1ZjZ1cThwZ1VWTjgwWkRCM2tzb3lpMjVkMUtsMmJEV3plVnI2a1JTZWR1bElLLzNpNEF1T3B6a2M3WE1TeTkzajBmWDFtM0tkbDdOSUtSM2pieXpiWTJ2SFd6RnFHbTMrbi91a2VTL1ZJQ0R3akRCdzMxcytTZXJ2em9NNDdkc0s3R2NzaHplQ2JMbjZTdmxYTlpoT2Q2VjREMk16VTFRaXROV09IV2xLYWs4elR6czFHSjNFM2VSOXFqWjRaajZ4Y1J3YnNPTTFLdWkrRUhXQTA0cDQ1QkkyOVhucXRaaGVCOVhmQmNveHBKbzBaTy9aeEdYZGJTcS9USmpjSWFQY3M5c0o1Wlo1YlhvTk1GRUtBQ285VDR2Z0dNQnB3ZzlCbU9rOUZPS1IzbCsyZitIdElEenRNUnFrWlB5cXk2bnp1SWpDYTFWbGpVOG1QRnp2WExzaWNveTB3UlRvUmxTa0VIZGk3QURHdU5aOTNQQ2pPcDVHcUQ2bGg3aVROQUNYejZXWHdMVVp2OWt0TXJndjVkdjJhRXFPSE1QVU5najBBMTk0blN3aks5dlFCMVFEZzcweEI5T0x4MU13V0NJUE9WaTREU09uT1VQWjhDOEhnUjlTYlpuMlB1YWI5Zno0Nm05SzdNWVJIUnRHM25pM1JzQzFWZVZQSjNCM0I2K2oyYjdBM3VWZmc3MWVFaGJSMEFtMkpBWno5S2VVTG1TMnNtTXJNRWdjOGFUeEFaZ0ViZVBrd3ZWNEFNY01lTm9kV201UTk1T21zTWQyRnlPSG5YNjRqMGtNZkRXemZmRXBxNDcrL2RScFdmVTI3aGVlSDZjUTNwb01BOVJTY3RJSFNVQlZDck02NzFiaFg4UEdrQWZ6ZGcrN2gyTHYzNkIwT3JPMHBEZWRxVWZuRitVNzFxMVZhSkdrMzZrcTJGbWY0dGZRS0VueVBBVHpvSzZabFQzZ1lZbmEvSlBrNmZwakNhdGw3c1hDZlBXa3V1UytlS1BLOURlZEw3MEMycWZEVnRGWUJCN2dVODJyV3c3QUNwSTd6Mmx6SW45ei9wUGNFM0Fyck1LRFdDUjNoU2ZobEd5bGJTZXMzMndHZVIzcXpEYVQwaSt4dGJZK3BzK1h3YkJzaStpK0NUVEszTWM5RDN1YUZUQ3VlRnNqUEh6Yk4rRDlVbzZDTWZPKzFxVTM4R2RmRUxjajBCb0swR2ZuNGJkb1laZWJ5QW5YblNHRG9QOUJBWktCaDRzZytUNTYrZ1hzdVhqZnhuSDFWWm1XbnlGZHpVREFFbGZVQkx4THJ2bjZ2Rnp2VXJHUm1YdGhLT2l6U1lVZUJiQ2EydU5OKzdZMVQ1YVZOcmZZN0xXZHkvZE5vZ0VFM0FiSWE2bnN1K0swOUliYVNsYzFZaUgzZjVmTDltTXJ4MVV6TTlxQU5PQ2tZckRTcjFYc1JaR1JTUlRVYjNLL2hzblZzQ3hUbGdlRVY1ZmdHYnJ6WEUvRkVYVjhjcjhwM2NlcENPbGVlZ1NUOFJQcjNlcHAvTGQ2bXVwZko3Vmw0UVdaN09sSm9XbmVPamZuNkNLQS9CczBFYTJFRTRsRENvaW5OeFBMeDFVOHNJTVgxN21mWEgrUURIcE5IRmZhRVpwZDREbTE5R0ZXdC9PMGlBOTBUdVFiSS96OXQ1TzIvbjdUMXJwVUxwa1plc29Yc0lJM1NQdzZKWDl4RktXUS9oU1hqc2FZOFZKR3p5VnVwNUZPOGxmK2F6aUJxc0ZGQmZCM0NZaXdiMC92RzVGQkpWWUdQdERRcUoydTdCUUtJblljVDk0ekNnOW5XLzc2OWdrWDVQK3ZoZkJ2RDRlRy8zN2NHMUd6TUgvejZCRUpxVWVkTExjZ1lUYkxjUUtXVTdpQlN5RitUM0pWak5UeW9TZDJBQ01BMnJ6OEhtUHpYQ1RnRGN5d0YrRHJCZmhZRjduL0gzL0RsTW9aMEQrTHkvNDdzdzQ4bGRCTGhiZWkzNVdBR3ZuOXdRbVVuUHB5MEFYMEVvRGZmOFdUOEM4Qi9DOXMvYlB0Ylgyb0JLQjloZmdLM0JNLzUrR3ZGWGJRYytyaDhnMXVBQTVnREEvNS94NS82Yzkza2ZFWFh3RjNCalFHYmNsWDN0a2U1em1QSG1QaXg2ZXpUZTIzME4xZWlTTlZnTjVLVWd1TlpGUGtzTjNsd2FaVThCdmdtYjF3L0R6dDQ5LzZIUjhaRzNodHJSeSs3WlFEZ29zR1ltbyt4WXQ0ZmZFV1Nkdzg3d2k3RDlPSUd0Wnc1b3luMUd4eEwxa0dWOUh5cXMycGVtUnNQaTZ3ZzZROFdJNS93RVJpTytKL05DSmZiN2lPamZBNFJnVEdQcFhRUUlYaW9TckJtTkZxRHJ2UDN0dEVmbzJabExwNWhHZk9aQXBsb05wSWZwQTZvQVJ2bWVSR0d1S1MrSllYeWUzRjk2eHVwenFQd1ZVUU53a1R5amJKbXhsWjY1T2FOb1EvOFVKTWtaR2hpUnFJQVhnVlVhZ3RUZ0NJUjhjcEk4NHdoMmpqbCtBaldNTkthTVVRSUpxRVliMDJoQkF6d2pJeXBwMklxSW5wd2pvaTgwQ2lZRlVidUlDTjZMTUxtazBwSTVZZFlXTmlyVWpCQ2gxL3RLUEViQWx1bXdBZmhkcFJFc0V1Q0U2elJIZUdCemZVc2d1QWd2N2tyYVNCa3oxMU9OR1RUcWM2MW91RXIzN1ZwaFVRUUVBb0V6MG12WnIwb1hlSTdVT0ZocmRIWkExVEJPQnhMT1F3Y1NBZG55L282UFV6M2k5YmM2SjlBNHdxZzVmVzVqZnhFUk1acUdOajFuYVJwTm5zMk8zSy9PWGN6UW9VNWFheTE3YmdJN1J6VGlFUWpaS2lJeWFBS1U5Y0tVUm5KUFRCSEdjanFvRVFpZUl5SnZ1aER3T0FGQjZhd0tIK3NoZ2didzNZemVBdXhzS2pCQVVMSHRQSjZnbXZLYWRjc0Iwd3NuaUFqaUdTSmJVRWxYZkF6Wk5MRkRTZnRjUkdwRDBpSm1kMkowYzNxdlBvOXBXTGxtckszT2FDczZxdkJkYjhKcU9wOGtCamFlb3pUaUphWERCRDhJaE5VY2tWQTlnd0RLcVBtSjdFK0NiV1AvVG10UnNrVExRa0UvNzlNRjJIbmI1ek9CZW0zN2RBK24vRm40S29FOG5wZXUwN0t5OXF6UXRrcTZ5aUtjZ3lxR2JhSGY2akNnVVVIVElpS08rYndGWks4TXF4SElLamVNWU9EdEFZMmtEVElOMTRXUm5UemZNNkNXZWVRa0FiNllYbmtUWVNTbnd3UjhMbEI0Vmc1L3hyVFl1WDRmWGthcGlEVHdCTjVJaCtnMHdmY1QwT2lnU3N1VVg1VXBjdjI5UENzY2s0SWZOWU8rR05wcDBLNDVjeWR6U0xCQzM3ZUE3elA1ZjZWc0hrVmtMU0VBZHhvWnRBSWlyc0xQL1ZMbDUzb09TNXFYNFprcUI5R2hRU081R0FuZGw4ODNYUllrd0U4QXBuVElsSGRrZWFqc2NUbzNIQTB0azBFSFZlYy9waWptdlYyRWZFcEhidkkwN21jQ3BxUXRYUmo5VThjSzlvRzB0SXV3NjNRUmZJcGoxaXdKQkd4NXZsWGVxVGpYQ2YwQkFreDlnT0JKVEdsTTJYck91VVRzWC9idnZyK2J0UGdRQnJEeXZvbGZjeEVPNWlSbmZ1YTBreGw3eHZMZURlZm5QY1NlbmNtKzUzWHNOejluSGZjT3pQWXdoVGtIalgxdUNUWjFNL3k4ZElSeXZZQXkrOHo1T2ZsZ3FkTWdaSm9UNzJlYlhZTHIxZmUxWnJZUlBvLzJGSzdkbXR5emdHYzJRRE0vcit3bmhGTTk5d0FqcFZ0MWdDS2MrcmpYdUo4SjlCMHJMU1FmMXo3NS9xcEZ0bnJqK0RyeWZ5b3JwNDRMSlRCZVNQYXVZVFdEQlRNcEtjL2t2VURva3FrOFE5cFlacEJya2o5WHBKdktTM2plS0Y4dGlxclRaRXBiS2V2TjVhZWlEMEdjVllUK3pJcW9YYStPQ2pXSDBVempYSzZTOVVGMVh2S2ZuT3d6a3pHVEpnSlZXcXB5RzUwTkpySzIxTTgzVVoyM2p0TU41ZGROT296cVZSWEgwY3dhOXhDeWUvbmNOdDNyRWRtVXp0dDVPMi8vanJkS3hLS25lajZDQVJodndiejBnQ0NtQndpRHhXVUE5MWd6V01Dbm1ZQVMycllBL0gwWVlYMEZscjRWQ0FEMEhTUXBUTlBtWURQVHNWNUJOWHB4QWF1amV5ZzFNRHNlSmJrWTcrM2U5ZjQvNXU5NnpwOUJBK1lBRmkzNklnd2tmQkVHWG5MOCt6QWc4UjJZc2VGbGVCb3ZoRmQ3SDhBZHFSR3FpaCtWTHdvUFYvMzVVeGhvUk0ralp4RHBhTk4yQWNDenJKdk11UnJ2N1c0QytDS2kxdUFhUWpqK3BJK1pScHlQd3dTK3YwYlV4VkxqOHdKQWF6MVduMCtnQ3JaVHlLTWcvbFdmczdkaEFubmo4N3grNmovME1kOEc4RzN2ejRlOGp5OGdYN00zYlljdzhQbXZmSXlYL2IxVU50NUZwQWw2REZaWDljc0FmZ21tTUx5YTlFczlhOWNCclB0Y1h3RHdpd0QrMU4vSE90ajd5YnpSYVdGVmNFNXJkSnc2Zlc4U3NjNTFYWU9CMUV4enRnRlRVbG9qaDkvdjV0SFR2d283bDkrQ25Ra2EyeWlnam1EQU5VRlZGYmd1SUl5SmJSN3EraDBWbE5Sem1rcnZkMkhBTEtOTkZpM25nbEU4QkxDcEFGR2dwamRnS3ZCeWY2N0Q5dThhYkorKzZwOC9oYUEvVk9RcnRZUzhUK2Zwbmo5ZzdheUN1Z0FzUUZVWm83RjZhZnFveElCNjZ2ZG5sQ3ROdTVvRmxtbjR5b0RDZ05PMUJrTTdBWkxjTStmcE9KYUJnelIwSk1hQlB1cUdmaG9MU09kNVp1bEZyWFVFMWNtQzgwOWpoNjRYRFhxa3Z5TTNvRkF4NXQ5cTJGRndpKytjd2FKem1QcHpCak5FS24vb3dmaFd5WHNMUzFrN0h0NjZ5VlM1UjV4M01mbzM4U1AyaXlES2VndUEzdk5yTm9aV0g3Z0xvOEVsYmZJK0srQlRjVXJRNXFBQ2E3WFZhcVV0YTVsbnBsR3RqTGJxQURnb011bTlocDZLRXMyT1BqUkU2UGRjZjlMMjBua2djLzRZTFZrYW8vU2F4TENiYlFKd01uSk9EUS9wNzF3MGRHcTB5SDBPNUoxT3RPbTdhT0JjeUU4SnJEaEl3alJzWmVRb0pIMXAwN3RrM3pPcWsrbmYrRTdBYVE2cWtRMmxNZHFONnRSMUNIQXBtTkFIbW8wdWlMT3AvQnd5Um5yNzYxbmpPU296L3NnN2dVaXpDZjlzQUsrLzZVWmF5dkR3TWF2UnFZY3dnRlhPbUR3UFFGbWY5UUhDb0xwVjdGdy9hSm52aVlPVUJBZjR2QVhDaVpVZytBTzRvVnlNaFRTeTV2WlUyWXB3TmxGNTdjSHcxczJqWXVkNk5qcFo3bDJIeVVXVXN4VDBBQVJvYzNySSttNDBVdExJcmM0N09ibU1hMGFRay9wTnVmY0ZSRWxwYXJmWXVkN3ovYnRaN0Z5L2hBQUZqMkhSMGhmOS83Y1E2d3BZYW1oTjI3dHc0SFROeDhTMHlhdklGNHh5VW5tWmM2Ujk1dS9wTU5JTmt4K3R3ODhnQWhDbXpuamcxekpMRGcydGFxeFhlcGtESzJ1eUJ2LzJlWmlSajhsbG00V2xveWN3eHI1TlVFME55M1BXQnpCMkhrZzZUbHJPZmNFMDZrRDFyREVDbXZTQ2htK1Y4N2xuVlQ0Z2J5Zk5PSFRRcDNUbUtNSUJqSEtHUnV4ditGNmZEbS9kcElNSVFTMTFSZ015UE12M2pZSW8vV0Z6WGRvZVBJM3hNT29yWG9La3JIVittY3NhVW10RjFIdHQ1ZWVwckppOFMxdFhhQkZRamFZK2NvQW1uUU10QjVCcnViblR0VkNISDUxcnBlWEtjd2kyS0cvaEhxZzAyZU9QSWJMU2tVNW9KQ2pwMEJxQWs4SWNSaGladGtBMTRvM3Y3U0RxaTdPLzVGM3dlenZ5VzBHYnVmZUhLZWk1eCttY3JjQWhhUUJwaEdiS3lxMHA1ZEVqV0UzY083Ny9DY1NTVDNJOXRsQk4vYzV6ZGdkMlRtY0l3SFdCaUx4alAycFI3ejVleW16c08rZVhaMjhidHQvdU9naE1IanBGWkV3ZzBMemhZenQyR2tqNjBZZGx5NWtXTzljUGtKUThLTVR4RlZWblB2SUliYVVjNjlkUW5sbjRjeHY1cFo5bHBqZlh4bnY1ZWMrZnczMlRScmd2NCtlVXY1U2ZqNTJYckFMK0VwQ25MVWIxUnQyMy9FN0xMcWlUUlVmNEx1ZUE1MEQxeTRwZW1jcnJSWkpWeXA5TGVVcnJCVk0rNWRpNWw5bjM4cjFKSy9sZzB2L1dKanBOcll5UzZ1ZnlXK2VKL2UzSitOV1pzaXdKNU9PcHlDVHlMcDBYMGtvMGZGOXJ3OFFwenQrWDA4KzVWdXA0U3htajc3dzhkYUxpR0lGdzl0Ukd1a3c5bUlCcktlLzVHbFB2bmlkbm9YUThndFFKOW41elRsTkhhOVgzQUZUS0VaVHJJL3UwdGJYcDBlZnR2SjIzODdacXE2V3NIVnk3Y1R6ZTIzM0RJMS9WaTRaRStMTC8vVVZZeE9TSFlCR1hSeHFCS09Ca0YyYWtmQkZXMS9VTkdJTjh3NTlIQWVidUtvQ1UxNkI5RjJaOFlGclV1ekNoc0tMa1pzQ2FCVXdJZTl2SGRRUmpFbGNBZkFwV0Y1YU53QkI4TG40TUkrcHZ3QmpIMXhCQUVUM3QzODY4VTRYbUJVeDR2SStxY0VHaDRkT0lhTWNjY1dkOWxDMEFXK085M1VQWW5GNkZSU2lQWU1EWlBreUkzMFJFY1d0N0hDWTRIenJvcjFFYUYyQ1JyRmtRbU9Dei96c2ZYTHRCd1dDYWdQNC85bkhlUndOd0pnRDVSUmpRcGw3Tno4TFc0d2NBL2hpeFgwWStycy82Zkx3S1MyODlnb0hPcjhPVTFCZDlqSXhLSGcrdTNUZ1k3KzNTTUVjalFkL2ZjVW5HQXFCME9MZ01FK28vRFlzYS9qb3N6ZSsvSEZ5N1FjR2I2VWRxamM0QUt6YldOdW14enZJWkk0RlpTNDFHanR1d0ZPaWZoSzM5UFFCclRXdjhLTm9wSTMrZmdVV01Qd1piL3dPWVVZeHREdXN6bjBrakRuL3V3MEJqK1AyZmIzbWRDdVZVb0FIYkI2L0Qxdm9uc1BWOEYxWG5qTzU0YjdmZlVGdjNnZC83TWlLMVl3ZmhNUE82WDlNSDhQUjRiL2N0aFBKSlp3MjJoVjk3eCtmaWk0aEk5VTBBTDR6M2RyOTl5cjExM241Nld1bDFpakNLbFB5b0NhaElQeitMZ2tDZ29jalVLeGFqWTYrbzFvbk1QbWNvNmFOeXovT21rUlkxNVlhS0lUTGdjRnR6WlVvTkFTbllwOERaUFAwZVZkQUdxSzRKRzVWUEd0SUpBbEVwdm9oUUFCbE53ZjR3Z3VLT2YzWVJGaUZ3Vk94YzM0ZGxsTGhZV0NSYnVxWlUwdmxzR2s0SWJxMmhDakNYUnRVaVBMWVpxVWRheHFpbGUzNS9MZTFuMHZqY3Zoc2xtY2xnM1Ewazl6TnJ4ZFJvNDJHOTNwcDZrV2YzbGU0TkFaeWE2cFNSTndEaEZNYytENGFXOXJMV2NzOXlZMGhwT0VFZFNDbUJUVDBUK3JjYkZOUVlvRTRFcDJubGVOMHdRWU4xWmE1VG81aThwK2wzR2JtNjdJeGxER3F6SWlLZStUMk53R3JjT0pHL2RkeEx6M1E2cjJLZ215WDdnUVpWbnMyRlhMdEFHTzVvQUlKY3Izc1FRTG4yR29Hc1o0THlBOCtPbmxQV3NHUFVMeU9xR0YzRUtFNzJXdzFzRlhteWlGcDZPbWNwSU1iRy9uVzlYMk5aRHpYMkxSd2MzWVRKTjVyT1hVRWUzVU5qaEtHV3ptNDhMeWRBUG9WaFF5T1FvV2RoclVnY2R4cmE0NmdDL1p4YlJqWTlrUDFDbVpxOFV3M1VOUHFsZmFhVGhocEc1M0JnRnNnYTYramdWQnBlQzR0VTdjTm9Pd0hvTlpqT3lzeFFNKzgzSTRQTFZsaEthRTF2cU1aeDFoRFB2WnYzVTcvWmdFVitsK3NxK3crSUZPY25DRVAzSWpsbnFRTlVGN0dQZVc3bThydzEyZDhLenBVUnh2NTVvd3lSakdjQkEwUlB4RWxDcjUwNUlMd296UGxDSGJlVUQvQjlCQjBVN0JzamRNSXBiSTh5UlhRWFVYcUYwWVhNRERSSDFQeTg2L2R1dzJqMW9ZTkhGMkVBbjZhYnJJQ3FSVVFQczMrYys1VG1wUHk4QTAvN0tieEJvNURKLzlvY1kvbGNwcmFmKzcwYkRoelhRRndIZVFsUXAveWNjd2cwODNOMTRPbkNRTGZTMFljdDRSZEtnNW1SYm9EbTZPWW1mcTdnc0o1L090OTBrRVJnUThEdndvQjRyVFdwMFdHVUZUbjJObnJHY3dmWW5ycUtLcUJMdnJRaEFMaUN5Nm9uOE84NWJFNEhNUDVZbTRNTWVFYit4am5RODBQOUEvNDhnaDJNZXVYOFhaUnJzZzZvc3ZmVHlGYlZkU2hMYTAxNzhrNWVwODZaUENQbEhvYnRoMDJZMDRmdXYwc0loMU9lOVFWaTNTaExwK201WjBVMXUwWUptTXI0Q1hiMllFNEoxTWVPVk43MHM3bUZPQ016R1AzUDdSTUZxdFFwcktUSmZJL3Y2MDFZaW0rTmVOZjE1MXB6M2drQ00wTUp2enVHOGZPVm92MVJCWDQ1anBvODFkQlNHWmI3bnZacGpUNm03QWFnNXNpTEl1UFlLWFNtQXNobTVBejlQd1ZaOWJ3d1BUZlhnUDB2YTFBN3YrTTkxRzNYRU9kbmhxQjdQR2RsNW9JV0dVaHBTMFZ1RVg3ZGt6N285d3Q1SitlandrK2t2K29RUWlmSk1udVFQTHVTSGVTVStua2ZWVWZHdEs5c3FhNms1MVZsSUpYblZVN2hNL293Snl5T2t6b3VNNjhRR0NjTklaMmYrelhkb1RsNmpHRDhmYVBZdVQ3SzZPZmt3VnhiN1ovcUo3bFdqc1BsbVJ3Z2pzSlNlN2ZPdDlDRjg2amg4M2Jlemx1dDFRQmd3QUJQL3owZDcrMlNjR2h0MVRrc25TeUJPM296RGNaN3UxT3ZiVXVBanpVck4yQ2c0RGNRNlhqSlFJOVBFNDNvRWFoVGY5NElwcWhNVUUyaG1MWU43OHM2RE1panQrQ2x6TFh3L2wwYTcrMFN3Snc3OEV4bVRTOUlncHNWQXV0alovcmZxWHgrSHlLaysxaG9yRkdHMVdRWWZNWi8vd01BenlmZlRXRVJ2dCtDemMySFVhM1I4aU9Zb1BrT2JPMS9icnkzeTdUYkp6Nm4rekJndDQxaERCQUNlSHdvOCtEcHhEOENxK2w4T043Yjdlb2FTOXBhR21HWVZvY0NPajFSS2RSK0ZaR3Vac3ZIOTFGWUZPKzM0TkdoRHRaMy9SNHE3aWN3Z0pxQ3pIT3dXc0NBN2Q4M0VBQnoycDZEemZuelBuOWZnKy9kUncyZytoNnJlTkNlcGtuVUx3MDZUT1crZ0szWngyRHplUkZBNzcwQ2YxZHB2djVYQWZ4ZG1QT0NDa3EvQUR1anY0ZUlJQWZDUTUvR0c4RDI0YmRoKzREQzd6Y0IvSGN0cjFmbGxvWlZldlRlaHUwMTdtV200cVBoN3FueDN1NmI4T2dIMGtycDM2c3dKNEduWUh2eU4vemFaMkYwN3dmd1ZJd0kwT1pEc0lqeUwzbi9EL3h6Um0zdit6VXptTFBLQWV6c3N1NFlBZVozQnRkdUxLdkZjOTQrK0kzOGxJYUtLVkJKa1p4R0lhYVJmcFhQRTAvYnRyU3VBSlo3OE1LVkdMOG5GMGxaZTM0R1RDNFY2OFNRM2dYS21vQmxUYkhVUTNpRjhUQ0tkd296b3RmdVF4Z08xTkRQOUpoVU1obUJ4SWdEb0FvRUx2UnZVWXdaN2FEMWdCakZ4WlIzcE0za2Qxd0RPaWN4ZFZYRklFcnczVUVtWmcrZ0FZRzFMemxHOXBzR054cjM2TVZPUlptMGN6YTA5R3F0YVpqOTNRZkozcUt6WCswK3pyZi9ETnlRcjN1WXRjU3lrVzB5bHJHL24vWEJlb1ZGTGFYdjVETVlxY0xmTkd5djFNUkFXczV2MHI4cEl0MW9rK3dKMlZlbFlZa09DcWx5djZSTkJaQ21JVHU5THdVK1Z2Mis2ZnBLbzdFZUdlLzF4T0NRR2puSzV3L3JxUlhQM01UUVVvSzRRNHRrMVRTdWpQS2swVnpiZ3RjWFZZY1RnaWcwRkhNTWFyQmJ3T1dUelBycGZES0tpa2JzOFRBaW8wdGpYUkVSZjVvU2ppbEowM1hMTlhWNFNTTTFlakJaQW9WRm1uR3NMSjJSaTFTYnVhR2Y4amtCS2pvMERCQU9zTmxvSkY4SG5qMUdmbkFlVXFOZW85Rlk1b045NFpqdXlXVnFvR1ZFczJiTm1EdTlVUHFnVFdrRkkwZzJDbk5hS1hrQ1VFdEJXSEhPS2lKU242V0pOaEhyZitEMzcvdVlyaUpLakpEZVUxZGxta2s2c05Cb3k4LzZ5TlN1TGlKTk0ra2QrOGZua09hcm9YVGQ1eXlOOHFUOGtUb3RxOXlna1dNTEFEb1A2ODdqK2R4dUNrNGw4a2NPeU42R3ljT0hiblROT1dwUUwrZGVaQVFud1NNZ3dBN3lLVjdMbXZYTTVBWEVQdU44TWZ2WUZtd3Q5eEUxZktsRFFKN0QrZHBFQUFXYVJwZDk3OEY0QWgxcGxPZlF3Vng1b1BJd1RlWGRFZnFsNEJaVFpyYng4MW14Yy8yb2daOHZNMVp2RkJiUnBXdkM3R0pOTlNRWldYMUlPZEsvNnZ2NVROL0plVkdnbFd0YTIvOU5UWGdPZWZVa3VaY0FNTkFDbU10YTlSR09FSFNJU1lIRXRyN2RoZTNySTVqdGczdFY3VUFjS3gwSUNUYXhqeG8xM2tVNExBUElsM0pJUG1NZDNrUGhReHdINTMwMnJLYnZWL3NORURydERCSFp2c3FhZERKL2syK1BZV2Z0R01aanR4R3kxcHAvUnVBRzhqNW01VnNnNW5RR0MxNmhicTJaT1RqWGpLN2ZYOUpuOGtyV0xDWS9ueFE3MSsvQStQbTBNQWNnMnNwbU1tY1hVQTJzbVNMc0RHa2pIMCtCTnNxL1I3NzNtT1VBTVBrNmU5NkhFWVZOMmtJWmgyQXcwM09UMXRUNlZVUVVydXBqNmxCWE9qQXNBNThFc0NRZ3p6UE81d0N5UjN6YzVabEs1Y3dHUFkrNjJjS0JzNHJ6TXZ1NGhKOXpQMVAzSnAzdHl2Tlo4bUN0Q0tlRHJ0TUtPbjh5YXcvbGd4S2dMTUk1TGVlMG9qS3Jnc3Qwc0VvelpYVjRUNGFXTW1xMWFWMDZRZ2ZTUGRTRjBXaE5GZDRwSWl0SithNjJ0Uy9Dc2JLYjB6VXorcm5haWhVNzROZ3Axd0NveUpScVUwOWxHSlpGSWoyZ2s3YW1ST2Z6MUVHQnRzZFNEMHI3UGd3SE90V3RlWmFWVC9aOVB6TXpDSjI2NkJBRm1ZT095N0kxbTB1dUpXZUVmV3QxOGoybExucmV6dHQ1K3lsdWJZWUVBSlVvVFlLVkZBdys1aFV0bFFBQUlBQkpSRUZVREJNT0NNNHNBSlRnYi9LTWRaandkZ2tXOFhJQ0EwWlhKakl0RWFsVWNzb3hwWkdjZmwzWCszMFp3SXV3U0wwalZLTiswM1lFQS8xdXcxSld2eW52SXRCR0pqaVZxT2NPTEszd1pRQi80dC9OL1RzS25nc2cwdkQ2SEQzdS9mb0NiRjZ2b0c2c0dnUDRuMkVScWI4Rm0wdldSWGtUSnNBZHdkSlpuOERXYWU3UGdvK0RmWDdHcjMwSEJtd3VWcXhWV3pLK3BqWDBxTTcvd3YvOUt4andkVEM0ZHVNdHVhYmplK3BaQUw4TU0rUzhCUk9RTDhNQXQ2OGhsRjFHU3hFVTZjTDIxZGo3UHBGblgvTDc3L2s4SE1IVzZ5a1lNUDBTYkYzL0VzQ1BHL2JXT29CL0JGdURqd0g0WFJqd1BHOGIrOE0wcWNFOFBlM3pCZUNlb0hwZU83Qzk5WGRnQ24wSHdPOE5ydDFvVWpyZXN5Wk9JWitBcmNQSFVCVzBWUERhaDlXWVpncG1JRkpGYVoyN3NvNk9mL2NZZ1ArK29RdC81dmQrQW1GWW5jT3lHVnlGMGFoWFlPZUhEaEdBblpYUHdCd0MvZzNzckIwbHpoMFVRalZpNkZkZ0Vid0VDanArLzVkOWZkWmgyUWQrRlpaUy9CZ1dZVDZEN2UycnNHakFlOTYzTlpqVEF2djFDWC8yYTdEenRiSWp6WG43WURmMTRJUXJuQVNNMUJNVXk0MU10V2VtbjhGNVVxb3NMcm0rWXVCYXB1dzM5S2NDSmhXUjRtNkJBQlpvRUtLM1BXVVFHaUpPWU1DY0t2WEtueXVldEpueE1KMGdBVm1sUVVBVkxLWFR4Z0pHaXdnNEFFQnZXSzNkeUxJTE01Z3l5OVJ0ZE55NFA2eEc3TkNJM29QUjZ5TjRXdGlrcjVmOWN4cUdhUVNrUi9WSnNYT2Q2WlNuUUwybWJoRjE1dm93UnlIT1Z6ZDk1MmxhYWx4SnYwT2tlVDdWTzN3OFBUWE8rUmkySUttNEd1NmxBV0VPcktiY3BvQ0V6enRsc1ZyZHRTSkpPK2VmbGNhWmhuZWN5WHZlNytVZVRPdEhzZW5mQy9tdDhpUU5JMHgzdGlvTmFUSXM4ZnVLRVVFQTJoTFVFTHFtMTFVQXdXWDl5VjFmVktQaTFRTWZjdFowTGJzdzJqR1Q3em9JYjM4NmJOQUl4SWk2RGVTajNOUCtzYWIyb2R6SHlNK3VnaVlDaWdDUndRY0lRMkg1TGpYR1o5NjdiSDB1eUpob0pEc2FybFl2ZlFOR2UrbU1lVFNNdElFOW9CbzE1RFNRNytKK3U0c3dOZ094Um1VbWxBYUFqNFkzenRNWWxxS1d4bkRxUzNkV29BZnc5K1I0bSs1SnJjMnJVZUExa0NybExVSjNOREtGamdVRTh1N0I5Z2g1ejJYWWVXUkVHSTNOM0tmNmZEcDZqcFBQTlEwcWE1U1MvbTM2YnpySDh2a0tMcEhIVW80OWpYekJzYkVzMGxYL2FnYVQwNm1IRXhnbjBNUm9IQUtwbFZyVkxoZGM4UEhNRUx5eW05Qy9oYy9uR2lLckRzZko5V0xxY1JxVUNSNHpRdzlyQWEvRDVIejQ5OVNocVh1eUxBdlArUDJFeGxDbTZjSDByZ2tzT2kvbDU0ejBQdkxQS0ZNUVhEenhjOFQ5a09NL1hDOGFzZ25vZDN3dVY0M01yN1FWK0RtQjlNT202ekwzZFJEWlVlNG1mR0liTmtlTmtZUEwrSG1MekFwZVgxUXpBVlRPY2hIcGJMVjJOei9yRE9zT0VyeVBUZ2ZzWDZzVFhkS3Z5NGhJNGhQRUh1WDNkUFNpRE1xOW9HbDg2ZXhIZmJoV0o3UGgzYnFHdVhrcno4b3dVdUN5VVM0blNLbWxHaWkzTDlLNXlORmcyZmRBMENIVzR6NUMwRUU2eHRJdXhMVE04SGNkSUVBVzVlZmpJcUp2NlVSM2dEanoreXZJSEU4ZzZIWWZrYjFoQVpOUDA4d2RWMzErOWhHWitHZ2pLTFAxREcvZHZOdnl6bVZ5NUFDUmFaQXkvOGtxNTlIWGlCR3NtN0E5d1BYclE5WlQzc1g5d0I4Q1oybTYzU25jYnBQWlY5UlpLTnVzKy9Vc1hWTTZKUEd6WldOWnBTbnRFQm0wZ3d5UGErRG55bWY0bTN1U2pvU2FhWUp5dWpwcU1vbzJsWEY0Zm5JT1F1dmU1K01FNk9YYWxSbHZwRC9VeitmcHVFOHhYd1JISjI1N1VKbU56bjVseGdUcEJ6OGo3NTBNNi9vNXdmUkthYWpNT2xBdnBRTW5aWEdkQTNXK3BXelBnREN1UVhkWWo4UXY1V3FmVzhxV0hRZ2ZVajdvZTVQeTFYRXlMZ2FuYUNrTmxRTnB3NkVzTzBNRG5hWnRaT2pPSkQ2dVRyby9IbVh6OGE4RU1KKzM4M2JlZnJwYjV5eFJqT085M2FzSWI3b3JzT2d6d0VDeG1oRkIzK0VnMVVwQW8xOVBnZkFxRE9nOFRpTkpKWXEyRHdBTmZlZ2hRTVZQdzVqQ0dCWnAyTlJPWU9EVFBaaVE5eWYrT1ExcHo4REFtMWRoek9jMmpIRzhBT0EzWVlMUi8rSFBPVTdTWWxjQVZJa1kvbzlnb000N01PQW4xMzdYci8ya2ovbi9Ra1F6WDRJSnk1ZDl6cDVDcEFHKzdOL3R3OERBemVTNWJ3SW9ZSUJvcVJBNVNEVUZzT1lwd21tQVAwa2lJQ0gzRUFDbUYrRlAvUGxmU2U4WjcrMStCQlpoTzRhbDNSMTVuLzhiZis5dFJPVHpDTUMvZ08yNU1kQ2NidGo3MllkRk5NLzhzMHV3YU1zTDNwKy9nUUY1aStUZWRSaDRSKy81WDRIdHYzL3VmUnEvRjJDYmc0aG5BWDlMSlMzWlp6UVMvUW9zc25ZT0E5TC8xZURhalR1UHN1OHI5SkZDMytkaGpnNGR4THBxNDloSEFQNHRiUCtNL2Rvck1PSHJFbXdmSDhOQVlnclQ2N0I5LzlzTjNmZ0RtSEw5R0d3ZmNILzlJU3lpL08vQTlzd1BBZncrd25EN0JkaTV2dXJYZjgrdnVldVIyelJlQVdJNEEvQmZ3NkovZ1ZEY3V3RCtWeGhkdVFKelNQa0NMQXA5SDhEWEJ0ZHUzUGM1bzlHWTBiOGZndTNiZDJCbi9pVTRqV282aStmdHA3KzFDZVpGUkpDc0JHeTFBTHF6ak1MYlZMTlZ2V3ByNmQ0ZW9pODBTQ3pnd0l3clN3dUU0OUlsaE9jNmxkOEpQRnFuVFhsUmczRU9vUEx2MUNET2RJNEwrVjhqRnpVeWJ4T1JtcFhLSldVUlJqMXFob1pSZ3lGM3plZXdKc2Y0L1FTV0QzUGpGVVBxQWhtZ1ZZQnBLc3FIM3JjMUFIMEJsdHM4dU0va0tkejJ6Slo3V0I5NEFvOU9VR1U4WTFCWFVKU0dQa1k3OU9GUkU3d2ZWWTkzOGt6dTd6SU5wSDgzUUJqbFMwZUlsbk81VWhxOTA4Nkx2SHNoZlM4OTVkV2dnbnFVSmZjN0RVYU1aSmcyblBWeXJlWGNWNklPMm9DMEloTU4xRUtEdEYrdFVXc044OEpvcU5aN25hYndQVm9HWWczdVVPRFAycEsrejRhUzZyU0l1c0xVQnppL1U1bC9Bajh6Tnc3U3FZZUd0TEZjUytOVFd1Smlxb2EvaHpXR3VoR1g2VHFuTURyQ0NEQUNWZ1NsY2hHOTNFOVpnNkxRVXdKRXBZRVU0WEJDR2dqRS9pd0IzY3c3bVJGbEhhWWpWQUQwTmtOdVMvOHJ6Z2NKMktOUjJXcW9uZ1A1Vk5mc1EwUC8xU2pjaCsycnVjOUZHYzBDb3krUHcrYit6ZlE1eWJzVTRGTytUVUJBUVVYcWJOeFBhWDFwNVhrMDRnTFZQWmdiRjllMWxDSDhLL2FIWlYwV01JRDBSUGMrWW8rbzB4WGZlUjl1VkpkK3BnNGp6SUxRVDRBbk90Y1FSQ0t3ekJKTHBIbGxiV1dFWXpIMzVWWFlYbU42Vk5vTVNKc216cHRvZ0Q1cTRPZDB5S2p4Z1NJQVlEcUp6SkdjS2FFTEM5UUJaSzZyQWhKTWswMUErSVF5MmpKQThIM2k1OXlmUURnRkVKREo4WFBLVHFVK2p3RHV1NUQ5bi9KYy8xK0IxTG5zRTM0M0oyMzIvMnVsSUVTbTZneHYzVlNINCt5Y3dKMFBWK1Zmc2cvbXFEb2liQ0FpUkJseHpMR29jd2lCRHU3aE5kaCt6TzA1QlYrNFIrYUk2UG1LODVBQXM1eDMvVnRsWVhVRzdjUE9HZDh6aC9FNnlrMnIwbXFDdFVmRHFrTklTcSt2K2pPUEVUSTQ1NUR5TFoyRXFJZFBoMVdIVFhWVTQ1d1EvT0s3U00vMkNjejR2cjNxL2J3dC9MeDAxdlR2cUxNY0QyL2RmSkRLbm1kdC9wNlN0dnNjS0Qya2d3M0xDVFE5cCtic0lUSWxFSTYzdXViVWNYUmZxa05YRnJ3Vk9adHJ0a0RDTzg5Q1cxckdkaWJhQnJUcXY4cXZLSXZuUUYxbTFtaXMxZXpYOXBFQitJVEhWTmF2Q0FlTDJiRHFkRmNCSEZIVlVkbmFNaTJ4bGZ4Y2RIekt3eDBZWHlFUEJDSTdBNTNiK0h6U0Mrcm5iVHlJNTY2aTQ2RWFBY3k5UnY1Tyt3QjE5RlEvNS80ZHdQbW44TVl5TTR4L1Rqcks4ZVhPUXhzL0orM25mT1FjQ3dnZ1V6L1AyVUIwYjAxbC9udXI2SlB2ZCtONWVGVG45YnlkdC9QMjNyZitHWUNtZFFDL0JnUGdTQncxYlZLdDZUdE9BMUk0dUR2MXY3VzJuclkxcVdHcnhGN0JZVEtNRVl3SkhjQUV4aCtpSFFEbXVKZ2loMUZDZ0RHVFoyRU1oRjZCNjdDSTRSL0RBTS9IWVdEdXR4Q0NPZWNobDNyc0MzNDkwQXorQWdZNmZ3Y0dHTDJGOExRYndWTG16djI3aXdEK0J4amc5eGYrL3lkOHpDbjRDeGk0OUo4RCtEZmp2ZDJ2K0hNR3NMa2FBZmg3WGd2NXlOOTUxMU05SC91WWxGa2V3SUJxenRrVE1ORHYyK085WFVieGtKbSs3bjJjd0pqNUE0UlMza2NWSk53RThKL0FnT3J2d3hUeWJEMC9wZ3BQOWpqSDlFdCszL01BaXZIZTdpUVR2VDd4ZDl4RHRUYlRNWUQxOGQ3dThXblB6N0xtTmE3TFBaNm16czQxQng4M0FJd3kvVkVCbmlub0xzRFc4dmZmNXpxeTY3Q0k5Si8zdmx4R1ZkRFIxcEY3RHYzNkoyRk9EMEJFRjlBSWRBKzJSMTlDTllWYTJyUVdKR0R6OFJZaXFvWDdUbE9aVW9pbjhmSWlMR0o5QkdBODN0c2RJYnlCUjdENXZRU2pEUVIvZ1dycW1sK0RuZEdQK2JnR01QQjNBbURUbjhucnFaaGZnWUhVanlQT3lIZFJUMFY5M243RzJoSWp3UUw1dExxNTV6VFJxNVU5Z3d0SjJjZDdFbU5NcjJpdlg5T21qRk9CNjhKU0lLbDNNeFZlbmxFcXRWVGttRW9zN1N0VDg4MzltWXpVWU9SalNsL1ZpRjFHT3ZzY3FhSk5MM1plUDBHVU1EZ1U0M3NmS0d1UnFtZjBabUZwRjFOdjVrdXdOSHFWOUlTdUhLL0IrTSsyLzZ3VlZwdE1GVWtxdmprZ2tQSU1sV1hTR0JvOWxSK3dIbVNPLzJ6NWM5TzBrWFJZQVJKanRiL2pMRVlZcmhjanFsanZjSnpwMndJbzA1TVRDR0FrdUhxSk56WE9FM21JcGxCY0lMemNnVEJjTnoweko2OCtrdWJ6a05ZY1hoU1dYcTV5SFFSOExhSm1aQWxxSW9EWExpSlZvVjYzNXZmUythR0RhanIwVG1GcDNDcU9JTG4vVzRaVWlkYjF2M3VGcC90YjFZQTNsRnFneTY1RnlBZ0Vnem5lTkpWeERYanh4dlBJL3ZMYW50elBzMGhBVHVkZGphYnNPMlZRVGUvZHlSbG56OXFHRmdsMURHRE5EZko5bUdHSmtYRXNpMU9PUStjL0dVUFpoRDdSR1pGQUdzOGVkUUZHcW1uOXhEWC9uQ0JZMnVoOFExNHkxK3ZTZmI1ay9LME9TenhiOGpYcEl5TXhjb2JUU2pSL1EvLzVucFBDVWdNcVg2ZWp4QmcyNTJ2Rnp2WG5FRTdGbkh1dG8xM1NidWxINlpRQ3EzK3A1NGJ6bDBhZEUrQW1UOURvS0FJWDNTTHE3M0xQODkwMHhpclBWNk12SFk1WUY1ajhuS1VPNkxTUnp0YzZwUHdCQWNKaTV6cEJGWjZoaXdDT3lTL0p4MlNObWJxOHBHVUlXWUhaUXhZdUY1QlhFSkNsampJYTNycDVWd3pFaTZKcUxPNGh6OC9KRHhkRk5mVTREYjE4MzZiTXh5VGhxd3F3cGZ5YzY4ZnJTc2NYbDFWVUhtSkt5Wnp6QXAyZXhzbm43SDhYbWNqY00vSnowalkyOHVnY2pTVVBCcXExdVV0YWtMbSs3ZjlPVWVYbmN3QWFJVmNCY1pKckdWbmQyb1FQbjRiM3orQmxNUHgrUnJocXRncEEwcTRpK0JjZE54ajl6WHJVZlpnY3FmUjRnVWhCL0FCeDlqU2F0bC9zWEQ5QUFLQkE3RUd1d2N4cFFjb1QyQVp5TDk4eGNMcXFjbEViR0VSYnl5UUZ4VEwwbW5OQytabmdKQkQ4WEowa0RqTHZwbXlzT2daZ3RJYjhuRGJHeTdCTUU2U1RSN0I1Vlg0KzlYbGtIeGdwM0Mrc3J2WWpBWEw4T1ErS25WbzJCTTZoOXFzUkFNNkFYWm9WU0cycnFxTXRZTFJMczBjQU1aZks0N1VwdjZhT2taTmRIMGs3QTUzU3VjdzlUK2RxVVVoYTZ1UTZwb3FuNDYzYUdGUGRvVFlIMGtwOTFaL0ZmYXlaTFhLQVBmdTFrTy9XWUhJK1pmWWFUZk94azQvUUtaRHJ5M1h2T1ozaWVhWitUbjFDeDZaNnV2TEFtbjdPL2lIa3JwSkdpOXlqTkkzOVlXWU1kZVpWb0g0QzQ5RzhsazZWUGVtTFBuZTkyTG1lT2pEUTFrcGRzR3p5UHMycXdoSkZldTVLV1N1UkIxUkhKNTFNMDUyblFIK1RnMExXK1ZqSG03Ny9ySTN2UW5PcGlQTjIzczdiQjdEMUpVcXltMHZmek9iWFhRYnduOElFaWhkZ2hPVHJNQ0IxbkY1L0ZuRE0zOU1iWExzeFRZRGpwblMxV3VzSHFBcmQvZkhlN21Nd3BzdTBheFI2THdENFhFdFhqaEhwblVhd3RHVnFKT29nb215WUp1eDdNSS9uTFVTMDhkOEQ4RFFzcmV3UGZDd1ZRY3ZIL0E5aEtXWlhhVDhQUy9uNkpneG9UZzIvOE44VVBoK0hnYjZNR3N5QnYyeGRHQkE5Z3dIWEhSL1RKZ3dzZmM2ditTcENPWGtBWUgrOHQ4djl3MmlzMXlVTjhSdzIzMC9DaE9VT2JBMllTb05wZTdpT2FUb1piZjh2YkUyZWdLM3gyNE5yTjI0M1hKc2FiTHF3Q0hBMjF2eEpnZEE1ckxic29kZkMvbk5lNTNXR3FSU2ZpdW10Y2k2Uzd3Zmp2VjMyYlE1VTZ6TzdjOE1XRFB5dDdDdi9mK1NSd0YrRGViTi8ycTkvRXNCbnhudTdYODI4ODZHYmdOaU1xcG5KZTRHSVVzOHB5dnlmNStqSHNIM0hGR3lxUEZCZ2ZCbmgvWHNwODB4OTlnVlk5Qy9mL1RsVWFjRWNWa2VZMzNkaGhyZ24vTjVqMko1L0VsNTdXdnBMejlZUHdjNjlOZ1VnbmtiVTNyc0hpOVIvRGlGODhvd2V3d3hjejhKU1NUTVYzazlnOU9idSt3emluN2NQV0hObGJRb3pzREJOVWdVQVpNc0JLVTNHOHdiRm9pdnY3S21TS0pkVmdEWlJNbXVnc1NoMUhYa3VvM0E2c0hQQWlIbzFQSk9uVEJFMXVkUnJXQTJrZEU1am1rMDFWRFExR2x4bk5OYkxjN1JSNFFVaVpUd1ZXamFOU0FVaStxMExZTHZZdWY2dUdMaG8rRXRyelFLUjJuS004UFN2Ulc3NjM2bFRsUExUR2R3N0h6Wm51WFh1b0QwNmdUWEQwbnRvK0tHeS83QTF5WFd1R0oxejRpQXdhK2dxT0thUlFRUVY2VUgvQVBXNVNnSHFtUVBxdkw4UHEzRkl1dHlIR1NNT0lVNFRSZFRvS3BYdXhQQlNTWFdZTVhSMzNEaS9NaC9XWi9BY05ZR0VpU0dyWEZNeDRxWnlraHFlYWJTaGt0OUZBQ0JBNHZtZEdjT3FJRzdhajlUSXUxSUUyNHB6cUFaTjBoUFNuSkhzWlJybGNnQWZ2NlBCQi9Cb0dGbGp6cGYyaytVcldNZTJiTU9JZHFSeGppRHhJM1VrSUJEcGY1ZWxMb1pSbDdpREFIKzdBQzRYTzlkUGtJbFlrRVpqY1VkK3FKc3RFSUEzOVFUUzRoTzVmZ3RSM2dMK2Z1NkpJeGhRblpWM2lsTkdJYlJkMTdTZkU0TmRHV1V6ckViaHAzMHY5N1RRZ2hwZEZkNDFRamdrUG8wQVVzZE9JMmhNbk1GNHdqR3EvR2FDYWhTNmdtN3AvTkQ1WVl6SU5OTXJvZ1lvZ1pTVVBneVFSTHdXTzljWlFWUGFGQkNsZDBnN0gwUHNDMGFBNlJ5Um4zTlBhRXBsdm5mVG4zMWZyMitRYStqMHdyMUdIWE9CaU14S3g4WHp5WXhVckVQSzUyaDkzemxDVnQrQW5mMzdNaTgwU09lTXZYUzBPRUhJTUl4SVRYbFVqcCtYaG1RWlY1Wk9jRjFhUUtlSzg3dzBBc0FFekI4V3RLSzlCZ2paNDZUWXVWN1N6QXcvSnk5S25XeFkyN2lObjgrZGJ1bStaRTFxM2RlTTdLYWN4cjI1WHV4Y2YrRFBQU2wycm5jS3l4NmhVY05ya0RUU0FweWRZRVg3Z0krQnFmUTE0cFpSOExuU0w1U0xTUStZZHYyK2o0M25jWTVJazh5elRwNU9rSm1SZFBEbmNUOTBVVjN6MUdFbG16b1hBYVJ3emZnc3RsYm5PQUlWVHV0WG1jTmpoS01DKzhOelFSbVU4dW9helBrcHRYZXlUNlE5TTVqdVRTQ0l2R29ydVk4UitQZFFwWkVhU2I3djQrSytXdXBJY05yR3ZhOTd5ZmMvYVRramdzbG5XeU9DRVE2VTVBR3E1MHdRVWNmOFh1ZWQxMi9BZUVEWmhFZE9JSmsyMHJhQ3ZQakltK3FoeTY3eDY1b2NJTFRORUU1djVDMXptSE5HU1RkOHJkYUtldjNtR2VxMXlobjVtM05pb0lOTUZ5anJ3aXRvbjJZTTQzbE5NeFlzL0g3ZTAwZWNNODVCdWdkVVRsQ1F1cXh4QzFUbWtCbS82T3lodW4ybE5RRHNVN2RCOFAxcFUrZVpPWXhHa203V0hHbGRGMUw5c1Z2c1hGZEhZNDRsdHo4NEw1cXVQNVdic3ZxNTZJL2xmQ1UyQXlUWFV6OXYycWZra1dtanZiUVBvNHNQWlRzVVFQblU1elFkMi90OTFzL2I2ZHI1ZXYzc05YclBYZ0x3dkVkbS9rakJWZ2R5bm9DQmdpOGlGRk42OVg0S3dLdURhemZlU1o1ZEkzekxtcVFXcHFKV2Z0NVFvM1VEUm5TcElGSFE0Yk1lOHo2enpnZFRWZmQ4M0cwZzQyMVloQ0VWdm4xNEdtY0gxQzdCd0xSWFlRRDRDNGphZmoxRTFPbzZMR3J4K2ZIZTdwY0J2SkxVcXUzQVV2T3VDdjRDSVpqK0VLRUU5cnhQbXpDZ2JCOFJEZHoxNS84WkRBUitFdFcweW1uVEZJaGpXS1RpRTdDNXZnTXpwSDRJd05DdjJRZndyLzE5aHc0OGxveUprYmgrMzhpZnM0NVlBd3Fhai92ekZ6QXdyS2s5QzF2ck5SaEErUG54M3U0ZkRxN2RlQzF6N1VMQXlHM1ltcDM0ZTk2R1JWRG1uQXZtRUlIZUl5eFZVSzBaNzFacHA2eDdUVUdGM3V1THdiVWJhUm9acGtocVRDL2pLWXJ2d1JURFYyRHo4Si9CNXZHcjcwVXRZMmxVTkttd0hzRDIwMVZZYmVoUElxOEl2Z1BibzI4aWF1VnMrLzJNc3FPQTlaTDh2Y3hZK2hLTUp0QTRTK0dYYlFGTEMvNDZ3cUF5QnZEWHNLajd5N0E5OUF3c212Nmk5L1ZGMkxuN0VTeWkrR1hFT1dRcUw0MTBHTUhXZzBMcDNKOXpFUUZZVUhINklveSt6UHpaNy9wN2JyYzU3WnkzRDFacjg5Zzg0N055RVkwRTNrN05melBQenlrWU5DeGxsVFJ2V3U4SVFGNmh6Z21VWXV4bkZBN1BTeGZCMzZlbzFvK2NvMjRJSlBnR1JPMmdTb1NnR0twbVNEeHRDNGtpRktOYkNsaW54cTAxV09TdkFpY0RuNjlqR2M4RWR1WTNZV2RkQWVNRnpKaWRNOHljQUdYOTg5SFFQSmpMc1MxcDlLaGU4K2VVV1FWOExDY0FIZ2hZVHpCQURmeE1jellmMXFPRk5TcE5JNko1NzFtTk9TcWpyYm54OVFSVklMZnZnTmxjK2pCSEdIRjVIVE0wdENxOS90eVpyQi92Wi9RdjkzSmY5cXRHUjVSTmphRnVxQ0I0bXM0SHovSlpGZW5XODY0QXFwK0pkTHlNcnVPMVd1Y05xSjR2UmdscjZ0VEd0cUtSclBYZVpmZHpEbklnZWlGcHdlWGpUdkkzLzJmZGNVMTEyRVdzTlZPU2pvYlZTRU9lclhWVTE1R0dVdDBYakt4YTl6NVBodWJVMElVWlJLY3laOU5Wem80YmxtdDFhYy9ZRGhwQVF0S0VtbE9IR0FuVkNLZUdZeldhTGVSdkJkRjdxRWJjczlIcEtKWEIwNloxb09rWXM1VHY1TDViWWI3cGpET0hSWjh1Z0d3dDBkUW9tUU5NR0MyeWllQnhhc1RWZVZTaklIbFgyUVJRNjRoUmtiTHgrdkRXelhMdGltcjBUUjk1dWtqZW9ESkZDVEFramYybXdacGxCUWc0MGZGYUhTODBXb250R1BYMGk5d25kRndpelNGd3luVm5DbldtWFdkZFJvMDhxbVQ0S0NMYW0zMmhEdCtIeWRyM2hTL1M2ZnRRcmlFSVIyTzRaaERnM3M3eFNqcFJyZmw0andweGxGdlN5SWQ2SEt0L3Z1WDBQVmRQTXhmaFIzN2VCTzd5OHprZURUL1h0UG1rVzVNRW1PNDVIVmVqTzFBRmdZR0lNR3l0WFM3OG5IUkIrUnFiT2kwQTFicVdlaTFUMFU5OGI1TlBIcU82cjlaZ1ozVnBIZUJNb3l4NUpMSm15Z3NwbndDaHAycUVPUGNHMzAzZ2lRYjcrOE5JazAxd2lIdWJjdUFDMWFoK1BmK05QSDBZRWN3RWxCVzRuOHU5YmZQU1EreUROQ1h1RnFxbE9VakgrQzdTb0FVODJLQ0kyclVjNjFvUnBRNk9ocmR1SHZwODNCZCtQa0RVZm1lalhuSlBQcU1ER0IxQVJzTFBlNmpLcWhYbm5LYm1lK3ZVSlRCeWJWaFBQVXlBYTFCVUhZcjAvYWxNcVhJdWRRaGQrMDdtZHdjdU55WDdSRUhXeHZHSjN0VkJDMUQ4S0ZwUnpZUkJwOGdLcjA1MHZtV3lLTmQra2R6RC8zbU5waEhQMHY1aDRsem1mU3BCMitTOWRCeFJPNERTVEFhdHpKTjFtU1hYUWZwSS9YanU4MFRlUTVzZTcxT25qb1ZjVTNPQWtyV2R5ZlA0anJuTUJ4MmRVcUI4SXM4aWZXcmlTNVJMZXZBMDlESmZqT1k5THNKNWpRN1NkQmdwTTMvU05vQThyNlN6RXROMTA1bHlsY2F4cDNMcndQbldoTEtiOUx1U0FVYjN4ekNjVldydmtiOGZ4WGxTK2ExYnJKNTlpYTJrRjRWRjBUODB2VHR2NzA5N0NCbnd2SDFBV21lOHQvdGgvL3NYWVVMTkR3Rzh6V2hDQjFsZmhOWEdKT0RLbENLSE1DTHlDb0F2ZTJSa0J3YVNmQVRBMzdDV0pWc0xtRXRtY2hHbU1KWjFXVDNGN1dZQ1RIZGhZQTRGNy91SVdoc0xmODVWR0JIL2VRUkR1ZzlMUS91aGxublpCL0Ivd2dDY0oySFJ2ei9rKzMyTXZ3YXJaZnBEQUY5Q2dIUUV6UDlKNXJrUFlKR1lYeWVRNTgvNkpWZ0U4R25iT3pBZzZGVi85MU93OVhrSlJwaC9IOEQvS05kVENRY01BSDI4NGJrUEFQeXhqK2t4Mkx5K0RlRFhFWWIzYmJuK083QTk4QnFzTm01dWZYdXdlYitEQU1qMy9kbFhFQkhUaklxOEFnTzkycG9LVjIvQzZzWGVoeW50L0o3Qzd2T3crZG1IcmYwaExMM3p1L0RhRktldDZidEtOSytQTzQzYVhlVStLcGNVa0RwQVBYWDRlRy8zUS9BbzByWTB3QVRCSFl6dndjRExBU3pLZTVUVWZPWlp2QXdId3BjOHU0dW9VVVVCa1VBSGxkTUJiRi9TbTV2R29NK2pLaFN6M1lIdHF6c3d3RGRYczFxRlZpb25iZUN2Tm8wQzdNSG1ZUisyaCsvQXp0RjlpQUZIb3RrL0RBTjRuNExSekxILy9UUWlzZ0d3UGZrbWJCNWZSSUFKSnpCQW1VRFdTd2puaWpmOGgyQVBBZWVlOSs4bk1KcnpKdklwdjgvYkI3Q0pVdmpRUW02aVlBSlZiMzBhV0tqQTFwVEhuT0NXZmliS2tIcXhWa0RubklkcVRpQnNFaFRWeUpCNU54RDBtMHFtR3U3SWY4YiswNXJPU043RjV6QlNsZEVoQkpGVEF6NlZPYWFJTENOaC9ETk5TejBmUnRwbmptRlQ3a25yQWE4aklyaG9hQ1F0MVNnaUhRZXpqU3lHdDI0ZXl1YzBQTGZXbmZOM3F0RmZ2Znp2SVl3SG13alpxcXlOUEt5bmxLcEZnVGc0MGhsVzY2dXh6NjNHMmt4L3R4SHB0TWhUOWpPR21lNVFvbVFFdkMyQkpiK2NrZE9yQUlxWFpHNkE4UDRtbUs5RzlmSnNwQWEzb2w1REx3Y0NsV20wSGxhcFdoWEV5dHpYOC90b0xLZHhtMnUrU000OGdjRmFsTTRaM2swRGpSb2RWNTRMcFJsTmN6dXNwdmJVZEtJYTZjU01NSFFlQUNSendERFNBRy9LV2Q5QWdJRTBWcDM0T3pZUmEzNVlSSFRZTVFRRWx2ZHdIbzdUODY5ME5ESFFzZ1lnL0w1VG5iRmx6ZC9GMm9takZvTXh3VDN5alFYQytXWWJZVHl2Z0FpSTdBNXJzSG02aHpNMjd3ZjFtZ1drVmlOUXFldWI0NEU1UjRIYzh3SFRMMW5IbHpvTlVJKzhyZkMzQmo3THFGYnlFb0t1Rlg0TE8yTjNmVnlNZ21VV2lKTmtiOUF4bXJ5TG1UUW04aXp5RWpxMkhDUG9GR0JuUm1zTzBrQmRwbWhNeGxJQ29vbmNRVG94UTlEVWpyeEhaZmNUdURQM2tuVlFzSTdSaXdPWVBzbEl3TW13WHVOekN3RklYL1JyVDJDeVBoQU90WnlIZDMzK3lBY0kvTk9KaW5MVzFIa3JRWHlDcG5TbXF0VUg5ajdSQ1d3eGxOcXlSVGhodFpiMVNNQmQ3aGVlTWRiVzVMUEs3REEwNW1kb1RJNmZiOEgyZ3NvYmpKNWVtZGFRYnFLcW95MWdOQ1U5aTJVSzFnd1l3REZ5bkdQdnl6SitUaDJWUCtsWlc1ZlBOVkp1UDNrT284U1p0cFFSVzdyblNRdXo5SEpaazNGVEZ1Tzd5RjhxY255TzUrc2ErUm95TTlaOWVkWlk1dktLOS9rQVZVY1VCZXBLZlh2SmZGTy9WeGtpVzVPNDRYN3k1N0lHdUh5M0FhUGxJL2xzRzFVYjNCd0c5aHlMek15K0swKzZoNGdJZnVEUDJvU3NIK3dNam4wK3lWc09oN2R1SHZnNE4yRHp5TCsxTEFUdGprZVpjVFR4Y3pwNXpwR1JBeDYySmZ1ejFpKzVoazV3cGU2S2lBN2ZRdGgyVkE4RklqaUREaWFWakI1bjZLK3VuZGI3Zm1RMXpZdW9HODh4Y2ozbTZSb3QwOStMY0F3QmdwNVFyOUpJenpuQ3lWOGpkM1BwdU11ektIb25iVzJRNTY4amRNbUpqSW55ejdFOGszUGF4cys3RUVlRVJFNm5rNjNxNjhyVCtmeGFwb2JNbkNuZm9reExQa3U1S0syQlRObUNwU2xvZHl0TE5ZbWNRRnArTFBjQ2taMUVIYURvU01qNVZNZkRudmRuM01EUHFUZGhXSGUyVzhNUzV3L1JGV2xEVmRscEpQMGFJSUtRMk45c0RlOE1iOTJBN1dOcW56YUhBQUFnQUVsRVFWVHRIeDFiVDBWclpJOEFpYzFwaFh2VjRVSDM5emtJL0FGc3E5ajZ6dHRQVjZObnl3bE15TXdwM2pSUzNvWVJ5SXN3NGVGUFlNVHA4ekNROE9OZXQvTGpNR0wxRW9CUGp2ZDJ2d1RnRG9FcmdpZ1o0R0lOQmdCdXdFRzU4ZDR1bWNFNmdJdmp2ZDFEdWEvci9XWE5Fekp0SUJqVWEvNzdiUmdZM0lNcGwxU2ExeEZwWmJXZGVCOE9ZQkYzeDZoNlBIZDlIdmp1NTczZlRCdjlVUmd3ZXdXVzl2bXlmL2NXUXBDSHpNZjNZYUJQVTBSdVUzdkNmejRCNEkvODc0ay9hd0lUVm04amdMTUxjbThUK0F1Ly95bVlVd0FOVkJUcWN1MzdNT1hpTGhyU0hybHp3QnNJNXM3NXBVRDVISURQb3FXV2RLWXBRWnJCUURuV1U2Vm44RlVZV05hSGdXZDN2YTlYWUhNdzgzNjBSdlJLUGVrZXdkQjBENmYxZWgwc1pNMUdiZjFNYldKOUR0ZHBDZ09tWndTU001ZXpObTJyMFN4NTF3SVc1ZnBSMk43cyt0a3FVM1A1N3czWTNub1R3RjltK3FsQzdoeTJaNTczeng2SEtVOC9nSTMvWXpDYXNPOC9WMkZucUFtdzNVS2tCWDhHK2Iybnh2a1VRRjdXcU5RQWxrcjVTd2pqR0RNS2FJUkNId0VDMzRWRkw3OEJBM1paTC9nSW9WaWV3TTdlSGRqNFNkc1dzSDM0MTM3ZHI4czd0bUFnOGd1b0dwSHUrdmNqR0UxN0F3Mk9GdWZ0ZzltRzRUbjZLQm9WSmZYd1ZlQ1hyZnliQnFNR293TmdIcGdhOVRwUHZnZXFFUmhsclZBMWtCWWVYYWpDWVFyV3lmODFZMlB5YmpZRm9hbWs3U1BTVnFWMWNkU1FvZ3FGS3FWTWdjUTVaQVRCTEJWMDVibWxVUXFocURORlpScUoyeHRhNUJGcmd6SEtSdzFnUE45emYvL0k1eVNyWFBKOWhhZUhUYjVpbGdFYU1GQlkxRU5hdzBpZFpzWXdta05ENEdXRThVQXpONVNLY1FiSVpYMURmVStGM3lWRzZ0TVlqQm5kUkM5eUdoOTZoVWV0REcvZG5PWE8xakJTUDZiR1pnTENsR20wajJXcVlnUmZ6ZEZZalM1bWxCNzgyZE5VRVI5S1BTMXYzU0x2N2F4NzkweU5RQmZzUEpmRzJ4V1Z0WjQvZzBadHZhY0RsR2tmRlpTcTBJaXpLb1YrMzdUSUdMSlh2RCtOYUFCUXpzY2NFbGtxWUE1UXBTbXNnNnMxYXdHUEJoaEthdStpR2tWTlF4VlFsVWxVWnVzV085Y3A3M0FmSC9sN0tEZXdyejFZaEZKSHdVdFlLa29GS05MK24wYitXYm41bk41dE02Z09JNktSVG02a2E0d0VaYVNrWm0vZ0dBaGVMNURQeGdPZ05LelNDYVFKZ0NpanJ2eC9PaXVsTktMdi9DNk56TmE5clVBTTE0eGowOUlEOEw5cC9GY0hrMldnRkEyS2dLUUFsdnUwZjlQa2N4cVVwN0Q5UlhDTisyTUNPMU05UklwbjBoY0N6M1EwSkJCRVkrZW05NUh2TGdGWjM0TUxmNmZLSHVyZ0NNNkI3d3VlSlFYdk9vZzBoT1N2bzhSSXJjWm1Sc1Z4enRXNVp4MFd1VDcxOTEyQ25SZk9oZkoreWdhazRRTlkxT01NdnYrS1NEbXR2SitsWHk3NmVJNFQ4RVRQSWZrNWVWaFc5aHZldWpueS9xYmYwM0dzTkQ0WHpYVkRGZGpha3I4cER5aFAwZjFOcDdhNVBEZkhwNXY0K1duVFFWT1dVRGtLTUY0RlZNR1ZuRXlvRWZHbEhJbzRQd29PbEdsT3hhak8vUTFVYWVVTUFYWnBTbVNlbno0aW1ud0JLeEdnNE9nNlRDWVo4Wm9pb3ZHVU43UzJRaHlWaExhUlBtanEyQWVGMTd1Vytjbnh2UTE0RkRKc0RmZFJqWEluYUttMG1RN2FsR2RMZVpIMExDY2ZKKyttTTk1OUJBODhsZU9yeTduZDlIUC9iQUtMakdNSkVBSS9aZVEvZ28veWM4cDBjREIzQUhPeW5NT2kveTdDNXBYZ0tIbE42VENJT0U4aldGbVFweEQ3dEE4RDFpOUJIRU1RL082eFl1ZjZQWVRNMlllVmZ5SFBZVitQRWZ2bHZlVG45MWZnNTh3K0J3VGZtNGhzVFQ3SWdDQjFldVVaVFZQWGwwMW9iQ000bU9oempRQkVUbTdrT1Z6eWJPWFRKYjhlUnJRcmRZK2wvTnlmeWJYVVBsTi9UV1Y3L1hzdTkxSC81WjdRZTVraWYxSkUzV3Z5YzRLVnlzOHBoMjE1Ly9qZWtuNklYTlR6NzhuUDZkU3N1Z3d6TEdua3A4NkxPb3NRUEU2ZHFsZlJ6NmtIejJFMG1QUTVCUTduQ0pwVTZtdGNkd0dDMDdQVWtiUFBldVVwT0t0eUdNc0VkaURPUG1seitTTzNuelZiQk9Xb3RXRytuRW5wa0M3dm44SWo5bEYxbmxOWnQ4emNKUDFiY3prM3pXSlFOcEZ2bG1YWXlUWHViYmFWYWRhdzdpZ0pvRjR5cWFubCtOQTVLUG5ldGZPNS9kbHJYWmpRUW9EelhRRHZKSkdRRklUK0FzQ2Z3b0NTZndhTFF2cytEQmk2RFNOVXZ3d0REVitHRWFWRDFPdGx0S1hCZlFJR0pqOExBNGdlUnlidG1BTnJIVmo5eXdlSWlFOEttd01BN3c2dTNUZ2FYTHR4T0xoMjQvYmcybzF2d2FMOGZnd0RYLzRJVnVjejE1U1pqQ0FDdkwvN2FZUjM0eE13OFBMbmZPeWJNSVBPUFJqNDlXTlkxTytmd21yWGZnUEFiTHkzMjVIVXhFZXdhTWV6dGkzdno1c3d3T243c09qZ3F3RCtQLzk1WThrejdzTG01V3V3dVNtOHp6K0FyZldQV3U3OXU3QUk1djhXd0crTzkzWS9KbU1yMitEYWpSTUEwOEcxRzZQQnRSdHZENjdkR1B0ZVkvMmQwNEMvMm1pdytKRC9NQlgyWmRqZWZRd0crSDRjbHJLYzZYV25DRy9MaStPOTNTMkNtdU85M1kzeDN1Nno0NzNkSnozSzlsUGp2ZDJQQXZqSWVHOTNHL2xXZ3BRK2Zpb3J5TXhINDFoOVR4LzYvSkJaMTZKYi9aa0hpTWd0UnVQeSs1NER4K256NTk2dkg4TDJTV3Fnb0lCMkQ3YVhGdWx6L0g5NmtkSmd3SlJLTDhQT3hHZGdrYnUvQTR0eXZ3SURpRDhETytOYUF6Z0ZzU2dnWHZYbk5jMlhHcFBhV2tYQTkwYmpFTDNqYVdCYmc1MHBOZVoyeDN1N1haL3pDV3plUjdENTI0WVpoZWhVUUcvMWpzL0xCWC9IWHdQNFBRQi9Eak1rM2ZiZlZCZ0hQbDRxbWdUTEQvMzNHN0R6ZlE3Ky9wUTFVVWdleGJxUlA2V2V0NnBJMVF3dStuNFIrdW14V29LN2lXQ3RaMGFWcy9UTThieldvaExZK0g5aHFXYjFiQ0c5WHZwS1J4Nm1rVktBY2dZelFxdWhTS09wdEk5cDFBaU4wanlya1BsVEl6b05ZR3FZendGcUZVTURGVHYvN01oL2NzcVZ2aCtJOUZQWmVaRm5wdTBZQVdnekltSkx4aytEeXlVSTJBMmpRZThnMHRnUitPVGVVSy8xZE44QnpqdkUwQW8zWUpZSzV6QnFHSjYySG5DWnloVVJvVWJEMHdZa0k0UTRMdWdhMFBCSG9KWVJVZHcvMnBTL01tS2tLeis4aHVla1lwUWEzcnA1NGo5ekdMaFVjVmlTT2NueG9iUWZLN1hDYW5CWCtLS2ZHd1h2YS95LzZWbW9uaFdOdXFjeGlwK3JjVlJUKzJiUCt3cnZMdFBWUGd5TmJMaFArNkRyV0lMMjdrUXdvMU9EUCtjWXh0OFBTWWNTT3BQU1BpQU16MnMrOW1QWXVUK1I2MUlENE56ZnJVWXpHbi82OGs1R3Y4MlQzelFBalpCSmIrNjBkczNuK0tFTXlzdld4WUU3bG5tWndNQThuck1SSEF6MmEyaXNQNGJSaGdmK015c2lkVEdTZnROWVR2cWU2OE1NSnJjUzdHa0NTVWdiOUY0MStOSFFtSjVITlhSVEJ1UVpPWUduWDA3N3hYRWtmVkFETFkyYU0vbE1mMmFJOU9SMDNENUN5TzREbUo3RGlKWU5WSGs3ZVJscEtkL0gvVUpBVkNOeEdHVTBnZTNwQzJKODVkN2p1NmdUbFdtNDNiQ3FxVDRuc0xWUlVPQUE0WXd6OC9mME9XY3cyZmtLSXVLWm9MTWFvR2MrRnh0RlJPUnB0RFBwRmoranpzZTFxRGoveXZOTDBHOTQ2K1pZYU5PaC82UUFLUGVCUm5JRFNmM0dGTmp5ODUrZXJSRWtyYkNEWEQzZFd3SnNBaWhUT1Qvd3Z1bjZrQThvQ00rNTQvNWdLK201R0dJclJuemg1eXVYbnluQ3Fhb0VCRkdsWTVROStJNGNQNmNzeGoxSWZwNHpYS3ZjUXA2bGNoMmZvZXZFL3pHMEZQK3NxYXY3bTIza2M4MnpxWUNLUHZNME5vMExBQzRsUEgwS095TVZvSEFGSHNuVTRseGpBaWdFTVNqbmJTTE9GbmtJOTNYWDl6emx1OTZLUEtUamdPcGllT3ZtSk9GdjJaYmpULzdlOUQ3S0pSM1llYWYrVHNlRmlieFQrZmtFRnUxS0J5Tm0vcUZjUEV1dTVSblpCdkNrdjRjNk8ra3dNNFdvb3hmMUZUb1NsT1c3WURZQzdnM1NxQTE1QnA5SmZsNXpCRlZaNldIYkN2eWNwV29ZSkRTUzlUaEc4UFA3c0hIeit2dXd1VHBFT0NCcC8vVzhkU0EwdjZHUGxKOGFIUmxYa1JremUwd2RKY21ERkRDY0E4aldZVjN4TTVYcCtKMk9uZU5pWmhLMXc5SHhnM1JNOXozN1RMcW5nUW9hbFYxeDJKYjdKekRaY2lDOGFDN3ZvZjVUeWtPVUk0RUtFRDVITlhzVlVNM3lBaGpQNGpucm9GMC9oOXc3OVh0Wnc1amo1VFVjSDhlK3BzOVpRVDlYdW5JTWMrYXEyVXNRWjFLRFhYSUFhbnBmMnRTT3dTamM5WVNmSzQvc09QMmpyRUY1alB5YXRFZGwxSngrbmpyeTF1aXE5L2ZVOVlEbDNLVDhuR2R0cVM2YlBFTmxqRWJiVUhKZjVlZGhkWnp6bG0vbjgvcXoyVG9DR0czQjBpNVhpT0I0Yi9jak1HRHpEeGdocUJHOGN2OENCdFQ4QnpBQy93WXMwdTByZzJzM0dyM0E1QmxiTVBEa0FnenNBSXpRdlkwRThNaEZFUHN6S0doY0dWeTdjYnZsZlV5cjgySGtVelhmQWZELytQUGVRUkFuTXVSZmhBRytUOE9JK2pkaERQTk5HRE81Q2dmVDRRYWdOSVd1OTNmRG4zSFgrL0xiL3ZXUFljQnltdksycWMwUVFId1hVU2VWQXVzVEFIN0RQMnRxYjhIcW5yN3J6NXJCd05LbkVFYWEzMXloTDYvQXdPSWZMRnQzTmdmVlhvQUJ5UytzY28rM2V3Z0R4UXdtckcvNk9MNEdpNWE4NnYxL0FyYTNYa0Y0SVpQaE1aVWJnV0dtRXI4SWxGRUphaHhXWUpaajZQbHpSaEJocXkxMThtbmFlRzlYUFRINXpEN002SE1JQTR3WENkQzhCV0F3dUhianpwSm42M251SU9hRGFkS2VoYVVaQjJDcHNxVmVOdzJkSFJqbyt6eHMzcS9BYWxzL2dhb2dTZ0Z2SVo4dlVCVWE0V05pYmQxVm1ncmJ1VVpoZTEwKzQvdjJBZndCcW1EdEFuWW1GckR6eEQ1M0VJcmNKbXpQUFE2TDhQMm9qR2tNMjU5My9ab252WTlmaDUyeGZkZzhmOXJ2djR6cWZOeUI3ZUZOMkJyZmhkY1hUdmZlZWZ0M3E3bENwSUNBcGlidEFQWGFSZW4vcUJyUTlkeVZRSExtbm5XNWx2UkJ6MjgzOGJndHozUUNDbFBCU2VzWElYMnZmSzl5QmhCR3JJVjhQa0VvVUpQaythWEJiMmhSQTFSMk9ZZnFWY3hJRTAwUDFZVXJjQm5scE96YmFjQXJONUF6MVJ2Z3luVEc2TE9GSmFuZ2lraDF4WlNmTkhpWHRSUzluNC83NTZOaGttclZGWHl1SmRQVUt2aENVSlExeXl2cDBESUF4NW1iN0ZFMWZFNkJNdDFtaCs5dmVxK1BoOFo0QXVzS0hxalJOcTN0ekxWUlJ3RHkzdnZ5RERVY2F0OXJxZUtLcXVjNlVQZWM3dm40bHRKM0JVRjhQOWZPdmhoc1ZuMGVuUnhvc0NJdG9LR0JtWE9VRjY2VXNvdGcyakFUd1pieitGN21CVTZqVU52WVpJNVV2bEJnWEowMDlENGFXUFRzcktPYU1oNEljQ0ExeEpIK2FPVEROcXFPQTZOaFJDK3hUbWtwSS9tK1pnUUdhNmt5VW92WHJhTzVYampwQmgwbUJvaTZrbnpYdG4vM3lOTk1Qa3pUOHl6bnNndFVJdlN6RVQ1TloyL1Y5OHEvWlhSSzJoL0VXZFhVaUJxcDJuVWFsZTY5SnNQV1pRUTR5VDE3aEREb0VleWl3MnB2YUtsTjJkOHRtSXhJK3NTMGtveHdaV3BoallwZWg5ZVNSNlR6SlBCQlB0cUhSY2JPaTBoenp2MC9rZjNMakVYN3FNcjJwQ08xZE03RnpuV21tOVdJYno2SGRPY1FFWTEzQkVrVlhJUURHVE50bEtVUkVNNU12SWFSam5SRzU1cU1rRSsxWGhxL2MvU3FxZmw5R3MwK1FUNURDZmw1NDdPTGlENmJ5djR2UVdtNWpsSGZpMkc5OUlCbXNORDl4ZjVSUmhqN0d0ZFNTRDZxVmtSRXFtYmdtQ0xvMjlKekt6SU5EZjlwUkxCR3FTdmQ0THZWNlZDQloyWmlJTWhRY1o0c2RySWxCR2kvNFY3bG1QZ2M4c3pGOE5iTlZ2M2JuMGYrZ3VHdG13OThQMi9CVTBqNy96emo3eXlUczRwcTZtaktiYXhuZTlrdll4WWRkUjVWWGFLSlhwRXU5ZEk5SjNQVFMrVHZIb3d1WnZtMTcrT2VBTFJOWTlLeUhnVHNTS3VPa0pIQjViN1JzTXJQTC9pNG1RM29HR0ZEU3AzL1hrdlcvekdFZytVaExQdkF6R25BSm95MkVManErZitYWUNVSlNLKzREa0RRclAwV2ZzNTFaSitucU81NTByK3oxSjErejVyU2xSdy9mNS82MENZejFQUzNSSC90Q28wQ1d1aVUwRGtnb2lPVjl2SzhzVVpzVFM0dXdva0pDSDVXNnRnSXV5VmxDc3FLVEVWT25WSXpaZEIyemJyaW1rS2EvSnhwbEVuWDZOd0dlVGVRMTRFMUl4S2IyaXlCcUt0Ynk1NlJrWDNwM0tUNk9hOVIvWnpQNTdzbm1iNmRWVCtuQXdmM0F2WC9uTHl3ckdRRjUwK2RwUmwxblBKelhwY3JKUVJVOXhUL3AvMjZDOC82OVY3eWN4a1RHK25TcVNKRlZZOUZFazI4d256bVFNbjNqYWFjdCtiMk1IclllWHYvV25tQTB2UzE4bmtQd1BiZzJvMkQ5THRjRysvdFBndmdjekRoOGg2c0RuQk5TTlQzb2lxY3A2a1VaNnZVWnBXSXl3VldBTjdHZTd1YkFMNEk0RmN5WDQ5Z0tYTHZ3VUNYZlJpZ3hYcDBCekRnOWlvTW9INFY0VmtOR1V0alhWbXZyWHdaSmtUdXcyb20vNVovL1lxLys5OWJNdXkyOWsxWW10cERXR1QyTDZ4NDN6NHNKZTQzQUh3QjRmSDRBTUIvMVhEUFQyQUE5aHpBdi9UL1Q3Um1jMXZ6UGZBWnhQaFg3ZWVQWUdEakVXek9md0dSOXZvcmcyczNmdUw3WWhPUkZ2b3dTZE9zRVQxQU1GTjZxUjFvM2QzVStVQUFWMGFNVXNtYXQ2ejkwaHJBRGZlVnFiTUcxMjVNZk42dXdHckJhazFwam1NTEtDT0tsejA3NTlRQm1KSzBEZ010K3o2dXFiL25JbXlPNkFtOURRTkJqMkNDNklkaEFDN3JiVGN4N2RTemU1Rjh0c3lUVEkwQk9VOVNSazlRc0U3QnBBV0FmNDd3aUg0Q0FjTHUrN1AzRVhVem40V0JBQ09mbTVkaFRpRmI4aTRxcEhSS0lSanhReGo5WU1wNEFta2ZSMFFQbjhCUzdIL2I3M2tlNWx4eWQzRHR4bW1qNk03YnoxZ1RNSllLYXF2eTBmSU05YXhWQjR6U2NBdFVVanpUVTE0amlMUmVUamJOVzJKQUw2TXZYS25XczEwYXkxdUFIL2FidkphS0ZHbkxjZHY5OGh6MmcvMGxxRDRmV2xwR2dvQTB0TXdoZFJZenowby83eTB6SGlkR2EvNGV3NzJSUlFHbE1mRmVpK0dCNlQybmJlOHRkcTR6QW5nOHZIWHpmc3QxT1JCbUUwa0t4YUdrNjN3VUxWSHNXSWU0TkhobERMTUVpU3RwcmdSQVpxU1hSdjhTdUV3VitUSkNTb3l1ckFrSmhCZDN6VnU4WVJ5cDQ0TXF1Z3F5S2lpNUtnQmNwcmowL3l2bktuTTl3ZUpWd0ZvNlBrRDZSZ09JQXBEWmM1WWE5K1RNQW9uQm8rSDlYTHRGN25yNXZqUjJOUFNCNTdzSmZHT2ZDUFR4RElMUFJuamJ6MUIxT0NGOTVMems2bWFPa2puSU9RVlFQcVdoUzZPUDVnRDZ2aGNwejZreHNJT0d2VWdlTVl5YVoxMDQ0RHUwV3NRbDRPQmp2TC9LM25pL212ZS9rWVlXbnQ0ZWRhY0hucU9sVVdmeUhpQUFTNDFtS1EzRy9GdnVJeEJicVpHYjBLY09JcnFuN2Yzck1IQ0E1MzR5bEhxcm1iNm1kSVY3NHpKTTlpU2dSWU1hd1U4Ni9Fd1JEZ0VMUkowOUdxWlpNM1ErbERweDhyNmVHNitaOFlmT3RBOFF2RXFkcGljcFRTc2lxb2VsQ3g1NFh6UnlzUU4zQnMvY240THlYSGZPdjQ1djM3OWpEVlFDWGcvU3RSSGFVcWErUlFCNlIyMjBTL2c1QVhZZ291SVdpS2dkanAyZ1VTNTFmWm5XZG9raGxNK2JuWllYeXp0MHZ6OVM1OUlNUDZlemRoK0ozQ3BubDNKbHVqYlVvWUJZUThxdGFacExCU1c2THRNcHpRT0M1cTdDenl2eXJlOWZkVGlnczlnQzRSZ0VIK2Z0Rlo3UHNrRUUvTGNSWU9kOTNTY0Mzc3lid0VKL0p1ZWRXYVhtQ0JCbUFkTkQ2UnhCMmFnSlFOV3hNMkJqSmVjaG4vZXIvdTg3bVhYcXdzQnR3R1RjcGpQSlRGMGxBRGFzMW9tdUFLQStoMnFUSTEza1hGQTJWQ2ViQ3doSFFjbzdmUmh0ZlQwRkRodjQrVVdFYy95UlBIOENPNmZqSWh4LzFCR1hUaTVOL0h4N0dIV0txYTlNaDVFdW13RWpkREQ3d0FBaEsvRHp2dk9VSEMwOE5aQ1ZBbTZaNzVZNmJUWUF4WjBWK0RtemFkQlJvZWFjazk2VDZVdXFiNnZkalB5STlKN091Y3JQZWFhblBxOXA2WjdLUElrdVRnQ1MyVm5JcS9nZU9pR2xaNVF5S3gxMEtFZWxHYVJHd0hJOVJOYVBkS25NVkNIbmgzb0s1MjU4Q3YyOFZTN3orelJyQnZWclJndXJrelhuNkVHTDNhS2lhN1M4ODJINE9XVTRJSnlEMzdOZ0VkWHptczVvVG1iTlBFTnRUN3kyMFk2VXNTZXhaZlc4UjlGRWpqa0htTEdjRmhZcjFKVE8wZnJ6OXY2MkhCanpVRzI4dDNzWkJzUXhGY2liR2ducXdLZDY5VEFGeWhHc3h1WnA2OHFjdG44a09NL0NsTmZmUVRBcWJTUyszNFV4MUV1d2RMaDMvV2NkQnE1T1BMWHhhZnJRZ1FGM1ZNajdNRUQ1Tjd4dlg0RXByZjhsenA0V0dRalFyaTN5dCttK3IvdmZ0eEdHOE4rV2EvWmh3dkliQUFvQS93ZzJubjhCajBiTlBiZ0JRUDBsV0FycFZSdHJOQzlnNi9ORFdLVHlDekNGNWpYL1lTUTVRZE9WaUkzVTdyMElUOUdiUk1oMlBBcVd6RHIxc2dYY0llQlJwK3JOUk90ZWhudkxaNkxNTzBCcnluVUM0RlM4VDVETVV3SW9xNkk0Z0FHN1V4aFF1Z0Z6WW5nWndMOUd0VzdPei9sM0gwbGV2NEN0M1ovNS95L0FhZ1UvanFCTmJlQ3ZBcmhNWnpyeXZyMkxTSXRIWS9BYVFzRFZaeHdEK0o4U0FMenYvYjBNcTAzTkZPa25zSFBQL1hjUmx1YjZGeEZLSSt0K3FnY2pGVUdlZWFZOWZ3QlR4Si94Y1U5ZzZlQy9od0NmNStjcG44OWIyb3BJcmJWcWpVKzlOelY4VStBdVFWalVvMGFBTUxyUitMQnk1RmhHMkZlZ2c2MWlmSmQ3bFQ5clpJdzZXSFJnSUsxRzN2V1MvNmxZVXFDZkRhc2V4NlVoMFo5TmcySEZTS2dLQWVxR0F5cW1XWVZVN2xkRHQ5YWdZeW93R25Tb2lMSXUrZnBRSWlVRVJPcWdwWDZ3WDlzRnNEWE1SRm9rWXlLSVVqUEdJQXlUZE5aTFFaaW0ya1pOZlVxTkc2clVxd0daMGMza1Y1dUl0Rm8wNnB6SS9Hc05ZQUtaZkdhYWxwTVIxSXprVk1jSFJrb2VOaWl4QTBqRXB4Z082RGhRbmxNRUFLRnpyWWFTdHZxbWpVM09WcFBCaXdhVXlaTDlvUVlOemdXTjJVejN2Y3l4SVpjR251dXppdUducEVsdFJrRTBLS0N5UHdnU2xIUkcrcVhHSGU0TlhSY2FlUWphbE9sWS9WcXRkY3MxMUlqeXpUYWpuL1FCOGw0Q0Z0d0g3QXZCYU5JTE5vNXJtZ0oxL3Z3TGljR1lvTjREMzdNYThiOEc0TzRIUlNHbklXeDQ2K1pSdy9jNTR5d2RSaXBSK1lYVThNdzlCK0lrMG5STmsvRktBWWhUamsvUEJkZmdrdmQ5M0VRL1c0elhHLzV6MForeGozQVc0Sm03QkRmQUlzNDN3U3BHQTUrMDBZZmtuWnVJV3JBRTlRaUE4ZSt5bmlXTno3N3ZML3JuM01QMy9iNU5oRE5wQndaKzBZbUJkR3lhMEJlTk5sYWF1K1hYSHZtMWRBUmV3R2g1bWlGRU15Q1ExMURINnNKckRMZk1CNTFTZ0tDWmpLd200S1JnTloyYldMOVl4OFI1T0dtam1kN3Y5WWJ6WDRJYVJlSXdsTjZQY0Q0Qjc1RnJ6c1RQWmY2VTc2cnVOVW11VWYyU01nVnI4SkltcXZPdXluRW55WmtnV015OXljZ3JPdm5Pa0FISjVDeVZqblJGUk9UeHZHZzJCb0lsRy9LK0VXeC8wMFkwUlFOdGFaay9uc21qREdoRHB3blNyRWFnb05pNWZnRjJEaWhiam1HNjZRSmVscVFKUkJhRHV4cjZLdzd6YmZ0QytERExrUnpEOUdpdXJlNHhucGVhazZXUDRTS2lYSjA2cTJpS2RFYmZFK1JXUjlaRDRlZWtkUW9PWDBhVUV1TjlUSWM5QlhCNWVPdm02MDFqOVQ1d2J1Z2d1K245cGsyQS9adkI5Z1dqaGJuLzJaL0Rodk44eWVjQWtQVDh3M0RHV1pkbklTZmovMjAxWDU5dWJsd04xNU91NTNTUVZuNHJZRnRqYmVHbWQ2WUEwMmxib3NzdzQ4VEpHZWduYlZia1NYUzhYTWdQSFJtQUFFc3JXYkN3WWpTNDhDL05DS0FBTFAvV05MMmtqN1N0QWFLcklhSlMrWnR5OWFyNk9SRE9tVTM2T2ZXMlZPOXYwODhyMmJKYTVrVFRLU3R0b2Q3TDh3YnZCNTJNMTFLNXRRaG5xMlh2N0VBY04zUGZyd0M0Y2wrVWV5NjFwWnpHYnRQU2gwYmRUdGFSKzZmU2p3YWRycE43VnZKZHprR3BtL3M4N1cvbWVhdjBweUxIUE15OC9hdzBvYzJOQUc5T1QwbSt5enJubkxmM3R5MkxyRHRMRzhGcTdmNGxMUHBYd2Q4dVRQaDhBaVp3YmNPSTZBYXFFYlR2WlZ2QUdQTTJ3aXVRU2hvYkkvMDJZQkdNbjRXbHQ1M0J3QnA2Vks0RDZPZnEzVGExOGQ3dUJSaHc5dXYrbkcyNGNna0RVdjhRQmk1OUZBOEgvc0tmM3dUK25zQ2lDdCtCZ2JnNjl3ZUlsTE1ITURBMUZYNlpzblliQmdEK1d3RGZHRnk3OFdBSldMVSszdHZkSE8vdHJvMzNkcDhDOFBkeE92QVg4SnBVc1BsaDJ2QjFXTXJlci9tNFNtL2h3YlVicHdMUS9Gb3EraThBMkI3djdRNjg5dTlWV0QxZ0tsYjBkanRFR0RGVWdIbWtUY2ZoZngvQVV6TjZ6ZCt1MUpkdTdJZGZRMEIwSFpINmFFMzM4K0RhallYL3pBZlhia3dHMTI1TUhXZytnb0czUC9HL0QyRjc2QjMvK3doR0N3NWcwZVJma3RkVEtKakI1dmQzWU00T3Z3cWIzOVM3dTZrZElhSkF4ckNvL1ZjQmZCVld1L29kMkQ2L0RlQ1BBZncrcWdZRTltR2N6T3ZjblRxWU92d3F6R0hrMHpCYThFOWgwZm1mQXZDUEFYd0NZY0FZSUpSL01rb2dqQnVzSlVVSGc0c3dVUGlic0Ryci84ckhjQUNybC8zSW5Rak8yODlHRzFacm9wMjFFY2lqd2trZ2ltZURmeXN0NGJsczlmak05SmZuV2gwMzlJeW5RS0ErTXdXbVdFZVkxMUpaUzg5SzVmOUU0Q3k5Y1lkV0YrZEVEYnhEcXlQR05KSHBXS24wZGhIMWxGVDViUVIvcGM4MFNLdkNScU10UGIvNXZKNWN2MGptdVZTMnhDQ1dYUWNmUnhaVWdkRW0wcnZMc0JwRlRUSUlsV3F0SWNkM1BLelhzVG9qY0QxS1QyUFlIR3pCYUQ0TmREMUVUU1VhWXhXazAvMmRSdEFCOVRTK0NoeVhJRVpEZjlOMVZ1Qk9yK2xtcnFIaVdnTFBaMnlOL0Y3MjRRSzJWOXRrRXdMVWpPRFRDSVFlL053VjRubGQ3Rmk5cDhKcnpTYjdubk9lTzV1VlZrUlVDL3o5cGVMTlo4dVlhaEhjMHBSbWFSMDFIYmYyaFhQUDcwdUF5ZmZ5YUdnMW5MbFdPa2VrWDExNExUc0I0MWRwbXpLZU1ZeHVzRVl1blJobzBOWmFwWFEycEVFODErYkZ6dlh0WXVmNlpVU1U1YUcvanc1b090K0Q3Rk5nQnZwaTUvcldrcjN6cUZzdVhYaXZ3VUJMb0o1cFZCWG9ielFFKytmam9kZDRUZC9qLzFiMnU5emJsSTFoYVMweTdpVmZkNEloQjk3L3JmUjZ2bC8yWURvRzhzSjdNUDN4OHYvUDNwdkZXSmFjWjJMZlhUTHpadGJTWGIyU3JXWTNGNUhVTmg2T3pMRkVFVG96OCtDUkRXT2dsd0VNR1BCRHZmazFEUnZsdDBLK3VRREQ5ZXluZkxNOVhnYXdNREE4dHNlbWo2VFJOcFNHcENpSlpJdk5acFBkN083YXF6THpadDdORC8vL1JYd25icHpsNXRaVnpmeUJSR2JlZTA2Y2lEZ1I4Uy9mdjhEV0ZxUE01akQ5aEVBVzk0WWFTcldlTjUvTHVyb3BVZWJlay92WUxzOE1CWXUwRGNySm0zNHZuU012U2R0TE1nYlBTUjEvaHAvemUwWk9FdnhsZngvQTluUEtvNmdEOGZkenBVV2xMUkRyVXplZHp6MUVvRXY1RGtuNUMrZHJRNjVOMityREl1WWFlWUovWCtlQXZnWmdzNHpScExsMUhBeTBQdFoxeEZyS2ZNWksvRHpocmR3SENsQUFWWDVPWFo1QUxSMEllT2FUbnhNVVYzNWVNUXJMdnFOY01KUDJnWGgycDdVU3RlOFZveldXK1RsQlJhWlFWZjdLbFBzS01NNlFlVllMa1dmbDVLK0pmTGVSTzVzU29uMXJqTWd6Q01vTW5HZUY5KzI4bkcwUGVVYjUxN1NyREFETVdzNjVFZXo4SWRqTWFPTk5BQytxYkZuY3ZuWG9QNmtSZm9DWUdwNVpEclE4QjBrelkyaVdvZ2tFZlBlMXZKZnc4NzdjejNlMlFKUXpSNmpmWTBvTHVMM056NkVuQUg1V1dBcHczczlzQUpmODd6M0VPcnZjeXh2SUU5TklNNVBIQWZVVmw0VlNSNEhjdWMzdmhnSktuU25KR2xsRlgrekxUK1g2TnREQTMyMmFXbGZsMVg3dXViSkdsb0NnRG5zc3RDSHJpbVVjbHQ1bmk1N01kVDU2cWlVQUFDQUFTVVJCVkF6RWlIZnVPUUxwUEd0VTFrMXRXNnByODdsckRXUGhHY0c5d0hibjhuZE90MUhBR3FqS0Y1QjdjdmE4SnYwOHlGZ04rcm5Xb2xZS2N3WFRlYlRlN2d6ZGdGanE1cHJxSDdENVQzVWtRR3pPK240VHZhVnQ3YXErbWZacENHQlVtZ1BRcHVnYTZmMXorWHNUd0ZiU2h4UGhMQVJFYzdLbzk1TzhhNDdJbThQNjhENzNNM09rOHNMU014RmxodlNhVkxmdVFwVm5wKzJtQUtiSUJUKzNsSnlEWVQvNDV4VmVVN2MybkNnTDBtNXdVYnY1WTZLVEFvd0FZbFFrRUZKb1BkUm9SQUdqcVBCUkFOVkRsVURhbVpMWFNXVnQzSmNSRFNpYW11aXUvMnpDSWt1RElJbm95WGVFV0RjRUtXalcwSVZmZ29GSUx3TDRaZm44eC83OHQyRkM1OHNuRzJtRkZqQndkQS9tR2Y0QkRMd2J3Q0lrcjhLaUhUOEhBMzYvQ1FQMk52eTdQY1E2VWluOUNEWUgzME5MRWZueDdnNEJXOWJqZlIyVzNuWlZJbk0vOG5IY2hSazNaakJGbmNhSE5SaWd1USswdnBlVWhvaEEveHVJNlI5ZmdBSDRURDE5bExRN0hlL3UxS1ovUG0zeTUzQU5xcEU3R0x2SHV6dUhyQnZyNjVSemN3blJLNWpDYWlkR21vRGtHTy91SE1LaVZyVk8zWHgwL2Vac3ZMdERaZnlic0xUaUt1QUNNY0lxRlZnMWV1Y0FjUTNUSS94RGIvZkxpUFdyQ1lqei9LR1EvRDdpK21Sa0dMMGRQOVN4eVJ6OUd1SWVIU0ZHSnEvRHdHQXEwVFEwOU9WN0tuTUhpSUtOUnZUdHdkYnRIZi9kaHhtbkdQVjdRUmZVaGNpelZoTHFNOExaa1FqQ1ZHUVVCTk9vbXlWaFdCVHpudjg5VHo1WG9pSklMOEpGdVgyRHoxa1N0djM3MUFPYUNqRnJnUFdRU1o5V1kwRE5HZmtxcEI2MnhiSm5LOXVnUVZjalBydWt1S1hTemhSYlZOcDRMalBxaGFsaCtUMVRVeExJSXdpV0ErVFgvZnNsbnR4aVZGYkZkZzFtQkF3Rzh3eUF6SE9QUnNPVjA1Rm5ETVpVdm1ZWnBXeUU1UWhSdm45R2JYTE8yTTVjMnFHQmtEUXN0Mit3MXFNYWJDSDNhdHF2cGZWY1NEMU8vMzVhYnQ5UW9JSTE5VklEaWdLTmFody9Mald0NlU2eVQySHBCT2xvd2FpcGtPcDRGZU9CR0FMNC9MNnZ5YnErRUZDZDZWejcyZEIwbnVnenVSZDBuL0szbmlselAxTUl2czNLR05FNXlPMS9PUmZaRmcxejZiTUlNbWlmVWkvOElKLzU3Nm1zSVo0RHFoL1J5TUhVZW54SFBjUXpOMTJYKzZYVktnVHlxZWYyRUFFdjd2azY0ck8wOXRpWlVWR2YycFRaQnlxUlJMNEhLWk51K2x3ZW9JT1hlYzMzYzltYlV6Y2dWakl2dE55L012bmEyNGNaN0NwUmwwMW5xby8xQ0ZYKzkzNXBFYThQWWFBSkhRb1k4Y21hd29BWWtzVVFScG1DaHR4WkdldlNRdTdsWG1NVUpOOUI0RnRGckhWSVlycm9IaVRDenA5RG5naDR2Y3gwampKVG9QdUUxNlh2aEttb0YrWDJEVTNicmM1dTdNc0dvc05aWTBrRmI0TjhlWXpJenltWERlVnZuaDBhR1JONHUvTWh6YmlTUmkxbEl5NGExb1lhM2FrVEQ4dnRHOEZnN3ZPazBVYlV3UWJPVjF2VEkrZEkxbEU0RzJ2NGVjVUpvWWoxTFBzUW5pdmo2Q1h0Y0EyUmh1WDJEUUo5Zk0vS3p5Zmw5ZzJPcHk1Nlg5Y0g1WVVEa1NQb2RFdzlrZStVd1FUY0QvZUJhcVRyaW5QSE5abCtQeXUzYjNCTk5Ub2JGWmJ0Z2RIMFJ6NEdac2thTjZ4dDdtdktadXBNeGI1cDFHcU9OMU4vWithYVFYcGYyUjZOVnVGemlMWTQydXQwVHVqVXhIa2IrK2ZEQm43T3FId2cyaFlvVDFMVzdrUDJTQXMvSjIrZVpQZzU1NU02U3pvV1BqZTdYbnp0SHFGR3pwTTVXSys3SnFGZWgvay9NVFdCV3JCelp1bGM4N0VBdGtlNUJscDFxd1pLWmI5QmFjNE5YZFBzcnZ4YzM4Y3oyQmhUZnQ0bXd5cDRCZ0Jqdml1WFJWS0g3QkJaeTJlaXlzOEo1UExNbWtzYkZabmIyNlQrUjdtUStycldiQ2VsY3FwRy9FSitML0dTQnYyODhjelVkVnNzbC83UlBuSCtRanJ0RHZvNStmTVJxdm81NVg5bTFGRDhST1h6T1piWGRhb1ROUEh6cHY2eEhUcnRyNWZiTjhZNmo0bnNUSDdVOTNHZFpBODFPaTc0OStwb2xjb0I2VmdEZjFFYlVIS3VobllTWFRsUUVSMytzcFFiYnpKZmxlYzFQT2RjYlBwUE9kRzJsODdwcW11cTRneHlXanJVQmExRzJjM3NBTWdyY0EvZnRyVE1kZldENVh1Q2pQUjRHd014cmFtbm9SM0FJdDdPYlpPTmQzZXV3S0pQbWFhRkhrdnZ3Z0RRQ1F5Zy9LSi8vaThSVXg5VHlkMUg5TWdNbnBFYStTelA2d0g0THp0MjcxMGNEeHpOMFQxWWF1WTdNT1UyVFg4REdMRDVSUmh6K1hQWWZQUmhxYW92dzVTWi95elQ5bmRnODRKUnRiYnVKYjl2REFObjEyRjFmcS82czQ1Z1FPb3E2YW5KbEFtc3pRRDhLUXlFWmdybWhmOTlEY0JuZlV3ZndOYjZaUmhBK0NldzFPUzFoaXhQNzN6Tis4MVUwZ1FlcnNLalMxZE4vMzNXNUNBN0hSb29zT3h6RDB2SzU1Q2k3RGgxWmNYcFF4VkZwc3FpUjc4S2hwc0EvbE9Zb1VmcElhcjF6M0tlWUhNQWZ3eFR3aDRpcHJGN0RGdGZ6eU1DclZwRC9EVllhdlhMc0Qzd0lZRC9CTkVMbjMwOEJQRGZJWHFwWFlhbHNmK0NqMmNMVlVNRGhVSWF0ZWpadkFiYkozUEUxTnpxcGJrRmo4QUI4UC81V0xnL3FGZ1QrS0hpL09ROHo4UUxPajBxVzFMVG5PSnpUbDJKTHkzdDJnSmVFekR6UFJXOGloR21vYjJjMFNUN1dadHk3TXJDSmlJQVRPVXVqZUtxcTlHMURuc3ZSMjNQODNzQzRPZ2ZwZW5yK2pDdjRFNk9HN2xubGpIRjFRaDJKcXpEVTNnaFJyUDJFTThhQXBZNVQzZVdKc2ltTEU2ZXU0bVl2b3FaVDVnV213YnN4dlNGYmlobS81dU1pbzBreG5qMUpGZEhIUm8yQURFSXlmdFJvMWRJd1p6cnU2NERaR3BhMVZ6UDV5NmxIaGF3ay8ycVRZMms0S1orMXZUOE5zcnRwZU5jNDljTllHUHNuT281OHgyTitLbEJCbWd3d2doUVZGdGZ1QU1ZVmtsVEtjOE5UZ055TFRMdlk5MzdTTkNMNTF5b3ZlanRIU0ZHOE5GSVJ1VjRWRmpkU2NwRTB5TFc4bVVVRkZBRnFHazhJZ2pGZmE2QTcxaXVwelBFZ1Y5Zk9hdExTNnQ1U2U2L1V6T25qTWhFa2FrOSt5eVFnRWxic0xrZEF2aXd6Y0RiZGUrVmxuNlROU1VmSlBPc0FOWnA3T1BuWU9CbjIxNGVwZ0JwZW8yY2o1Y1JnY2hIQ2YvaU13a0c4aXpiUXpUUXFSTU5qWjl6Vk5PZWh6U3UvcHRydmE2T042OVp3SndyMXhEMThFT2ZnN2xjSDBEY3BKMTEySGsxN2lKenVXekRmdEtnT2szMi96bzY4RSsvdnAvTUR4RDU0UVlpUHo5QWpEN1Y4a0dVTGFhSUlMV20zK1ZaMnBaVlJNOWRuaVU4ODVSUE5ocUJ5MWhqZGcyZS9hQnREbXJhMFpUYUJQM0l6eW0va09jajAwL3ljOTZ6Vkd0ZG5zVnI2TGpVeHJ2SVp5aTdwZEdUZERKbW10MUt1bkJabCt3L3oycWVCU2RLYjlqR2cyVzhpdzVqWlpyaHhycXdkV2VoUDB0TEdqRnJFTThRMXR6TjFUS2wzRG90WWdwNDVjMXQ1OE1RTWNNYjM5bGpmL1k2UEh1RGdGeGd2MlEvajJEOGZKTGg1NW9SWVI5MkRyRmZCR2NYc0xQMnZ1K05LejZYQi9JZVdGODh5SUN3L2M0Mm1ERXdCYzlwdDFqSTkzU0NxY2lsM25jNmhjNkw1cnF5UTUrRFo5YVpQRG43Z0E0T2lDdndjNjZudnJlYjFxVStsZnFVUG9iTHNQcXdiYUJtcDFySHdndnBWSkZMbTg0OXp6T0pjaUtBck5NdCthYXVOK3BIMUxNb3o5ZldWV2JidnVkQ3BKLy9IaWZQWGNyT0ltTmIrSDd0b3A5cnl1c0Y4dnI1b0VsV1NzZlNvSjh6OElnNk00RmhSdFBUYmo1SGhnL0plY0YxMXphMmtQWE16MWpsUFozc0RzSlAxMkR2NEZqMnhKcDVxY2krWlFUUGMydXNrcW1qdzlpUEpWZTM4TEZUa2ROL1hxbXJEYUZER3lyL1o4SDRDenA3NmdtUW84ckxhekJRWlEwR1VyeWJBbDNqM1IxR3dmYUE1aHFWbnVyM0NrekErdGw1cGpUMThWMkdDVTRQWURWN0NUejNBZnhqMkJqdXdvUzRJMWcwN21QL2ZBdVdqbmtkQnRvc0VGTzh2Z2xqT25mOTh6ZjlzUjhBZUl0UjBBSnd2d2dEd2M2RDltRlJqeS9BR003dndRQ3dlVm9ybGlUZzROUWpwWHV3U0dSR0xXL203b05GZHI0MXVuN3pIVytuQitDZit2WGZoa1VIcjhFQTJjc3dZZmdTckY1c21vYUdhWlN2WVptZUlLYngydmRyZmdpcnpmb0NiSDVmaFVYc1hzbmNUenFDUmF2K0VZQzd1ZlhvNlpGVmVBR2lJUzFFWXB4MXplcFZ5ZDhoRUQzOU54RlRKWWVEMXQ5dkVPaFcyWk4rMzB1SSs1K0dUNEw1UDRXOWo2L0FnTnN4N0YzL0V5eWZOUi9DRkNGRzE2cEJnTXpoUTFoYTczdXdtczhFQ1Zpamg1a0YrdjZzbm4vMmQyRlJ2RndMSDhIV2h3SUY4T2YvTTNqTk1OaDYvd0xNV1dDQXVJZG9qSjBqR2wwWjljQytNdTMwRTcvbTF4R3pIb3o4OTNzQS9rL0VpQURXRFA0VUxOWDhubC96czZmTndlRG5tVllWZnM0TEFENExLcU5IZTlaWVdGYlQvRlE4QXV1VWhCb3dOZ3NLNTlxUmZ0SGdGbW9PWmdDNWNKWWtTbTBmTWNYbVBxS3llZFRRSHpxR0tkQlRJUnB0a2RRb3pCR05qMFUxRW9FZ3RvS3A5MFdwZWg0eERTV05RRXRnYXhtQmUwWXoxVWFnZUgrdnlCemN5MTNURVRBRW9xRm1IUm5IZ1JiQWtIMWhTaTJlcy9wZUEvQmE4NjRZdWNYN2E4ZGZ4cHBwMHhVTUEwdktiZkpzOHJZSnFoNzFTMnYvdEluRzlnUXdRYTZ2eVgzY0k4R0FXM2FzMTFZMjE1WFV5QzcyaGRGdHJZQjd3ek96ZGRveTRJdEdOMVQ2VndQZWhmcGlDZmpDdE1oakFYa0NNSUFZbGEvUnVUMFlBTHp2Y3pRc0xFSlZ6NTQwQ25BbW4zRlBVeDZuSVU4akRzYkpYdEJ5SkFmZS95SHMzT0JlZWxpekYvb3dBTEFIQXplZldZZXowaUtlZVE0OExtN2ZlbGh6M1Rwc2JoaEZjcmVoVGVxUVczNzl2Yk9jb3hXTTJKME14bjR0VTVrK1RnMnJQajZXRnlDd0U5S29GZ21JN3V0cUhWVm5CTURCRDU2blpkVnhhcER5QTJtTFBKYXBGa1BHQmVtZk9sSWN5aDdsZlQyWXZNMzl1b2RvMUU0amI1UkhNdlVxOTVueWQrNy9ISjhONTdxdkpYVXNvV09HWmlmcGNTMEtyMk9tSXZMem84elpSQWNPOXJPTm54Tll6Z0pFeCtEbklXTDhHUHhjTXd2MDVXK1ZGYnZ3YzU1Zms3cnhpendhQUl1bU1mbzliTHZpdkppY3A0Qkh5eGZSSVNpN2xrK1RYSTZiRkxIK2RVaFpYZmRzQVZ3SjBKTDN2ZUNYM0d0NVg4SDVML2x1Q0Z1dmZJY0VMK25vUFczb1UyMmRkQUZ0ZzVPSmZLNEc0blZFdXhFUWd5NG82ejFXV1F2UndaM2dLK2VoajJnTGVDVDhuQTZXZTdEM1B2SHIxR0ZqcmJoOTY2NmZONXZGN1Z1UG5HOHlTeHpQUzdiSHROdk1GS2pnY0I4UlJPSTR4OGs1RlJ4c00zd2VhS2tyNjN1bm56c0RuaVh5Y1lRc0RVM3JEUEhzN3hVdGpteGxkSExwbzhVeDRxUzBBai92RERxWDBUazNsLzVZblpqbThqTkR4cWxFZGYya21RRVFuUWdJT0FJaEUwT3VSRWRmN3VYNU9TdXFEalRjQTNTMDFPeGpkRHdDNGg1QmczN085NjdSOUpUQksrQ1MwNUlUV2QwWUV2MmN0bzdna0ZEY3Z2Vll4bk1GTVgwMmdmT2xkK095QVNCNmJzdVpIQUtianJ1WFJXL1ZlWjgwblI4MTdkQ2hxM2J1T3N3cnorSTJKejExU2ppeHJKM3dsS1VvNDJmUlJ2Y3NVM0tXOElmNys1blZQNTgxNG9ha01UVUlnVEFnSTNpOU9PZ0RJQUI4bTdBVXZyK0lhbjJmSE8zQkkvRE9FdnlWMnFmYVR5cDhyL25mQTY4L3k4WDNsdmZ2UGl6OThvOWhBajhGdC9zd0lQVjcvaG5UREg4R0ZpWDRaUUJmQi9CYnNCcW1yOEZTS1Q4LzN0MFpPcEQ0Q2l3UzlXdG5OWGFoZTdDMHlPOTcvNytKbU01NlZnZitBb0IvTjAzZTBXc0F2b3A2OEJld3RMNy84WGgzNTBzK1hucFR2Z09iMnhHaTk5Ump4SnJEYWVxdU9ZQWZ3T3ExVnRMeU9sMkdBWVV2dzRDOXo4QnFzWDdGUC84bEFMK0tQUGlyWTFxSHBmYjlUZFNrUEpaNnQvek4ycmVzb1VOajM0bkkxMnkyRDhsMWZmNGU3KzdVMVlpQjE0eWRlYis1NzlZQTlLV2U3OEt2bmE5YVk5WWpqRjlCOUFoK0FwdlBhN0IzOHJvLzd3R0FmK3ZmWFFYd0pjVHpodldCQVl0MC8xT1lnd0lCQ0Fxa0ZBSm9uSVEvZCtCOWVBVXhvbmlCbUtacEFWdHpyL2h2QXJQdm9NcHdLQ3dPWUd2aFpVUkZsNmtScVlCQStnTy85NkdQaFU0TGo2Vi9QNFU1R2FTUkFITi96bGNCZkJweExmOGoyUHFkd01EdWozQU9xUll2YUNYcUFVdGdRNVpjcUR4UkZNREhSVDYrQldKRUJ1dCtLcWcwZ3lrUjAyU2NmYmFSZ2pLbHAyTGpkOFh0VzQyQ3VON3Y5NnpKc3pTYWNKWmVoNWgrY2RQN3JtbmdlUDZ3ZmU3cERiOCtuTWYrTENxNk9sWWFua2Z3V21tSUJ0T3NQRVREYXBGUG9jUFBOQXFRTmZDb3lOTUFGektPWk5ZaTAzd3RFT3YvTEpYNktLTUgvQjZrTm1pR3N2VXZsWHoreWNzNUIydjZYUFl6ODA2NVRpaUhzalprVU5ZZ0NyMWZyOFlGcFpEdUNpM0tJOWR2MDdneVJNTkhiazh6N1NCNUNvMEVwNkxBdGhIM1lmSng0emtsUnQrZUdwZ1JEY2h0ejJ4S3A1Wit2cWo1ZkNVU1EyK29XeWhyaWpJRFVCMDdBZGFsK2ZEK2N4N1dmVjl3UDRmOXlMbjE5MG5uQ2hxcXVCN1hFUTFFekZJd2hLY2E5V3Q1bG5DLzg1M3AvTStMMjdjbWhkV2wzUWV3NzBBQVU0eU85Y3p6TWRBWmJ3UEFGVDlMcHpBbnRna2FJbERrVEt4Tjk4cHpPL2ZkVTBiTXFuSWZKby9WMFJ3bTMya3E1RHJpdTNrTWM4cnBDcnF1Vk5zcVorQnNvaTc5OFBkRy9qR0RwUnJmQkhDcHJOYkZHOE1jQkI0ak9sYjJZT2M0YTNDdkozdHRDN0UrNjREN1FnQkVRTkpCS3gveE5rTmtIcUx4OXFBUXh4TnY2d3JzWFkwQVhLWngyL2ZvRkxFVUUvVUwxa2k4Qk5zTHl2OElYQUcyM21ta3ZlVFBlUTZ4ZmpKbGlGeHQ3RDZpcktEUmtFQVY2T1R2UlJucm1CT3cxc2pmQVdJTmV5VTFadk85TGZHK01rWTJzbFJWM1pyTzh2T01iRWQrSGdBMTZYOVhmazQreUdnMXprZG8xNit2azVrSUhQT25kczE3bjV2NGM0N215R1R6a0dmVEJqU0g4WnUreWcxbmZCN3VvWm8ybDNwa1AvZituTGduQ2I1ditGdzhnYS81dWpQSitWcGIrUTUxNk9DY3RXWDl5VHJNeVdkY0MxdkorVUl3T3ppUStPZVVmNWtLdVZLblVmcS9oaGo0Y1JVUmxEbUN5L0Z5NzhUbmg1bTN1TjlIOHRtdzNMN3hnbjgya1RYT0Vsbzh2MWdUbmV0OGhpby9QeWh1Mzlyek00ODFtWE5SZVpSWFJxN1BzSytzRjl6R3M5aWZMRDBqdkJ5SU5sZksxazAwbzd6VWRKSHNuK0FzMTdVelo4elBPNEhFQXVneHJmNndsTnErL3R3SlRHNWs4QWY1K1pBNlZLTFQwMm1DTWl6NU9aMWVnS3FEVk1yUHFVTndEd2JRdVhDSE03K3VqK2hzTm9UekZlOFhNNWx4ZmFkelBZS2RFNnFmMDJHTTlnanE1d3grdVlUSXl5bW5yeUZERGZwNTZxZ0ptTTdFK1dPV2cyQTNRY1JVY3NUck50THhTRi80MlNFaUhwSHJjNnVNS1hOQ1dXSUROdTl0dUUyT0FpLzJ0dFdHRTJTQ0doN1ZlWjhsTnA3TzFESVhBWGhPNUoxbnprYjN0RlB1UFRTOG0yY3lTT2FUUUFUbDZQMXpEZEVvU01FZEFNYWFodFNqQjErRUNWYWZoU25iT2NDT3RKOUxpWHphSkZHcit2L1UrMGFCZXNidkFHQzh1L05UbUdML0JOSDRDc1FVTXdzWU1FeGdkRGJlM1puRG9udy82KzI5anNpMExzSEFHODdyekovOVZSaFlYa2Nmd0tJVFQwSnZ3U0lIMTJIUmhKK0RHWURlUm92bkRpa0JBM3V3ZDB4RnU0NmhrWDRId1A4Q0c4c2ZJQXIzZ00zTFZWaTZaakw1ZTRpTWV0TS9vd0QzUXhnNGxoNGFQVlRUQ1BkaElQeDlHRmhkUjhxY0g4UGV5Um9NaFB0Snk3Z0MrZnh3N1p5S1liZExpbDllTTdwK2N6N2UzZW5zZmV6WHQ2WnhieUxaVXpRR0hBQzRON3ArODhpLyt3alJxNVhyWlRhNmZ2T3UzNzhKQTJEZmdnbW03eU91cCsvRDN2Y2N0amF1d3Q3SlYyRnIrRzBZa05xREFhUy80YzhpU1BBK2dQOEpzcTg5Q3ZwVGZ0MUgvcXkvaEsyUnYrZGpVWSs0QlN4cWZNUDd5QlJ4RzZpbVVpTll6TE9SUmhmOVBZY3BkaC9BakpHOEY2aldyZnVDOStVSUJoYmZSNnh6L0NIc3pMMWdpazhYZFJaVW5uV0J4b1ZrR2tsWTg2WlhXbjIxckZHSDk0akJWWTFER21WVFNRVUVBVzM4bVFSVGdoRkQycVloakdudTZSM1AvY205UnUvZnBlaGc4ZXdOYVlMOWZ0M242ZlZIWmRYb3lmMU9XaFFXbWFSQVRrclpWRGV1SUROU1FvRXlHcUNvZERObEpJM2RBL21NYmRIUVJ5Y1dTSi9UbExGVDl5cHVpc1pjaDcyWEE1azNndEpoYm1XOXFLS1pXeDlaNDJPNUhIVTB6M3pmUzc1blRWbldtS1M4dFlBWStkam56SHBOYTFNMmt2ZWo3dXRjamRVSzVmcHdWa1NGdjBVaHB0TW45dzNmWlJveDN6bTl1UlAzSHR2dElScDBsaUtNamtsOC8wQVZKRW5QZ0FXZnliRmszZ1BsUXZZVmlFQkNuYXhGV1lEdFVFNmdZWWZmYzgzU2VBYkUxS2Y4YmdJM0VxZDk0Lyt5bjdubjkvejdFUFdHYURUVytlVjV1Vmx1MzZpTmpIT0FlU2xkc29OMGpJWTdnT2xKNTA1bGRQcG9qTjd3dGZXZ1E1TXM3VEtHR1IvZkxHN2ZlcWVtelVscHRYbGIxNjYrdjFYMytobWREU0hkSUtKRDF4Z200MUsvcjBSVzBvRHJjMDZkZGdGUDRlaDdqaEY0NGF3dFk5VEdXaG1qZjVuK2xObHZhQWZnbW1XdFdhWldKQzliYzM1Q0hieVBDSG9FbWNEL1ovMXNaaVZqSFhPVnZTSDNITUg0T1FGTkdvY0oyTEIwRHZua0lOMlhibmcvUkpSbDlMc2prVWQwanhQUTRsbEYzajFHNU9lc3o4eSs3b204RVNMY2dCamw1OWVIYUNvMEcwNDMvZDY5aEo5dmx0czNRaDFKNGVjOHMraFExYnEyNWJ4U1o3UmdmNUR2Z1pncFlnNS81d2svRDQ0TENWL0s4VkptZ2VwRXZtYnJ2cTdVZnE3WjEwc3l6bWxSd2dQNjhJd3FwVVF0WjRpMWZybnV1STYwZnEybUt1MUtYR05xRzJNZDVGa3FHeVFPQUYzbWlIdVM3NXZQQkNLdjVCZ0l5dE4rTUJEWnVTZDdrYnd3QllzQ09LZ0FuYThEZFR6Y1I3UVh2b0M0LzlhbFQ0enNQWUtkcHdTOTdxTW15NG53Yys1L1poQmhwRGY3TlBmOWw3UGJrYWZYQXFJQ3dxWFBKd0EyTExkdlZESU9uQ2Y1bXE1enZnams3N05MblY2ZXNYeWZsNHZidDdLeWl1ejdWbjArYys2dkNtS2ROdldBVUFlZHo1bjZ2cVp6ejB6Mmdlb0MzSTg4QXlheUZsV0dacllENnJqQjJSSlJycVhjR1hpVnIxY0N3V3d6WkxQeDcvWDg0aDZkU2ovNWZxanZ6aEQxOHpvbnpobUFneklDNE53ZmZCYjV5eUZpRm9FYzFlbm4wM0w3eGl5WnF3bE1MbFpBbFBZRXBvRWVPajlUL1h6c2ZkVDNRSDVPcDJ6bDU1VmE1eGxhaDczYnREUUdvM3dyYTFkNCtrcmdiNkpINW5US0hod1U5ekh3bmFWN3JDSXJOVkdMdmwxN1Q1ZlBuM1g3M05OT0hlWTNPRlhJdGR5ckYzUk9SR1hrRFZoRTVPc3cwSEFMSmt4K0Y4QVBGRHp5aU1YbllDRGFlN0EwdW8zZzdua0NHZW16UE9KeE5ycCs4NUZIY1M3MG10SDFtd2VqNnpjL0dGMi91VGU2ZnZQUTY4TFNhNW1ncnRZVkJVeUEraERBWDhGcTYvNFBBUDVIQUxzQS9qbXNodTQ5eEpRUmx4Q0JyeHpkZ3dGZEo2RkR4SlExVkFTMllPRFNlNmhKZFp5U0F1aXdNZjhRd0YvRHdMazJtc0ZBT3NBRTZMSDg5R0JnTkJYRHR3QjhBelpYZndNRCtmNEtOdWN2dzR3NFA0QkZiV2JUdUFrTllldTJpU2lNUEliTjkwZXdTTXZYZlQydlRLZXhyby9UeHFyM25FS2FhaFhvNXJDNjRFZnNDL2NZYkQ3L0Z2YStLM3NNRmczOEI3Q1U0RCtGUmY3K0ZNQmozNWR6LzNrQVd3Ly9NMncvZlFPMi91N0IwaU5mZ2EzcmhmNzRIcDk3cFBTTHNJamp5ekRsN1RKc1QvQTkwM3U0NzMybHN2Y2NiQjI5aGlnZ3FhRlc2OUZzd2NEcWtiZTlqN2ltLzE4WTRLMmVlelJ5c1owclBxOEhpUFhYUHZEN0xzRGZwNWphUEM2ZlpWSkFOalY0d3ZkTXpuTzByRWJlTGdxTFNOVDc1LzVaaUJwTWdGUlZRaGwxWDRsdzlUNm9jVW1mUWFCS3ZjVW5SVTBhMnpKRzRqQktnZ2JieGpwN05lRHZIQkZzQytuYW10WkpDanlLQVoxcER6VU5GaFZZcHJQanVUVXVhdEk0aWJIcklIMFgzbmRHRTdiUkVTemRuQnFUQnZLanoxeTRRWWtwUEpjVTExUWhsZitaV1lXOGcrTWMrTHBpblNXTnhsTG5BUnJ4cDBocWVpVk9CaW1kR0tTaE1hL2xmVmVNa2VkQjBxODZvOGNjN2pXUG1yU1ozTGMxN2ZmOTNhVFBKT2c2S1c3Zk9pd3M4b1dwdGhmSnRkbS9jOEM4N0NrRmJZRElsd25lcUxFSzhNaHhOQnNmTkNMbk1MZXZIREJpTkk1R3lGR1JKVURJaUQ0RkNzajNPVTdxRmlIQ1RZM0RNdGFSRzNQb0NETHg4ZlRsdktBaGFRKzJyN1YyNlNWRWNQckYwcU9zL1A2dERyeU0zeXQ0ZDY3ay9PWjVtSU55a3dGdjZWeHRJSllkZWQ1L04wWU5GZTNSY2JtK1pIbkFPY3NQQklCNU52UGNmWXdJem02bGU5L1gzRFhFOU1UN1JkVmhoaEhwaDRqcm5BN2xQQk80dmdtc2hDZ2xmNTRhZEtlbzFwb25ENlJqQXAyMEh5VjhnelNBeWZtVXBabUdkYi91L0VKMHFsS25yeFM0MVVqb1liSytna05ZbVdUWmtMVkNweXZ1ZllKS2MxUnJKUjhnUnZwWHFJaVJqVStTOGFoekNhT2cyb2k4V2RjeXo4OGNQNTk0M3lwcHNITnJPSGt2SEovT2ZROTJ6dkdNVmlPOVhnTkVSMXZLSCttemwvWjVjYnlvb1p5VDFBRDVURENCQk1BN2MzSWVyTFc4cjlXY2MxUFlHVDJCOFlEY1hOUkdodGJ3YzVXTEg4TDIzMk0vUzBKQVJXblJjSG92KzhmSTkwcDBleGt6dVZDVzVqN3BJVWJzSFNGRzVuT3V1V2ZaVmhhMGdmSHlSN0F6NmhFU3dOdjd3c0FEcHJtbGZNSUFCV1lIZUlJSW1sRHUySVRacVM0aDFsZFhBM1lkSDFyM2VXSkdBd0pGcVJ3TDMzdHArbm1tZUY4dnQyK01ramxkUmI1c2pCQStTL0orWG9KSGZiZGMyNVZYTHJ5OVFXbE9hNDMzY1UrMU5acUFhblg4L0R6bCt1Q2tXRlN6d05EeEp4dmg2bnVOZTJ3QjErbEVubVpVL1NGaXhocnFYZXFNd2JOWGRYajJRUU4rZ0dwOVgvSVg3alBhaGZkcitEa0JVdXJuN0hkakRWczZGcUI2WHVpOFRSQ3prUTJTOTVuVlIzeHM1Qk9jUTlyeUtyWFFFWFZTOHRrNi9Yd0I0NnNIaVo2czkzZmg1Nkhja1BTZHVubU9SeklEeW41T1A2OGo0YTJWdVpjOVFUMkc3eW5ITDN0d3dLK0duOVk5OThUVVpZOStISGE5Tmp2UnMwbzZMdjR0dXEwNlFYNmk3YWxQTzFISStpa3NPblVEQnZROWdodlNGSWh3Y0lVMXBZQ1lCblV4M3QzcGQ0bGtmQmFJVVo0T2h2YmhndHA0ZDJlTXFEQU9ZQ0F3RlZRRmlGUkJtY0hBb2kwWW1QbHBlZFJmdzBDek4yRDFTazlDRXhpQTlBRDIvbnF3MU04ZndsTGhib3gzZHg2MTFHcW1rTERuZjM4V0Jycjljb2ZuTTlKNERjQ1YwZldiS1dqN0hvRDNQQnFVUnJJZURJaDkwWi9MaUVzNkdQd2ZpRWE5RFJpNC9GbVlvd0tONHZmOS9qYWlVUURlL2l1SVRQYnFlSGVuSEYyLzJWano3dWVZNklVNkFMRG1nTzRTK2RxcU03Yk1ZR2NGYTYwTkFQUnk2OUUvR3dNWSt6b2NvdW9GeXYzMUxjUzFSTG9NU3cxK0NURzlLZXZ4UGtCVTdtWXd4WktLRUZPY2Z4cnhmS1BSSmlpemlCN3ByQS84a24vM2h6QlFld3JKbUREZTNibVBDT293aW9icjdDTnZuK2tLSDhHeUpYd2l6dEZQR29tSDZpY1duQytTYUpiMHU5SThjK3VFNlFIeUViZDF3bjd3bmkzTTQ1aDhWVUdrbkdLakVRRktGZU5MQndWbkFZUlVWaWt3WGVzMW1oZ2dVMjltUmgweHRXNEEwT1IrR25DQ01pc0tOOXRVUUp4S1p2RFlwbmVzdDdXVWlyZXNydytweG9OV0JUQm5QSGNnb0RhalNGR3Q5OFIrMEJzNiswenYvNlNzMW9aQjhqZEpvd0g1TEthTG5QbXphQlJwWE5PblJGeTNBMytuT1NBMXJMTXo3RWRLTks3U2FXTU94SHJFeWJ0WTg3MDlnOVM3YnpycmlvWUlxaHFndkk4WTVkOTBQWUgvTklwR0FRL3VQNjZGWG1HUm11ck1BYm1HZkRzOVU0S3hxR2l1TDhmblRBY3Y1Z0FBSUFCSlJFRlU2MzZnd1N0RUdzcjZQVUxWRUtjT2REd2ZlTllGWTVXY2NScjVwTUFSMks2dnFjclpndVhJTG9KTlFEWEs0eFZFdWFlMi9pMWkrc0RhNk9FeTcrbC9tc1NVdVF0WWYwOHNweGVXcmVFdG1DNHdMbXFpaFk3UjdpTDNOMG5XeDBtZE1yTkVJRkxPYlkwbVRmdktyQmJycFRoMStaN2pHajNVdVNtcWtXWGtaeHBKeTcxSEp3aDlkMm1hZW9LOGpLYlRQakphQ0pCc0ZXcE1Tb2FqRHFGck1BTzNaZ2RCOG16TkFKSHV6WjczaDFsR0NOZ3dHbWxQd0ZHVVZxOTF2ZHkrOFlqekxzNFo2Z1RDODVnNnlGRnlGblhoNStuWjJZTTV2blVDYzNKbm5LOERQU2RxN3hGQU1FVHIxdHl6Z0tVUERZWmZ4UEZ6YkNtUDEyZ3B5aGRaZnA3akljZWhtak9MSU1xMWN2dkdnNXpNSXZ6OFhLaU1VVzNrR1JzK0I0UENzNzRVWHZmVTUveXlmeitHblptSHFJbEtKVFh3YzVVWmRMN1cvSGs4TC9RYUJlelhZWHZoc055K2NZRHFlMWZBaG1VVm1MS2VBUTBMeEtnNkFzQ0hQcmEweG5mZm4xVmJNN09NVVdwcnFEcithTWFBalNKR1hLL0I5UE0rSXZBVFV1R2ltaEtiQVJpek1rWmNic0xsVlZSTHo2Z2poL2FoaVlkUTVxZ1l6VXRMNno4bzI2TjY1MWgyNkt6UU9mRHpOVlJ0TENlT1FpWlE3K0F2SFp4T2xacGsydE4rVnRLKzhxNm0vUnVpZHN1cTg0cXVtVW9kWlo3VC9xL3FwMEdIUll4NFZmMGM4SXdpU1Y4NUg5d2ZTbXhMNWZWV2Z1N3RCdm16UVQ5WFFGdUpVYlhNQ3RLRDJRa0pSbE5Hb2k2K0FlTTV1YXhYMnFiaUlETTRQMC8wOHpWa1pHY1pzMzRlNVBNaVh5WnFpWEw3dUpEc0pEWDNMR1cyb0g3WVFkOUw1NWJ2RktnK3I2L3RKZk95OVA3TzBxWkcyMHE1ZldOUk5KK05PcFlMcXFHNi9aY1F3VjBnN2hXVmhaVm5RdHE3bVA5ekpCN3krNGlwZVpzVTFBVU1USm5EUUxkTGlQVTR6OFViOHB4cEFBTkFQd3VMOW5zZUJqNytLaXhkTTQwMVc3Qkl3eS9Ed0ZKR0thYjFnMTVDbFQ3blB3OVFVNWVnaHQ2SGdjbU1wSHdDaXh4a0tsMGdBcXdMUkNXOGtUeUtrbDcrTkQ1MU1ZeDhBOEEvZzBXRGZ3dXh2bXVPRG1HT0Jab0c3ejVzRGg3Q1FMRDMvRGRRallSNjVQMXBHc3VQL1A1M1VSVXMxY09TZGFGZlJCVG9QNWRFUDU4YW5WVzc1MEh1OU1INndheTNkWncyL2gxNG1pVFdta1kzRDFSVnloNGpLbHkvRCtEL0FmQk5TZWRPdy9BWTVsenhsN0FhMk4rRzdaZjdpQUlmbFZSRzVtb0tSNjRiS29xcTVLa2cvaU1BZndMTGxQQU9ESEErVEFEY0RkaTVjUm0ydnAvQTF1YnZlUi92K1A4L2dVVkRYNEMvRjNSdXRLb0hJbzJRcFVVTDlCTmhNQmVwa1NNYWZIaitxMEdaeXVZQ25uclIyMUxGRTRpMUI5bXZhVkZOSGRoTCsxaWF4NjlHSUxGMlYxTmthdDBjRUJpWm9CcnRtbzQ1MXc2amVhblFCaWN6LzV4blVUaHJpdHUzamxKbENqR0s0RklwMFJkdWNFdHJxZ0V4SThHSmhleWllMzFyMW1vRS9IMjJyRGxHRGxFWkp2SGNac2FHUTFSVFg4OEtpelRsT2QzYU41LzNFSlYyQW1LTnd6bWFJeFRQQlBUSmtTdmJkSTRLNlYvUlBpOGJpT3R1bysxc3lCZ2dnbE5IaHRTSTNUVG53ZmlSZVRmcUZNRjF3bXNaWWFBR3I2RFU2NzR1dDVkcVNXY05hd0pzRGJFTVlGWHVTNERpa0w0T2NUNHBuL0IvMWg3a21xZmhMUzFGdzNGRDd1ZVlhZzIrM25jQzBSc3crWW1wZTVreXVqRk51Ty96MnJUTFpZeUthSTNtT1FFUkVGaWd1YTV2MWlEV2NPMml1SDNyd1dtQnZ4MmZXUXVhblJKdElLYjVKUmhjU1oyYlhNOG96VFhFZXZhTVFIa0FNNnFUbDlicCtIMUVmWmQ3a0RLemdrRjlPZi9wWE1uOXV3R3BnVnRZNW81OXhLd1BHMjZZWlhZUWxOczNOcmptZkl3UC9CNlZLVWgxeGxEeUMzVWtlb3hZKzFXZHNpcEdUU0h5SmhxTEdlRVdTa3drY3pVdExETkM2b2pDbXNvakJlUjkzamZQbUo4MzFYTlhJbUMvZ0wvUGx1dDFIWkFJRUZBUFBKUy90VC9LejFQd1BnZkdESEU2NTlBR1BDSWI5aDcxR1JxMWNpN3BjOHZvY01qMHg1UjltblJvOHRnWEVPZnUrVFpaSndGVDZaUzRKQWRJbjlTNXVjSkw1RzltMXBqQUFHc0ZEQmkxeURyRlhBTk04Y3hJd2I3OHpHQWdTVWpKWDhaYTU1cDlZSW5LV0lOMEN4WWxuYzRmc3hib0hxUWRqOUhWdEVtUXR6T0RHTXVYaldIclo0Z0kvaXBZREVpR0cxUUIzN1l5QTdUckVjaGR5THRndTdWVTNLN1VTYTZqRWF4MitsYkxkY2Nsem1zUHpiYkNsWUVoUHpPNnBJdytGWEorZnBaT25aUTlGUXhPK1liMmg3eVhhNnN2bng4bXpqeE4rbmthK1F0a2dENDVEMU81bjZtanljKzUvd2txVS80T0paTktqOHFWTVI3NFBibnlQWFg4bkh0c2pNaGp1Ry9wUEFJc3k5ZEtNeXpyNXl5RFFyMWZTeU5VK0xuc3lTdndyQ1NKZnI0RzA5bFRQa1ZkN1R6MWM5Vi91K2pCT2RrS2lHY2hTd0lzbldNMVRrUzE1SEppWTJhdGprUzljNzFNTWx6aytuZWUxR1pySXFuY1VTWTF2OCtiMnZwTTI0UE1aM2gvc2ovNWVldTdQWVgzZjBFMXhKUk5CT01ZcmFhcEJnTnpjNkRsYUx5N3N3WTdZTGRnQU9ucmlEVjJuM2thNys0TVllRGdwMkcxT3RkaHpPaFRNQ0NZUXNzVWx0cjJKVVRCOHlFc3N1OHFiSTZ1K1gzN3NKUXhTcXhaeE5xb0d3RGVoQW50ZGZTK1gzL1BuL0VJcHFTOEN1RHIzZ2E5UGpkZ2d2VXJNS1gySTBSZ2xjRGNOZGg3VHpjMERlNFRXSjNXMTcyOU85N215N0MxOFYxWXlsNzRPSi9Bb28wbmRkSEc4am5UN2o0SG0rUFB3UmptSGUvVCs3QjNjTTJ2WHdmd1k4UjMwa2MxK3BlUm1mUXlZN3RBTkRZTVVmWGtldDUvdmd6Z3cvSHV6Z01ZU0hscW5palBhanBmQVZUVE0yQ1ZOdWhwQzlnODN3ZXc2QXAwZWszZlE5aWErQmV3MU00L0F2Q2VBOUwzazF1T0FId1BWU2NXR3VobnNQVXpnKzI5THlBcXNmeWVoaGlneXFnVVdGakE5dndkV05yeWlqSEF4d3kvam1zWHNMVk00ZnA3TUdIeUVlek1lT2pwNXkvb2dzNk4yb1RQTW9ra0xXTXFWY0FpVDhKMzdpSEtsSDRFY0lGbFpVQWpRUmFKQWsyUFpFWmhrTmZTNkJKcUNpRnY1RkdoT05RaTluNk12RzExWXVraGVobXY0dldlUnRhcEJ6R05XbG5qZ0hqU01sS0o5YjVvTEtkeGlZWTFSakpwWFo5VUtPYXptWjZLRVVnOVdPUUZoZTJqRmNaNEdzUXpqVXFZcm9QVVdZRHZuRVlNb042VHZOWmdYWFNNYmthc0w4a0kwZU1TTStrczRHbkxjMzA3cjNubnV5NHRhcXF5UnhybTdNalhUcWpwVjNwZHFUSkdIODNjdTd5MmxuRVJveERTUHFWbEpHajBVYS93SHVJZVpIUWQwNnZPMkQ0OHNrejZGa0NHSWtiRmFpVDVUT1pEdlpDSDh2Y3MweCtnYWdoTGpXMUhmZy9sQzY3dlVGUFZRU3VlVmR6TGxLbTROL2I5bVZvakZON1d3TjhOSFVrSk5vMUtpekE2WkgvMVhkRmhwTFNJcXhsaXFtLzQvUEQ4ZW5UQ2Rha2dPL2ZCRXRXdEdRSFlnZm9hdTlSWk5zNFlQUDBra0ViU1ZzNUEzMGNicGRWNlZUNDZRWFJtUGhBbmlRbGkvZDhKektBN2d2R1ExTG1XUm4wNk0zQk5xS0YwQUpNWlpzSWpsVC9rem5UcWVRdVliZ2dBKzc3bm1FMUtVeW4zRUdzTEF4M3FObnQvMkdlQ3ZITVkzNlJqQnUwa3VRaGE4dGV0Y3Z2R0hxcUdjdFkyMWRTY1BGOXowYjRWb0VqNG9rWkVNM0s3ajVhYTJHZEF0QTBCTWJzRXNCeUpxUUNYem44S0pvVFBXL2g1RjZMelZlMDUxRWJTYjU2UHc1d01YSWd6VlJNL1BDbVZNY0tRV1IvMmt1ZlZsZG00Nzd4bkRaRy83QUhWTEJPKzlyUFpZdndlcHBaTm82T1kxcDI2TWZjcFlEVzV1VFlZZGZ6RXh6TW90MjljUVl5OG5SWWVDZWpQMjRDQUxNNURDUUNQRUROK0Raei9VVjVnOWpyK0hlU0hCQ1NsWFV4QlU5Smp2L2FLejl0ejN1L0gwaGNnT212T0VDTUxReVFoWXEzMDFNRzFEK1BuVStmQmRMU1p3Zmc1eTJSVVNOODM1eVBSdXhaK1Z0ZG1NZWxLTWs4OG40L1Rodkx6M0w1Z0ZQVHc0d0JkbmpFS3VsQTZWOXpIdm01VS8xT2VxK2ZEM1BrbStRdkJ0VFJyVjhWeEVwR2ZBL0VzVUpsNGdTcmZDdXMrOC81VkxxY2RsdWNGSGYzMmsydjVQV3JhckpEb0FPSGNvazdobnhPSTVsbVMzai8xTmJ3T0w1ZFF4b3dURTJtWHppL012S0RSdmpwSEMxU3pZZkNzM0hDZGhQeTg5ekhJdDF4ZlBkaDZDSHd0bmVlRU41SXFUZ0VLZ2pjOXRDTy9WRWZoazh4THlINkZsdHJwVHl2SmZLbStHK1NjczVSQjJpaDlkcVlmWVUzcDk4NUxhL3N0KzRWdDFENi81cmtYMUVLOThlN09PaXo5OENFc29wUlJNWDBBMDF6OVVML25lZGdDdkFvRDRlN0E2bi9Pa3JUUlBXQVpPSEtRaE14cThUU0JaT1Bkbld1d0tGOUcyTHlBS3Bpb2RNOS83OEZxMXY0TUVTeitFZ3dvK2g0c3pkcHZZamxkOFgwQS81di8vUUtBcjhCU1F0ZlJUd0g4c2Y4OWdvRlYxMkJBL0V1STN0eWtKNGlwbGY4NUxFMzBGdUloL2tWWTlPSWpST1k5aDczZlYzd2MxMkJDOENVWTJFdlFtZlhGSHZ1emZ4SG1oZjB1YkMzVWdzQUE0T21nZndjV1laM083U0dBL3h1MnZuNEpFYWk3akdiNlBnd2czSWVCNmIrTW1Mb0hpT0JDamdobS94aTJqcGVFVTEvN1g0Q05lYy9iMi9PbzFzNzBTVXFaWGtlK3gxK0ZNYWxObUVmY3p4QlRJUTFZUzdoamV4U2VqakxuaVhvODM0V2NRLzdPV0Uvc05jUzE5QVVBditaTjBNaEZoWnVLNUlld3ZVQUhEVElrS3FuM1lJNEs5RFI4N1BmUXFQWVBZZnZrcW8vOUI0aGVrR3V3dmZRaExQWHpVM01HWHREUEZ6VVk2SmVBMFNaaFU0UTJLa2prSjJwMHBxSWFqSHR1K0tHeGhBcmtvWHlmZXU0UzdDSFlxUVpjS2lrYXdhOS9qMm40Z3UxQkFvYXFMTGFOVTZPaEtpQzJnTHNoVFdUbWZqNTdxcUNaR0t2WTMzNXgrOWJZeDBrajlCU1J6eE53cDlHSjlkTjRUdEV3RlFDOFRCL09IQlF1WTZTZ1JrcFBCQXpmUURUZ01ZcUxGRUF6djM0ZFpnaVl0aWsrYXRCSzF6QmlpczRGOHRHZFhjZDJHZFc2OHZPNjl5N1A3aDMzZWFkRk1nZXpJcVl6WFJkZ2t3NktHcTNQOTBlUXM2djNzc3FrOUJidnlkb1BpbDdHOEVBUTlrajJab2owOTh1VzBsc0tPTnlEN2FPY3c0SDJnMjFPRWRjR0RSQ1QxRGdqeG5tMnMwQW1IYXVmRmFuekEvczI5TFlKd05NcElXUmpLaXoxclFMQUM5aGVZUVFOalZXY3h3RU0yRDN6ZE9ObGpMcGlmNC9TZWZMcmx2YXB2NFBuSUU0dU1MRGlFK0ZJZkJMaTJqcnVPeXlyemtMOGpCRnBhU1RRb01nNGRpZ2ZnNjJyUzRqN1liK1FGS3Rjbjg2cmVDM2xhTzRUUnZRQVVRZlZhR0YrdmdhVHBRZlN6Z0dpN25lSXFqTUZNMEl3aXJsU2U3YUlEaTFaSjY4eVJ2Z0VVSzJ3Q09Rd1AvN3NXVkVUTGU1enkyY1RKT1c1d3YzUGVkaEg1TjJNbXBuSU9iY29xczRsbGJTYmlBYnNsSi96T1lkZHp1V1RrS3lOQ3JncjV6TlQrUklFQitMNWxQTHpJVnlHNmlCYkFoRzgxTFZLZ0JEZWRtMzl4UTdqdWdwYmZ3dkU5T08xWnhLQnZpYmovVWtOdEYzdTk3Ni9BSFBpMlBmUFhvWFo1aFl3Tzg0alZHc3ZFNGpVTENIYUhvQ2xxRU5tVUNPZm9qTVRnVmV1OCtBNG5keC9CVGF2OTBXKzUzN2dtWkhqdDF4UDhQdjNpcW84d09DVnZ2QlRwaGkrakFnQ0RHRG5TWnFDbmZ1UG1RWW9WMWYydk9zcTEveDdub0VFYzlmOG5vbWNHNXdIT216Um9hdUhDQ2hSTm1hcWF3V25lK2ZGRTRXZjAwbHZrajY3UVZmc0lZNFgvdnZnZ3ArZlhPWW5qMDQvUStRREt0dldsZjhKVWNTd2Q4TTF5UDJtTXNHNjk1Zk9UWnRZam1DZkNtK2xmTTkxenZWQi9zVlNKdHhqalBBSFJHOUNQTHNWRks0NDlNcVprUVYra3Y0Q1NkcHI0Uld6b2laYVhQaGJjSHIxK1ppWDBTR1c4dm0rN0JzNnJreEZad2Y4clBKOXord25QRFBvSkZaeFZxTStjaHcrZGh3cW95TXJzT3pRcGRtU2N2MEp0cE02T2F2aHVYWG5DWFVhNEFRMkNtK0graGJYVitNKy9EZ0IxYVoraUk2S0hyRDRiYmVCb01wdnp4VU1yVHZiVks4L3kvbCtXdDdWczBoVVdwNzMzeS9EVXZnU0xNblM2UHJOby9IdURnWEpEMkNBMzc4TG9JQkZDUDhFZGtnODh1OG00OTJkdzlIMW00ZUFBVG1qNnpmbjQ5MmRNeHRZRXdtUXBLa1BXR09MaHRlUFlJQU5sZG12SXc4QWZ3L1JRUFlSb2pIb0xreUowRFEyZXpDQXRBZmc4M0kvWU1BUnZmV3Z3Y0F5S3JwcWJQNEZXRHJkZTRoTTh4V1k0RVdsVlkxdFZKcDdNSUNXZmFIZ1NXQ1hxWlY1d0x3QVd4TVB2QjhqMkx0OEIxSFFmUmxSV0tWbjVXVVlvTHVBUmRUdWEyMWRCd1Y3UHNaL2pBaklwWFFId0EvOTcrL0R3UFRQb3g0QVBvS2xmdjRiR0VoT0k4QkxxTlpkem9HL05IQjhHVGFYM3dEd2NMeTdNME44SjJUY240WkZRNC85ZWRjQS9IaTh1M08zS3dqc2MzRG1CeFpCMGVOR2x2bytQVWsvQ2FyU29QTWFvb1BFQU1BYjQ5MmR0MGZYYjg0NEowM1A4KzhxNTVMdlpUWEMwcEZCU1ZObDdjR2NNTjZFN1NYMmt4NVZmSWMwdXJ6aS8xTWhwRURDYXkvQkhEWjRmdndWTEEzMGU5NjNmK3ZYYi9rMTl4Q2RKL1pnNThRRitIdEJKNkt5M2V2NldKUVQzSnJhOSs4V1pZd0VKcUE3S3JkdjdCUHdvMUpWeGdnd1RRbkpxQU45ZGdCeE13WUZSa2RRV1dVRW9LWmVDd0F2UEhyQSs2SjE1ZEt4OVFWRVNtc0VFMlFPeW02aVhGTVJycHNuZWhWdmxPYTlUK01VRFhKQTFZQ3ZZSlNlUXp6L2FPaGlLa3FOWXFHc2svSUJCWkRQMUVqajh6dVcvbW9rdEJyY09CZEFsQzNDMnZiNzZER3RnSGxxcE9UN0QybDFTNnVQdHBEN1VrQ3VUVWxoVkhmNlhpdnJBR0tzcUpzTG5CTC9yek9DZENHWmc3NG9VUk1DN0toR3A1Ty9hdm8rUGorazdHNEFyTGlmSzQ2ZmFtVDI3L3FsUnpSSW4xaXFJYTBYRjZMSmNvWnJNZFlvY0IzR2ptV3ZjajBudUgrcFVOZGxHK0M4QkpsT3dlVWkxdTNVZlR5Vit4YytabzE4NXoxcmNpMTFFNTZENmhuTk0xVFBEcDFYemdzTmF0bElvMVdwdEJTUlBGUFZtSmNqamxIQnFVM0VmUmRBeG5LNTl2UFBJejBQQUtWRmUrMjNYWnlocGZmdlJza242Vm1SQW0vSm1hTE9JTHEydGtxTHBwbkM5djI0dERTc0JGM1VLRVVEYmpCT2xWWTNsSURQV0o3TnRYUUZwbnR5WGZQY1VYN09OY1B6aXJYNGVGMDRqOFNnTy9MemJKenNnUUhpMlRLUlBjenpROU0rTGxFUm8vcTJFTk5IRTJqaW5JMkY1d0dSdjFFT0N1ZUlHUHoxck9EejExR05uaVlwUHovVE5LaGNHNG1SaitlNVp0bEs1U0RPcTdZMVZUNUFPYXJHQUUxK25rWkM2ak1vNHpWR2Y1ZmlTS2JqOHJYSjlocmxPTDluYVYya1J0RVZqT0ZyeUdTT1dZRy9UMkV5SlIxeDdzUE9ra09ZclljOFloT1Jyd0t4bnU4UXNjd2J6K3QwRGltbkVmUmRSN1MzNkJsQkEvNEJUUDRpTUxVSGMveTVpbW9HTDU0UktXQk1lWnUyaENIa3pQRDVtV001blREN0NjU3pnYmErSEtDd2hzaHo2V1RCOWFnT0YveWU2NUUyQi9JeTFrVG5OYXJMOERmblhtVUhBaWprOGNGWk1tZmtsbm5wbXU2MWtjcm9iQUpVSFU0cVZNVG81aUdxODhqTWFUTzVmNk9VQ05XZlk5cUN2Y2RKSGVqWVFtbmtKZm4yMHJ0dm1tdCtWOGFNUFBEZmE4NFgrZTRtM3QvVS9zdzFuanNYZTBnY0lPVmNYM2NaZ1E2V3Fpc2phV3ZnNDVxSnpraCtycGt4MW1GcGZXZFlMc1BFODJJQk8zdjRXU3FUMU0wVGRhTjE0UWZVZFVncXkzTE9oOTcvdnZ6UHZtckpCcFUzZUthbGN0NFFIcFZibzMrY0toV2VpU0g5WEVGSFZHVzR3UHVUZGxyM3V0emI5Ly9uTlh3R2lQcE5vODdTQUR4VGI4cXR0U3c5TFlBaTUxbnNGc3hDc2ZqdHFpMkRZNlQ4V0duak5QcFNaMnNnNkoveXFLNTJqcE1DdUUvTHUzb1dhWWhZeTVZZXVRT1lBS2lHdUNVYVhiODVGaUJySHdhNi9Rb01GSHpWTHhzRCtGY3c0SEFwamV4NVJrQjYydXJBU0dBYmhXT2Z3c2I4eVB1cGd2SU1ka0F6VXJvSFM5bDZ4YS83Q3hnbytCb01WUG9LRExpODY0OCtnSUU5NzhIQTAzc3dVUExBLy80QXhoaTJZSUx4QndEK3pOdDcyL3YwV1FCZlJZeE0rS0szZlFjR09sK0d2YTk3M3I4WFVRVktQNExWUTMyRVdBdU10VzNJM0wrSzZKMzF0ekN3bFdtWXY0TG9uY2kwQXhUdVI5Ny9EZi9zUlIvYkpneTB2VHplM2ZrRFdKVGpIQlp4T2ZUdm5zTXkrUHNBQnZoK0M4RFkxOHJCZUhmblQvM3pyOERXR1pYY2E3QjM5elB2SzlOWjkzM09meC9BcjhPaWlIUEU5VXRQOXhjQS9BTkU0OE1qV01wdEdnTmU5akgvT1dLNmtnbUEwWGgzWjl3UkJPWTZQRE5LZ05HVmpIMFNUVHZ6U09YWktoSEw4bXdhWGE3QzlzaFZHRmk2Q1Z0UHJ3UDQ5bmgzNTF1dy9YSWNvMlR3dWtOVlFBdHpyUDBlNys0OGdVVzFNN1g0SE5Yb0xjajk2ZHJVOHdPb0NyR01ZSHdOd0hmOHVZdng3czRjOFV5OEM5djdyOEhPZ25keEFmNWUwT25Ta3FMWWhVNGlSSW1Db0lwS3hWUFkrelIwWlFxdVhIRS9NUzB6RmJTbHRJWlVkaUhHUXdGbkNSd1JHRWtCSHhxemxqd1VXOGJOL25DZlQ1UHZ0QVpaV2pPSndFNFEzSk5uTTFxSmJSM0JsSENDWEdyODNFVGtUMXFEVEEwdDZtbDVLUGZTY0RvVlJRSFNCdjgrY3hLUWZTN2dQMzg0WmdKZ3lpT0RZMDZxNUltaEhxaStIMVg0dzVtdFNvd0R5WjJjc1dpZ3p4amgwdnRydmUvUGlEaE9ldUozVnFiODJxTlM2bkdxWVYvYW9lRlVaV2NxbkVEaUxWNURCRHNZSVpTZU9WUmFVd2VNdVJoRmV6UWkxejFQSEFvV2NzYVFWZ0htSzdYU3lueFV4VUorT0VZOTk0WU9DZzJUenpsM1hOZERWTWZOTTIyR2FMd2lPRXp3aDg5amxNWWNjZjNYUlpxd2pwa2F4amxHUm9XRmFQRGsrNXp6QTUzbXVIOTdjRkEvWThDL3dyNkpVWTlubWhMbnAvWmRpWEZ0SGU2a1VIZnRzMGcrWDF3REcxZzJETFpTblpHNTdXd29ZL1RNbWh2dTl3U2NKSEhOYjhGcmtUcGZaNytaZnBGNkJETnVxQ0ZycklDREdHaHBIT1phcC9IdkVKNXEwZisrak9WOU15aGlSRklQNHRqaVp3akJRNjR2VFQvTk5hV1pOQ2d6c043cTBQdThaSkQxNnpmOTN3M1lmbURkWXExdENzUjl5RDd3WEUwZGtnaUVxVUdkQnZrY1ArZnZjOTBQZExSSitEblhnUEp6bnNYQjJhWEdhRHYwNy9SemduQUtsSWNheEFJV2hMTzJCZndOUERQNW5PK0ZhM210a0dqd2x2WVdzcjQ3R1QrVE5uajJqVXAzMUNqemFjTHJxSWVZblMzSXJNWHRXM2VWZjVVeERTcXpXbEZPMGlpdkdaK2JBZVRER1FHekpZVnNQdHh2eVJsR0dqb296M2UxVlc3ZjJDdk1vWFBxYmFSMWhQdUllNTJnTEowbUd1Y2xlZjhIM2g3YnB0MVBLVVRpeVRncHkyL0IxaHZubDIxcUJnd0d6bWlrSEdVbk9vUFFBWVJ5dWdhaURIeis1cVdsNlc5NzU4RzVFUW0vYkFPSGErUkU3bFgyUGNnemVuMFpJMzBwa3pHNk0zV0E1ZCtOS2RubG5ZUnpyWG5ZenhiSlhnQWlMMXVKY2pLWmY5NUZkd2xPTThLMytLNzFuVEhhbGpwNXlzOTVyV1p1Q3Ywclk5cDMxVW1ENDJJWm5kUXAyNnBlVGZ0WkFQM2t6QXBuUXNMUHFlOXJDVGZJTXhiZVYwYmVhb21XT2FwcDVIUDZPVXNLMElZNktzMXBpRUZCdkpadGsxZnozTk41QzJkb0tZN0laWFNZMDNJN2ZELzhmVzc4UE5ualNoeHZYVnJ2V2llVU91QVF5NWtPS3VQME5aWE9SeFBsc3J1b1BxRzgrVnlJTXRGSmRKU09EaDZVdFJTc3B3elNhZy9zWWpkbytaNU9EYTJPQ21VMU9BVEFVbm1tQ3pvbjByU0tDd0NmUVV4ZitxanVKbElDckx3SEErMitoQWdBdndjREgxZE9rWHNhNUVBV0RTWmNYQU1ZOEVnRDdBRFczM2NSVTlQeTBObEhQRGkrQ3dObkFSTitYb0lCai91d09mc1VMS1hzQ0JacGV3ZlZvdmRmZ0lGZjkvMzZkMkVnNHg1TXVOeUNDUVpqR0lCOHo2OGxzOXFFQVZhZjhUNVFlZndJNXVHNTV2ZU1FU054anhCckRQL1ErM2pGbi9WWmYvYTN2ZjA5R0lCOUJRYVkwcUQwQVBaZXJ3SDREd0I4RFJIdzVkenMrN2pKTU5kUUJhQy83bk0xOHI1ODZPMCs5R2YrWFg4UGZ3Z0RlU2NwMk9qcjUrNTRkK2NiQVA2Tnp5dlQ4UFM4L1JsczNWSjRYY0RlMmYvdWJmK3UvNzh1ODhnRFV6MGV1VzdlZ2tXQS9qcWlnUHVTei9NRGI1L0tZV2hEYWl1L0RBUDZ4cEtPdUFkTGZYeW0rOEhCUnhvWFZ5VXFnajBZc0QwSGdQSHV6a0ZUdjMxc216QVFmUk8yOWthd3VmNENvb09CZXBxeWx0Y1dnQ2ZqM1IzazBzNDNFSTBKR3FYVVpOUWZJTlo5VmlGTHdSWDJUZE8ya2RTTHJBZHpCSGdidHQ1LzI4YzdsVHJBdndLTE5KN0E1bVVDMi9zZndzN0ZUNVR4OG9JK05tSjA1TWNoUkEzZ1NsZ1phOW1xb1U1VE9WTWdYZ0NWZW1SQjJhd2JReUZSZTZJWTBIa0xpRVpqTmVEUVVLb0FTVlpaeVFqYVRJdXJ4ak1GbVBVektzd2FpVWVsdW9mbDZBUitycEZMUExmSVJ3L0xhaXBGanBGS2pVWmRERVN3MW5TRXdSQXB4bjBnaVhCc296S0MvSzAxRlp0STVwanp3M2IzL1cvV1Y2TkNUOE1hcjEySGpUazFLS1Y4S1IyZkdxUjZBQ29wZjFmWk4yV01LcVhTazY3NXJ1M1VLY2FyMEJJQTdldTF6VnQ2QUFONU5QMHo1MmFCR0NYUGVhV1RBcVBjbENjcThCblN3YkZkMzM4VHhIMmZOUWJxSGlzbFMwQnkyVkoyb2xKU2lDS3VFNTQ5NlhoV1dydGlRT2dsZ0FSUUJibDRIckI5bmxVSy9nYWptcmZETTVGdEVSQlZvd2ozL2tMYTFQUGxraHZUYyttcDAvNCtnUUVhdWZtblByU25IL3I0dHhEUDk0Y0ppRWRBaW1sdnQveTZBM20yUnZ5dG8xcW5WdDlIa04zS0dLMU1RRzdMLzJmbUtjQU04V2NhNmZoeGtJLzNNYW9SNEdkTkFYQjBJeWNqV1FoK0F2RXNac3BsQlZQbWNpLzVsOHJVdVhOdWltVWdrNDdNdko4Z00ybGNXTVFvQVpRNThrNEFsWlR2L3Z3OUFIdmVSOG9SM0w5elJDTXNBVXpxS25SOFhzRDVaN2w5NDNGaUxPV1lLUXNvUDJJNlNxWnlaK1JmeGVEdHh1RUFTb3VNbzJOUkF6bUJHSDFla0V1YVNIbWZ6ODFweUkzS3orbmtvZmFYdEcrYzN3V1c5M0VLN2xFZW9LeElua3NIQXA3RlRJR2QxVk9GeDVGdnpnVklvUHlvL2RQNjZtMzhtb0RDY1NNeTZSU2pRQ2dkNis4MzNlaU9CcGNoamhLVXJSM3czZlRmZE5TaHpIVUUwNFU1TDNUcVVTZk1LMzQ5OStVTVpydUJqeldrU0U3bUtjalB6cU1uM2gvTzlRTEExWEw3eGwzZTY4MnNsK2I0Ulo1Q1BrN2dsZWNDeXpDdFFwempDb0FzTWp6WEdHMW41Tms5NzM5d2VvSEo5R05FbVpqWkV1aXdvMWx0S044ejY0WGFtM1JQckN0QTFFUUVTR3BrR3ZKUDFoZ09SSjNDeHgrY0crUmNwVHd6ZzRGZTZmN1VQVGp3ZDg3ditGNTc4anVrelMxaWFudmFWb0pESUV3MmVlYnFjN2FSejAvcVhIQ21sQUE2Qk5yb2tKektvM1FHNFRxbk0vZXNyRWFGVjhEU2pMNGMrSkR3OHhsczdYQmRwRUVWRTNrTzdjazVmV3dKUkN0aW12c2dZL3M2Qyt0WHppUHVhNVZWQWVmYmlid0tSUDJjKzVkeU54RDUrYmlNWlRVVWFGUDlQR1R4RlAyYzZ6N01xZmNoeU0rb3lseXQxT2J3Y1J4U0lGOTBzZURVanVwZTcwa2ZsdlNzekZxaFRhYXlKaFF3TFdNMmthV0FnRXhmZ3g2YzZJeHBVRTluZnRFRkZPMUFGZjExRloyLzZmbi8rci80cjNxLzlkLzgxL29kOXdmdEdtcW5ibTM3Rk1iSnVWL2lSNWt4cTk2Z3o3MEFnTStaNklGK2lGZ3I3b3N3a09zQkRHanJ1bUdZc3ZoOVdEVHdFLytiUU5uSFFmU3VvL0JGcGZGVm1OQTdRNnc3eHpTVXp5TWFsU2NDM08wRCtJbmNkdzNSV0hJQVN6M2M4L1orQkJNTW1UYjRDR2E0K0RRc1F2WjFHS2g2eDY5N2dsaW5CVEN2eW4zRUdzdWZRVFNjdkE5TEcvMmU5NE9DL3dFTURGNzM3NjRpTWk0eWxnLzhNOVlqWmMxbitMTSs4ajZ3QnM0R0xCcjJJYXJ4TmllVEFBQWdBRWxFUVZTcHFHaEVKdmo3Z2YvOUFxS3lzSThJb0Nzbyt6WWlVeDM3TTkvaWRTMDFneGxOK3BxUGVSTVcyYnpuYmRGWXBrYTN1VWV3M2dmdzMvczRyc0pBK3RjUjY4SXk5ZEVWNzl2UEVJVjhlcUJlOG5tY0F1WUFNZDdkVWUvSGhZT2dDNytINmEzZlFWd3JuYnhra25HSE9saXJBTWNPQWg5SG9LWWd0a0QwZ3A4Qm1MdFRSVERXNlB2eTUxSEEzSVN0OVRkZzg4RGFXSDNZWEZ5RnplbTdmdTF6T0Vha0F6eUNWbXFLdDNuQXYrVGplb1JZeDF5RjFXRHdSZFdnbjBhVDlXQnI1MjNZZnJzQzRJLzgzamU4L1h1SWl1VEN4LzBJdHJZZXJBaDBYOUFGMWRKWkFMOHFTT2M4SytVekJTUklOSWdjWlFUTnRLOGFVVWlERmV2RFVhRmJKTmN6UlpSK3ovMi9GRG1EQmtPbkdBWFR0SU9Wejl6SXhtY2Z5alZhNjNnQmp4b3BZNXFxckVEczE4NmtyZFJybnJ5TXFlUVVETjMzc2ZBNTZ1RWMwdWY2SEZKeFg3aHhpbTJrNEdpVHh5b1Y0b0VyOS92SFdYT3libFI1NURtbzZjWkNUVG9IdVBUYW1iYmx4aWMxcHFmcFN4V2c2TWs0Z2U3Uk5ibTBWMnJ3NWhqNFRMN0ROc0M4bDY2ekZXbkdObndjWElOZEtUeXppQjdvSEJjUTUwZHJZckttTlBua3V0OUhSVjFUUVlhMlYreVg5cW5DZHhQUWhudGZqUkloRWpacHJvc1JQeVhPeGRJNjhiN1I4VVlqQXBibUVPTDBvbTJVTWZwYUl4UFRhRXM5RjVTQzRSVFJDS1ZHdjE1cGtVUmpHWE1kK0g3Zyt5aE5NMGhRTDJlb1lZMHpQcGYzRW5pWStSbEV3L0ljY203NE9xS1JQQjNmYy82Yjl6S3FqU2wydHlEeTRpa1phNTRhY3NEdjFPUkQyVE1MYVYrL1k5cEY2blRNVHNHMVI1Mlk5eXZQVUVNcitiRWFlWVlPYkRLRmErb3dBaURVMnVPNU1vZXREWllyU3VkakgxaU94UFgyaGpCRDVVQUFCelZPOHJQbkVIbm1RK2VWQTVqdXBuM2NndW5BNUxOTHBTSlEzZXQ3ZWpZZ2drNTA4aUFZb002bWg5NHVnV2xHNUFOVnZqYjNkam5uanhGNXMrcHRuSXNtZnM3b28xNXA1VG1PdlgrS3FvTWNuMVhSRlJGNXNJNUp6MDN5YzU3MStybUNDM1ErMS9rakw1cEI1SjlNUC9uOE5HSkcvK1krQ1hKV0dldEdjaDB2amQvZjJUck1DRXZIaE01ejZtMGNJS1lRSmZEV0JQU1J5Q2NtY3I3T0VkZkdPZ3lBSXlENGdEZVcyemZvbk05OWV4a0dHTjh2WXNybTRFaWVrYTNUY2VUR3pMTmxXc2JvYSs2Yk5kaCs1ZjRJMFZxSWVnUURLVFRqaEpaNDZBcDgwTTVYaWJDVjg0czFlS2N5ajR3QTVKa3dCa0ttbDF6a29EcHk4dHpSTWliTTVoSDY3dC9SOXFBcFpFbkJLVkpsamJvMTRUeTNjczRLNVVyWkJUN2cvNnFNcnFDYXBydG41aWJPSDB2RGtWUW1IL2t6dUcrcDN3emsvMDhjK0VzNkEzNWUwYmN6ZW10NFgvNWN2cGQwWDRVU1NQeXVqRmwzVkI3amVkaDNlWkR2TVJjZzBVUGs1K3BjdzNmTy9hMTc4QWdaNE5EN28vS0padmpvUVdTQWN2dkdaY1N6L0hFUkhjc29PN0x0amVMMnJTZWl1NmNsWkNyOFhQVHpmUmtmbjhQYTNaVGRpVG13MUFiTFV0R0pzdUljNW1mK2xIM3daNlNCZVUyMkYxS29vVjRtamgzSElUbjdkQS9uOUVKbWxDQjExbUZGWnRBeHFuN09kZFRsWEYvSW1rMzdyUE9kWmxOcDVCdkNoNDlsWXhNZ20vK2ZpbzR5bXkrbzg5TVpvekpHV2NOOXlqdW5EUGptS0xkM2M4RllxbU9xTTlpNTBpZE5aendPTVZybENMRTI1M013RUhnR0E5ZWUxTjd0Tk43ZG9lRDdFUXpRT1VUMHpwMmVKTVdwQTJyOUhQRGwzNkd1L2RIMW0yblVEZTk3RzFHWit4eGluZDduWWFEVkhoSlBlQUczQUV1UGZCV1JxVjN4MzI4amdwSXovL3d0R0tDN0IvZkE5MnRlUndRK2p3Um9aalRWMFB2M1pSanplQUNMR2h3QitHdFVqYWIwNnFTWDZCNWkydW9wTENYdFk4U050d2ZnanM3UGVIZm5wejVHQXNNMHhsNlR2azVoSURqckF6Tmw5bmRnWU5lbllHdm5FQVpvL3d4UmtiK0tHTzEwQkdBbTBZLzBMSzBsZjlmWEFQd21MSjN6K3pEZ2VZcm9ZVWFGaDBMc1B1dmYrclBHM3RaRDJMc2l5RDJIQVlOM2ZkNHV3ZDdkZTRqTWZzdkhjQ0R0aHlqNDhlN09YTmVoUjhTemxzNUM2dW5XQ2VWTjQ3N2s0NXA1TGUxVkRNWEhqZGFhdzk0eGxZVjczditaUndSbjZ3T1BydDg4Y05ENUxneGtmd2xtUEpuQTl0ZTdzQlRqWDRQTjUyUFkrM3NPMFhPOE0yazYrUVRzN3FmdnhHa1B0bmFld05iM1AvRFBxZnlvb0twR1RRcDVmSDkvQk51VFAwRVU3SDdnMTc0TWMvWjQ0bi9EeC84aGJLM2ZHMTIvZWFZMU41OVd1bUM2endhSjBLcUdUYVdRdG9YQWdnamYvYUk1QWtNTkx2UjJWYUZkQWJWVU9OUm9QL1l2T0tua0RNTFNaZzk1NDEzT2FNcnNJRlBFTXluTVNSbHJkb1pJRXNTSVA0M0d6a1dvc1ozUU5wVjJINWVDbDR3VVVzV3hUOFZDOWhKQjRqQ1A1ZllOZXRTcmwvOWNGSzVjcW0wcXpVc1JWWWlaRnZqL3Nielp0ZCtKTVZ1QmVEMGZOZG9uQUdMUzl3cm82ZTJFZEtESldxUWhnOG9mRmJUR05FMWlCQTZHTVRGV3MyOUFYRi9CWUZsYTNhL2NtVmN4NGh4SFVlVGFMUzFxbHZ5Sm5yaE5CaWUrL3h4d0NWVHJkS1hQbk1JTXVZd0Vwb0V6dkV1c29OQ0pzWk9BQk04VE5RaWxTajNIUUNNUTM2TTZjeTNnMFhNeXQ2eDF5R3U0ditybUs3enZNb0w2ZEVSWUZKbHpUdnJDdm9kblpnQXBCWXMxS3BCajArOFVHQ0ZBbEViR0FSRXdJMmpSU2FZcWJ0L0s2a3VJbVZ3ZXkyZk0rTU8rc29TTlJ1Y2UwT0JiM0w2MWxGR3FNQ2NaU0RzRUdYVmY4SjFQZll3VGYwK2hQVGY4YlpUYk4rNWR5QmJMSkd0TkhXeFVyMWVaZDFKWVduaDErR1VVaGhxWnlZTUlJS29EVEFCSzViazh6OU1JVUo0Ym1vNlpUZ1ZUSkVDTkVJR1dKZnRFa2E4cFMrUHdIREY2VVkyNVc2VTVHdWtaVDhQNVZNNjBuSk1xNzVuQkRiOEVnb3FZaXB0R2FuVkc1OTRORWFZeTFvb0JNK0ZwT1g0K2szN3FYR2hheWJUUDdJTm1NVmlKTXYwT3dLZndrd0M2eXpYc3cwTCtWd0JaQVloQnVYMWpXRVJIRmkxeFFmQ0laK0VSSXRnUnp0cU04VlByNW5FZStJNVpDN2FQS0wvUnlXL29RRVRkWE9uNjdaZm0rSkRsRXpueXRjczFRcnZhRU1adjl4ck90d1hNOFVEbm1lTll3RFBiNWZRdjMrOWF6NWQ3ZGdRRHdEdURWOEtEQ2E1Y2dqdjNDNENqZkJRUUp5c1pDOEVqWGpmMk1hd1Z0Mi90aTZ6SXVyTzkwcUlzQ2VBT2kzd2FmSzQxcmsrTzl4QTFEaVZGVEZsTndHc0RFWkJpRkNMSHJQWFBGZVJXbVloNkJmY2V4MDhBV25sL21BL0VzNnJyV3Fxek1ZeFIxYkZTOEJmSVJFcjZHcG5CNWlsMzdoNDVQOWR5ZXlwNzZCeW9ITTE5eTc2c3c4NjZPbm5rZ3FwckJzam9hNVNmblVkb2FiUkJ1czU1TG5BZGw5RVpXYlBxa0hRTjZsbWk4bmRhWG9GN29DN2JrcTcvQ2hXeC9GUG9LOHlHVHRtQnRucVZtemZkSVVIUGVKWXVWUDB4SnhzSDhCRlJQKytqcWlQUUdZbXlkMFVQcjlIUHVTOUNOSzN6aGVBb0pQeDhqdFdpZWZsKzVqQWVkU3FsaU9wME9XMDdBWXV6MGI3NmZ6TDIxSWxGOVhOR29mY3oxeTMxVStRRkxSRkZIYS9paUYvR3V1N0VKSnFJT3ZXeG9xdjFua1FtYW53L3VXZjkvbjl1WS96dC83WUtMR2Z1MWU5VC9ucHM2dkl1L0xwc2hMR3NrZXo5cDJFZjd0cUc5dW5uVlcvc2VWUWxRWXJYWUNEZVoyRkF4YjhCOElNdUFPNTRkNGZSTVdNWU9IVGl3MGZhNXVHMlNGTHBBcWdIZ0R1ME80SWRBQlJTTDhOQXhrMVlGTzhER0ZDcDRPeXJzSlN1Zng4MjNoSjJzTCtOQ0hyVFc1RGVRUlJLZnhjR2VyR093SGY0SEVZRCtyaTBYdUc2OSt1UjExMWVJNmdwNDJCRUxwbm5KbUphNk5kZzBjWk0zM2NabG5MNU9RRGZSS3hWVEViL0pneThmZDQvdityWHZnWmJGM2RnaGlDQ3BVOWdnRFRyOGNLL28vQk5SZUJUUG5jL0JmQ3o0d0JnSGduN3V6QkErbnNBL2dUMmpxakFFUXpZZ2dIUlQyQmc0NzY4d3o0TTVQODBxbDViditCOWV4TUdjSC9vODBZRjVJby9sMnZsZiswYWphdjFjOGU3T3l1bmZ4N3Y3bHlEdmI5VHJSZnI2eG5hSDZuZnk3M3dCbXp0Zld2RmRvZXdOYk1PNE1ldzFQRFgvUE9md2Q3UnI4QU1LbHhMMzRJNWtjeE9PazUzU21GV0FxWnlBdUw3SkZQOE5WanFaaW9zYWhCSkJRTit6bWptOTJHcHhUZDlERlNzM29DdG94OEErQTNZV2hyNy8vdVFsT0FYZEVGUEU2VmdXSjF3Vk1ZVVQ2cTRiTURPK2lkTkFxSW9tNnBVcXVFSU1FVXhSSG9pR2l5SDhPamZURjgwOVhINnpMNS8zM3IyK3JWYjh0RWMwZkZIZ1JxZUdZeFc1cmxIQTJpdFlKbCtSNk9IMzF1SmlrR3MwMFl3WlNJS0RHVUZac0RvdzBHUzB1b1M4bThxbjZFOHdpb0tZaGxUVWM5aHhyWEhMYmMwdFpWVklzcm9LVDFPM2owcG5NdUpRa0dGcWdJQ0ovK25VY0RrQXhwdFFpQzN0c1pzdzNnSVltbUtSU3I5d2NPNzVuN2RTelEwckNRZlplWnBnUVlEUXU0ZGVCdGNUM08wN0pjeWV0ZXJzZWd3MHliM1NkWXh4TmNXSS84V3lROVR4TkVSamVPaGdWTDVPdVFheW9PVThSZzlyOWZ3M1hOdkxFVnN5WnlvYkVERDB4UkpaSG5OV2NrNTFZaEVQcFB6UnNDQkJndU5vdU9aRTlLOUkwWktIY25abytuZGFkQWZGSmI2Tmt1bFJhMXRRQnhWNnM3UTVENDY3QUhMVGpwY3h4ekRvellGTzUwLzV5WHJpSURhT2t5ZU93QndJTmNOWWZKNkQzWU8zMm5yKzFtUzkrZFNjZnZXdzlhTHo0RktTem5jaDgxYk1BUmwxamxyT25JL0hTRTZuajdrUGNLNzlieWhjVmY1TjljbzkrVUJZanB2N2lFNkIxT2VKdEVwdDVlQWZlbzQxQW9TS0lBSVd6dmM3eHN3KzhZRzRqNVNRem9kS0RRdE92dFRaN2dpVDJYL0NEanZGZFZvYTlvRnVOZW56czhWcENlWXd2U2JVK2ZoSS9tYm9PY2hqc2ZQQ1M0dVlQUFk2dWpmMEZiV2dhcU1XUUtDODBER0tNbG9TMzdQT1FneVhnSitzKzBSSW0rZ2d6YjVPZGVTMm5hV3dOTmtQZldTTTRYcGhnbjRiL3JmbXpCWkt3c0NlMSt2SUFJT2pDaS91K0w3SVMray9OZUQ4ZFowTGRFUnJWSjJRY2J4SEdKMnZ5RWFNcmY0bm5vQjBTRmtCdUNleWlJaWQvS2FjV1pldDN6TXpFS256b3YzL0xPWEVPWFdHZXo5UFVZRUplbEFRb2NBZ3FsOER5eEZRZEo5ZXdtMmR4OW0xaVN6NmpFOTZ6cmlPejFFbE9XYitQbVc5d1hjTnk1cncrZGxnaGlJb05HdWZKLzhuVHAxSFJYVmNod3FJNFI3aW9ZMHlmNSsxaEQzUUZlZFIxUGU2aDRsVVZmcmR6a3JNdng4Q0pGcnBaK3p6Sm9PS1hXTG1scjI1MFU4SndzSCtqOXU4djcwaEdmVXJWRjF6Z05zWDFDR250U2MxYW1qcXdMTXFkUEdGTlc2dGJ5SC9GUmxTSzcvTlBOSWV1WTJ5cDZKM1lEeUNuVnhPaDlxTmdmeVdQYUhldHE0V0Fab3M4K1MveW1QN2hmTFRyTjBGcWRERjdOQ01vaHI3djNqZFN4anNRRmYvMlUxSmZxU1B0dEd6aTlHaUE3VXgrYm5MYytweURuSmQxazVvS2FkV3YzYy85Y3NaWFA1ZTgydnkyVithWHFmNnJnTFZNL1d4a3dkQ1ZqTStUMTJ0b0t1SUdyTnZSVTdSZ2U5U2pOU1ZMSkhyUGhjNVVmY2Q4R3hUYzRNVWorelQwZ3FKM2NDWDFmY3EzUWU2RFMvYWw5Y1pjOTlFbWc0dW41ek10N2RZU1RuRlVRZzdCRU1zTHM2M3QzNTRlajZ6Y1lvemRIMW00Y1M1UmdtMFFHM2hWOXpyTW4xNkw1ZThsbm50cndQbWphSXd1c2gwK1Q2NzMzRXlFZUN1ZnJNMlhoM2gxR25uNGVCUEYrRmdiaFVZcm5oZ0FndXZ1clAvekVNSEdJMDhHVUEveEdBTzE3Ymx0NUlDMGtQT3gzdjdoeXhMeW40NjUrbFN2Q1Q4ZTdPZ2ZlRjZSTnAxUDVGNzgvcjNyZlMrOG5VRTg4aHBwb0dETmg2RlJZcERaamcvaEpzbmR4RFpLNEhrRWpjQktpblF0OUhySjNjR3ZXYm9YMEEvd0xBYnlHbXpLYlJZaDAydDFTSUwzdWZQdy9nZXg3MXZlbi9GN0IzOWJiM2cwYTJWNzF2ajJGUjNQY1FtVGJUWTcrSmF0cTZWbEpuaU9QVS9oMWR2OWxZLytjRUZCaWFQSXRwckYrQWdiWlVvbGNoS3IyQVJmejJZRUQ5UG14OVhZS3RzYitCR1pkWTM0MUNGcDBWVGtMMCtycmliVDFHTklKTlpKemZoZTJUcjZGcWVDWXRzSnd5aVViWU4yR1I4YXpWdlFhYnR6ZGh3UEliZnYwZWJMMU80V2ZPQ2NkMlFSZDBMdFFnRUZFWUI2SkhLNDI5bHlFUldpUUthdEltK1JJRlNocExjcDd1R2dtb0F1VkNQczhaZTdJUmlXWDBlTmZJUlVhTU1pMlRwbUtpNHFOcGhRbEdNeFhkR2xCSlJiUmVidCtZNW9UdWRGN2Q0THZrdGV2WGFhMU50azJESjlQSlhZWW9qMlcxZGhPTnpKdmV4MDdwSGxXd2RvVm40b2FpbFpVZm1lOWdhQytUbXFyKzkxN21Ia1pvTElFWEdUQkMyd3JqU0QrRGVMVW5CazUrMTVuOC9kUGJYQTBQTk5pbHhtOCtJeGdFNWIzUFM0dm0zVmpSK0tVS3pEU2pGSEYvYWxSYVpadytsMDNHeFlIZnoyc0lqT3FZMGhxOTNCZGNsM3B0ejl1YUlzcFVxdXlucEh1ZGtTaDgveHI1UzlDWjYwZWpGZnBJRlA0eTFyVHFseGFsbSs1WGpRN1R0dEk5eEhUZU9hTXJ6eTMyalQ5QXRjYTNBaVBxK0tLZ21VWWM5T1RkamhIMWp3M1l2cThGZnpQUFl6MjBKeDNPQjZadjF0cmRBMFE5Z1ByR2dlN1J1bll6NXlHelNKRVVCT0RlMGUvb2NQRngwd2dXTGZWaWNmdlczZGFyejU3bXNEM0w5VnBuRkRsRXJDZEw0SXB5N3pXWS9BcmhCNHN5MXQ3VHRxbG5NMFVvUVpwaDhvNEp4dkxNckdTdlFIS08rUG9abFpiU1hDTTJGV2lra3hMSFFNQ1plcitlRWVUZGo3eU5kZS9yb2ZOS2dyOWhEbUZSd29jaUF5aC9UT2QxRHhtSEY3OXV2NHlPRjlwL3lKaW9Nd1BHRXpUbFBrSGdkWmd1MVJRWkdpanBMN000REZHVEZyNmxyZlNkTGEwdGY1YStRK1huZElvUDc5RnBrWDVHbnBZOEc4bno5TXcvS0tKVGpBSWJRYTdNbkRmNnZHbTVmWU5aMVBnVGdIYkV1dFY2UnBQbmoyQnJTTWM5aGdWWmZKaVp5aVZLRE02TStDYi81RGo3Y0pDeHRCVE9DNkJTQ29MamVJaXFuS0Y4ajlIRmRLaGh3QUxIUlNkcVBjZldVSTJtMTJoN3ltbGoySm1oY2oxcFVOeStkZWg3VW9FU3BxS2RKMnNyQUptSTZhd2hiUS9nV1FEa0hYUFBNWEpjMS9jQ01mVXRRV00rSjEyTHlsdlRMQzZNQ2t1alp2bnUxTEdRNXdmN3BuWVg3b0daUDQ4NkFQbVpyckdtREVkS1hDT2NyeTdnSmM5RXpnZjNLczl4dGhkSzN6U2RPWm45VlpkZHBWZlRWc3JqUHk1aWhvdk40dW1JU0E0QWZjdVpUOENYWjZldXYxUkdEOEJ2V1UzUHI4NExkR2dobnhwazloWGxhNjUzL2E2UDZobmVBN0JXeHV4SUZWdGtHUjJjTktKNDRuMVYvWnk2QW5XNXNkelA5TTRUMzZjYmNuOGZKazhjY1cwbVoyYzZ0MGZJQU9mQ3p4bDRSQ2ROQmxEeFBHV0p1eDRpUHcrZ3BBRENseEhUUjNjbWx6UDJ5bnoycmxhU016eWNyN2srRkhublh1bzduZmRzVGR2cFp3RkhLYW9SclJXOXR1R2RhZHRUNlM5bGtBVnE2Z3V6WFpFWlZMZm9sZHMzMW9zVm5MUmJaTVZ3RFZvQWRKVW5tL3J0ZjZzZUNSZy9YQUpHMVpiV01JZHNSK1VQZGV4Szc2dDdsN3ArVWh0ZUxhM0NhN0Q2K3RkeHRkbU5QbEUwQklEUjladFBQR3FQQi9TN3NNakpIbUp0dVM3VUgrL3VMQkxBYStYREtFY25CRTBJUWw2RkNhZDdrUHFsOG5zNjN0MzVDQzRJNWZydUlQQURHQ0I0RFFZU1VqRGdRVUdBaWZNNWdSM3N6OEUyekYvQmhPcVhZVkdRcjhMQXNKK2dtbWFSRk1EVXJ2UGcvYVFDcHVsbU5oQUJhSHBqVGhBOW96K0g2REhPZXNpZmgwWE1LcTBCZUFYT0dIMnVRcjk5UGMxOTNGL3p0Z2ltdlRyZTNmbkQwZldiU3lCQnk1Z1c0OTJkSnpEZzlvby92dzhENEY0QzhEc3dKdnRkUkcrcXl6Q1EvcEwzOVRjUVBTUmY4RDQrOUhuNkRBek12NFBvSGZwRXdQaS9HTy91L0NXQXRkT01jUDhZcVo5K0lEV003OExtNWlwY2NmWHZLTFJNV3RiaWZkaTgwanQ3RC9ZT2FERGNoSzJ0RDJEdmNvUVljVURGOXlSRVJXL1QyKy9EZ05sRFdFMW1wbDNmSCsvdS9BaTJ2aGtKVGdxUmhVbmJGS3pIc0xXaWhvd3hnRC8yOFgvQm4vY0JMT3I1eVNkazNWelFLVkpYTDdqem9CeFlXbmRkYVdtWlZIa2puOGs2dWVTTWJtVk1jY3ovbDJyMUppQ2ZHaWcwVFhRZlpuaW5na3huSkpLQ3VVQUVwdWdvMVUrRTlMRUkwSFFtMFhxelFQVGVwVElSQUNMdnN3cVRROWc1R09vWlp1YWo2V3hRejBzMUN0Rm9ReDRlRElQc1MxbE5CYjIrd2xvYjBFRE12cTJpOUtSdElRS0c3T2VpOVBxUjNzOVVlUWxnTWFJQkxMZTJkSjQxS2tZOWJTdUtVeG5yQUthZTRCWGo4QXA3a3dwUjhIYUhnUjQ2WDVydVQ5ZDNaVTdUdGFORWcyUVJJMFZDeEpSK0Q1bmJCSGh1VkVMbGVxNzdkSXc5V2U5cS9HUi9COG1jcWVNRyswSG5oRVhwNlRUTG1QWlNEUkhoTENyTVFVTHI2S1hLcXFhUlp6dmNhM081YjhuTFYrYVNmRDFWc21rOG9PRmdXaXdiUXZnT09FZHBIVFhLV3NGcHhzYzl3dktlRGdaczZUdkhGWFFNUk9DQjUwQS9aNlFzSlhJdy9jNk5ZNVRkVjBrdk9VYTFMclJtUFJyNG5CSmNJeGpNbXNUSE9VTVVNRWlCUkFJQXRhbXVGVGpwYUVRL0x0RklPamtydnE3R3FiYjJmYTRyOHkzOEFBNlFNTVVyamYwMHJqTHRkaVVOTTUrcmhsTi8xcXlNOWNIaDkrOEIxZFNxUmF6MUMvK2V6Z2MwU25NL1hDbWp3d2hMR0hFL01Tc0dEWE9NZ0xtUG1EYVgwYk1MQUEvTG1HbUFtYkNtSWkvMDRGR0FmaDBCSERxTHpCSitQb0lia0wwUGxWcnZJdHZVRVkzeDZyREN2bWhrSUlGNDlsdmYzd0ZXNCtkOW4vZmdsSGFDdlVDQUtJQ0w1WEtXRGVVbmV2NVQ1dXZDejdWdVlnRHdYVDdUOW5nUHdRNmVhWXdXRFhNQTQvbTFLUUFKVGlBNmxtdjA2UU81bHBHZ0JFV290K2I0ZVdXY1pZenc1YnJWMU9FYmlQSWNvOGdXeUFONWxKZXo3N0dJamdMTU9xZkdma2FpSC9yYTFqcWhJWDF4TWorYUdoNnc5OGgwckhQWXU1bVVWc3M0bEVNUjRuNjlCNXMvUm14cm1temFyVWg4Rnp3ck5FdEJ4VWpydnc5OGpLdzdxM0w5RE1DVE1xWi9wdE9TUnA5UmhpSUF4dWZUMFZYMzlTV2ZrNlBpOXEyRDBwd3N5YXVWRnZLajBXMFR4RWgyeWc2VWxiUHYxZmR3Tmt1TkF5V0hva3MxUmpyS2ZSVmpmaG5UeXV1enRGek5wcC9OaytJWTBYRGVUK29VaStUelNqMzBIQ2xnMWFJM25aUjRQcytlRW42dTc2bHl2Lyt0dGFsVlA2Zk1ucTVmYlh2cGMxOURQSGNKQXFkQWxEcmJVRVpUL1J6KzdBM2hpWFM0SU4vVGpFencvdmFLMjdmMmZMMkhURXIrelAweWxyeWhvOWs4MGMvcHRFdzVtdWVhcmovTzJ4RFZOT2U1bXFsTjc0YjJqelR0TzhmSGpDS1UxYW0zbzl5K01TaHUzNW9WNWhqVE9mSlh6cWxnUzZqaHAxMUo5ZEpRNHF2bG5nV2lZMUpyM3hQOVBKemROZjJ1WUFwK1QxMDVwVWJTUFlhNEJ5cG5xTmdjS004QWVUMjRiWXlwUEZIUjkzMnQ1Y2FjMnBrN1A0T2ZBVXY2RWRjZzI2OXpFQWpndXJZanoxRCtwVzBEcU5yb2F2WktMZ2ppMU0vdHVqTTBmZi9KczNsOW4vemQxMlFZVTJKRFlmK2ZDcHZ0U1NnQXV3NFk3c01pMnQ1eFVKaUNjT3VMR3UvdXJNTUF6cWZCNjdsQ1ByWWpSTkQyTlFDUHhyczdkL3k3a0tMWEl6VGJEdEVaRENpa3NQOFlCa0RlOTg5QzNWbC83aDRNWEh3QzRNOFFhMmw5NUo5dEFQZzdNSUgxUGNEcTFQcjlOS3BNVmsyYjdQZmZGNkJ1TXQ3ZCtUNkF2NGZvNVgwSkJ2QlJHWGtJQTh6Vy9POFhZWXJIQjRoUlJwY1FtZHdMY0UvLzVQRlVZcDd6Wi8zUVArZHpPaDkyQ1pIUk11VTBoWXd2KzNjdndFQjFHajYrRFhzM0wvcXpLYXd5ZGZSTGlNQTRCZDRSVEtsSlBka1lnWjBWZUZjQjZKOFNXZ1BRRysvdXBDbUphUXo1SVlDdkFNQjRkNGNwblRaaERpSk40K1g4TUwwU2F5RlAvZjh0MkY3aE92b0ljWjA4aDVPRHYzUVdtSGpiQ3I2OENPQkFhbDZUWVc3NitNaXNOVUloUitvSk5ZWkZ2YzhBM1BXMCtndFlKb1VGYkU4L1BFNzA5d1Y5OHVrOEJZbEVTRHZXL2FLc1ZoUThWNTVTb1pTZ1JWQlNxUEQ0SlJWbHNVTy8xSk5RamFZOVJNY010bm1RRVdEaHoyRTBLOXVzQTJRSnJGR3hvekk2Y1lXTlN0M2MveC9JL2NxdkZUVExwZURVbEVRRVU5WVFqZThWNEs2MHFCSUNOaU1ZanlaL28yR1BvQmdWNzV4QnJvbG9BR1hrMDBrajdCUjg1MXhvSFYwRjB5Z2owS0JJNDVncU9aUkIwbmZYYytWdDZHM3FlS2g0YzI1eWlqN3EvczlSMG1lT2syTkxGWktLa3RuUWJFLzJXbXBRVUhrOGVNSEwvdUxlNkNzUXVjTDdDd1o3UHR2dnBSR2V5bEhGYTkvNzEwL2ZCV0swS0EwNEJHVnBQR0FFa081SEdvT0NZUXRSS2MxRm10SFFIWXhDUlRYZEhJM2JUYkpGVTFxeDRHeFJ4QWlDMU9BUkluTlZlVVJWQ1E5ekpudGVzdzNRR01heGM4NG5SUUp3bGpHS2dFYStYRXBTUmtZRzQxZEtjaFkzUnJpMEdDaDdpSmxpTHBWV3IxSWp4WUhvU0xNeUFPelBYUUo0K2JrbzZuei9RUFZjb0FNd3l1MGI5MC9oTEt2cjU1RzNmeVk4M2NmWnB5RzF6S1IrN2RCSFRUTktvOGNRbm4zQjk5ZlVuNkdSYkZ4emEyV014QVVFbklSRWppbi96QkQzZ1JweGxaK0hpQjJuUG9ESE9aREk5OW9CWW1RaWVWOGFmUnQwTitlZnRHOXN3UGJYNHpKbXlaakE5SmFockh1TnRGV1pZeWt0cXdPWHJLWElkT3hEVlBtNWx0b0kvRWllei8ydkFLTTZ1Z1VqY2tjaVh4cVcyemZHeGNtTXhXeVBPbEQ0bjhaZ1lJazM4ajNUaVkvWDBzZ2EwbUFXTWVKSEFZRWdJemxQWjlTVVpoMEk3OTNuK2FpMGpCcVVPVFhiUjUwTmdqS2U4Z3phTTJnYzVoaDV0bkk5TEFWTGxESGFiVmpFMGh4TWZVNUhKY29zbHhGQnQwTy9sK0FCVXhYenZEL29lTTRRN0tSUmUxamN2dlhROTRDQ3ZpcFRNMUkxSFE5dFJGZGg4ejd6UG9VMHg2VTVSMmhLVnRLK3pCM0xsU3lReityQ05Nck1ETlp6ZVpycklnQkd1VG1RTnRKc01BVElHQ0hJckgraFpxcGZ5blViNWtMV0MyMFpsYXdGd3M4UEVhTUJ5ZlA2Y3Q4Q1Nha1htVnZPSStlL1FzTHpzOS9yZUUrQngvSGNHZmw1d2VkcG5XUHVpNVdwRHVCTjVMYmdPSkxJZlpwQjRlQVV6cks2UGg0ZEYzVHFRcFN2Q1ViNkdzcldvbTdvWXlwdkF6SExBcjhQdFdVejRGU1RmaDVrY2YrK2JaNjUzeFg4VkFjZzhvcEthUURFODRjMGdXWFFVc0F1MWMyQ3JiNDBSeXpLNkJ6UHVJeVpzT2FGT1dqb2VhU09iWHdHNWZvVVpOZjB0OXo3YTRncDhPbk1RQ2VSUjRqOGlMWkhQb3QyQ3M3TmVoa2Q1enF2WTlFTnQzd1BuQVJRVTMyMGRzNkJLRGR5RExKdUFsaldCcmFKWEtCOE9OWFBhVmM1a1g3dU5DaXJUdFU1MlpSNm52NnY2emY3ckVTR1NiK2o3cTd2ZFFiYjg1V01iMTNmWHdyMGNyNkw2Tmllam9ucnVnSkU2M05WdDhzQnVFV011Zzk2T0k2M1ZudXdkekU5NFhwZG9oYjlWTmZaMGhvcW93TjZDcERyR2FiN0EyVTNCNG1ubW9aQUJjajVFTUFIU1pUYTBtS29vVTBZZUJOUyt6NWxnQmdaNmlFc2NuUUNoRnFoN0d2WEJiMkFnYmpmUjB5cHdiYm55WmpuL3ZuMy9UZlQwSzVMUC9aZ05YS3Z3QVRydjRVQmMzMXRkNFd4QnNyTS84c3dNUG8rTE9yNERoQnFybjQwM3QzNUMwU0ZmZ1pqWkorQ3ZWc2E4YlNXMmhhQTMvRDdQcFIrYnZuUENERU44RWV3ZWV1NnBnSnhMVGxnL3hQdnozMll3OEVHTEdYMTUyRHpleGZ1UVE1TFkvd3Q3OHV2STRMVjc4T0UvMC9EZ09SRG40czdzR2pOR1F3YzNocnY3cnpmRkxrcGtiRjlKS2xWbm5LaUFMOEdjNGlnSi80TU5uZGZSa3ovL1M4UjA1ZzBSdVE3c0xvRjRPdXdlWGtFcTlsTWIrcDkyTHZiUTJSUWQyRHpUWU5sSzdGZWNhM0lpUm9BQUNBQVNVUkJWTU83R1NPbWN4OTdQM28ramtmdThES0NnY0l2bytxQnFCRkpIQ3ZUUFBPekR4Q0ZGWjBQQ2pLQXJmMjd1ZFR0RjNSQjUwRWlrR3RLMUZaZWw0SWNmajhOSVFyR1VVZ1BrWmQrcnhwNVo0akdINlptTzNUQnNxNm16QUF3cFVvRVNGSlBmb2ZVaVA1TVJnZHR1SkVMYkNkNUJFSFV4cnBhZmkramIyaUFVWUZTaGNhUkt4cXBjVTRCakpENnl0dllrREdvd1ZpVjg4bzdTNHpaVkZ3NDN4TklhbXRFaDZhVjVBZ0IrWVl3ai8vMW9qMmw3QkxKT3RFK0VseFE0ekVWRlRVY1VyR2VTenZaU0VVQksvbXVhTEJsS2p3K1E1MEZKbWxiRFVhbkxxUk9ZNm55cXBHa2xJRlkzMVRyR3ZQZE1TV2JLdHhUQ0REclRSTk1wK0U3UkpQQTlscldTRnBIUmRYeFlZaXFVVitWTEs1VDlxSHY5ekI5NlVBK3AvRnBTZkdXczRMN2tRRHV6STMzdmVRNVM1U0FCVUNjVndVQUo4bjFGZS81WE51eVJ5bVRETW9ZdmFVUjdKcGlySEl2Mzd1MFZURlVJYjVYUG1OZjFrTFBqWkE1c0lKeVJsT3RQRHFUcUtkN2lOVEwzZURmVnh4OEhMUklzeXB3SGxsbWcrK2FaekZKN3psdUJvRkc4cm05Z3BoS25NQXd6MkVGMk91QW4xUHJDLy8yK2RtQ25VdkhycHN1cE02em00aEd4dGFJNDlMcTBzN0VFTXIzcGc2d2l6STYrd1FReU04QkdvRFdVSTJlSlU4ODhMV2FqZXowYzZGWDNMN0ZHbnhjNyttWkdKeC9FTmY0QU9aWW9FYVlzSi85L1Q5QWpMTFIxT05MVVdLRlI4cVhNUTB1TTNrQXNiWXVZUHI0dE55KzhUaGp5S1REQkFGeExjOFFJaUpSelZwQ0p4SkdDN0UvdXRlQUtvL2ovUVNRZWpDZWZvUVY5R2d4ZEszQitQbTBhSWlhNzBCcVVHTS9WRVlqZjlkeUZFRldUUGg1Mmc0UWdXT2VHUVI1TDZIcTlFSUgzd1hNcUo5R3lxN0IzaEd6Q0REcWFLbDhSSmxFNnlBQzhqTlVNNkVzWUNrM0NhNHFPUEJDdVgzam9mRDdTL0FNV0M1UGFXM3NKekpIL0dIR2hIM3ZJK3ZrOGxtSFdIWSthcUpEbjVkRnVYM2pLb3lITWFLT05SWFZpWUxFZDNuRis2MU84bk40NUNwaWRnYk9JUjBZN2lLQzZTenJSTjdIZXBWTmNqZlh3eHltZHlnL1o2cjNpYXlqZFZSQm5XelVrZXhSb0ZvSFBFU1lpZXdZNUFyaDUwZGxWWDduK3Vzam5nbDBlanNxa25xY0RlYzBuVDFDTGVCTS83bW1LcEZyVFhKcTdneE1aYzdrK2sxVU14T2tjckR5MERQTHBsRkc1MW9hM0djeUwzV08rYWRPR1g2K0R1ZGpwOUM4UnRLejFqY2RzTnI0T2ZjdVFjYzEvMXlCakY0Wnl4QnhuM05PRlJqcUkwYTRFNXhpWkhxZGZyNE9HRWp1MXlrL1Y5NmdkalFGMmRhRW4xZDRvSng3ZEo0WXkzN0xBWUVzeXhDY0xXcjBSVHBESHladFVCY0VFc2VxTXRiLzVWbkFjeXpMejcxZGRUVGFReldiSUdVdTFZVzI0SUVrV0kzb1BIb2FUdHBxNjFRZURXQXBPNVE2eHl5Uzc3UEVkU2V5SWM4eXJuc0ZYR25EWVlZVmJTY0FvQ3Z3UUIwWHovTWxSMkpmRzZrTVE5cyt6OFFCcXZKaXNFVVYwYUZQYlI2YUVhZVNIYVp0aitkSUFkcW0rUlplUi8wdmZhZGN2MXpUYmM4bEgrNGFmWnhTQlVqVnZkekd3OXFJY2xzNkgreG4yeHdYMGJtRkRpV3FnN0R2ZEVnNFZlRDY0eVNDakZudzB5UFpWSkVad3NEQ3BVUEcyM2tlUUlnNEpZRFpKZTBwYS95ZUZXQTgzdDE1Q1NhSVUzbmFnMFhvQlU4V0FJdTI1L3VZNk5IRE9XTWs0d0VzVW5jbTE5S2dwVXJsSml3ZDdWZUFrSUo0RHB1L0h3SDRtOU91KytwOStUeUEzL1QrZndmQW4wbDZZMTdIQTBNalZkNkFnWE9mUVl6VStEUk1lZmt1b3FmZ0QvMnp6L2k0WC9FeEg4RUF2eCtpUFhWd3J1L0JBQ3Ixb0RYSzZYbi9vWEEyUTR3d0plQytCZ00wdDJCZy9FOWh5czdMaUNEOE9reHBtZnJubCtEcGUrdWNBeVJDbXluTURrNnlobGt6K3p3Y0p4eWs1WjU0aEdqSW1RUDRaVmhVK2d1d3ZmR3YvYm9mQUxqWEJHaU9kM2V1d3Via3M5NytSNGlwVnIrWGprM3FlNVBSTHJwRXU4dDlLbXpTTTVURzVEY1EwNzRmQVBqM0VJSDZkMkhPRGIrRnVHNFljVU9nZ0o3RzcvZ3ozZ1R3ci96M04wZlhiNzRqZmRtQ2djdi9QaXlkKzlzd1I0TTB3dnFDTHFpVzZwU2NrN1NGeUlNb1ZLc2hxKzdlRkFEV1ZGTThrK0h0ekJMQlVnMjZORFlORU91WkRVVnB5eGtvZUdZVENHTC9hWlFPNlFCUkZXVG5pUHlZaHFrbFlLVmx6R25xWG42blVRdVFNWkVQeldIbjNoUlZRSTk5bnhmTDN1MDBrTUhuWlZyRXlJL09TZzZOKzRpZ0VpTUo5aEVqOHpyVkNremE3Y0hPdEJDOVVPVFR6TmFDcG1YMHVsWlpDSWdwczNMZ0xNL2dXVkd0MGF2ekh3Qnl4TE8vaDhTd0pZWUoxdTZqOTNZUEhtbFRNeGJPL3lxZXVZQkVEdVh1RmVWaUxrb2ErMDRqc3NwZ1ZKd29nNlFaVktqa3BLbGVPWmVMdXI1MEhWY0RXRWlITGI1REdxcVhJbHpLcEs2eEdNL2g5ODFxNW92encrdFVrVnhhYyt5djlJM1JSRE1CZm5yQWNvM09takZXMWd2RU1KMFpZK3ZaWGNaNjNveDIwelNkQzBURFAydWFjcXlUUXNCZ3VTWTdiOGt6Q1JTMzlZdGpwR0dMWjFpMkpyVzNld25tMkJtaWtUa3ZaVFVDT2RSYk8yM3lmbEFIMFBQNW9SZzlhZGhPalg5blJqNm5ML3EvZThVeEhHaVM5cmdlcUp0WERCZklSNWF4SDl3RFhFTjA2QVhpT3VQNXluU3JmSmJ5Y3pwVERCRUJySUhzclNFUTZudERQdHVDeVI3a3lkeWJDaTZ4M1EzNTdqS2lFVXVqNng2MjdWK2ZyeEVzZWpnMVdoR0VJaDM1YzVrdU42U0tSdFVwZ3dCV0JVQVZtWVZwWUFtU2taOHZSYlEwOUp2Z1BHVUw4c05EeEhyYngrWG5CTCtXK0d2bTJxV3pUQXlmUEMrVVQ5WHg4NkY4ZjVRWWs3bXVlQ1pTbHRyMForekxlYUw5WjYzZmtjOEpqYmNQRS80L1JIUXNuc0VqVVd0QURWMFBIS2MrYjVwY1R4NUc0RzdzYTQ1bGgrYXdzNUgxbWlGemRPRGZieUVhdkxsdURtSHBwbFBISGNwNWxhakhyb1prdmpzMVZDY3lQWjMyZ2VpTXVPbDlIY041aUkveGNuSDcxajFwZXgzbU1NR3hqUXR4ZnBMcjFoQkIvQkNCSzcrUm5CMTlmODhFYTJtRG1pTTZlcWdjbmt0SnFYUEFPc2FxQzAyQjVScTc2WHpWek9rYTdIMERkczZ3aGpoVFhPOEpyK1phbWlEREQ4c1c1NngwVGxxdVVhUDhJTkU5aHVtelpid2oyUHNMZXpNNSt5Z0xUWkRKbkhRYUpMSXJFTS9vdWVpTTNIYzhZOCtMbjlQK3U0Q3RseE9Cd09TVmlHY285d0hmYlowT0VVQmUwYjNWRVpsbk0zVVlkU0pNOVFmZGUzUjhZTmFmSEhESGRVcjVnWUVSZEJKVDUwL3FvZ1JoNTZobXRFZ2RTcnJJc1JwNXE5K1JuN01OOW90T1JIejJMRDFmRUIwcFUzbCtBQzlmNGg4ZEhwT2YwMWxQeDd5QW5ha2JNSnZEay9vV0d0dG1tYzRlaEZkbXJxdlZUVlIvUjF3MzFIWEErMlNkaFhXYTA3MlNOdWxzeFhWd1ZDenpaeUR5bGdHaWZYOVdKQTVkeDlYUDVmNmw5WnhwZnlsekJPSlpTcjFUZFZJZ3JydFVKcUt1WHllWHJ6eUdyaVRyVk04VjdsWFZIK2cwdWJJKzY5ZTE4c21HdmxGT1hBWFFUOXVxQkF4NFg0N2JGdGU0Qm43d2ZjK1RjekNjbytmRmcwNlRlcmtQSFlRaW8yUFV5TUwvSDQ2dTM3eFhjOSs2QWpjT2lneFNrTEhtZWFkV0x6alQvZ0RBUDBKTStjTDB4bitPeEtEVUJOUjR0UEFXRE9TYlpMN3JBWmltQUxoL1B1RGNPTEQrSlpoZ1RVVjN5L3YxMXVqNnpiZFBZY3c5NmNjYUxCcnpLLzZNUFFCL0RhQnNBVGE1cVg0QlpnVG1obVVhN1hkZ0FQQUdnRitDQ1kxdndzRGlkL3phK3pBbWR3OEd1bllDdzhhN08ydWo2emNuL3U3NmlBTDJRLzlOWlNDTmR0TFVPS3FBWG9JQjAwenQ5VDZxQnpjVmYzb1pmeHIyZnZZQXZKY0RKSDE5czdieEhzeVI0a3dpSE9SNXArWWs0UUN3cHR5Z1VXWU00QmNCL0gwWWlBOEF2NGZvT0RCcmlZaitWZGpjQVZIUmV4N0Fqd0Y4TzNjdm8zbmhERUdBZmpxbzFKNGhyRGVkQVpiWFllbk85MkZwbUIvNXVCN0MxdlFCN0ozL0hWaWtNOWVPR2lXT0FId1RCdWdPL1A2WGZiNytMd0NQSlZYN2YranRmZ0FEeXQrRjFmMTk1aGpEQlgxODFGWG9XcUU5S2pnVWJNSlplWkpuNUl4T0FpSUFFZndOSG91b2dnb0tUb2NJWFZWbXhWQzE0V09nbDJ5YTBwWFBZWHNFblprU21kZE82Z1IvZnc3bmFzbW9VQ1llMXdJczlQd3pHdEZUQllkcEppc0ttczhWU3cyb0VVcnZWWkE0WnpEcXl4elJjRTZoWG8wQThQdFg1aytpWU5JdzNzc29aVlNVRjZraW15aVhmY1RVbmp4ZktXdnd2YVNHWVNyTmRDeWdZWkxLUFNQSmw1UXkvNXdHQm4yZmJDdEVMaGJMNER5OGpjNTdSRUFBUUF3S3F5cDZZdEFNd0c4UkhTSFlmMVhTT2NkcUFDVndDV1RXMW1tUjdobjI2LzluNzgyYUpNM084N0FuTTJ2SnF1cnVXVEZZQmdCQkVpQ3hFQ0p0THFKSUtpbUZMRjFaSVY4NGZPZXdPM1RqMjdwdzFHVTdML3VxLzRIekJ6aDhvd2phRG9lbHNMK3dSWW9TR1NRQUVSUXdCQWFZd2N4Z1pucDZxeVdyS2hkZnZPOXp6blBlUEY4dTFkVTkyRTVFUlZWbGZzdFozKzE1bDBIRkU3MlIyblZpeU5IK2RKQTkvWHZobktVNVJVbkhDSDYzQWUya0E5d1hGL0hhRmpxbUlLdlNUMEM4eUpHTkZBdlB4Q0lOVStlRjVJd2pCdlVJVXRQWUQrUjlIK25kT1ZxTVVHcmtiVlBRd3pocEZCK2o5THFuTGppTEFLWVlNR2tvbmpxdEpzMmRJd041S3cxOFYyMENQdkI4a0xZOC9qZ1ZjNS9mVzdEMWZ2QzA0eGNhcjFseWVQWVhvczM4SHVyenJlZmZuMHNBUmFNalNmdTU5NUpoem04OWk0WmlaT1BKZ3JGZVBydnAxN0owQVVGVE9obHcvM0I4MU0wdVllQU5lY0o0R1U5ck1nQjhYTm43TEcrVm5PR2NadlRjWU02eGF2cFQ4a01haFovSW1BaHNzVy9ucVBOejZsbm5GWjZUbkZLYURGd1NiRkY3QW1uSHhoRS9UWTZzbzhGK0h1ZFErVmh0ZmdPWXdPZnh6Q2x2VlFNa2pYMTAvS0pUQWtzNk1SUEt1UU9IbEk4NjhOVEhnNXhDV1owZXVIOTJrT1hEcnRCUnloZmtBV3RIMEFyZ3czM0F0ZDdsdk1sY0xFU2FpK3h4Z0N3REh2dTFwMDEyS2lUd1NnY0p6djlqZnhUMWMrNzlVendqNEt2SkRnNjBsVzNENU5ZNHRwZGc5SFhxYS9LeWYwV1paQUt6Kzh6aEtWLzllOW9TeVJzNGZrWUpMK3hINlJlZnczT1IrcVV5ZWVXekNIaHBWTjhNR1l5bjdGOHpoQ2VIVlA5TStUblhsdklMYWNHWUlLSHpWOUljMmhvNFRqcWdhOXJlT1A1aVhHM1h5ZldrM2Vjb0k3em8vRk56ZnV6S3YrUURCR1E0Vnp6WGt6aFAxOVc4SDlSbFVuOFFkS3ZuM1lRbmNxMmZscCtUVmtiYURyZ3pjRXNmbHRZK0ZsNGNVejd6WGRTdHFFY2twN213eDVMdUZ2YjlGbXgva1BmVDNrY0FtUEpKTEFOQ1hZVXlCRE5TOFBQSk1wN1c1QXhjQzA1OFRrdG5nekxqanVybnlYR2hBa0J5cjQwSHBieXUyU1lXSEI1RTUyVDJnWVgwNWZJODZzaU11Q1FRUGtjRzREWjJrQlQ1ams1RU5VZWxwZnc4WEtjWk9XZ1A1ZG1QUURHdjRSaVNQaFQzb013VkhRMm9uNnR6SWVVd3JqTlRaOWYwYys3TEt3SEFrTE94cWMxTnppMjhqMjNSdjRWK1hnRVBPZmExSEFtdTJsVEg5Yk9xR1JRVWdEMlZlNkxPMnhyOUd1ZXZ5WFczVnpwRHExM2pxdlEwMkppcURtNVhlQjdDL3RqR292Mnl5T2FtMzMyY2ZHcmQxcTE5NkFETkZDWk0wM2k1alVvS3NIRGZSZmgvdmdiNHF3ZnBXVFhXRWFGSC9RRTh2Uy9LeUNpTVI4T08vL1RHbytFcjQ5SHdOZjlONzVYeld2UmovL2FkU2YvMm5TSzZ0WC83enN4L2loQjd2Ly9iQVA0S1ZoUDRyMkVwY244SXI2LzZOTTJCc3ozdjk1Y0EvRXNBdncwVGN0K0gxYjg5UldaQXRVWUJuaURucndMNExFd0JlUkVHeUtZb0hYL21TekFsNEFTbTVQUmhnUEJMeUl4a1M0Qng5cmNyMFp6Y0UxTWcxV1JtUDU0Z2c3c1g4ZzRTVzBhenpwRUJRVEl1QlRwZlFLNFh4ZXZPL1htWC91eTNrVk5DZHgxRTUvN1k4diszWVFEZ1ExLzdhd04vL1QxNy9xNnVPQis4UEI0TmQxZmR2MmJqMldOVVArdFZkMkR6Y1I4MkQyL0IwcExmUnlrc3RyVWZ3WUQvSDhMMk9iMTJHWTNkMXZqY2ZRZHZQdzhEVzZjOGwvRUcxdkJ0QVZrbjNuOTZYbmQ4ZkJQazJ0c3pHR0RMOU9VODV4U1VtVDZhS2RIdnc4N3JOLzI1LzJBOEd2N1hBUDU3MlBtNEQ1dXZkd0djL0FMOHJiZWdrS001dEZTZjhmT2Z4emE0ZC9mS25uQXRqVUk2YWJVcVlVVnJ5aG81QzAwTkJGU3crRm1UVTVNeDBqWFI0b0dsaWJvUUFZa0tpNmE5VWtGTGhVOGcwLzJVUXRELzV6c1VHQ0lReHRSTXA4aUd5UzBkWTNONHhIUjRIRk9yUjdrcnBrbXhFUkNMZmFNc1VXc0Z5QzEvTXhKZ1BMaDNOMFdveWptZ2NncFlldWswL3o2T0xlMC95blQwT2tkTUw3ZDJhdzZQV0xlT0dSVFlGbEwweTFnV29vTmx2VlJnMXI1U2NkeVN2N1Zta2dKd0hhQ29SOFYxMXpRK0VlemxudS9DRk1tNXovVzU5N3ZqNHkxQTN5VmdTU3VOOG51Szk0dHkwclkzaW1jSFVHMDJzQlRvOVBKWDRIVGk0NGhwaW5xeXg4bTNDcy9zMmpubnUzVjhxMml5S3pvek9kdGM1MXFiQWltZE5KMzIyRWlidWxUKzNhQ3o3ZGNUTkppalZMZ0tnRFdNYTRac2xLRWpLMmxWTDQ0ci9OK1J2dXFhNnBsU1JUODI3dlV0ZWJZcXFUT1V4cVJrS0FoenJ0OERpOGFaTGM1UmMzaTAyK1M2NW9ETXI4L1IzSy9oSEZCbVBnaUFEbW4zRmd4WW9URW16aGVkY2c3ODUwWmpLVWFaRFllQUhXWGx2U1o3KzE5M28rRnhLcitmVzZSdlczTTY4Z2pBUjJJVWU1cm54WElqYkhOWWVzUGRwdVFSTjNoZnhXRGFiUTZQRGh4WW1MaGhzQTliSjY0L3p4MXIxSkdYSE1PajNmeFoyekNnbXhGdW1yNWRJMERaNkJSQVFJVTZ0WUtFUUpiRHlTZlBZUTZjS2IyLzdua2YvNzdzNTB0WUJONkNZWW44M0ovZjhURnNJNmVWVlFlYU9OZmtPVW5uOCtlTllRYllreForemdqaERpeHRvOUtybm85SE00SWtKeGVVTkVjTnlHczE3d2RUZTVJZUpwb1k1a2FOM20xTmFSLzd5bkV3UW94L0svM1ZWTWRBNXVjOHcxM25Ld1RSYVhmaWZycEFqcUtpWTlVSkxHS1drWXNxcS9MWkJPUVg2bURXZUp6UWZ2YUxjZ0xwT2xPZ3p2Mm56WGpKakRSakdHQjVOakR3ZHd1NTdOY0ZEQ3g5TUxCVThRUXJEdng3UHVNVTJRbFArZm5DUHZYUGl6M21ZMjJsd1M3dlRRYjM3dEpoUWtHaTJNYXd0ZW9pWndyamp3SS9yTC9Pc21Ed2NhaGV6Y2p3ODBFRzJYc1Zma2FIRTBib2M2MTEvRzFHV0o0ZHlvbHpaTjVHMlZNZEJiU1JGbWlhWFowVDBpZmwxMTJZSEtPQUNXVlcwaEE5QjV4cmptbEgxMHIzRi9lY2ZpOHlRS3lkcnJTVURnZHR1aC8zM0EwWUg2QXpsL2FiZkwvL0RQazVVQUpOQzJEbXg5RjgzcytRc3c4OGxiMWlzQWlneitSbnkzVXdsY2QzL2I2YXcyUEg5d3hsOGlsRUYyaXl3d0xsbzdoL2s0TmVrNTIyTlBPTkFwNVJmK0E0VXJwcC96L1pCRkRxZUhQa2lIdVdNdWdncDZmbm1MWjlUN092VTdRNEFUamRtSElmTjltWkt6b1d4NWJrKzNER1puRDczK0RlM1ZQbm16WDkvSWJQMVVHUTc4alBPVmUwcThZNUkwM2F5SzVMK2NyWG1zN3VjK1RnbTlSRU4xN0hZYXltNjVCdko1QVhvbThpUkp6N2Zmb003VVBFaEtJVE0rWFZzZWpueFhvTHY3MEtQU2o2RmNhNHNza2FUK0U2M0tBRStWV3VJYzFLTnJLd2YvU3NQTE1Xem91ZVRlMUR0QzF4M3RsLzVUVmQxVk1yOXBKNTViTUYyd25QNWxPc3BiWWtsMHZmV3UwWGJYS2Y5NmZvdS93ZGJRVHhtVDlWOXV0VzV1MTFQS2xrM0lTbGNaMmpOQVJlcVkxSHc2NUVBYzVRaWQ2N2huZndRTy9DaEZPQ09mZjlad2ZaK3k0ZXdBNHNBdlNQWUFEVUR3RDhHendGb0JPakhqMXFrUDlPVVlKUVQ5czZBTDRLcTkzNml2Ly9QUmpJZk9vL2ovdTM3MVRUbDRUb1lUS1VUOE1Zd0VPWUVIOERCbmdkd3dDdkQyRkE3N3NBM29ETkw5T0luU0FyN0lBY2RBZDdYL2EvUCtyZnZqT3RSQ1Z2KzFnbUFMN2R2MzFIbWVoSGZ1OHJzS2prQ1d3ZUgvZyttNDVIdzVuMyt4ZzJ2NHhzL1FHQUg0OUh3Mk1ncFplbWNES0JnWmp3dnI4OEhnMS8xY2Z5R01EN29SL1gxcVNtOE11d3ROVS84UDZmdytiMWhmRm8rUEFhQU9ma2Nlc0FNNzFRdDJCamZCTklLYXltc05ySU5PREhDSGc5MHdTUkdiWDFDRG1LWUg4OEd0YWlZaWx3dmc1VFFONkc3ZE1QMTZnMzNNYTQ1N0Q5OFNKeVdxTUQ1R2lEaC83elBtd1Bmd1JMQ2YwWjc4c0xzSE41QU9CcjNyZHYrTDIvQTRzYWhvLzFFYkxUd052d3lPQzJmdis4TmxXY0c2di84Z3VBL0JrM1YxcUFFaWdGa0dxTXN1MzZad3ZlL2tDT1VHbktta0FVc3VqTnFXQ3dLcHcxZ3d6NzA0V0JHS29ZekpDTnNnUkxMdVU1bDBIWVZyQ1FudlFhU1RpVmEzVnNhbkNjYzc3YTVoTFpnQUprNzJVYXNTNEFMSGorZWI4dmE4Yi93YUlIL2g2ZjJlUjZjV3BZNnpXNTVtOU1lME9EdWhvM0djMHhoYzJ4S3NScnQwRVpFZFpwS2lub0JrdlNvZm45Qkt3QW15czFKQ1F2VkdRRGhScXErQzQxaU5Pd3NPMXpHOU1zTVJJamV1SXVHRjNhMWx5TnJMcm5xWGpydFhMTk5GdzNEK2VzMnVUTUFOa2p0K1pBbVZLSkI0VWplVmFqakxnaUgxN1ZHQkhUa2VjUTlJa1JZdVRYOCtidzZFTE96cFJHcThxY01pSjI3bnVZNENCNVFnZHVRR3B5ZlZGR0U4N2x2VVZrTFJ2cFQ1TzlqN3ZlUDQwYVowdkdDdG5iVzgzaEVmZVFLcjJxTUVkRmVzRTQ0UzJkV2QwWFRVNkR4cVpHSU5MbVZKTXdQRnRCTFFWV0dVVk1rSzB0aW9qT0ExMWtSdzN1RTYxYnFnWnhBaGZITUlDeGozeEdXUXJuR05sNHZZZThWeFNzNGhyM25IOWNhK1NRci8xajVFaU9aNVp1K2lwTnpzZGFNbUdUQWNocDJQdHo1QlRLRVJpY3dBRjd2NThPam5UZWpvMTZ4ZzZzWHJLdU9YV0JYYm1XYzZ0MUdDZnlQWkN6QUhCdjhCeVR6ekpDOWdLNUxpbnBpMFlPa2Y3My9Ebm5NT2NyOGx1bWF3WktnNkptaXBnSTMybHJDazVUOTVrTUxJcG9ESE1ZaW5UbXZEazhZdVlLaE84S0h1am5aUWVabjJzZFUvTHpHVXF3V2ZsYmpEZ2lzSnIyeExwN3F0Sm8xSjNYNlBXeTh5TThqWE53Z1p5UlEya2l3WHp5YWpVU2MxL290WFJDMkc1eXJVWUZXaGhKUy9BK1JZdEsveS9EYzlsNFJvb0lGVGpkYTd5ZU93Mkg4S2dqWDJzRlUzUTlWcFZIMExJaHM4RmlmV0lnbHlnQ3NzTVRmQzRmb3dUZHFMTkgyMTJ0RHk4Z0E1YWs5enN3K25BUzloWFRHTSthdzZQSHNxY3UvVG5NL3FLTmRXUm56cTlaZG90eU9lblhSTTRnQVN6eVJqbzRMdFN2ZERtZzQvT1kwcUJUMW9QVE5GbXZ5TSszbTF5UG5MSVY2WnJLejBBR09QbnMyR2drWncxRU5mZ1hvSlpmcjFGNTU2TGI2TDdVL2NwSWFHYTFnL1M1MmpoM1RnUEljK2tBU0hDYnRLVXJ2eTlnZTQ3T28reVRadFhUczZIZ1REeTdyQmQ3cmJZTzMxUG5rRkkvMXkwelBFMWJVMWNzR21sT2haOXozNmw5bE0vZFJ0YlRTWHNZekJJYjk4c1dzcjVKZlJ6SWUyR09jbTlGSUJMU0g1NmRuY0JIR1EzTTFQdFR1T08wbnozS0FkUWZWUDhpblZmWlhPMFMwVEdVZmFIZFlaVitycy9zaVV5ZnNpUHBEZjdkV1EyOEdTeG14cUQ5Y056a3V1alV1NUo4aTFKM1VQNFdTeHBSWmliZy96U1JnN1I5ZEd2UFdmUDhjQTQ0NzZxYkFabVBxVTdMTlUyT0F2NCswbmdDbmd0eXY5TWY3bWZWLzdWdHBKOXpIVmZjRTdOQ3JBWGNOYVhqVDV2VGx3TEM3QmZsaVNtUWFtMUhmclhPdTVOY0syT3RaZ01nZmFuTWc5SWIxVE9qdktkMmsySmRkSHlWOTdicHhNbU9GTWRjQTR0cnoxMEJLRWR3ZWQ2WVhiTHR1VzF5VzlHdjhQeWFmS0I2V01FWE50bVhIMGRiNWIzRkFUR05DL0FVQUtVRFcxUnlMb0JuVS9QWHdTeW1lSGtKQm9iK09reVlmZ3dEYVdnb0lhSHJJNmVXb1ZEMEgyQUFzSHJrWG5kL3Q3RWlwZTZ5cG1DdC83OEhBN0g2TUsvTFl3Qi9BNHZnUElFZjVGV2dtdnhMd3pickRyMkN6S0J2d2lLcG4vaDNwN0Q1ZllKY3A0VkU1UUZFc0hUUTdoUElSb29IOGwweHB2N3RPeGZqMGZBYnNEVGFiYURyRXgvakFXeGZ2K2g5NFhqT3g2TWhHZThwTW5qM0tiLzNyZkZvK0JCNVA5Qmd5RU4vQVhNY29LS3pjZXF0RGR1MjkrM0hzUE9Ydk12YjBuWnYydnEzNzV5SDFNdDg3NnYrMC9GM3EyQTJRVVVwMGYzcnFic0orblpnS1pSdkludUVwM1BrKzRDcG1tLzYrOTZHQWJQcjFrTG12b2xnQWcwU3IvdmZyOEFpMHY4V0ZwM2NneW0xVFBWMkFadHZPcnZzd1BaUUQ4QWZ3L2JNUDBVMnZsTElmTlB2K1JHOGR0T3F6QWMvajAwWWE1V08vaVF4eHArMkp1RFJyQ1o4b0RSTVVJbWt3cURldVVBMk5CV3R4WmhhQ1AxQVNyZFVHQUVwT0xzeU5uY0ZuMUc1TklvUytLQXhoRDhVb0ZVNVpWVGtIRm1JWnQ4VHdCMFVqb1gwcjM1Zk1ncldsQ1F4T3ROSWU0SE1HeExvdU1vSTB2YTlHUHNaR1VUZVUxTytGRmlmK0R6Mm1wYWFYbUo4aS9XUjFta3o3eFBUaXA3QXhuKzhvZUdqTzNCUFdCclZVUUpycE5ma0Rib0dxcENtejVvTTdOT291d1ZYZkpHTkNmbzNrQ085VkFGWm1rcU5yVGJlcUpCVWxBWHVTL0xMZFhuQ1hINjBwWFJSTGJRMHByUnFvN2RieU1hWFhqUnloRGFGR1NhaWtZOEtvYVk5NHZyTllJYkpWR3VyeWJXMXgvSmNHb3BTdWkrK2cyZUtSbmw1cnhvaGF5MHB5VEpXcm5PUzJRWjFBSjBHVGI2SDR5UzRXY2pGdW9jcXlxbk9mK3dmdis4S3pXR0tUejJqUE8vNlRGWCtlVzVvUUxuRW9uT0ROb0l4aVY0MWgwY25LTk9ucWpHTGMzY0xHWWlBMzA4bk9vM1U1MXpwdWFOUisxeitKcmd6aTREWjB6UmYwNThWdVl1Um9tZkl2SmdSdVRQWVdpbk5KTyttM011elJiNWEwNXRvaUZWNm9oRmo3TWN4U21EMkVnN2tPUC9sdm1LdDArUnc1UGVjSUJ1RG1jSlZlUzJCb2t2ZkY1UVBhRWdGc2tPRzltMWNBWTNJN3pxTk9WT2RSL29lK0RuN3cvMlpuRzVvckt2TW0wYXpMTFFWL0Z4NU9IK3Jnd3FOMW0zOGZOcGtSeW8rYjkxR3VZLzc2UUpHa3hleWRpeHJwSFZPL3lqRFVYWkwyYnRReXBoQU1DTDczNlM1WEJNZzc2K3VmMGNnaUk0Q0JLVzJZT3ZNYUx3ZVVOU3UxT2lQV1BOUDAxTFN5TmtOOGkzL3BrTUJyeU5kVkZyTU9yVmRJTWw2NUFFRXZ5T2YxUnFhQk9kMHY1OE5MTVUwUCs4aGw4eUl6MkdLMCsyQlJSY3JZS2M4Ukd0eVJvZEw4Z2FPU2N1dTdQdnp6MUJHWDFNR2UrenZPVWJXOVIvS1dXSlViOHhFd0hHMThRSGFCemdudENGY0J0N0I1K3RZZVpiNEhGMEwycDE0NzZXc1g0MmZVMlpWSnp0K3pqNTJHM09HNDF4ZW9Gd0RkVUlGZ3NPbThIT2VJZVd0dFpib041QjBHUVlKTU1CRjVXbnlpSDJZRFl5TnRnNEZyQlQwMVViWmk4L3V3aUtCQWFPZEc5R1NaVzBaL2YxcGEwMTIvRk5IUks2ekFxRDZFNEZhbnRkbEFRL3FJTXRyWXdTc2xoTUFNakNjSExtbFgxMTVCdS9YMVA0TGRnZVVUbFRVejhuUHRmeFBvc24rM1VMcWRkSHhFOSt1Z0VES3owblhycUtmTHdPRTZOUkdtemIzZitJZFliN1NlQnAzU3EzWkZ2eDdCdHB0Rk9IdTUxMzU3UVZNcnJxeWJYcVFuYTMwN09zWU84anlZbkx5UWRCWkEvMmt2RUorckhSUTUyUkJUMTRYRUkvWHJBTW1ocjlyK25iYlBRVDVvbHlaYk5zcWR3aFFIdTBhQzRDaHZrZkJVcmx2WVp4THdPTzI4WEM5dHNLMXFoL1RXWmw5WENoekZQdXRZMXRoNjFJNWkveDJaWG1xbHZtb3pVR3lTYlRkdzM3eSt0Qy9HczBGMmpHZnRIOHE3K21LemZNbnpyN2R0bkVJMXRLN1J3V1JyVm9LNUJYUG9iRUFjQWJ5cktJbi9aMTc4SnBWc0RIOEkxajlWNEozMzRBSnFtL0F4cllIMXRWNVp3QUFJQUJKUkVGVTRPL0I2bnZPWVZHczMwUTJldlJoQ3VMRmRRRFdCRGlmdHFhcmovTTFHR2gyRXhhUit3bGtzUEJYWUl6bDd3RDhPd0NuVndHYS9UMy9Fc2E4ejJEUnYxTUEvOXIvNzhIcXFMNEFBOEwrRE5rUThDRXlPTXg2VC9EK3ZneWI0eGtzdW5waFgwVXdlTTMrTXVwcElWMjNBNDZmOGZlLzcvMm5ra1BCaGtBaVFlUmJzTDN4QkJhTmUveXNvenQ5em4vTiszWU1BeWFmSURPcTduVUJ3ZjQrTXZNZDJQcCtHYmJHM3dId1NNK3JBNjN6RlhXQUY5Wk5hQUdmOVJxQWZ3WmJpeDFZaFBvSnJIN3V1NXZNc1FEWlpGb1VXbmRnOWEvSjhMWUIvTi9JOVg4bnNIMjk1Mzh6bGRVNWJBOXhmLzV6LzQ0T0VmUWtuc0NpZjkrRVJkbmZmNWEwN2FlMUJjQWlHdGQvQWY0K2g2WWdNVXF3UVQwQ3U4akdrQ1NraXBDVm9wS2lSMXVUdlNQVmNLYmU5cXpQMDVWK2FFUUwzemRHQUJWVW9LeUFVUW04YlVxUDVBNndYdDFURjk0WjBhQUt5QjZ5YzlpcGpIL0I0TGprMlIxNWR1RTU2ZlBJOUg1c3FZNXVrOU5NUTY0cGFrTjVIMm53SjVoK0Z0WWwxa0ZlWjA1b1NPSytlTElPV0ZvWmR3ZVNqalY4UGtjSnJ0TkFwK0FYOTVRYVFCYnF6T3ErMEwwcmwzRFBNNDBxRlNCVmZLSnhvZXAxR3NZU0ZUaW1wWnpKbWFIUk93RXRjaGJVRUZJb2YvSjNWNTVUS05IK0hGVmNLTDlRY1l0ZTF6eW5Hdm5HdnNWOXdZalJTUTJRQ00rbGNlZEMrcXlHTHhwTlNFLzZnM3QzeDM3ZGJzMTRTS1Y2MWJ2RDJOU2puRVpiN3FzaWNyakpLUXpWK0U0amVZb2l3Q0lZeXpsTFNyK0F5Z1E2U2JzMFRhNnVVd2VMNTVUN2dtQVpIZTRvejhUNjRqenZuY0VWNm52N014aFZweWw5Vlo2NkNYYytSRFlVTTRVM0k5SUlQS2IwNU1obmJJd01DSkxXYzk5OTdHbWFQNDZtYTcza21pMlVBRUVuckQzbmU0cnNvRXR3V0ZPbnNxWXpRVmdhSnFrbjZmcGdrT3VhM3ZUUG5pQTdTWE1Qa0NhZklEdGJzMlFVOXkwTnZnUWJhQ0JOMFVLY2l3by9KNkNtOVY0Wi9iQ1NCN2tjY0FCUHVTdWZIeUJuN1RqMStaaktmUFN3b3M2a25POWwvRnlqQzJlQm43UHNCZW5TTlBTUktSd3Y1VG14ZkFZZHVwaTZjeDErdm8yY2duZUd6UjI1ZU1hN1dPVG5PaVoxNmlFTm5hT2NFM1hXb0h3VG42bkdiUUtrQ3BTdzVOTXBzclBhREl2Z1ZwUlJFWGlBQXVrZFlLRlczMDMvay9JZkhSd1VqTjN4Ny9zd0kvemp3UHZKUHhRa29hd0taSjJTNytHOWZaZytUcDMwT05KNU1UeXpwTmtwc2t5bFlEdHRldHN3dmxPci82cXkvaXQrN3lOa1hzY0FpU21NRmlodi9UVE0vck1QNE9iZzN0MjNFWnJ6cTY2Q3Q4dU0vTUlINmZCQ09zZjVuNFcxSXYraEhFQmV4S2h4MGtxbFlYUUFVU2Nzb015c2tkSWdEektZemZWS0FQRGczdDJIWVQ3Snora1Fvdkpib1d2SVBhUWxWN0x2dUJ6R05TN2tTdThyYXhOZk5Ea0NqelNIL0FNb2dYZmR3NmVpLzJnSzZ4bCt2dmw1ZERLSjE4UUk0TWpQMWFsSEF5VlVQeWZOVjBDVytqajMvRVNlTVI5a1IxbDFERlA2bXVpeTd3bDFFRkdIRktCMGhBSDdHSFRtQmJCVCtQbFY5WFB1MDZKR2NKT2RWT2J3cUhaa3graVZhK0xQNk1oOUMzcGRjM2lrcFNJSktqL3k2elNyRHVuSkxOQzNWTnNlV1Q2dWxjTWlyVnAzVHRRNVpuWVYrZC8zNUFLdEVSc05rT1cycUQ4cmI2TStCR1Q2RldXNnFEZEhmWk82V09Ib2NGVTYyTlpVQmhDYm1PcnI4TzhYYkZ4TG5xbTR3U3FRdXllZnQ0TCtOVm1sNWIweDBLSHQydXJ6MnNiWTVEckhoYVBTMHphaEJaeDcwckJWNDR5MlNGMGpkZENPSlQ1cU5wb2s2OFRydkpGMkxOUFAxSG56WXk5UGNKVzJLZ1gwdWFmRjVRVFBBT3g2YXVpVndLWGZkd3VaWWMzaHdxRkhDSjQvQ3lDdGYvdk9HWUF6cjlONkNRTm5QZ2ZiUUM4QitFMFlFUHdCVEloOENjRGZSL1pPb29jakFkOUVXQjM4S2lKby9iUGtCWUJTOGVrQVpTUWovMzRhTUhrOEd2YVJVOVgrSVd4ZTZhMzlBTFplNzhJaU9SbjkyQjJQaG1lYkFQamVMbURSalorSHplZVBZRUFvNjd1K0RwdTdGNUhUUGI4TzRFdXd1WDhIV1lpbk45QTJERnhqZEZIMW9BbFF2akNQYmExLys4NWtQQnBPQWR6eXROSTY5N1B4YUhqZjM4MytuQ2tnNzMzNVBBeWNQSU5GaTNaODNJeWlUazBBL2U2NmZWeWpYY0lBeHdNQTM0Y3BnWFJvK0JVQWsvRm8rTGY5MjNlT0hmRCtCR3lkSGw0RkdQWnpTR1hvWkR3YVB2RFAyNFNLcmZGb2VOazIxcGJQcWJ6OWZmOGgwWDRDaTFML0VIWm1HSUc3U2Y5NTlvcitPcTE2RDFiRGVneWJ5MlJNUW83bU80YnRVU3E3TXdDL0I2TU5ZM2lhY21UbGtrYXBNY3dCNDhkKzc3WFZnZjRaYk5IanFtQytQNDBNOUtlbEJZRmJsVUFhWDJ0OFdKVWFDbDVKRUl6clJhRk9oUHlaUEVNTlVhbzhSbVdTUUI4TmZoTll4TmhjK3N3eEtXaE5yOEp6V0ZUTE5BaDBWTmJTT0lQQXFWN1AyaGp0ajhvOHFaSzByQ1hscWNtcEkrYytybUpNS0Ewd0thcE5ERWg4SHNJOStsc1ZXWG91YzU3cG1QVzQxbEV4NXRJZ3RvT3NBRzUwUGdmWlF6a1ovbWtBOUV0SXN4Vmc0N3Fyd1RRWlBzUWdWL09tMXJWTjZYOWtIN0FmaGVlOUdFOVNmNWZSSXYydTVibzVTaTlnTmRhazhUU1ZWRW5oZWZTTzVUTW5NdjVrR0JKZ0VUSlgvTHM2VDFRR3BiOEx4aW5wQTVBamFaWXBnaE9ZMHFUUjFUUXlBbUxrOFBPcy9lazBIdlVtNTNwV084ZnNYMFZoVFhwSzJIdEEzbGVkNXZBb1JnVlNmdGN4YzcxaWlsdmRweXJ6UjBNR2xjNVV6eENsZ1lCeWhQWmQwNjdXUUltYVl4a05VNHdVdTRxbnNaN0RTKzhIOTlsTjVPaUh2bHpMQ0NVYXo0QU1yRVd3ZzBad0F1dU1OUHVwVkpxdnFhWDU4WGxlY0dpSnhvZHdOdFdCU3lQb2R1RTE1WU9SaEk1V3ZDZkpyNFBzdUVENlNnUE5tVCtMUm1HbStTWG93K3ZWWVlmN09obW41VDQrWXcvRys4N0NQUEE4ZEdCMGpVYmQ3VUdPZkUxbjMzbUp5Zys2bjlvaTRobXhTbjZoOG5vQ1gxWTBBbUdNVHVWOVBlZnZTZytta09qckNqOVh1Z081aC9KU2NyanpzZk1zOHZrRTNJL1IwdHdBelRUR3lsTTNhb0dYa3A4VGJGSzZRT2RZeWt1NnJteDAwa2xyVjNsbGpJNEU4djRpSUVvbk5hNDE2d1dUMXBMWFQ2VHZDM0tyL0JzTmd1UUJDb1l3VXdMSDJaUHZ6dUZwbkwzdjZoUkUwSjdqWlRUdExqS2d1ZzF6cE9mWllSWXIycFVXbXA4TjhoZk9hUjlsMlJUT0dlV3ZmZjhzZ1pBVitla1VTQmw5T0ViMkdURGVBR1RBbW52MkRNRE5KanQ0SlZsK2tKMUxFTjVWOEM3UlZ4aXB5NzZUZCt6QUFmL0dTOWFJUEJYNU9kOVBlNkFDRnZ6UjlPdHpsQkhpQkprVS9PVjZiaUhMeWwyaFRSRVlXemdETGNabDVlZFgxWWxWYnVDN3lBUG9BTFBkV0ZrY1BWZnFyTXY3bFphcC9Bcmt1WnNBaXlVNWZnNmIwdWdGNEtyeWYrVG5PdGU2YndwZ01vQzlmQytka3BPRFZDTXA3ZjAzNVhQSy8rUUhmSWJxa2RSdDlhenlUS2wremloN3plQXdGOXFaNUFIbjUrZHdmczZIU3YrVzZlZmNtM0dQSmJwYzRlZnI4amc2eG5XRFByN2wvK3VhVUNaaEg4blBJMzNYUmxrcnlRUUIvQ1VkcFcwY1dNN1BDYkJ6djJ6TXk2VjEvSmxLdDlTQm1QUkEzNlg4VGgyMFpySTNGMmhCalphdDBNK0xWTXJMbnJOaGl6b3UzeEYxcnFYcG1ZTzhDbVJiUXFHZkk0UDAvRDhCNnl2R2t1WnhDUy9nMlZySGJsR2x6MUhubDJkY3UyNFdiQjc4ZXdJN2F4eERkRWFJZGp6bDdkckhSRC9qZkZYQTM1Z0JCY2owVGgzaW43cFJuN3FPWjExM1c1b0NtdUNzZzF1Y2tKc0Eva3NBRDhlakliMUpkd0I4Q3dZODNvS2xiK1hHZng5bFNvYXhQK01UTUpEMi9yT0twdlJVdEhOWUJPdy85SS9Kd041RVRrbDhBeWJFVWhCL0Z4YjFtRGFOZzd4OUdKQzZQeDROejJDQTFUa01YR0s5bFYveHNmOEZEQ1FseURobG5kUlFzelFCaHY0T0JaNlh0UWtNV1AwNmNzb2tlaHJ0ZU44ZXdhTXBrZXU0ZGpUeXVCYUZYUG5zTlJpUXZBVUR4UGFSbzZNblBnZW5NT2I3SnJMQy96bi9tUUQ0RTU4LzFnOCtodFZKWFJjd2V3M0FyM25kNUcvQmFoaFhRV05acTE3dGUxZzA3d1NXMHZrY3dJVUR4Z3JhNzhIV2NSY0c3cjNvZlY1SW4rM3pTQVdNelA0NjJtTVlrUDViM285M3ZCOFBZT3Q3MDUwY3ZnNWJpMi9obW9pMnA5MnVFa0FIbUs4eXhsZGhmZjhDc3NBN2h0R0xSekNBL1JoQUs3QzhhZlB6OWtOLzd6SHlQcDM3OTNPSlZpNGlrSHo4bjRYVm4xYmxrbnVXTmNYZmdrZVRQNHVVOWo4anJZMlpWbzB5djJqTDJ5WkNSUkRxRmN5dEFrVFM1a0FaZlZzVE1OVjRFNFF1alNKT0FxZ2F4dngrZ3FJZDVMcUFhamlrSVZScmoxQ1Fub2ZmT2lZQ2JZelNMUlFNRnhLbjBxY2FMNkxScTZiUXJPdEl4VWdwTlVqeFhvMEttTUFNOGtYYW1xYXN1MG1RVy91aDBjQ244amZsTmIyZXh0RDlRYjBlSGVEUlhvTjdkOC84ZVR0WWpEeWtRVzJPNVJGSWpOSlFReE5sU1VhOXpPVi85WFRuejl6SFdSaUx4Y2pRcHZnd25hOEN6Z1hvSCs1TFNsL0xXRlkyVVhDS1BkL2sxR3FjT3pYcXRDbDRoU0ZQdmxjREFyL1hmVThBTXFVSGxQNnBCNzhhanZSOXFwaXJJa1JIaS9uQTByVVcvWXFLRzVCU3YvT0h6K0srMFgwNWg1OVZaS0Rxd28yVWZYK1hPazhRR0wrVVo4NlE2eEpUQWRjenh6blNlV2FmMkQvK3ovbWhNbCtBOXpJZnlZZ3FZMDJ5QXRjMUdPbjV2V1pTMlBIcngzSlcySy9VM0xqUWRVTTZ3US8yajNWWEY0QmlweUhKNlMzc05lNFhPbW15UllNVzU1UlJ2ZXdiMHhKenZ4RVVwbjVKR2p0REdaMFgrOGo2YlJlVnZmUmNXcUJycWRiMmRiZEJqamdGM0Ntbk9UeDZzQ2J0WWNSdEI3YldsMzRlZCtIUldmNE9QYzlUUDB0QVdRdHZJdGNRSk9nM0JnYlRPVkpUSzlQd1BKZm5YRFFaUE9aWkpKMVJQWkgzTWJKVkRYdzhGeEV3VkNjTVBWK3BMaXV5VTBIWERlQ3NOVmR6Y3VxZ25aK3ZxNHRPa0d1MmNyek1icUFSN3BmSVVZVEt6OVVnR09sZzBZOUc2cXQ3MjhNaURaczNoMGMzQmg1bFhHa2RtTkg5b2prOGV1UjlMQng1UkVaY1ZaOTdnbEltNU5wU1R0cEh6Z2pBejZrM2tjYk9rWUVJcmpsZ05IMGJsYXdWZmcvUEplblZKVEtnVDlvVzExV2Q5Z3A1WXMxR25zR3p5clhhZ3BjVWNkcWEwcGNLT0tQeW9aNkJCRXI3M2poSGxzbDVSamgvNS9MdVJ3aEd5eWJYY0tYejlpVXlVSkhtVUVBZkJYZjJBT3k1L00wMDdTcXJuY2tlWWY5cFg5Sk1XN2Y4OTRsY0IyVEQ5QTIvOXRSQnFGdmVsMU5rdnQyRHlRdGovL3VHai8wbXNsMkd6aFlxKzNPc3BGL2srWlN4eVk4NEpqb0xLRDlmY0Jid3ZuT3R1R2RTalU2ZlQ4b2V6SXluY3ZBdWpKK2YrbWRjSTRJcFhWKy9EdkpaWUVRdHYyZjZ5QVVlMU9USXh4by9Wd2NjYll6ZTVsbmgzSkdtVUo3aCtlVVpVMUFZbk1zbE9oUDd5SWpXdGJJMlBJc21aM0dHWndoU3kvb0JtUjZ0bXc2YnpsSEpNY3VmVjBTbCtudTQxMmV5MTZ1Z3FZQnhQUWVEaStzQ2tBTGtkUzJBVk9kWHBFdmtaK29VbkhpMjkwL0wzZ0NsMDFIaTU4THp1eWpMTVhiaHVzT2dkRTVwYzRCTTlqeHRHOGlRMGZHYi9IeU8wdWt4WmRzSS9GeWRSK2p3cHYzUTh4dFQzZE9aaTNTcUE1dS9nOEc5dXllb3Q2N3JrMU5ZZlhGMWRFMnRPVnpMSVZUdEgyeHpaS2ROM1NQazU5RXBJT3JuaFZ4UmV6OWxUZEhoZ2RLWnJ3b2lWOGI0TklFaldzdTkrdmVLOTZqTlNXMEpxcDhuV3dCS0dRQ28yTjdDZTlKOExCbWo5b0ZPRmhzNTFzb2FkNUYxWndYKytaMW1rOUQ1VXZzS1pMeHE4eWljMkZ4ZldBRDMwZUk0UUx1S3pDdlBTVWZvRWQrZHJoa0VtMlFZYXhxVHZGdHRBYXZtVUdXc3Fsekp1WkgzdHA3SFpYdjVLZmQ1YTFzS0FMTTVFRUxEekZkaDBaR2ZENWQxQWZ4Ym1GREhOTEpqR0poRE1JbUU3aEZjc0hqV3FYUzlmUXJHakFud1RtQUFHbXNXaldIZzB3dklxUWlMeUZOa2dmNGhUTkI5Q2NCdndBQWdSc0RlZ0tYQkFZQS9BdkM3c05UTGI0MUh3Mk1CMUdmeWJHMDlHTUMzTng0TjJiZEhDTUNTQThpYWV1TEhQcVlic0RxbFl4aGpZZXJnUjhoQWRGTGlIVHljd0tKSmFiUmh2UjJNUjBNYVpQNHJaQzhseUZ6d1dYdkkzdjlkR0xqL2lYRDkxL3h2UHVjQ3dNemZNVzJMV3ZXeERtQTFZc2xvZjl2bjlFM1kyakFGMUJOWTlPaTBmL3ZPZy9GbzJBdnp0Z1ZMcS95cXo4ODVjbHBsUmtuL0dCWlovVHBzandBR3NMSU84bXc4R3ZiN3QrOGMrek9wRU0zOHVaOGRqNFlmQXZqZVU0S0JXN0QxL0JReWtYOFZCZ0ovQU51SFQ3eHZ2dy9nZi9YL2l4VGptL1NoY3YyV08zNHNyUm05eG5NSnlGL0E1dmdUeUo3Q0g4RG1uQ21XSnV1K2l6Vi9sMFU4Kzc0K1JvN1dUZlcyeDZOaFowbXE2aTFZQkxCbUJTQ2pvd0hyTVl4dXZJdm5rQmI4cDdFRjVsN3pxUHVKckkyd2JoTUI1SGxITUZNSldIZlBKZUZjQmZWbGZWN24yUUo2TEFoTU1pZEw1MlZRUmlsc083QXpRVTdsQkhoa0U3SkF6TStCck1CdHdkTHZuY2sxcE0ycTlKSnY3YmlCZFpuaGR3THptdSs2TVdmaitqbzYzNDJrZUVOT0NRVmtJeWtWeXYzRzZuTnk3Q3pyTUljWjdUamZFMVYwSyt0SkF4ZU54a251Y01ObGtiTE45M0pLd2UxN29GQmFCWGhLeHQxbU1hcVNqYnhMNTM0TG1SWm9yV01hUURSYWtoN1ljeEhvYVVCWUFJbGIzcTFLSm8zRWNlL1hoSGZXTFFJcW5xbExtb0tBYkZSMnA4QkNqWnlGL290eFpDSGlOaWhCcW9EUzBFQ1A5QjZRSXVPcEZQTHpvZzVaYmUwR0VqV0FZRkNVZlp4QUY5SjFmdy8zbkNyeTNIL3o4RGZuZ05Gc25HY0ZKQlVZVWhCYkl5ZW9YMERHbTVSSHpvMEFYZWtNK1hkZEI4cGlSRnQ4ZDFSMFZhSFUvK082TVpKUzAwK3E0WG83WEtzcFV2bjNMbXhQY280bzB5ZERlaFBxaHpZNXhSM250TnNZME16K1BVSFlrd29JSVpmQllQWUFCWGtWMkFGeXltMDkwMUhSYm12c0kvZk9jMjFPRDdVY0FhUExubFZmK0Z5V0lYb0Zybk9Fc3hTYk9tWE1rS01iQzlBbnRvR25XMS9CMTVsV2VzRUFodXhzczFDdlV3elQ4K2J3NkxHQVdjeGNORVpPTlEwczFvZFZ4d3VleXg0QU5RSVROSi9ML3dvME1qVnRxNU1COGx4ditSbllPR09QeWpSQ0I1bXRvQy9qNmdxdDJYVytDbVQ2ZGU0eXliNmZaL0x6V1hpWE5uWGVZZXZDYU1JK3pJRXNycTlHSU05UjUrYzkrWCtHNVdtd2xaOG51VVZrQjNXMklSMVJHWEdLN0lCSEdZRFByUnF6L1RvZzJ6eW9kNThqejZVQ3NBV1BhY295R0hDZXRYVHQ1WjFhSDVXZzJiNC9sMm1ROVZtMU1kQ2huSFlZclZPWE1tQWcwOEF4Z0pNd3B3UnNZMTN3YldRSHcvN0FIQUpyaml0em1NNU4ydDJYNy9qdXJjYWMvbVlvZ1FhQ2pjblpBaFc1QUptUEF5WTNIeURMN1Fjd1hzTzkxcFhyQ0FDOWlNelRPTjlBNXR0cXBKMGpBektKcmczTUdVYWpIVW5QYVB2ajM2UVpiQVNuZEgrUnpoS1lVMW41ckRId25EV1A5VndWbVgyY05oQVExUDJ4Qzl0SG5LTkp1Q1pGRmZOWndwdHBxeXdjUlp3KzEyb3FrM1krUkFhalg0VFFLNzlPVXovVHdZeDBXZW4wcXFici9OeHRJNzd1Q3JoM0duTmVmQ1o2dXNnSnBFTjcxRVhYNE9kSjVoQTlkVjZoNWNYNzFyQTdLTWdhbjhWM3JISnl1M1I1dEFlakQwRHBRRUFaVC9lRi9sN0d6eWx2cVU2ZjVHay8xNnYwYzhxMEN5blYxMmtWZnE2NnA1YXc2Y28xdTQwNTdnQ1pOekQ3eElHZTV3MzJXOVRQbWMwbDNoK2RBbUxFSk1mQTUyenF5S2p5QlhtNDZtMUs3N20yVlNjRXJLWVZxcDlUN2xkOWxjK3M2ZWNFUFpjQ2E1VjdFcmdwOUlCWjV0YWFweUQzcmRMUDV5aWQybElXaVVyZkdiQ3dGRmlVZDdHMk5ubENXcWNWTktmb2I3REpSc2VoNUpBUjU4RFhtdnVEZXlYUm1pWkg5YXVPM2theld0ZXd3ditLendkMU1CbmhIc3FobEVGcjYwWjVmU1hQcXRrMkszUE8zM3h2VlJmbWZxS05xRzFQWFhmYkdvK0dOK0NlbEV1QWx5NU00UDFEQUY5cHVlYXpNTVhySVhLcVF0YUhTdEdrRGlpZFBFZXc1Q1pNNlB4L1lRUjYzL3Y0UWYvMm5lbDROTHlBZ1ZBbjN0K0hzRFN4NXlnUEgwRlhDdWk3c0tqVU4vemVyL24vckltN0N4TnNmeFBBRzdXb1VYazJhNzcrT3JMeDVBRG1XZGtEOE8zeGFQaEE1b3dIblNsdDN2UFBIOE1Bd3RmODJZeDRaRzNBUzNrMklKN1l5QUpnUjY3dHdjQTZCWC81ZnZielpSaW8rcnIvL3crUWpiamF2dWpQL0JEWmM1ZUNlUFhReXJ0ZVJla2xkQXdEdXIvZ245OEg4SzlnNlkvVlFIL2dJRGZUUUhkaDBkb3ZJNmVPbXNCUytQSmdjbzB2WU1BNXZUc3ZrR3NPOVNUdE4xTVVVYUQrSlBKNlhLbjVzejhCQTdxQlVwbWxnOFZudkg5L0FZdHdmOFNJNlBGb3VPdVI3NnBBcld5VjgwL2hhbmM4R283WGlkWnVBWjA3c0xuN0ZMS3l4MVRpMzBBR09GN0JrdFFuNFQxVTNtWk9VeGI2NzJ1L0MwbXg0aW16dWQ5NkFMWkRxdnMrVENuYWwwY3BZRE1EOEZldzlPWS9BdkEyYk80L2xvaVZuK1FXbVBHQ01NZnYxMUJpZmlLYjlwKy9yM3NjUzU3Sk9keGFKZHo3L1F2N1U5YWgxU2pjVkx4SUs1OFZYbmZJd3RPV0t4L1ZsQzZWY2FseVFSNUVJZmRFM3gzdVVmQTVBclF4T2xXRjFlajVxLzFUMElUWEVoeTZjcjNOUWZiY25xT01wRXExZndTQW9uSDdES1ZoQU1pRzBIbHplSFM4Qk1BN1JWbmZpNkFNNTJUWDk5aVozTGRLTnFQUlRCM0tkbnhjYWpEaXVzZlVrUXBhcTJLZ1FDRTRMOHVVQWdIQ2F0OVRPZUorNUw1YjVtWGFFNFZLRlo2ZUdFTmJteGlOZGR3Y2UzcXVuNHRDU1doUlhxb0tZSk1qRlRtVzJDOENMQWx3ZDBNN0FkMm81TFUxclkzRWZtaXE2RmdmZks0R0IxbWZWRDlMKytoOW9vRWxSaWR6ei9OTXAyY05jZ1F5QVd4Tk94ZjNUSngvdG0wSTROSWNIaEcwNHJXcXROT29wL29BQWVPby9QSk1VNTdVdXJwVFpObTYyeHdlYlEvTXFXUUtpN2lxR1ZJMDhvRmdBS056NThqblVWUDBRdDdaUVk2VUkyREFyRXhWUlJabEJCRG5iUTg1SmI1R0xsd2lPL2h4dnRRcmZGMFpsUDMvdUdRQkJjSTR0K3VDMXl1YnI4VU4yRHJySHUzQTljYm04T2pWd2IyN0gvcCszbkdqWmpRR01ESSsxcC9YMnBSdFdSbTJHb3NHU21PaWtXYVFTeHdrZ0E1Wmw3MUFqakEvbGZFQVdXK2NEa3FQZTg0ZkRmRm5nNXd5OFRnOGcvTXdSNlk1QkdTMGFVcEczZ09VNEZUUjVBeHdiZFA1ZENOcloxQUJ0ZGRwM2s5bUxlSHprL09hLzU4Y1E1eGVYUEJlNlEvcFR0ZkJuRFllZkk3c2xLclBKdDNjY3o2Vm9vZldrRW1WNWdGdVcvQTlwbnA4b3A5Q2E3dmVKK1hueVFrbjlBMm9SRVFMTHlFdHFZN2RBVGM2RmFTSWtvSFVYZlhyTkxxTnRKRzBqLzNvUmNONGkxeXFnQ1BIcUtDaFJva3FqV2RhVko0QkdwMjNXdllhMCswVE9JaTFWRy9BMHpyRGdnOW9ueUROWmZhM0JjQlE1b1VsWEtaTlRtMDZRNjRKVHBCekt2SUZuVXRJWnhqcHpuSHJITkU1aURZUmphU2J3OVorMGh3ZVBmSDcrTXlKcnkzcHlMblRPSUwySjRNTTdxWjAwZkpld0l5bnBGTkpudlA5UXJsRDVVN1NPTFdwYVFrSzdndnFJVE8vUHVsYlRYWm9QRUVHb2ZnOW5SSnFJSWJTS0oxUDVlZWtVUnF4cS9TU0lEOVRzRWU2V0dzejVPd0hIWmk5QmNqMGgrZjBISGt0RmZCTnRIbkZlOWdZTWY1eDhmUG9tTURmMTlZZjU3VzFDR2Z5bDUzQnZidWtlVlhITnQ5ejVPY2FrVW1aazNKcXJkOVJsMGhaZnZ3enl0WDhqblpzeXFha3VRalhxSU9LOG5PbHExUGY2M040eXZLb24vdTR5YzlyNDQvN1ZwMkgyc0FTOWtGbHpCa01wS3FXMDFpM2taOGpBOWJzbzBZc3Bpd05rWjhMVGFBVHhYWnplSFRXc25aQXpwckJlYU9zVGpxdzNaaXprcWFkWHJWL294NnB6c2VhWnB2dm15UExlNFZUZ09penVnZTRwMVpsQzFscVN4amtDT05reXdCVzF0SFdjeHhseDVWeWV0VFA1Wm1xQXhVMFFuVEx0ajdVOUhQaUtPcjBwdDhyeUxqbE1oc3ppblJrTFZZMjZtL1VUU3ZuZHQwVzkwVnllcEMrcG5tUzkrallGRlJIRTRKVW1uYVFQYTJGM050VzVnbG9BWXNESFN5QTRxWjBtazUyaThwekZOVGVhQTViM2svNWo2bXVGM2lvMEk1YThNQXphMTJZRVBCMUFLKzNwWHoxYS80eERQUm9peHArQzZZWVRtRkU3U0VxWG1nT2xEeVh3VG1vK2dTV252WHZZTUR1WDhPaU02a2d6V0RBNlFNQWZ3YmdyL3UzNzl6djM3NHo4NSs1Z0xWVUl2WmdxWTI3L3Z6N01CQ1JCNTBMU1VCNW45R0tsVDd1akVmRDEyQnI4R21ZOEhYdS9Ya0hsc0taeElMUmlUTi85aG1BNy9uNC90ekh4N29rWnpDRjRsWGs2Q0ZHSC9SaFFOd2NtZm56dVorR0FhdGZCZkFIQVA1cHkvUytDbE5FL2dDMkx3cGphZVg2TjJBS3kvdXcyc0gza1kyUlBaK0g3ZkZvMkJ1UGh2dmowZkNXcng5cmxxZzNJVC9uTzE4QjhCVUZmeDJJNUxydWprZkR6OERTZ04rQXJkRUhBUDQ5TXJoTGNJK0ErdDhDK0k4QS9oVEFYOExXUVkwZ05Jd3c1ZDRVQm03L05ZQjNuekw2dHd0TEpUNkc3WUh2WVJHc21QdFl0bUI3VEFXZVZITjdQQnAybDV6cnBjMzNQdE43THpYaSticHRBK2lPUjhQWHhxUGhTNzZHM2Y3dE81UCs3VHZ2dytyOGZnQ0xpdjhMNytjSjdHemU5M0dzN0N0ckxhTk04VlM3NzFWNHluYi8vNUxqZ3AwTi91eDVkRGc5Zm52SWpoUHFuVW5hZGdKYmw3ZGd6Z1ZYRWpaL0hsb3dDUDVNdFk5NVhFa0JhZzZQdGxyQW83VmIyLzJEZTNkcjZXU1NZYzBGR1ZWTzFmczBHV2lvSERiWk8zV3JDUjZGV1BTU2k4b0RvNU5vbkdMRUZnMXlWRWkxL3pRRWJUZUhSemZnZGZjRzkrNU9CL2Z1MGlBZHg3OEZveG03L3B2UkcremJXblBkSEI3dFZzYUl3YjI3Tk03UFVkWVQ0aHhld3VRS3ByTzhVSVZNNW9VT2Rsdk40ZEZlYzNoMEVOZHhZTkVnSjhoeXlYUmdZQzk1N3dXd2tMSnIyWmpheGs3WkNONXYxb3Jyb053ZnRYVlZKd0ZHSWw3S1BISC9xT0UxUmNrdU80ZGlTSWxLWGpHV0pxZmZvNEdrSnNOVVpialFKKzc3YWVYczhQMHpaS1VjRUk5Mytic0d5bWxUeitKekFBcEF4UGVsSnZ0T2pVS3QrMW1WcEVHdU8wVUZOU3I0eVNqYlpPOW1vRFJ1UmlWelM3NVg4SEJPSTg3QXdES2VCZjE4UGhBZ3pYOFhxYVhFSURXWGR3Slp1ZFU5eGY1TklDazkvVms5TWZ6QSs4ZDZocVJMYWxDbllWZnBFYStqUXduaysyMFllTk82RmsyT3ZOZitNcXJzeFBmQkJSd0U4R3Yya0dzWThuMWQ1QnFRMWVaenlET3hqNXd4UjllSVA3VjlPdmUrTEROK3hjWnp1dk8wL0d6VFZqbUxRQVpEcjdQTmFmaFNZd2JFNE5BY0hyM1dIQjdSMmJUYW5IOHRrenZiMXJZQTJKb2NIYzVvUURvY2NTMVlXb2o3bG1lYk5UaVo3WXRSY0xFUHBCbFRvS2pEQ3VTSS95NnlReTZCTEFDTFdSZmtiTzgwRnZHNkErTUJrOEc5dThjOGsrRTkxTlVXbmkvZnIyeU5SZW91WERzb25abHE2U2luZzN0M1V5UzVyNTJPaXp5Unh2Q2V5dzRMNThEdjAwaHFSanhyaWExTitYbE5mMUk1anJWUFU4UzY4SkVZR1RrSFVqWUtOUkNtZE5oK1hhY3l2cFJWWklrOE9rR09vcDJnVEZXcWE3TU5qL1JHanVCbC85Z0tXMWJVVlpyc0FIR0s3RXl2b0pidTdYMlJUMmhqb1F6SnM3UHN2UGFRN1JDUDRlQlI2Q3NCUEQ2SFBIbmlZMlgwK1RLNlBwVitjaDYzRzNORW1nMnlZeVBsR01vS3RFSFJzQTNwanpxYTkxRTY4VkJPWjJRcURkMFh3czlUeHA3QnZidFAyQWMvNncrZHI1R2ZheHA1OGpJZ0F5WjBkbVRqdVRvZkxQSnpkYUNiQVRqek5kOUZUdjE2QVpkRnZVK3FMekIxTDFOMXArL0tGbloxQUFBZ0FFbEVRVlQ5dXhnNFViU216QWJDOU16TXduY3VhNnYwVEs4RGNxQ0s3cFcyeHYzY2wvRnBKS2NhL3FNQlBNbEZhN3lITGRIWGo0bWYxMmpiZGV2c3F3RHhtZE81cGRrMlJiNnV2Z010c2tDOFIwQUVkZEtkZUQvSTYxVnU2L2k1NnJtT1RBZkI3UXF2S3h3QklMS1IwRW8rbjlrRTFLbHVJUkkxOFBNYjhIM3NQSExNOFZYMGM4cTBTUjhmNUdqRWRYbmZUb3QrVHAyQytubU5uNU4yRnZ4YzlNMHBzcnpjODNjdG5GRy83OFRmY3duTDRERkdxWjl2YXQrcFhjdTFaMmFEeE45RDN4ZnNkVUtuVmMrS1RvU2R1RitDRGxodE1sOUFmVS9wczBqMzFPbXF1R2JadS9oTXlpT3l6a2xuWnovMFdmNTNWOGFqdW13YlBhSHNPeGxrQjVEb2tESVBQem9ubWwxcHJhYTJrblh2a2V1Vmp3TForWWZ6b2pyS09tdkt2eVBRMmViSW9uWjJ0bTVjMDdnWDEra0g5UUhadDdPd2x4R3ZxOUgwZFdWcXY1YTBrTTQ0bEprWG5HMkN2akpEcWI4LzA3WUZpelI4RlViMEgwUHE1b3hIUTBhNS9qT1lNTlAxNzZsc3ZPeVh2Z0VEZEU0aFJoQ2dudUw1V2RiSmRCQnFHNVkyK2N3L1kyVEtRcFN6UkNaZkFEaGYwamVtZ3hqRGdNK0hNTkNLQy9vT2dPL0E1dWgxdWU4Q0JoYjN2Qi92d2NEaW16QVE4MlZrZ3pvTnYwLzhPVlE2MUhDbUJwZExXSXJ0U3gvRGg3QWF2TWV3ZE5ZbnlNSUErMG1ERGpnbnlNYXdmZS9UR0JZcCsrV1d1UUFzbXZPL3EzeCtBUVA0NXJBSXlYTllPdXdmK3ZPL0FBUE5UcnpQYzFqYTM1bi9UK0NjUm9tdndhTEx0Zld4Mkg1L1BCcWVBL2ozQk80OXZmUnIvczR2d3NEZ1AvRitQT0wrWUJ1UGh1OGhDOGtQVUJwc0FadTdXNUNJTGVTMWVBR1pPYTFOS0dKelI0RlB3b3dxZndFN2J6VHMvVEt5ViszcnNMMXhIeGJabXM1WlBITVJBSzdWZlY3VzJtb3R5L08yQWZ3T2JBN2VnKzNwQTlnYy90VjRORHh4TVBseVBCcituZDlHd1czaWEvVm9nejUxUEdKM2xTY3FhUlhnM3N3K3Z3ZXdNem1HN2FXWFlPRDl0bi9HYzFNVDJvOWh3dWZiZnMrVklnR2ZWNnNZa0o0YmFMbnFYYyt6TDgralBZdnhMSGxtOUJLN3N0ZllDZ1cyclNXYXNLU1BjK1RVTWRHWVVBUGlOSHF1QTQrNlJDbjBYeUFyZjR5SW9EeVNGSWltakdybSt6c3dCV2VobGxBWUE0VmVOWWJRWTVEZkwyMU5qbDdZYml5TjZNSTlEZ1JRVU93MGxqNXlaWnJwZ2FYeVpOUlJCMmIwSWo4NmFDektReU42V1J0T0d3RWVOZlN0YlA3TzVBR01QSzlUNVByRjNTYlhUOU9JeGlxb3FjSzR6Ky9DbnBMM2FsdlpaeXB2eUx5NmJlM2FnQ3h0cmVzdVNsUW5Ham1ROTZVYVoybDhBYkxTbytjamVzNnFaNnlDN1FwYzlScjNMaDNrZE1OY3AxbVlaeDFyYTVRakZkNG0xMUxXZWFJeGxPZHJKbnN5am9sOWpNWTRwUTJxQUs0TnZGRXhVOFZPREZKZDVJd3pIRXNCdkpGVzFQYW5HTTFvM0VoNzJ1ZVFmYWJSaDg0dGpNb0NnQk41SjljdFJUUkpYMXIzbit5djVGVGhYMjNYNkpsY3l4cVMzSGVVclFIYkx3Y3dtaE1OaVFxY1UvNThRZm9ZRFlIVXNmamRjY3N6dDdFOHZTenZqMk4vcHZLQzcxdW01Q2NQS2lLeXI2RnRvZHdMYkFSQXVYL21NQm4xZm0zTWJnaHJUZDFJQUlVMFEzbGhDMTJkdzhIWlFZNEM1cnVBQU9JaU84cHdMOUo1TmtZWU1iMmpSclF3SlNzakNxWW9BUTBnMHh2b2N3TS9aK1B6aXpGVnBrVjVYSXFROHJHdmxPR0ZuL2NheTdoUjQyTXpHWCtxVWI1cUR3M0ttcjhkNUhJNGMxaUdqZ0xzSDRRYWpYN2ZGQ1lIbktQVVM1ZTJRWTZNU0ZHc3lESkJTcS9iNUhxZXBIYzBGc2M5V0syZmgwWERja0h2bXV3NGxmb1YreXFnMnc0TWVLVE1rNTRwWjR2Z25vNUo2ZlZTZWJuSnRlaDd5QTRSbkM5bVlTQVl4L2Z3ZWpYY2twWWtnN0hRY3U1Qk9pWjBVSlptMkhkK2Z0a2NIdDFIem1ZMVE1bnFXL2t4KzFXdFB5cnkwQXpac1lmNzZaRmZzNDBNL0JPSTVwbm1YdUg0Tkl2TkRCbnNWZ0NLUEdTdDV1K2J1OUZVNlFvQjdsUC82Y3AzbklPK3k4YlZzaGJDejhtYkNhenIvcURNd1BuY2FpeWxkTCt4aUtaVGtYTUk0QzdzUmF6T2ZFR3dtdk05ZzBTQnluT1UzakdMWDFmK0IvSysyaDYwWnlmaTNxZmpLTzFvWENQU1krNEh5ajNSZVNPMVpra0dLcFV6bzZFOWZuYmRUZWdhOXllTi85ZjJUdWVYYmJxYU9nd0RXWGV0UFlmUmxGVStNUkNuQSs2N0FMSVVmNnVPR21WYTRhdHNkS0xRTThROW9KR0ljN21HKzJqTDExZFRxODZROTAyUzUwV1BJTTJyOFhQcUtRdnoxTUk3b3ZNcDIwcmRRYzV1cnluTG9lZzdtUW1oSi9lazdCeHRleW5LNDY3WE13dlREb3gycS8xa2daOGpSTjl2dUcrcG53T2lodzF5cVMydTZYYThjVjJiM1RYcjV6d2J5K3dRdXNkaVcwdG5GRDAxcHZMWGpDRkpMZ2g4UmQvRE9haWVWNUVCZ1pMblV6OVBUcUJ5WGV4N09odnh2RmZlUjdwQTN0OGhEK1QzM3Q5NXZFY2V3NzlWTjlFOVdOandOdG1QYmZTZTYrSDliSFA2WXpiV1ZlK0lUcDM2dnFMZlliN1VpYWFnVVZqY2EwdkhMUHNMS0IxVFd1K1R2WmY2M0VoV3UyVnJ2MnBmck5PMllKR0dIL25QU3c1U1RtRWcxT2RnQURGcmNaM0I2blYyWUtBYTB5N0I3eUV3d3pTd0czbFByNnBaS2tBV0YxUVBHUmQrSDhCVW4rTUEwN0lVMXd1Z1dhWE5ZTUFRWU1EV0Zrd0lKU05oL2FZeExNcDFEd1pja3NqK0NtdyszMEFHazMrQW5QSjJ6KzlsQk83ZklFZnpuc1BtZm81c0tEaUFSR2I2M096NjgvYThyeFBrK3FkejVQb3ZyUFBiUlJaU1ovNjh4N0MwMVY5WU1SKzFkdXhqK2g0eWNBa0EveGZLbXNCOVdldTVnUEJjMXc2eUF0T1h6OXJhdTk3L0x3UDQrbmcwZkI4MjkxVEl2Z3NEb3hrWlBVTTlPbjN1VGc5TU1YVURGckg2UkFESExrd0pHd3RvM1lNQnpaK0V6ZnVQR2FYS1dyenlmR1VxSk5nVDJMNTlEYlpIWGtDT29PZmFVd0c4Qll0azV0cjlzRGFXT0M3dko1bitsMkZSMkU4ZHVlcnp0UTliNzMxa2hlRVIvSHlFczZnZXR3dDkzTEJ4UEF0bmV6d2F2b1JjRzZrUGMxaDRHNWF1L0NGc3JUN2pmZjBCN093UzJEOUg2UUUvUjQ1V3B1UEhSd2kxdVg4UzI3TlVzalpwUHluOXVPNzJ2TWZWWkM4MEJWT215SUxpQXM5VmdHVEZzeFZrWWhSZVRXaGpxdGRDZ0JuazZGVDJyVlVoRU1OaU4xeXIwVmQ4Rm8xcUJGcklCMmZ5TjQzWXU3eW15ZEVDTkVRWFNtTlFRblY4SFhoOVB2K01kWnpJeTFzTk84M2gwZTdnM2wzVzlrdnlRZE9TMXRHVnpER3lvNVlDVEYxWVdycFdoVmdNa2t3SmU0NXNaR2UyQ3FiZW8xSStIK1NhWk5zQWRwWVlqWlkxNWNubjBxZVo5NEVBUVpIeVNQZG9UWkhrMzdYOUdONi9WREZ1Y29SSGNpZ1k1SlM5N0plT0l4cUlFWDVYWlJBNWszT0lzdWRqVlZDMDlvNW9pRjZaMmdqbFBxYlg2cXl4VkdIUktES1g2NWppVVBzeXErMUxhVEhGY3FRSE9nNXRVZm5pNzBsY1k5aSs0Qm05bFBmeDNGK0dlMUthTjMxL2swSHFaR3dQejRwMFJwVzFXZGh2bWlvdDdnYytSMVBLenBGbGZSclVhTGpyRDd6K0tpcnJMc0JHMVdEdGZhS3hsbnVyVFptL2hJQXdmdFpTT2wvZi85UTVEcENqTmhZaUxadkRvNC9DdkROZG5kSjU2aExNaE5OQmUvcGhSb04wSVFCRmsydGZYZ3p1M1QwTjY4QW9aRFNXRHZtNkkzSlRHOXk3ZSs2Ry9wVEs5enFVYkNDdHNmYWR4a2ZxTjR6azFOcnFyemFIUis4akd4TElhNW1LZXhYQW9LbERkeENpTnZ4enJaUEltdDhFbUxtbTNOL3FhRVc2U3NNd1FSOW15MkI2MGxuNDRmVTg5NHg2WlNSZFlXenlmdE9JeG5YUmFQdU8wS1plQkNQazNCZVpBZUQwMEM5Ymw1L3ozT3d1NGVlenhsTkNJZ003ZXM2M2xvQUd5cys1RHliSXNnem5pS254azZ6ZzUvb0VIclVmamRCcnRNaWYwaGtXZnM2MVlaa0twaC9WOFdqR2lBZys2RmxLOHFYd280V0k3OUJlUU9uVXNnZmdzZlJMQWVvb2cvTHZOdGswTmRrenRJVVJmR1JOOEVsandBY2RYbWdISXgrTEdSNlVIM0hNTVRzSVpTV3U4UVRpRENnR2R0TC83ZWJ3YUg5dzd5NWxUSTd4WWR2YU45bTVnQ21mdVRlVGZhWEpUanBLcjdUL0JJODd5SkcxdXNZMGZqTTQ1REd5WXlBalhzL0NQVHV3czNzbWNpTDVPZWRUNnhxVFhxVHpnYkxFeEJaUTFKZ21mK1Y0Rkp3aS95UGRJMTBqUFZONjFJUFJiR1pkNFdmcFhNaDAwem0xMnBxeXpJdWVrMkpmK2pyTjRsbmtYUHZuRi9MTWhSVC84cXdUL2I4NVBIb0VLWS9sUDRtSEkwYzF0d0VkV3o0ZlJaMVcwUkVua2RZMXBZUE1TdWVZcDJrdUg2cHhmOVpjRXorUFRmWXQ5OWJFMTQ2ZlQyRU9CRVhHcHlEN3JkTEJrcU5tVTVadGlQMVEva2I2UllCWnp6VDVMZi9uR2FjK0VXMWcraHRZbEk5NS91Z2tvczRpbkplK3J3bWZULzFjNVlNMGxvcThraHdaQXo5WElIM1p1ZXNOekRtRTlkczdjQWVQRnIyTEthSHBwS2Ryc0pLZmU2TU1SUnJVRXpwN0FZOUs1RGpJTzBYZXZrcFRIWU5yelRIeHMzT1p1OEtKZDlPWENROVBiZFZ6WFBZbG4rRitUczZMUU9FSXFFNHdVUTlkaGcxby8xUS8xek9oWnhFbzkzamtrZXVBOFpUblU5LzgrYlU5bHZwZW8wMnI5bGF6YU1PS1oxVGZzYXpmeTV3YTFERi93Ymx2emYyaXp1NHFHNnBzWEh0L2xXWUhIVkhCNldKdmNOM0QrdEt4WmQvLzFoSnF5Mnc4cThhcDg1em9ybDRRWmVMYW1HVmMzS2RWbWZnNitGZ1hCb3g5SDBZZzdpTjdPMUxSL3c0c0ZlNGJBTDRKUzNIN2w3Q2F1bjhEQTk5ZWh3RlhPMWROTjh2K2pFZkRqdjkwUGExc1p6d2Fibm1hNUsvQ2dOUWJEcnhNWUJHRVUwblYvQmpBaWQrVHZJcFhBTXZkdHUvMGZubkhCU3pTOFJRR0pIM1IrM1lMQm9KK0JKdkQ3OE9BdG5kaDBaei9KNHdSN3NGQXA3K0ZnVklQWWVsa0FXTUtCSGZwaGJjTnEyZTc3Kzk3RGNCdndWSXZ2K0FnSFB5ZEwvbjlXLzViSTE4NnlGNmtuL1I3WXBxUEwvaFBMY3AyVmJ1RTdac1hVUXJPUUFZeUgvaDRBU3lzaXdyVVFFN1pGUS9BSEFiR2ZRaWIydzloKy9OOVdQUTBhK25NWUd2UndQYnRSN0ExMmtQbG9JOUh3ejRNRkh6Rm44RW9NeFhPR2VtZzg4YTBPdXhUTFEyWUVnZGUvelVBL3dUQWZ3N2dqMkZSdEw4TjIwOHo1R2o4SG16T1dEK1pScHZYa1EzL1M1dUQxRDBZTU03VVZFL1YvS3ozdko5dnd0SmxmeGZBdDJENy9SdjkyM2VldEQ3ZzZxMC9IZzNwVUxFUWNlM251UStMUFA5dkFmd0xXQmFEMzRQdHpUR0EvNFM4UDk2RzdadUhzRDJxQm1uQTF2ell2Lyt4ai9ma0p4MzgvVVY3UHEzSktaU2VXZW9PZndmUGZlRmRLNy9iM3I4Z2ROUmFNTHJUK2FqMnJCbGNhZkhQYUh3cDBnUDUzeFRBOUg4RmZ2VWRDcERRVUxDTGJOeTc5R2RkRG5MZE55b1FUSnVrWlE2b2VKSnUwN0RHOGRiQVh5cDVtdkpuejM5dVlRbGY5UFU1YUN5cVRvVjM1WU1MelJWV2prTlR6TzNEbE5PWVdxblRTTnJ2SUx6MmtaWHZ4ejcyYmUvVEhvQTlNU2FScjU2MjlhMmxrYitsYU1RbGhodzF0SEZkMTJwQndFM0ttbzk5QnlFMVZ2aWJ3Q1hyVXM1Z1JrR2VIeHJVaTVxcG9kLzZ0eXFQc1orejhLUEdGTGJrd2V6WHFJSzRvQXl0b0NOTUM4NjBuRzBPSGpvdWdpaHJaeWhSWXhMZkszM20ySlVPOVZ3eFMzT0J2RTlZRjNOQjJmRzVHQTg4SmJ0Y0UyVkl0aVFqS2syQkdKdjRYSmxuOVNBbjNVbUtHbzNUVFU0MXBuTktnM0ROUTEwanF2aS8wakRPeXg2eXpFaWxqZ1pXZ21zYVJVc0RTVXc3RzllMGlGNlF2VjQwVlR3Rm5LRlJuVWFYeUQ4NjRSbDBFRlhENFNWeW1aYXA3OHMyWGtNSHlxaHpjQS92TlZZekwrb0VmTmRDeE1KMU45OHZMOEIwZ0ZkZ0lPemFOQXN3UHRBY0h0MXF5clNQNUN1TWRxVWUwcE1mbFRtNVYzWGZjQjNKNjFhTmhkZlFTWE8zUWx1NHZ6V0NiUmZHTThpVG1BWlZqUnJVcjFMS1NHU2dqSTFyUjFyTHRORThNNm1mZzN0M2oxR2VVVVlVSnNBTGk3UW9HZG9vZCtqNEE1alZrM1hrR21nNjZJWG02N2ZuNTVDUnVnVEJXcHZQRTQycGVoYTNBU3pRZGwrVGRQYmtyT3A1bVEwc05lUWNScStZbWx2NU9jOWxOZnB6U1NNZlNYSklEVUR5eGo0cGlLOWpyeHBJQXhnSGxFYlNiWml6ZFpHV1h1bGVZK2xCeDhqcHJzOWc5R3NiUGcveW03UmQrWTlHc2lTZUVtVXJIOFBVOTZUeVdOYUI1TmhZZ29yWkplaU16elBEcUhnOXp3dDFqNzFOWWJhRFkrUTY2TFhJY0FJSUhQdlU1Ym9FSkFCTDAzOHprcGRyUUdmbkdYSjZkdkxISFpnczJ4dGtSeENlU1pZZlc2RDFnNXhHK3NQQnZidnZPVS9YT2RCeVhrVy9taHdGVHYzN1JSamRTdW1waGI4d3RUYlBJd01qenBGVHorNzUrakpWUGZjRU0rSW9YK2M1MWV3RVFJNW1WTHZVZm1QcDU1ZWwrRDREVW8xeEFBWjBOMWFxUlFFenpnMzU4SUl6L3hKK0dqK2ZJcFN1MEJicGpxOFQ2MGl6THpOa25yTXF2WEcxWHlMM0xlZ3VLR24vMHJUSTE5RzhMOXozdTdBOXNTay9ML1F0LzR4Um9kUmwxUUZoamt6bk9VZlV5YmovbGRiSDZQRzJzZkFham1lcndzK1ZkNmpzMjVQek5VV09ncVNjUzBlS0hrcjlYRUdNK0RzNTUrbjduWGFleW5lVUZ5WnlEL1ZVZGFMVVBpUHU0ekRQc2NRTWRicld0YVU4UUxsc0lDVnQydTd4NjNnR0lsOWt0T1hDL2JySDVQelNnVTVUOEhPK2FldmVsdnNZcUZRNGJxeHFnNXdLbXordGtlL0NremZXeitOekZKQnJySVJGcTQzWng2djdnam9JUysxUVJpdk9TeGhYbEFlWDJWam0rb05nRTJ0S0IvVzUwTEIwUC85ZnBaLzcvUk0vVTNSMHFORngwb2RVTGtPZXZkSmVWK2tESFhpS01pOThWOHVlUkppWHRqR3RjaFF2K2xYUkk4blRrOHdkM2xub0JBSzRUcjN2NlpuQ1AxUGZVTkhQVzlaSWRmTWs2d2k5NHpWeGpncG5rOXFZdzBmY0ExZDJXQlk3MGpOclhWZ0U0ZHNBM3U3ZnZuUHNFWHBUbUJEd0ZpeWE4MDhCL0g4d0lQZ0RaTUR0R3dEK0ZZRC9EUVlVVDRHclJmTTVtS1QxWG5WQ3B6Q2c1aDFJdlZNQlpGTUxOWHZuNDlId3huZzAzQnVQaHJzRWhmMW54Mzhmd0VEVVZrV3cwbDZDZ1crZmhRbXBuMGFPQ042REFiVGJ5QURsZmRnOGZ4Y0dSRTU4SEROUDMvd0lCaXg5R3daTWZRYzU0dnJNbi9lSHlOSFlwN0ExK3dDNTduTFgzLzB1Yk4zZWdSbHJORVhSSGd4cy9DTUF2dzhEeEY1QlBwajBCcnhLWk9qRXg4djAxbC8wL3Q3eTd4LzR6enY5MjNlS3lFbUMvc2dDRkFuaXF6QlBVaDRFTlhTcnNmNDlHTmorSDJEMVpDOWhnT1MzQVB3di9kdDNIbmdOMmovMytzNGZ0S1FtSC9kdjMvbGUvL2FkdiszZnZ2TmQvLzFqOXRWVFM5K0h6ZTIyMXl6ZWdxVm1mZ0VsK051Rk9UUm92UUk5R3kvQ3dOK3Z3T29vZndvR1B2UDczNEJGcTM0RkdleG5tbllxQ1IvQ3dQb3ZqVWZEVC9rZWIyTk1jNS9MVC9udnIzbU41U3MzUDJ1bjdvQngwcjk5NXhRR3BEN3kvMWNhcVRadGZrNS8xWCtZNHJtdlRoeSt0bW9zQUl4ZS9RM3NmTDBQRTZyK0g1Z3p5MzJVRE9RQXRqNVU3TVl3NWZ4ZG1NUE1relV5Qm16VXFFaVFTWlBoYmFxcy9LSTkzOWFVYVZ5ZUNmZ3J6MWFqNXdKd0JGR2VWQ0JaSmR4VkdnWEpXTE12UnZueXM4dUJSNlM0MEwvdGZ4TU1pb0tVS3FtWFlxaWV5bmVzT3pkR1BzdXNoMFZlZlI5R2J4NkxBc3ZmVkxZQU0xUmR3QTNaT2g0L2N4UklhUnlhb2pUZTlwRlQvejllWVpCSlVhLyt6QXNZU05NcUNQb1o1M1ZxSUdTZG9VZ0RPcEM2bnFJd01PTUh3ZU1PY2lSV01tS3BVV1pnZFpZMm90TUU3UHo1VEE5YmEycThaOXRZTnZSMzZuMEUwQkw0cVVvQkZkcW9zQVRGV0Z2MExrYTRyZ0IwVjRDejZWMHQrMFEvVTVsRzM2bmpxRFlhcEhnZWVkN0NaV29BNE5sU2IzeWd4WUFoL1ZOSEQxV3l0ZDhLWm0reGI3b21TK1lEL0w3eThSUVNpUjgrN3pyUUZoWE5CYVZKemdmUEpvMzBOVEJIYVpNQ0ZsTzVKL2FGTkVYWFUwdUU4QnpvdFlXeHlvM3NCSGYybXB5R2t3QTU2WmthNWliTHpxNnZ3WTcvM2dOd0k1ejl5NEhWVFdXazVRc3dJSWJnMTR0TnFDdnVCdmlITURyekJCbThxRVpFaGtiYUdxT05sYWZVakJwQXBtL1B0RFdIUjU5QWpweWxRZlNGZGM2OE5JNUQ1em9CTFZnY0ora1lqWnZSR01yditLeUx3ZXFvRTRTOXkyeENrWjhuY0V6TzZMRmZTMmZlV3pEd1dLTVQxWEdCd05DbDMwc0FrdThqTHp2MTc4YVEwa05pSUdNdHZMTUt6Vkhna2Z5Y3RiWTVGbVlWVVg3T3Z1bDVwb01ZSFUrVzhYTjFkdUE1SFMvYjYwNlhXWnBDRy90U2sra2pNTWF6ejNsaXZWeUM3b2xYTk9Kb01MQm81WTJNVGo0V3JwWFcrbzJOc3E2QzhTdjFJT0ZUbXJsRStRRkxVWjM3M3pUSVVyNmg4ZkFDT2FzR2djaVlQcHhubHZ1bUt6L1JyalNIQTZZckRMb0UzeWR5YllxWVF1WUpsOGg3bTJlNEo5Y1c3d2lHMGo1eU5CblREZXU2a2xmTllQdWZzaUdkT3dpR2NtMXFqZjFUZVp0OEtkWGtSYzZTdGdQZ1ZuTjRkQXQ1ejlLSkxSbXRXK2FzUnFzdmtXVjFiWFRjcE13S2xNQlFCSUpJbjdsbnVXOTUzeno4SGNGWmZzWitLUEJCUFFISXppOUFXZDVnQ2xzdnRac1Y4eTd6YzZNeFp5QTZ2L1FFOUNNLzVIUGJNbWZFc2RQWnRCOTRjNHJHOTMyNlR4REd6OUJCRStxUXVwR2FaZWRPWWV0K2hvcXpYbXpDTzlyazNHWDhIRmdEOUh6YTVuSVA2VC9YZlBlSy9GemxOWUpxQ29ycVhKRC82OW52eVhmUkFXcVR1ZER4RkUzMDY1U0Z3WGtJSTl5cE54S2NuNkdNc2xNWlY1MGYyVzgyUHBkZ0UzOFMvNFU0NjhqNFZFOG5YVDUzK1NqVjJtWlRtNWdBUGRUUEZUd3FJa2hYekozT0Y1MG1XdmY2RW43T3NYZmo5VmgwZnBoNy8wNlJNMWh3L3VsMG9rQTkrN2Z5SE5hYXp5ZlhaOW5Zb2o1NEhYYk5WTEpMNkZXeVpZck5qUE9uZGkzeWM5VnpORTEvQWRMSnZRV2d1NnF0MGtlbHFlMnMwTStYTmJGL1VjWllwbU1yQUtzT1IwdHRBSU82c3kvM1lzM21ScDM1Mm16S3RUbjB6MktwSmYxZDIyTkpkdzRBZU0wMm84OUs3MnpyUzVBOXlaZjJVV1lRcHAwcUJ2ZkZjZlhDUHRidk50cUQrZ3pWV3lydmhGelRpZmMrVGVzQytMQi8rODU1Ly9hZG1EYm1KZjkrMXI5OTU5SkJ1MVRVSERhSk5BSjhId2J1WFY0Ui9DV2ozSWFEa0E0cXBjaGVCNU1ld3NEU2xZWUEzby9zemZZU0RHQmp6ZU5YL0xzRG1OSGpZTTIrOXYzK1Q4SVdleGNtTU5FajhERU1nUDAyYkg0dUJaUW1nYnNGNU5USERpWlJDYU9DQmVTTlNnK1pPY3pZc2cyYjk5ZTgzd2N3SVBBVi80NEtPQlg1V3pEQStwOEErTHJQUlI4R012NDJMQ1h3Ri96M0YvMmQzNGNCbmV1Mk9ReFkrdzRNbkg2QVhFdFY2NjNjV1BFTUtuNHZ3TURxVHlKN2IzYVFtWERmeC8wU0RNeitSekJ3Y3hzR2pQOElCZ0luNC9NMVJteVNLSDBHQnM3K0htek9mc2wvdjRTY0Z2eDNBUHc2Z0Z2dWNNQjd4ekNIZ0RjQS9CdFlSUGc3eUVMcWpqL25CUUNmaDRIQlpKcHZ3Qnd6dnUrLzN3SHcyTTl4MnhnNy9xemZnczN4RXdBM0NHSS9aZVIrYXI3WEZ3aThnUHdiTjhrQ1FHSGxUUmpZLzZoLys4NkYxNU9PNDc2QW5jTy9nVGxkL0Jsc250N3k3M3F3dVh3UkJvalRnWUpFbUhXenoyRjA1OTM1SEQrYXovSG9XUURiM2hMakl4TUZyb2ZRLzZJOXM4WTFTNExwZFROcGIrUWZVZWxUenprQ1ZOSFF0VkViNU9pNVpjQnhOR1pwZEJPRjJLNEx3ajBSZENqODcvcTdsRmJNa1ZNaU1mVWRqUnBheHpaNVZCSTRjV0diaHF3enVaNDhwUkQ2eGZpMkIvUG9KNCthRGNyNllZenlPSVpIeXRZRU5lay9sZXRhaEM2RnVHMzV2NE9zckUrRFVFa2x1UkRhL1hsRmVrQ0lVdXhHNEdOa0FUY1p2UHp6R0dtenNTZSt6OUdwZ3hGdFNpUDNBdUM4ZXhsZ3RhckozRVFQNTlpM1pYdytHbXFBUlFVbGdyOEFzTTZaV09pdkNQWUptRlRETC9ja2xibG93S2s5Vno3bnVVb0dwckJQMUVBVFd6TGdoek9SbFBhS2dwbkFVZjNjcjlQb0o0SVVHbTFVcFlWTjl2aXV0UjZDSVR6MGd5a1ExWWdBR0EzZWxqTklZd0psU3pVcVU5NUs2eVBmYmN1OWZDL2tXZDNLZmFRNTVBczlsRFE3UlFVajArdWRKcWZyMHo0bHc3WFBMeU1BT3lpTmFpbTZxREovaklxamZyRU03RktRTEtYTkQvdURRT0FGUE0zaElFZktMVzFVb0pFekV1aDNCRTVpUFZjNjg2MFZKZk0wcmNuMU1iV082aFJ1dFBjNWZxVlpFdG5nZmI1QWp1YlR4cmsvUU40enFuZnovTUMvWnhtZlBpeHlhU09lTG5UaWNtQ09QdE1saHE4WWdjcXpRa0NLMFNrRVB0U1l2ZU5qNmpqdklkK2F3ZlNNTVJ4b2RZTW0xNWxqVjM2cWRJWEcyVEV5V0ZMd2N4MUFrek40YkFkK3puMUtFSzJJNkZ4aUVPUDFsR01XK0xtOGQ2SEZlZmI3dWxnMDhzNWwzblFlWnY3OXhPZEE1Ym81VEU0NmdRRWExY2paZFp2dmkvSEFuRUxhemhubE9uZy96cVBCdnVYWlZab2pjOEQ5UXFPeHl0Sk1jWmdNcGZJSTBsZ0M2OXdmTS9sTldxMThrczlnNXBKMWVUcWpTZmVSSTIyQUxQZHlUcWErbHVlK2JselhDRDVRMTV2Ni9idE5tYUVrZ3NCUDRFN1BZaVRsK05sL3JmM1hhdzZQWG1oeVJocEcwYXB6eFF3Qk9QSHJIdmwzcDdEenV3OC80LzdzcXV6bE5MSXRiZWsyZ0pzUmhFUSswOHdlb0h1cUE1TlhYMmtPajI0SVlORkJCclFVdUtMVEtCMVMrQm1RamI2Um4yczJBSFhpb3U1Qnh6SHkvQnFva3RaSmVDUUJaT29qRE9oUXA0TFV4NHF4dDRpdXBJN1Y1TkltcTg2ZTBxV3FqT1V5VWxkb0pQV2ZkWGt0NlZuUlY3OS93VUZ0a0oxTm5pbzZhcDBXOUFXbENYUVcydksxV2tvdnZjL0wrcnZNQVZ6ZlRUclZROGhldEdGamRvSTJmVVR0RVd3Y296cTI5V0Q4VWtFUGxaT2pBM2VpcmFKNzBsRmI5Zk9rUHdBNVhUSnBJang3QUxJVFdCcy9UdzVIc3IvVUFTaEdDazdsdmxwVGZsNk5ocFJuTHJUWVAvbS9BR1o4VFM3Q2ZsRitmamt3SUpqMXcwbDNMZ2RtdTlpL0Roc1M1MmtKL3lVdEJaQWlGcS9EUnE2T3RtMmcxcFIveXg2TzRDNVE2dWJKT1IrbHprY2V0aEY0TGZvNVpkV2FmbDRBcWJyMzFtZ0ZlQm4zbGREYWFJdlFkOGE5MmVxd1BSQVFza1gyNUJ6M21wRFJZRmxiZHQwUzJUbUIyTklYeW1oOGZ3UlNLZTlwLzNXK2syMThjTy91TWxDOWNMRFJKdllDemdmbE04NGRzNmkwQXZic3o1STVyc3E4TGMvc0NnMWJ1YThxOHU5VHRhMys3VHR0NllLK0RZOW9IWStHVXdFOXVqQkI2aFJXZS9NNlBFWW9xTTlScHR3dG1xUjkzcVI5aEF3QU0xVlBGd2FHcVhmZjluZzAzT25mdnROcXlIQ2dlZ0tMMWgzRGdDRkdDYjd2eit6NTMxTmdvZjdwZkR3YS9naTVWakRDZHhNWVVIc21OV2NmSUtlcHBhSkFBWnJSdngxWWRHS01yS1ZYNWRkaDBjcXZvQ1RJUDRKRno1N0JqQTJuUG9adisrZTdNRkNWTmFDWjl1aWh6K2R2eXJPMkFmeG5NQ0R5bTVXNTYvZzlYeDZQaG5NQUgzSHZoQnExZ0RrQi9LcjM1eEd5NE0zYXZFb1F1c2plbEIvQUlvRFAvUmtIS0Ewc2F6V0N0RXYyZGc4R3BQNUQrZXpUc0huOGZmLzlFRFp2VkJTM1lJQXRDYzRqR09qN2dYLzJGaXlOK0lGZi93M1lQdW5BMXU1enlIdUFJUHBEWkdGdXordDNUOXp4UVZPYmMvL2ZncTN6Q3pCSENOWXNmZ3ZBay9Gb2VNWjduMEhyQXVoNW41WUIxYlhXZ2RFRjF1dzRnVG1tRkdjcjNITUdtMXZBNXZxamNEYk9ZYUQ2TDhQbS96OGllL3Z2d1Biek1ZRHpPZkJCQi9qaGREYS9QNWs4ZmQza2xyYkF1QWYzeWdMeHYyZy9rWTNydzdOVzljeDkyc1o5SVlZZk9tTHgzWjJCMVNiVHlJUzFXbk80V1YwazM1ZngraGdSb1FLbkd0NnEwUkNpMEVDWHlra0FBQ0FBU1VSQlZMRStGQUVTUFJNOVNCb21OelNSWHhlR1BBckQzcyt0eGxLTEttK1AvWnJxTytVNlRjbDA2Y2FyZm1QMTlwTFM0bjNhUlRabTdnTVlpM0ZCYTVaMW1sd1Boa3BTRWIwdDR6aXRyVTlsdmNpaitZeGRlTjA2NUdnSjllUSthSEpOdyszRzZveGRoeXluVGVlU1VXNVBmVFo4bjZlNWxuWHJObDZYR3ViVlh0VEhDY3FLemg4Ritxbk90UmhmRXpBMnlJQkJyVDUyeno5WEl4Ty9qb0IxNnhrVlJXNVowM25rZVZ0UWVuVDgvdmRGazlOQVQyV3NoZE5JVTZtLzVlTlpTQ2NtSUN1Qlh3V0IxUUN4NWZNUkRRM1IwYW1QTW9xcWJWL3lqQ2lmMURsUVdrTWxTOGRDd0UrQmcvZ2RrR1ZzeXQweE1vTDM2SHZVS1ljUi9wb1NqL054aVF4K01EcVNlMkFCREcyc1Jpc05kam92TmFXWC9VMTlhVHZqVHRzZXkzN2dtRFVsL1E1TTlwekNJMFNid3lNNm02eHNZWi8wd25lazdYeC9kMUFxMnM4OFdzaWJBa2Y4WWEwMDdmL1NWak1XQzA4aWJ6eUd6U2QxS3o3L0dBWTBUV0I4cElkUWEzTlphdzZQdGdjQ3pLMXhIOCtyTnZJcU5xMEYzRUYyZENNdEtkWnpjTy91aVgvUC91LzRubExaZ0xTQy9IeFgvaTZNbDl3RHpzOEpqa3gwdjZCMHhwdjVOZlBtOEVocE5mczdjM3BQQTNPaGp3OXlOQWJwYWg4R3ZKSFg4RGNCbkhnV3EzTStXTU5SUXZxWmROY21wMFhrY3drbXNMRytKT1dkSzlYeVc2TnhiSnBoNWFtZU5iRDY2RGVRSFo5WkU1TGdIblhvSGVTelNPY1dQa2Y3UmtlS0M1aVRFQjNybUhhVXRMdnIvSWgxWFZWVzRQVXo1T2pZU3pIV0taREl2VmRFa3NuZW5iYXRoM3pHL1VmNmNvbkZpR1dnNUtlVDV2Q0lkZ2JTQ05Mclc4aE9HelBuNTQvRHM1Z1pvTENwK1Y3YlEwNnhUV2VOUFppZXdmbmM5L040S24zcW9uU0M3Y0RzRGNmSWVrdWtOYVFyQktkbnplSFJLZklhYzY2amd4UFhnckxVbnY5L2hneTRrVGN6d3A1T0xhUk5CSFFaSlZrWWNJTk9RRDYrSmVOaENhNXQ1RUNOYlFBM0J2ZnUzcWVNWGVQbjNqZ1hrV2FvNHhrYmdXcWVpZFo2cHo2UHlwZkowMVRQWUVER2VXTjF5M2RRcWR2YjFnTEFTb2Q2L1c2dS8wZGF2czQ3cnFITjVRZmV6MmhYMmRUd1hud3VNajRqMlRrZm5IUHVDUVlBZGJBa0xXOXNVUlpmNDc3bzRBb0UrUmZpNUlEeXpKTG1GRHFJMEJXbVBRYkt1U1ZQVkg2dWRiRG5LTWZNOHpXSDBkOGRDUDJzNkdwYU0xaGJvcEV1SHpPS3R0akRnK3pVeG51NkxvL3dmSFBkU0J0MFQ3VHFyVzNucjlJaVArZDdTVitWZDNSZ21RT08yZSthM25VTlRlV1dhNnVQN2Z5Qno2ZURyNDZEZTJSTDFxa0FvK1Z4aWNaRVBpcTJsV0t2dG8yRFoxN3BrSnhkdml1dHdUSjd5SnBuTVBYRjM5TlpOY2R1MjFqUU0wVC9vSzdjSnQ5VjkwbVRzOGVvVEZIczZ6Zy8rbGw0bHRwVjJzWVN6d3YxU2VyVkhkZ1oxQ3djSEp0R1E4T3ZtVmY2MVhGN1Q3UmhhSW10V2lNdjdpQ2ZkOG9scER0cEw5QVdNREFIaWFXOFF1d0FSWlAxaTJOZ2lUdktMTXYyeGtvK3BiYXBkYzV6MVN2TWdhOFUvUmtpOXlod0xVMEJVMnNPL25RQlRDdmd6WHc4R2hMUVZHLzRwMm9PYUUzSG95RlRFTk1RZVlKc1hCckRDUEdMNDlId2dhZGxqbjN2SUlOT0Q4ZWo0U05rWmYwQ3RwQXZ3QlY1U1VNZCs1TzhBQ3VOS2JhKzQ5ZldCTWJwZURTa01yUVBBenEvQm1NdWIzcS9idm4zalB6OWl0elA4YjRIUzB0TlF4MlE2d2MvUWE0Ri9UYXlrZm9sR0dqOGdjK1hBc0FVdkw5VEc1Z0QzQVR3ZmhkV3A1bnI4WjYvOXc5ZzgvakUvNytBZWJ4K0NKdm5ML3RuTHlHSDdKL0RJbWtmSUF2eWMzL0dFOWkrNm13Q09FYmdsL2RMQk9xblVJSy9iSHZ5VzVXVjd5Sjcway80L1BGbytBWnl5cTJ1ai9YYk1LRDRRNWlEeFh3OEdyNERtMWZXNFZFbGhpbXltY0t2TXg0TmYrajkvQndzU3Z4OUdBaDZIemt0T0pYR2gzQ3dBcHZYanRxa3pXRVIwbDhDY0R3ZURkOEQ4T1lLaDR1dXA5MmUrVDByalcvdXBNSDUrQUxLZEhhcEhuSC85cDFqQUg4NUhnMy9HdUs5N1Y5dmU0ZGY4eFA4M3R5ZE5sNzhILzZuWjJGVVdhcGdBSnVEZEw5b3o2MHAvWndoQ0dEUFlzMmN1YXVTeDlweXJWNnRLOXJHd0Z3UXhuaS9BaUEwN2xIWjN2WStBeTFHanlaSEVmUCtIc3pvZXlIUFVWbUVmSG9hUG84Q0Z6MnVaeFN3UlZta1VNeE1IbkhlK1A5RkVLSTFpZ3MrTnUwRG81RTZNS1BLRTcvL0pvQmptVDhheHk4SGRXL3Vta0RPZXB0VXRMbi8raWlOUG1jdEJ1Y3pBRHRDVzVhbHdieFNjNFYrTXNpZ09ZME1rSDdUR0xJeTlSMndzS2VwUEhQZnFyT1RlcHEyZWFoeXJmak1HbCtKaHBUQ3NPblBuZ1dobjg0TGFteWo4VEMrVTBFeEtpNXJnZkF0SUd5U09XV2ZjUC9wK1dhMCtFeXUxYjdGYzFhMHlJdGsvRFRzcVJMRmlDNmRpM1R1cWRUVHNPVFh6R0JSbDlWMHBHSkFxRFdOMW1GVFFJOWpWa01Ydk04S1RIUE5PQTdkUjIyQUhDUEJ1SWFYUGo0ZG04NnoxZzdrOHlsalZ1V2l3YjI3Rjk1M1ByYzdzTWc5R25IaDQrTjROZFhlWlZEZTlkcTRwemhuVEVkTkdRcklHVlFXZ0w5bFRmaFdUYi9iaHZHSU9ZQ1RkYy9CZFRibkNTZkkyYUJvS0dDYTdBc0FUOVkxa0d2VE9SN2N1L3VveVE0R1hETUNDelNJbktOMGhsNUxObTl5K3NIcEpyU0VoakF4QXV1K29XSGtYUDdlUTNab29DRTE5Vi9vRC9rNUhaZG44QlRQbEFkazMya0VmS3ZocWNrT0xEUFlPVkIrem1jeFNyM21OZDlCTG0vQmZjNlUwTWtJaFpJT2NsNUlKMDVrak1rSVhKRlJWclltT0E0MU9US0g1dzdJQUZtTjdwM0QrRG52WDFhSCswcXRNV2M3NnA5OTVFZ3E1ZWQwT0ZtVlVwTkdLdDJmTStSVTBCMFlNTVhmNS9CZ0JKRVpsRytyNFZ3QjFMZ09rVzkwNVI1R3hEQU5LZGNhOGw3S2h6UGt2VS9nY0FmbWJMQ0ZmRzZaelVZREhLcHRrRlAzUmw2c1BQb0FKbCtjT3grZ2NmblM1elBWVVpUKzBaYkNPbmRBTnFiU2tTbnlkSjREcm8rbVAyYjlhUVYya3Y0d01EQy9COHVzeFdkTllPbXRHUWtiMitYZzN0MzcvRWRrQ2RwTUdCMU1leDJkTFFrNkptT3h0QjdLZmFoclN0dUhPbk1zN0ZsZmN6cmtUMkY4WUNMeUxIazNNeVIwM0ZqTk5LOUFkdTZxQmlJNDNUcUg3WjBlREhob0srMmdzdUlFSGdtKzVsbm5PV0VOMUV0a01KbHpUTHF6Rm4venZVYzZXWE1nNnJneC8xbUFWK3Yyai9LRzBuUEticE9tZEE2NjZuc3V3cmxWdlpOck5VV1p5WENUUUthZTkzTVQzVUIxREFLem1na0J5R2VIZXJjNkxRS0xBSkhxTUFva0ZmcTV6S2RtUGxpbG4xTnZvOVBHckNsMXQraVF4aFpsQjg1dmpKN1g5ZGR6UlBtVmdXRVJxT1cxYTl0SG11QWdMSExDREZuZW02TXNkYUh0RktLZnQ5Q0NwMnBOempTaElIaTNFYUM1eVptZ3JvTEZuTVBvQ3gyYktETk1ZT09lT0gwbERWSStydnNQYUhjQ3J1b3gvbmZrZFlEdk45bkhFVXl1NmZNS05LL3RWTmR5WFFReHUzNXRNUTUvZjlWSkd1S3dnWW84c2FSL3lsTTdLTXVIOGI2Rlo4cjhGTFNCZkdlSjNicTJYclFQYVBBS1AxZGRZOEdCQ09FTTZob0pMVkg3NDBJVDNXWUdXMHZWVmJRdk0zaGd3U0JuQTl4RUgyMWJsMXEvTkwzNXBqcHZBZklLL1cxektsdG9LeFVWQno0cEdCQ2NCUnljV3Jlbi9oeW1lSm5XZ0IrL2htbW1UcStTYW5VOEd2YldpV0tVbXJNRWkyN0E2NG42SlErUTBmbld2ampnUkVXWEN2MzVWU09qeDZQaDFqcmpkakNNOVdmL0dMWTI5MzBjbi9heFBZRVpoRDh0dDc0THE0UDZGaXl5bUlvNTAyOS9GUlo5ZW95czZEeEJGaERIL2R0M0xueisva2QyQjZZY3ZRZmdmNi8xZnp3YWZocVd5dmhMTUdDYWd2elUzMHR2M21QdjIzK0NnWk1ueU9sRmZnbTJYcCtDQWR1Zjhtdit0WStGQ2lTWmlSclo1MWVKYnBWOXl6bzd2K2J2L2NLS1crZXdQVFNCZ2VaL0N0dEhyZnRpUEJyZThqRys2ZGRPNVRzVnZtWU9ESGVRNjFtOURBUEdwN0RJNGkvNGQxdisvN3ZlZjBaUjArbUJocVhMbXVQRGRUWHYvMi9BSXJ2N01BUFNmUUIvRXZmTGVEVGNSMWtyNzZKLys4NVV6bXdISVFLNDhqNm10MG1lL1p1bUFELzduNGUvMU9sZ1BwL2pZYWVENDZ1ZTZWKzBuLzIyZ1NKK3JjOFVZMDhIYmlCMEJYKytpZUFlMzdYczNTNE1xaEYvQjluUUU0R3VxUXRyTkNJeENtZ0xKWWhKL3FucGc5U1RXZzAxQytkUWhXa0Jkd2lVTXVxUlBDRUNPK3p6UW0wL04zWlJEbUNxcXc1eXRBSDd5TDZyUVV5anNNNzllVGZodGJaV0dFbmJ2Rmh2U3Irbi9xdzlHSjNiRzFpYVFQVXdacHZEbzJIYTNubWRyVGs4Nmc4c3hSMy8xNXBIRTlrVFhOTXJLYm15RjRFc1NGZFRXYW15MHdKNnhXdFZQbGJldzMzRTd4V0VaaCs0UGwyNUw0RXlzajc2ZlhJZ2lVYUVOZVpCK3djRUF3MnZXMk84NmV5cUVVWU1QSVdIYk50KzhuT2pjNlhyR3hWaEdpTTRCeXRUa1ZWQWsrMTRIOEV3bE92Ri9wTGVSQUJoNmpTVWtUM0pXSUJ5UDV6NnZLaUNUQmxXMDBadWlZR1FUb0drR1lBWWdacmdFYnpHSE9oKzN2SjNqZVc3QTJUalRnUjNDY0p0K1hXVGdhV1QxZm1sRVorQUlPZndEQmtJS3d6YnEzaFdVTUk1SjZ6bHVJdWM4cGZYYjNRT05tbExhQ3ozeGxPbHFReUdoWDJZY240Y3ZvL0dpNXZJKzJjTHBudTk2SDBwSXZoOGpSYjRpSnducGpqdUlUdFUxUHJKZE8za2Zmdis5eG5LTlA2TS9KN0I5Z3dOT3Z6L0VuWXU1akE5UXdGdTZudDhEdzFaVmE5Nkd1bjhMSkpITTBwOEV2aWJ6ck5tUlZsSVorem5PdGt3Wk14YUxvRjdWQTBvQlhnb2dGMFJ1YlJwY3pySnNkQkF6T2p2bm9ObTZSeUUyNThuUDc4cHNzWENldmpuakxKY1dwdDh4WHQ2eU00RmxQa2VpcHpZR2JRWUpWRTZGcldkQ1NDWDJWSlFRTmVBOWc0NkVSRFVIWHZmeURkWVZ4c3cyalZGanVRbkNNM3p3bXdZSytkRitDeC81c2pSeTFOa0o3OElNaWcvSXYvVnpETmpaQjQxUnJZZEFQbThITmRvYm5ONDlETEtldHFSbGlod2NBTVp3SDhDaXhCZXFqdjdPV0tVTlhuWGFXV01qQTZuN01RK2NjOVFENEhQMTlocENPMGVhanpuN3huTU1UNW1XcUlNUUVlMHlNOVpHNWtwc3FjQUhsWDZ1NDNTNlhObDR4blQvZEtVV1gxSW53aEFuNHZjdUF2WGUrUmU5cGY3WG9Hb01USWdzakU5Q2JTSkRqRTh1NFZUNDdQUWsxYzl1NUZNUHV1Q3FHdThheHZJZkVEN2dGS09adTF5bnVFei84MFU0SHB2R3o4bkhhQnVRRjJxNnVqVGxBNVNRSmJaQ2J3b3NNYTEycFhQWm5JLzMwa2J3eXpjci9JbGRhOVYram5QSUduaVpkRFBPWGR4TG10T0dod3IrOFB2MVNGRTlaYTVYTXN6dlF1ek0vUHZLenRFTjlrNWhPKzRoR2RPOExHU255L3MxYWJpblBtc21zb3RQb2RjMXlJTER6elk2Q25tZzNZWXpnc0I0Rlk5ZEFQOW5DM0thK1FObEFYSVUrZ295T3ZWS1FJbzlYUGVydzVuZEp4ZUs3cHlSWjhUSDlyVVRzZS80enpKdUlBVjlEeWN0NlhScGFKSGQzREZ2ZEMydHdQdjZBeEsrNGl1SjdTZm9VL2N1N3kyT3FkTnhTbGdpVHpKL1JMMWg3U1BOcDJEU244NEJxQjA3Q29jcHRwMFlPRUxRTlpOTnVyYjB0cHZEdHF3VHU0bllDRGJFeGhSTzlna1phd0RWcW9NVnE4QmNPR3BqNjhDMXUwQWVHMDhHajZCcFNKZTJLZ2hHcFJNanNJeERka0VnMWsvcmRNV1JlckExS3gvKzg0NGZyZWlyOHJjK25DREVpeE43cXdOYlBMN0dIMjBBNHZ3N01QVzVrOWg2WjQvNDVjZncwQzJXMzdQK3dEK0NnWUlNdHI2MHNmZWd3R1dnQXZEeUJHMTlNcnRBSmlOUjBONk03RjlDSnZEVndIOFBRQi9HZnA4QU9DL2dPMmhKOTd2ajJEQTZHdXd5Rlg0ZSs3REFOQmpBUGNEQ1ByWXIza1h3RGZoNmJMOS9RcjZhbHF5RjJFMWVDL0hvK0YzKzdmdnZGdWIxOUJmS29nWHlMVnZkcENqakQrQ0NRcWZibm5FcWYvOE94L0hNVHl0OTZwWHcrYnhTN0JvN2djK2ptcGRYZCtQNXg0UmZneExUVTd2M0JQWWVoOERDYnc4aDNpM3Jlc3M4YlRONjJiUFljNEtuNGZORGZkZDErY2J5QXJYQVhKay9SNkFyZkZvU0VCOExlYmo1M0lzNmNXN2ZvWTNJZHozQVV3Nm5XdExkYit5UFVzRjZYbTBWWUxiejJLNzZwcXRjMSs4UmdXbXdiMVVON2FuMThNTlRzMmFYc1AreklVMGVFdGFCQmFCckFpcVVEMzM1ODZSZVN1UWxVd0s0MVFPenBFOTlDL2xPaTE3d1B2VTRVcUZRVDZEWUUvaFdTOUNuZ3A3TkxqWG1nSjZmZVMwL25vOWpVaDhMK3Qra1E5dE5aN0dCdGtRTVBYNXZsUkJicEJUQU4xb2NqUWNCVlFWRnFsTXFaQ3NoaWZXL1V5MWszemV4cy9MYUZ4cFRNbklQWE1KWDVlclBuQ1EwK0lDUVlHdFhLdUt4THlwRzlYMWUvNGJRVFIxU0ZDREJZMDNjd0RSZzcxNHp5Q25VZXlFeitkeWZTZmUxOWI0WGprWGZJWXFPMTE1cDQ1ZFFlZlVKOTkvY3lEWFl2VFBlSjNXcjlGblJDZVFtZmN4UlFrMGtyb3B6TkU2NEc5UytCdUw2bWZVVnExeHJLa1dzdmRUbzE0NHoxMk9WZVpISFR5QXZQWmJ5Q25NcGhEbjFnQ0liRHNkdm13T2owZ1RHQkVjNVptVXNuMGRmaEt1NmN2Y0FCbUlJQWhCVUE4b293dlZHS2N0anJjTGt5bm55Q0RJQTczQkRkVGJqYVhXbTBJY2ZFS2ZOWjBnK3pMMmUvWjliNHg5SGRqdlUxeGphNnhlY3JjNVBOTDBwY253TUFqQTloclBvNUZMbjBmUWhrQlJyN0ZJU3RLckNLNmV3aHhhWDBRR00yaEEzbTBPai9ZSFZqc093TkxJRE5icFBVZGVzMVg3U2NFUS9rOWRRbWtjZGIvb0hNRXlQQVN4NXpBWm5tbExtVUtha1hpVUVYcW84M05HUzZuVCtReUFPc2RvS2svU0xZNlZ2REUyZlI0amtuV01pWmJMM3h3YjVheWloaSt5aktNUkpZWFJ4dmQ2QVFBMnBVT05PZytSTm5UbE91WDk4UDUyRzR2MmZSNzhYUGNQKzhpMUFwQU1yUVZvZFlXbXdHb2ZkcDRXd0Y5L1h3RXNJUnRVRi9hNjgxdlNiWFZBNFI0ajBFdTd5aHpaTVczU1dQVC9DeWhUTTZ0OGZkYmsycXhzM0JPSmI2NWo1Qi9reU1XWno0RWFPcWV5NzVuQ3Vnc0g5dnp6ODRGbGhEaUFuVVU2Wm1xMGJOL25tSUE3K2ZJdDc4WkprNk1uMVFtVHRGMTFqOFJEZFIxOFR0dWkzRkpyTXRpNjNWamEwL1BtOE9pa2hRZHlyTFJmY2I0STBuSyt5TjkzblVmcnVWYjVSQ09TdGh2THhEUHhPZG1DZ1d6S3oyODBWaXBoMGh3ZU1admFUWDlXdEFFU3JMNEtvTFFEU2YzcS9Lb0gweXNtOGs3U0pOVmhGQWpRcHZSeEM1azNiTVBrOGhPOXVNbU9RUVRaMjg2V2dpYndaMDFjRHVnMXVTd0xJUExRQm5PeHN2bmFkSHo5SWovZk9JcVNNbUNnMStyb093VlNLUUlGV2xXZVpPcjBIZmtzT1ZvMW9TelJFanBPeHhwMXdPcTJYTXVtOGpmLzN3ci82MmVVOFFyZEFUYW4xQ0ZKUjFJVUhiSWVsSGdqTWorbi9BbVVUbGZrZStUbktkSlU5bERVSDlyT2ozNnVFZGVSbjZ2ZVF0dSt5cmlVM3p2STJjb2lHTG9PUDFmOVN1WHRnbGZDendYSytldzRQMzhldHNab3cxbElKKzk4NXFsS1NUanRvcFBLRmxib052eHVIZjBjeUxZcmxIT3JaME5UaDgvbDNvblFOeloxOEZQWk10bFhBbTNadEhSYXNrV2hBbTdxYzJVODBRRktiUkhwTEZPZkZwNU5lbmlCK2o0RnlxQ0ZWUzNwenV1TVZkWmw0bmJLdGozZGtldlNOV0lmMGZPaGM2NXpGRzFnYVc5VUFPVnBtRTltdzRoOGpQS1dqb252M3ZnOGNFM0RPK2dBeTJBSTBreGdNZHRCelJha2MwQm4wSGw4MTdKV1pTTGowYkFqMFlXZmhhWGUvUndNY0hzRkZtMzRPb0RQamtmRG5aQWl1clgxYjkrWitzL1NDZXpmdmpQWk5McllJLzVlODM3ZUFQQkw0OUh3MWZGb3VPVS91eDVaK0xvRFRqMFlJTW1JNHo0eW8yVjBFMEdxR1F5WXJZNXozYjU2SHo0M0hnMC9ENHYwZkJtNUZ1dFhZUURaRndIOHNvK24xbWdnZndXNUh0ZGJzTlRCWXdCL0J1RC9nTlUwUGZiUHZnMUw5L3dXTW9nNTc5KytRMkNSU2pBTkxVeDl3M0h0ZVYrL0NrczMvWFVBWDVBK3ZlaGorQVNBUCtMK2NkQnRDMmJFbWNCU1IvOWJBSDhPQXlmSnFPbFIrc2o3ZHVEdlBKQTZ0b0JGeFI3M2I5KzU2TisrY3dwTGxmeU9BNE1rRkh1d1BmdTdBUDRJd0g4RDRMZGhvT3B2amtmRFYxcm1sZnVvRHdNcHZ3b1RzbGx2OTRIM2xmV1NINkVFQWU3RGdPa2YrTmhPZlA0ZndRRDFkWmc2MDJSd241RkJ4ZG8zNVUzbEdqNzJkNzhENEwzKzdUdVAyOERMWnduKyt0cjMzQ21EamdxZlJRWXU3bnNmS1Jpb0FEWkJUa0UrZ3prd2ROYWxNM3cvZ0p2ajBmRFdlRFI4RGJadnYrSjlhanRic1ozT1psZVA1cjlLKzFrQlRvT0I3R2U2UGVNMTIyNE9qM1ljdkZHQVJnMXZGNkpJTWcwcCtjVEs1b0pDRk1CV0Nla0thSTVSWmw0QXNpY2JEVEg4WENQOWFQeG5ORERmejJ0cCtLS0Jqb29Fa0QzcmFleW1zWlJaRDZpc0o1REJEV0o4RjFQM2tjYTB0UVdBRlZtaFYrR1VCbnltZjV1ampMWUFwTjRQeWpVa2phZWl2Uy9mZDV2RG85MG1wNnRtUDg2UkkvRzZBUFlIWlMxTzlYRG1HQklJOWh6YWhmZDdxeEd2YURWeXVHS3dFZEJTYXdPckZUa2JoQm90YTlDZ3BlZlc5em1WeDJoUUFVcURmYmZsekVSRk96NmZlN0J3UWxpaE5GVmJNTVpPNVlmUFpIOTVCcmwzdHByc1JLSTBSc2ZVRVlWS3p5bm5adHVOUHBUbmFLaUt4cHZhbXRDd2ZCWGdjOVYxbklNT01xMUJHQWY3d1A0cFFLQ0tWNXRCV3ZlR0dqWkpBNmxnMHZBNWwzc0ozRkx2MkIyc1h5Y1V6ZUZScDdHb1JoMUxWQ1E1VmpYVXNVOHNzM0xzejlwcGNzcHVHakUxelNtalBKOVU5aWZQQytXNVBwWTMwbk1hdmRnLzhycWJ5RWJDNjVZbkxsSDNacC9CbkhQSVQxWVpXdGtvcXl0b3gvSFJBTU9JdXh2SUdZVjREbmRoTkh3NnNIU29IeUVEd0R2K25KMDE1K0VjbVNlVFByWWEzQWx5SWU5TGxnQWliUUx5UGpoSFdidVgrNStmTS9LWDlFd0JaZTY5cVh5bllEajVkVXFaM3VRSVdZNDcwUzZDeGo2K0JFeGh1Zk5NbFAxcEJGSzVTblhTQzJTNnhMM0E4MGtEV2dFcWlmR3I1Lzl6UEQwL1kxMVpSNTVOT2x2ei9Uc0RqeENUUFJyUDI2VHkyYk5xWjgzaDBRMEhvcmgzYStrTDErTG5iZnZZYVNUcmtCNFBjbHBqQmN1cjl3R0w2UnREbzAwTEtHazYxNXZyeUhQYXhoKzQ1dEc1aFk3WVk1Z09ub3o1L3AybWVWNm5LZmc3Z1oyeC81KzlkNHV4TFRuUHc3NTk2OTdkNXpabmJwb1praU9LMUpVU1NkbXlaRnVLdGdBbGptQTdDQklyZ1pNQVFYTG9YR3dnZXVpbjg1Wm0rMjJlNWlXd0hTUnd2eWRJZ0R3bHpvUGhMTUdoTFV0MkpJcVVTTTJRd3lIbnhqTm41dHk2ZTNmdnk4ckQvMzlWWDlXdXRmYmEzWDNPREVVVzBPanV2ZGVxVlZXcjZyOTkveVdrZnZZOXI0NkovTG5tUElIOGlLRHBDRkVHM0VHTVNEeEM2dkRVUTdSOThJdyt6T2Fzamd0Qmx2WDNRUHJ6cUFYVTBuV2pISFNhZmRaMEhVSDRYVGhOZEJxbXNnYmZKMHVsS2M5ZEl1V0pDbnJSQVV4dGdHd3ptRU1tMDlReTdiYVdqdG9CQWczWWhkVUMzZ2pzRk1DTjBYQURSRDJHKzFYMUY3NDNuc2NUdU01Qi9pV0dhOTdEczhEMWJBcGdVVnJXeWd0RnBsSWdPdXdOcCtXUHF5MkJZbGFsUkg3WTRPelJJVUt2RC9Lc3o1WHJRZG1OUEN6d2RPZm5MUHVuVGtYTFF2OU5MWlNQQXdJL2IwenpuNTBGZmVjY1AybVlPbTNwMmVmNFNEZUN3MVgyS0hWTW1jdHZJT29XcERzQWdvTXE5WFB5M2o2TU45SmhqdktTOHZPbWx0QWZSSkJkd1NITzV4UXhtaCtJY2diUHkweStEL3hHNkFINU9lVzJvZkx6N0gwb3lGeERzdk5JeS9Xb1luYXp4OVRtY05zU1V1QS9hVGtvZko1R1hkYjM3TWI2ZWROMUFvaVdkSE1nem1zQVcvOFNnTWJmSy90TTZQc01CZnZZcG5hL0ttWWhVU2VTT3J0RzdVcDl1QzZVZ2RHVWZ4V1FIUGovbENYVjN0TjNPMHpnQlVJajlMa3JmL042WU9Qc0VOUzkxN1hBTDNTTWhiNUl6L3BpcTFBNVRQV01zRll5bHg0eS9pRDJnZEx6Z0ZYNjNHc1lYMnZMeGxEYXQwRFVOMWJHUS90V29XdjJNNEE0cGJiWmpweGU5YlNEcEUwUEQrajVSb1h1UlJoNDh6a1lzUFVRQnVROUF6TUVmQTFPOUM4emhTenJmM2E0am90UXc0VmZtQmYxMDRqMVRaLzN6OStBcGZEOWZiLytVNGgxUVhjUTB4NnJzYm1XZExzYnA1SE54dmxMTUREcmJaalJoVFYxbnZMblBRZGIxMmNBZkhWOGEvOVBDLzBNWVJHK3U5NkhFdWdQRUEvQ3RzOTc0WE5iK0xQZjkzVWhzRTNGbGxIZWM4UzZxVXdQL0NLQVgwRk1KL3lCLy95WHNMVy82OS9kQVBBYWdQOERTTklVUHdYZ0w4TUE2SGRoaXNVdit1ZE1TelAxUGw3MzhkMzFjYnpMRk1IY0UxSkxtbEZsUzFqNjQ1Y0IvR2JUTy9EMnU3QTl5L3NvSUMwUkFmVUJETkIrQjlIb05VY0VIT0RQK2d4c24zM2QxNFVHRVBqYTNmWGZaeDNUZWxNbzc4SFNpTFB1OEFnZFVxNmZKNktYa2VoU2wzaWxEMGsvWGN2Njg5eGRRMnJvSTdDZmU5RThEK0EvOU0vZlJnVFEvd2l4cmhRRnQ2c0FYdk5uMFhDNzRQTTd6dXNtZ0w4T2U0ZFQvN2tHNEovWE5RYTlYanpiVFgwYy8rT0QvdTZYZnBUMmVaT21UT2lqSHN1VGJPSmxlQ25wUWFSZktsQUVXQk9oSVY5bjhXb0xFVFdUTEJYWTQzdzNQdDZsZVBCUndlUDZxT0JMV25lR1ZVOUhJQXJtQkcxbTJYTjRqUXBVNU45S28yaFlaWnErcEg1bi9yenNPMDBaT2RUckVJVnhLcXRxWE9vakdvYUNKNlE4Ynd1VzR2RllERHhVOHE4Z3BtcWJ5dm9kSVlMRFIyTHNYQmwzdGs0OWRFemRJL3N0R09rdnNwL0YwN0dUTWluQ2NYTDlKbDZOVGYyZVo5K0wwd1ZiRG1icWQzbnFuc1JvdlU2QnFtSmEwMVpQNDZhNXlMc0dHbEt4eVp4S1RsRGMwNEhmVDJMNnJENVdJOXg0ajU2L3BNWVEwa2c4R2luUFJYK3FMRVZlRld1R3R3SmNmaTNIRkJSWkFXYlVXWUtLTjlkQ2pVbEwrYTBnRUdYUjAzelBOcnduWFIrdWJlMXo2VTA4MVdxWFZzV2FrMEIwVU96TFo5Tkp6Q3BBaHh1bUR6eXJVaS9wSzRpUllTY3dlVjdUYVM0blZyK1c2NWpzTDkwbmlOR3ZUWkZjVGZQaFd0Q1pjKzVyc2pZQ1dOZGI1N1ZwODNrUWZONEc4S0NMRVovUGQwTTNEWHA2YnJkaCtnNGpyeFZBSlI4NWdwLy9La2JHaldGNmFnM2d5c1JUUWRNd1dYSVl1SWdjSnZQb0llcU9HcG1iRzBGb2FOcEY1Rk1LeHVUMHMwVGY4d2pYbko4cm1FQTZ5bElYS2hjb1RTYk5Xc3AzZExJbG5jdWR6b0FVd0FqemtITzB3b2NxU1FrcTU0QlJ5cHFWZ2ZTd040bXBMM3VGT1JUZm5SanhPdTN0S2pxVzhOa2JPeFlWbmoveWZ0WTZxdmoxcExOVE9aK1U2YzVkK21IVGVZamNSZG1SUExCcHI5SSt3NzB5UU15K3RrQkxhbU4vRnRNQ0o0NXV2aDgwa25lQVF1YVN5c3A5d0o5Tmg0NUUxcXRpaWsyQ2F6eGZwQzh6eEhNNWg5bFc2SlEvbmNUU0pNeTBNRU5xeDdqdjk1SU9rSGFwZkx0eFpKU01lelpKK2ZrT0NxVUZDdmR6WHkwbjBVbmdCbUpaSzZZMVptQ0hSZ2dEQXZENDliUjFjVzVKOUhtSHVTZy9KOUMrQTZQUGQ1dnViWmdYU3plUUgzQXY5WkJHeEN1Z1VFcDN6MzFCZStaVnBDRGw2ZVRWVng2UzV6Ym9rbHBmZmVOc1BSa3ZZV1E5T3RLT1FBY3ZvcmQ2UDR6R3BpN1VtWFkwMGR3cXBoOW1WZ25OZkVYZWNZcVVuNU4vaHRxb0Uwa0xETnN2SzdMR0pmTHprTjBBcWZNVEcrV1FKYVMwRkZacER1USs4blBsWWNQc0d1WExta1dCem1MQmpwL2JLMlJzaVE3aTMyOWwzL04zN2dpbURqOXNNN2srNzVleU9OTzlVLzVsMlpSYzN6a3ZQOS9vdlZZUmpBWWlQNytRUGFmcC9MZGN2eUlEWGRUdWR3SDlYSUcwMGw1VFI0aGxZUStIMU9ZZGRFanVLMHhhK0YxSC9ielJpaEI4SUFBQUlBQkpSRUZVSHBQWkRmSnJjdjFjZVVHYmZrNlpRM1hCNERpVXorbXkyaVo3Szc5VzZHdXdaWWp0Z2paRVBmT2MwNnl3TndjWGtEV1ZmbTVzZzZyUyt0SUI3QVpXNWQrU3JTV2ZCOUpzYTVwQmF1Tm9mU1d1a01nNHB2M1lnWUdSTjJGUndEUU1mZ1hSWSsrT2YzNGREa2crN29nNXBtUG1lQWxZVFE4UEdCVjBnbFNCL0dYLys0OGhOVmI5bW0zRTJyOTkvL3pzc3FNanA0Y0hWLzFaTk5BTUVKbkhUWmlDZjkxLy93VUFiNDV2N2I5ZTZHY0hCcVlwODdvTE54NDNwTDNlZ1lIR0ZLcFBFRDBqajJGZzU4L0NBTm4vRlRGdEhNZjNlUmpZK1MyWUF2RStUSUQ1MnpDUTlnZ0dwdDhFOEljQWZwYzFuaDJ3dmdHTGJtWk4zT2NRMHlmUEVDT09uL1BuZlEzQTk3emY3MnU5YUFFRXI4TWlTaC9BUU1kZmgwVlB0MGJMd2dESFAvTXh2ZWpYZnd0V2M1aTFPZ0RiRDN3dTl4RVZKeHI0YWFTaUZ5MVRMZ0gySHJtSEhwWnFYbmR0VGVuSEgwZVRzeFdlcVFDdy8vUUVDTDRKZXcrTTJEMkd2Wk1UcE00VFE1Z1R3VFhZUG1OL3I4UFc4UTRpM2JrM3ZyV2ZLRTJzUmQ3MVhIcWs5Mi9DMG94LzM4ZTB1Nnp4Sm1yVXUzOG56RzJBRFlEbFRkcEZoYUlmdFIrY3BrTENwdTk3M1Q0Umc3THVmUXFpVFFZb1JnUDBKMW50d01mUk11VlNQWTBKWk5aSUJia2dwSXNockVsSm9tTFlCbWhSS2VNYThmY1lhYjNMSXFBcHhwUWtiYW12UFFYM2tJckcvNmVCa0VLYjFrbWl3Wk1DTjQyQk5PSXhRdU1rM3pjK2xsMS96Z25YcndGd0NVcDhialFUSmJ4em5SbWZMNDBhbkdlZlJvckgzY1JZenZSK0YvWkFibmxXNTdOYWxUMC9WWDdPSTZGVUVldUo0QjhjbzNLbFVmdk1GWmlPQ3FZcUJHMEtKbzJjeTlMWmsrK0w2YlJGU2VrQlNWMHlJQnJET0IvU2cvQi8xNzFZZUI2amNnamM4RmtyNmN2VzlFV2paa2dyUDRucDRWVnYwUFZVWjBrYTFnbXVjTDJtSEVjVm94bG1tVUdMZElMS09GUGs5cVQvVG9abjcwOGpKSVBodkVyVDZpbHRZWFJiRHlhclhZV0J3VWYrM1E2TUpwM0p0ZFFEYVB4bmVuazZvZkFhTlVCcyszV0x5UWFBdHN4THdaYmxKQU9BeFFnSHBORXFCREJHa0hxTTUzaitqdlIxdWdHZG9HNHlLL0ZkWHl0bVYrS2U1ZjZlbzFBcnNvcDFVYW5YZG5YbXVZalJuTS9rT2VPNTB6U1NJZjJ3OEUrZXBiRC9DbjIzZ3BoVkJDMTVEb0c0VmdTTkNFbzA4Y1dRTm5PU1JwRnVJMDM3cDNSRE15YlFXWUt5REpDQ1ZWd0hkYmdPMGY2RjhXZ2taNnRCakFhanZDL2g5NXNZYTNsT2t1dTdBRENYMGFxWTVyMkd6ZWxZdnJzb3FKTWJZanVCd2xVRUQ3VytIdzJsUU9wMEFLU3lOelBNSFBzZUpPM09vNXNvQy9OY2FLMTNacUhSdW4zNlAwRXZSdi8zWUhSaFdUbzdsZFJlUnFTRlFXWVVYU0R3SjExRFJEc0dZSFlNd0doWTdmOWZSYlQ5TVhBZ2dCQ1QxY2kyMWlhNndoYWk0ejk1S2tIZFRzRWtLbDlWbHI2YTZhSHBPRW4rckZIRHVTejNVTDZudytjQWFlMXBmbjZhZ1R0OXhOcjE1T2RQK2RjRW5qL3NhalQyZDNrTjBjR0FVZVBodldmOG5BNWdkUDdhOGJHY3lUNC9FLzJIZGkzU0l1b2ljOFE2d3NIaFBwTUpWeHh1dWphaHZVRG1FQ0h6WUhya0phSnNwZUJnWSszUURzL25uRmJxT25ZWTk0ckRValp1ZFRZT05Ocm5zWkwrbXpSNVlxbk9POXVJTG9HZkswK2xUSzY4WVo3cEtRUmtRcm1hRnQxNW5YNmVSN3hwVnA2elNVd24zOFRQZzVOMEprK0hiQ0dJZEkvL2E3Uzc2dWVjNzZuTVRjdEJBSDRtbXZhNnYwT2VvVGJiRGNmZXozbXUwTjlOQUdDbDFieG5sdmY5dUpyTWg3cmZZOE42enFHZmw3SzdxRDBxdE16VzBzL283SXJ1cS9ZOXZYK1RjYStqSmRsMXJVRGpPbG1ueWdCR3lxdHl6cmhXbXZsbkk5bXlOR2FJMDBYWDlWb3poeHdBVnYwOW5DMUVHZ3lram9iaHV3TGZiclJ4Rk1ZUm5IbzIyZk9paXl3N1Bvdlh3M240VU8vTDMzdHByM1U5TjlYZTdWNnY5SVhVcDZXeXRBVUQrQWcrZmdVR0JLcmdmQlVtTE00WnVmZTRRQ3NIbm5ZUlBkc29qSTVoQkorMXRzamNmdHJuOGoyLzVqMi9kd0JnSVFCeU1FcGZOaUFrZlZPUVVyQlI2MGpVL3Y5ekFMNlhyNkZFdjdMUmNMQTl2clZmTk5MNnMybVE2c09Bejc4QWkySzlDd1BKV0hmcWYwZWFCdU41QVA4cGJKM2Zob0huZDJHQTJwZGdrY0QwVHAzQjBqdmZrYm50d0VEM1o3ei9HN0Q5ZEFYQUg4RGVCYU9VditEaitEMFlXRHlGZ2FkaERRUk1mQjZXNHJrUEEzVS83MnZXQlFDbWM4T0pqMk1id0QvenVmQlphdWpQOTdGNit0Rm94NThRWWVHL2orRFIwR3ZHOWJGb3ZyOXFZSDIwKy9UdzREcU1MbndLcG5SOUI3YW1qTzVWUUdZWEZpM045TjVMbUtMenN2LzlGbXhQZlJmQWgxMGlwZ3ZqNFRuS3ZaLzZ5eHF6Zm04MTR0ZWRScTREdUg4UmtQNHkya1VFL0IrMUg4elc1WjJMVUtDS2ErSUIySEFQalN5bmw2MGdsQVRRS3FZcFppTXRQRjBuTkltQm9PVEpYaFJ5c0JxcFJ6Q0VpaDhOSFh3MkZjQjU0Um1VRjVMdnhIaW16Mk4vSjBCSU8wZ0RFUTNtYzdoaTRYMnIwa2IreW51YlBNeVoybzhHeU5Oc2JJeldKUzlLRENSVkJPVlVFU0FZdlJKbDRkOWRnZFQ4OHEvNERoODdiYXBTais2a2RvMWNjKzdvdmtKZm5SUVVWZFo1L1RyaE8xTldXRU8zQ0l6NHV3b3k0T05lYTFGbyt3QTYxMjJzSW9DdENoL0JJWUtqUWRGRktqdlYyRnlCMGxwaS9KdG51aE1RVmhpL0FvZjZYb1BCUUJSTWZxYUdKaHBVUSsxRXBNNGNCQW1BR0oyekVnR0dLRHVPNVc4Z0JaSnBZQTVBVm1GOXFEQ3VSTWxXc1RZdEZYM1NJZEpIMHR4cDFlSWc0MzF0STgzMjhoRFI0Wkh2ZmlxSzZ6aWZlMHUvSzN4S2FQSlpkcWJ5VWlrcWg1UDJqM0FCZy9GNVdoWEJYK3BoM0ErYWphT3U5bTdUR1pqdmhMeGxPWG4xbGZzdGZXOTUzMWNtRGFDNnJNOWFucHZkazBRaFZoSXg3NWZWaUtVV0d1dklaM1R5dXEvQml1R3pnWjhyemNnanFqUWRLKytsRVRaMzJxTHNRd1BQV2ZaNUh0V3ZCbUVhbWdnUTBpZ2N3QU0xMHZENTZHNUkwc2lMM01oSXc1elNtZHhKaVB3cUJ4dWJlR1dJdXBQZnBFbFBncCtyUGw1UENtQmhidVM2NFBNYXdZZ0NjRVo2TzV4WUpwWXR5RjZTOThFOVFzZVNZOFM2MWp3VEN2RDJZWFNSOHVlaWlRYTJuSVhRbXI3UHppcWRva2FjejVxbFlsOU0yVTdiRU5PazdzTE95bjJmQSt0NnE0TUVZQ0JsNS9yc1ZYU01Pa2FrNHlOLzdzYTFjcXNJSEpML3FNMUJ6K2F5U25XR0s0Z1o1Qjc0OXl3Und3eUlkSERhOXZXZ0lmaEJ4cWMwb25zQXMzR2RJY3JTQ2lTdjQrY0VxZXRKV3RKRjUwdUhxeHJSc1pRcFora2dzOGozU1VOZkdoMStoQlFnWDhCcklBcy9XQXY2VU1iRnFwTWp6OU5zc3NyUGVRLzNNZTA0Wi9MM0U2RlpNdDZFQjJidlVKMDZ5ZDgxZTh6U3J5bWVEZElmbDVYR0picVlqYUZUZVJTNXA4VFBTL3A1RHdXZE8rdUxqUUJzcnJ1c1JQbkpXUU1pN1ZUSEsrckJrREcxOFhPbWpnNDF1ZjA3MVFrQ2YvU21RSkJtZm1CR1I5YXFKcDdBc1p5aEd6L1g3Qm9yTWtBVm5UMjU5c2VGTlFLdzRzZ1VzcWdWbmtsWldYbDZ2UWtOdmtqTDlLY2lMYmhNTythRytqblhrM0phMDc1a295MWtocGlOTFp6THJQOWdGMy9TTnRwTjFyT0tFZEhVeHltN2t2WnlYaXByVXdmaDJlczhQMzAvWWh0SW9sMDNhUm5kb0g2K0ZxQ1dzeGljeDJROFNXQ0gwRlRhRVZybkxIWk55cFlyOWttdVFjUDliWUVuS3J0QnhzVU10VnpMVFJ3aGdCU0E3K2xuZXYwUWhlWWdTVDA5UEtCSDNnd1dSZmNTYkFQdHdFQkFHbTNwaVg4TndNUHA0UUVBakthSEI4UHhyZjJpUW51UjVnQXpVejNYTUJCcERnT09qZ0ZnZW5qQXpiT0VSYXcrQmVCWkdNaEhUL0dGUmhSeTNwYzVWZ2NzcjhDaWlpbk01SXJhV1ZiZmxHczhtaDRlekJTMGtucXYrVE1hRFhnZWhYbUdhQ1FIREN3RkRKZ0ZMQ3AyRndhNmtpQ3d0aStaOTFNd1llMEtET1JseXV4VFdHcm5Cd0RlSDkvYW4wdlU2QUsyNXRkbFNQcHNUVW45TGYvOXBzK255WW1BQkkwR3JCdisrVHJ3bDJtY1J6Nm1kMkVHbFpmOTNoNHNHalRzaWVuaHdRb1FPajA4V0FBUklQVzlGcjVHRkFLTGpnVGlERUFIaE1jYU1iOWhxNEVrSlhUeEhYaGs5MC9BMXY3YitwWC8zb1VEQjdDOWN4UEFDN0IzTUlEVkVLLzk3M3VJTlZKeW9LdFRFOGVBRVlDVERkTFJYNFh0eHcrUC91Y3Y5OC9tTlc3KzNZTW4vajdJUkM1VGVQcTROZ0VmenB2MjVTSmVaZWUrOTNHMEZxRWhySTJ2RmZjekJTSVZHb3I5Vm51M2N3RDBYQzBYcEdtTXJ2WnVKNTZuQmNHb1JxWWs1Tzg4TTU0a05XcEZtT2w1WDZRWDVDdEFCRGZVVUt6UkJEUnFxUWYwcU5xN2ZaS050NGFranFraThGdjcvZXlmL0pPUmFSUjhOYU1IMjdZcmJDZmVCOEd4Uk9Cc01haW9NOUpLRkkvTW0vM2szd2RuR0s2N2o1ZmZsVnJ1OEVSanhoYWtSdHRqYkl6RVVNTjgzdXJxa2tEZ3JuU2dkRjJEWWJibjQrdkJGRWxHTWlkR3BPd2VLbU90ODI2aVhWVkx0SjNlbSsyNUJCVFljRDMxTEtxUkowKzN5cjFKbmcvNHUrUGZIZFpmRlVJdExkSEZRRU5ueTZEa09aMWh2N3JYMVNNNHJJUE1KemlNaW1MRk1ZVXhWakhpamMrbzVYODJmY1lDd0pHQ1NwTUkvaklLRVRDYVZZcStVWWNUblR0bGZWWHVsWjVNZVordnlWVWY1eFNGY3k2R1d0SXcxam1uMFRuWkQyNVlvd0dkRWE4cmdLdzhGL0JvSlg0M2liVnB0ZEhZcjRZTElOSmZPcXBjV2ptaXBpWkdSWUkvYzFodDVOeXdUOGVrcFkrTEtaS3BqNUMrTC9OektvMWdNZDlwVzJzMTBsZHBtUWFOWWg5V2U3ZFB5U2VRcldHMWQ1djBKZWZSZWNwcXZqZG1CZUsxNFZ3NFArZThLYVB3RFBDY2gvbjRaeHAxdzcyMlJKUkZRalNPOTAvamwvSnpJT1huZEZJTGRGY010eXB6QWNEQTUwQURNdng1bTlKTm9PQjA0KytEejJ1aWpicm5TLzIyUFp1L3FUOC90dXdhMGs0UmRicFNaQmZIZENuamFlT0JHZi9UWjdGV2RwNTZsUHVBVWFyYk1GQndXZTNkcHA0N2hiMUxsUnNKSnV3Z09zYXZOSmNORTlwZFJTZUZ0bnJLdW03SnZQMk1EcXU5MjFzbGdERjdQczhBcjZNelBNL1ZNYUxUaW1ZRU9FSk1yWHhhR2FnTFpGSFFEWTA4R1lqcnlocUxYUUFYZ3FvblRxZm1mdFlwUjJuSzdpUjZDRWpXNlFpZTVTNHpsSjdJdmZvK2cwMEhNYktYTFl6ZCsvL0E3ejNObmtudzl4cUFlYlYzKzJHQm45ZUl2RG1mTzlkWm5lMW9ENlJUR25VUzZqNGxIc3AzZjBYbXhmMU1uc1RucU14SnczcUlKaXYwUzZDQmF4V3VtY1E2N2RwR2NyM3lBUWJKUERIUXQ4cUFYVi9IRWk4ZHdIbll4T296em55OUdZekV1YlRaT0pRdjVmUThiK3N5Um1oMEg4OVhEMERmK1NMdnoyVkVsUWZER21UenBYNitxUFp1YTdTZzh2TStUSFpSZnE2UnR6blBvdXlqSmFCMDMyeFZlN2VERTZUdzgxT08xZWRNL1Z6UFlzZ0VKdllLcmtsKzFzWStacWFBNXhuZWhKOXpYaVYrdnZRMUk4amVkUiszOGZOY1ArL0I5dUxnUElEYnBrMzBwOFk5ZVpubmRVUDl2TTQrSzhrYmZUa25sRXZDdnA1RVp4ZTloL3JOQ3ZaUzZMK2tueGNkL0RkcEc5cEtPVTdTVmpaMXZDRm1semc3cTI3YjhYa0tITE9mVFFETEJCejE1emNGMytYL2grYnZOSDh1K1VsdzlNN3NMU1hkdU5pMy85bkVSelh3bzlTYU1xbVJWK1Q2cklMbktqdTA3cUVxemRxZzYwbDVibVdlUlFCWUdqMGtTTmp2SXFZQTFnTnhBMFpjSHlFYVFXdWszdUliTlFjUTJ3QXlDajliTUpEeVRRQW5BcVR5ZmlxaXp5S0NoUStCbURyNmNUWUh6eDVsQUcvVGRTSFZMUXd3ZXdmUjJOSjY3L1R3WUozeXBNVHJDQlp4K1pPdzlmazZnRCtGZ2JSNitKZ1M3azBZK1BzR0RDZytncTNwMTJIdi9ENU1XV0JLVElMMFBVU0R4M2RoYTg5MHoyLzdkNS94ejkrRmdjckhpS21zazgwcTlaNzdzSGY0b2QvM0xWZ2tjVk1FOEJ4UjJlajdmZCtCN1dkR1lnOWdZT0FqQXJyalcvdkZHckg1WjFtRXNxWlhXRTRQRDJwOXQzSnREN0h1OU1lbTZickxYaXlkRS9WK204TEFmMGFJVU5BblVSekNvczc1L212WU85QW8rRFAvK1dEVE1jczRBWGZzNkhnZlBaRmZHOS9hbjMvd0QvZDdULys5Z3llaWJPU05qUGRKS1R1WDBjNDdYbEdXMjVTYXRqUXFGMm9mNVZwM2ZXNStUUTdZb01NZTkzczJTcy9XMEVyMWYyWUFRdG9tdUNDVkswRVF4WStLbUF0cTlMeFY0VzlSZUwvMDZPOW4vUkhNMFNnK2xuWFF0RERxaFVzZU9BU3dreW1aK1hxcThqclBRSitnMEltQ0VJejQyYzhjMGFpV3BJL1RWc1UwZm1wRXF4R2pqRmZldHorL3NkYXJmODdVYjV6dmN2THFLMGVsNjcwUk5LYWhtQzBIc1I1TEt4a3FnT0s1K1ZqUlNRVThxK2d4dXR4QU1kZTl0U0tvUy8rbHo3dU1MZms3bzhIemF1LzJJRi9qYXUvMmNKSjYyK2VaVC9UczVjb1grZjRpZjZlbHVlVEdON2FKMStBU1JhWnp1bWVrUU96QTd5ZmdHUUJYeElqM0FjeG9GNXhGWEZHbWNxc0dkenJZME9CS3gwS040Q3Z4cngzcGw4QUQ2V3ZKWUIrY09CRDNsenJrQklmUzdOMXlIZGt2NlZVTmt6dDM0WkdxYnRDaDBaRFJUenBtdnE4UStTYmd3ckZjazlSWjh1ZnRJQnFTYzhNNUVJMSt6TnpVMkVUWjFrWjZ1ZzB6N25RMVBGQy9PVnQzVDR0QlpJQUlXaTliM2lGcjBtdTZ3R00zdG5iS3pDRm5xSFh2dDR4QlcyNGs0V2RMbUtNQjkxeC9ra1ltcVZNSDl5RlRKOUtJTzBjRVJKaUdWTytuUHBGSDR1c1BtNEsrK3NNek5wZDdTTDltdmc3NUd1Z1p5dms1c3Mrb283Q3BVdzZqeTNsUGtmZUtRVTIvNXp0c00rZzNHczlFQmt0b2M1Tk1VV2hxWk9xdnVmWlNtcysvU0U4bUVUUzlOSWZiTnVQbGhqSS9JKzVybUwzaXlQL2Vydlp1SjNRcTQxbVVNMVZ2VG5pMDBMRThJZytJNTZKdG5BRjRxR0tVQzBHcmhZOXZoM0syUFBNSzByckZWeENqYjJrbm96RXpkNUE4UXl5bm9zNDlCRmZvR01FNU1qVjJramxtWWxGVzVPYzAvbmExd3hFdzZzSEFtNUNOd1AvVzBnWjhCNHpLSGNQNDdoekd6MmRWQkk3cHdISXNmelBpVU9zMmxnQ3pIZGllbUdhMHN1bGNMbUcySzQ0MTJiTWlteVJ0RXAxREtEZVFYaTFoL1B4S1phQTIrVG5IMzNhMkNPU2ZDdDgraFlINkFTelJHNm9ZT1Y4WERPNUExQjNXdnRmTUdFOTVrR3RHSjRoTitQbTU2enpLR1BvNnJ3YjZ2c3kvY3psMUpXMS9VMnZTYzg1NW5kcEs4NzFEZms2YTI4UVhWVCt2L1h4UTkyN1R6d2t1cU4yemhzdnBHZituczZEcTVwVERhQ3ZtUE1iVjN1MHpqcmV3cmtGZjBuM21leitQVXVZODZ1eUhmYksrZVdOdDZCWitudFJITHJRdS9Ed0JjTmZzNGRMNGFMOSs3SGdHY0RFZ2M5TjJXWGE2S2dLKzFHT1pNV0VIUmpmVThUU1hqMXVETFRoT2JLQzNiOUpVOTgzNnp0TUI4d3dTME5iNjFMbHpRbDN0M1ZiSDlCVzhKWjlINlQxa3o5OEVPTllBajc2QWx3cFNKeEczVHBmME84cGF4Zk9YMFFDbGoveTduMzJuUEdtVFNPZ2tFS013am5XeTNGem1OWVBSN055Qmp6YU1Sa2NTMmlqeTcyVWRWdTVyTlI0NVFFSUFtRkUxZlkydW14NGViQUg0S1poUTh3Rk0rQ0txUFJ6ZjJ1OGNOZUtnN3hBbW1JNFJhOVMrQjZUUmxOUERneGY5ZWR1dzlMOWZCL0FnUytkTTVYUWJGcTE0Qmt0RCs4YjQxdjQ3SGNZVEZONkxSR215bjY1OWVIVGxGMkIxYVlld2VWMkt3Vk1BeW1kZ2F6R0ZnYk16SUFHaWg3Q0l6UUVNS0FZTU1QMHV2Tll6Z04vd3Y3VmU2L2ZrSGZCOWptRHZjd2w3dDcvZzF4N0Qwa1BmZzcyLzd3SllOcVgvblI0ZS9EaXMzaXozNDY0Lys1dCt5VS9DNnI3dStQanVlSi8wL2g3QkFPTVBZR0EyWVB2MEdpeTYvWkgzZHdMZ3RHbk5CY3hYWTRSNjNPd2lwcGorUUNLaXIvcWNxYXlNWUttSG40UW5kdWVXT1ZFTVlkSHJPUmpmaDZVUmY0UzRsbFNvYUVDaGdya0E4TGRnYS9JZURQeGxGQVJnNy85dHVNY3hiQTlzZk43VWFRUllUZmRjbU9QZ3ZNLzZZVytiTXZ1UHV0LzhHWmZaZjJhUWZ5SnplRkt0YmEycTFOdDdCRnVEb2hGZkRPNFVwZ2tRTmFhZnl1NFBIbkFpL0dtMEhGUHMwc3VlamZTQUVUMUJHZmFmayt5OWhYUmJWWllTc0dGY1Y1RUtsS2VJaWk2TkpVcnpnUWg0c09hV3BuVWE0Z0sxS3h2R2VNMzdQMjU2UDNLdGpwT0diNmJlZXV4UmRSeURHSWNWcUFzUldac3FvWmQxSnB2NktRQWRCQWJWVU5Ga1hPQVpDb2JkL05xcWtNNDdmM2JibW14SzgyZ0FoQmd3NURQSTcyTGtqb3gzUlpFU3hVN2ZNWUdlenA3eXFsdzNqSUdHSlkzU0pkMmhJc2hhdkRRUUJNTXhvbjVFNHhIdld3RU5xNWdHa01ZWUlMN1RJU0lOMEtnSG9FV0JsVG5TcVZIVEcvY1FzNnVvRVhVNXNYVE9DVStTL3FoZmNhOXhiaU81N0dRU2F3bFRidVhubldtQXI4a3Vuelh4OU1aVnJKK202OHIzTWlqUnFDcEdsNnJzRFVTajEzank2aXYzQ3ZkZEJZQ0pwTk9VZlRPZVpEVkpFWjJlRnpEZGlQL1hrOHh4cG9VV2RLSTF1UUhuc2x0dXhHOHg2bk10dVljQkI5b25XUnBTQVcvNmlKR09ORklUNEc4RlJnWDhJZWhNaHkwOUZ3TTVsOXVJdWdMUE1NKzFBcG9EQ09CVVJVY09HcGEzZld4dDlkZXUrSitrRDh6Y29ka09ab2k2RWMvNFV0WTVHQnRoNjkzS2N6ZHRRbXNXNndBUDRaL2NpN1ROdE1vMWw5a3FBYXN6K1lMbnF6Vnl0NkhQdFZrdk92U3h3dVBrTzlvTXlBZFlWNVVaWndZbzhEN3ZrL1NEK3hSSURadDltRU05NWVDamtyeFRBR3VTNStpek8vemZoL0dScWV6VExjU01BZ1JCSHFETXM2LzdYQjVsZ0VzZlhxdWQ5TEdLa2JvcjE3ZTFEdnlja2JoVDJQb1R2R1lLWVRvYk1QUFJOdXlzY3V4MG9LR1QrTmpIWGVJM21pS2NkaDJlNmNYazFWZnVWUkZVSitnTWlGelRNa2Z5Ukk2RE1nR0RGSFlRNmRwODRxQTUwSmo5aFRTTDg2UHRwZS9QT0pta2pnRGNlMGZyNkVmaFdUd1RtbW96R1p1QUZRUWZTcEhDNU9lays2U2pCQnhIazNKSmkyM1lHcGZxcVk0YVBtZUU3RnpPL0lWb1I2bDlSUHg4UmErUWM2UnlMcStkWnRjcHdLVE9EcG9sb2hFTXlmaTUzcGNBenVRQmxUaGpTRGU4UnpOdThEMGRUMUw5UTdQd3RKWXM4WHVZOVVPZHVSZHl2aGxwcnVBWmtLYU1KZTJrdm5DcG1iQ3E2UHk5MWhZaTlDT3NNZUpaZmxMOGZNVlJHRmdMWEsvdDAvdTRzSDdld0R0VUp1TStXTXIrYlR5N21YN2U1RndXZ2d3Syt2bmpzcFd1MUlORnRNZlIrYWRKUDIrVW4wcTY0MlhJV3cxam9HT3NCbXh1eWQ5YS9vZG5XSjJiTklOS29QT0ZaeW05NGJrSjJRcUVQMjQ4endML1U3cXE3NFN5emJvelR1YzV6WWdZWkE5Z3BiVENXanJZMU5aNWdmWmdVWlVER0NDMktLUldwZERJQ0QvZXQrSlJNRDA4NkU4UEQ1NlpIaDVzVHc4UGRxYUhCemNkdE5IeFBBVURkTDhJNExjQi9PY0FmZzdBcm9PWEN1N3V3b1M3ZDVHbGQzRHc1d3kyT1haaFVjTGIvdk5UYlJHNTA4T0RnUVBiUHdQZ3J3TDRLLzUvYXl2MUtTQm92aGE5NmVIQjBIOG5QN0ExL1RhaVIrWW83L2U4emQvaEdRd2NmUVBBdDhlMzlzODAyblY2ZUxBRFM5SDdLd0QrT29EUCtSaXV3eGdoRCtnOVdQUXZoUzdXSjJIait3UU1LSHprMTM3WDc0T1BBekFRZHVUUEgvcGU2V1ZyZWhmQVZ3RjhEY0QvQitDZnc0RERGMkI3N3pyaVdqRmw5VXN3b1BzbHhIcGxUOE9BWkg1K0g4QWZ3NktDNzQ5djdVOWJ3TjhyTUpENVN3RCtHd0MvQStDL2crMlZaL3dackMwekFQQWIwOE9Ebndmd0h3RDR6d0Q4K3pEUThjSDQxdjdkanhQNDYydE9zSjUxbWhtOWxqUUhUZjhRRmttdXltNGZ0ZzQvQ2VEWFlQdm5QNEtkUWRLVEhiOW1qaGlGL1FMTU1lQnpzSlRjSEZPcmswcWhNUlg5ODE3ZkYrLy9EL3U5RC83QmZ2K0RmN0FmNXVIdmx3YkkxbGFaaDE3ck9OWjkvOFBVdXF4WFcrc2lLUEVaR2ZCeWFmM256Mm9aQXlNRnRnU0lhVEpnTks3SngyWC82RGhVV2VaYXl3OFZENElTTTBUUDhWTGo1MnI0V01DOS95cUxRRng1bDlsbmZOODB4b3dLenlNQVErRlNEY1FoVXNHTlBpZUlSdXlWc1U1ZWZlV3NZQ3dmOEpraWtKS0drNllBTWQza0RMRk14aEZpZElJYW1KaGVlZXA5WGFta2RwNnN6OVk1OXdtTlltdWp3VjJJNURpNGpoc0JQNCt4S2JDMmFhUFFmNkhXUkR0RStBN2dMNi8zbjNYQ09XbEdEN2JQODNPSTB2OWk3TmxvM05rK1hxSFhQdVltd3crQm15WGltY3lmVnpRY3lYakRNeWN4WXJWVG5iTnE3L1pRak5kYTJ5dHZUQzFKQlk4cCtrSlVnNHgzNllZZFBsL3BsVVlBQW9YTVNaTlhYMkd0VzAxelNKckRkZENzQUJ6REFCWjFzVjE1S3MyTXIyM0x0WnIrbURvUW95QURvT3FHOGwzdnQrOTBZNmVLOVFVRFhZZWRkWUlBQVF6T0RHZGNxeWJnc0tscGhKdkt1VnR3STZDdkM4SEVyZXpab2NtKzROalZ5RGxDSVhxNGt1ZzAyZXNqbUY0d0xOeXpBNU5QZDJHZzkzVkUrcTdSYlFPbno2d1ptYmNkQU5kTDg4amF1UTFDL2w1TC9FL2JGaXc2aldNY3dmWkV6KzhkVnpGeW5Ub3FEU296QUZNYVJOakVxS0hqcDlOVE1PVDRuaXRsamFEc1FNTUllVGw1TS92V0xCaUJMc3JmT3FhRm43OHBUQTRyR1hzd2VmV1ZrUEdEeldsSm9JT0ZaNU9XMDRoRFIxOUdQVFBLWWlEM2M5L1BZZWR4eTllWno2VHNldDZzR2dzMEdMcnk1bU5YeDdkT2h1WkxiblhoYnhvcHVhYWRteGpWTHNUUEp6SHFaVkE0UnpQRURGVWg1YmNER2tIbUsvQk8waWFDY1FUTmh0azFORjd5ZnpiU3QxYmFrSU85aUJrdWFNVE16OGdTQnFZazRKR01WWjB5MVlHUzdSRlNwMjAyenEvUFBlN1BPTVZxRkhHeE9TMWl0cmxkTlBQekV4aUFQWGRleXpyQ25NY0l6bE9jbnl0OUp3K25ycUxuczhUUDUvNnVlZjFjZnFaK0RXMk1CTldaaVdEb1p6NnNvK3lSYlJoZnVlYnpMZkZ6QWxJN0FLNVZlN2VmOHV1cEs0MmNuOU9aUXVkRUdZZXRodEY4ZnFaMGQxTWFvSHkzemo0Zlp1ZUE5SHpRc0w2NW5LVThnV1VBa2liNnFOSnM4dUlrQXQyLzQ1NGlUeHJKYzVQejQvME1HM1RRTm42bTdTTDhuR05vbzJuazN4eGppTHFWTWViOG5PZTZCakRUWjFBM3lXZ0I2UUgzY3grMjc0cHJnNVNmNjk2aTNLVzJBc2h2M1VmSzR3Rno0anB4aHhLMUorYzBiY1hSckVGdlVobWUxM045emhEdHRScDl2bDNnNTdSWGpQSTluY25zbXphQ09sMnp1aDNEYVBIVWZ4NCtTWDVlME5GNHZzNDdmK0FTZEhOZ1JUN1Z6MGtibWFGR0kxL1hSalU3UDFFZ3N0UjZpT2NCZnUyNTdBNWQ3RHlGTWV0K0QvaGJ3M3EwT1FDV3hweG41MmxzSXQrcXJiQTAvcUR6KzkrMGxWMUhsSmw2Y3IwQ255RmprTmhiMVlrdWYxWXQxNm16VVNnVFU1cG5tNDFFdmcrMFRyN3FWUWJRYzF3OWVQblVCbjJBc2h2dEV6TkVteENqb3dmU3Q0NUZuVk0zYXV0U1FOZXdsL0ZXU3pRZFFiOGJpTXoySG1MVTU5c080cndNQTFNWkhYTUdJMlIvTmowOElBaEk0QWxJaGNEUCsrL1hwb2NoUmVzWmpBaGVSelNNMER2WU9vdUFaZzBUWU4veGEyOEErT1hwNGNFYmlOR3I3UGNsR0ZDWHQ1M3A0Y0UzWU5HTHg0QkY5SHFrYk0rQjhaNm4rZFdEUXFhb0FqL2JUVmpkNGptQkxobnpUVmhVOVJSWmJheThUUThQZGdGc2pXL3QzM1BBbVY1NkMrK3pkTkFYTUZCZm82b3A0RDBMQTBnL2ljaUFQd0VEL000UURTY0VxRC9oOTl3SGNFZEF1MjJmNHdDUjBmNE54THJESjdBOTh3QXhKY083c0hkQlEvbGdlbmhBUUZhank1ZWUrdm8rVE5tZzBlc1BmQ3k3TUVQUERnem8vbzQvOHdPWU1NMWFWUVFsNmQzUFZPYjVHdmQ5THIveFBLeXpBQUFnQUVsRVFWUUtjMGpJMjk4RThMc3djUHNJTWMzUENCWXBlOVBIY29STHFuZjBHQnBybFMzOGI1N0JZcXBxMzdjYUZjSFVibGRocWIwL2plaXh3ejNSaDcyZk4vMy9KWURuQWZ3bHhMTXluUjRlL0Q5Kzc4bjA4T0E5QU1kdFlMbWtnZDZDSzFoMWplTVAvK0grN09iZk84Z051TnFHMDhPRGVWdTBjSmQyMmQ1ZFA4anRjWG54NWM5d0p2Z2sxcjFYV2JxVS9GbXNqYzV4REtwQ0NnNWgxajJmMjRvZ2RWbjdSd1dEd2pnMjhsRDJOZGJyeVIrQUtId2xpcDBvbU9URlZDSnBRQTNDZHhYcjQvRGM5eXRMeTZZUmR2Uk9wcEttQ254ZWo1TmpKcEJEWUVNakFNT2U0YjJ5M3hTYzJ2RnhhTFFEalUyTEtxM0pyTkZMVktvWkVjWHg3aUlxbUtjQWRxWHZITnpJQlZDdFFjWm93cVMxblJrM1pIVktOZXJYMDdqZCtaN0xiTHBIc3ozSUZGbEJFZHR3UDIvc0lkbUZGdVg5aTlMVDZBaVNmVTdhb2VuVzlIc1Y5dk0rTnhiODI4YldOTllxcHBya3ZYa1VVSDRmUDB1ZTRYMEZwNHpLMCsxMWZUZFZUTTI0QWdUbFRZQmxmWForVHo2K2VSVlQ0QVk2NFY4enBXMnZXbzFxMDFTMVNrc0FlYWMrZDNyTW4vbi9OQlJUc2FPaFQ1M3FTUHRvNktUaXliT3F2SWlOL2RMeEl6ZmVxbkdRMzNNUE10TUNaYWZUa3NIQnoyQ1RJZUZVeHNEb205d29CeC8vRWpIU3M4bjRPMFdNVXFXc3lmdUhPVDJZbUljLzVWTWFqUmt0dGoxSmEzNnlOQTBiamVzbjhKU2hmdDAyWXRRWCszMlVnWEYwUEY1eG10RXhyanQvVlFTNk5KcWVmUkw0RG1CVW9URWFUT2xuWDg2QjhrTUZyVFN6QmczZlhIT3VPL1VFOVo0L2srOUc4UE1OQjRMay9UT3FWMU9uQlhsQ2FBM1BUSWdLazJ0MUgrV3RWMGt0WGYvc1NtWDFqUlhJWjVUY3FmTnpIUitROGovT204OVZrR0lHaXo3VGM2UnlTazV6Z3NIRzZldEd1cUR3NTY3WGt3NCtTZEJYbjUvVFlGMjM4L0x6a2oxbGJhdWsvclYvVktQQUMzMmN0RWtFZWp3cE9FVlY1cnlqTXVzTVJqdW04R2pVN0IwejJ3dXcrbDVXZ2dVNk51V2hqZmU3Z1pGbjZTcGloRHl6Snl4Ukx0Mm1Ua0xhRm9oMm5PMXE3L1lqbU56Y0tVcE82SzZtYVMwMlgxOWR4OUxaeWgyNzV0WGU3ZnZTdjlMZFUrSG5JUVdyOEhNRlNpa1A1R3RRKzd6cGtERnozV0ViMFNGMjZOZlFlWUIwa3M4NGc3MlBIZGg3bklyK1FKcThCYk5iem1FMkpOV2RTT2RWeGxuS0QyRDhuSE40aUJibnZKWXp5SEkyWVoyRnBnZVpkaExyaEZMbmF6cW41T2REbVE4ZEx2b0ZmbDdMR3ZiOUdReEdTUnhpcXBqOVFXMC9URFdxMldkb04rN0pOVGs5NEJ4VzFrVmwrUTM0T2ZtTFJndHFCR3JUZXRHaFJIbUw4aHo5QWFKREFHUnZieUhLUWdIVVJGeDc1ZWN6R2U4QWRrNlc4RlRKSWt2eisyWDJiSTR4NkFkQ1YxVS9WM203bEkxQjlTWHlpaEV5aDFHbmJiMnFYTGVaNjZkL2Mxd3pSUHNDOWZoQnhzOTFYUk9hVTZWcDBWZHFBYTlyUDJqOHZORG1hS2NiWFZvbmZUUnYzSU5kN3BVelB4QTZVTkxQY3pra1JBb0xnSmlQSWRDNWd1NitzWjF5MDdVUTJrSitrbWNjS2Rva0c1NURSNlkrbkU5MEhVOFZBelNBRElndU5lM1hhUVAvYlZ5M1NWb1dTbTEvSVVWOWJtTXA2SjVzcGJrRmU2L1lQb0o4SW4ycEhrMTdSaTN6WURwOWxvL1NralYwbUtNc3FtTW9uU1BTeVJLdldWdkdxS210OVRLWUhoNk1FV3U0S0tNZXdrQXRwczhkSWRhVnZZYzQwVy82ZGIvdGZaQTQvajRzMnUrNi8vOG1nSDhGaXdpOUNRT0xYL2J2M29FQmVNY3dnSkF2NHkxRTQzRVBWanMyV1R5SkZxWTNkdzhHRFA2RWovTUlCdXFld0FUUjMwSUVLRGxlS3VCL0FxczMrd1pNZU9HejFHdE5OenlqVUs4QWVIZDhhLzlZSW9sbk1PRHhBMFNtenFpRzUyRGc2M2Q4akFOWUt1RXpueE1QTkEzanovdHpudkgxZXdzR3huSmp0cWJEOVQ3cGNYZ0dlNTlmaEFGMUN0YitVeC9Ua1lPdk4vMzdxejdlTFFCZmdiMGpSdi8rTlYrYkk5aDcxYlZsZXdmQWF3QytoMmcwdVlvWVJmdTk4YTM5cVVjbUkxdm42ejcvVDhLaVNPL0JCTnd2K25QdkEvaSsvOTZGdmNPYnNIZnpFQllaZml6OTNvV0JuZmNRamZIWFlCSHVUd1A0OVlZbGZBZkE3OEgyMHIzeHJmMHozM3ZYZkl3dklLYXMvak8reTQ5RDgvMmtEaGRVRUhkZzcvQzk4YTM5enJXS3A0Y0h6d1A0OTJEcnZKQytneUNPVlBBak1hM2xieExaN3dQNGw3RDFmVkJLMSt5UnZqU08zdkIrVVFPejZlbnkvczIvZXhEdXVmZVB2dHdiallCQnY5ZXZhNHhyWUxIN3BmM0xxSlA2bzNZSnJZTVMrcVRHa2FRcGJmaWVnS0FLNURTZ1V2Z3FLUTVKV3RVMjVyMEpBRlZGRCtWRWFlNXliOGYrcVN3bnp3Qlc2dkF3ZTRCNnovUE1hMm9scmcwTklTcW9uaUFGanZ1STZaczBKVStJcE0yTlRnSVduWG8vekdaQUwzNnR3MFplMlp1OCtzcXBnQjlBNUFPTWRtQmtvYVo0b1hCR28zeElMNFBvMUFiLzdOUS9ZeDIxRWFKaGhmTTZtNlJwMi9xSWFkMFdzTlI2S3VDeVpsWkl1UVV6OWw4cW45bGtQMTdpTTRldzk1SjcrRC8yc1hSOWhockNzcTlXYUVpRGNoSlNtMlg5cVFHRi9ESlBBVlJVNXBTRzZUVUNNamFtYXZYN2cxT2xLRUxjZjhGWlFSVHJvVnlyNDgvbmx0UzMyWkRHTVYwYXZQK1pQSE1sZlpPT3c2OVI0QXhJYTI2WG5rZlpBdG1ZdDMzdU0vODdCOEUxc3VkVXpqSTltNWNUVDhkWHhkU0tOSDVTbitENnFXRU5NTnJJZTg2eXZrbHpLSE1ORUZObUJqQVdrYmJ5T3hvNGFaaFR3SjlBeGtiOHhNZkRFaUJiTUIyQUVXYkhYUXhsL3I2MllHdVlSeUFUcUNBOUJWTFBhYjJPd085RG4xT1NQcmV5S0N1dXNScHBIN0pmQnhQb25RNmtCZ0RxRjQwcC9QMDk3NkJRQzc1MEJpcEwzYy8zeWVjeE1rME5qek5ncy9xSFFnTTBzalVZU0xLOXpyVmpoQ0JUSUhNOFNmbzBSRWRTalpoNmlNaHZhWFNtZktDOGx2ZVJCK3A3SlBoUFF6ajhQcVV0Ty9KNU9MY1pQOWU1Yk1QMnQ5SXRkY0lpaUtBQVVCNEp0Z0JpSFRrQkgxU25TV2l0ckQ5cFU1NjZOS0ZsSHhlNStESmFGU1BqWjluN2ZSTDhQREg4TnExckZjdWJLSy9vKzVoUDVib2VKUFdzM0VlYU5STVFrR2VaZXNNcFJLNlYvc2kzYzNySEZJZXNlVXV3clFkUGQ1emZrOTNQckhrUFlYdWFtUTQrOEhsZWdmRVcya09lZ2tXWHplVHM4YjdqU1hTS3VTbDlYc1VHR1dPcUdLVko4T3NZTGZ6Yzd3bnZzSW9sRFFpRUhqZWRFVmtuR3Vyem1zWFU0Y2FJS2JHQlNLL0lFeDRKeldPZ0N6TVFjSHhqdU9NVVV0NWJ5ek5JUDQva25weWY4L25NYkVaZXd6NlhpUHVJem1GOFQ2US9XL0o5SHh1bWZwWTFZckFQNytYY3VJZlgwcVlxcG1MTjY3U2lzc3dsbkU5d2JpcndSYzAwT0VXVVVWWHUwL2ZIcHJ5VXprWnE5MUl3Z3VtS0crdjZDZzFmaWFacjRPZGFBb2cvV2pvZ1BLOFNoNFF1VGNhaWZDcUFGRUtmNkFUSHZhN0FKOGVUOC9OOGpRaVNVdjRJL056WGpUd3pCN3lUZXVBaUMydGZOYUtzcFhiSkFDajdkMkY5TXpCb1JhL0pkQi95Wlk2Slowc2R2NVpBVEpjdDQxRGJmbWxmQmhwWmtPOUsvTHpOZWZJSHB2bmNOblprZTVKTjVEck5qc0c5MXVad3NGYjJ5bVRHVGZUelJoQzI2dWdNVjZXT1M5ei82aUNzQVJjSlRkRnpVNUN6NlNDeVBjbEszNndaaitKeEsxSHREWFJSejNJZk1TdGZxQUhlOGp4MUx0RXpQL0RuYTNwN0FxMThQdGUvVWI3SW55UHlsanE0azU1d3ptRzlnZFRXNjMxd1RHTzRQcWR5SDhRV2lVSkFnTmhoT0taejIvajZrbXAzd0JUTGJBNWcxVDdRVDhBaUdUOFBBMlkvRDB1RisxZGdnc2tDQm41ZGd3RS9uNFVKS0M4anB0NEZEUGk5QTZzRitvZEl2WEkrRFFNLy94MUlHbGhFVVBEbllBRHRiOE1pREh2alcvdExqNzR0Z2I4VUZENE5Bd21mUXdSa2FkQmR3TUREendINFdjUklVRzBQL1BkOW1MQTg5VlRLdGYvUW9QSXNET2o3REF5QS9DSXNyZTFmQmZDckVtSDduUCsraDVnTzVzY0EvRVZmejE4RDhOT3dxTWlmOUg1ZThOVFpXNGhwaG11WUFQUTJERHg5MjhjSFNKbzFpU3J1WlNtM3RYRVRVd0NyWWUrVGMzOERxMTd0T3pCUTlNZGhnRHBUTVpQQVBnVTdlQy82UEhMd2R3NERmcjhLQS9yZUh0L2FmM2Q4YS85ZHhHanRHWUFyRHY3K3V3QiswZGZ2Qm1LazhxZGhkYWhmZ08yYmx4QkJjS1o4KzNHLzd6bS83bGxmYzNwVkV2Qzg3ajkwRW5nSnR2ZUhLS2NMWlR2eXRickhOZks5OFdCOGEvOTc0MXY3dnorK3RWOEIrUHJIQ2Z6MTltT3dkYVFSakl6eUZES2ZEZG9PWXMwN0N0MUI0SlgvOCtnVFhxc0UrVDNZM2o1dXFkWDdET3g5OW1IZy9UR0FoejNnZ1lLL0FMQzExZHNhOUh1N0FLN1V3R2cycXo4T3FVMy8zRFF5dWZNMlozVEZOQzVQYWd6ZXVoaWk4Z2dxSUVaMjlNVVlsQXNNblZ1VFFhd3FwMVpSNGFiWWVGOGxxUTgzYUxseGxHbFpTa3JNa2YrUVQxRnhIRldyZ3E5R3ovRTVCRVVWdEtVd3BCNittcm9wek5IL25NUFNzMUVoWTJyalBtSXBBem9aQmZEWkJkTEVRMzVpM29EenlhdXZIRThzM1NRVmE5SXhLck4weXFMQldWTmluU0ptejJoUy9DaThqNm9ZZmFWT01mRCt0aXVMUE9GbkkvK01LVEMzK1gvRGMxcGI1U25Sc3MrMkFleUlJZU5KdFJLd2V0bk9EY1d6c09FelN1ZXhjZHgrRHRWUm9DZGo2U05HVldnVUE0Q1lOcjN3bVQ1dmdPakp5OVJ3YkhtZlRVMlZXZjVXSlZxZkc5NVRkcllaN2FMUFBsZnpjOHd6a285dkFFc0J1eU8zc0phajF0RGgyVHQxaFk0cG1CUFoyTmRYUVVKZFc0MnVvZXhNQUpjMGdkR3NDKzkvUy9vTEtXQ0Zmdks5TS8zb0ZKNzJFdEhwOFN5alJYUFpSMzBaQjQyemJFeGJTd0FycDF0elg5dUZQMXVOZ2lFVFRMVjMrMnErVGkwdDdHbEVXamlERzZDcnZlYTBlZjRkNmFqeVQyMXF3T0c2RTB6SXg2RVpLQUlnTDQxOFFZRnZBdWsxZ04xcTcvYlRTSUU5eU5pQzdOcEVNL3c5TTlwWjV6cUNyVzJlZXBYdmkrUEpRVlU2YW03QlVvVmVSZmVXRzhQNG0rY3J1WGJ5Nml0SGJoQmxCQmJIdGRXd2ozdHlIWTA2V3VlZXFmaTRsemxYcmxFU0dlcjlrdGZ6WEFFeHVtN3M1MTZOSjBHV2JPRG5zOG1ycnp6eTV5cy9YeUtDMkQxRUFFWG5CczdCLzg3ZnVlNTd3S0lCa3ZTYjJsKzFXZ0tqRDVNQjFBamZKUTFwc1RYdzh5Mm5TNWRXWXFwajA3VU83UW54ODJWaEg2dzRhQ0dDdjlwcXBLbEJlVC9CRmRvUTZGZ1RlQ1NpQTBxTm1GMkY0NkNzdHkzN2oybUU5WjB4UmY0SVpnUFM4ejVITjM1K2lzZ3phWWVnbldZQXM0MHh0WDNnbTg0YmxqSy92TlFYWmZLTjZsMzcyaDBobG9YSitmbFk1VTJua2J1SXFkNFhQcWM1dkpheTgvTnhnYmN3T2dvQWNsbHBMczhtNzE3QWJBbVUzK2Z3ZXJweWJrS2FielVTSXpVS3p4R0I5V09ubzQ4UStUdjNaWENLcW1JVXNxYXFwVndBeEwyWkc0NUQ3V3JSaytpRXE3b0NLays5dllFZXFLQXluNzJBUjRSNm40MTlWYWxUUlltT0tUL25maTdSUE4zbmkwbWhWRTkyamRKczlzVXlJcER2U3VOcFBGTU5zamtCNmxHQnJpNnh5dE4xajlZd2VaM2xqVXFwMkp0YUhrakIvaEorN21QdXlacWRadmNNWkIrWDFwUzBNa1JlSXpwdlVEOG5QeWVmVHB6eU12MmNzaGozTjJrczVRVStMNERaTW8ra2tSYm45Tnl2SFlpTXZJTjRybmpPU0J0SVMvSzVCMUFMd3BzTCs3MFBveTJEYk4rU1JpZy9YOUU1dXJhQy9vY3FwcDVmbDluMWNiUkw0OTJsZGdrMnZSSm9CNVRMK2VUNnVRSi9rTzlVbHROOU9paklXMDM2dWRyajh0VDlYVm9wMkVNelFmVmxyTW56Qllqc1ovdFFIWUlYbTZ4OXhqOXp1dGhIV281QWFXVllaeGhmbklsYzFWaFNVTTU2L3IzU2dEQW1wMms1enl5MXZMK3dmazVubUEyR0djeW8rK243eUhYQnNBY25NZXFmZEVicFVLNDdKVFJDYUNzQWFQcm9qVXN2VXNCWXdBRFNlMGdGdUJFaVlNWkl5TEg4ZndQUnlQcytJbWo0SEF6a3ZZL28rZnNhVExDODZ6L3YrODhNRVZoN0RnYm01UUFaMDlPODVzKzhnVmdyNUJRSU5Va0JCT0JhUGVUdXcwRHBHekNROU1TZiszM0VkTlI4NXIrRldKY1VQci83TUlCeEY4QlpubExabjBkRmNOdm44S0kvbTU1N2pPNGxvNk9CdXc4RExTbU16T1g2TjJDQzR2ZjlPM3BXa1VuVkhvbTdoQW1YSHlBSzA4RTRKZWx4ODBnQ0hYOFAwYkIyaHZnKzZibi9iMkFBNXh4QWIzcDRBQUMvNFd1aXdPN1B3S0trdDJEQUtZV1BkL3p2bDcyUE93QXFuOXNaZ0ZHMnJzYysveHN3UllkQ01KV2VNWUJQSWFhWjVpRzVodWh3UUk5U3BzOEJJc0IvN09ONUh3WXl3dWZ5cnYrdFJvQnQySjY1NzJ2QXFIVnRiL3I0a25UQzA4T0R2dTdOaTZZYXZ1em1UaDkwRm5nT0Z1RjlncWlnN3NEVy9Ec045NDlZRjl3ZExqNEI0RzhoTlRoU1NBVFM2Q0VnRStibCs5ZGdlK05iV004TXI4QUE0Ty9EOXRWUlE5cHo5TXhob1FmZ0NEVWUzZmh2djd6V0E2K0tLZWxXMHRQOHFLWHRNdGFuQmZUc0ZDR3c2UmdhK20xTmV6SXhML3hUU0hwR0lFU1EwdkRJUFo4cmVlY2VLOGZyZnc0cVMzZVVBelJCV2Nybk5va3BGZ2tVYk9xQnFzcHJlQWJTcUlVbDNKdGRucEVEUXZUQ1gxYVc3a3lCWWw1SFlhZ1lFY0YxOW45UHM3VXByUzNIVHNWVUJXNkNFMEFVcW9iSTBrQ3paY1llOWsySEpTcWFOQjdUbUtRR0k4ZzZNQXFwTDMzd2M4b0ZOQmJSR0JaU3NWVXhWU3pYUGFuNTEvWGN5TnhvOE9wVmxzS0dVZGNjNzJVNFdHelNPdFdHdlVpN2FQK1ROSDBSSUh1NXcvcnpMREVGZW1oVlROL0VhMG9LanhxVHVOY0FONmJsaGdML2JJR28rQVg2a2UzMXRqRXIwTUt4NU5jcndCUUF0NGw0OEdmUDc5cVUvcWhEU3RQZUpNaEN6K2E1R0lvSlRKWU1NWUZPSWVNSGt4ajlwRVpRcFlkNkx4QnAySm5zazYxcTcvWlVqUEVFR3lsM0hzc3ppMDZEVlhUMjBNYjB1dnBzMHJ0Y3FjeDVoenF2TU5KWTB3NTNObGc1M2VCem1ZcVFodUkrVEs3cyt4cE0zU0M3SkNCWFdhcEE3ZzhGNGhXTUk1akV0Sk45R0ppcUdSS29NeW5va2pmcUJYUWVZSlFmNmVvakdGQkMzdEdUOVdBRTBNazZCWHhTOXRZbUdEdjBjOEdNTkhSTUxaNFJuL01aWWtSUGJ3TmFyM3ljYytFK3BCR2FnT3VpaWhFSkk1anVwQkhtT2lhK2MzMUhDL25Oendpb0JQcFk0dWR5ZmVMaEQ1T3ZjdDJCUmgzZUUzaXQwOEFSSk1KT1d3ZCtybUFlNlREUFNSOEk2ZEQ1dVViWnErTUZVNWNTUEI1S3Z6MWZPd1dQK0I1MDNUYVMyV1R1RUg1T0dxQ09HVStxZmF6NU9la3g2WkYvcklEK0ZqeTliOEhBeDk4RXI0QW9BL005a0QvUWpnUC9qZ1k4QmY1MHI1NDRYZFRzRU1yUGg1V0JwWUh1VFR4YTJmc05JSTJNay91WmRpTUdTT2ozYkV6VlRFQ1Q3VU1ZVUhzR3M3M2MzMURtVkFjWDVlY0tXckxwK2VZNmJNRm8wdlZxN3pidGpiVHJhU045V05IbEoya1UxWHp5Nml1ME9hTGF1MzJNR0tuSVJsNDE0OXJEbklTT3ZGOW1HQ0lkR1U2a0pySFRvR0xFbkFOL1hBdlNWeHFMeVhQT0VPMmJhdEFtbmFVc292eURUdm1rSDZScm5jNis4eHZhQ0V1WnJyWmhlNWdSbkpSNWd1T3UwMnphUURsZmRiclNaeWxmVkZtSXdHYWpzeFZpVnBBOHFxcVcrNGZ5SGVUNVFhWkFlbDVLYTFKNmg0RU9WRlozbUhNTnZFS3V6WFZ6Mm9hcEQzUk5pNTlmdzdNN1ErVG5uTGV1bWZLcUhyTHhDYS9nWGltQlZFRlhWbEFzNCtkNnZ2UitsZDhVeE5henozSE5rWUpZL1FMSUFuMU85aDJCTGY3TlBaRHJFbjFFeHpIYXdIbVAyakhIc0pUdkhHOXc3a1RrOVFya0FHa2tZbGkzZlB4dFRYZ0U5WE91WFI3ZC9FUmF5VDd5R0o1eFVmMmNKVzN5ZmphUm1STW5CRGJSOTFUMzFuT2s3MGJUOVd1R055Q2xCWFgyWGZKNTZYK3h3OUVHUi95Sm41VnNDMzBnelZMbXVoaDFpdk91L1lvZUpEcGFpZjZwTS94VHNKSkJ1NU5YWC9rUWtUZXNST3JLdUV0T0gvcTMyaDhXbFplZWtyNXllcUh5ZktDRFlyTllTZlhlWXJkV1hXamdhMENkZ0RZSTVUVzhuclJvS1gycDdTTXBvWEtleGsxSllXb2s5VmFCRkRnRERHQ2N3NklwdHhEcmVMSTJLLzltTGRmM1lDL3RPUmg0ZGdXbVlMK0ZtRnJyMy9pOVYyR2c2VHg3NW1zd2tHNFh3Si9DaU80eERCamFuaDRlbkRXQWFvdnhyZjBqQUpnZUhwejYySGtJZWo0Mk5VYlhNSENJYWFHL0JTK3dqaGpSdUl0b0lNamJHUXc0WnVwaXZsQUNZVTk1LzNjUURiVDB6UHV1OThFbzA2ZjkvOWRoYTV3ZllETHNwZFRiQlR6MWNHbHcwOE9EcGE5VERsNFBZZS96SGd6Y0pHRCtWY1NJeWhmOGNqV0tESDFOQ0JaZWdRR2pQNFVZZVh2TnYvOFRSTkQ3TGt4aGVBZkFvL0d0L1JPT1Q4ZmxZNTBCZUg5NmVNQnh2ZWYzUGtTTWtQaHAvLzhJQmtRL0w5ME1mVjUvNm1QYjliSEJ4L0lBc1M3dnpQOW42dEVlWW5wdStIZEhBTDRPaTlKbW8xRC9Pc29waW11dkMvMVlGZDRMdEI3c1hUQ1NvQTk3bDg4akFoYkQwaHg4NzkyY0hoNWNoYTNqSjJDZ2ZKMzlxSEpDbWdPa3RZSFBJQkVpTU1ENUxjUTkyV1pZZStUMzMwT2hQaVlBdlAzcWY5OTdhZS92MTNXTkV3QjFyNGVIdTMrbk1hSTRiOHJNZitCVHR2d2d0MDNCclBQMFI0SE9HWE5UYWxYQWFYaVRzSVpWWVRFWWJDNHlaaGRDVkxoY3lPZFU5SlpvQjdGTGN3NnA3UExtUWt5VFFrd0JsMTV3ODhwcUwyN0JqVmFJNTJibC9BZ29vb3FMR282QjFFdFJCV29xMTdVcW5TSU1hNTFpTlFBQVVXbXJFYjMzQ0ZBazZWc0tUUTBzd1hDT0dEVkFSWm1nZ3dxd1V6aTRXKzNkbnZvYWFFbzVOYjRUM0tGTVFRV2UvUk9zVlVHNDU4OWdpcG1OOXBzQXZpVmwvVW1EdjVjYUdmU1kyNHB5MlhheGdNYkJZSXZVVVUrTm5UbnR5QTNQVkdEQytaSnJTd2FCRVZKRkF3QWdnS2dDRzNtVWYya01QRVA1WjFRd1ZkbWkxL0VTcmtpdG8rdlo5MVMwYzgvWUJWWTlsZ21zQWhHRURaRUtmaTNyTkdvVVN4NTEwaVFyTUJXMHJqdkJZVDR2MUQzMnZ2WDkwcURWbjhTVWN6emIyNVhWTFYyMy81V21VVlpSbW5EbVk5aEZCRFJwREdaVThwYlErQ1NxaDgxcGVnN2kxckEwWVUxbE5QaWVrcFRMU05Nb2M2MFZzR09reHNra1RVZk10TDN3dWRSVlduOFRXSDFYT3pCYVNLUFp2V3cvTXJVbUk2elVtWmNHY3M1MWhqVGxOQUZSK05xMDdXRWE5WE9hckU2UmRBYmk1d1JqR0pWU2lsd211S1RuZUF2QWVQTHFLdyt5NnpXNlRPZWxhNmFnSk9BMUszMy84SXczR2kwblZrSWhHQ245WS9JTzFRVUlodEk1ZytCNkRhRVpBczRNL1g4MXRQS0hCaFdlUTY0eCtTckgwSVdmMHp1ZjU0SE9XVXIzK0V3Z0F2VTA1b1owaUFMbXpPVSt6WFNqeG1ET1NlMHl3WmxIeDdsSmMzNU9lcDhiRzgvamdIT2g5Z1BFenpXS1JVRkt5bXo1UFBndTFaRStCMWk0dndLdlY3NmxCa2IvTHB3emtmdnp0S2hBdEw4UUhBUU1rS0hkaGNEMUZaaHg5UjdpL3VMK25zRm9HWG5UWGFUZ0lHdGwxaGt0SDhCckFDUHU4eUc2T3hYUThUdlppODVuOGxyQ212MkROb3VIb25QVWZrL2dtOW1hOFh3MTBTK21EZzdQZFg0K0UvMERpRkdBeDRoOHE0Zkk0MFBxWUFKYkdSaTRyaWtQNmtOMGdrbnFmS2FPTzRBWS92MTcwdmFTSHBCbldnanIycVFISW9MUXFsY0JrWWVyMHdEM09QdG15UXJsNTB5aERZaEIzTWVrVGlyYUtBUE1LNHVhVDdJMlZqRVRCR1daaGR6SGNYR3NhaFBtWjUzc1FueXZCUUNNYThUKzJNSjZJSlg1a1YwVDVHWkV2a1FuZ2hVNVMvWkJmb1owM3NxenBwWFVTTTcwODVVMmlXbnNjNWxZQVZ0MUt0VE1MaUZEUmtFL3o1MWNramtqOHZNYWNiK3BqTjdZU0N1cjZOakZsTkkxekw2b2pvV2FOcDN6SmRqTHNYSFA1cG1NQnBDelJadVJySXZLNGt6UHEydTZzVDNSNTBad0w1ZXYybVNjSC9hbWE3UUN1dVpOOUxad3YraWhQYUFWdkZXNlE1cllWSnM2cHdrcW93TlJYMXdpMVcrRFBDMzhtSFlpeVA4Y1Y2NDc4Tnptd0NyWDZGeU9nYXJ2RnI3TGdkcUZnTUlNUnB2QytPKzRkSStNY1MwZGFMTGpyWkZCdVM2QkYxU3Jqamk5d21kdGplZVN6alQ4LzB4b0IvV0k0SWhmeFpyQ0N2d1c3Ym90QUhTamJXVTR2clUvY3lEbkVTeVM4bFBUdzROMy9mOW5ZQVNRWG5VTC8vc0tvb0wwTW93WlArV2ZQZXUvcjhPQTJ3ZXdkTkEzL0pwbllZQWNzR3BRL2lRTU9QNDlBRi96WjM0WFJyQS9DVStoQXVEL1JlckprMnpzSEtoeVVDNFJhRHlDbFI2NEo0ZzFncjhOOTJLRUFXTkFGS3F2QTdqaGdPUVJnQ1hUUUh1Zk04VG8wN2Y5NzRjd1VHd0U0Ry9DNmh6ZmhZRlZxbHlRbVR3RThIOGhHcEtwU1BCQVhrZGt4SnFlOTdRbFJXNHg4blI2ZURDQ2dYYWZnNzJydHdHODZkYys5R3Y0SHI0SUF6bnZJTlljK2FhdkErZjhCZGloL1N6aS9tQmFwRGNRYXdFekxja0wwOE1EL2s4RnBEUjIxajcrTGd6a1pzVHB6TWYwTm14L2ZMSndPK3ZhTUozMUZkaCt2UWJiM3kvQjl0d2RwRjdkQTFoRTZWakdQSVZGT0xNOThIbTk3OWNNSE1qdUFXQjY4RG9ENlJ1YlIrTXVuekJZVENGNWptaDRHc0hTUXY4eWJGMmVBL0JvZW5od1ozeHJQeGk3Zkc0REdBaC9EN2F2ZDJGN2xJSXNGUkJsbEFRM0dQbC9DZ1AzcndENFk5amVlUmNSN0ZEQW85VE9ZUFRxMGZqV2Z2M3dmL3B5Ly83LytPWFIwY2x5OGRTMVFkM3ZBN041V05KajJCcDNKZHhjbzQxcXN2eW9yYllxcGlMdHcxTHpiZ3BNbmV0Y3FKQ3dRUjhxTE9hTk5DTDV2dEMzN2x1bUlMbXNzNzBDd21TQ1lYR3VvZ1NwY1F0d1VOVy9MOVVTb3pGMjVYbVQ2Tm1kckVWbEVRRzhOaEhFVkNqeHY3V0dtaHBzZ2tQT0pQVUtWNENTU21JT2Z1WHBXMmxncHVMRjhhelFBaHJsc25WVFlaVFJISHkvajdJMUlpOWpqVkIxQnVNNEVnQ3VpbEVhVkJyNXJnamc4TGxxbktaZ1NKNnNTc1pHNmZpeXRvQVlOeVl4VXJ1UlQvK29sUUh5dGpPdjUwd1VvUnl3cFJMQUZFUWxvOUdLSXRjd1BqYjFobTh5UnVVS3FjNk5lN1BOY0phREdKQnI5ZmM2NEd5SUdNaytuY1RJeHlKOXp2cFNPckdFS0c0Wlg5Q3hrOGJrMFJLbGNUVzJTUnBWcEgwekd3RC9IL0k2TjVKTjNUREtkSTZNNGlKQXFGa0phRHdOaGpML3Y1ZGRCempRaTFqM2VBa3pvdElZT0lRWnpuT2pleklmbWRNVldEM0VhV1hlMmlYbk85S3pmQjFaNTQrMEs0KzRJVzJsUVlCTmpTWGNYMXZpdU5CRGFwQlR1Wk43UG95bmlnNDNBY3hUK2lsOGFwR0JkVHdQeHkzRzhsSXIwWWQ1RlNONWRaMDBmZjhBWGg4enU1MDE2WE1nYnd2QVVzRHRxYnkvWUF5ZXBCR0MzSk9zeWFjT0hZdHE3elo1TWRjdFdlZnNiem96TU1VNGpSNUgvbmQvRXFPTEtCUHkvVkUyeWZtTW5pY0ZUTGtYbVBHZ1pQREorZmtBU09yV01XcVEvUkpNVW9NZWZFMXB1TllJT25WV1V3YzlmcTUwU1BkTEgrbWU1Tzg1WW1SNWlFckYrZHNNd0JibksvTFppdjNrejBOck0zcHQwRFJyQXRzQ3RnZDZPWTN4ZDNXVTBYdnVLK1Y1M0MrTVVNd2piY2pibXQ0MzVWK3Q2OG15Wm9EUlUrcll1cWNVWEtKRGpOSmJIZTgyZ0x2WkduTFBIMlhyUzFvWTluOGIwT2swWWR1dmUrUzgrQmpvVk9PYXRBU0lZUE9WeWlKL1M4NXZITjgyMGtDVkZhZTRLa1pXRjlza2RSQlRneTRqQ1lGNDF2Vyt1Zk9uSFRmb2F1VFhMc3pKaVgwelZUaHRmZ1RuZ1ZXbkxEcitLTGlyWU4wSU1jVnU0M3hrTEZkOWplYlYzdTF4Q1d4MG1sMWFJd1U5TlRwWVFjaVFoVUh1eTJXRFBzenhUZmw1VHMvSkkvb1F4d21meHlDN0R2bmF5TFg1YzN0b2p5cnUxSHcvSzlqTHBvWi95aWtsY0R1UlVXUjh5OUYvVFFJQUFDQUFTVVJCVkNxbWhWNXgwUE5uSzAxUWZwN3dhOWk2QmJzYzdRSWQ5SE1HaVhBUE1FVjZUL2k1QXBOS1kwck9hM2xVRzkvdEV2RmRsT2FaNlB1NWZpNEFMdVVpcHJwdTR1Y0JVSzFpUko3cTV6eFRvVVFUb202ajh5SS9WNGU4Rlg3dTQ3Z0lQOC8xODdveVovSkIwM24vVVlQU2xQRFpHdjE4S1g4SEhWd3VxUXUwcCtRUVF0dE9xVkdlTFRuVUFHVjduZDVMUjRmY1FZbm5LWGNTMGxZOFh3M1BLaloxRGhINXNwT3RYR1I1bnFVcGpBL05KNisrOHJEbDFyRFBtMEJnNGRNYnRVa0VzS25ycUY0UzlOVEtTaWlzT0xkbmZKWDNCc2RVUkw2VWcrRkxvVDFoTEhKSkR3M2diNm41czIvNDN4K1c3c3VGbGhkaElQRFB3R3V2d2lKdzd5QUtoalVNSkNXQmZBc1dzZm9pMGtqWkc5N1BOMkNHeUMzRUtNRm5ZS0FaRHlUOHViOEU0QThRVSt5K0llTjhGNVplTjQ5Z1hYU05zTXl1VTBQdUVqSHQ4eFFHRm43SVp6bFl6SlF3ckl1eTQydHg1QUFmdmNVWnlUejE3M2NSMHhEWEFINFZCaTcvRXdEdk80aW1ubHM5djVkTVp5RUFNdzBpVHlOR0l0OEYwaFRZWFpyMzFmUDd2K2w5M2tTTTZtYXJZZnZnT2IvbUFRekFmd0RiSTQ5OHZXcFkxT1l1VExrNDlYWDRQT0w3Zk45LzAranlJV3o5ZDFHdXZjeXhjdCtOQUd4TkR3K1lacmtQV3lzYW5qNkR1RSs1dDQ4Qi9Ed3NvcHMxZW10WWRPOFYvK3dkQ1BBcUtiMUpORXRHVEhxT3ZlL3JweW01RThCOUEwQjNBS0R2ejU5bDR4bjZHQzhiaE5ReE02SjhBUU8vNTdEYXpZekt2ekU5UEhnTEJzSXY1TnFIUHZZcmlNWk5DbGs4MzJRMHFpeHl2Mi83dlcvQjlzRTkySGtuUTl1Q1pTZllocVZnRCt2cFkzak94OXNEVUwvMTNxeCs2dHBnKytwdS8ycS9qNXNBTUJ6MjNqbjV4d2NQbDh0NjYrSHhzaGdsM05ReXcrUzVteGdLTG1xWStFRnRDajZlaXptZnR6V3RlZWx6L3l6NVhCV2lpVVdzTmtVT0J5T0dDeExCT05zMGh2TVlxM0tBVTU2M0VobVhOVFZlbzRyUlV3cEtybmkzdGF3VC8yNVMwdGlvK05ldWNBMFJEZnRiSEljWUdLalE4ZnFlQzJVRVJtbDBVYVdzc2ZHZFZqRWw2ZHFJUS8rejc4SnNqZWpkcndvZzk4ckk5d1VqbFplVDZMazNtNlNwdDBQNlpyL25wSXIxTHFkSURkRW5QaDd1b1VkVkJQRXB0eEg4SGNLaXFvckdnUTBiOTBOb0gxZkZNajgvK1RsOFVtMFNRZnJBM3pZWmc5elB4bmNjbEptV2M3aGljSFVGUUorZkd3K0RZWGl5Q2hUbWlsVit2a3JuTFFHaEp3WEhFSm1YS24zcldnRDlCQ1RsZVdiOW9LWklXVFc0MGZnZVNzZjRPRmZBb21ydnRocVRGTnlCZjZaSys2RGF1ejNNRkZMdXdRWDVnSnlmUU9NbU1ZWGtBRVlIZVhibndFcWtsWUplYkVydktkTnJuVWR0VzNLUE5vSnZXZ3BINThxYWFTR3Rzc3dwUDNkYk1PVzlGYmp5K3gvSk5YbWpBK3pDNlgvZkRXWTUwTm1YNjZsY0oxRnpBQjQ1d0JEdXFXS0tZeUJtbzVwbjg5bUdwVGFsSXk1QjYxMUU0M3dTdmU1N2tTQjd2czZVaFllVmxXNVEvanBGQ25RRFJ2dURJMUJPZjZzMFNvQ3BpaGw1RjZMMUVQbVZqaWVKbWhaWkJiQjlXM3huaUh1WG9EbmZEL2tRWUpGeDg0blZ4enJ6L1QxR3FuUDNSQTRnQ0ViK09QUHY4L0lWT1JCSCtqS0M4UFBTZmhKYVJzTVJuVUY0amhYOHFXSFJWck9jbi9QWk5BYksydkkrSUFMeVBOOER1U1lBN2s3SEdNMUhuWWw2VXc4SWRRdG5EV2RrazdaRUZrMTVXWHJOWmJlQ0VlMmo0dWRudnI4STNNeVIwYktxRUdFaXRFRFBHNytudnN1Z2hKTGN2RVRtdkZmRkZMdnFMSzk2eGhGaXRPanBKQVh2Nkl4QloyL05Fa1NRV0oyQUtPK0dpRFZ2SjRoQVJyNGZlWGFQMnZhcXpHTUxBc2dwUC9mbm5qVDBvMDZQcE1HSlExY0RQNThpeXVSSjZubi91dyt6UVJDQURCa3JoSi9EYVZwZFdhcG5CYUJPRUoxYVNGdUNFNDJQN3lUYnc4R29MQzJrQ1BWMVdxQlp0cUY4bC9kQm1xUTFCa09qcmpGSlUxTFhic3dPMlJZcWlTek5lTldLSHVEMzA1R3JpWi9UY0U3YXFKSFRiQXBXa0Nma2RPdTBFdWRpSUtRUDVSaEROSFRHejZrZmFiUWNuMThFUWdUY2FBU0dHMmhBU1ZkaWhCZXZTWjZuY2lQU0VnTGtWNW85STVmdDU1Tm1mbzVKd2FtUFo4Ny9EUm04cWdpZWhuclRHVCtuRHB2ejgvQTM0cnZqSGsvNGVXRXRhOWplSUMxYWF5ZkwrRUl1aCtxK3FxdTkyd1BhRnFvTTdFYkt6MmxqNTdnWFBtZU9TYk5qTGJBcVIybDBQcDkvNmZ4YzZaaCtobytoTTlkNTdGdVBvMDNTTWpGMExEbXZQVDNRTE5INWkyQnlpMzZ1ZHB5YzlxaERUVkcrZ08xcnlnTXF1K29ZUTJhR0JubTZ6Wm0vU0JNTGpYU3FpWDUybGQxNkUzT1dldFJBUDdXVlpLdThOVGxwckxUQ2V3czBSZWxHeGdlN0JFS29JOGtJOWk2YlNqL2tlb2EyeHYwbHRvUjhMdzhSbllxTGpwNURUOS9LTHduVTFqQWw5MlgvZVJNR0FuL0R2eHY3ei90Ky9jL0NVc2IrVThSb1dzQ0FtVS9Cd0xidklOYVMvUkRBenlHbVZ4NzYzNi9KZmZkZ2thazNZQkhCNzVYQUwwWWhTZ3JoVHlJQ3hnd2pQOUZJWGJsdkNmY0s5TzhvRUNWcHMveTVKNTVLR3I0R1ExajYyMC9EbU9HbllBenpLUmpJZllhWUNwbEsvQTMvZlFYQWZ3emdmNXNlSHJEV0xpQUFTUU9nUytQR0hQWmVQZ1J3NTV3Um96VU1VRCtiSGg2ODduUGVCWkthd0VCTUN6eEdtcWI3QTUvckg4T0FPeEl5ZXJmV3NFamdGNzBmUmxOemphZElvN0VhRDVORS9ONEhjQ3hSdFdwd2ZNNS83L2l6N3ZpemptQlJ2aS83ZDYvRDN2bVpmL2RPdnE4a3NwVXB1dlZkdklHWW9wem5ZZ3lQUG0yYVExT1R0YWF3VFdMUmwvM0dGRXNuMDhPRGVsT3d2OHNZT0hhZit4eDIvdjRKZ0YrQjdlTnZJS2FuRy9pNG40YXQrN2RoKytSWmlJQ0x0RjRHM3hWcmI1L0M5dHNuL0pwM1lZNEY5d0QwczNUbEorNEU4QktBaDM1dUg0NXY3Yzk4dkZNQXUzV04wK25od2ZUaDBiTGVHdlZtdzBGdjVHUGM3UUg5R3ZoMkRaejgyTy84L1kvRTZFRWgwNDNMSDdsQTlCRTBkWFJKMGxvOGlmV29ZbHFpVGJ5b2FOaGdMYzE2OHVvclRRSjhEMGpyZUtyUlZBR1ZEWisvMFpqUkRxcG81b3pTZHhSOEJsWG0zVllZbDZZbldUZW5VMUd5OHRReWpJQ2JpWUdGaXBTbWVnNGdKMUxubkFSb0V3TTFhMzJHOGZsMXJaNjNZb1Fhd2Q0N0k2L281QVZrMGJ2eWY2bXVWQzNYa2tjQ3RsZm9hYTlqWXYwNTlrdUZkQ29HYi9KYjFwSGJRVFRDRlVHWFRScjM3VVg2K1BQVU91N3hvdlBJaGswVlFqV01iVVFqcStqOXl0OTVDa0FDUkVCRDlIQm1QQXRqRUdOYkRraVdESU1sWHF2ZXpxMk9HOTZhSW52NEhlbkNpZ3c1aVZFSk9wNEUvTTBWWXhxUW5QNEZwN1ZNQWFUU3pmZXRUamNqUlBwNjRzL0pqVFVLVWpJS2dRWStSbURtaG14R0V1bm5wRFVLQk9jR1BEYW1mUzRaak90SmN4cm5vbktQbUdhU1AzU0szYTZzcnU5R2NwYjN4YlQxYWtoamJVRmRZK29PUzdpT05iRkk1RG1zRnVOc0VxTldnc01Odk82dy9OOEg4S0JCbVIvRHpvaEdkSndndmw4RlhMblcxRXVTTXlWR1NZTDBpd0lna0RmU2VhWjVUdG9rclJrWURKNXk5a2xEbGpCZUU3SWI2WDcwdmNkSTRqbHM3emQ2OGZ1WllTUytyZ0ZiRDdZM2FEUm05RENRcG4xVVo3Uys5SkViN2duUU1vcVh6bUVMZjIrdGhoam41M3hmcEdYazUwMlJGcVJMQ1QvUGFFVncwa2FVL2JaODM0V0k0MGthTlVkK1hsZWUzdDNueHozR0tPWXRlZlk2UTkzYWRnbDg2YU51WGZoRWFCM0FneFVRcktFZnB2OWQ0UkgrVHRYUkx6RjBpcEcrRDl2dlkwUWJUc2xCcEsxUnJxUHNuTk5YbGx6Um9JcDhMa3ZFdE5CTWc3eUVaVU9iSXFZL0pxaVlBMjlOY2lWTEM1QldhK2FmRmFPekE0V25LSU5xUEZOdC9EelViL1U1UFZMNXJQQ3VTRDhZWVVNbkhYVnlWRkNaRGh2OGJneFBuUTBQQk1uZm5kSlRrWkZJVTJlaXgrZzlTNmVqVGZ3OFJIQlg1Y3d2VFRVQXFaczEwWXdCZ0pWMVFnVC9lTlpZZnFDdTBocThqYTBnUjIwQmFma0g1OGZES3RZVEpzakxjOExNSjh5OGQ2VXlCMkh5YzNXVzRaa0NKQUsrNFd6MTVYZVFpK1gvSGh6SWxMVlcrYWEwenFHdktuT0lhM2srQ24xeDMyaVFCSHkrT2JoRFFKVTBJVEgrVjlHeEtwU0g4SGZkUm0rb0szTk91U3hQRUhneGlSbDRxSXNTc09hN2hId0dyT3JuSlg1ZXU2d3d4eHF3cG9xbE5NalBRNGJNS2pwbEJUdVRqQWZJb3RRem1WNTFHc0QyS08wOU9UOFA1UkNkbC9TUTJqaEl4K2JDejlYeDVzSkE3USt5RGZHeVFXSGFsZGFCY3BPTE83MnBmaDdPL3FhNmp2UUZGSUJvUDJOOFZvbjI4THBnWCtSNlp2cDVrRjAzV0cvU2dLNkJPbzAyTmJGNUY5KzNmMDhhd0hGMk9SczZMc3JlcFJKVVFBWitpeTZXbHpGSXhvVUN2YS9TbE13bFo3TlNmN3duY2F6dmVHOCtwbExMbmFMWlpvaDRHMlVTUG52T0c1K0ZnYWFmUVV5aHkxb2diQy9Ed05oZmdBRTJ2d1RnTHdMNEd3RCtFZ3pvSTlENXZ0L0xsTTh2d2lJd240VUJTUjk2bi9RbWZBOEd5czBSd1NDbWVyN3J2NDhnQkhONmVMRGxFYXc1Z0xibGM3Z0pFMnI3Y1BBM1h4bS9iekMrdGQ4NTVhNWZ5K3RmQVBDWEFmd21MQVh1ZFg4bTA5b1NPQjM1WE1tQVR1VTNRN1Nwb0JKWVZoQk5uMzhLQThxL0JlRC9CdkNkQzRDT0dqVzhnQUhBOUhTLzR1UGFoaGxNQ05JZisvTXBvRzdCb3JsSk1HN0MzdlcvRFl0MC9xdzg5Z1ppRFY2bVhIN2djejNyQ0dycXU2SUFjT3JqMlVVRWdZLzhPVXg5d3Rxd1d6QVE4Um5ZZm53S2hZUGo2eFBTZTQ5djdTLzRBK0I3c0QzK0ZRQi82SFBaOFhWakd1ZW5wNGNIMXh2NkxUWDFKR2RrM0J3UmNPakJ6OHRsZzcrbEpzNFE3OENjTDE2RFJTUS84SFRjOUNMK05SL2orN0IxK1NxczN2TTdTQVZuenZ0ZkEvZy9BZndMLy9tS1gvOVZ4SWpzbHdCODF0ZFJHNDBneHdEdTB5bkEyMXNBSHZSNkdBUFl2WGFsdjcwMTZ2WDdmWXhoNS9KREFIZDZQWnhkL2ErKy9KR0NHZ1M0UHNveGZGUnRFajBVbitnN2tQWE9sZE9Wdi9tL0dKdFZvUUJhREZIT3dJdWV3ZzQrYWgyYzB2aEtiVlBEWGZFWjJUam1NRU9qR25oVTZDc0JScUVKaUt0R3pWWURYZllPUXZTQ054cGxFb0JjeHNxME1zeTZFQXkxSllHZlFyR1BWYU9NZEE3Ni92dElHNDNhZFA3WlJaUW5xTHdGRURmcmswYjBmbVdSYzJOWUZCbjd6RDBYR1NtUU42NHhBWWlsOTdXTmFCeWpjRWNqTk85N0l1Y3JPeWNmV1ZPQm5QK2ZVeUZyYXpRT1hjcDhxUlRsbnhNd0VVVzEzb1JuRkp3ZGduTlpCb1RTbUx2TXo1Q1BMVTlqMkZwUGZOTHNGTVArOGoyK290aVcxc09mdmVCUDRUdktvb09XKzNrbVo5bm5ZZDlVMGVHQ2JZbG9VSnBqTlYwZjE0ZHJta2ZxMWtDU0NqYTBobkdTcG5VQmVrYStwc3dhd0lnYVJwRTJaVVFZK1hVNS82RXpaRk03UnJsa3d5bU1IdEVJeTJjeVhmL1Fmd2JWM3UwZEFXSnBwTGdLTSs2cWNXNEFvNWRiUGpidTA0VThnM01rcUVmQVB0VDVSVFFPRXBSZ2FrMGc2aTl6K1I5eVBkc1JURWM1UlhSQUlzREJiRkdreldwWU9NM1BsUEFrQmZEWE9aT0U1MHd5b0VvQXFObkVhaUN5aEF2bm91a2ZHVVcya0hGbzR6cHFXdklpaUNSajQzTUNQODhNMVNvemthNlJkMm82dEpDSzBhOHI4WFBlVjhQV1h4MHN1QjdLaC9PeDh6dU5qS2F6QXNmQWNlUnlJV2xIei9mWGRyVjNtL1d5TmIxbGNTelpHSmpXUGZCMnA0dVVLelI5cCs2Vkh6Wit2bFQrNkx6bnN0ZUEwWUM3VFh3akc5T0t6TTZmS2pxdTVMSWd6L0NwL3o3MnYwL1FIQzJqLy9mNTQzMmRJcDZyWFFmQ3RIMElzODhjU3grOWF1LzIyUGV1amwzTHZPVEF4d0xBdmFZMWQ1cCtWY2FyS2VoUE9kNm12VFI1OVpVei95bng4d1dNM3U2MDhIUFMzaVRUQTkrUnY1TnR1WVZuaU8vb0ZKYk5Rbm0yMXBXZkl3Vy9BK0RZWmE5SVd4dDVCQmk5OHZlazZjSjd2a1p0Mlh5b3N5WE41OVhtMkRCRk9hcjRETFlPMi9rTllzZ2ZVUGJRL2VmdmV1eDdUZlhDSVlTZmUrT2FrSGMvUXF5WFRkcmVoK2xkL0QrVXlVQjB6ZzNPMFlqdk9OR1hzL2RGWFZKQm9MNzh2M0kvNzJzeTdPdnoxOG5vdnJlWEVBYzNiUTVTekgxL2srZHBQV1FnOGdVNlZ3V0FSNW82QWdJWkwyNFltL1pScWxXYTgzTmVRLzRJeFBVRll2UmN5WTZnUEkzNmJCcy9MK25ueWlPcDQ2djhRWnNDUHljTlZYNitDNk9qTzFXTWF1YTF0R2xzTmRBeDZ1WjAxQnJDNUhMS1VpR29TZmc1Wlpnblp2L2FrRjQ5bHRaa0Q3dmt4ekJMWEJFNzJiUzE2T2RCSCtkNVB1OWM5TDdTODN5dnJ0RC9rcHlXalVIL0prQzl6cWtpZDA3cHBLUHcyV3ZzQTQxT2FYNy8wdWxFbzgybUlOUFg1SnR5ZjA3M1NkT2JITTAyZlcrZDNyWFlGTlNwaU9OczdFTjB1cFhXdGpaQ2kwdjNIQ0hWN1JNSDhDR002SDBDSnZDOEJRTk1qckZxaUtEeU5JS2xoV1ZqaE9jWXdHOEIrTHBmOTVUM1J6RDR2bDkzRThic24vSFAzd0h3UnpDd2NBZkFwNzJQNTJHMVhiOEw0RUVHZE00QTlBUlFJM0Q2bEkvdkhaakI5aFRBdHRjdVRSYmQveitYRjQ2RHo3OElpMklHRExqNkpneDhaajFjcHBva3lFbXZqQm9HU0g3THI3M3VQM2RnZ1BjVkdCaFdiQjZ4MjhzQXNFMWJEOEI0ZW5oQUlYRWJKbXo5RkF5UVorUWtJNThvRU05OW5CVEE2YTFIQVBRWFlIVmpTd3p6MHdEK3pPK2w4WWJDK05xNUVMQm5uVnpFMU5Hc1FjRjZ2TThqS2tCTW9YWUZkZ2hPL0ZuUElRTDFYNE9uMGM1YThjQ05iKzJmZWhwa0hxcGdTUFV4UGdON3IrUHA0Y0dmS0dCYkF1dTVELzFlT2dXdzN5SHNmTjFGZ3lORFU1c2VIZ1R2cENiUVdKd25TdjNXaUlhaEI0VSt6bUQ3OUl1dzkzZ0hNUjM0dndidzY0amdPMmtFSThZZklMN0Q5eERQNmhYWXZuc2V3TXZUd3dOR2NiL0lhOGUzOWt0Ukt1ckJ0d1JRTDVmMW90L3Z2ZDNyb2VkaitIQjhhLzlqbHg3bGg2bGx6RzBsZFk5ZVUyS1NwZS9hcnMvYnBDRUtvdUhlb01BSUl3K2Z0ejJqS3FTRTB2SG1ndDg2c0dvVEFiTmwzUUlvUVNHMlN0Tm02ZHEwcG16eGUxWGdheFBjVm1xbHlYZWMrN3A2MERRb01UWGxXUTc0Rlo2blNuTXgxWStBVWprQW9JWmRLcFBjcXlvWU0yb0hTT3NoMHNnYjFoT1IzM0V2NlpxdE9DQmtuNmxCaFkxUmdueFhJUzNhSnZ0RkZOYU4wbEs1d3JEbGY4L1hLUmgvRGxxTk5lZGlrMVpRNnVnRlgrdDVsWFBhZ3lneWZuM3c2cGQ3cUVUVXJoUXhUV29BR2lySmFwQy9Od0d4Z0FaRGhUeXp4aHFneUJ0VHhQRzhxOE1IbFZsVjJEWnRDNnd4d0RXOU54bzJVVkNhRWIxbGFmemxHZFl4YXZRZit6aUZHeXdMdklyR1pLYUdaUjNTSmFKaDg2eGtJUFRHTko4RTNuZ09GMDUzR05sMFFxT3M5MGVnaTJEOE5xUSs0S1pyVjhVSUp4cjlHTkdoSU1DTzNOTHpNWkcyTWlWd0h4NHRpcmd2WmpEREd3MHNNLzgrcE5yMTkwYjVQaGh1SnpIYU1uaTlWN0hXSGJNVGNleDB0c3hwc2ZMK1BxSjhHcDZCNkdCRThKbE9rU3lEQlBtK0ovdStCNitEMjFGbVdVbmQ2T0FHMTVFR3pmQU9mTTdVc2JoZWJWSDBkS3JTZS9WNUpia05jbTcxWjRFV1h1TDlrKzh1SmpHZHAwWUFOUEZ6enJsRUo1ZytWcDJobEM3bVo1WXRCeEY0dHBUVzVuVVBGU0JYSGFxVy8vT1dyeE1nd05Ja1ppcmgraW9vM2JrSmpXcDA0R3U0ajQ0U2pHUjc3STdHbDltcW1KMm42N2hwbjdtc2RKeTVETHZ0TklIT2dLVExzMnJ2OWxYL0xLUVI1aDZyWWxUNEZtSktZc0JvNnBHZmx4cXg1aS81Q0NNdDgwZ2M4Z2M2enF5TUhUR0Nkb25VNmJ4cFhYYXc2Z2pEZlRlRzdhRStWbE5SaDViclFWbGJZRTBxNlRYRzRuenNlajZwdnhCd1pmWkQwZ2ltK1I4S0hYem84MXJSNlNvRDFwa2Fsenlmdkd6SGYydjVoN3lSRng5UFlvWVBSaXVIOGNrKzBWcXVTOWllb1hOSk9MZHIxcTVKUjJSYWY0NkxnQlhyQ3UvS0xkUTVHTGl5alVnL3lRK0JTTmQ1SHBZK3p5TmYwd0NpK0dkMGJpVmRuRmVXc1VINU9la3MzeGVCWXgxemFkNko3SXU0SDhMZlZVem5xdG1xRnRwbnhwT0FEaVdJWkF3ciswRDRGblVwOGpoMUdGWm56aVFDdllHZmgzMVNaYW1DMVdhUzZlZTVBd3Q1VWFOOU51UG5QVDhIWEk5Rys0Zm9Ea3VnbUJhVi9Cd284M1BWejV1YUFrL0tTeFcwVmRtQzd6Q1IvOWMwWGt0bkJ3Q1J4aUJHWjUrWG45TzVjMlA5dW9vcHp5K2poTVNGMmhwNlg3d2UyTWlXd1hUeWx3S3VkOVRQU2JjR3NIYzB5NjdQOVhNTmNsaE1Zclk3NmtGZDdacnF5Tm80ZHU5WDkzV3gwUWJFZmVKN2wrczVFSHJiR0RIYjFpWXg4T2NpcldpakxmQmo3alBPZVFrVTA4KzNPbWVyelhJU0hmMUNWc1NtZlZsRisrRk1udE9YZlJNeUUvcjFBKzRSdWFhVFhYaGRFM3JPL2FvT1JhajJiZytIc05UTTlDUi9DQ1AyMS8zdmR4RFR4QkhZUFlFQk9Dc1Jqajd4TDhBQUs2YnYrQm9zMnBLTkhzbHZ3VksrM29RQlBMOHAxN3dKcXdYTWVyZUpBdWRBV0hnQjA4TURHa1B1K0dTUFlVSXAwOXhjV25NQThsZGhnT1lKb3BIamRkZzh0MkJDeVYyWVVIUWZ3RS80TlJURzc4Q0VxVThpUnFHT1lPdjZBR3NPeXpsVFB1djlTd0YvaDRoMWUwOEEvRzNZbW5NakQveHpHcDRlK1J5dXdkYmdCVmpVN3lOWUd1d21UN001Yks2ZlI2d0xQUnZmMm4vVU50YnA0Y0d6TUdWbkJxdVp2UERQQVU4ajVKZCtDN0hHOEFNZnl3aXh2dGRESDhOTkFEK09HQzA4bXg0ZWZBMjJYM2xBeDdDYXM0Q0JuRXZXeC9XSTROZXpNYjdycVloM2tEb0FOS1hPVzJuK1RxY0NjQU8yaisvNS9GdlhxZEJmNDNPekZOOTlBS3dCdkpEdkFUdmpKMGl6QWVoMS94SzJoK204UWEvTUdXemQ2TUZKQnNmYTBPclp2a0QwVm4zazMzOFc4WjEvRWZZdS8wVUQrTXRHQmZTc3JyRThPbGxpV1dPMk8rNi8xK3ZoNU5wLy9lVUxwVkQ3VWJ1VWRtRnZ4QUxqRGQ1V2x3ak8xSVgvTzlIY0tubzZOOTZUTWYwVjd6NGRRMWNCV0VHTXdqM0JLelZUSkdqVXBOSzhGTVdsdGVrelZGaEM2cFZPQXdXTkZUUVdrTWF0QlIvOCs2VE9Zc3N6bVNxVVJ2TWhHbEx0dWJBVnJ2RythRWlnVWtlNlJYcVZBT25lbGRLeEpnQ040RU1lWlFoa2duODJOdlZPNTk5VG1VL3dNRzRUU3B1YUNLdFVSRUxOc2cyNm9lenlrUUxBajF2QjNZUUduTFBWUUZLVE10QTErVDYvUG0vSzEzdlp0VXRnSmUxK1lsZ1JSV2VCRHJSYTl1bTZkUWxwM3Z4L0tzSjZ4dmg1VTlSUlVuTjdFc0U1Z3FpZDVQelNIaGVERzc4bmZjb05UK3FjUjRNY2xleSsvRkRHWVlSZmlBYmdPbFF4TFMzcEw5QXRPd2JwRFkxNzNDc0t0ZzdncVpTUlJqL01xd2orOWhBQjNQTTAwaU0xcnM4bUVZQmxWTERPUjJ2Rk1ubzRBT2pTajZiZXBMTVBRYzQ4MGlzbytzSlQ4NzF3QWdOY0YyTGdmWWg0RG9KUnA4QXJyaU9tQ3o1Q2x0NFVZa2gwNHljUTZUSkJjSUxWUFVRamZhdXNJc2JQRUJVclBEQ0phdkdtRGlEY3UydWY0LzB2a1ViVEtkakFLQnJLOVhUOElPQk5RRDFFQW5YZzUzUVFVSGtsNTU4RU5aWUNKcFJrR1BaSlE5cEkrcUxjdy9WUm5xMmY2Vm91NVNjLzk1clNjcDdKZWdydU5zMWZ2dzlSUXJsaHF1SGV0VTNHR2d5VEpkbW5wZkVzWGJyZFpOTW1CcktpNFRnREtMRGhQRUdnNHJMa2hrSS81SGxNL2FuT1E2WDNYQUx1ZEwvbVBQTU01dlFUUUNxbGUxWHFiTVgwdXEzamQ2T3ZubzJteGdoRjBoWUNLcnhQZ2FTbStyVTdmbjdvbE1QbzVpRmlOb3UxTFFORXcxd1FaZm9SakhZemlJSHZnUG9DM3dmTHlTeDhQa3ovVDd2b0FoWXRHR2lkUDJjTFJxT0FXQnVld1M3RlNPK3MxVWpUZWRNUlk4dkhSQWNwSUFVQnliZklEN2pYT3ExYm9TbVF4ZGJFenhVMDZ5TTZBdERKZ1dPazNrUkFjSXpvSE1iM29meWM2d2hJRkdxQm41L0NTajVRVjYwaFVVN0N6MHMyQWZLZE5rQ0RxVDZYVlpvT1dwMkd5UXNXWGVpMmdxdUZaN1k1REEyeWQ5K0ZuNGY5cjgrcm9uTVFkWXRhZnBQR2hMVkJUSG04anA5UEMveGN3U3pTcnVBdzdGL1J1YUVyUHlmSXFpQ3dQa3QxSC83UXdXREZVUlppMTV5WWsyRUpMR3ViTzgrTE9wSGwvUHlpZ0dTd0IyOEtvc3E0Nk9UeWtiVk4rZXc1cnU4azYxNmc4YXdFblJOR0p4YjZmWDU5NGJNVi9WejJPdndaNjhEdlRudEsrTU82dG9UUVlaa2pkVzZsNDhVMXJsTEhHZ1VabStod3NUWHRjWlVIRWVXZHBWNWZwWTdjdEJNRUhabDBUdnBudW45OUh2VnpJTTJpQkhTM2plVm5iVXQwc2g2aXczTU5vKzlMcFJreTNvdW1TVmRlbDlnSHVjZUdNR2I2RFJnNHR5T0RuOExTczQ1Z2ticHZJOWIwN1JKbS83Yi9mZ0RiT0M5Nm4zZDlZRHYrLzlPd05OTDB5UHcrSWdpNmhJRkM2d0RSNEEwMFBUejRQb0RlK05iK3dvSGgva1VCVTdicDRjRVZBRjlDYW13QmJIMU9ZZWx5eHpDUThSNmkwV0tHbUZhRlRPd0lGdWtJMkpvOEJXT1E5L0VZQ1ZtV2hyajJzWDhPQnRqZGdRRnZIOEpTRzE5REJPMStESllLL0NZczB2WUVGakVNbUpHRWEwQ0RjTjZ1d1J3S2ptRnJjWWZqYVVqUlBVQ01FaC9EOTQyQWwxUnNGcDZXK0dSNmVFQ2pEb0hjSFVSdnVHdUlJUEJUUHVhN01LSDlSZGkrTy9idmoyVWVYV3J1N25yS1p3THBVOFNheHhzMTM3Y3F3QUJSWVRuM3ZwQ0k0RS9EMXVKOUgrT3U5Ny8wbXNNcVRER2xZTk56RnpEYUFkaWUvaWJzdlA0WHNQUit1V0JHUmtLajc2ZGc1NEFnTncyVHIzdmZ2dzV6TUtnQi9QejA4T0FEUkVHL0IzdjM3SThBL256blMvdjF2WCswdjFYWDZKMmNMayttMC9yY3dzOGxFT0dQWmZ1STVxWE1xQWg4QXMyQ1Q1TmcwQVd3eko1VE12UnVjajhRamVvcmtTaHd4UTJGYzVNTGU0VytxWVIxSHA5NGxnRXhLa2hiWTJvcnhQcEE0ZnZ6N0FzeGh1dFo1Mi95UFBWMFRDS0RPeWlaeWZjQ3JLaHhqWWJhRWFJaGhPbHNWZmptL2x2NE9KYXk5dVF0cWlpcTRWWU5OVU1ZSDF3ZzFqeWtJVzBGbEhKZ21tQ3A3aEd0SGNoMmhwaXlqdXMyei9lYkc5RzJLb3NPS1JsS0I3NStwZjBVRk5jcVJoRXdLcTYxaWJHbTMrWDZqN3A5M09tNEdxMlE3cmRnTkM0WU9ldnMvb1hjeTBoUDdVdkJPcDQ5MG8xZUpSN0EvaDFwblA2Zks0cHJ6ekNWODhxaWJuS2xrclF1VDQrZU4vYmQxN0hKK29TVzhRT05XQ1FnUkcvblpRTklvclJpNk91cWMxTmp0eG80Rld4S1VsN0xtakhDSy8rZWtkcUQ3RHNDaXpRS1RLczBIUmJwQTBFYjBscWxlYm9lbXAyZ0VlU3BZb1IvYjFLdWs4bnNQNHllVWhxaktYb1paVUU2R2VwMFZhczFtK0JyVGJxbzhtOUk4MWVsOVFpWnlsZWRRWk0ya1loZHhIZEQrWDVVV1FUcXlQdCtsQmtMK1h6S0RicjNkeEhYWE9leEs4WkwxcXZzVGRiVUorTVo4ak15Ump4Yjg4bXJTYnJaVTdpeGZSSWp1TFUyNXJraVJyS3hFSVFJUEZQbXFmdzhPSFhKZSsyUzFTUTNlREY2aTJDU0dyc0hpQUFOejRmdUQ5S3NKY3hJUTlCQ0RiTTVuY2dCTVo0VGdqWUQ3azlmMTFMMEZwMTg5WDZlNGJ6bUlzK0pBczFuaGYwL2dLMWw4V3ptTkxrd0J5QTYrZ3lkdnEwRmM1Vi9kTG4rU2JVV250MEd0RiswNzh0b2xFMVZqaVJvZG9xc1RtbSt0NXpta3hiMllIVHVtb0FncEpFZitMTW93OUpSZjZ2YXUvMWdFclBEc0ZZbEl6Q3BNMmowblRvb051cFVFOHRLY0ZwWlJNdzFSRjdITTBqYWVreWFWVmhyR2tCNTFzbi9lZFpEeTR5OGVhM0RiVmgwNmJIejg1ejJxR01XZkYwNEZqNlA2MGxna3M0NjIzSXY2U0dRQXM0UGZZNEVQN2xHck9ISTZHK3VhYTNuUzk0RlQ3VSsxd0FBSUFCSlJFRlVtenFaVVU4SXo1VisySlRYcitQbjFBV0thZmJGaUU5d1ZQbTVwc2dtWUw5QXFrdXZ5QWxWQktpWDJmMU1kNTNYUWRZOTJGUlhVaDJXZUw1VXRnc3lTV1cxZzNVL05OS05ncDdJenlrdkJMbWsyc0RoWE5mZVczNGZiZDlCOXZiM1FidGZhOFI3eHpGb21jRjgvc3E3MlBxeU45Zk90Y0RQQjVQb0pLVm5rT3ZJOTBmOVhQbTVBbnFzVGF4MEZFZ2RFQ0cvVlUvb3dla3M1WHcvcTJjK3A1eWYweWxSYlJqTTRKRExWSHhucEY4SitDdHJNWVE1S3pSbVF2RDVsblQzRWo4dlpqTnJhQVR3THlVcTlvZTVDVENYeTQxOW9GakRkMFUvaHpsczhaeG9tU1YxYUNpbE11WVpUQnd5OHIyVDg5a3F6ZERUT2pkRVhZTjhrUGRTL3FDalZsTlR1ejZkVmtoTE8rMC95aVIrN3pybnZOeW1FVDZ2b2hNUitlMmlTbTByNmppY2dNQ1o3cGZRdk14R1V3UldDK2VmNzVicm8xaGdLUnNFZVVYbmROTXQxMUh2S1RsSERBRDBoakN3OUd4NmVIQVhCb3Fkd1lUTk1ReWtHOE1BMlVjd0FQZ0w2d1lGQSs2T1lDQXdnYm9wREhUcXdjREUzNEpGQVQ4SEE0QUFXNXcvUWdUZ2FsaDkyTFVMNFFCWERRT1Nhby9lSkhqNGVzdXRuWnBIZC80blNNSGZkeERUMi9MLy93V1dCdmxsMkx4R3NQbGZsZXV1STRKV24vYWZOLzMzRm14ZEx0MWpaM3A0TUdRYVhJLzRyS2VIQjQ5Z2tkaDkyRHNld0VEZSs3RDAyelBZbXQ3MWVkend6OG5BV2FOd0d5WUFUbjFlVC90OVBHamJNTUQ0ZTM1ZEh4SEF5OGZaZzRHMDF4QUJ3QThSRmFFZ0FCWlNMTmUrRndCYis1K0JyU3VqYVY5Q1ZGaHUrTThiL3Y4Y0J2aFNRRTRFMEh5cy9wd2JzSWppOTJEbjVYaDhhMy91QVBiYTlJZ0tnQXM0cndSNElaK2RxMlhqZkFIdW9lcGdNOU1WTW1vdVJHS01iKzIzMVlVRGJFL3Z3dmI5S1R4Q2UzcDRjSVptNWZ4bEdGQk1yelFDdHd0RVk5cFArUDB2ZUw5bi92ZXZ3ZW9STTFKKzZlZWNiY2ExSEcvMzU2ZG5kZjFqdjNQd2tSb0pQcTdBdzBjeHBsd29LbndITjFSc3RHWnQxemIwdGVuMUtreFJRYVdoSXhkdWFJeGZVWmpZZDBIQTR4eUNzRkNKVjFqRE9Qc3d4ZUpNQkpPVjhjaDhpbEd3S0FzaGJhRGhTdDlVK0h6OFNaU1dDRnBxWU5HNTgxNnRsNU9rU1NrOGx3bzVFTDBTTmIwT2xUNFZnSUN5c0ViamJnQnVFYjJmQ1M3d3Mxd0JPS0ZTV0tXZWxuTVU2UFhFdkl3SkRBQXhNcENSeTVxbVpsSHQzYWF6VkIrZUxqTmJJeUR1TmFaT3k5ZHBoT2pSbUNnckNvejRPNmZUWFdPcll0M1JlWk5TKzFHMU51QmhqWUo5YWRrREx0aEs1NzJrNUJRYjZXdTE2Z21iOXpjQVFtUytnaWhLbHlpL3NEKzlYNzJldWFlNjBHdjJveEhHYXZScHBEZHl6amd1S2pWOStZNFpTSlRQMFBPWEVaSGgyU1VsRC9HY2E4U0YvcCtzR1VUSmhDbjRwSW5zS3dGVU1uckpQdGkyNWYvZ0FGREZ6QVEwaEczQjNzc1VxOEJ6TUJvaVpneFFHaDhpZE5hQWhEVGNsZ3hhNUgybmNrMWVULzRFTVJJWi92dFJ5ZmpzL2RJcFdOY2kxTXB6dXFuMVV6bDJ6cWM0bDJydjlnMS9MbW5lM1BlSjZoSHFLRUVEaEJxdWVXWjBqb3dRT3dYd0lETmdjMDFZcDNJQWs1VWZjSzQ1dmFrOHJYTmxrY0xxY0pDRGhOejdKL21aODdtdG5DRUJJTnJxZFBjQWpCeDRZaXB5SURyMTh2d001WWZSWDhycit6NFBsVXVZQmFncG9raFRqekw5cHpwUk1CS043eUhRbnpYOFhCMUxHTm5IOTF3eUhvZnNHbUpFQWhvTVdBTHk4SDF6anFTdjZ0bS84UE9xYVo5VkZrb01ibFhCTWFXSzRCL1BBMmt2blFDQ1hsekZLTHQxL0p6QXdHenlNUUordVplYWVFS0pYMWN4MG15dHM4WGpicjQzMURFb25HZkVGUFN0Tmg3aEthUjdCUHNBSlBWbFdkK2NlNC8wVWM4Wm8xcVpNbHF6ZFdrR2lpV2tOTUNhRmtBOFJGa2dHRWo1RGtvMFp4S2RtZ2pBRW13WmNoL0t2R3VoYXlNL2M1VDdRNnI3VEU1aFkycDh5dlpjZndWd05PTkhPRk9pRCtqY2tvaFVtVnZKY1hjYnNUd2E1WTZGOTZ1OGhmV090YXlZeWh2NkxuSWFIdlROTmhuVzl5TnRkYUZWcVZNZmF3QXJ3QW9meHlOZkEwWUNiOEY0VVBGOFZySDhCT2ZERk9XYVJZSThSUG01Nmx1bGZuY2hFZFArbnZROGFUbUJFaGhSbFBrRitNZ2pVc25UZ01nRC8zLzIzaVJHdGl3OUQvdGl5TXg0YzcwYXVxdXJtajAzZStEUU5DbFpKR1NGYUZxUURVRzJEQyswZnh2RDIxeTk1VU11YTFVN3c0Qmg1TUtBRjRibGhlME5ZY3VTTDJsSkZFWFNaSGV6eVdiUDFkWFZOYjhwTXlNelkvRGkvNzl6dnZQZmMyOUU1TXRYVlczWEFSS1pHWEdITS83VDl3OUFSZDhLL1ZSOU42NlhYdGR5Q21Cem5sRkxPNjZweGpzYmVVaFRac0pJVGhyVEV2Ulh1Vm41T2UrbDdxbk9YMTM4Zkl3c3E2cmpVNDJmSi8yaENkRjRhcCtZWnNkNTVXdTd5R2RGMTVmbjVrVFdXQjFSQ3JCWjNrY2VUWG1KTkpiOFhQWHpKU3c3RGRETno0Rk12Mm95SCtlRTlJMXp3YjJkNUJtZnkraUkybXF5MWkxbjhRKzdiV3ZYRS8zOFE3Rlh4aWJ5bnVwYmdOT1lUV3dJRmYyUHRJNTdXR1hCcUd1bUpuSzFaalZhTlo2NUlQUjNHd0EyMGdMMnExZkhGOXVENnNReHhieWVUM1h1VE05dmN2QkVwNTI0eVJrTGdQSmNBNW4yRjdabTlpODhyczkyMFpyM0pnZEpjRjRTYUI5c0xyc29hVHA1QU5kVTVZZWF6RjBOSG9vdDZPS3RKalMyWlhNbXJVb0t2Z00zak5hZElhZC9QWU9CZWI4TUE1RzYwai9Edjd1S1hJLzNNN0RVdkcvNXowdkk0Q2hnd052L2pBdzZ2Z0Zuc2c3a0xHYUhCOGRkVWFLaHJaQWpVYThpSDZxdnp3NFBmanE1YzY5VlMyblQ1bURlUzhnQ0dtdGgvRy8rKzdjZ2RWSm5od2QvNXUrZXdBRFB0MkNwY3I4Q205L3ZJaXU2MS93Wm40QUJua3UvNTlLYjFrQk5RTm1kZXllend3UFdjRm5BNXUrbnlIV3ZDT3FlK1RpK2hLejB6MkZ6d2JUZ1B3SHdReGpBK0JBRzJIMEp0cTdxVWY0Ti8vdFBZaDhkckJ6RHdOb2x6Sm5nUjk2SEsvNzVRSzZ2N1kwVnpQbmdCSmFXZTR4Y2ExbmJHRGIvY3dDUG1kcDRrelk3UE5oRFRpUDlQb0Mzdy94cTFFSFhNd1lBeHJQREF3cnhWRGkwc2ZiMllIWjRRQy9UMWFaOTlYNCtDMXZmSzdBNnpPOGhnOENuRHRqU0lVQnJ1YTFySzJTbkRocFlUdno1dDVFVkxnTE1BOWorK3FxUGliWEdsN0I2MnIvbG45MkdSV3V6YnZNeGN0b3BScWlmK1R5c2ZKem51ZzgyaU5yK1FOcEhRWEFCUGh3Z1dnVTQ0UExuWXBNeFZZeWtOTTVYbjlVREZGRm9Vd1dJeG5rMXV0ZU1MOVcrZEh4RzVVUWpTcnRBYkUyTlZJQjUwK3oxdHV2S1J5MktxNnRWRlNSdElzU3FWem9WeXloNDBmTlJoYXFoM0tNcG5nZnlYWHduZ1drQ1Bna0VWOE8zR0FXQUlPRDE3UmtYbkZWT2VNVDNUTE1YY2tvQkZwNlRQQWM1NW81M0xHVHV6dnVFWHY4L2dheE5XVnVhQnJSemRBT1lOVVdpNm1BeGZmV1Z0ZnpLVzRwcTQvNnNYU1JqdkZEZG1JdTBiZDRqeWc0VnB5ZXV1ZktrVFdnVGxSVTlBekdDcmRwMDNzTlhQR3VrWWZ5TXYrTjVVNk8xQW9wRmY3R2RveUtWSm4zdlJtZFQzaG4zNlpMMyt2L1JTTGRFdVFmbk1rY0QveitCc1dMWUlaQkxnNHIyT3dKaXFSL1NmNlo4NzVxZllyNWxQOFo2Y2xFV28wRmJBVkYrcitVMjZHZ1NuVFM0cjlhQkR3U1kxVWhLSjFZMVdDemhVWmR5Nzh5dlg4bjlpMGlIQVV5Y2huQ3Vra0VRM2ZJbmpjL3NQdzM2S1pXV2cxcE1oL2tJN2VoeU9oeXBvWnQ3WUE5bFBlTVoydWNGTUxtVStvTm1xV0trYWdJakNDWTBGaTEzQ3VQSng0SGU2SmdWRUJrMCszZVp5UWpJK3VJUkttdlljWDdvS05GM3RzWXdjSVh2SVEyS0taZlBrVUVrcFF2cW1LR0djWUlzTFRDb0NjQzBHelRVR1JWd0lFbkF2VzM1dVJwWXVDOFQ2TkZrWjdKb0NJcjh2TnFtR1dnZVRVdG5zSlpoU1VDV1Z0OWxMeXcyb1lQU3V2ajVwcnhNbytFNytZdlFwMDJkZlo2bzBlQlB1cjd1blUxMlRFdkd4ZzdqMmdmV3BqbXRLRkNDczRESlQwTWdSL2JVbWdCcFVSNVl3dWhPY3ZKRGpqZ2VvY3hXTUpEdjZOeEIraEtqa04vZFlvam55S2wvazBGVys5NjNEMFYrVU9CRUFRK2dkR0lnT0tuZ0J1dlFFcGc4a1ROTmVmdUk3MnRLOERzNURDQkh0RExyem1NMUdqZjdkeC83MzBVNUxHbkt2OW4yNUcvT3RmSnpOYkJ6blNsbnFKNUpCNldkeXZzVEQrN29sN2JDTWI4eHA2TWhrRXFQa0srZkIzNnU0Qi83Vzh2ZVFaQ1gwZTlBS2VQcC91V1lWOGkyTHlCbjdOTU1ETXhNeEVDaUtOOG1VRkJvTU44MVJrNU56YmtxNUU0Zkk0R1V3bkZIcmgvNmRkd1BDekhBRTNEVForcmY2clF4YUhMRWEvck8zOWs2S3ozOGZKMStUbG9UWmVWbFdOc2xNbGlyenl3Y0xlVXNEK1h6eU05M0lJNGY3TU0wTzNza0dWMzRlYXVreHhiOC9NVGZVNnRqSE8wUWtaZDB2c05wa05aUXJ1NTN2MzRkUHovckdWUGhrQkIreC9kMDlqazB6YWpReS84K2FKMTNHN21oeVpHUUt3Umc4OE5zb3FNWGRNRi9ML3YycjdRaXd4TUVCQTducEMvb1N4MDNxSXUyOXNnMk1wRElzcXBMQXhzNm9QTVplbTNOYnNsMUZEcTRpdWVHOUdGYWNYSUo5R3ZWZU5DUTlqUElQbDEyNEhXMnFTSmdCZGxoU1ozSlcrT25mVUZzbnVwRXh1ZFNacXZ4YzlXYk8xdWNHN1ZqNkxNNjlCQUFCaXJGQ0VReXkrdmV5ZHN3OEhJSEJ1NTlHZ1o4RWNSVlFQZ1BZQURQei8zL1g0TFZEdjRaRE1qN3g4Z0E4ZjhKNEM4OGZTL2ZQWm5jdWJlTm9icG9ucUw1MDhpZTVLL0JJZ2QvUHJsemJ4dkJWdXVranVRM2dXWEFRTFVmdytibEdRQnZTVzNVSVd6ZXJzUG1na2FicjhIbWw1NytuL2IrN2NDSTlYMFlRUGZuNjJyamJqcUdiZE5menc0UHVNbWZoVEZZUmdYdmVSOS8xWDgvRHdOeWp3SDhHeC9YdDVFMytSbXMzdTlOLzV3YkhyQ0kzQlVzTXZzeGJDLzlCTUNwMXRyMWVhUXg1M2hMZ0paQzQ5OEc4TnRyTHY5bkFINndicTVrYnBKWEdQSmhQdHFtZi80OHpoVU5TVlFRQ0NCcDlPOU4yTDVld0lUZyt4dEd4by84M212Kzh4QUJyTDVvODdUWEx5S256MTVON3R3N254MGUvSDJZdzhSVjVIMDBnVG1EUEVhT2hpZll5eWp2TTJTdzk2K1I2UWdGVC9qOWp6NHFBTys2dHFrQjQvK0xyYUpVQUJXRzlMVDdVREU4ajd3Zm11NmpVRWJDTTZMM1BlbUFlbVdTRnFnWGZTMGFwNittV1FSSE5qSmlPZU9uUnkrTnFEUTRET0cxcnFqSVgxWUxpaGNORk11S1lFSkZYNzE5S2VDemxrZXZNY3lmZnhVYlJDZjRIRnp6ZDU0SklFRURTNXFIUHVOYkhPTmx0bWI3K253MDJDeW5HMFMzRUdCQkJ1bDF6QmNhajZ6Qnd2dlJsM0tPQnRuRkpudjRzcHF2OFFBV0pkQTVUaEdXZ1J6WjhhSFdTV0pyc2dld3RtUzRDdlJNd1F4MVVJajhrYlJKbFJnRkQyblFTWTRqS01GVWpiRGZxSFppazZNTGtwSW5mVlJGVVJYcEJJQnVvdkNMMFNrWi9zVFEyMmswRU1OOEFreHIxOHBjVUluVGE1SUJkOU16MWVRb25CUmxNTTBSVDR4S0JWQ1BDcEZucUlHVjhpalhoNFpjUnJURXVyWFZEQXMxV2llOGtZWlU4aFVhTGpoM1haRzlWZDdhNVBTZGk2blZoQ1d0V2lHRHF6R3FnbnJtaVlNckErUXNRelNBcEl3S1BzYVRpZ3h3SFZuV1RuczU4R0Exc281aHN2ZGpIK3RTYUNIMW9sUGtGTVowVkR4R1BrTWpaTEM0dWk5bHJqUUtTK2VGcVorSE1JRG5ZVzNPTjIwVncybml2MzQrSmo3ZVk3MEgyUUJNWjZBVnNqN0VGTXpjajlVb0lmK2V3SFlyRlhLNGxudVArK2pZUCtkY2NPK3RpMnAvbXZ4OGEyTnFreDNhTm8zUTBHakZOTTRuR1krZk8yQTlQMCtwTGo4b1B1bDdqVFN4cTVhc2dxUkFTWjg3NzduTXRtN3RSUmJpendBNXpmQks1WExuWjBwZjZaQkN1azFhY0E2ekYxMkhuWTBqbEJrYmVDN3BWSDdEUHljOTBxajdZOVdGZXVaNTdQMDVoUU1pUHZlM1VNb1NDb1krUkFha1Q5ZWRQNWR4YTZWT2VzOUtZODQxbk5kZDlPZ0p6ZjVkOGd4MW9EcEZwcmtiT3kzNjJqSVFndm9HQWJBSnNpM3lxSWVma3hjbStRcGxWZ28xd01lTUhvVU1HRDd2NHVmd2NjZVUzNVRYa3M3VTBkK3U1MTd6ZTg5OEhibkhUdnp2QkE3NlBUZDhYTE5wVGpkOFZlWUJzUFdnN1hCUjIwTXVOeTBRSE5Ga2JqaC92Q2ZwN2hXWkpNbDVzci9wWEpHeVd3a2Y3SXFDMVhsaGhEWkJZeloxSEI5dW90ZjF0Um9RR2dBVnlsUXh4WHBOUDA4QThvYjhuRFQ0Zk4wNFJMYmdQQlBJMWF3RXdCcm5tS2Zabm9DZmJ3eFVxcTNtc25pcThKcnp2bWMySlFEL2djMngwNFhrVk5Kekhla2ZrSUdzajBSRXM4anB5WllJQVV1MW4zRWZ5VGtFU2xDVjUweEIzVFQreW5uVExEelVRMG1mdG5HRXIwV204N20wMFFIdU1DdDBlaU81cyt2YURlUUF5ang5QVE1cERQNG4xd01JbVFnM2JXSS9hRG1HTm1VRThOcHNTdjR2Z1dLZU56NkRhM3k4N2R6MDlGMXRBbXgwMEs0K2J4eWk1bGF6d3dNU1h6S25YUmhqL3o1c1VoL0Fhc2F5YVZUbExSaEkvQTZ5Si9BRVdmajhrWC9IS04zVVVlL0hoY0ZmYnhSMm1jdWZ4cGFOaWFzRHYrbzlOUVNLT3JNRUo1bTJlZ0VEbUhXQ1Y3QjVlcy8vNTBiK09iTGdlUjAyZHhNWW9QNElGdG5JdEk5UERBQjdQN2NDZ1NWRjlEc29GUllhQVlhdy9YRGR4L1FEWkFIcEs3QTB3Mi9Bd1BGem1FZnBmV1FpTllhdC85K0ZnWDkvQ0FNUVovN2VKUEE2eUhlSzBpTjgwMFlqMjVzYlhNczZOdXNFTU82cFI4amVuUVJrdHdZa0JjUTg4M3JWYXBoaUcvdm5qSDZlQWZYVTJSM3ZZR1EvalZFTG1PUEgwTUgySFVsNXZXMy9IODRPRDhpb1ZnQnVla3JwTHlJRExXL0F3R0Q0ZGRkZ2UrVWFnQzhnZ3hOTTBmMCtiSDYvRFVuL3puM3hpd0w4c24wUUJvZ25iVS9MS09aTmpRS0Q4TmxUYmFMc3BqYk5IbndhT1VGRkp4bUN3M3lvUnhVQkRTcEQzSS84bndhRXJnalFXbHFVMm50RzNzZE5GWkZCa3lPQkZaUllORlo3OW9rOFB0VkFISlZMR1JjUXZCWUQ0Sk1NT0c1RUx6ei9BaWdYbXhxWWF2M1Q2RmdLNVVOWXRCWFR4TkZJbmRJd1lyM24vTEI1Q3Q2blFVbWdZTGdITTZCMHlTdG5zbTg2QVdSNUhpQXBUam5IVFVnckZ1YXVyOCtyeHRKU2Irb1J1bWxVY1dkemhaSEd2NjdvQzE1THBRSFlqSjlmU3R0RzhhZnkySGV0bkFVRnRvRDZuUE5jTEZBcWhJWHkzUE11TmNqdHVlSnpoaHpKdUNPWDF4U2lBYnIzanNyUVE2Y1AzQk1hZlZNejBLR1IxRllkZ0prcXFITWExNXJONm1TcFU1bUNlcTAwZEUxTzc4NTVwU3k3VlRSY05MVEJsRWdkMXd5bUQ2ankzMnB1WUZVQWJnSFRweGk1RUJWaHZYZUZTbVNBbjUxeFl6V0t0VStNR0l0N2tXUFJ2VmJyYTlmKzQ3TTBBcHVHN3hUeFJFQUFaU1FZZVFheko5Q2dVb0QwMDV6MVlvSlN0eXljSHNTZ0V3SCtNYktlZWdRSERKeWZ6R0hyTlVkMk5tTHRYZ0x3akV5amcrOGN3TlhwcTY4ODZwb3I2UXY1QWNkTng2cDVZMmt3VjgzKzNiMTFoclN1Um1PcjhNYUNGa0JBcUlvOHBNQUJEU0Z6bFM5Y1R0amh1Q3BkMEFqcEdwaWcwYVpLMHdaaUhJeEdxdDZ6eU9jK0pYNGVqV2pKK2FYclhWRUdXR01RNDNoVlhsMEtUU211M1pRdVRhMm0rRGJ5L3hQSjduNmV5UVBYMlh0b3Z5RWY2Z0tvdFU5SzB5OWlSS1BqM0tvUEJKUHJTYS82cmsxbkRKTFJDMzdHd3Z5VEw5S1JwVWJiMGxsQTV2M2trMGN5RG9LaUxKazBoTmtSeU5OcHlDVDR1d3VUbDF1cGZjUHpyc0FpMjhoTG1QbHZUNTVMUHAvQWVkSzJKbWQ5aUhOSmUrTUl3TEdBWlp2dzgxTmtQblVLMDN0YWVvbzNyc2VSajRsNjA5azJJRVBnNTNPL3YzQkFRSTVNN3VPUm1oNWUwOXN5dW5wZDFGRk5OaHJCYWlQUHd2ZWF1VUhQaDhxTG5YMzE5N1hPbGZPdUpYSTZUR2JkMElqcm5jWkE4VG15ZzBLVXRTakhzcW1zUlY0WFpmdENQZzc4UE1xVktoY05aQTM1SHNwT0xCMHlrdThIc01ndWxZVjJJcUJhYWVRN3ZBOG85WE9tQVI1ZkZBaXM4UE40WmxSMjAvc1V4RXB0S3VsRDVmOTEvTHpMMmJLTG55ZGRGcG1mcSt5NkNjQzBGZWk2YWV2ZzU0bnZkdHl6TFQ4bkhkNXBjclI3MWJsaUMzN2VGM0ZjYTAvS3p6c2RDenF1NWQvcmJGR1haaXVVZmJ1cDQzeG42UWwvanRxNjFBWUl0UHM3YkR3OWRKT2RLbXIyazBoenFZc3FlSno0bWVnQ2FmNFI2Q25IMHdOVU1uTVNJQ240cHdieWtvWlRseGtBcVhidUVFWWZJeTJydFFTUXEzNjl3ZjdVTW1ycnJpVnRWcDMrd29GRzNzK1d3NEd2b1RvR1Z4dDFiTFdyTmJra0MvdEpRTDNLU3p2NlZRUHIxZGFuUVBoYTNSd29HUzJBREVyTkRnK09ZSkd0RHdCOEN3YmNNdjNVNjdEVXZ0cStCNHNBVm1IM01RejhlUnNtSkw2RHJJaC9BOERyczhPREgxOUdOS0wzL1hSMmVQQWFzdWYwM01kdzNjZlIyenpGN2kyWU1NOUZvQkF6OTNla3hla0M0Znh6QXFsa0hBTVkwRW1sNWdZTUhMMEZBNExmaGFXQlhzSG1iS09JWlkvdy9EU0FCNU03OSs3SDc3ZU5BSmI3aXRRODhyNmZ3OUtCbjhMRzh4QVpHSDBURnJuNWxsLytIVGhZNlFBZTUrTFhZUkhoeDhocHBna1VEQUZjY1VjRUdrMEcyMGJYK2o0K0F2RFhzOE9EL3hyWncvT2ZlRjhad1Q2SFJZcjNQbCtpZFQ4QjREZGhDczh4YkYrOVBibHo3OGZiOUsvUzJGOTZBQTk4SEV6UnZESDR5WHJZc3ZZazRpZklndmV0MmVIQkJNRExzOE9EdDVIVGpsK0JSVnN2NVhsVkp3SmZVOVlJb3pmL3k3RG9jTGI3S0ExNGI4TWNIbDZDelIvbjhGMFlmWGpmNXlHbWRPNDFaSC9jUHRxTmpJdEN3RVhhbG9KdFgwc0daUDlkTTVMSFJvTW96MFdLSEVNWk1jUzZISm8raFVwS3FtY1QzeWRDQitlSjk2NmRyMm1PMnFzYTNLZlpnM2ZZN04vZDZUSWF1M0d1QU8ya3I5RllVQk5Fa2dJZURGcXRxQlUreDRWekdwSDdVdkd1VUFGSFJaSFNTQ3lObk5LVWE2UkROV04vVit1TElseXJMSFExTjdZVkFpdHkycmZhR0NOb1dKd25BZVZvSEIvQkRWb3V0TktybTBZNlJsSFJLSGlLZGczaDFudDdBSjNZaXBTZjZ4VG9uck05UUwwMFFxdE55MVNoMjZ6SmhXbEtrNzFQTmExYlo5dGsvZ0tONUY3bFo0T21CUEExRW9keVF6SzRWQjVQV1lCR1dtMEU0QlM0T0JVajBSSW9hbUhWb2lzNGh2UU1VWmFYOEVnSE55N1JBTUwxNVZnNDdtVElhN0wzYllvMjlXY3JXRW9IdzBFanppVzE1bU5MWnlnWXdvcG9LRFdxTkJ0a0t0RDNSbjduWTJjMDQ2NGJ3L1c4MHhCY2k5b2RrSGJUQUNCenpUMlNEQUY5QUV1VG93blBaRThtc0tyQ3AzWGZLQmhWNHdXYkdES3BJMFlBaThBMlpDenFOVThRZ1E0dzZvQjE3c1lMeVBVS0JITmMzQ2RKcjBQcFFVOSt2SURwTjR3QVRoRS84R3dVTUpsYURjYzAwcWUwbGROWFgzblk3Tjk5RnA1T1d2ZUlyME55UHZNOVBVTTI2dFRTN0ovNCs4ZCtmOVdMSERrQ0s4MlI3RnRkc3dHQTZBQ2hkRWNOVm5USUdhQU5lQXpkd0svWlQzU090VEhhcnNaekNPU3M1QnFOMkZmWmk0NHFjVXl0NXV2NnRQaTU4Z0h1MndSRzF0NmxhOVpqOU9IWXVQZm9XSkRxS3pzLzBOUzVZemNvYjhSbk41U3BhOUZ5STFReUNYUzlSNW9hOXpyYk5HY0cwS2l3cmhhQmhZczZudEU1c05xL3lyck54UkRhOTh3SWN2QjhKOERTcjJXYTNoRXlVQnlkc05TNFIyY3RsWE81MXhrTlN4bDdBZUN4bkxFRmNvbVlKYkt6U3BFYTJoc2RHalFMd1Jrc3hldHBZMm1XMldldUZUT1pjVDVKMittNE1JRmtxSERhcHlEQ0VrWnZobzJCMG4xT2MyZklaVkhnYzBNYXZheGN5N055WDhiUWtqSFg4SE9tcDFkK25nQjFYNE1IcU12MDVPZHA3TWgxVnFQTU4vUjU2blNBcEh3ZFFJNU9zSXI5bCtldktwK252cTREVDZoZm9xUi9iQnJkdkVKMjh1SStWMGZuQkRiQXhreFpVUjJHWWwvSUQ4Wk5ycVVLaERQaGYvTk1KZWRGLzA2amRIWHU5YXdONVpyZHl2TmJqcm0rQjg3WnA0NzFTS0IzczM5M2Qxb0IwaXI4ZklWU040djh2Q3Y2TG9LTUdta1pBUW55RnpvcWNyMXEvSncwdDBzL3AwTUE5VXlOa09QNnJRUFRhcTBYL0wyb3pVajRlZFRQcTNhREMvQnpIZTlZWk02eHl5ZzZqenV1SjF3bVAyK1Ywa0FJaE5pdzhieHZhcWNDNmdCb2JQRU1YZ2pnYjNMS2Y1NzlkWDFjS3p2UUxvSnl6R20vTkdWcHJJV3M3Ukp0ZVRxMkZiclhZSVhna09tMEpwVU5VZjRrL2V4NkY3K0x0RkIxNjBUTFJXZlIvZ3lSWlZFQ25pMDdGZTl2OXUrT0d3UEUxNVlnUWxpSHBpTlFJZGhVemk5NjVxV1Bhbk9JcWVTcnorK3dsVVVISENEUDU5b2EzVTNiRnRxM1ozUS9ybERhT1R0YkN3Qm04OGpCKzhqUm15dFlaQjVUVzMwSG1aQS9BUER0eVoxN1IwQUNvUDRPVEduK0kyUWhscEcvZndVRGVrNEJyTHhPNlFvQjlMbGdPL0ZuTVhYeEdNRFhab2NIUCt0N3RxUWI1cVkvOS83VUROY0lrWW1NY240RWkxcU1DNnRwZU1nRUNkWXl6UzFUSGY4eUxIcDIwL1lNREFBK1duZmhKYlUzWUFBdkRjZWM3eGRobS95Tm5qVGVJd0QvRVF6OGV4K1c5cGtlL0t3ZkMxaGs4QmdHMGg3QkhBNVM4LzB5aEsxUGxaQW9hS25wdEdlSEI3L3Z6Ly9IeU5IcjE3MC8xZVo3ZzByYkY1QWpXdCtIcmQ5bHBLYWdnQldOTDRETjJ3dCtIbWQ5a2QzZVY0SWhDa0l0NGVubi9FZVZpVEZzRDkyR3BXMy83dXp3NEMxa0FINk1zTC9jOFlER0xvMVUrQXdzOG4wRTRGL0I1dmdHREdUL0VYTEUrd1AvZVFjR0NyOEhPeituMkNMQytlTldieDNDLzRmU05oR010MzFPWDZzeDQ5QldNTTgzQlZ5VEVsd1RNRndwVklDRmprRjhIbWtFVUFKN0toaTJsRHNSNU9MWUtQUVdBdCttd2tkSDIwRVcxcUQzTkdXYWE5WkhCTXFVVHlwMEptTmptSXNpa2hyWldFUUYraVI4TjRZcFBhenhYVzFpSE5BeGF3MG13QlNsTTE4dk9pWVJXRmVqendTU0lyZ0Noc1QzZHZXcFUxbW9yVWtRNkdnSW9XZmdIQTR5MUl3SWFJUDZLeG5MQUJZeFFUclAvVGdTNDBrU1BMWFAwMXp6S1BhZmhuN3UvV2pzVDJOQ0hSQWJUck5qZ2hvOGR4dUxTT2VjcTdEYVpWaG9lYWozdEkzU1BrNXpKUHNBRjR3V2t2NnROV1pyVThWc3pYdlZRTWYvaTc1U3FVSTJDTkh6VkNOc1cyZTNvNmtSYnlIN2d1bmErS01nVWlzQ1RmcksvWmZxZ0NtOWM4UDVTdmVKekEzNG5jOFpvdzRUUU9uUFNzNEJzcGZYMVRzdG10Q0JxSGp2ZUI4WFFGSHZYU08wRjRHT0RPQ0dCcUVyUUFheW1TS1J0UnRIeUo3Y0JMaWpBWkM2U1hWTWZpNTUvbE5OeURXS01Ha1BRUndGbEVtWGdWem5rUUFBVzhIam1wd0trL1I4Yi9ycUswZGRmWmdhY0VJZXR4TytUcndQMlZER3NUSGlkdERzMzZWdVNoQmwxNDBXdThnMU51ZVFkRjIrN3pRVk9oMXgwbnVGWmk3a2MwYUlLWmg4SFJuWXVBNlRxUmxaUnQyVGE4bGF4VXU0azJXVG5SckdjaGJvUUUxQXV6WjNkSkpnNm05NjhZK20yYm1MeitDWmppQkljdlJ5QXkvcHlJN01EODhYeDB2RFBaKzEyMWpFT0oyTEdQMjg1K3ZRRjBWUmZDLzdYeDA2R0psTU1DczVCa3hmTFdvOWpuV3VtcHpDcmpWL1Q4alBDem10c3JjMStpQ2x6ZHpHU051RWxQWXlmdTVKbmdzMk92VHF0VFUrbmNxVytMT3FlNnVIbitzOHFMUE1yc3R1cEdWTFpKQ2x5OGluVVlpOWJicEJGSzZQbVJHZ05LNWR5R0NNTElldE5XaExHemo5STMrTzJWM1l1TDgwQ2loR25hNlFTNFNOcHErK2N1elBKdjhqRHpvSDFrWmRhU21VNDhheXR3QTVrcGQ3aVRTRFlHa1J6Uy85V2lHbk5INWZ4cUNPSzR0cFRzK2ZvdUJsN0tRMWUvS1pucVhrME9IUHBLeTRFVCtYUGIxcVFwMTFmK2ZDZVErZElSY3dvL0VOR08xN0lETEhEbXlQWnBvYUFBQWdBRWxFUVZSdDJXYzZtckl0WU9VSXlNOVQyUlBScDRxMHh4d3I4bnEyMXMvSGNDVHkvS2I4bk5sOW1BcFp4OEU1WlBZSzBrM3VUOVZ0eDQybFZlYTUzblBacURNcm9kTzdZMzhINmJUcXhDa1RqSXg1NUgvdndlYjVNVElvTmdNd0VaNlRNc2hVYUJPZkhSMHJnRktXaURSQkFYSm1SMUxlUTRldzVHZzNMUUZYQXEwN3N1Y3BkeXc1TC82c1Fkd0hNbmVrN3lzZlo1S3JoQStvUFVINXViNUhuVWdTS08vOFFIVkF5cUthWlloajVwNUorOWZIdEVKNy9uUU1rWjlyQktIS0loenZNWHlmS045dE1tQ3MvSnp6VjZzSHV0YnBxK3U3ZUo0NitEbjF3NjM1dVl5bG9BRWl2d0VDMXZ2bkxhY0NWR1NTSmp0VTB5RzRLOTM5V2p1ZzlKUDlPVzl5QnBPMDdoM1BvRFBscHZSNUkxdjVORWVocmwzak5lMml3UEc2ZVNPdDVObFNwNVV1L1p6T3oxRUdVUDI4Yng3VGZtckVJYUNSekZkK25lbzZmY05NTW1YSHVuU3Qrd3JaZHFIMElyMWJ4aC8xanJsY3UxV0xmV3dDUUt2L2MvL3F1WWhyS2pKS3N1bE9MYm82WmpOYzFlNFBqYnkwS284SkQ2SGRyN2ZKK1M0QWRPa0g1Vy9OWHBab084cDFTSFh0UlY5YVRsOTlaYkdOa0FzZ1Jja1dRRzBFb3h5RWVoN21QVDJBZ2I1WFlQVmpYd0R3KzhqcG9kK0VDQ0tUTy9lSzZLUktOR1Bzenc2QVQ4SHFERk9KWk9xVnJ3SDQrOGhwZXU4RCtHTll0REpCc21nZ0hTRFhPZWw3N3hBbVhEL3IxejhQQTdoL0F1QnZXTnM0M0hQRjd6bnkvdDBYSVBrNmdOL3hlZmt1REVqdEphb09QbjhXSnRCLzcwbnFKMSswU1dUc3l6Q2g5cldPc2QrQ3BZaitHZ3dFK0JGczN2NFFub1puY3VmZWZSL1R5ekJ3OEJac0hUaHZQNEhOOTZkaGFZYmZCL0N2Sm5mdXRjQmIzeGQ3Y0tCVEl0dDNZR3YxRDJCNzVpcHN2bjlTbXorSlhCN0RvcFkvQVFNMXI4THFOYjhIWUdkeTU5NWI0YjZ4ait0QmpOejFaNmFhSXZFc2VYOFpOVDJDblJ2dTd6ZVJqZUlrQWxTNHg2ZzRVZmlZQWR0elZBS1ozdTd2K2QvOC9OZTlYei95K2ZzSmJMMitBMXNMbmhVYTF3YXdkYUtYNHorRnBZRm5tdkJQdzV3R1hvZWR2NXV3OC9xMmo0WFpBVTYzamZMK3VGMU9XNk5ZYm5RL05nTTBPb0ZXRVlDZk9NcDNuV0F2REJUSUJoa0ZNbm85cDVzTUhBR1pieWpJR1Jrd1A5K2hFbDBicDM0bWZhUnhNeHFWR0ZWYzFBM3BNU3dTTEFTeTQ0WjZvVkxnNFBqWG5rVlpkMDBSU29XUDZjdlV1RCtFcDdCSHFhaXpIenFYYTQxNFl0UlVXbmpjdC9iK1dRSlkzU2pFT1FHQzhUV09kVk5sUkFYaU5XdkNHa0Nxa0hOZTF0WWk4LzdUcUpLTWNmN2RGV1E2ZlQ2VmxKRWI5RW5YaFB2d3BES1hqSDZZaHowNm5MYWRDelJ5UzVVQWdsQ2RkVVNmbENZOHpiWk4vK1RzSmk5K29JZzZaS3B1bGMwVEtOcWhCQ1VqYTFDR3FFQjNHUWQySVdkZGpMSkF1VTVSVVYyRXRSN0xOVUJXU2hMNFZPbTNPZ0FROUVybnZvTVdhb1RxMWpXMHQyMHlMa2hmbGJaekxxcUdLcUZQQS9tWnlWbFhrRzBNNU9na3YzOG9lMkhYbjkwTGlBaWRYNkcvYm1hS2dBMXJxY1ppQlVFMStwWDhRNk55Z1RMaWtUeUFvSjRhMFNOSW9pbUZPYWZMSmdQUnFxTngzcFl3dVJFd09adXlPNTBSMWFqVmlwNFNPV1FJazRQNWJvNkQ2Nnp5Y21Gbzg3bW1vOHl1WDB0SHlPdklnSlFDNkFRMGFDelhpTnJsMUFBZk92V2tlZVA3d2w3YlJkYVAyQWdPcVV5elJEMlN1R2hOVHJsS3B5MmxVWHdQUHdNeTcrWTZLNzFRQS9VUS9hVU4xQWc1Q0Q4Rnorbmc1OHBydUpmU0diMGtmcjdXa01xK29LVG5iSnZLeDVUQmFvWWZ6czhDU0tubE5razFxUVlqbnFHQzFzajFkSm9ySEw0cWUwL1htMDRYUE5NRTMvdnFnbjhrbkZOcnJlbEpLOXJCbHliSVFEelgrVXhvS1VGTjhraWV6ZHIrSnRoTEIyNnVNN01RckdEMVpHdUFBeU5xeVg5dXlEMU11OHMrYzI4U2JEdVRQVXQ3SGI5LzVJWnIxclE5aVh6SVpjMHIvaXc2YXpBRHdxSXliOGtJeVRuL2dQZzV6d0V6QkEyUmJSZERBQW9BanlIQVhaTnJseXBkUFJhRE0vbFNjb2lOL0NLZTVkb1pESDBlSUpjR2E4bmZjbDAxSWwvNlRKck05M0V2OHZ3eWEwVXRrcGZYY2wyVGs1by9memx0QSswMGRNK0JWTjl5Z3V6Y0FKVE9Qa2wzYTh5eGlxVm02RmhHWGdOL1hnVFZLU3R4SFNEWDZ4amlPVzNwaHNobmhFNFdxcHNwNkFOa0FJelAzWkh2VnRPY3hRRG9xZlVxdEVUbEtqWTZlaWx2M1lTZnEwMUNHM2xJQVRESWQ2dktQV3ljdTR2bzV3dUk0M1ZmdjRXZmE3a21vSWN1QTFzSENXekN6OVZXb1B5Y2VzMm1NbFhMTmlQenM1RzlSZTVUY0o1clZRV0JSUjZLZEtGR2o0SHNsQk1kS2RabEUvakl0blUyajNCdDFZYTNSajlQT2w2RkxtbW1vV1Zsemp2TEc4UitCNTJSdGphVmxXa0RXSWJuNkRVeGdLTWE5ZDJFakczcnprdjgvb093MmNnYXFEMFhrTUMzaXQwaDJvSUx1bHJSN3phaUtkdm9FODRmbDNHdjFKN1pJZWVSYmxDdWcvelBjU2pZeTg4NUY4bnVjQkVrZmdKZ09EczhHTXdPRDNabWh3ZlhBSHhtZG5qd2xkbmh3WFVIQk1jQTNwL2N1VGVEQ1lUdndRQ3MxMkRnNndLbXZOK2YzTG0zZE1Cd0Q4QS9uQjBlVEFtQ0FRbTRHM25FWVZlN0RRT2N2Z1NMb0gwV3dHOEIrRjFrWUl4ZzFEK0NnVnovSGd5NGVnbkFjOTRQMXAybHdONDNQODhCK0tvLzQzVllWUE1md0FDekxtTE9hRWtLOHdNQThEbjhEVmowNUFobFBaVjE3UjEvZHdUT0J6cVA2OXJzOEdBNE96d1l6UTRQeHA0YWVOTTJnQmxnbUFiNmh1K0xuZG5oQWY4ZXdFRFh6OElBdnovMFBuL1R3Y3FVK3NQL2Z3OFdyZm96ZjhmdkFQaFBBZnhEMkZvLzYrLzlESURQZHV3TkNyU0p1WGsvcnNBQTV1L0IwZzRmQS9nVkFMOHlPenk0TFdDcGd0dEFGb0RmZ2UzZHY0RWR2dFpjeVgwUE85STIwN2hTaStKTjRKSi9Sd0h6aXdBK0IrRHp5TXhhRFRRam41dmFYSkJnY0Y4cjRYakJuM3NWMlJBMmhwMmxYNExWYXY0MHN1S3dCOXY3VkV4WUQveHpzUFc1Qlp0UDFySjdEY0MvOWZkOHhlLzVJV3orZmdUZ25jbWRlOGNmZzcrLzhLMEZabTV5WGVXZVFlV3pyVm8wR0haOHI4WktOdEtLMWhrS3oxRUZhVFY5OVJWR3F2RzVhaURWcGdLNmV2cW1zVGY3ZC9rNUZYZlMxZGdTelVUcHVaMjhtSnY5bE5xVVk2YkFRV1dXN3lEUVFhRnkyRGZ2L2x4VnJtazRVRTlzRmNwVUNSekw5d3NZWFdFdFJSb2lkQTVyNzlRNWlGN3NzUTJiL2JzN3pmN2RYZjg5Q0FMd0NnNCsrazlOaVJyQzFpRkdxckZmWFI1OUt5QkZOY2I3VXZTZkdKQm9yQ1pOSDIrdy94bHhRMjlONVRjekdIOUx4bHovdmJQbXVhb01hcXZkRTBFeDhEM3lqcG9ReXUvT1liTExRSXpmUlF2bm1XdDVJUy9TcDlHMk1EcW9WeWNWdXdUVUlrZG82ZGdpM1ludjVwbU5leTJ0eVJZMGxLazVrM3lDYkJEUU5SNkZQa1k2R2x1OEhoQ0R1TTlEUVR0MVRwMithc1RmeHA3a1Q5aG9KSXZuT3huUFF6OFgwekp5ajFHMVNxdjN4QkFLbEJHYWM2Y25FNzltNHNhdzFkUWlPMDhicTlPOEM5aCs4ck9nNTBaVG1IYWVrZW1ycjh6OW1lb0V3LzRBQXZZanIvOTgrdW9ycDA0bkkrL1JmY2Z4SkFPajA3aVU4WUV2aThZSmxFbzA2eHZUZ1hjdXp3YUFQZUZyRTNuR1VuNWFCbFh2eHpXVTlZMFZKSHVFTEIvUWlhbktXNUNOc3dSSTZSQXpoTkhleDhnMGpuOHZZTjdwckRQSy9hRzhoL000OGYwd2drVmI3Z29QSXowaFgrZVpaUjlVUCtqY0N5NHowRENmSXB0UWdsV2M5OEp4UmI3alhwa2hwN1FsR04yS2F2RjludmF0cktQdWg1cEQyOEQ3eS9UWDZ2Q2tjc0FjSFFiM1JpS3ZLOTkxOGlINXZzYlB4elJjUjlyRmZtT3pxTmNsaEs2RVo1MVBYMzNsek9sTStyNlBGd3FQYWNta0hYeWh4Y3ZsUGJ5ZUlBZGxQajIvVEVrODd1cVg3M3Z5cGwybmFSOGxmdDVYNTFGNXFwWWVvUnpHaU1raE1zaElNSldnR0hXTWFCQUdjc1lGUGQrOFY1MVZheTJ1NXpIS2lFcDFsSVE4bjg0cUhCOXBJdlVRbGZWSEFLNVh6Z2hsQU81Tm5zRldGSkd2djZZcy95RDUrUmlsMDgwQXVWemNJKzJIODBpTjNKdkQ1dlFFTHJNQ3VOSllUZmFyTUo2aTBkWFVNM2FkNTF5UjhaN0RJdTEybWh6QjFjWFB1UmFkTXBidldZS3lhcE5TcDFKSXZ3ZzhuZm80STMxUS9zblB1SjhWeE5ZNjFXeWtyd05ZZWx2T0tjdnpVQzlSdnNXeEFwbWZhMy9KZHhTVWd2ZGpCTk5wZEs4QzJabnNGSm0zNmhtbzJSclVTVldmeCsrb255MmNIcFBQUmFjYVhzKy9BZE5GeWNPSHpqTlNWR3psUG81WjdYM2t6MzA4YXRTRWpEa3lId3FhMUpwK3p2SHEvRWRkZ08vczBzL2pmb3A5SFFvLzUxekVQcWVvOWg3d2w3SmNxM1hwUDMxNm0vZXBWUTRpM05PSFNiQXQwZUdZNytldVZYZDhBMTdJOXhaeWM4LzdnYlorcnYrcmJLZHJCbVFhdm9rdGduTFE3a1hzZGsrclJabXNxelVaL0kzNmVUcS9RRXBYcnp4VVplRFlsQTlHMlpIOHRLL3ZoWDZKOGh4eS9aVkdEVHZzVVYwOFpJQnVlMURpRyt2bUwzNy90TUZmZVVmVWM1TWVWNU1wS3YzaytwekQxbWZzUDZRblhUYS9vVitUbmt1Ymw4NmxYMWY4ajgzb1JwUTFJWDhYOWdlL2J1RDdQTkthdUE1S3U4ZHJRNUcxelE0UGJnUDROUUIvNmg5OUVnWTYwZnVhRDk2RnBJejFhRWJBQUwwSE1BVjdGOENaMU1pOURlQUhNSUJ3ZDNaNG9NYW9aLzF6ekE0UGhncXFUZTdjT3dmdzU3UERneHZJYWFaZmhrV2ExdG9lZ1A4WXR1Q1AvYjAvQS9DV0FLWXE4RmJiNU02OXQyZUhCKzhpcDg1OUZ4NGgyUVZtVGU3Y081c2RIakRxOUJqQXp1endZQVVEcWovcmZmb3NMRUx5VDJlSEJ6LzJXNWUxNkZRSENGdHBXU1JxZFhkMmVIQzZTZTNZeVoxN1M0OWEvU3lBWjJhSEIzL2hjOXQ2ZGdBdGI4SG1FN0NJM0J2SUh1K255Q2wrYjhQMnl3K1JqV3Fhc2tTZlNXQjFEd1ljdm90c2dQOWRsS0RyaXdDKzQvc2k5ZGZIL0w2RHd6dStuOGF3R3NCTVFmeWNQT2NUUHBhL25CMGV2QU1qdE0vQ29sWTFCZE9KLzN6QysvTW1nUEhzOE9EdFVPdFlCYm5ZQnJBOXNKZ2RIaHlIV3JkcDczamZQK1hYbnNOU2I3K0pVcGdsUWJnRzRMY0J2RFk3UFBqenNBZlZZM1VBWU9YcmZWUG00SE1kZllYUEYvZklNWExLN2hlUmEyeC9FYmErTkFxOEJFdVAvVHB5VGJzei8vOE4yTHllZlp6cStlbTI1aWw0WXNWbmRnaTNXd2tNVDNyZHR2ZFBjN3BRQ2psTCtkM3lHZ05TS2lXMm1nY3VqZDU2MXRSVFU3MjlWOGhBYS9Ua1EvaE5nV1N1eHJQS2U1UEhiK04xU0FncytwaFR2VElmdnlxWFdxc2tnVE8xdWZOR3ozRWdlejlUYVZZaGxlOG5YZEIwdjhtTE9paDJOUzlwcGppalJ6azlzMWt2c1dWZ2RVSDRPdHEwK0lILzFraE0zak1BV3JVOFdKdXNKU1I3SDJwZWhqUktWNFlDSUFqV1FYamt2cUhSdnl2aWc5ZHlyVnQ5NjNqM3VsbzRuRWNWVkZzR0UzOUg1N1BDK3dmSXRSeDFYK2l6QjI1TW0zVVpZTkUrSDc4UUxTcCswektxb05QWTNKUTFrK0krVFlvSG42djNvdHNSa2RjVWRXYW51ZjRabjBOakdWQUNRN0ZwWGJYb2daeldxOGxSeVJ5UE9pYWtsTnpjeHhWbDdRUDFRSmV6clFxK0t0K003dXA3eGhJQW8xbWpZVXNqa0RUcU1rVzZvS1RCQ1R3VkkvRktydVh2TVRhUEtpQmRaWGtDZ2hnRGxHbnlZMnIvd2lpQ0VuQlV1cXI5Vno3QkZ2ZVUxb2RNemkyK0ZyeVBCdnVSRzdzSk9ETGFqYzlsMzg2Yk1yVXVVM1d5OWpuN1NjRCtLc3JzQnl1L2R0RHMzNzB2Ky9JR2pKY3cyOFVwTXFDaTY4SnpRVURnREFic01tVno0YnlMZk5ZMFZTZmxpSkdjMnhPWnAyUGtQYlJDR2Vta0VYK2JOTDQvR2JaUkduQVZDRnlFYTdrUHRKeENUWjdhaGNrcDV5ajUrUmtrc2x4bFRRRnVDYndQbXYyN1Y2YzV1anNhNy9yNE9XbFcwY0krS3o2WDU5VmFud3ljMXNEWHZJOW1ESVFtYmlvanI2T0xnOHJmVlJtdnIyOFZveWYzbk5aOTVUUEp6eWZvS0I4aHp5cWNSWDVCR3VXekFUeHlwTW4xaW1jaVg2ZTVtT1kwc1RSY3F1dzBhbkp0UEs2QmdwRUxsM1ZuUUQwZDhEVFVmUGQ3M2tjSi9qSHdRSFVPaEdjKzhyRmQ4K2VRUGhYZ2gvUHBDWEptc2Z1a2NTSkw5UEh6RDlUcFcrZ0w1UnFOb2lGSTN5c2JCMzZ1YVZPNWQ2bTdzQXlCMHRDb001SUh6WnN5ODRhVzd5SjQwSGVHdEkzOXZhemJxM1JPTTRMRUNPNmF2a2ZBUVIxQ2s4RjltdXZ6UnJsVW5ZU1lidnVLaitVTVpZVFNDamtiSGxPcGt3ZnNobmNtWFowZ21jOEorNmMwSkRrckNTQkNYZ3hrZTU3eTN0MnBSZXhxZEN5ZEYzbk9hM29Xei80STJRRks5N3Z5U0tDTXNGWTlPa1ZlK3R3V3pzMml6Mi9MejltVUhrWGRqSDFSblV6SHJUcDViUjhPSWZZTTRlZGEwcUxvYzVNZHE0SHNMTEV6OWV3Q3ZtK2lERm0xUDNYeGMzNi95V2ZyV3JDUFVHNGVUL3V6OG15Y1pVVGVzK24xY1Q1clBLRzMxcW8rYTVyVDg2cjlDc2o4bVU0ZmZkSG5xZy84d3RoMmcwNFRIZDY2YklncUsrcjVUbnZYMTVLZlIvMThYUjNjbWh5YStGT1RVN3VyenRpMTE4bVBZeXZHM2VRbzQvTW9DMTZXVGZlU216ckVxTzF5dDhtMXkzdWJyTFhTVnZMZFBwMjNlTGJvTmZPbVRDR2Q5SGlYQzFPNXBYV043M1haa0RTVk1wYnFOSDNQaTNSeDFmVkZaL01vMWQrREFaNy9Ed3dzQTB3QmZnc0c4aDNCQnYwOEhPQ0JnWmNFeGw2QUNRS3YrVzhsMmwvei8zOE1BM0EvQ1lzdVpKM1dSd0QrVi8vN1BvQ2pTdXJjTDhGU1BqKzd3WkRtL3J6UCtYdi9DTGttSVEwUGk2NjB5djQrdm5NSEJpSXZZTXIvQTlaRDdybjNoby81SlFCZmhpM0tNWEtrTktONk9UL242QUdYTzk1REQ4Nk5haXQ3djY3QkFmeVlqcnR5L1M2QS93UVdDUTFrNFdJR0E0Ty9CWXZ5ZkFqZ3Y0QkZyeDdCZ1A3dkFUaVozTG4zVTMvT2lnRHU3UERnR1huTjEyR1J2cy9DNXJiVy9qdC81MGtsM2ZJUXRwZStESnZyei9ST2drVncveFZ5K3BxLzhjLzE4SDhLdG4vSHNIMTV4Y2MwZzYyckFzWnZJS2ZESTZHYXc0RFgzd1R3cmNtZGV6OE5mZDd4WjM3QjMvRTJQR3ArY3VmZVE3K0d4T2E2Lzl4R1R2MzJQaXlGK0Z5ZTJZbzJuaDBlL0MwQVU2elBTZjlEMko1OEE5bEE5cXZJYWIrakZ3N0Jka1lBZjlzL0o0ajk2T09JMzh0dGZVRHYwd0NCdDJrS1ZqeXQvc1Izckx1TzE0cHlwNG9yK2NBTXBhR2swNU5RbFVUL3JaRXBWT3BVUUNRdEFNcW9TUFZPWmdUU3l2dFNTOVhDMU5rajVQUmFqTHpaTkgzSkZVZ3RNaEdHV25WM3BOOFVrdGh2K0xzbjNzK3pKa2N5azc0d2hid2FqSWNJS2E0ci9ZdlBvVmV5emhXRjRLSzJYV1BweEhhbXI3N3l2djlQSUlhR0J4cGJ0VzdTTlppeHBKZi9WZnJadVFkcmU3NTJ2WXlWY3pPQ0dSUnI2UnE1UnIyMGROMTFzb2VvL0RHdGRQVGFydFlOWE5mQzJTQm9vRmtwK0U0Zzc2dHoyTHFkaFdlTlVObVh2eWd0QUJvMVJYbUlIanJqOTZsVHgwYnIwYlVIbXB3NkVFQTF0Yk1hM3Rob2xGRlFLOVdvblpiUnVvVjNzdHc3bk9aNnhhUXA2andEVkdweWZ4aXR5ZlY2Z2F3YjBBaEVPdHVwYVByY2F5cER6Z1h2NTdPVWpxNWc2L1ZZbmtPWlQ5T0FyWUQxNmFSNitzYSthRFJhNmx1RlprWGp1Um96Z1p6VkFUS21Ya1c4S2RPWTc4amZuQjgxS1BOYTBnM3FCRU40M1VEL1RiQVF5RkYxekhBemttY3cvZWVwSytkOFA0RlY1ZWtzTFVTZGNDQjg3aVl5ZUtDZ0ZoMlV6bEdtK3Q4REFBRXYwWlFPSWFTVG5BZktIK3ZTaG5HdnBUU1pNcjh0UTBFNC80VWpoLy9OZE9MSHlQSUkrM2xlK1p2ZzdCbFFUN3NuWUFmcENzY1orVG4zanZMSFBYOHUrYlhTcHdSVWhMSHZvYWZFUUZmYlZLYnN1MTdPbDRJb25YeDBFOWw0RzFsWDlsdU1rdWdGZTljOGwzdUd6aFRVOS9nWjEwTEJtRDUrUHNJRlpZc0w5UDNDdWtmZzNZbitCUjZZbkJDUTE1MmdWMWYwV3FMbm14Z3NaVThONDU1dWNzckpBVUlFZkpQVFN5dHd1VUttc1l5V1JMTi85eFp5Vm9VM3hVaktleWtuRThBNm5iNzZ5bVBaYThvekNZQlZIUmsvNk9aenhQSml6SlpBdWZNaDFzalVQZyswU3c3azl3STVkWEYwUnVKNkhJWG5jRDNJejdrT0Y1SnZLVlBxUHVJZXE5RS80ZlhzditxY3FrdFNYeHFqMzBGVDk2ZnEwdkRQVGxEeWMxN0x2akc0WTRDeWhBVHZWK2RpM2NlQTZDdEJCdFY5cTJ0Q2gxVE4ycktVZmE3WDhtOW0vRmdFT3I4RG8yK1JuOVB4bVNBMzlWVHk4M1c2VzdJSkNKMFp5V2RkNTUvbk90cjRtVFdEY290R2szTDlPVjZkMTc3eVVwUXZobks5OG5QSTgrSzg3YUxrMTNwUEZ6L2ZSVTg2N2N0cVBmcTUybHBXOERUM205emY5NjR0NUF5VjJZQ3NkMTFJQjlEMys3TTFvSURnRlhrVWdGUVRPZGFKMzlnbThWRnRjUjNVWHNpMmdkeWwvUHpDc21ONC93QkJucGJ2b29NeWY5VG1TanBmVFhPTXJJTnlmNTlXcnROM2JPM1k4TFNheUZEVUdSTHd1dWsrZERvVXo5UjhhazRSMFM2YjVxSWl6MFk2Q0hUb1FVL1NhbWN2OUlFTy9jbVdpN0FubS8yN2c4SHM4R0MwRG96eDJyVy9BZ003UDRNY3dmY0FGdEgzR29DNVJ3anV3V3FpUG5id2JUQzVjMi9oZjM4WkJ1VDlCVXd4dm9tY2J1dnpNSUhzSVF6NCtvSy9UOXVKdjQrMWxuNkNIRkg2ZXpCUXF0WVdmdDNLMy9lc1Q4b2ZBZmdQWUlMc3YwQTIrcC82K0hZZ2RYb3I4ektDMTY5RlRtbENJZnVSMUozbHBpR0krU1ZZeE9TZXYyOEFpM0k5QWZBbkFON1RPcnFTVXZnV0RKamRXSEVqdUFvRHMzc1ByQU9QUzErdm5iNTdmRXkvQitBYmFBT0k1N0RJM3orRTdZMGxnUDhTdHQ1ditIZkhNRWVDaHhCRGpUc0xmQklXMlh3R2l6ai9Lc3p4b05iZWd3R003d0g0S1hJNkpqS3hYNFdsSnU1cWI4QUFYVzFNOWZNSE1EQjRLYldhUjdEbzN3U3ljRXFRdldGcGFQb0VETkNuMStrSkxHcjJ4ejZtNTJIQTdaOTYzMWtuKytzQS9ocDJ2bGhyK0FqQTQ3Q25kcENCNUJNQS83ZjNpMGFxSlpBaXhWdHRkbmp3WHlFck1yWDJFQWJZM3ZlL3Z3YWI1K3MranE0MDVYOEtpeVRuV3IvbW56K0FnZlFmdWhMNGNmdmdXbE42NjE3bWM2dkNtU2g5RktwcUVTaHFrRk1CWWduYjExU0dUdEhEeUFONE5oSkZKUXFTdzNoL0ZKWlZDQlFsbElKSDFRTTh2SjhnS2IwTysrcmZ0ZVpMQUdzS2dhcXNzalluRlRDZ0hibVVCQi9wRTVYMmdYeXVSdEZWK0w0VHBFUmVKMTA3R3RvS280U004UW9zVlNnQllCcURHWEhJZWRDeHM1YmFoUXlrSFgzZldCSDBQeW1Ram1DMXY1SkJZeHRoTWhoQVdvQmFaUTl5elRSaWtRYUFTMVhxZ3NGMFBIMzFsUk14ckxKKzhUSVlWYll5eW9mN2VPOUhRbkZoRStBbktkaEF0eU1CS3NyZ211Y1g1ejE4cnVubEdUM0hxQTBheDhiaG11UjhJUW9TblNsYWRaRDhYWHJlYVd3aTBLWEFGNysvZEFOUDM5bnBVNmo4ZXpxNkFlMElkaURYdUtXeXVCUjZxV0NlT2h5eGJpeWpzdWdZa1F6QlFOdjQxdVM2MzJxWW1Ta2Y2UmtuRGZNcDhySmpyR2s5Z2lHQSsyS0k3T2hEdXN5OWRPNmZ0eHlmNURteHBtajA0RWFZYi9LakFRejRlT3ozWGtWcExBWXk0RFNHMFJVMXVsOUhHeGptTzVmSXBVczR2K3o3TGt4M0hNTDB4VE1BazhCWGFMdytRcFlqQ0N6UUFNeS9hUmcrcmN3RHp4eEJhcVhITFRtZ3liVmh5YU5IRUhDb3lZNGMwZmpNS0NQdUlZMGFoc3dUK2VXT2ZFZGdTNEY1ZnE5bm5ORlFrVGRUcnFtbDJlemk1OG1RTDBBVmpWb3BLa3pmcDhiOEp6R1F4cmFsd1piajVaNWFXNzl4emJNQUFSNXIzNnVSeDcrS1VXT1hYdFBQMTJJUG1XN01oSi96bk02bk9jS3JkeXc5NytHYVVuYXBPdWsvcmJadTdadjl1d1JHS2R1eWxtaE5GaWM5M1JqMGE4VHBvWEpHR0lrSTVMUEhEQWlzMGF1cGZKbWVmdUxYRXNSOVh0N3hacVVQWTVqdGdnNGZENEJVNHV5YVg4WXp1d0R3K0xMa2FlbER0VzR3ejF2ZmZEYTVITUVPTW0wOWtqNmZDRC9uK3FqK3czME9sRTRyeC83ZEhzd0dveG1SNWtBclE0b2FuNWZJNE91eDByQWVmcTQ4bzgvaGhtQk9yTmVyK3R5NUdJMEpjaTNoempOTlR0RzdqcCtUcDZSTURtanpVNTROZUw5Snp5bDdhTjFiemgxNXYyYXVvVnpHK2VkMTFBMUg0VGZYWWlTeVM2cG5QaTBkZ1ZQa3RqeUQ3eGtqODhVUk1tQjhGdWFCNTRPOGtmSUdlVzZybGk3bkdWbGZMdWE5eVNCdmNqYjNhK2ROQ1FDejMyejYzS1c4Ui9jdmtOZHJLTi96TjZQUGFub2t3bjM2N09qSXBYTEVZRnFwS2IyR24xKzZQcnBwOHo2b0RMNjJydkVHejZ6cUh6VjlWMmlTN3ZOT2dQNUorZ1J4NUtLdTUzc3lsUXlKZEhaYkd3WHZ3VWRYUDFjQURmemRRV3RwTzdzVStVck9LQ0IyQWRyUXhJNlY5b0o4andvdHF0YUs5bXMwQzVYcXM5UURsQlp2REc1ZlJ0dEE1bExkVWVrZmdINTdrZXp6cUljb2ZTY2RWNXBZM1FlNmw1R0I0cTNrMnczR3luV3F2YitxZHpjNStDWFJpaUdBYTdQRGd5dTFlckZlUi9ZS1ROQzdDaE9RSGdMNEpnekUvUUVNNEpvREdEaFFTYVdWYVhncEJQRDNOLzAzQlM0YSt6NEhxem42Z245UElUSzJsLzJhVDhGQTFMOEQ0TitIZ1czYTN2TG52d3VMaUx6dG44SEhjZ05XVy9aVE1CRHM4N0NOZmd4THN6dERpREtXZWRsem9Ic0ZpL1o5RDhDcEEra3pHSGg1WlhaNHNDc3ByamxHMWcybTRQa0l3RCtEZ2FYL0I0QTNPd0RlZ2R5elRWc2JidTYxZjUrRjE4Vnk4SGNNUzIwODlMckF0MzNjbzluaHdYUEl0Vzhld1FDKzk1QWRBMzRBNER1d3lGVjZZR3NrOXdLbVlHamRyam1Ba2U5REtoRmZCL0FQMEEzK3ptRWdNbURnT2ozc0p2Ny95LzVUYXcrOWo3Vkk3YkgzOTlmUnJ2RzdoTzJqOS8wWmoveUhocHBQK2h3Y3cvYlpDLzZzV3pEUTlBdCtEVUhtUDRWRlNlL0tmRHlHQWNKdit6Vkg4TlJQMGc4YVhFYXdQVTRnQkFDT0ozZnVMYnltZFovelFoLzRDLy8rU3pEQTl6NXlEYk9sai9rY3B1UWtZdWp0aTk3dm4vczRUbnkrUGdaLy8vL1o0djU0b3RiczErdXdDU01rQTZaZ1ZHc1V6dFR3VEVWY0ZjVkM2T3Q2TjBybHRpYXdBNlZpbEo2cDkvQSsvL3NNWnB3NWpVcDdSVEZRNFl4Sy9haVJtc0RTK1AxVk53N0VkQ0tNTktJVGpVWXNMWkVqcDdTbGVsQXlCZ3FicEUzYVp6V2U4UGVneVRXU1d2UHM3ejczTVo3Q0ZLL1o5TlZYanFkdFladTA4UnpBV2JOLzk3bG0vKzV6S0JVYTNxUHpHVDJYdDJyZTc3ak9Xd09XYmhDWndReEJjNW1MVVZPcDhSSVVoZHBucVpaMGsydU5GWUtpS0xZMFFnRU9oS3N3MmVUNlZlc3lSNndibzlhSFpCbzFHcy9nbjlNZ3BjYlM2aHpVV2xpUEQ1WDM5TkFPTmJ3QTZONHYvdm0yZTJrRk03TFU3b3QwYnRoa0wzRFNBUDZjVFhQOTExamZqOGFvVmNjWVc0NGUwaCtDbmR3TGFvenFiYjRYZTJ1VyszVURIMXVyeHFjWUxQdWExaWZWNkRhbFpaeUxJV3lQcXFFRzhsdnZVV1VSc1BONDVLQUcwekZmUWRuTy9QdmtvRUhEclN0NWt4b044a2JEMVI3SytySnhyQnhIaldleC84a1k2R2VadEg2bnNhd1NlN0JVWEt6YnFzOUt0QjZsUXcvM281NVpnZ2hKbHhHK1J2MHFBYVRTUjAybEdSdjNIbzM1QkYxVmR0REkyS05wcnJjTi8zM3FoakRTNjRFOEJ6QytmZXowOHdnbFNNMmF4dU1tMTN3ZW9Jd0k1em9STEI3NjNNWjZiT3czYS9tbWRMTnVUR0JHQlUwcnlyWkFlZmJZcmlCSGZQR2NNNlVvei9GNG11dGU4NWxLTDRZd0hlaXE4Z3VoRjF3djBoUFcxanpwNGVjTDJONjU2bk9XSWxQOEhnV3dFKzNEay9IelBsbHo3ZjErUGRlZ0FIKzdudC94bVo2ZkllZWpwcndBQUNBQVNVUkJWUDhuajJ0eXZYQUZmMG5iT0FjTG9lSGFCNVladVhEek1aNXluRTFPazZ2MXBYVmRlVzdIVFZtSHZMTUZnNlNDQWg5b2t6bXY4UTNsRlhSK3JkcGdwcm1HNk1hTmE5ZGhZT1pab256TzJxZ0xtQjJCanVzbkFCNDZyNkV0NGt6NjlOaWZjOVF4eGdXeURlQm9tdXZJS28vVDFPQ2JndHZVV2JyNEY2OUxQTGJKOVU3Wkp1aTJIN0l4OHdQTFV6MUUxcCtTL2MzSFJOb0RsRTYyUU9ZMU9uYnlLd0xvczZuVjJsM0Exb01CQXFrdndzOFhrSXdaVGE3OTNqVWZWNUNERHJyNHVRS1l0YlZVbWsxK1Rwbys4ajd6TE84cXZkR0hDRDludVRadDFJOVZ2cU9EV3p6RDBZaS9DdmZIcG5zdVppZmhPVlErUU5rMjB2RUl0ZzVReWlLcDdxL3plNllDSHlITEdxUEdhcHFUbjFNZnA1MGhPYy81TTJ0N25YSlhxak01emNBOGFjbVp6STBDdmFRblM1Unp4ZmNPaFg0UVJPWGNrSDhrMlE3bC9nYThMbVpGNXRiN0NKNVFYNmhsOHVGOExIemVkMzNPaGhYNnBrQnd3ZDh2MHA2RVg4Z2F6R0EwdEFCL2UzUzhkUzNXRGszbEw4THpXWmRVUWFxV1ExbnRmRzdiZ3A1SGh3SHEzb1ZkVFBxOEErUG5MWHRFVjJzeXdQYUI4L0ZLWDdwMFZ3VVkrL1J6UFR0UCtsNitXODlmZXIvWVpBakVKMUEyN2h1VWNuNVhvdzRYczdHb1F3aWRTN2VTZjdlNU50N1RaSWVremlaMGdiUjF6czhyWjJNUTNzV2ZhQXVKamZ4OElYUGRrZ0dGaHRaazN0NDVhWEk5KzFFWExSSDlxYWFmQTIzYXo1WXlWRkVuSDhQQXRjZVRPL2QrVXJtQm9CU1orUTRNclBwTFpLQ042RG1Cc2dTME9wZzNkMENSQU8ySlJCeWYrWFV6V0VyZ3I4RFM5TzZnSFpVSm1KRDZPZ3hJWlRyWkdReUVmaE9XanBpS0JOK25LVysrREt0WlNvSHh0ano3NXpCUThtMWtwajN2aUpCZUFJaTFpRmY4N2VBYU44VUxNTEQ1Rk1CM1lkR3FFKy9MM3dMd2ZaandPV2JLWmFicmxWVFI5RlEvUms0L3RuSHp2cTBrYXZROFJMUytoTHhwWG9hQmRRUVZLUURUODEwVjlkZVJQUkcrQy9NQzNVVTJIaXlSVXhTelBZOGNuWHJOM3pYeVBzMjlUKy9CMXVucmE0WjI0cy80TG13ZlhJTXBPVlRBR0xuNkZiUUYzL3V3ZmJ6dUhic3c1NGJvREtEcCsxYitQNTBJbU1MNkpkaWFNYko4REFQSE9ZZmZRMWJJenZ6K1l3RC9PMncvcndDOEhsTTUrenM1eHlld00vazhERmgrNEhPd3p0djJxMnUrMS9ZY1NyQ1hkWDF2K3J0LzF6K25jVkVOdUFNNGlQVXgrUHZSYXhReSs3NUhabnhicjU4dzd5Nm1GSy90VElNeUZXOVk5RE5xVlRLTGVsbkNVTW1ZeVFzWVpVUmxqbzVNMGJoZk1IQVZ1SHI2UThWdjFlemZMWVMwWnY4dWF4UlZQVGc3akR3MDlnTFowNUR2SHlIWEltVGJiVEtvUTRXUG50YXNRY1d4YXRvcXpra1JCU2pHQ1hxRGp1VyttSktxVU02Yi9ic3JDbVdOMWUzaGQyb2tWS0dzOERqMis4aWZhZHlLcVRUSnJ6aWZ5amVqZ1RSNXhjbG5NYm92UnRMMFJjN3R3SlNseGRTOW1yYzhOMm5jY2UzZHdCdTliUm14dk5QczN6MlpaazlxUFRQa1VUdE42YzFJSXd2bEcwYStKekFRUVdHUXRaNzdPRmxyN0VKdG1yM1doeWlCSjAwZnVPdDdYZnU2MFp4T2N5UTYyNGZDZzNSZmNUMWtiWXIrUllOQzNEOXkzemF0Umx0b3BOVSthbXFub2s1eE9EZXhybVlDNWxBQlhQeGUxcnJUUmtOc3BEdTd6ZjdkMHpnWDhpdzIzc3U5ZzQ3clIrRjYzZGRkaGtWOWprYkZjczBpZU11enFkRysvTTJ6VmhnY2tVRS8zbGNZbjUwdXh6Wm9ER0FsZ0xiVFdHUXI2Umo1amFiSjFVWXdNVVhENkh6NGZIWEpqNlFmUTVoekJ2V3RzNm5WejZPeksrZGJRZkJCWTNXb2xMNHF6ZWZuYW5qbG5DOGhVWC9JRHNsRHVaZjNhMmFKcGZmeERHVnFleUJINDNCUG5xQUVUN2krMTVENUIra1U3NzJKbkFuakJIay83RTVEYlRpZjE1bklWTG91S24vUUVLTjdWZWVNZGFiMHJDMkFWQ2VRaHZnbFRObm5PK2o5VGEvMlJBT0VudWg4ck5BMkJpblBHSkwrVHkxaVJ6T0NNT0p6SWZjTm1seExXdmt3ZVJIQjdxWE1OM21PNmhSYUdpbktwWXpFaWpwN0Z6OW5WRVNObjZjTUxON3ZKOHBJMENIZjFkNUxjQ3RsUktud2M4cUFlbTZHemY1ZGpTaWpiSnVjS2pya2g1UTFwdG0vTzRuN2Rzc3hrcCt6TmpEN2tveldUcnZZU0h1MzRlZjYwWVdqcVordzhad3NtekpxVFFGQ25yZVVGUWlWL1RZdEhmdzJiUzI5Z1B3aThNd2lxNDdLV2lySFE2THcvRmxITVBCM0FqY1loajZ2L0x4SHcrd01PUjA4ZWRRQXdJMW0vKzZqYVhBODRMUGtmdG9TSHlPMFJrcGZJTXZ0R3JuRFJpZUV2a1pabmZSR0l6Nkh5THdBeURXZDFiaXNUa3RBS1J1b28weHNDb3JyMktqL2tKOWZsWEVwRDFUYXBmSUhaWEx5a1czNGVkS0JtaHhOZHU3OC9CdzVZbHo1RnVsNWRKaFYzcXVOY29EYUFSU3MzZlA5cExMak1GeExmWDQ4elZscUlOZFE5cUY4UFc5Q1pHVWpFZDBvWlhITlpCTWRwUWFvUkpUcnZJYTlHUTMwZEw1SzV4K2wzRGdXblRhQnpjaU9mWFRPS2FKaWtla0w2WTdLMmZyOFZoU2h6SWYyZStqNk9TT1BkYnhxUDFYWkpRRXQvTjFZalVvQ0k0eUFVejFEOXpYckhYY0JhNXFLbTYwRmV1aVo2TENacU82NkNueHkyOVpwRCt2ZzU5em5pN2dYbzJ3bDU0blhKUDdXNUFqTkpETjMyTXJTT1dzNnNpUnMyb1R1NmRsVm04NUsxeGw1clM0eXR4dkxBWmZkMXVqbnBFbUYzTXI3S3ZyNXN0bVNuM2ZKTUpVOTJuVmQ3N3o1OTR1K2Z2bDRTWnZVcm5uYTVFeFdJeGk5cW1ZMHFiVm1mZDNvQ1A0VzlnT2hLWDN2VUlBYThQTWhkS1ZseDVWbnF3N0tkZFo1V3FKRFIwREhQaGNhdC9KK3FONnN6cmk5cldkZjFIUWNkWkJNemxYaEh2TE5FWURoRUxrdVg2MWRoVVZTVG1BQTArZVF3VmtLS0M4aWUyemRoS1YrL1lyVUhLVWl2NENCYmlPTk5wWmFwaitEZ1dOL2hRdzB4dlkrekpoNzAvdHhCRXN4eTZqVFA1SnJrd2VrZlBZQ3VpTm9QK1BqK3dKeXJlSkJCSCs5djRzMWFaalBZUUxzREFaKzdpQkhGSjlNN3R4N0h3WUUvM01BMy9abm5janpHVTE5RlRhdnJDdjdESzl4VUgxdEN5bWN4N0FvNnhkbmh3ZGs2RVBrS05OM1lJQmVGRjdQWUhOOEh3NWUrdHErQmt0UGZPSS9WMkh6ZGdiYkZ5L0RIQXcwQ25jWHRsYU1LS1UzMjFEMnhTa3MrdmFYMWd6dkJnem9KMmp6ZVJqWU93SXc4N1Y3Q09EZlZlN2RnYVZiN3FvcnpEYng5MHdjTE5lSWhUM1l1ZmdpZ1A4TXdOLzEvNzhNMjB1TXRKdjVlR2ZJcWFxL083bHo3N0h2QjNwYXpXREE3OFBKblh0TGorQXR6b0djcWF1dzFNKy9oUXdpZndaMk5wL3JHOURzOE9BbWdOOVlNMjV0R3VuTnVqay9oMFZmZncrMmQ5NUFkZ3g0QkV2UHp1ajcyY2ZnNzBlbk5lNVpGSVdCMm1jTzFqMUp1ZzhWOXBPSGQrMUNCUmlDUUtDdEFLU2pNS1lDaEFpK1ZjQ1dERkd1b1ZjdERmRUtQclk4TkxlYUJXdFJzR0RiQVhCbHkyZVM1KzZKWXFBR0REcmlNSlV1RFcxTVY4Vm5BRGw5cDJaa1lPUkc4aWF1N1EwUm5BbU1Sa0NKQmdVMUVQQitOUTVTS0ZtNklhcG1STkJHV3J3amM4REdOWnpBWklVYnZvZHIremg1dmN2dkk1aXdQUEp4a0Jmdm9LSjB5VFZhVDZ4em42OXB0ZFF0TFNFMk5LNVJLOW83S0lUY00rb2h2bXB5bEt3YVp5aGc3alQ3ZHhWb24wL04rNTFqV3l2SU5nWkk3RFU1OGpqS1lBbFFudWFvOFRuTThFWVBaRTFQdW0zOW1TVnNYai9RdEVWc05hVkdHcjlMeHB6S2ZhMjI3VGcydVo2MHZ0SS9vT3k3R2t0alc3Y3VBNVNSRFR6bkduRkJZK2VlN3oxVjVPSTR1RS9KTzRieW14N3JPc2VBMGZJWVZjQjl1dE56YmlQd3pPZEd6K29sUEJzQ0xFcVMyVnVVVnRLd3RacGFkTkNwbjYzaVBQbi9jVTVwaktXaktZSGd3bURwWjQ1MGkxSDlUSTE4N3VmNGZGcW1WQ3g0WElYbnFkNmhORGhGcWlEelRxWmpwSUVvL2owSTE3RlVDdGVHUU91cFhNLzU1Wm92NURNNmRQRTltdWJ6R2twbkw2Qk1jei94L1g5RzJjRHBCYk02OFI0Q1dhUkJDNWRwcnNsNm5Qcm5NWHNRZkk1cSswajNzUUxkYWl4V3NPemMrOFdTUlVsMlFsbUxHSEs5Z3Q4TDNlZlNKKzRyQUdXTkt6R3lLSzhZeTlua09ySitNdGZwR0FKUVYrYUE3MHo3b2ltOTZwTlRpUDljcWZGejcwZk4wZkFjWWp5WGZUeEVQejlYMlhWdFZHS3RSUmwxaTlaSisxRUNJNFZ4RXVVKzBQbWdBWEJIYVp6UDRSbnl1VnpiVjZjcjVPZFI5bUwvVXVTUTc0c0ZNajhIU2xCa01OME9YS2Q4Y0Q2OXhMVGVtN1FtQTJRRXBOaTRWbXJrTzNVYUMvbnVJakpocTYweERPci9VVDVMd0tYUWRrMWZIeHVkWWJ2ZXhRalZhMklNSjAxZnlzOFF3TzJtek81VE8zdDAvbGo2ZFl5RUlXMVZaNUNValNEd2N3S2xWMzEveG93ZnVsYTB2WkNuQWs2LzVaYVYwL0lkWk1lZUdVcmFUR0IzNVh4OFRob1Y1cXhXNTFuSGxzQlYvNDduKzBxemYvZFdzMy8zQmpLL1hVay9qcjFmODJrSFA2LzlqOHdUS2RNeEE0OW1oaUkvNTFtamJFUGJMZThsNytGMXh5anBpZXJXa1c0bHh5Qy9WbzN5bEp0U0ZHdVRuWHlCMHBGTi8yN3BUTlQ1NVhNQzJkeUwxSWY0Zk9wTEJMcldOZTFUZExiV3huMm51Z21kenlKTjQzT0c0VjdWZzJMS1pPVVBhdi9RY2g0NnQ3dzI2WkR5YkUzbHpmM1FCOWFwM2c5a0FJUjlJRTFndE50dWpVLzI4UE16dFBtNXBnSnZOYkZGSkV6aUlqYWNEaDFwWGF1TklmWXRBaytGcmFqU2YrNVY4dk9oOUkreUh0QXhIK0g5NlJuOE8xd1NiUWJjanp4SHNWOWI2ZGxUajBUL2lPbm5TbjhIQUxyc1I5WDJRWTJqWmlPbzJYRzFYMnYyUGZYemd1ZFB5K3c2UTVodVB0bndERlhCMzloUG9RR3RaM3EvMTBXMXEvMUFuMUdWNy9rekxTUGRlWCtSNGF4UDN1cjRUbWxneW80SWNacWdiQkxzR3d0NDZ1a0w3aUhLQnJTYnRNN3pOR2VkT2FjbjFJMmVod0VHREw0QkE3VmVob0Z1VEFONTVQKy9CWXVvdmVXZjAwT2JDdmdqbUxBQ2lUN2RBZkRMc0lqQ0dYSks2TmY5dlJISXVnMFRLZ0NiMkJOa3IrNDVnSC9yL1hnSkJqTCtrekMydnMzS2lNamZnUUZyZndiZ203UERneU1ZNEx2UXZxOXBBMlRqK1o3MzU0RytmM0xuM2hHc3ppdi9aNFF1TnduL1BvZk43OS96Wi8wdjhHaFNCNG5QMXZYSndkN1BlejlZZjVmak9mZUkyL0hrenIxekFHZXp3d1BPOGRDZnZaQm5wVFMrZnUrYnNIVjREZ2Fjai93ZG40YlZqSTBwbHEvQW5BcEdBRjZjM0xuM2xqZ0xzRDJQZWdTNHRoTi8xdWY5NXp1d1BYY0cyNnVQWjRjSGZPYWZ3QndMZnMzL2Y4bjcreW5ZdXZTMXozbC8zb0d0eGJPd3ZmdytUR242SGVROXh2cTRWMkVBNk5MZjh6NXNmejVHQnFaak80ZlZCajdlWUkrOUNPQWZ3WXhhMzRMTkpkT2RYd1B3V1FkNTM1emN1WGVmTnptQS9USnlaUEs3TU1lTFgwTzluY0FBL2g4aE8xLzhITFkvajJFT0NTL0M1dmNxc3NQQ0QySG43eUUrQm44L3FxMFE4bFVaYU53amFoTUdKSXBUOVg5a1dwWVVGZlFMNmRxL21yR3dwaVRFcHFtVXE1N3k4bThDQmVMektTeUowREZzekVQdUlnSmVBcSs4MzJxY25jTm8yYlZtLys3UkZzOVdQc0huc1daeE5PaEZaVW8vSnowaWlMa0kxdy9rczJoZ1lrUUdEZVh3OFkwcTk5WFdQaGtBa0lVamplYXEwVW9hdFBtc09UeUtpUUpaazZPS0NxTWIrelhOYVpOYWpselRITTNJLzVmTi90M2pMZGVsS3NqNmMybDRibzJ0Nnl4VkROMUpHVzNNUzUvelFVL2pOSGUrWnluUXh1am9tcWNyeDFCNDl2dHpWbkkvYTRsMk5sSGlnVklBM2hQamFNM3dySXBOTWxKc2FTaUczL05SNEQrRkFVZjZwTCtIemY3ZFpMUU5CckduMHNTZ1hhWDNjaFlHVGZZbTE3SG9zd2F4ejJLWVNNQ1QzMHVqRVBjWmplYThMdTA3VktMaHBYOHBRcTdKS2Nwb1lFcG5jSnFqc0FwSGgyRFFWK1BRY0pwcko2b0REWnNhYWFPeXh0cXZLNWpIN1hCcTllYVlVaGZ3R29OeC9wRHJqMnQvOS95TUV3U2pvWlBuWmlDLytYek9KZXZQallUZW5Ta05rZmZ2K3RqbjhpNGdSN2hxRkJBTnVXb2s1WnB3ckh2SXdLTTI5a3NkVTJKa2k5SWlHbjlwVUI3S3VwOGdPNUJ3L2hUbzFEa2lUK0I3YVhSWHZrTkhGNDJHVXg3QmEzWWJpMWhpNWlFZzg3Z3JjSWZlUU9kYUVScmhSOWRSKzgvNVVGcXJjNTZNa2szMjFJLzhHN3pmK3hDelAyZ0VBT2RkKzgxbkx1UjVTNkNWRGk2ZElmay8xUjlEYU1JZnpwQUJlUnJQdFYrYStXRW85eWY2UXVOK2ZFZVFjZGRGeE9rNGREeWRyWGFXbnFRSlQ0OXBJTFZQQ3F3bDNoME0vN0UvZWhZWVljd3NEd3RJMW9DdUZ1aG5TZ1haN04rOU1zMjFlR21QNFQzUlNNazFIQVNBZEtOMkFRTjgwUzVwdlFoZ0FCNnA1My9UVUQ2SHBlUmRUVDA3emRTaStTN3FFTEJSYXlURFM4ZDdPTjgwVEdycTJwZ3BpWFJXNWZwZG9Jam9teUU3Mm94ZGQ2UmprTXIyM0FOWFlhbW5XNkNJdnovU3FBa3k0Szh5S3lNdkMxb2h1c01WaU5PcjhITTZMTTFnOWdtZUUwWUgxdVp1Z3V6SWYrcjluUHRZSnpEK1g0MmFid3c0amxIZ3JBZlArOGNvNndzQ3BkTVA1US9PNDU3TXdUa2tnMFBnNXp0QXlyckFHdTZKUmpZbE1NNW5zWDlLZnhrMWRBVWxYZUU1NVBxUTN3TkIzMFVKaUtaM1V2ZVFmcDhEcWJZbDk0Qm1FK0d6OURrMUhhTUF6WlJtZEp3THloQ1VsN1JSenhrMEhuM01ML1FkNFo0b3d5UzVsLzBYdmxUVDlUVHp3d2psR05QZWtQdXFvQWxLZlZyN1RUbFIrMW16dHdBbHoyVi8xdW5uakVSblg2SmpvMFpKUnFCeklQeThwVjlPSzFreElMSktUOU54cnVYcGw4alBxUWNNS3ArelVaY3ZuUFE2WkNzMjVlZmpadit1MW0ybGJMQXVjbEx0WHVvY3BISnI1TjAxZms3NTQ4TFJ4aDlHQytQdjBzOExtOTBHdE9UUys5Z0hRRUxvbmRpL09yR3VOWDFPK3Bqek4vQi9sUHROOVpoT21iRml0MUlubmE0K0ZmSmR2TS9YSVdaUW8wT1l0a1JMS3M4cmJCNXlSa2NJL0NMY205NnRud1g5UytkSiswSjZSaDVMUjNCTjU5OHAzeXB0bFArTHdDbGsybnNxZHRDV3JjYS8yeG5EQUswdVZQMFl1ZjdVV3dEK1hMNTdBUVlBUFFNRGxZNWdBTlk3TUZCcGQzWjRjQXZacUR5SEFXbnoyZUhCajJEZzdCZ0dRbzFnNlhnQmk1VDhJVElUWmxUcFkvLzgrekJRNmxkaGdQQkRHSkQzdHFkUS9vRURxZGRnRVl1YTRwZDFXZGUxUFFDL0RZdmsvQnNBYjg0T0Q5NEE4R2dUTUd0eTU5NXlkbmhBd2ZySE1CRHhOd0hjOTFUQ1hVUlNqU3RVVWluTU1xWFdKMkZnM0M0TVpMMDFPeno0S1lBZjFxS1NIZlI3enAveFhRQnZ4ZmM3K0x6MGE0R2NYbmcrT3p4NFRIRGF4ejZZSFI1b3l1dUY5K2Q5QUQrVU5OUHZ3S0xCNFgzOWtyenlLN0Q5MUFMVnZROTBNT2hyc1M3YTErVHZMd1A0Yi8wWlN3ZmJqMmFIQjM4TTREK0VBYlVFbUlld2ZmWDV5anYrQWxuNDIvSHhQQXZiNjg4Z0MvQ0FLUWZmaHUzSDk1QWozcDlERnRyZjZocVhSd0hYNmhHbjV2VzRBVHR2MzRlZGlVZCszMjNZZm1CYTdKZjhuaU1BMzRCRlU4K1EwNUUvOG11UFlWRzhYSjgvZ2RYcFppcW5NOWt2OUh4bGY4NzlYZS9BMW9NQ3d6c3dZUDNqdE0rWDBDNVRHSldtQ2dYL0w0eEpLQldwbHVBZ3pMZFQ2SnVXZGZPMkFUWDZqRFJGclZ6dFg1L2cwOUUvR2owVk1CekRQRXc1cmlpMFVEanFVcGppT3lqWUQ0RGtyYTc5WkEydVhaam4xbmtZQ3hYQWVXWCsxQkNYQkJ2a2pBdzB5S2lCV1kyc2FwQlFVT0ZNbnI5QzI4aXNnc281MnNyS0NCYjlscnpBVmJtUnNhWDBneWlqditpYzFnV1M2cm94SXZXYUd6a2V1MEhtdmh0Z1ZEbmNneWxMajljWkVsV1oyZUQ4Y1Y2andhUDIzSm9odkRBc2hEWVVZMjFOMFk5ekdyK2ZJeXVnZEVwYk9sQ1RvakZSN2hIdWVZNkpnaVRuZ1lBTCt4K05oNk9wZyt3VW1zUHplVjloM0JFQmVqVE5LYlRYeVFKUHJYVVprYlpwc25lNjlqSU5jaHZSZUZXSW5zUVlMb0FYMXlXQnZjZ1IvVXBuMmVlRkc2MTJVS2FnNHo3VmZjd29la1pWTHZ3NU5PeXA0ZzJVdkVlTjdMMU4rbGVqandqL0wyUmYwdWhCMEgzaFJ1Sm8zRXRHUUpSUlNNbVJvOG0xRnNsTGFQUURTc0FQcVBCTm5XTnBNZUlzZ3I1cXFOaVY3M1M4U1Fsc2NvMitWYk4vZDlaRmM0UXZEdVN6dWRCK0d1QzFicVEyelRpaCs1L2dNdWRXeDhtMHNRUUMrWnYwdXdiT0xvRlVpMDhOM01vL05Pb1lLQUZvWForYktIbGZyVEhhZGdmWjJTcWV3U1ZNTGo0RkRBUkdhVmdtSDF6STUycUlZa3JsQVJ4Z2dOY3A5cy9aZC9MK1lXUHAwcG1HZGludllqcFdqZUtodk1RMVpMUVg1UTVHWWl0ZjRmeWxsTkMrM3drK3NQL2NnNmNvYXlxVHZ0ZFN5VUw2RFovL1laUFRvcktjd3JHdnM0SXRJNysyVm1ld2FCZWdsZEVvMVdlRUs1b2FoU3JmclpYblpWNWExNFhuTXBKYjVUUEtpMG9MU0s5SXM1Yk8remxPbnN2a0RCYmtpdkUwcC9yV0dvQnNLdU94Y2QrTTlIa3VtM1hLSzAreitkeVFUandwK0x5bzdHZEd2S054RUwvbmZ2WnBEQU9MTytueEpzMmZRNUR1RkpuK0pGQlA2RFRMejZSNjRiQW8wNW4zOFlyL2Z6NTk5WldIOHB3OS81c1JXMmZ5K1RYWTJkWDlRWDdGdmRmSnp5dDBnYlM0ajU4RG1TNFNlQjdCYUFTTm9WZGhldGNjMmY0M1FFNHpUMk1zamNLcTUzQ2ZxSTZvc3YwU3BrOTBudmZRWndYMG1JMWpnYXlEQVprLzFKeG15UFBIM2tjNldxR3hFakRLaDlWSXo3N3Fma3hHYytFRjU1RDA0T0ZhdnAvendpaDhUUzJxZXVndWN1a0ZqZ2VRYkQ0K2IxSFBJazNUdWFZc29EUXR5ajlSN3RFeU1sMU41WlN1Um40Njl6N1RuczE5cmpJRTk3anFPZWN5TG80ak9lRDQvTkZ4a1JrMXpnWE1vYlBhVU42YjVIWWEvcWZaeVlEUnorcVVFdTA1bEFIU09qc3ZpTG9rNWJjWUpWOTE2UEpuVWo5UElIR1RIZE1BbzBQenFaY01DWHQyNUhOUWxIL3BlTS9HL0Z6bUVjajJqTTduVjJ4ZFQ4VFBhOCtzZlM2MklpMlJvZnRMNTUrZ0VmbDVQTnNGT05Tam4zZnk0Y0RQK2Q2aWY5TVBPQXRIYkJWNzFNWXRyRW1YZms3OWJ0UCtrTzQrY1hrSzUrbDA0dEd6dW5iUGhUWG51aTNEYzRxNUV4MVVuVlYwRCtnN2grRzdUVnFuSE0ybTQycXlyVFE1eFRmWmNaeTZIZmxFTE4zRDk3V2VyL2EwTUkrazUxMTdxYkJmU1QvVkVVZDVKTzhCU29CYTdlemFYOUx2TG51VDZ1UEYyWjFtd0hjdVp6UHQzMW9id3dERm4zWjh6OVMrTC9vUFlNTHRqMkJBMkhPd2lOOHZ3NGc3b3cwWkRUaUdBVkhYVUc4ckdDZ0plY2Q5NUhURWdBRnRyL3ZuUDRORklGNkZnV25YNE9Ib0FNNW5od2VQWUJQMEFtd0IzNFdCWkt5UDlVTVlTSFlkbXhtV2JpR0RrZTlzQTJaSlBWdk8xL00rM2l1enc0UGprSnFaOXl4bmh3ZHpBQ3NIWFdjK3ZyOUJuc3RieU43ckw4UEExTi95ZC8wM3lGSFVQSnlmOVhuNEtlcHB0Zm51aGFSZ3BrZkNxUUM5L0wzMGR3MDd4ckR5TVdqS21QZVJEUkc4NTFrQWYzdDJlUEF6MkhvOEMwOFJEbHVqWTdUYlF4L2ZDMmpYOUkzdFdmWmhkbmhBUmU4RjJIcCtEK1ljY0JVMkwzOEdtK01YWVdDOU9nazhRZ2JFZDlDdWFjejJ0ditlSTljaGZzdC9IaUlyRUZzeGhERFAzTFBmUjE0anBtNWR3dWI1Njk2WEdleGNYSUhOMVczazJtS3YrN1V2K1p3b09NK0k2Rk5ZWGVaMVRQVTJiTDRXUHRhZm9nU05QMjVQMko1VWlHQVRaa0ZCSURGQUZ5Q1QwaDZZandJNGFoQXM2a3R0MGxmZVd6RVlSOFpmTmFwcFAwSkwwYmw4VHdlRGJ6VlJ6dmpSeXZ1b1hwc2FaUVFJQSs4eTFJVkdKVmFGZ3dXeUlFMlFiaGVtSENvZ3FpbTJOT3BLQlFxTnB1SjFOUHhTd1YzQ0JQOWpXVU9PbDcrWE1NL3N2bk5mUkh6NSswWStEMVJ5ZDJHQ2E2d1JPK0I4cVdIWkRVbDh0aXI0NnhxRjdTdklEalEzNFViaWFkc3puMmxQTHd5YzFacVA1eFRadUxqeDgxM0kzL1c1U3JVUG80Q25odGdtUjZhdmRKODNaVm9kcHY4R1NuNE1aRU9HQ3J1NmZ4YVZNN29JdjVuS2hvWUlBb1owb0tCeXp6cFJWRkozZkR3VDVEV08vSHhycFhLTkVlNmlqZlBCK2xpWFFvdHJiWXUrYXlUbWt6U1ZnV3ZPUUMzbG9TbWpnRlVaNnVxTFJqT2o0MXBWTXVOMTBRaENJMjAwMEJRQWgzK3M5OVJxdktuakEybFhpb3dRWlpqOVUwY0kvc1RJbmpITSs3WVdpVGhYSTFUSGZ0Vm9xeFJwSkVaVzBuOEZFd2tpY3V6SnlVT2VxeEdVdkk1OFJyTW9KZHBmTSt5SXdaOWpKcjg2bXdaZzFvM0ozQ2VNNUthVHdSVmtmc3ExMUdnZnBuM21HczVoY2k3cm1pVTY2WTE5NVppNUh0U2g0SE5IbXFOeUJLUDJ6cERYc05xbTJabm11b0FVYzdrbjhYTC9YeDJhK0M2K2o1RmZYQk1GeXpYeWxjRDRHTDQrWWhTbVhySFg3Titkb1UwWDZNaWhVWExSR0VnUWdvMGdCUUVCVGVsTWozVmV4M3NwMTFEZTRQb29QKzhDTkpYUDhabDBIaU9mNExVUm5GK2dRZytldElreGhXdXk4VHVjVm8xZHpsa2JVU3VBVXcwYzE3WFV5RFN1UnpKWU5UbjZrK2U3TUc0S3JTRzlLLzZIbmEyVVN0T044SFRFMEhxQzVPZEtVNWttbDg4aytNL24xMmpKT2wyaHp5bnVvbzNnQ1VITUp3RmNlL252dXJXWFo5RGVRR0Rwb2kybHAwZDVucE9qRXcyZi9qbEJzak1Jd0NjQVVlSEU2UHVSY25XVUY4Z2JsekNhUzZCZCtUR0JhVFhzQWgzODNIa2U3MWRqOHdEWjhZVE9OUVN0OVpuVVJVYXc5T09wdmlPZk04M1JyWFJLMGpXam8yUUMwOE44TEdRK3FycG0xRCtjZHArS0xIeU12RDVNRTZteUJoMk50UFRZQUZsT0tOWkI1b1RyU2tDL0ZvVzVRdHZaYVFkR3U4NlUvNHQrUXo2MXgvbnpTN1NjQW5tKzZwL2t3OXhYbEIwb0IwWDZFR2tUYVhFYUswb0hPMzZtOTdBZm5VN3FvdnRIV1ZqbFVZMis1bytDRUtURHpKNVZBSG5obGVwRW9QM2l2S3BzR3RlR2NsOU5Od05RZ0x2eHZUb1BSU3JTUUFQVnVWM0hxeG1tdUlicitLSEs0V00vUitvUTErazQrSlQwTEhWaTN2ajV2bzRqbjZ1Titma0d6KzNLSWtSK251UXdieXJiS3BDbllFKzBveVVueDhZREMrQzEyWjBYVUg2TSt2bkErYm1lTVQ2WHNzZUgzb1NQZkJENithYlBUcW5xc1NZQ3U2ODFaUmtTWFZPT3Q0dHYwaVpVb3o5Rld3TXlMdVZIYVo3U21JM2xsV2tJWGxFOVV2VVIrYnNJRGdqeWNKUS9JTmVBL1F4bklUMm5kbGI4Lzk2OTNXRzNYdXIzWXRmaytSNGhaMW9oN1dUcDNXUjdDT1BoZFZ2WjJ5djdJZEhyeXY2ZER6eFY3Tm5renIxV0NoT1B4bVFFS3FOdGoySFJsamRob0NaZ0FOSzdNS0R6Rmd5WWpCR2FzWjNCUUxodndRQzVKUXhZbThBaUtDbWNVdWlod1p2Szl0Y0FUR0dDeGMzdzdITllHdUMvOU9kOEZRWWsvNlZmeTVvTXoyRk52VlJZS3Q5M0FQeHJXTzNidE5pZXdub2VJbVNMNXFEcUVBWldYNFBORGRQd3p2eloveGNNcUU0TW9GSjcrRFlNekdYL3Y0NTIzWmIvSHRuejhSbllXdDJBMTJIMWVabHZrREk2QWJVZFk5cmhjN3VlNWVtcGIvdS81N0RJV3dyalRHMjlBdkF2WVh2bEdBYTJqbUZBN0NkaGdQQ3Z3V3JiQXNDL2dkWEkvUldzMzJQL2c3L3I2MmluT0g0UEJsWXlpdll0Mkh6ZDlQZi91dmY5eitUNksvNmNydFRVMzRRQnJ5ZXdjM0Rtejd2dTcyQzZkS3dEUjMzUDNJRHQwU3YrM0dXSWxDNDg2bUQ3K0xNdzhQd1JESWlkK045ZlFhNlovWE40cW1sLzloZDlYTS80cy80bkgyOHYrT3Z2L3lLTUJud2FSaHUrQStCZGo3ait1SDJBVFpuYkp0ZDJNTnhrY08xU01QeTZQcWF5N3QxSk1Mcmd2UW80NlAwcUtDWG1YbFBLZTU2dlFvNGFzcWcwUllDaEpyeDNQVnVGUXZLME03aW5iNjJmTGdEUk9FK0ZsOFlWL01RcmFnQUFJQUJKUkVGVUdvdW9VRExhZHdEZ3lFRkNmczc3aitHRzFVYWlpOVNvNzlmUitOSlNabVNPRmtHNDR0cFE4R0hxMUJNeCtyY013VDR2Qy9sZmVmN3BOSGc5SW51NzB2T1A2NU9BaTJiLzd1M3BxNis4MzdjZUgwVGJkTzhwS0FxSnNKTHZXZzRid2ZqSXM2Qnp0MEtPbkVKanRVQ0J2SCtqUi84Y1c1eEo2VE1OTjlGNHdmZG81SnRHeENnd3BJNWhlbzdYT1NKb2Y5UTQvc1NldCtIWmpHQjZJbU4wczZXbmNzLzVVNERxd21NVndLQUY5cWxpUFMzVEZ6STlIeU9RVjRGdTBudDFiV3J3d0hjWUxRSVpIK1ZFR2lHMHhqYWpUMXB6S1VZd2prRU5XdHlubXFJdUFUd1ZwVnZ2cVVaY055SHQ3aGFHL3lGa2Z1VzdWRk1YN1pwK0kxRXlDZklTU05Teno3Vll3dll1d1RUbFA0eTJUUWJ3NmF1dnpHandndkRCam5HUGtYV1FPWExhcVJvdmkrdDlGWmwyRUFpbVlUQVo3RGxtWk9NNERhZG5mRjk0ejhUdmp4a3dhT2dpWDJKcWFpcnBHcFU4bjc3Nnl1TTRYaDBMckJaa0JET1lybFRUR1hNUHBTaGVmNzZDYlJwSlJ5T3lScWt6cGZRRVl0QnZERVJmVGkyU1pvd3lzbkVnNys3ajUrVFY4OENuTmJxcE1Qb0tUeG5LOHdrR1RtQjBtM3YwQ3JLY2RqWXRnZWdVcVNSek1haGNGNTNJUHBTMnBTd1pvN0NxeitsNlpqQWlFZFRWS0MrdXRUYVY0YllDeHNQZUk5RFBPV2NxZUVaWmFLUzlHdFRWV1ZFLzQ5N1pocDlQd24yWHdzOTl6ekpGZnlzTi81YlAyZ1hXQTczQ2owWUkvTnI3US92VkNpYTdYMGpPOEQzQlBoMkY3M2lPazVPaDBQbVVNVUZBQURxcmN1MTdTOU9vL3VsLzMwQklXZXp2T1JMNWdjN3BkTDZwUnYyRitZdlptSmpoaHc0eVFKWjlHUzJrKzVGeTZ5azZvbXlFamcyd1laM3BOZnljZXNyUW42ZXBlSldmMDRHQ1o0KzgrVXcrSndENFFONUxtWXNPYkhSeVdrNWZmZVVrekVFVkRKWis4bXpRR2F5NjVoVitUanBQQnhIS0dZbGZDOTlTZVlsdFh0djNUUzQ5Y0M3M2NDMzViQVVsZ01EN3VwNGQzcE9BVU5HdGRGNFYvQUJrbllMdXlqT3VhYlpqclhxMUtjemwvbDA0dUN0ckJwUjZrem9IMU5LYjhweFhJLzFRT3RXdE9ENFpOODh4MXlycTUxcnZmVDV0Nitla0FacjlJenFnN1c0aUkzK1VXcE1kUTFzNjhoWjZ2anFPY2krcC9xenlvanJJQUJmUTg3elBhc2ZpUHRyaldKRHB6QW9seU0renhUMm9mU3YyellaOVNicldwakxBbHMrK0RQMThZeHNxcjYvdEJXVGRiWWtMMkRuRHN5aEgxbWhqc29mMTljay8xejIzZGJTMDZBbEtZNm1EaytlVHg2MFFhRVBQK0dJcmJGMzhzR0lUcTk3VDg2NnRiQy82cm80MUpnM3RmSy9NT2ZYcmRJLy81dnEyZ04zd25KVDlRZWp5cGpTbmRhKzJNY3dvUEpMMHYvUkVtZ0Q0UFJnSWR3dTIrRCtBUmVGK0ZRWjR2WWtzZFAzRWYxN3cveitIMGxBVjI3OUVyc0c2Y25EcmtkZVlYUURBN1BEZ3pOTTZwK2IxYksvQ0FDdEdHc1cyQXdNTlB5T2Z2UXNEcVU1Z29OeW5ZRUFkVTB6em12ai92NE9CYURWQTdEYUFCNHphMWRUSWxUWUI4SitqckVsOEF6WmZRMWhVNWxYa09kWXhEOWtIR01oM0RXM3c5ejBZd01lRCtBNU15RDFDQm9VcFZQUVNTcG4vZ1FEWU5BZzhENnQ3K3d5QTM1OGRIcnlMU3AxWGoyWitEdzVtenc0UC9qbHNYai9oei9pRVg4cjZ1RE02SWN3T0QxNURUay84Tmd5Zy9JWmZmOFhuNFhXZmh5NUE5cCtpZS84OTZ6OHZBL2dmWlY0QTJ6c1B2WC9YZk15dmVUOXYrbjBybUlQQmJaOEh6dk1qNUhSQzNDdE15MHdBK01UdmJiWFo0Y0Z6ZnU4dDJQcmVoSjAvQ3VVL0NyZmNndTMvdDJBZ001L05PbWlmaE5YWTNvSHQ1WDhOcjZQbVRndVBZV21yZitEdldxQ1NJanowa2Z1TFNpTHJvTDN0ODFhdGhmTmh0TWdvTGhNVStDZzFGZHdSakVJMVJxSC9oKzk0empjeHRrV2xwb2owUUllZ0hQdTRwZEJWTTNoUklGV3YzUUljM3ZRZExuVFEwRWFGaDBhTUZQMjdqZUFyNzFkUFpRb0VOS1NsK2tJbzAzY3NHa3ZIU0lWZXg4Vy8xZE1lL3R4Smt5UGlJTDhURU9CalRRQ3J6STJtMUc0SkROTWNyUncvcDJEQ0tERXFxRlF1WTZvbktzeFJnQ0lRV1JQVW1BNkh6a00wNUMvOWM4N3hqUHRlaFdoZUJ6SDBJM2pQU3QrMlVnWnFiZE43cDNWUC9OaDIzU2hLVDN5dG4wVkFmSUl5RFk1NkQzUE9rdmMzc3FKM3luNm93YVd2LzlQc2Fha0dtWmhDS0hxN2oyQUdNZ0lJa085SUd6UWxHL3UzYWFQc2VxbHQyL1BlODV3YW1GdFRidEo4K0o2dXBXTG0rUzVvWGEzMTdHVWFDVnZSZ1hLZTlSNUdCZEtneStqdmxsTk1COWpFUFJEUE53MkVOTmdtQlhxYWdTV1Y1VlNXVldDVDcxZmpuL0pHUmpRbHBheWlhQzZCbEZLNDJOc28rWnMyVFFtOURWQ1ZETEpzbGJFT2FERHpzN25YZUozNEpxZkpPNU45ZzZtQnVHcjBqZU5UUUpuek5wTG5jUDdUM1BrNkp3TjlBQWw0TGRQSkQ1eHZudXUrMVRFaEEvQUVHZWpjeE91U25pSUdjdElzSU5maG5RVmpJc2U3aSt3QXkzVW4wS0YwWXVYdlpSU1pwdUlzbXN6eFZaUVppcGhCWlFiVFR5S2dUV0I4NXZjeXNsYzk2M20ya3hHdUtTTTZOVnNDWkQ2WWdwczFLY2xQVy93Y0ZUcmhjNnZYYzYwSU5OSXhnNFpMUnQ3dFZJeTRleEJqcjQ4bjlhOHlwU1BZWG9ITWhkWUJaMHVwZG9Nc3BYdWIwUllmT2ovM2EzdDVoaHJVR292TXFjMFBlYlVhak5qaVo1eUxZZzdFQUxRSlAxY0RGWTI4akhJblArZCtKSDFoeGdOTnNhbTBtUEp6ZFBUYXBLbE1meWxOenVuV2U2R2lTeFVwbm4zK0J0T1NuNDZSb3pkWHNMMmNuRGlRMTVmbmVhZkptVlE2KzRFSytPUFBTZGtuOURyaGEzb1BkYlpiN0Y5ak5kVjE3MUszYUVVek5SbHdub1g5enJXbUU4NFp4TEZEWkhMdUpRS0lPekFiU3VGY2doSVUwZnZteUprR2t1NFUrUGtDTnVkWFVZS2dYYnljODhMOXZpbW93SDdHT1NJZjRGd3ZYVGFxOFhNNlBaMktUbjgrelU1WkJGazE0aWpxWXlxemFIcHV6UWpDN0FiUkFTSWErSmtsYUFSYnUvU2V5djZrYzVYcUdHZnl2OHJ5dkZjQjNLSHJOK2RoTDVIV1VOZmpPK0k2YW4rUzg0dlQyVTZhSS9KV2Eyek9vOGROamtMbi91RStPNGV0SCtXaWhWelhpbkNWTlYzS3M3U2x0WjNtVWlrRlB5Y3RGajJnYU5NeWsxdnh1ZC9QdnBFMlJQMWNaWXd4MElyR25ldnpRcU4rb0JsQjVuQVpSSjZ6MVArRjc2amMzc3ZQL2I2blVScXQyanI0cy9aRm5ScmlIbFpnVVBWYzVXMGNCODlEeTBIQW43TU4yRm1iUis0UDJyVFVBWWc4blhLZDJrdjBuUEc4WGlUenlyWTYvZHAyaWZyNTJySElHUjdDNk9NS2JmMmNjeFJ0ZGhkcG5iSkFrUE9Uak92bmxqUTRaaDN0blA4dXVVTDJMcDJOVTdZbDZadmFtd1l3M2F6bGVCUGtlUFlIS0dsNjc5a1d1bDdvNXh2UWc2M1hvZU41UlhhYkptUTBGUDJIODBoNXJMQzFpb3l6VnRhRDJFeTRIbUlIb214VmMrNEZ5ajFDUFc0eGZmV1ZGVGNLMDJ0OUFSWjlPWUNCVmNjdzRSRCs5eGc1SXZOdEFIOE1VNTVmUS9iaXU0MHlYVWxYMHhxa0duR2FOa3dIbUxwQ0JuSzNhYy9Cd0xyM1lLRHJEYlNOTlV3QkJtU3Y2M04vWDQzSXZJc01GbGZUK3pyUUJnQy9nUXorem1IQU42T1BuL2VmcS83N1g4QUFSMGJiMHVCMkU5MkE1MDNZM0wrRFROQjNBUXdFMEVzYnBDdUZjNlh2SXhqNCtnMFk2SG9UQm80T2tFSEtvWVAxNS9GKzVIazdRVGEyWEVlTytPVjYzL1RQTUxsejc5UlRRNC85Mm0vQ0lscDVMNURUb25VMTdqK21qYTdOMncyWU04TmZldisrNnM5L0JrR1o5cisvRFFOYVg0VFZCLzRzREJBbW9ET0NnYTdIL3ZQWVAzOEp1UmJLNjdQRGd5NlFkUW1yUmZ5NnYvZTJ6ODkxSUFIRXAvN3NGV3dQZlJxMmp4YXd0WjhoZTQ2eVRqUWRPaGE2NXI0KzUrN0FjQVFEaGp2M2hEdGZqSkRublY3RzM0T25XLytvcEg0V0JwTVV5R2F6VkwyL2NJMkNnQWdBQXhWSXRuZ1VEZGpyN3FtbFdsRWhrZjhYMTBTQnhSdlR4U1lCdGV1bDRaMmFxaXdhNm9Gc1dOVC9xOENtR2dmamR5NHc5d29XWGQrSC9nRVM0WUlzaUxIbUQ0WHhZWk1CVHZqdkUyUWhZSVZzaEZWaitPazAxMWJiUlk2dzRuUE9FVURHcnJsK1FpT3BwaHJsMkxxRXVwcVNWRE5zc1ZHcFpHb2l0Z2l1TS9Vbi9POGJ5UHhIdmNqbmZoMXB2VGJPcnhyVDFub2FYbllUUlYvVDFZNzBlLytUUmx2dXNSTlkyaXFXditBUGtBMnl5WmdncjZUQ1NFTmtDeHhzTXJqSDkxSFJZWjhVWUtJUk9ZRlIwUmlBTFBpemZ5UDVYZlY4N1ZpREllcTA2WW1hSzFScmpRRGhublY3R1NpOStlTm5iRFRFd2Z2QWZidVJZaG43RVl6VU5Yb1hhWFlFYWx1R1lHVDVaNFVzRzlUNnhqMHdibkk2TWhxN2RwcWM3aGJJVGgwMC9xa2hieEMrQjhwYWQycElnbnpHZmxONTVQMERlSXJvc0M5MUxUbzkzdDJZVzNORTdXeHlqbXAwSnhxb2gwMk9HcGw1djZtUXorVjVUUHZQT2FVZWNONVVBSGx2ZEVSS0lGUlRsbHBRbzJiYWN6UllvMXdYbmJzUjhqb1hjdm8wMTdHbG5Ib09rNDNQL085ekdQMVJZOEVwc2dHY1BISHBjM01kd0xHUGowWmk4a1NXTk9GWllJM0tFMzkyaXJyeGE1WUFydnBjc2o0aXdiSHI2TmpYYmd4Yk9JQ2lLWk1Ic0ZxYUNtYlJ1V0R1NzJDOVc2Mzlld1daaCswaHB3eWpveE9qZGxOL2V2Wm5yeXk0UnVhaXM0NkNOZ3Z2UjNUcTRsNkIzME5EU1IvZHBIR0pQQ0RKNnRMVTZFU2JoWjVsSVBNaWdrMWQ4bW1Mbi9YMDdXazJkWmpjQk9Ua1BpR2RVWGxYWmVCaDRGT1VNM2Via1BLWU5FRm9nenBxcFRiMVNIZS9oMmRTKzZEenplY283VkJnS0VaSGRnSHpDU1M1ekRWcXl1d0RHMGVoMFhEbWM2aUFodmF0bG1hWklQbEtyaG5LdUJmTi90M0h5UHlyZDd4aU5GUkFoL3Q2R2VoQlM5K3E4SFBLdzl3WHBKMTB4bUZadGRpUEFjeEJmaGRHMzk3anM2YzUrOUIxWkxsZ0FLT1RsQ0hvUE1UdjZORER1YUlqamU1eDlwa1JzVFYrenZtSnRQQU1YZ3RZNXFLTFh0THBiR1A2NE9lbzVlVHFyUURXZkp6azNaUmp1UDdxUEVPYXorY2Z3NTN1ZS9nNXo5OWNlSnArVHA1RTJxejlLdEpTSXA5WjZxa2pmYTZNblE1TmRDQ25IWFVBeWRvb05oa2cyeWpWU0U3RCtDNXlEVnpXajZXc1ZKeFp2bGZHR25XQUZWeVhnWndQQVRWcWVudDZoc3NwbWwySXhuZlZlWGFiRFByTTRjNWJRWGZTQ004Q2NCYmVHczl2YXk5Tk05RGN4ODg3OTJ6WUUzUXk2d0pRQ2ptMHFUaTRoRVllWEpSVzRUTmtuSWwvKzc3ZlErWUxtc1plOWZOaVRDcTN5MmNmQlg2K1R0OERzbU1KUVY2bGczcHQ1SzE4RHgyMXE0N3lnVGVwN0E3QUhFVGxXdTV6SUsrZjBnQjExTnhJUCs5b2FpdTQxSFlSL2R6dlcyZlg2NG9hNVJ3bG1UTFlFTStiYnJsbTQzYkJlMG1EMlRmU1dNNU5uM01aN1k5RkJpK2g3NlJicEdHREpqdVVhZmFOMUJlaCtXbnRtd3hjOHZNSWpCYnlSc2M2MFZrMzZaNXI1bXZydWV6Wkg2MzlJREpmeXFaUXNhWEUvMXZPdDdGTnMyTmxmR2UwTFpQdkZzK3ZQRExwRDgzKzNZTDRuTU5Bc21zd1FKZmczQ2Y4TzlaQ1pmc0dESUQ2THJMbnlNS3YrWXhjTjRkRnRMNkVzZzdTZThnQTJVYk5vdytYSGxHNnMvYUdkdnNkV0ZyZkwzZy8zL1RQSDZJRVYzbFlqbUFiOUZScTN5Wmx5L3ZCdEw0cmo1amRnUUYzanlaMzdoR2tYc0VpT2QrQWdjOFBZS0RqcDJEcHM2L0NOdk1EMkZ4L1luWjRjTjhCdWwwWWc3d09TMmZjMWNiKy9adXdXc2M4SEtjZDEyL3FqVHNBOEVzd2tKRWd4V1AvVzlOczdzME9ENjdEUU1BYU1Fc0hnUWN3d1BEbnNIbjVCR3c5M3BvZEh1eE83dHc3QXdwdzhoRnNEZDVEVmxCL0Jrcy8vSHZoSFZ4SHdBeEVWL3ovbUNKYzIrZGc0UEpiTUFEMUNEWm45MzE4ejhOQTJWMll3OE0zWVVEdzB1OVJoWHppejNqWGdkRDU3UERneC83OVRYOXV3WXhENnZBWjdKeDkwdjkvNEgyZ284UVZaSTlhQ3Radis5OU00ZnpZbjNFREZ1Rk1adjBzN0F4K1AwNUFBT3BUdjFDbUxLQ2dkaXhuNFNFeUlIMnN6aHNmZGhPakhkdUhKUmgrWUcyZG9XL0QreTk2cnhxUHNjVnphQ1Jhd1FXR0xmdS82dmk3RU41VTZJaUMzUm9oY0pQK3NQN3dBSFZCUk9kMWlWSzRwakNwYWFFMGhhNm0vU3RBTmxHZWFCVFI3Mmpvb2hmMlUyazloZ2dhYWhtVlVBUGRvMEZRSTNYMU9pcjRxaEJSQU9UK0djci9LZ2d0WVBTSkVXQTBMTllpRVZPYnRqMnBhUmk5OEJtNVNHc3lnTTc5MEpWcU5ScGptYXFUZTRGWklZRHNyVDhITUE4QzkwcCtsdkxkQ0tib0VJUVl5SE5XUU4wcldmc25jN29URkFjcWgvb3VLZ05hSTVFQUJNK2w3dm5XR2JtTTF1VFVYeGVKUkVwMW1sR25EVFdEUVRRRTZMclNzTW45dmttazBGam1oc0FUR2t0NTF5VWJ4bWNRUUZhQUo4NXpZYnh1OXU5R29EK09jU1JyeGZNOGhza1RkSGprOTdyUDJEZ2ZDajd5T1RHNlNEM1pkYThONURxbTdEM1hmY1puaXVFc1BTZU03UnpBNkFsNEY0QkVkODZtcFRLc1FQR3l5V255b3hGeEVCVDNVNWl4ZUFmb3JKRjFqaUNUSXBjWklFMU52RWplVjBURGFGLzlFaHFPZHZ3TUtBQTZkeU03eDZRcHZ6a21ScFB3TXhyTUtLc3lIZktpMmI5N0JETXdzNVRNTWVwOG1NYkhSQ3VtOVZTRUhQY1Z2KzRoMnJSL0I1a2VVdmVsVXEvcFNPbXNvWkVXVEd1ZURGZE9GM2Y5M2lIS2RGODhFNHc0ckFHY1c3V2FnWXBqbWRaVG5wSTNVOWFvUmFZa0k0VHc5NXBYZWdLc2tQY2Q5MHNCR0tGOTFwWnlyenFFNkhYVmMxVVovMFdqV0M2anFReFlyWThiNUk4VXpRaWs2RXVORmtwR1d0TGRDbDluWFVyQXo1cXZoenBIcEZUY3RYblJkWmptV3RSN1RSbjFCZWtiVzNKQWtuMU5HWEhRR0xCYXlMRFNyOHRzaktUWGtnT2JOc29lQk5SajFFWGl5Y0w3dUY4cDUxUCtWMmNLT2kyZWRNbWovbDQ2ZGRQUmN3SkpzenZ0U1Zzdno0ajgvQXJxTnJqQ1Fhelp2enZVdFJOd2pLVm85aHFMc2gzQTdCYjNrZVZWMXFSZHlyT1ZUd09aRml6a04rMlNIT2ZNZjVJY0lubytRV1U2YmRJcFIvazVqZGN0UndpMCtRV2ozYmRwMWZOUzRlY0tvaTc4TE5NQnFwQXoxSWdiK0huMVhEai9pZXQ1Z3V4MHpQU3ZCWjJVT1lnUnE2cDNER0Y4bG1lYlBJSHpxZEhkQkFtVVoybW1GTkt5bFR5TEtjanA3REtZdnZyS3ZJTWZxU3lXemt6bC9DaE4ybkVaaUNVU3RDbVlOUWo3bkhzVmNrMlVMM21PeWM5SFRYYmE0ek81QnlnSHFMNms4dEhXcllPZlI5a3hqaGZzZjRVLzBpWXhEL2VzS3RjbGgxTGtlZVdjS1kvVy9hTDhuSTdxUE5kcG4vVHc4d1M2eVZoSHpacnNDVStqQ2E5ZUF2VjByZ0tpMGZhaytvckt6dFNUdTV6TmRUNktTTW80Sjc0UFU3VGlCdnc4UmJXamRDalhkVjJuYnlZYmp1NnA2WnJhcWhkdG9vZU0xbDBiN3FQOHgvbXN6WGNYb0wrUzcvbDMwbnZXbkx0V1B5cG5Gc0JhNS9IL2w3MDNpYkV0dTdMRDFtdWkrMDAySkpQRlpJbE5WWkZGVmlPVnFwRlVzcVVMU0JZa1c3QUJDelVSREhqd3A1NzkwUjkreERCSE9mVEFObUlnUUo2NFlCaXdiS05zcU9CclFWV29FbDFtZFdTUnJDSXJrMHlTbWN6dS94OC9Ya1M4eG9POTF6bnI3SHZ1ZmZkRnhFODJ5QU1FSXVLOWUwOS9kcmYyM3FkVG10TFJ2ckNwakR3VGlaN0pXazdoMXlDMEZ0RmJSTjhLVFV0NzJjdW04cjNlVFV6Wko5SU5JRHR6OGZOMG43ckl0VndiNnVlRDQ3c0tUZWg3Wjh5NllxU09ObktOaTJlOFg3eCtTR1dvTWFYSTRqTlpuQnpmUmhiU1BnVURsSGhmTEdDQ0c5TU5YOEtBcE4rU0NyK0I3TFg5RlJpZytldnkvUmtNN0h3TndMK1F6LzhINUxUR1E2bVRxMlZ4Y3Z4WkFQOEVCb3d1WVJHSUw4Q00zbU9Jd1JMQWw3MzlqOEZBMnoxWTlPVWZBZmhuTUlEdkQ3enV0YWMxVG9KOEJSUW1FWjhBV0lidlgwSytNL1YxbU9EOU1uSXE1RXZrRkwvZmdnRzVaOGlwcmovaWZkb1dXZjBFT1czMXR3L3ZQWHc4WWk2cXhhTi9Yd1R3SDhQMnhWTVlrUGtFQm1ZejVURzk3ZzhCNFBEZXc3NFV4MVFXZ014WVBnT2dnZTIvUHdMdzljTjdEd2Z2YjNTUS9kTXdnUE0za0FXVjk1SFRHVzByajJIcittZisreW5NK1FISUVleWZSUmFhTndEKzhQRGV3emVsSDhrYmQrQXVaQ3B0VTYrZkVlVnEvR0JLWmpvUDNJWE41UlBrcUY0eXVZL0IxdURieVBOT3hmMDUyUDUvdzUvOUtPeU1uUG96LzlmaHZZZVBSc3dOKzU3QWFlL2JXc2ZxRWNFVGhNamlINVVTaEtFZmhwSG5SNllNR09PdlZCZlFQNmNEeWtqbkhmMWN3QllLRS95dTZ1V28vNDhSb3ZSemVXL0k0Qkx2T1JvVXltcUdCQkZXVkRnR3hQTU5KZGhBQVU2TkpFdU1FSElxZmFGQlJvMnRlcmZpTHZkSXpCRlNHdzBaak5VQVhCT1kyaHpKTWhrQ29scTV3d0tTUnMrL1poMnFhRTVod2xHdklpaksxcTV6K29GN0dJZDlUaU5KMzdob2hBZXlVV0lEa3pVaUVIWU9kTzZKNHZ0cTlPSHpyTE5xVEsvMVNSVWhHUWNkOTZLSE0wRStqVDVVWXovUGp4cFViaXpiQlBkcjNNdHRqaFFBdHFUUnJOU1p6bldrQ1VHUkFzU3hvU2tCYjAxbEIyeWhpNVcrejFET243WUZvTHlmcTFJSG5TV293Q3NRcXg3aDFmdDRlL3JFZDJqMFlrcEVHcDFZTkFVMFpTanVHZEkxcHBqdEFGbkllNFhHU0w3TGRlRTg2RDRrZUVjRnRYYVhXaFY4Yi91ZFlRYm5ZbGVhMHViN01aZkk2UWdQWUdlaWN3V0gwT0xxUFdKaXVOOGdSOGJxT3BITzBxR1ZBRFQzcXlxanlzTzVCaHBWb0h0bkkvVnhQOUNRU21CYWVTYnI0cjVaTjM2ZnBiZS9CMlJua0lGNVk2VDVwSG4xbFk1KzVHTS9RSTdrMVRsTkRwL05xNitjeXQ2OGxIT3JkMVhUeUpGNEtESVlVa3ZiVlkwNmFQUDlnblRvNHBwcTlISW5pcWd5TmdJbDhHYzFXd1BicU4ydFREMG9yWGY0am1kcXY4bjNUYXRzcC9TZklES2RMc2luRXBpRkxuaTQ3YTZ0RytVSEgwVFpSaStDUVZVTmJKcUNqbVdKTHAraEl3T05nZEhabzVPbWxPMzIwQWsxM0hGZDlZN25DS0NseUV6NW5rNTQzRTgwU0hYU1psNm5jSjlIZXVpZjA1NDErZzdnSUFmRXV5OEo5TEJlNVRFWHlQZmtIU0RUQTlhVndQcyt1aFg2cms2UHZCb0t5SE4vUGxTUDBHaktWYytoZFBvamJYazYwb0JORzhndC8xa0JlTnpZdmVUY3Y5d0R5MEFqMlgvT1pZcktEdnVZZkVBek1xaWNTdWRHN25IYW1CaU5sZTVtUlYzbXBmeHlMWDd1Nyt5c0k3VDNIOXlHWjZWQXVWZW15dCswRFF6b0F2NHU5Y2hGb0wvVUN6ZklHZHpJbXdCYkl6cElxUU9ZeWxCYzAyVC9RbzdLM2lEemM1NTNvSFJjWk5HNUphOUllN2VtVDRkeEt0Z3hqKytIWjlXeE91MFBHWk02a1JaOHRDM3ZzMVdIRGdXZjFrRDNuc1VCdTRjQ1pYcTFRZUYwTVRSK2VTWUJzMDI0WHhybzNra3QvWnJGZCtRNy91elZaRXA1VnVrWWVRMzVlWElPUmdrRUQ5NFBLalRsaCtXY2RhV3k3ZXpMdkFJbE9LYnlFNytyMlV5aURZbG5LdXJudS9DMEFxaDAyZ0Ywd1N2YVgvUzdEVkJjbzZONjFZMEQ4VFY2TExvTjBLUGZETlNYNk1jSS9Sd0lZQ041VU9QWkgvd1pCYjNIMk5haWpSRUlPTktJUFpWc1dXMTJEbExkZjdWTnRxalVTMTE4Z2xLM0dkckR1ai9TM3RnMmJubGY5UnFXSXJOdTJHc2QrakRHVHZ1c3l6YTd6eFhyNjZXSDNIdE42YVJlZGNTUWVRYUEvY25pNVBpWFlDbHR2dzBEUHpYQ0wzcWE3Y0ZBckw4SEE4ZUFIQlhNZE1sQWpyaGtpcXYvelJ2OUZRQ2Y5MmYvZSsrazNrbTZOUzB4eStMaytCOTRINWhPK0ZzdzRPdzVXQVRsbUpScy94WWxnQWtBWDBYMmdPZGRUNm1QM3ZZRVNIZmJjc015M1EwamdoTlJkZUR6T1JnZ040Y0JleS9DNXU1NTVPaE53SURXdjRCNVVQNjBQOE01L2hVWUtQMVo1RVB5WFI4cjAwbC9FN2FPU3dCL2RuanZJWVc4MGNYSHRJZWNWdm9GR0tqNENMYU9MOERBMWpOazRZT0g4dWp3M3NOM1FuMVRueCttTlRzRGdNTjdEeS9jQVlFQTl4eGhEL2IwN1NPd3FOd2xMRzN6QzdCNWZ3a2w4UmdxYi9uUDc2RTBVSEhmckdEei93SnN6NThDK0FNRlVNZnNWd2VBU1JBUFlmTjZDaVBNTHdCNEx3Q3FlOGh6Znh2QTE1R1Y1VXZZSHY5NVdDVHZxVC8zTnJLeDdXZGdvUEVsYk8wK0E5dS9yd0g0d1ZXQldoOUhNcXJLM3QvWmVlUEQ4cE5aUkhDaWtGQjRiTldZY3NWSXFPK3A1L1pvZ2FydldhMGZaZFRJR0NCbEsyQzRwVzJPUmZscFV2cFFlaEt1VWFhRExCVERzY1dOY3hxRlE4T3JBaU9EOVlxQ3VZZHdENVIvZnhXRGg5TG9XVk9tR05RSUZZSk9yRDlGdWNDVlUyUkRGdDhCZGdUcWZ0eUtHb0NBVHVvY1JvUlRjT1puQ3FweUgvTHVNZjVQQTBtTXdrcDcwdzE3V3cxajBzY0l0aEZVNWxveGJlMjhzYnZPOXVVZGVvZHJDa1VBWmFUamRVdFFJcXRHcEtzWUE0ZmFDMHBrQkR3NlNwK3NFWkM5eExjQ2lESTJqVENnWXdtVnRHMXJTUnFneWgvcm9RR00vUjRDazVYK2NqejZmL0tpZHNQdFJQWW5GVXpPRlkyT3ZFZThsaXBjdllaVmw0bGU3UnpMcGZBZGpkaE1FV2tjUng5QWNoTjdSQXdQZlFiZVFpZHI4bjJDQlhqWHgzY3JDaU5sVHFCTXRVdXdoK3RDQXp2cExsQTZhTkJCUUEzQlFENzNjNm12TUhJZzcwZEc1ekE2TGRJQ3ZuOEEyMjhSakx3TDRNbUE0WUhSVnVUbjFhZzVQNWZVdTdSdGdwYlQ1dFZYem1SUEZ3NE42RHBKTU9LUTl4M1BzU1hpcjlLblEwajJCK1F6b1FhNVRlMHNoSEhwSGR0RmVsK01qRnlvOUV2dm1MK1VQbW8wR00rdHpoUDV6VVQrNTFocUVVTS9rV1dBcHBCdThVeEZVRmhsMll1bTVPY2F0Y2I1TGU3M2JsNTk1VWtFUEhyNlIxN09NNndPRzBBMjlwT2Z6NXlmRS9CbmZ4bGhWTkRneHAwR2JxSzAyVmtCRUVBcmptZVhmYTZHenhvOWJiS1QyeTJVdkcwSzRQM0tPNlN2UUhrR3RqbWxFc0RtbXZKOWpuY3hkUDZsRHNwWmNYOHBZSE9KQVZsYStETEJiOTYzL2doWnh0c2c2QTFDdTZMalQzS082ZUhucWl1cVBISW9mOVBCSUY1cG9IYSt3bEZxNE96ZGlNT242ckZiK1BrRUpnZVRuek1xdkRDVTkrd2x6Y0pGUUpkUjAwRG01K1RSbExzV0tGUHdxOTVBZTVnNlpuSFA4dHBBbFN1NWYralV3ZlBPekNicTRFbGdnbndpQWJoQlBoNDhwL0l1K2ZsUXRMREtJK1JEeVRHd0tiTUlxWjJnQU9ka1Boa0JUL21uNDlBMVZGckx3aFAxNldpLzdMMTZ4Sjh2UUtyS09kc1pER25MeUdWZUQ1TFdBLzM4WE04eTEwWDE4eXJnL0pOWUJtaEtrdTNsWTlWOWtpelhkS1B4MWVGQzN3V3lMU3RlWmRQYlAyUitucHlLcFY5Y1gyYWttYnZ1cjNTWDE1NmtpRkJrSG5hamF5ejdyaThnWkNkKzd1OXNwZnRCUHkva3JQQk9Sei9mb1I5Ui93ZDJsSDNGYmhabGowUnJzY1daSk5USDh6dEJ6dUtnK25rTmVGWGRoOEQ0VmllVzBIK2d4SEJTbG9nYUh4eGIvMDJYSzlvOXJ3b0FjejNqMmVlWkkxOVdQWnYyaXlJalRWczZUVTBuaTVQai94UUduTjBHOEg4QytHdGtiNTVQd1JUeVUyUlFsSUxVQVF4c2Voa0dCZ0w1dnVCZjhOOU15YnVBS1FaM2tEZlJDWExLdDBlSDl4NHVIUUE3UVBZTVBJZWxYKzR3OWNYSjhUK0RnWjR2K2tmZmdRRjZyd0g0QWd3a0pSRDlId0Q4RlN4NjhqZGhvTnJiL2gxVDdNNWdvQ3NWNG9TZ085Z1ZEK2toTEtYdUw4S0F2THN3OFBWTHNPalNjNGtZL3FSL1Q2SHUzT3Y2S1B6ZVc1UUdtTzk1WDM4ZE9kM3ZwMzArZjkvSDlURi8vZ2MrTnZobmN4L1RvOE43RDkrSzh6YW1lSitQa0NOaGFWQm1LczBqNmRmRzV5aUI0d29JU2lyaGw3eStjMWc2NTZXRC9uZTlqVU9ZOGpRSDhKcWt6Mlk5Qkdidnd2WWRmSngzWWZkU0wySGhBeWs3QUFBZ0FFbEVRVlR6dkVzcWlOK0JwVERmd01CZXJqMmpiL2U5emt2WTNucWpKNzMxWUlsendzOEFUQ0lndXpnNVBvQ2RuNi80UnlrdERXeVBmTUgvZjlmNytRZzJuN3pYNkhQK0hRWDJPN0NJODlQcjNzL3I1M1A5b3hqdCsyRzVXZ25DVGdIQVhyVWUvNStDU0lkNWozay8xQUVFQTlVWThHT29MYWwzaXUzUm9qdDc4MVcrbzRJRWxLQUg1RFBBSXdTYXJ0Zld6aEV1cm5EZlFabUdpNFlkcGdnZVUwK3Y4V3ZYMHVhSXFhU0FCeU4waWxnTWN4QzlDemR4MzFZTUl6VDJ4SHVqS0dlc1VJbDJDcytPOGNKT3l1NU5nWVJqU20zY2JZNnNWczlKamhld3RWOGozOEdtNEEwTFAwdm4xeitmb3FMOGhEN041RmtXVlhqMUROQWdSWVZoR2M2bWduZEpxZWhyKzZvbEdvZXVBaTRIc0hFVXpSQ0FKQ3IvbWxhM0x4cGhoVkllSFlxMjU5NGNxL3dWUm9vbVI5eW9iTVc5b1g4WHFSV2x2aHJZdTVKM3VkNnFjSzdDbUpuU1RPVnd6bDNWWUN6dDYvcXlUU0FyVEl5bXFYbVh6ekRDNGFETmFaazdFWks3bEREUGlVYkxHT0s5M09rdVdBV0xmSzU0eHk0YWp5UVMrZ3ZJV2ZabkZVemtQUFBhRXFhTVZ5UHFDakovOGc0ZzBhcXlmelE3Z1FKVXVnZWV1bUxQL3RBb1RaNmdYczYzK0gxVFJnN2RiVHl5VnczbWJVNmhTbEFpcGN1VmQwbVhac2pwVWRVNFRzWDZFUGxlZWU1YlBRK2NJM1dPdUpRMW1jQlRxNkduVlBxVzdrWVUwQ0FCU1dQM1hac2RISUJyT2tzSjJFYWQ5akRzTmVYbnVtL1ZRWnVSOXNyUGExRlRCZEJ4bGZHTU5jTDhzQXhMbFg3MEdZejFMSzNsZjlMWGpmelA3OVdBVENlZ3hSYkFrZXVrNlVCcEQxQ0FuKzJ5cjZ0d1ZnRWtYa0lBK0hLc3dYcVhFbWhEa1ZwNmh6bzBvbWVPTFk0Vi9nN3RHRUFwLzV6S1hPekRJK0RhN0xBSDVCVDNMTDF0dG5KZmVQaTh6NkROdmFIOG5JNHdoZUVlNWI2NWlQUkp6dlFNWm9kaUVNZVoxQUhZdktVTUNoVjlCcEgrdGptS2FFdzB0RHAwNlI2a0EwS2Y4OVFjbm5Ga1MvMXoyQjVhWEdYL2hIcG85M3phT1BBc2ZIaFpvWXZjSCtRVlBDZjc4bzdXdzdUbTZ2eTFCK0dQeUhaYjhuUE5Dc1M1Wm5TNk9qTXBUMU81bERwRjNEOHExMjJRSTVDVlJpZmRKUEMzUk1QQ25QU0NPKzBXWnptWkkzVklZT0VZNlpERmVZanl1TzdyUkVObFRmajhUbGtNMmpvQVRCQmx0Sk9yeUN4ajA1TnVxMHRwL1VIWWEzMzhYSjBLMWhqUHp6dmo5RFdsZnI1TjMveVI1dWM5ZHJIQ2ppTHpDcFM2dU1yaVNwOTFEUHI4Vmh1UjhEWEs3S3FIUjUxY3owSFNqK0o2S245NVZ2TXIvZDQ1RU1MZlYvMThMQ2lwSUNoUUFzQ2NpNlIvK2Y5Skxxdnd2R3FidThvL3RmTWtORTdwc2Y0L2FEc1IvWElUeHFPMGI0WXREaW1WT2tmWmsxc0IrQkdBOUMxMjFWMXRMZGZhb3pKUDFOK0tOUjR4eDVOd2pqcnpNN0MrbW1FaDJhM2xPOUp0bnVXVnpsOVl5MG56Nml0ck1yMDNZQURkT1RJeFdmdm4vSnRFbWdvd2djdGJ5QkdpYjhNRUM0S1lBUEFQL1RNS3hvQ0JhWE5ZSk9mZkFQRFZ4Y254bXpBQW1hRGl4TnZvVzZ4M1lLQ2Qzakh5cnY5d290N3d0cjRPRTV5T1lCRzAzL0MrTWxVSy9QK1ZnTFpINklKbTNLUlQ1TlROWC9PeEVlUitEMlhVRXVlUEtWN08vZS8za2U5QVBrVUczUm01Q2VTVXhPL0RnTzMzWUtEeFMvN3plekRnK3oxLy95MXZkM2tka003bllJSHN5YWNNYU9iOTNRRFl4SFlDK0R2MVoxWitsKzhCOHYzQm1ocjc0ekRRL0EwZjh3dUxrMk1BV0VoOUZFaldQaGY3M28vSE1FVmtCWE5ZR0ZzZXc5WnM0blV6TW81R3J3dlkzaWJBK3ZaVndGK2dOMEsyQS81NjJTQ24ydU5adUFVRDkzOEJHZWo5V2RnKytSS3lsK2NCYk4rZStXZDMvSE05MXdBU29INVpBYVo1bG1qb2UwK2VXWDBZN2Z1alZ3WUU3Q3Q1TnU4QUZLUjZLc3dxR2FLQ01KRVlYbHQ2ZlFGZFdxK0dwWjN2YStzYnB6RERBZ1NXUGtLKzYwMUJyVXkxZWZXVnFvZWExcUhqUnlta2Fia1N5RVVCS3JSNTJkNS84QlJsMnRhdFNsVXMvdXltdFh1TlJndXJRWUJtMmllT21RYUJZdndpWE5iMkU1Q1ZsQVNBc1grVkx2VE5JOVBtQThCUmUvL0JVQ3JBTVVvamhhOVplLy9CSUtCOHcrVTVBR2p2UDNqTWRZL0dLdGx6bkF0NlpPczluMUdnbnpZNXJTdlA2THp5M0ZDaElZbkdKeHFjVmJnL2kvdXB0cGErajI4c0FyZW4wSEF4SGROV1VMajQva1JwMmpaNjVmU0Q3NlorYkRPY2VJbUtSS1Q5T29aUmhvODJwNGRVV1ErdDNXSEhlMHAxZlhpR3FUUjJVb2tpeTljNlRocmVPSCtGRWF4aTlDN29LTWVIdksvbTdmMEhCSWhKSDlRZ09ZMzFoUDVFTUoxdGJXTGZha1VVTU1yNVZ3YUFrYzhJOTJQOGZGYlpWd2V0M1JQTDZCN2xOVUE1Zjd6VEx1NnJ1SmNKU0JDNDFYVmZJQU5PQkt3MzhobGdjNjYwVVBjTzlVNDFORkxlbkxkMkQ5a0syUkErZyt1UHZzNVB2ZDVUR3FKYnUvdU40enhyY3dRVjd5dlhNVDZWWi9kOVBramZVcXJsNXRWWDN2YzI3NkJNZzg0NVlDU2VlcjVUUWRjOXJsazNTQmVCQVhyYVp1Qk42Zm1sOTFmM2E4Y1FzYTAwRnJXeFFiN3JiVlMwUmx0bUFxRFRCZGVlTWthazVjdEluNExjRjBIRUlmbXpiNHdUWlBzRW5ZeXJaUWRqTWZmS0I1WlcydGU4QUw5NmFLcEcvWEJQTXIwekRiaEFlZDRZT2M3MW8wUEh0dmxRb3pCdEdBZnlmNkl4alVYOGR1VER5cHdua0s3bis1c29wSit6SGZpNXlxUXFyMHo5bWJNdHhrL2FmV0pFaHZLc0RxLzJVblBFMWI3cDlSU1V4MnV5azQ2SklCMzN3WUYvL3RSbEtxWEozQ2VhOWxHZGFqZ1B2QzVBTTZVeE94bnRhZS9KZDMxT2tjVlo5L29aRExCeW1YYlZCamtyZktZMGxYVU9nb0VWMmFKVDJ1eEFNTWZWN29yV3d2dUx0WjhBMHRVS213by92OTNhdmZiazU2cEw2ZmxPZHd6emI2bUQrNGQ4bk01YXpBQkJYV3dEeWNLRDBnbXZBRXdEVUVlK3dXaHkvazNlcDFlOWtGL1JlWW15RzJWa1p2Z2lyNWlIT1ZFSHJxaWZjNjl1NUpsa2UwQSt3OHNtTzlNeEVsbjVPZWRHK1hZOEh5cXZxdXhZOEs5YThUYWpROGVxTGFOdE9aNmRRQXFSNlVicEx0SW5qVHlsM1lIajFpd1RxUjFVWklVSUxLQ3lSM3U2TUtTZjAybjlDQmxyNkpRZDlCcktieDlZOUhHYm5RTlN0b0dldGRHOTNHY2JLczUyVTRuMFJ2OTh4cExPUm1QWkJ1aVFyeUJjYjRCQWhiOHZmZDg5Uzd0SHN0VzFkby8zWUZ0QkQwelJzVHduTUIxcDBGa3cyQWxWSnh1am4vZjFQNzI3NjN3SkQrRC9kQTZuUFMveWYrV2IxYjNSbGc0QlNlOTNIWU9BSlcyamd6U3VVdFFwc1pabVBzNmQ2b3JwdTV1d1ZVTWNaV05mZGl6SlNRMWRHMlYxYjVJbXE3MTRxR3daRTNscFRMMnVkSnFPOHZ0dVgxcTIrZjV4N3VNSmdQVWNSbHcvQTRzdy9WVUFieDNlZTNpK09EbW0wQUNnQUxHU2NyRTRPWDRFQXgyZjg5OXZ3d1NuYjhLVXNLY3d3UFVGQVArNURPSWxBUCsxLy8yV3YvTVZiKys3TUlLNUJuTGFaUzBPSEw0RFMvdk1kTVNYTUFDWjNtM1B3d0RDOTJGZzN3disvSnNBdm5ONDcrRVN3SlBhUGE0T2dLNWhRT1I3RGdLVE9OSVk4UzZ5RVpXSGhjTFB4dnRKQnZzSWZsOFhjb296SmRxWFVnYzlKMmtrNFgxU3Y0Y3NiQVBBbjhCQTl2ZFJldDJsT2JvcVdDZDNHak1xOXlYWVdyNkJIRUZVWFp0UXh3RXk4MXY0enlhQXhPL0M5dDduWWVEMloyQlI2Ri9TK2dRc2ZkY2pVV21NdVBTK2ZRRzdGZDZ6KzFIWWZjdW5zTFhoSFRKVC8vczJEUHd0bUtIYzdYdXhhMlF0NTVjcGxIMThuSk5MMk43aS9VZ3pBSitGT1ZJOFY5YUV0MkY3bSsvUjZQVXpzTWp3enlHZmdUY1hKOGNVcWxJS3JzWEo4VEtrb0g0SmVZODloZ0FFUDhuZzcxVVk4bzlLR1ZCMnE4Skc3VzloeUtOU2k5YStWd0hGRFF4OWlzeTh2ZjhnZWNHTFVzaDZJbkNjUEJ3aHdrRjcvOEhrcXVzbWhtVkFqRkVvMC9FQVprQldCVk1qaXFMZ1hvRGNsWGxNQUtnYk1qUXlRejB3QzNveVVxSHIyd1BuQU03SHJxbVd5dHoyM1VGUmVMVzIyV09iaXZZRXB1eXE4RU9oNWRvR1ZtLy9DT1p0bnVvYk1OWVZnTUFOQ0ppcXRNMEc5djFnYWUwdXNJMzNhZkRxaHRidTdXUzcreWp2cWV6ckk5Qk4rYVNHRE1EWGkyc3ZlKytpdmY5Z2I4UzRZdDBLOGxDbVRHZHM3RHh0VVdBS2hYalgwbVFnbGtXTnIzcmVWZERlNXBVTm1FS3d6U3RmQlhQQXpvblN2L2p1SnZ4bS8vc2lYcVp3NXcxa1FKN3ZiVE5HRkhTM01nNHFGdXlEUnBpcFlqSU5kVkZXamhHZ2FSNkZMekQ2ZE9WekdldlI5V0JKYWYza04xQkd0cXljQnFjVWgwTTBVdWg2OHJ5VnJ3c0ZyTDMvNEtDNWVoUXc1NnU0RzczSkFIeVVxNEg2ZkZQNVhzTDRMZWxqTmJxcXNmUnV6QXpCdGVRVk9OeWpNL2o5NnNoMGg3b0x6em41MXdHQXZUYUQ0NWROdmhlU243R3ZkSXJsMk9DR3FVbGIzaXM4Z1R0Wk5EbEM2aElHU3QxR2xvVlh5TTZ6dkp0UVFiMDkzN2RNSFRvTDN3TjVQenlIMHZsNTZuTVNEY3djZzU2eERZTFIxOC9RMlFoRGJjZlk0bnZ1UE96RjJ0MlZNZW9rblRNeHRxOTlEbXJPYmNWZHltMk9WT0lhVWI1SmhqVU04L0hJYStMbnNYM3UzK0t1d0lINVl2dEtENjViMGhqSEd0UmphZk5kMEZ1anM5c2NPVElaMFNibmpVYmJqaU1kY29TdTBrQWFNQUUvb3lQNEx4MjQrQzVUbUxNT3ZSdHdGRC92QXhLQTd0NjdTbkg2cFh4UytYbUtKaFN3aU9kWStURFF2Y2Q0Myt1dDNaRTk4VE4xamd5RWJ1RFhGUENzQlpxZW5ISFFCZlhpdVo2RVB0UHhoVTdzdGV3ZnV2N3FORUFlRnRmZ3NyMy9JRjIzMDJhSEQ4NERnUmxHbkxKL2RKZ25mVkRadm1NTWhlOGgxd0g1dmRKaHRzdnhNQ3Znc2pWZ2xQUk1BVHVObWgwRjlMVDlVVUVGTDNXNTk2cjc4UUpaMXRVNkdQaEJQcXZ5dnFac0orOWxSb3dGVE1kSTF3SFU1RXZubjNwbk11MTU2c0NrOHdaa0lCY28rUmlkN0lwNUYzNE9aRkNaWStNNjBqbVBaNDVyeTZKbmt6SWZhWXIyWHgzaldMaW5aN0M5UWY3TFBjR3pyL281SFJkNDVvRXlRNVpHS2FzOG0vb2JlQkw1K1d3RVB5OEs2YURNWWZYNmhjZ1BoQVlrY0VabzNpNzZlYkVPSWxkRW5oSHJxOG5KdmNDR3lJQmorVG5yNHhtNHFUS0d0L2FXTmwrenNobkJ6eE5QSHNuUGEvdDZIZjVXK1RTVkpqdm9GM3BJclRTbEF3M2xEbUlXYWdQWVNZNGEwTTlwWTdtdTgzWmhzMEUrejVHZnN4ME5YSXZ5RXZmMm5wK1pvWHQyNlZpbitoVHRJOFJ1dEhUMGMyQTRNcjltVyt3cGloa3BxTjBiNkJMN29jWFhKanJ5QVNqdUpWY0gyaUg2VWdQbEMxdW9qaE5DZTlzUU1DUnQ3UXF5RDlueHQ4N1h5TEtCOENWK3FMUmM5NlM4VS95dDU2SWRZY2YyNzJKd0IrVUN3UFZ5N2grdmQ0T01DYVdnVFdTNVprS1BUcGJQQS9qM3NQVEZ2WjBSNEdvTkEySmZnSUZScHpEbGVBODVtdllwZ0gvVVZ4ZHlOT3ZmZ0JHZ3J3UDRRNWd5WCsyRHB3NytQZ3dzNXQyNnY0cWNpdW9JZGxCNWZ5M3YySDNzL1ZSZ2U2MWdxZDk3L0dua2lPVWpiK3RGNytjN3NNamxPekNRN1FBV2thcDNKeGVIU2VhRm01eVJtdW9KU3pDVFhvZHpmMllPaTVEOVJWaTA4VHZJeEdnQkFhNWhnTjRVZHFjekZpZkg3OEdpZ1hmMVlGUWozZHAvdncvZ2JOdStrTytuM3UrM0FUd1pBRWx2d3p4RzM0UHR4VWNBL2pFc1ZmZnZMMDZPdjFTNXg1ajlvcUQ4RlpnakFlL3NlaDRHbVBLT2pyN3lULzMzL3dFRGdlL0NJcFNmSUNzNit6QkhnRnZJYTNhS0xLQk9GaWZINXlnalpjZVVqWStkVWI0WGk1UGpqOElpZmY4Uk10aDdKdU9LNWFNQWZzdi9mdHY3OXJML3Y0VE5DZTlIM2dCcHY1L0hmZTlsalh5ZjhBWUNibC9Ib2VESG9WeURJZnpJbDJBTVZFRktEUjRVQW5zRi94RmxEM2FHemwySlk3UlNpamdTb2FPdmJ4cE5zd3p2OVk2clZrYUNWZlFHVk9QNWtPS3pxZFFkbjYwOUV3WDFCTnlnUjdEZnBXd1RzQWZBb2Q3M2UvcGZLNnFrc0c0VktrbXZDY3hRbVZraENOQTFRVWlVV3pWaXhmWW5HQitsU2hsaGloN3ZmbDlyT3NvTVJRZ0QyZEJGd1hibXlram56bVRXM1ZNZkFkSXhrZFlFUGVpb05GUlU4RnNENmE0Z2V1S3JaMzZ4OTNrbW0xZGZXWTB4Z29WNk5JcEc2WXorcG1JOVFRWE1HQ3FpeUc3YVNqcTFIWXZlVWFyM2p3TkdIelRhRmVpZStVbjRMdDFqSHBSc1Bvdkd2VUlob0s5OFAyMXpkUEFhMlRpMFJrV2hGdVVxQXZjMGRPbVo2WnhYcjJQVlppQjhMenpmUjE4NE5qVW9jZnk4azA0TlRheUx5cnJLaXl1ZEN6RjBVVTdXT2FjTXpMb1ZHSXYwTkNrOUtJMWVnTXR3d21NNm9MMnNQZnM1ZHdNOW4xSGpEQTBMMis1REpzZ2JuK0g1TE82ajg3MmludGdzN0JlQkdUMEQwWmxwRnI1WG85WXluSjg1Y2pwbUtwTDh6Yk1TOTdPbXEyYTZTdEw1bVQvRGlLVkQ3eHZyWWxTeDNpOE1aTm4zek9kaDJkNS9zTjk2R2xTdmM5M2VmM0JLUTczd1ZScjNhZlRTdVZMK1JJQWpPZUpTTVVjSm5LWDdVNzBmbkdPbUxWMjA1c1NqTWxhVm5zWHp5ek1pQnQxZVdpdUdIYVdoS3M5TlVQS0V0YnluOWZUcGhmR3NwUWdtcVcrRmZKV0RHbStLdTdKUnAxWHJOa2RpMU00ci8xYUQzbENodzBFeEo2SC9sQS9HOEJrYVEya0FvNVBlVmRKbHE3R3V0L2graXFuRWgvcFhHT1dhSEQwWFV3d3JzTXgzQ0s1dmN4b2pUMGhSOGNoMFFBMmljUy9TOFcrblRETnRUdjI1ZEJwOFpSQVlKdU14ZXBPOGhGa0VuaUxiV2JqVzVKTkFTZGNveDVEM0hzQWlORFZqMkI2TWI1dzMyVkZIblN0U0ZnWGY5NlJOdkVhcnMrWnFnUFh6dzNPbE9nb0xhZEJacUlOUnZrQ1pnVS9CMVZoSTE1Y3cycnNIczRlc201emEvUWdsTFZqN3N3dXBkdzZodlNJWEtqL1hvbmRJUjcyQTc1SFBrdjZwOHdOMXhRdlZGU1A0NVoveFBjcWR5OWF5bktqTXBMSUpIWmFIak9tZGRtUit6bXI4bk8wRWZzNjB5cmNoK2dBeVRlYStYdmxjUlRxZEhQMUNYeUo5NXZocEhLYnNtMmh4VTBhQVJ3ZUpHYkxlc0VEZWx3bVFSNVkvdEIva29TbHFXWGd6Wlo5TmUvL0JNaGpTSXdoUjhBd0JGWlFXRlNrd3BROHFEMUpYWDd2Tkl0Rk1QOHRSRHE2V0tNZFJkaFhiUjY5dUluMVRtVFB5YzUzRFpPUVA5UXc1U01WOUVwMGtWVC9YZDhicTUzME9uZnlmZFk3aDU1UVBKeGpXejVraWZmQWFBMlFhTllYcDF1UmR1L0p6ZFRnWkxFMitHNWQ3YmFod0hSTDlDV0RacWluMTZxSlVkTDV0UmM4bzZlZE12bFBhbHlMRnI2aGZ6MkN5eDloQWhyNmlUcWJxbkRScGN5Q0ZqZ01vN1VWeEw3THN3L1ExelpMSmVWN0ozbFlieXRUYkxZRDY1dFZYbHNydmhnYlRZNU10L3ErY3MzWHJUajFTQnUyR1dsZlVPZFZtZ0R4SHRIOFExS1VPM3dmeUZrRkQwaTduWm9OdTRFamk0ZUc5cUxPUHNzdEwvN2tmVnBFZW81UWR0am1zRHBVTkJod0dhTStSdmszOWQ1SlZuTi96bkFIbC91eVVnZjFFYkNzNXpiVVdnWHpwN1NyK1ZaeGZ6dGtjZGo4b0JjZXZZaURkQWxCRWRuSWpYdmc3TDhJQXdwV25sLzNweGNueGJRQi9Hd1pVYlN0TUhUMkhwZjd0WFNEdncxTUhzYzY4RHkvQW9rY0owbjBQQnRLKzdQMzlQdktkVFN1UDhDVVJPZlNJenR1d1NOSlB3a0RGYnlLbmFtSDY1czhnYjZaUGVYMnZBNWd2VG81cHJGakRvMTE5UEV1UE9JYTNUWUpDa0k5UndXVEFIMGVlNDduUDdZdXd1MjYvNCtONno3Ly92Z09RVTUrRGw1QVo3UjZBL2NYSjhldWhEMk1LaGZCSGJHdUVVOEI4Y1hLODlyV2IrbHpkV1p3Y2Y5WDNSVlN3WGdUd2N3QytEVnV2UTlpY2trSC9wby92YTlxMk93QUFtU0V6YXBiM2NuM2RQL3NDOGx3T2xYM1luRklKZVI0R2VNOWd5czluQVB3dGYvYWIvdDFieUttalQ3MVBFNkEzdGJOR0RjUDcra1VBZnduZ0hUOHovN3p5V2gvNEcwczhZM05ZeFBiN1BxNFV3Y3YrOWF6bkpSejQ3WWxRL3JDTUxNcFlyMkE0ZXBaRmpXNWtIcGNRbzN0ZmY3ZU1pY3lQOUlqRzNDVEU5eWhrNnAxYTdUQ05ubjNDMGJZeW9MaVFsZ04xUVRFYTI5Y1lZTllqKzZYUHFLQVVsZmJlTWlTUTdWQzRqdGZ5enF3SUZrZkljM1VxQWlLRndiN29EL0xqbXVGUGhXOEZZYmpuRmpCakNvMzc1d0hFT1lBYkpQM3pKMzNqOGI3ZVJsN3JHSEZYSzFSQ2REMFAzZGpJdFBxVUN4aEpGd3VGeE5rMjQ2enYzZE14aW9ZYk5xaGtKdUhWMTBYM2JOcno4b3hHcVFBb3dJQnF1dklnZks4RGVFRDZvbDY3UUU2L090cFpyY21SdTlkeW5tQmRrSDNuZTNFTjk1UkUxNGlpaGtqK256NlRPZVg4S08xUUEzNU40U05ncGZldGt2Yk4vWjArRUlscGlOUjVob0JycWd1ZUdwTjliMG93a3dwUzhwWWVvTHM2QjBrNURuMkxCamMxTW1vbWhtalVuY0RPTEZQV3pyd2ZHdTNIZm1xa09hT1JkRHlzUCszeGFLU0RBTVJ0bVlJd0tzaFU1TlJRZUk0TWpnNTZmTk9nNG5WcDlCOE52cWtJMktlZjZUTUsrT24rbXFLN05rVjJnalpIQmExZzBXVHBYTG9oL2RDQkRnSWxsOGg4SGNoRzNnUXN5MWxoUkN4bGRPWEI2dUJGSS94NTQ5a3FkT3plUHJ5TmRadlRtaWJRMVo5ZHQvY2ZUTnY3RC9ZYkF6YlpiNjFMUVZ6Mm1UUlI2WTdTdmpPcGgvU2IwVkFhL2FqR0RNb1VWTUlIaTQrSlJ2MmhmYlBOc0VSK0hsT3E3eVFqTko3S2wyMGlwN3JtT3RGaGJnM2pBUmM5ZmFOUm9tWm8xY3dIRTJSbndVMlRIVkc0M2xNRTJhaVZ1OWQ4ejI0ejZHamF0aFJkdHFWRUI4azlOOEFSRE9FZTdvdHdVWGxsYXhsallCVitudmhtNE5YS0YxU3UxVHNaNHgxdmxFMzZyaDg1bC9vWk9jLzEzUGMrS0MyajNEOUdidEpDK2hVZEFuWXVQbzdVZGx1bXVTUjRRSnBPUUZUNUE4OHZVR1oyby96RzdBTjZkeS9uaE8vcDNhcUFSWHFtY3lQOUFIS0dPQzE3OEhTNHlOR2VOQUtuKzk3Wm52QVJ2ZU9XMytzNzJ3RExKSWZBWmRxd04ybVhVanRUd1dla25SbnMzQUJkcDZLcDBGSFNTam9DTVEwbGtJTktnTUFMSWFuTTI1d1NrM3M3T2VjZ1JISHFYUGd6bHpvbjdmMEhUNURsbjBFOXF5MGRIcU16ejY3OG5HTlNwd09WMys1QUl1OHJ0Slc4Y2EzNmdkTlU2aUV4OGpNQllzZzhXODhPNVFzRldhUGhQam9CWHZiUXN5TEswUGRGZEJKTi9Mck5qcDA2QjBCZHBrd3l0ODVwbUo4WTJidnlPYURUVnllOXA0d3hPUm9NRmErRGNzOTEwb2V6LzVmaC8xMzVlZFRQZVc0SmNxbCszbnZYT2VYV3RwNXRTR2tya01FSTBpeWUwVDUrbnNCKy83d1hoL0MrM2tKT3J6OG1BeGFRMXozUkxhZWxTc3VHK0RucDRhajViMGJlSFM3elAyWnRhL1NqK0g5YlhUNDJqbThwNTUvbktON2ZuUGpMR0JsbFRKOTNMVTNwQkJVZEVvRzZBeUgvSnYxWEJ4RytTM3BBL1ZHZEJZcjZaRStvZms0Nm9nNTNFNWV4b242ZTlwNnVUUk1DWE9ML0tsdkxkOUZwYlV4SnVuellHOUY1UTIweWlIMUJwcm5KT1VIN0xEb2U0UE1ieHRESnR0Vm1aL2MwUHpXZG9xS3pzMHhSeXRxUjcxN3FPTFlWYlZ2N3VpdnQ5YUlPNUdwTG1Jb2VWYTNYeDV1QTNmQTFiV2Jjdzd4V2dicmFHcVZ6VnlwdXM1ak1rZTlOL1hjQTNod1JMYXJDTHpmaWV6NkFmVThqKzNNQWZoa1dLWHZZVTArdG5NTUF0b21rVDU0Q1dDdDQ2V0RVUnY1K1ozRnkvSWNBL2hRWkJEeUFBYm0zL0xVTG1QQTBSYjc3bFFyY0NnYWN2dWpqK2dZc1d2Z0lOb0g3c01uOU5neUFwY0p3Q3hadGU5Zi9wdUg3RkprSUxYMDhHa0c1UkU0dlRJRnRCWXM4dm9DdHljZFFCLzkrMm44L0R3TW1tYjc0RUJhOStSYnlYYnFmOE9lZUFIaTZPRGwrdk8xdVlBSDlOdDZYcmVDZnY4TjljVTR3R01iRUZ3QnVleVQ0QkxZblBvTHNiZjg2REtSOHpwOTlIUlpSL1dtZnA1OEM4TTNGeWZGbEJRVGV3UFlHUWZYWFlKSG5xOFhKOGRkOFhuNEpsZ3E1cjZ5UWhlcjNmUXdmaGEzL2k5NW5yakdGaFROazVZK09DQlB2MXhENCs2ditMMU1wUFEvYmQ0dzJmcm4yN2pYS3QyRUEvbHM5ZlpxRU9WMHZUbzQzQWhSZmkybC9XQUJjVS9BWktpTU1ncDNTWkUrd1pPeEdhWFJKaHI4eGRhdlM3RXoyZldsRGxiSlI0eGd5NXJValBTcmIwcU1OWG0rZk1Ld2dFb1hEdVR4eW82bkJLMzNqV0hkT0c3enQrYlkveW96dlg5VUxicWlrYUU3L1h3VzliY29EQVJZQWhaY3ZrS04xSi9FNXJidk4zcHFxWEU1aHZIVGloc0F6UHI5bERpbEk2VDFjSFFIZTY2R1NTK1VmeUVySG50UjFHejFHZ2ViVlYwN2JFV21jd3JqSFB0YzM5NnMycHg0aVBlZ0ZFTm95bW5OVWhGWVQ3cElML1U1ZXZUM2ZieXZKbTdYTjN2cFVUUG9NR1dQYW9CSklaVVJUb0VZYXBQOVBrRDJlVlRGS2hrUUZWN3dmSFlNM0RXRCtOdzJMcXBRT3pmM0U1MEpCWEQwejZ2UkNNRk9qTjFRR1ZMNHc4ejdwNStwTnl6a2d1THlVdlVlREdQZVpHdWtpbjJEN0JJbjRuTzVQZnFlT25Kd2ZwdjJOZDcycDRWS2phbWc4U2pRNTdBK2RGNlhmQk53MVNtY3dVbDRBa29YL3p6c1YxN0I3SHJjYXNvSVJyd0FoL2JldW56b2dBREtmdnNkVVdkK25FUjBaakNSWXBuUVlUYjRqUEtZRDNZZnhuSVVZOTlQM2JYbVByTW9JZlh0NUJhZmRNamFPUFJwR2wrMzlCd2ZlSjQ3NXFNMnBqdFdJeTcxQThKdDhvL0R1Yml6TkpUMnB1Y2RJVjZqM2FOKzU3OWpPR1BDdlJsTnFaVTVqZklYL2pPR3Z2U1hTUlBtYjBYNDhQenk3aFVHdWg1NXVJR2VweldrUm80d0ZoUFVYUUhHTllQQVIyWkw4UE1tTUEzU2RZMGdHcmlGRHFkRGZHajNVeUpMazlGR3A0L0lxTXZxMk1vS2ZzMDA2eHB6M3JDMVFHaEJyZ0JMaXUrMzlCd3RaMDVpMlVPZGpUQ2FUb3AzV29na1ZzS0xCdlpwTnBhY1B0VUpuRXpybVA0V2RhVFhBNlRra2pXQWY2R0FEWk9NcitRcFR6ODZkanJCZVpva2d6eWU5V3ZwWUNUeHNVRG93YWFFdFpkcWFNd3puZHcwSmFFRGVrd2NvRFl1cTYrbitYOElBa09pVXBpQVg1K3pJKzBxbnlxZkl3UXM4enhmeVhnUUpTVGZwUE1GNVpOUit2QUlOTXFjekh5ZjVBT1VJQXViOGZ3YXpvVnlpQklOcW9CM2Y1N3h3UFRsWFROdThoeTNSaFQ3UGgvQXNRYjVucHpCQTRLaDU5WlZlUjlOUUIvbnlBdm1PYmM2REFqWmNQd1h4OUh3dHBhNTVtMU1lOHdvMjdzTURxV3NtL0x3QVFOdlN5WTNuZ254VCt3NzVQY1RMbFBicnZ1dklBS1RCYlJtRnEzdUwreXV1RDFPdWQ0Q0NScHdQRUJ5NkZld0tSYU1qVlI0ZEttUHNIc254cjRmbVBndjluUDFQc2pxeVBqdEdQMWR3VUdWb25pTWdBOHZLTjZqRDFQZzVkUXZTdWt0dEp4YVJXL1dNOUdZY2tYY2kwQlgzQWZsNW43MkVqb1UzWGdaNHBKN3hDZXJnVnlxY1MvOTdyRlBaMERQYTltZ0FUWXJxR2dWQTF6Zm1IZlZ6OHRJSTVLdk14cjI5Ukw2ZUlmTHdtQWt0T1FJajc2KzBKMlUvUmYwODZxRzFraklqcXIybnRxNlVkZHZTQ1Y5QjJNSmVGbXcxeFhrUVd5ZWR4UG41eXNkQzNUU2V2N2p1QlVBc1JaMk85U2UxeVhGNlgyWUMvSEl0VkRiZmErV09lQUZ3ZTNVTnFhY1lQOC9GbVBQUWxtbkZLWWN3eTl4Z2dHeFB2NkxqU1dFcjhwOXFZQlNFNStqWmJpemEvTEoxWjg2MnZOZGU3MjFXbXRxeENVOFdKOGQvSHlaZy9mbVlWTUY2OTZsL3hGU0tDaVljd0VDeno4SEE0RjNLWHdMNFk5ZzlzQlF5VndBZUt3aGNTMGtyNE9VTUJ1TDlsUGZ0SGVuelczQkJLS1JzL2dqczd0UTkySHk4Q3dQUEZqQmcrZ0RkMURWM1lLbXIzL1Q2bVlLYUhuUXFNSjE2dmR3SVpNVGNISHN3UVBBRkdQajdhUmdndU1Bd2lINk9qUEwvRVN5UzloMS9oK25JdnNPK2pBSDFhdmNpOXp3WGxXRkdMVjhpMzY4K2h3Z0FBQ0FBU1VSQlZMSDcxSDhJTU83RGdOV1h2YyszWWFEL0FqbXErUzRzY3B6Zy9aL0M1dXF0dUFlODNvMzBtMTdIejhQVzUyLzViMFlDNi9weGJiOEVBLzFYc0gzN3hQdHlCRnZYWDRlQjdSZXd2Zmx0ZU1ybGtmUEp1ZmxOWkllTDI4ak9CVitHcmR0L3RhMnVIY3UveGppbmpnL0xqMUVSUmtnRDFsWVFScGxMRUZUVVVVVU5DYjBDZU9nSFBmRTZhVEZ1MnZoRllXa2s4QWtFSVhEa2VLTEFPMjFDK2k2SVVITVZFSFdrd2VwR3lyTXdRSTVvay9jbVRzWUlUR29ZRm1HYWdvc3FtRFJncEhVWUk5QkpHM2VRRFhsckFQczFBMDJiNzc5TUJxc21SMFZWRlV3NWsweGRSVU1MYVQrakd6aXVYb0JTNnFSc2RUNTJuRmNwRHBqUUtMWXQyb0VHOXcxTW9MNXlta2Fmc3dNSWdIaWRjUVlheDBqQStFeVNVOGVld1lwaXBiSnVRWCtWUmlqWUM2SFZBbUFVZCsyRU9sTkVDLy8zK2xYSjNhQkxuNklYTEVGc1ZWSzFiekg2SWtVR29MenprMzJqa25jT1VVWmsvUFNtaHJmRHZpa1F6VGI3RElBMFdySWZsS0UxWmVkTXZtZmhaelNVczZ5UmxYdTllNVp6Y1M1enZlZnpsWlRPc1Bic0E0M2phbkNZK3J3TVpkQ2cva1NETjZOOWFBZ25qZW1WMmRveXlvNFJFREVTamVBUDIrRSs2R1Fla1AxTUF6cGdaL3RNbm1GbWhTSmFWdnZTU1ByTkxlTm5lMXlqcDdLLzFRaEhZSVQ3NFZMZVM4Ym01dFZYZVBjdjI2QlJIaWpsZmZicEVyWkhlRldRR20zUVZPNWY5L0h2d3dBQjdvMDk1RFRJaXpBR2FMKzMwUnFlM2FiTVdsSE1aZTJaWjEzYUhHM0RkTnVEdWtRNC85RjRFOWMxUmdHdngvSVRhWWYxYlFEczlmVlBnQTFHRUNTYXVZWGZhZVNoQW1pcTI4OHdmSThjNjZJVHdmbXpsUCtFbjZlNUdUaVBQQU5yMkpuZlNWZXM2QlhNS0FCdit5cHBzMWwzNHVFT3BwM1Zub0U0aEl4cFM4NG5TMHFUamV5MFFINUp1a2NuQTc1TFF5bFRKWE5kTDlxY2Jub0NCeU1kUUtPc28wWkFPb3VreU1pbVRLWFBpRTExOXJtVS9pVUFwODBwdEpOODRYMDhRdWFaOGN3Um1HWEVhNDJmMzBLV1dSL0x2UEFLcTVpK0dTajMzNkU4czBBK044ek1SZ2VqeEQvOVp3ODVrR0NPN0FoMERxZTNJbGVrYyttR1ViMG52cFlTa3VOTDM0dHNwWHJ3dHRUUGxFczRaNVFQZ0t5L1BCMmlhOTRIMmc1WE1Qc1k2NkM4bytsbk9kY1hQVEt1OGgvdTdmT3dyblJVWFliUHVZZDZIUzVDVytUbk5ONXZZcDhVNUVDV3U3am5LWXNCUFRxZEdyNlJ6NmpxZ1V5OWVpamY4WGZWSVUvNHg3SXBaV1BLdkozMDllME9WOVZFWFZIMWdQRFpUZHlQdWxPUjlkamF0dWdtVVkrZ0hndGt2c29vY1phK2pCSjk3YWpqUTY5RFpGdG1ybUcvRXMwY3djOFZQRk81UktQY3g2d3g5OHBXM24rZDBvb1R4b2huVmYrcjNnKytZOXRhMytqMTdLbXJBTlpxNDVIMlJ2ZTlSejlYSHEvN1ZwM0sxQkYwSCtiRXN4STVqZG1uZEs5clppMmxhL3lNZEpWWE84YlV1OG5wbGJhQW9UbVY1NEZTZjQ0QWNNZlcyYWVMNmZ5SWZFNCtUem1YOGs3SDhTQ2NvWFJPMUs0aGZVek8vY2k2TGE5NVlqK1dGVG9KWkdkanZVWkNIVmI2NWt2SHI3eGdySzFjMTVXT1VoTmtaOWozdHF5WjBrczZoYW5URm4vVVFaOE9TME8wYTRvc1gxeUVQVThldWFwODNybC9uWVhSakk4eDB0dklveXZKVUdtMDROODBCbEFvR09QOUhNdFRTQ3BvR0pDM0FmREV3Y1BiL3Y5MGNYSjhBVTg3N1gzandKZXcxTUZ2SVJ0Yzd5QjdFazVnNllyVk0vd0lCcFN5UEVMMnNBU3lWNkI2MUQrR2dZRzNrRk5LTHBBQngrZGh3UEllZ0c4QitDdXZrOEs4UmphZiszallsKy83TStjWWptQlYwUFU5K0YyOXlNSTJoZjlCTUZkTHoxM0d0Y0tEb1FyZkhkaThBQ1ZUWFR0QWV4Y0dnbjdmMy8wNUdPRDlGWGlhYVUvci9WZXcrZnVVLzM0ZFlZL3FlSmgrR1JsNC9wcytIOS95Uis3NGZId0srVzVpT2diOEpmSSsrQUd5RituUzZ6djNNVEVkOXZ2czY1YjVTZjEweDRubi9IMGdHNkZPQWZ3R3NyUERUWlh2d3VidHpSdXU5eWUyYkJNZWY1aEYreVlNZC9UN1lWelIySytnd2xiZ1YrdHNQWVZ5QUR1dWt5NmpVeUtvVXZsT0ZUUFNaL1ZLVm8vWHdTTHZKNkZHaEZXT1R6MmRCL3RkWWNZVG9KcUc1ZHFsSmh6OWtQYnpVd0FITlVONkxHMTVqOG9tR1BSVWZxQmd1eFpCaUFKbXJMTWorRGJsL2FZMGVIYjRtNy9MOU05N2NLVkE2cXZPcDV4SkNwdk1Rc0xvaGlJU3pwKzlvL1ZYQ3VlQkVSdlBxbEMyQVpDalYyc1B1b0dUb01kT3ltQUFmelJTWVNLZmphMnJFTEs5YjdyZUY2M2ZDUnBlVFFZbkFsOFYwQ1dDcVBST1Z4b3cxa0VtdHEwZ01QdTY2YUhsS2VyRDZjWGFEY21rdHlreVhlZ3Q5em1OTy9GK25vMlBKL1VINVo2ZWhQOTVEalZTaUZFam5mWHlOaS9ha0tKTERLelJrMW5mNVJuU3N6OUZDUnhGNXg3eWhjczJlMG56dVJXNllDclhVT21PRnRJaDFqOXpKWjEzMWluNHFZYmVOYkx6SitBT3NwSE8renpRRTExQjJ4aXRQVlE0RjJyZzVaNVZPc08xMHZzaml5SktPMlgxRkhIazRCRDN3eUtNbmNvOEk0TzA3cUU3RStsUlQwTkJOTFRTc0VmZ2x6cVJuajNXRThlUzdrSnJjNXBjNm54QXZ2TlFVMkp4emxORVFXdFIyZWtLZ1dDQTFyN3VJenRDOE8rNGo3YzZtc2g1VmtjU2phNGgrTXJ6WFhoeFA4dlM1T2lLZlppdXNxMW85Z3NDTUN4eC9YaHV1ZGFUZ1gwVCs1WFNWb3J4cUEva0lTM3FHSFoza0k5NFBra0hsZFpNcEoyaC92T3N4YWp4bXk0RlA1ZCsxZ29kekVmTHlDeStSL2VkbDdCTjh2TmtIQndqNjRwQmNDWG5SZWRvMGNQUDFmbm1zTFhJbHBpK2xrWlpBbWNFWjNuMUZqRE9pSitBRStUOXUya3QvWC9pYlU3anRXNWVvVURhVEtCc0NlT1ZRL3o4b3MyUmdtdlVvNG9PUlg1UVlLem0vSElCczFjcEQ5bURnUzBkb016UDJTbnluYlFzZEZaU1hTZ0JJaWlON3Vxd2xWTEF5anZrSDZUeFRBUFA4WExPQU5zZnlSRkFEUFRjYzlFWlR5T3c0VzN2TmZucWdFN3FmMlI1UTlOWFZoM0NBbjFrbEJrZ2dHaWMwMHFoVStvQk1paXVQREk2bUhIOE5YNmVRTVcyakhna09NSHZOV0piZGFaVm0rLzA1WGU5SUVXVDd6clZ5R3p0RDljM0dhajlxd2hjb09mL21JMUIwOWRUTnB5TExCWmxYYVoxamhHSHVtZFlHRjAvUS8wNm1zSVpzNi9JZWRhUE5YdVExaFB2K3Y0Z0N0ZGlqTDdGZWFKY3JIYjk5RGwvWEI0a0xSL041NW9jMWF1Z1Z0KzcxTS9uQ0JINkkyZzQ5d2RsWFFXNjJPWU1TRm1VaG9EZ2FHTjZKb1U2MzhobjEwSVBkOTVQYWp1aGZJVzhYMGZYMTJPejAzbGM5ZENWZEk0cE8xYjBEczJjY1FtTEZKMmdkRURvaXpBbUxkSXpFT2xBSndOYWtDMzVmS1E1NU9ua0ZTa3lYV3dVaFQ1ZW0xT3hEY1QreDM2eUR3b1NwKzhHYkRpazJmclp1czNYNGZHOUlrT0NsR1NYZ1BISHZqdCswNXhWYkdmSmdiTjJmbVh2eGJacjl0OWtpK2pab3dTRlI2VmFiL0pWQUhTZzQxa3FBUCtCOTVPZUZ0WlM3ZTNFSGtkZis0Y3dwM0xHT082YVBZWXlML1E5am44T0E3YSt1UzAxY0tVakZPajJZRUlKRVcwMnhuc2dOVVhaVUhrZEJzeWRIdDU3K0MxK3VEZzVacFRrR2hZZCt5bVlnWG5tLzk5ZG5Cei9CWURYNHhnQ2tQa2VnV0pKTDcyQkFhUHJ4Y254OXlGQ1NieUQyTzhNM3ZBN1R6ODhQYnozOEozRnlmRzdQaGVQa0ExQno4RWlpbW1rWVhUdjJ6QlFjZ2xUcUxYUEJCd0JpNERtNW5tRVlZQ1F4b2ZIQUI3NWVIZ3Y3ZW1PYTV2S0NJQlROM1ZNUzBQUFVoWHdTYVFPWUtBdkk2cGZSeGxOdTBZMk5uekxuKzMwSjBZQWUxMHZ3VURsTDNvOWZ3Q0w3djJlUC9NRDJGeFM0ZmorNGIySFQveSs2dWRnYzNncDlTMWdkd3AvRndieS93Q1c5cms2Tjc2M1pvZjNIbDZHejI3RGdPWTN2SjNQd2ZieHgxQmYyN2RoWjR2ZjhYREhzL1FOQUordGZQNmU5emVtSC8rdzlKUWZFbGlXeXBDaHBQYjVWZm9yakZXQmw4Um9SeHBxSm5BQVJFR0FwdUlWTjdaUFd4aHlIMENpWllwOHB3dUZJdktmUTlnNUhoVFNZeC9hSE4ya2R3V3JVaytCWXBlb25BUXd1ZUIwWmNWQjUyMnNnaUR2RG5yU1hiTWY2MllMK051YVZ4eGdBQURua1o1eWEvbE4zajhOaWdUcGQrb0Q4bDJGQ2k1cWVZeDhEOXNHZFNDZW9BUFh1emNsVkUraElWU0YxdzI2SUJZRjhIMDNGdTQzWFc5bjhzZG5tc0dCUU9FT3IxdzFxa2VORHBRTEFJa1UyNkh3L2JUT3JYZ1Y4enlJOFgvVHZQcUszbmNGOUNnVEtKVWVDdi9SY0ovU09Ha2RvampITmdybGpmM29VMGphTWowazY0a0dxSTdYS09tUi81M2VsejZsYUh1WnY5aFBsWTlWSm9NOHY4MjVjdzJibzVrWWFUbVBHbUdUNUhBYUJCd1VZbnBJOWtuQlVjcVdkTkpJeGt1WmgzUGtxMnBTQ1VhMzVFRGlmVXpSV0VMUGxFK3k3Z04vaHFEem9mZVBFVjQwSHRHZ2Z4YldsOUhEeTdqdiszZ2g1Nk41OVJVQ3BremJSVHJDK1dSRU1kZTdFLzBrKzV4S09Pa1RJOXBVUnFESGNUUStzRjN1STAxL1NzUEFLc3hsQW5tUURhSk1GNjU5M2pUbXdMRkU5a3FuY1lmM3ZkSFIrS21NNlpiTENRVllMZDlyQ2xoTmJjeHhjTi9UQUt4RzZwckRBQTJlS3g4Lzc2VmpXU0liVFl0OUZjcWVHei8zMnZzUENEekhLQWJkR3gzRGl4dkxkakVtOUphMjlLSW56ZXU5YjE1NEw0MFFQS05jWXlEVEhJMUNWRENnY0Q0VVExL2lUWlgyTDVCbFBxQmlqQkpERGo5TDZkQkdsdWg0d0JJZEF0UVJvOCs0U1g3K0xKMjVDbjQrVXJZbUdMWXJUOWU1WlBRVzkvbTI5T0NwaU96SDg4OU1BbnBuK1JSaUZQWTJWbUljNy9DbE5rY2s2enJ3WEJNODR0N1lhODN4TGNwYW1pRkE3UjJKdHdwWXFTbjBtWnFQZStjUVpjUjZNdGpKL0JSblFPWW1SUTBocnl2cFZJeFFWcmtLS0RQbzZMVXNTbTg1TDlWejRlTll3dFBweXh3OVFubXVONUQ3MG9XZnAvVkVwcS9hTm9NOXlEODBvcDcwZ0prck9oa3NaSjRUVFhINUttVWFVWmtwNnBKQ083bU96THlUNXNucENQV0xRazRYNDNtazc2Yzc4UE5sbTZQTnFkc3cwa29kQUpoV1hPdFNtZTNBUDF2QzZJM09GL1dwYWR0TjlSNXRBVk1mMDB6K3JrVVhLUjBuWDJJOXlzODV0em9XZlYrZElsZy9zeStRcjBWNnFqdzZ5ZmtvWlJXVkhTT0lFOHRFK2pscnM2TXJ5MHBzSEVNT1dBU2taejdQSEN2bnBWcUNIbjJqK2psUTJHZlFiTW0wMFpZWmU5UytXdVBuYXdBUjVPcUF2K1RGMUgxNitMbktERFVuZWpwYXFIN2VvUWtEaFlCT0xHclg0WjdoNTh0V29sZWxMREc4RDI2czdMSVBydG9mdFNHSjdoanA1OWlpZW1hdFB5cjdBeWp1a2wwaFp3ZUsvSnhuVXVVdS9xMU94MHh6SFBjNW5XODUxbzRqU2lOT3pHTFBLdVIrcDAyVVpmV01hT21MbUo1NkhUVzlYMjFEdFhwVk4yT0VLZUx6MitRK1pKMU5IVlExd3dybkkrbDVyRlAwK1dLdXcvaVVWdFpzY2RTcmgyUmg1ZWRGZ0JHTDdKZFVSTzZncmorSHk1SVF1Uml1WC9TY2w5cmE5VjduMEdQSG9kektNekNWbjdVOE0xU242bzVyQVBFdTR6NUg5bGpYVk9qeXJQVTdxdWN3OE9pYlF5L0g0Z0FvWUlJU1V5T25DRk8vNy9WOXIvZlRQZFg4Tmd5aytpLzkvVC93dnZ4RmFHdmprYkV6Yis4TUJzSzlnQ3hnL0NJc292ZTl3M3NQMzY3MGR4bitYeTlPanRWREV3clk5WXk1T0l3K0IydjlqdmVuZW9UMGl6Qnc3d2tzK25RTlMwbDkxOGZ5TGpLb3FQMWlPdWwzL09PNWozVUlBSDRYbHRyNk5nd1FmK0x0OWQ1Sld5dTh5emZPVi9oZUFkZGIzbGVtVzdzTFcwdmVrVXREM1NVc0Vwb3BzNy9vLzU4QytGOWhleVgxMDhIM2QvMEgvbHhLKysyQTZndGV6MnMrWnlUR1I4aDM2VTVoZDFFL0Q0c3c1dDAxakZDbVlRbklRajJWbEZzQUZ0Nlh2eDZjdUxKTUFCejVYZGdLSkx6di9hTzNOZmZweDN2cTJRUHcrOTYvOTJIbjdDNHNSZlVsTEMwMVlIZENSL0Qza2IvekF6Z1lzamc1bm4yWUN2cEh2NHhnM05jcXFsUkxteFRncTdSQ2xBRXF4VWw0RW9WaUswTWJLc3JVZ2hGd2pBQks1a3FnaDBMQkJ0bGJzSy9kb1JRc2FsUTZRazdSbFVDaUprVHVhT25wTS9zNWhRbGdhcGdaTGVoWDlra2hnUGpjTWRWb0RhaTZTYVZsNnNJc2hicEJNTG90VStqdXRmbU9SYzROaFhSMUJGTHdiSU91MGtlUDQ0NzNzQXVBVENuMHBMMy80SzcvWHdoMGJZNFkwSFJqbHk3c3J3YjJpUlkxWXZDZVR5bzBHaVh5Vkl6VFI3QTVuRFVPbkV0ZmRsSytSRW5pTzUxVVptRzhqSUl0d1BSdFJ1T3gvYW1VWklqRGRoQnhxRVJ2VlhwS3gxUngvRWw3b3lrOVlIV3ZrczVGQVZ0cG0zNVhPQkQwekZ0OFBzMmZLalY4VnhRVE5VWk00S0Jsa3lPRnF2dFJqTFZLQzJqc2p2U0NmYU9SbTNNMlFVNS9UbVZURFd3eGJTQU5lWnJTT2hsUTJ1dzBwS2tyVlRtcU9mbFFWbEVnU0QyZDFjRW5HcHBvZUZpRS9uQy8wUWkwQ3U5Mm5GVjlEdlVPYXpWc0FPVWVBOHAwa3B2d1hqUldkUXhoRllNQURlS0FBTmRPeStqc3BPMlR6Z0EyMzlGN252UkJEUWxBTm5vVlVhZXN0N0xYRWhnaDc3SndIdWZlWndMZ210cjdVdXBndTF5VEF6RW9rSThUQ09iL0U1UXl5MXplcnpudE1PS2E5VEx5a1lDY0t0STFvNVVhVVl2NlJkN2daMXg3Wm9CUW8wNmZ3V01HanpvT0NqNzMwZ3g1L1R0cE5uRkQ0Sy8wWlFJNWcxdG8vb0U4cS9zK0d1T0JQUDVMcFlNSW9BcEUxcXljQ1pWMUxoeE1RUlBTbXdzZGlQTTUycmdlNU9VVTNkZVdhUVlaeVJ3ak9ZdjBmMjZBMllsL0NqOWdXNzNPVjRIdXFrSDFnK0RuQ3BUdXRBOUZoazUwbFRKZWUvL0J2dkFGNWZuS3ora3dGR1ZQUnZxcU1adjlxL0ZDVFRYSWVZOHBERG5HUzVSeUwrZEFIV0RVYVlWMFpTUGY2MzZwR2lLRm55YzVzTTNYbWVqWTJNYzF6TTZoMlJ1bU1Kc0hlZmlwdkg4T296dks0emgyT3N3bFlCSG1aTU01ME5UOThIZFNGZ1RsNTAyK1k1YnpRYkNhNTRpL3lSZmlQS3doQnVxMmpFUlVoMC9scFoxSUozNHU5U2k0enNJNW15SkhzUmZ5b3I4M2I3WmNlOUREejNrMTI4TDNDQ09ZbUsxQ3djNDlaTURpYVE4L1AvS1BsSWVScDZyTXcxS2pmYXBuc040MFhzNUhXenBKcUc2dG1VZjAvVFV5UUtCN1ZOTUhkNHFzQzl1T1JuNEY3S2d6YXBRdFAwOWdTV2lDZG92aXFoWDVUR1VBdHNXN2hYbCtoN0o3Y08ra1RCWCtIcytUT3IzVjlQRWJBWCtsLzBCMlp0cW1uNnNqclVad3g5K0E4LzNZMXlZQWI3S2VuYk5DTzQ4QUhKM0lUM21PZWdDUW5ZV3V5cy9aUjlhUjVHenljMi8zQUNaN1RYVmNzcmFqUzAwWEdlcDNtSnRuWGVMWjJXbHNvUlQ4SENneVh5a295SGxJam5GeS90UUJHc2dPVzFxaWt6VEhNWVVCOThyUDZlUzBrbmRKd3k3UVBkUEpVZFg3emJPdmpvbkt6L1VxaGw3YUVNOTZrUEdpekt4WjcxVGUxSGxOZGxqMDJJc3FNaUNmbjNPdXczbmpPS0tUR3R1TWFhM1o3NlFmTy8rdnprTkZyMWJha1BaTzFJMXI1NjFHUzhJamlTK0ZaNkhQdGxlNG1rLzJGVkRLaWtrdnJQUnYwQ0ZZMWxMM3hLek4yUVdUWHRHV3dQdFFtY3A0Wi80dTVyQ0l5VS9DVWhtUExnNkEwbU9uWnZRNmd3bWFwOGdSckxlUlBlaSs3OC84SzJTUDYxOEU4QXVMaytNbE1raTNCeFBrUHdZRHdCaWgrVFlNUU42SGdZRkhBSDUrY1hMOFo0ZjNIcjQyb3YvS0NLNWE1ZzZFSnc5SUI0VnZ3WURPSlF6SWZlU2ZNZTN3SEJZZGZMUTRPZjdHNGIySDZaN0V3M3NQMy9aMHdVY3dnQml3dWVzRGdaOEErQk5ZcEN3anFFWVRicm5IbDNQeDhjWEo4WGQ3b20wbk1tWWEzbmpITDRWVUdxQkkvRlZCWE1IV25POSt5OS9kR3dJbkpXTDdFNTRlK21Pd0ZNOGZnWUc3ZndZRHdDZXd1WDdpbjhQbjR4T3crZnVHZi84WU9VMzJ6SUhsMWVMa21FWWgzcC84THNhbFBVdkY2K0ZkejdmOVorRy9Qd0Z6aVBpQlAvNTUyRjNWdGJJSEEzbS83TS9zd2M3cUtjeXg0dGQ5UEU5OWJPcG84UjBBWDRVRDJMNTJOeVZNZmxpZVVSa2p3RzR6NWx5ajNZSkpCZkNBd3BnQ2QzMmdTSFVjUS8zZTh2bVlzYTRSRkpFbWUvSjJEQU9oalNHR1QrY1ZJSHVGRXhqWitVeUpVVVFGNDBoL1I5VlpFY2dVOEtTd1NGck1kUFBQcXFnaXU4MFRUZFB4VVpBbTJFc2pZZ0poZGhESVdHZUtjcEM1anNMdGt5Q1VNWktDQm1TOXI0eHp1R252UDNnNnRMY3BmSXFSUGhtNDNkQ1RJZ3hiaXhaVEFIUU5NVUFpODlCcGEzZmhqYjFMbVZHSUtwRDNnUTdKc055S2gzUEZhSlc4d2E5SmV6UkZreW83TzZkRVY2QWtHUEdpSVlleVEvWDlzTCtVbHZFM2pTYVJCdEtvbE9pQTlMOXF3S3daR3l0alZxTVhrTy9IQTl4b2pIeTJFK0NoUnNoS25Rcmtxbnc0UXpad3NtMzlUdWtTOTFCTmFWR0RoaXIxSEN1Zkx5SjBJTWF3dVA0NmwzNTJGTXhKWHJYaEhPczYxKzQ1WnFHSGNuVDZMQXdXYnZpaElUQVowWnA4SHpqQytJcG9FZGJuL2RDOXhWU0RlL0FvRWM1VnBVODBUdkljeC8wV24wOUc3NmE4MTVCRzhyblVwLzJkb0hRRVNBYUY4QndqYzBndkdUbDEyWmdEQnVuN0t0UURsSGVxRjVHeWJVNGpPVUYybE9RN3krYlZWODVhdStPUG9NRU1KV2pJK2VUN3NWeDRudy9rLzlwZDBkSEpUU084VklGZndyMnhSVTdSaUVLZU44NVQ3ejJVMGRBcG9BL2JUbEdQWG0vdHZIVDQ1RFZreFJUMTduM3VkUlpyY3lZUDNkOEtZR3dnemdFNzhQTXBrSjJwZ3VFbjB1MTRIeGIzdVdaeVV2cEhmbjYrYlg3NndKMWdkR1BLT0JxVldLTGhoK2U5ZWhkM3BXMDlyeDBhV2lrS3lIQzh5WEFtTWozMzZYVkJCbWI0WXIvWWJpMXlhOXRlWktwM0doN1p4OEk1VXVZa3JzZDUyNzFYY0IyZTNhQk0rNno4UE5GNUFYbklieFNVVkRCRnMwOXd2cy9FSUtwdGtBWnJDdXE1OFBOaVhRTS9qMmRHb3lncDMzQk1qM3h2NnZ4UW5sUmQ3aWx5UkdsY0Y3MTNHTWk4Z1lDNFJodHpmYWlETWNLa2F0eDBlc2JzZ0x6dmwvUzBGdjNNOXpieW1ZNlphOVNYNlNMcEptMk9IdHhBQUVyZk8ybStmZTdXOGk2am5qU0xsTks3R2JLanppMmZXL0M5TUFWOFp3WFo4ekxHU0JkVzdmMEhGMENLVGlYdjQ5a2ptTDRYMzBPbTR4cHhYZVBuVTFqMCtrVmprVk5yQjBJNEYrb1VwMnVhSEtmQ09EVWltMjJ5RGpva2N5ektiNk96ekpCVHVUcjJjRjlIZVNZWnpORjEraWprVXNvd2dVNUYycXYyaE43N1VLTU1SeUJBeHFWWkVmdjQrVTQybEMwbDh2UGU0bjNUTk1MSzA1V21BZGpxR0thbDJDZUJueGNaMUtJODVNL3lybnFnZEZCTFRvdStmNi9EejlOWmJITTJJS0RrSDZ3bjhRNC9LMXV6ZWdTd0NLalEvZkI4b25NOGozMzEzb1JOc0NrQjdVTGV3dTYyTHRXamtoN2c2NXdjWC8yTVI5cEZaKzRJeVBFOEsrMjlESi9ONUhQTk5ET1IzK1E3UUplZnExUHlHbkpGZzQrRjlDcnBvRklIZ1dJNmlJNlZkZldjcVE2cXZMOUtEL2oza0Z3dFo3bEcvNUsrVXFGQksxbTdYcnFoZlJTYjYyaGJrZlNQL1VMZisyRmZKY2VQY0s1algzV2NXdUsxSDdybldhZGVRMVRyRS90ZXRURlg2TXdHQTFIUElqdXEzV29DdVU0RjlYWHMxQlAyQkNPeXRlN05aSEZ5L1BjQmZQWHczc04zWXlVM1VUenljT1YvYzNBcEVnWjJlRjRBOEErUTc3cjlmNUFGeTNkaDBiUXZ3MUlGdnc0RDhRNlJGMmNKQXdWL0RSYnArYjNEZXc4ZlNSOG1FQUhrcWltUnQ0eFRoY0dQK0ZqbUFMNEdFd2pwYlU3aDk3Wi8vdVR3M3NPelVOY2VnSC9wNDNzVFJsQStoLzd5djhPaVZPbUpUUUowQ2h0djcrRWxzQ3Zwc2o4S1N5UGRpWWoyOVdOcU8wWTVuM3BiTkI0eHpUVTM2dElqbTIvRG1QZ25ZVkdydHdIOEtTeTlNdnI2NlAxajFDeFRSLytNdi85eDJCeitPY3daZ0h2bEYyQUFNUWswdlYrZndnVDAzNFdCcEpjd29QNE5sSUwzRkFhMnZuTjQ3K0V1NlVYWTUxcytENS94L240Y0J1SXVrZmUxUm1yRThzZklpc1JYWU42Nm40Q0J2bDhCOEg4RCtJLzhtVXNmTDhzakFQL0JuenZidHRjL1RBLzk0MVZ1U3RnYnFoK1YrNkJjSUU3M0l1eGd5Q3ZxL2dENkhqM0Zrc0o4SFNPcEd3OW91TmUwTDBrQUdGbFBqRHhVQnA0QWcyMzFqQ2x0VGtPNlJyNnJjRlVSbUo1SmFjUGRTOTdtYmVSNVczbS9GR2loWWxVMWt2YXRWeXZwM2xCR2s5R1lOWlRDOGxZakFLdjM4eEJad1dRNjJnc3FwNktVVWlHZ2NhaXpyc0dveGY3UXFFZ2hrODRGbXFLUWluQUVzSHRMYS9kMnNuM09hWFZQdFRuRkd2dlppUUp1Y3dwbEZkS3ZIRzFHbzNtVDA5RVFqRXNBeTY1N3NzMlIxSVVTcFhWNm03MzF5djVSZ1g3bnMxZ1J2UFc3TWYzZy9sY0Z0MGlMQmw5Yk1hYVF4aTFsWHZWdVRCck5FZXJRZVkrWkVsZ1gxNS83bkh1VENna0J1VlhZUDR5RVdzcTdTZG1VZG5WL2FiOTZqUjFBdXVNdXBwNVhqMW1OeGxSajc0WHN1N1g4VHBGZEF1N1FVS2NSS3l4OGw2Q3NHZ1k3aHFLbWpCQ2s0VGJOdGN6UklvNjl6ZW13VlRtOHFCbnpoSFl4UWxoVEtDZlFwelVIRkJwUDFMT2VoZ3ZxYVh4MzJwVEdPenJOTENzR3UxdnliMHgvWFMxdEJvQlplQTdVWUUxakVZMHVUNE5CWUk0Y2Rkc0JObVQrSjdCN0lIbS9wcDR2MHN5eGQ5anZDMCtZb295dTNzRFdmcXZ6enBZMnFMQVRjRkU2UllOQ09wL1BpciszSWZPQXI5a2hza0dOZW1HaTZkNFA4dmZlTmVrWk14REFHamh0alBKcGVIZS9zaWZwbEVCd0VkNGZCWmpWRUhrNVpoNkZYcXNCU09tZEFod0tLSTFLQSsxMFZBM1FhL1FZeDZMUm1uTVVESURKbVVoZVBlK3JjMFQvZUhab1FKM0RhRk9hVjg3akZyNm50RHltYlFaRTVoaFRGL0k1SkExYm9GOE82dHVEaVU0TWpMM21oS1RSdWd4ZzROcWRJYWM1QmpLdlNnQ204SWRMNXh2NzRmc1pMQmdnOFJ6L09mZm5TU3RVWnVOVks5empoOGhBTUxNUFVONDdnTWk2M2lidGJYUnVaLzNrSzZRN2Q1SGxoQ1hjUWFnMmZ6cG5VV2JxNGVma1Nab2ErRUxvSTgrWDhuUEtNZVJacE10NlZuVC9MbENlMTlvVkc3T21Hd0ZGM3NVNW1zRjRac3hzb0dkNkp1ODhyZEVFMFpsVzNyYzczaGF6L0pHZlA0OFNvS1RSV2pPa01CUFNNdTU1QVM0NjZ5V3lYQzN6UkxVSS9TNkFQdjhkd1Z2cUg5SG1RSnE4VmQ4Z3pRODBFQkNRZFV6ZksveThFNms4eEh2R0ZLSEhDazRweitEOFRKb0FtTjR3UDYvcDV3a0FRM2JrbXdJNWRUTmtIKzNRVmdTNTlKeE9odGJHNWQ4TDZTZjNLaDBLMVRsVCtUbmxacVZUeWg4Ny9GM2swS1c4cXlDaDJtODYrc3lJZVRpUWY2bnJEQUhBYWE2Q3JFdStHcDA3Qm1XalhZcktZTmZaZDlKSEZzcXB1L0J6bm12VmkzZlN6Ni9JejJ0ME1qbVZDYjlWZVNycHgvSU85Zk9xTENROElUa1lWZmhPS2pVNWV1QnpudDg0amtoL2dNRHpuSjd5dVUyc3AxYTJ5UFNGalRQTTNUcnVpYUN6Rlk0aU91YTJtK2xqRFdSSDBhRTkxaU4vY005U0pwaDYrNTJ6RmRhbW9OdDk3U0hUSDlLL2VCVVVuYXhWZCtjY0pYcTk1ZHhVZ1hpUjJWZnFyZkJNaWdKN0RrYnhFTy9CZ05KREdIQ3JBT2Z6L3YwWlRFQ045eXJSTS9RUkRJQThoNEY0ZitpL0dUMk14Y254UG9BdndBREIyd0NtQXRaZXVjUTZ3ajIwditUak9ZQUJpWXoyT1lkdHBzZXdDT2duQU5ZZThZdkZ5ZkZrY1hMOGVRRC9GQVo0ZnhRWjNCdGl0cjhHRXd3SmtsNzQzN2NCdk95QWNyVWMzbnU0Q1NEaEhKVklZeC92QWZLOWFtdGtUMVlDbTVjK05ocWZkT014OWMwRkxOcjgvd1h3Vjc0LzFnTnJrdExad2VidUI3QjA0UzBzQXZaMS8zd04yMDkza1ZOUTAwaDEyK3M0OEhuNnV3RCtDWURmQXZDclBvNDlaQ0I4QlZ1Zm5SbXBBOTB2d2RidE4yQmdIaEdUR3dBQUlBQkpSRUZVTmFOODU4anBlbXBwbXdFRGJyK0NIUDE5Qm91VS92OEEvSGNBL3IzMzl4ZGhlK3dYVUpZM2tkTmRkL1pwTEIrQ3YvVVNHZTVOMXkzQ1ZlMjd5VTIydjB0ZHppeHFxVzA2bm02NzlqRW9HcDArM3RTWUtWUTA1ajIvYkY1OTVYeXNnSzUxdFBjZnpLUlBhaXluSjZNQ3Q3dVdHQ1VEM0NENEN5UkZsUVlpR3AxVVVKcFZCS2ViTEhIT3lmc1ZyRlh2UWo0L2JicnBISGtuMDFGNy84RmhSU0NteHp1VnloUzVpKzFwRStPZFhsVDhqaUNSYnRKUFBoT0YvbzIvYzRSTTY0OWFTMlBJZVNiNFMwR2IvVjdJNXpTZXFiUFYyTUxJTnQ3bldTaTZNbWJ1ajZSZzZqTXlYK3FnQU5UQnNOR2w4UWdELzN2VnZQb0swNlR0dTNJOFJCZW5QWFJUb3pLU3dVZkhza1ZRVm1Qc0JBNENqbEIwU0NQNitqenRPMThjUzN4ZjZKUWFLbXVsRnUyZy9ZMVJkMHVVS1lwV01EcStKNHFaS3AvYUQxVzhDYWd5ZW9uL3g3bGlYZXgvWWRocTd6K1loM2xqTzZ4N3ovZEVla1lOSXI1WDlsMlpZYjlvOU9Wei9Fem5pYlJDSTJKcjY2ZkFCdldONlBqRGZVWjZOcThvN2Z2STk4T3lIUnBvV2M5YS91YTQ5NlVPR3VGSU85ZXdOTWx6R2I4VzlYYm1Pa3pDbmxaZ1ZRMlFmRWNOa25zd09rYmVsMEFMR0ErNUZkYVNVWFpxV05oV1pzaTBpM1BNL1VLK05Xa3NiZjhhQml4SC9xS2dZVHJYVGp2dXdOS1gzb1k0WDdyaXpmUEJ1ZGdBS09RUk9hdHorZXdBRnIyVG5GcWtEN1VvNVNzVnA1azh2NXdQalVUZ2IrbzdXMmxlcll5UXY1TE1Jd1pkcnBIdVQ4MElBRlI0c05ER3ZUYmZ0VmFNR1NWTmlVYXFvVkxqbDVUZHlIK0xDQTNoK1dxa2hyYzU5VDNFdnFyc200eGpNdWMwN0hJTTJsYkgyTE9sVU80b1V0MFA4SE9XbUVvOHlaZ1F3N1hYdlg5VnVkUGw2MHNmTzY5L1dyWDNIOXgybWpmck1YaE9aQTlFd3lYcEIvdFp5QndqK2twbmU0Ny9iSWlmcXpIUzExY2pjOVA4T2wyK0hkYWYrdHArYXlEcGN3Q2VFNXBBT1l6cnlNd0djVy9yLytTbnVvWUpPSEQreFd1ZTlMcVJpZE0zQlN3SUV0YjQrUVptR3psQTV0TjlXUlNZM3ZvTzhwNC9oNjNMWFFEUHR4bGNMbmlpeitjc25uT2RSNWZwRDRXUFVJWS9RT2JGL1A4QUdjQW1yYUFoVzBGamxZbjRMTStsWm9EUU1jOThqTGRoWUVIY00vc3d1ZU5JemgzNVJ3S1hrSGtJWlJubDArcm95dkVjYmVIbkszbDNCVGVHUy85aUJGS01UazlyN20wVXNwWE00ZFQzc3RJTzZnazc2ZnpPdDlndjNlUEo2TzgwZy9RdEZwM1BvdWk4K2ppb3Y3QWVCZkJxNzNmMGlWWlM5N1Avb1M5YS81V0wwMHJWLzNWT0ZXQ2Njajg4STM0ZStVa0VNaWpmVHVOM0ZjQmk2bXR4ME1QUG8yN0dINVZEKzBwQnU1dWNJamJkRjQ0NlA0ZTI2Wjh4Qzh5c05XZnBReGlONGo0ZzZFMWdsL1ZxQUVHeGRqdmFsc2dQa243ZXQwNGlQMFJaU01jWDkvZW1oNGJzWEtpckU2Z1N2bGd0YmI4TmIxMzVyZnJwdG4wZGRjenpIZlR6RGorWDcvZEl4OXNjV1VsWmp6cllrZTlwcGZWcFhXU3VWUytzamtuWExPaExhT3d1K0lTWjBHYWo4em5tL0F0ZFUvbTBCaFJ1VURwVEpmb1AweTBQWkU3VW5wTHMwM0VNb1IrODNpNzFDNW5uemVUOW1yNFE1NnJEQjdpZWZFN09xUUxLbk1NWnlqTmU5RE9NbHlXZTZZM1UxN2N1M0dON1EzT0RjRjVScHdGY0M5WWJuU2ppT0RydENmZ2Q1emJ4Um5vVW44V1huMFdSTk1MSmlBSGdQMEgzbnVDZmhnRllDeGpCWm5TeWdvb1hIbG5LZTJFbkFON1UrMnM5WXZVdXNwY3lCZGluaTVQandjallFZVBvRkxtditBOEJ2T2JqdU9QOWZnb0RmTThVZE9PY0xFNk9EMkhScUo5RFY0R3RSZjlxU3A1eldHVHRYOEtVQWpJTmVvcE92SzBwRE9RY0d2Y013SXVMaytQM3cxM0E5SjY4Z00zOVpuRnkvSWFQRHlqVFBxLzllOEJTUnErOEh3Y3d4ZVVjWlpSeFZVanovdDVCOXNCZ3BBTC8vN3IvZmd4Ylp6b3owSXVUNVJEQTkzeHVmaGtHcnZPZTRPL0JnT1BiQU43eWU1dzdESGRNOFRYOHFJLzFVekFBZ1AwNVJWWTJlSmMxWUpITFROSDZIZ3o0dlFOTEZmNG1nQjk0ZjRwb2hNWEo4VzhEYUdRY0xCVFdDWDR3NnZ3bnZ0UU1EVmN0TnduRVZRcUYrNDVRTDJCTmNWL2tCOVF2dHJFaWt4TUd1Mjd2UHpoRHZ0dHZFSlFTQmgwOXF5TFl3REtGTWNLZHgwamhvc25lc2tBUHM0eDdKSUxTT3YvK0NGTUpzMFFsZ3dwNXJVOUE4RUxqWi9xc0tFZlBvcWlYTEZNZm52bzRyMFRuZGl3VWxxaW9uU003d2FTb05EaFFna3kzYW9WR0gvSWhSckxSMDNmaG55OWdUbVF6R00vZGErOC9lQUcyVG1kQmVlMUV1M3VKSHNDZHlEeU9EOWxMai85elBPVERqQnpYNTJtTTRWN2puaUNmblRaWGlCeHJ1dDc3RklBbmJiNkhpM2Q1ZGFMM0trV0ZSeHJJbG5wZWR1MWpMRzE1QnhjVjhMNis4QzZtZUE0TDBBY2o5N1VvSmdRRXQ0SEZTaitvUkRHVjhjcjdWenpEL2daYW8vTWFVM3hSK0ZjamlZSmljZDQxMG95R2k1aUdUdE82VVpaS2hzRW0zMlduQnJFVTNlc2ZNVG9nQW1aVWVqYlNUdXBiVTBhL3F2TkhOUDVzcEY2ZW4vM1dVeUJLM3d1RnE4MGVyVm9QZjZ2eE14cnZDT3lxZzh5NkxkTWVrcTlvK2lRZ1J4YnAvWTd6aWd6Q2R6WXdSWk55TzQxTTZ0M0xlV0U2V1lJRk9tYktkSWxlK1A1aU5HdmhaZDFhNmtHQzZ2Uk1Kd0ROYUZucVdad1B0cW0vSWMrVFQxNGlSN2ZwR2VhZW1mZzdXK2xZVTJaV1VDUCt1YmRCdVJaTnZrK1NqamFYOElnMTd4T2RieVl1c3pBQ2xmdUFZMlVoU0VKdi9qMlU5MXZTVUVLalBwWG81RUVmZURzelIzUWlROXJzRkxCek5GVmprVnZLTzRGc1NMOXN3NzNUdTVhUnRId2lhOFR6RkowbDFzakErQkJOSmEyT1JuaWVXYTdMcXMxcHNDOWhlNTc3cm9oWWErVXFnMUNVaGswd2ZQZGVMYUpISFVubXNuYmJqT3lKdDBlaitaZ1Mrc0g5T0VYbTU2b3JWUG01amxQa2J5RExocVQ5MTc1cjBPbUMwc1MrU0hyU2hrbHJxVHMxL2VzR2R2OHZRVDlnTzBnQW9PQ3RqRVFmakI2czBHdnlPTjRaVGljWEJhRVBtMWRmZWRwNm11TTJaK0FnRGFSakVkZENIV3FtOGx3Q0RrTWZhYnRocGdzNjFLZlM1Q3dWQkJIWmJ4cDhuOGg4Y0t4Nkpjd1NtWjVmVlBaTjVPZWt4YXVtdkFKQlpSVEs5M1IybWlEYkhtNTVYM252N1VTZTBhTFhYRVFaZ2Z4SjUwOEwrYW55Zk9wdjVLbnBibXdnWFM5Qk9rSitUbDFscisybWxkVzZiN1dXemxyN3c2dkZ0SDhIM2piYlVockhxRUsyUVljSjBuUEtZQmUrMXlnLzBQbHQ0ZlR1S2N3R0JtVGFxZEdGMFVtUGRldlpWQWNGMVd0Vlp0dkRpT3VFd243bSt3UVp5S2NVVktIc25wd2ZHa25CU3I3Z1BEQm02K0hlNTNsUm9JYjE2bjJUNnZoSCtrTjVwZVo0bEs3ZXFQR01Ob08wWTdNNnBIRUx2K044OGZ5dWZOOStFUHljN1Vabkx0VTdwazREaHh6R05ic0VJM0UxNG5VTk8yZThzNTFPZjdNMlo3a3A2TFhMdHJWNWpSazMrdmg1bFAwcGEyaG1qWnArenZZN3dDRndZL3ljYlZCV1VyMW0wNGl6OUphU1pDV2dqSks4aVJMbW9HcjdFN2tXa1diNjM5d1AzRCs3OEhPbGs5c3lhTlgwYzlLdFMrVHJadmpkQk9ZQWQ5N21sUE1LU0ZKLzAzMUIycFVja3VXNzJ0d25rSzk1dFhxbGd4YnlMQVZjayswZ3lISlZHMHhGWnB6VWJDYmtSK0c4cFQwb05zSmtneEJhUFllZDJ5Ui9oMzJTYkIzU3YrZ0lFSGw3WjEyajdWVHFVN3F2WTFycG5JZzh5TFhxNDExMDVrMlpFcjN1aGRlYnhvU2MrcjNHVzJrVFpuK1QvaVB6b3hIQ2FTeGhuZGV0WFRsQlo3Y3pkTE0xYU9FMUFqVzcrcXkxSzVyMDNUbUF6ZFFydnBiUUR4aFk1NEJkYjNIZzh3aVdFcGZlZkJIOEJReEUrNlQvZmVZLzc4THVlVjBkM251WTBqZ1RUUFhmY1J5cTZBQkdvRDRDUzh2N3M5ZUlCSjRBbU5iRzdQMVlJTitOZXdrRDlBZ0dJajR2Z0NQVEJUMGZud3VGa2RIZmdFVTh2K1h2L0J3c1ZmQkhZY0xnRkJZeHUvUW80NThDOE5NNmJvODZWcWIrUFZoVTdVYWZnUW53YXdDWEFtRHpUcHVmZ3MzcnA3MGYwOFhKOGR6NzhRVllGT3luWU1aNFJtelAyWS9EZXcvWGxUdUhiOE9pVzM4Tmx1NzRaWisvcDc3K2w3QW8zZTk1bmUvQkFOTjNmVzUrRjVZSytZOWhnUHdmd1FEak43MEplaXMvZ2FXTi9sbWZ1NDh0VG82ZjI3YVhRMTgvdWpnNWZ0bm5BREFBV084Zy9vNjMrK2NvN3hROThuRjlHclkzZnc4WnFINFR3QnQ5S1p3UDd6Mzhhd0QvSTREL0JSYngreHBzUC93NWJLMk80SXh6Y1hJODg3MjY3MzlmZGQvL1NKZWJBQ00raUVMbHBLKy9WRTUzSFUrRktXaDl1L2F4dzJoRVNhTEhPRDI1K3ZaVFh3UmMwUjh4b0Z3SHdDOEVnWm9RM0daUHNJNG5ZMmlYQWlJVkloWm1GaGpMTDVQUUVqNVRZR0xyZUxmTWNmWFp0dXZGdklaZmw2QkN4ak0rTXpPWXNaU0tud3JkVXhpTlloWUpDcG9YVFFYNDlQWFUrOGJZYjBiek1QdkY4OGlBTVBjQUJhZ2xNdmpNY2pRd3R5bktUVDlzTTZpYW5McGtMcU55QU9SOU1BK2YwM2kzNThiYmpSdnV6bkd6VG5uUitCaVZqRGcyRlY0QlNmK0RuSktZUnFpYjRDV2NOOGp2ZUc0bzdPdXpuZEprVDlCTm15TlB0dlZ4Q0NTTTlkZmFUa1lTMU05OExPcmxud3hMc3E5MDc2YTkzbGlrVlMxbG1CcENBRnRialg0OENBQ0s3bE9lUGRKTnBwMWtCQTc3cXdaZnBkTWEzYlRuN1RBVkw1V1BQV1REcmdKeE1UbzNSdEZwR2lZK28vMmhJWnMwanBFa3ZFL3dFbmFXT0llek5rZmpIOEJvUWF5Yk5KT1JxQ21DS1JnV09NY0VBcmx1ZXpSNitmT2FlazczN3JxeDlKQjZMKzVDNm1lZnBqNEdCUkhZVnpxWDdMZjNIeHk2UVlyelNFV1ljd0IvbnhHaUduVkRJR0tLZkxXT0dteFRab0xXSXVCaWhFRTZOejUyS3RveEtxa292aFl4d2wyTjRTem5NTDZRYUtLQUdSZmV0NlAyL2dOR2JLbUJRWjBEa2lISzY3Z3Qrenp4UlA5YWFWczBEdS9KNTl4TDVHT2RjK1Zua0FBOERmcUQwUlQrM3F5MWlMNGptUE1BNzN1a0FxOEdjd0tBenl5Ymw3ZExReExYVm8xbCs4aE9XbW12b1dJd1ZBTTl5dlhXc3pLQm43L3dPczhFczJSbzZZdCtZWjJGZ1lqRjErS2lNZWVDR2cvWWhCKytVL0FyWDJOMW5GenlwNmRmTzVWZ1pGUERWbFhXcnZCem5vRVUyWVFjQ1hKUWt3a3E5V3pqcHdyT3FIRlIzOXZxck5Ea3FPSTF6REZuZndRL1Z4NERiSEZVcllCN0xKUkhPV2NGL1E2R1RVMzdUbHA2MlZxRVViS2JvTHNIRjc0M1loL1pmK1ZOYzVIdG4ydnZQMkFLNk1mSWZKQmpUMFpPN2oxZjEwT1liZUFGWkh0VUJHRUo0aTY5VGZMenV6N09vOWFjTDVnYVVnSFhRNmxuQ2pkWUNnQkE4SkpubEh1RVY2Q1FaM0Q4ZEU1aXVrL2FtMml6Wk9UTzNOdStLM1duY1huNzVPZU00T2MrSnkzaitXQ2JFLy84b0xYc0VTek1kRWUreUQzQmJEYWNVMTVod3ozQitXZG1RODIrdy9XaUk5cGhlLy9CZ2RDTVJELzhQSndpODZIYi92a2FPZHNFK2RLKzhOZ0VhRFE1QW1qYTNuOXdKOUFOMGkzT0NlMjBtdjJrV3RwS1ZqQ2hrU283TVRYNFpYaE81ZUlhTFNKOTFiVmpuVHdqZlJsek5JTkFsTWNVbEpvaVoyR0orbm1rOWRxZnJYcEdtNEhzdWZkVm5lWlVaMHhyTUJJQXZHcVpBaWt5bHZwcjVDOHFQeEdFcnprWmtlN0ZQYUpBeHhTMkovZkNjK3BNcGxlajhMdWl5RHluczF0NVJqUEtLQ0JKdWFPbWJ5YjlDVmsvMlVQSnp5K2ZFVDlYb0dvS2JJKzJsM2MzN0dQamQydTMvZGtFcmxLMEgzMzdVUjJWZTR1ZmVkWFB4OXJaT2M1QjU1T0tmazc2Ry9rNXY5c0FIYWR0dmFLQmpqUnJwMi9jdXdua1F3YjFsazBGdEpkNnAwRFhucWY4cU1sUjMyUHNjblRzTFJ5Z3c3NWhYNHZvMVRZNzI4d0MzZWFab2xONzFUYURyR3ZYc3JJbEo1YUtmRlZreXhFOWxQd295WmhoZnloZFN2TkVlYkF5Wmo2WDJvVHByMXhEZnM5by9ITmtmcjcyUHFiN2hkbFgwUzhwbnlVSGNlVDlwZXZQTlpvMnBmMGc5VTkwdGlKcUdxV0Q3VDZ5N0ZMTWhaYzE2am9BWlJQVldkTCtuZ1A0SzR6YmJJT0YwYmdqSGoyRkFZYi96WmJuUGczZ3F6QkFiSTBNcGc0SjlHa2NEdUROWVF2N0ZseUo5cS9uM3VlZHgrMFJ4MnVwdithSnVJSUo1bS9CaEwwRlRQanJFRThIWDNub0g4UHU4djNpbG00Y0ljL0grOGh6OHJLMzk3Ny9QNE9Cc0c4Z1I3MmVlN3ZmbHBUY2U0dVRZd2l3SGoxMko3Qzdpb3YrK3p5Y2VYL3V3aFNMVDhLaWZDOThQTnlzZC95WkJVd0plUWtHeU5idVAvNGxyL041V0tyak9ZQmZBZkJ2WVB2MTB0dGZ5WHVuc01OMjV1MU9ZYUR3ei9oOG5NT0EvelVNRkgvYngvbWM5MmNQT1pwNTVYTnlNYlJIdks4dmVCdnZldHQzZld4UFVhYXZmdDNIOUhYWVhiNHNyd0g0RXpqd2UzanY0VklpNVFmM3B6LzdOWjhUS3ZHOC80MzdiUXJnbi90WS94eTJGeTRXSjhjZDBQM0Q4c0dWYllMOWRVRGJteW85OVJFVVU2R21FN25iWk84eEtrbGsrTVc0Z3hBN09DZEJTT05uVkpyR0tFcnFmVS9QdWtSRHBHNWxtQnQ1YndVQlVDdmowSGJnWTZvQitRckFWTmVzTnRadFJmckFOVkZqYlRMSVhhWHVrZTBYNlhDQ1lZdGpWV0V4S2NCTmVkL1lYc1VvQmdjQXpyVC9EbGF4L2x2SUNpSHZLbnNlbVovVjVCTjZOU3N3Y0FlbElWOGRJcWJJNEJZVkVvMlNwQkVuS3ZTM2tZMTBqRWlqc0xnSVl4cGNtelpIeGd4Rk1iSFV4bHdvQzJGc2pJTGtuVS82dkthanBtQ2RQSUpEWGNXOERaVW1SNW5RQU1mUHE4YVhiWFU2N2VIY3pvQ1ViYUdtdEVmdjc2MThWNHFlTjZCTEc5Z1BOYjdIb25kbHN1MlpHMjI1UjRib0JPdU5Tb2Q2TTJ0LytTelhEZ2hHbERiZlphckdHKzdyalh4T1JVSWpsb0V1Z01MdnlEc21LR2xrQVZvQ1JnL2FESml0d3pzc2U4ajNqMUpSTCthcHlkRmtsSStvK0hLT3VNOXBuT1krWGdvOTNRQXA4akVwYS83NVpXUGU0MXdIZXNIUGFNQnJ6YXVZS1JscENLZkNUejY1TDJlTmM2TGoxRDI2UU40UHlhamUzbjh3YnlyM3BydFJpSEs2emc4amVJSFMrS29nckVZU2M4d0hya1F6MWZ3VU9US0l2N2wyMVJUSWJiNXJiZE9hRnpuUENpUHZLTXNQN1gvZHl5dWZnNW1NbDBXQmVnVXQ5bUFSaXZIKzl4VHBKM1NFaG1MT1ArZEs1U0JHOWpLU2VDWm5tSGZLMTBEUHZrSjlWUTNWNURkeitaeG42MGFMR0Vwb0VLbDUrZ01adE9HYUEzNm5xRCt2QnQ1VWF2UzR5WkZQV2xTKzR4VkVOU01JMERYbW9jM09MNVB3VzRFSEdwNlNFd1hyaytjVHJXcnp2Zk1xMDZpUmVhY2lzdHJZc25Yc0lodkhDQVlXMHBWSTExSTB2c3hqakhyb0d3Y0JyU1NqOUR5NlJuWmkyRFp1T3Jva1dkemxrNWlHZEFLamNSb2RQOFlteGFJT05uUkdWQUNiRVJreldQU24waGp1RFRycmtKNWVJdDhqeHpNQzlBTVh6R0oyQ2FRTU1YTmtPa3l3Vk5keWdad3BnY0NwMXNsNTRUa2lIeUlZU2VjZEFwU2s2UVQrbEo2dnZSMUdqNTRqWnplalhId0I0NHNLUkRPaVd3RjF6cmRHbURMaXBubzNKc0ZjcDZ2UGV4MTZuUVBuaVh3eHlhSCtHUXYzQlQvamVpMGJpKzdtOTdkOEhjalAyVDZqUGxlb3Axcy9FRHFtVGpzcEVrM0cvQlI1UFptWjQ4RDVZb2QvT28wOFJhbnY4RjFHWDVNMzZud3I4RVYrUG9IeE9VMU5PK0Y0VVFMcU9sOUZDV3VyZkNJNWVvaE1WZE9KbGNieVo2KzF5Q1U2VUxBdDhqdmRRNm1lQ2tESkRFajc2TklEclR2S3BNemlzV3B6RmlVRkI2dEE0a0FoUDFXK3pjakdDSFI4RVBwNVBBOGNkOHlXVVR3cmU2TW9QY0R3VXVSYUhaY0dFMUIvNk90M3RGY3crd2ZMdENuMVRyMHZsclJNSGVFMWdweEYrWVk2SjIxd2hiVGZPL0x6UGxrbTFwbm1rQUNheWtxK3ZweFh6a2RmUnBUUnhjZXgzakltdFdsdHJjLzVuTm9IKzJ5aWZHNkRITFcveTd3VytrN1lSNHMyWjN4ZzlDZjd6elo1UlJVL1g4SDA4MHVYaFRSWXBGTkVMOVExMFBWSmRGUDJlYkcyUGZaR3BSbXNjd0tnbG1tTTczTi9xQk0yL0ptSjgxenF3clFGa1cvRU5Pd2JHTjlMSUtuVU4vSDZhcG5hT2tYR1NobFQ1UU8xUWNUU21YTzJwL2FuSmp0MHB3ajBZRzliZXB2a1M2dFFwOTR4clAyWXdIVE90WXdoQmgrdGtJT2xlcU8vUmUrSk52UW9uL2Z0dDNUKzJnRjdPL0s2cndBc0o0dVQ0MmxmbE9GTkZ3ZTJmaDNBUHg3NXlyK0JBV2JKZTNJTWFPWFJwOC9EQUw4RkxKcVN3aEM5WDJtc21jQWlrdCtGUjVkVzZ1Smh1d0JTZW1NS25NdSsrV042YXZtZm0yZ09pNlJkTDhxMDJEU2tITUpBMEFOWUJLMUdMYjBHQXphL0J3UHo5Z0g4QzMvbXU3QzdkUmxaK2hRR2NMWStacWJodWV2dnYzc1RJS0JINi80eUxPWDFZMWdrYS9MY1JRYUF1WEgzdkErbmgvY2V2dTExN01PaWhPOEMrRTNZbW5QdC82RTA5NjhCZktldjN6S2ZVOWk2L2dvTVZLY1R3TitEN1lHdndlYm5lZVQ1L1V2L2pFem1GQ2dkQmJ6K1BlL3J4NUc5Ujk2QUFkL1B3VURoai9qUHl6NG5iM2dWZXdBK0QxdUx0MkNSeWQva1hGM25MTXIrbW5uLy9vNjN4elRSdnczZ3IwT2E5TW1IUVBDUFgxR0dHNHdVTndydTFZUytpb0V0TVp5K1BpSXJnUVZBNUlVUlVGY3luS0ZVbnFvQXJUOUxCVnhwL0NDSUprSVVHVytuL2pBV0lDdE9xOG84Y2E2WXdtMnJNOERZd3ZvZ1FsOFUvbTk2ZjJpOXlQZFpBYmFlajN1ZTQ1M3NhMlFISUVhQlUwbStySUVabGZwb2VGZGp3OEtGdXVkaGZHamYyOW1IM3djbjd6OHZmYUNDUVNNN2VmSXBzdnpBL2NDMktLRFJpL0V1UkJoSGpsYWcwWjZmcXpGd2cyQnNIQmp2Qk1aaldFZTZDN1B2ckVxL0ZjaFlBVVY2Y280WEVQRGVGVFVxTERRYWFoc3BQVjFvTXdtcTE5MXZjcjU0ZHJZNWlxalNvMnUyQ21zZmhYcjJld3hOQUVydjlDckFMR2NTUUVydHhuYWpvWTU5QU1wSU9EcEpETTVqb0lWTVQ4aytLaUNzU3M2RS9aSjZTQ2M1SGdXZ0NzTzc3SzkwN21IeUVDTkIyWDhxcDVjUmRQSFNTMWRGQVZQNWh2MVNveE5UaE5WU2xHbjZlRDNMakhqbS93U0wxdWdxLzVyaWp2TldPRXZTZ0I5NE1tbFUwaUhRTllDdmtXbUllcURUVUVnbFZ1bjU3VENlODlvZWxIN3N3d0ZhQlNtUjlTSzJSM3A2QVNUbGRBS1RXYldzWWZyVkhzcVVlaWthcldZVTlMNVFqdGIweitwUXdIRWRBVGl0N0kxOUJIb3VQT2ljUm9sQWx4aXRTeDF3Q3N0UWNSYnFWVU90MGhMeWYvWlg5VElhN29FTVhNK1JVM2ZxZWRvcTcvZ1oxR3NFdUZjVS9GZDYzWEhpdUk1Y0lYczI4WXdhR05IbXlFSVdQcU5wb1Rjd0krMVdRMnJnSGNsWTBlVDBySnBDZlk1dUNtaW1DNGU4cjNVQlR0L2xYR3ViUllSd1cwYlJrQTRDSmUzU3p4TE5HOHYzMmd5MDl6a3B4ZWZWZ2FXUG55c3ZVUEIrWDk0bE9NbDlRaG5xUE5DdkdiTFIvWHpJb013enAyZXZSMThBY3JUNEdRYm1LL0F3NVJ1Um45UEJSd0dXT1NyMEkvWVpHYkJPL0xkR3UxcUw2RlVqTytYTERUTGRPSmZQT0ZhQzRwVGJOazFYWm9vcEhoa3RPNEd2aVlCWVhKOENNRWFkbjFQbWpueDNDdUQ5SG41KzVNL3lpamhldGNJSXJrT1luSDNhbGlsMUtlYysza0xmdUQvWkZzRWFPdU93SDFWSGtkWXlUZENSVXNITTA4QVAwdDZwME1nRDJEcVJYNkVKMllkNitIbmlYY2owalgybURLSEJJZHlUbkJ0R01sOGdHL3QxalhndW4yNDVhOHhpY2lyOFBPbWVVamVCK1hOa0daVDhuUHlOdkkzT2NnZnlPY2UxMk5LZlFwOFYrV0lqUC9PZWM4VTlSSUFDM3JmWkZoa2kwb2JvVEJ5ZHBhS3VudVRaTnFjaEpoK1kreHhTWnRWcnBxWmhuSU42dk1pdktnOG5lMFd3bFhUcTZyT3hqQzJ5WnlsYjlhMEQ1M1FTeHE1Z0VJQnhkOWxMdTBvTEtWY3pXSVYwWm9adUNtak5lc0wzS1E5Ui9xSFRpRHJ3Y0Yrd2o5U0g2QVRKZmEvZ3Y2NlA5bmVOQWJ0U1pjemtJeDBucFo3bkU5QXU3Ulk2bjZ3QklMSmptNEZBWHBXaDREVjVRVTBmMmlsdCtaYitxejdNUGIzdExBRGQ4MWpJQUZHR1FWNmo4NkcxQ1AxSk9sOFBIN21GUEYvVXNUUkZQNUNkQ0lDOEQ1Tyt0TU8rNk5oczVUTmRzNjNYVUtGMDJHWHBsUi9ibkRhZkRzL3FkQVZrKzBqc1Z5OFBIaGlmN29Nb2gvUUIydXJJRTJYL3FNTnhySkZHcWtNaEFkMVI5aytSTVd0cGxzbER5TmRwRCtRNkxCRmtoRkRuR2lQMEg2NXJmSzRpUDVNdjFSejNnVktHaldPaGpyeHFYbjNsSWpMRFoxSWNOSHNCbG1MM1AwTTlUUk05MUxYOERvQS9oYVY5SG5YSUhBVDdPRXk0K1R6czhQNDd1REVqZ0hsL0UzYnZMcjJ6M3did0o0ZjNIcDR1VG82Zmh5MzQrOGdiNEltL1NwQjJjWGp2NGFoN25HSWZhL2Z3U2pRd1VIcGJIc0lVNjAvQWdOdm41TFhmZ0tWS3JwWHZ3amJuL3d6Z25HTjNzSFdPY0IveFZZdjMrNHNBUGd0TGQvekhDR0M5N3dGVkVEYisvRGRnMGQ1L0J4YngvUmpBMzRVQjhsUUlmZ1Y1ekw4RDRNdGJJbk5WaWJubGRkRFQ3dE13TVBvdC8ySGFzc2ZJOTdkTUFPd2YzbnQ0NWtBL1A1dkIwa1VmQWZnTWJIOTlIVGJQZjQweUhTRDMrTWU4L3ArU3Z0Q1FSbS9RTDN2N1QyL0NHY01CK1g4SmkvNk81VjhCK1A0SDVmVHg0MXo2bU1XUFVuMUFlZWZIQUlOVDVXSlhnU1U5ZngwRkpCbzhibW91cEo4VWVJZU00QlNZT1I5UjRhaEZHWk9lZEl4VTdmMU8rcXpPWElsUjdFWUIzMWlrbjhucmNKZTF2dTU2dU9KRFErRWV6TGkwRGF5ajBrM0JNUWxXVFFWQXJ2VWJwVmRvRXFEYkRHUWRlRi82REl6Sm1Tc285U3FVTTB2RUNqa3RIZHRWZ0VobEc5N3R6ckVWQ2dsS3I3N0xzY3BZYXhIS2JKK0d3V2pZcTNwa1N4MkZNTjdtOU5SQVYva2hDRWRsZmluZko1QkQ2dVk2QWpzYUxXbzBUVDR2RktXK3ZSV01LYXJJck1UNHhYT3IzdTRzdlVZbnI1K0tocDczcEh3RjQ3ZEdVMDcxR1pRUnVCR01UdjBaTUpqRnUyV2lFcVgxNkwxN1d2ak9oZlNaZ0s0YTR6YmUzOHRJTDVHTjU2eGJBVFlhWG5haUwzSjJHZm12QUNIM0FTTS9lYWIwYkttQm5LQW1aVURkVyt3VDU0Zm5sUFZUcG1PYk1jWGdoUmhlZWhWbDdvTW1BOHBNVzZscDdmbHpBS01iZXI5dVNtWG5ORlA3d1lpcklhT0JBblUwRU05aFJ1YWE0c3A3Q0dORUlmdXpoMng0bzhHWWhtM09SVFg2cjQrZkNuMVI1NXFwOTJWUnFZUGpXUVQ2eEhjUC9kMFk0WHZFdXJWZTNYTW9BVU91Qy9jUDV5K2xnbTQ4WWoyY2pTdEhYOGg2S1loUUcwdUtVZ3J2MHBoNlpaN2VodnV0c2NXdzUrL29mYzFUNVAyOU4wUlRReDFWOEZDTVJOdm9jMmQvVmVSUEJmdDQvMmNOcUZTK28rZFgrY3NHWFg2emk4R1lmS0FQRUNDdjNocDlHK1pLYWIzUzVrMDRMNW9ocGpDd3Roa29TazRaZmVlNjFoOWttcHBBOXlZNzlDZzlud0I0VXR0ZklwOUZnN0h5YzhwZUJFSjEvTVc1cWRSUDRKaHJTZU43Y1RleTBBNlZiWGdmdWRKWEFuZ1RlVllkV3pvR2JPb1JUWFlNVlZCMWd1em94SHJWeVFRSVVUMFZlbm1FN05nRDVQUDVib1dmMC9tRGM1SlNRaU92NDA0T0ptMTJ2a2xYSGJRNS9UN2JvWU1UMTBHZENGZGh2OTcybnd1WVhTN0pZZUY1N2orVkMzUVAwYWxMQVdUSzA5TXRQQ3htQm1LQXhhYnlvL2Y1cldDT1MzU3kzRWNHd1Njd0EvTTJmajVEdm1hTVRuZHoyQm1xN2EycDgzTUZMbFZmMkVjSnBCMGczOWVhWkplQnVhaks0OEtMMk04RVZsV2U1WDZQb0J6cE05UHhYb1QzeUtlbVRRbitUbEU2Yy9FMy82YnN5TE9aZEFMdW41dXlXUWdOVStmZkFweFRtaC9PSk9uQmFIMitwdythdFdLT0NtalI4MDZSUWN5L211L0FCd3BkSlp5Wk9ZSWNWbmwva0o4TFhlRDZNVVc3MmdYTE0vVXFBQUFnQUVsRVFWU0FNcDAxWlRpTnpsZG5pTUx1aFJHeWovUTNBZDVOZGhaVWZzNzVHQzBieWg1UWtCam9BbVJjWTlVZkk2Q2s4N0N6akRoZ0kxTWJ4QVE5TkV6bDF2Q1ZyaS90ZE9TWktvdlZvdnkxZm5XMkI1QXlQVkgzbmdvL0w2TEpoVGRScGxBOWhPTlMvaEV6M2VrWUkzL2dQcVp1Q2RiYmxFNUxXanIwd0orYmgyYzIvdHkyREEzd3VkaFpKNi9VUnlCU2JScmFUdHpmYWYvMjZKUThyK3FjanZCOHNYZUV6N1BzU1gxSlB1TzdPOGprM0J2VWExbjNGTUNqcHJ3bWF3VTVSMEtQV01aazZvdm5rZzZkZlpsaUJzY3lsbmZGelhhanhhTm5wN0NJemwvMmorL0FBTFBic0VuNnN2LytMQXl3V3NLaUpkK0FnV3Buc0VqVlVjekdBYnNqci84ZndKakI3M285YXdGQkp3RCtDMlNoakZHUzV3RCtKLzk3RFFPRnlUREpwUFlBN0IzZWV4aFRKVis1ZUg4WVVid1I0UEVsR09oNDZuMTl4OGZWQi9wcVdjRkF4Zi8ycHZyWlYzeXRQd2JndmNON0Q2dk0zTWYwSElDZmh6a0UvRzFZTlBNTHNQWDV0N0R4dll3ODFydkk5MFQvQlR6U3RnYWdleHZSeUxtUlNPc3BMTEw2RGl3TjlEZFJSdG9BbVlBeFBkS1JqNHVwa0M1aGUrc0FCZ0IvRHdaaXgzUlFUSkc5QjF1L0w4SVVoRzhpcnlVamdiOEU0THRYY1Nhb2pIOEtpLzV0dkovUGhVZitESFllTHJDRFk4V0g1ZnJsT2d5WDc4ZlBlZ1N4NGp0aHpGZjJJQjNUdDJkVnQ5ZS8xZUF3cElpR1p5aHNKR01CMndCMkEyaEZNRmVoSkNxb3ozUnV0QjJVVVI5UmFPenNqV3UyRlNNV0dKVkZ3T1VSWExrZUVHVHVJdC9qU2NGcEFqTkdqS2FIZlhQc0J1bFIwYlVEZGIrSU1ucHZDakcwdERsQ2hxQU5sVXROQjZocG9UZklkNUtsdmRpVWtXaDl4b0FKY3FSWlZGZzBXd2tWcDE3aFUvYUxLbU9NOGkyQVRSRnFrd0VRV2NpT0NxWUNrYnRFUXFsd1Q2L3d2cXdCME84cWRXa2ZDcU44Vzk1QnBRby9uNittMGczMWEzUWMrNXVpTHNLWUNpV3ZieXdvamRCcTlLR2hzQWI2c3U4UnJJRDhUb3BoTUlyeW1ha1lzcU8zdmlyZzZ0bkxpSk5vdE9POGNOL3ZkQzlwNkIvbmlCRURWT3hadjZhb3BZR2FhOEU5U1FlVFdEUWFjNE91RXdPak5EZXloaHFad3VoYnBuU21jZnRwR0VkZlpneUNld29xY3A0WlpYVUw1UnBQa0EzSmFwUlFVSklPSjlHeFNZMGlOSVp6akpGZk1WcGxsT0s2U3dsR2w2RUlZUnFscDdDMTZZdXVQMEttczByUGVMY3BFSXcwYmI0VE1YcW9FOFFoOEE5azRKWG5ndzRDakJUdEF3aXExeGlNS1cyTzR0RFV4ZVNKS3F2UVlYb0RBeFN1Ykt5dXlVNnRPUnFRTnpOU2xEU29iOXkza0VHNDZBaDBwZmtJOWMvN2pGdzcxQkZCZ1pvaG5zN1k2Z2dXMDkxRkk3SHlrTkVHWGpsdk1ic0NlUURiR2F3ekFEb3NYTHZFNTVvYzFjVjAycVE3NU9keExwajJlSVVkWkNreGtOR0JJTjF4N3ZQSUNHRGxGWDNPVHJXN1BTK2tIaldjY1E0NGIvUG0xVmVlVk43WE5qVDZMems4eUdkNnRjUStoQzlMSDdYdy9LcERDUTJGRi9xTzhEWSt3N1ZRdnI1QkdZbWtVZTZrVzJyVXA5TVUrUnZwaFJwY3VWOGZOL25LQlFLL3ZGcUJWNWRjSW1kWEdIMk9oWGNTVkZRZUdVRXgwdnVsOTRkMGtNQStrTzJHR3VuRE8zVTV6cHBNMm1zUWJUT3dUMGNyWnN2Yk5PNkV1azEzYWpPSXEybEIrZlBVMTVoT3BGekRjOWlaVUJ2Tk9iS3N0WlQvSXorbkF4bVFvL2tKa3NVVTREeUhnNUZ6VnkxdFRyRS9wT2VwM2owRURDbEl5WDN6LzdQM0pqMlNaZG1aMkdlRHUxdE1XWlZaRXpPTGN4ZkpKaHRWYkxKSU5VR0lCaldncGhZaTBBdHAyNHNBSkVBQ3RGQ3NmQm53WmF6aUJ3aUNyN1VRb0FZa1FHaEliT0NKYUpJaVdpUzdtdXhxRGpWWFZtWldSZzR4dUp1YnU1bHBjYzUzNzNmUHUrL1pNM09Qekt3aUwrQndkN1AzN256UDlKMXpicFQzNGx4VUhaNkNJWjV5TEdVeUJjRzVsL29NN250bjFKQXpxUHl3V05OOVFZT2VObXY2dVVZQWF3UmhYK1FnSFNmWmY1WXFpTDlIUHdsRVgyZXNlbFVHMEhic0kxMHJaRUprQjFjTlNtSlJoM0tnSXIvVTV0Zy81ejR2NUVQaDV5M2JVOGU0Q3NCWStxMWowT3dlU1M1RjVndXRURE5OR1FTeDB6NlR2ZHc2SzAySWVOUytWY1lWSFo0UnhzRXhxTk5Pa3UvblBRNERYb2ZLemx4anloYVJuN2Z1dG83NitUdzdyVVU5VzRIbDZoVllRVjdVZDZtejFBQmV5b1NBMEZYcGw5cEtTTmM0dGhqNXFabGhJbjNkSzBPYjBxdDUyK2xtSTNNN1FwYWJ5ZmNvOHdHWko3RHZsTDhVajlrNWFFYlduN1NMRG5aRGd5em9ZSFdJalB1TXZMN3plWFo4MW5XaTdFQUhiZkp2cmxWeXFPL2hmN3FPblRiN203SXB0eUp4SFNpNzV4MTlzUzlBNUZHaC96bnNEbGRPM2dld0Nma0F3TCtCQ1RDZkFmQXQyUDJrdndvRDFMNExpNVM4NXovUEZxY25Wd1A3c3ZFMlhnWHdKZi9zRzdDVXYxTUh5TWdJUHcwRDkzUWVqbURSbW0vRG9sRFhmdGZxeHZ0N0FVdmZmRzJ3TGhRVkR1RDkveW4vb2RCN0NJczRIUUwrQXJicHpqK2lOTCthaHFoYUhCRDlMSUQvVEQ2ZUF2Z2o1SHR5M3ZLNnZnSURnTi95NTU3QjBsOWZBT2hNWGU3Z2VTU0tqUHhlK1YzQlArUGZQNEd0OFFTMnorN0NsSWtKVEFGNDI1KzlCVXNQVGVQYU9TeDYrTnRlVDNRc2dQeTlndTFsM3RuOFBuSVU4Qmtzd3Z3ZDdISFBSRWU1QlFOZS9uZmtWTnYvREtaa2tMalN3S2lHMHI4dmFCUGhqd0s0MjdYMDlZa0NSM2dtQ1IxUnFOeUZzZllJdkdUMDExWUlPdHBWTUtlemVMK0dyRmQwK3RpN3pMTW5ZZklzai9QL3N2Y1EyL04yT3RmZ0p2dlJVeGVGZnhXMms4RFhHT0E3Z2RGendMejM3L2huTCthUEh5MG9LQ29ndUVWUkdzUHU0cWlsajlxV2ppZ0pyQjNmVStsWW9QUUVuQUFnTURxYmV5cll4dTdzWUlwclJvc2tRUmlsZ1UrQnRoaFZrYUxSZkZ4TXg3cHBIaHluRktmc3AvK3ZLWm9ML3RkUkNOWW54Vm42azBEVDhNNjR5ZmRhS3ZDWENzL0V0djNXY2E1NWpycU1BdW5jYnFsZlFUT2dWRUlpcUFiNWV3UFlmVWQ4cHFLY2tkWnBWRS95dW03OC9tVHA0NnA1Y0R4cUpNcEhGRFJWa3JpZktBdGVJZE5zT2thc0dydDdTSlZvallUVjhUSGRVN3k3aklvSW43MlN2cWd5bGd4aktPVlRBbXdFRmpSNlFqMTRBVHVYdkZOWHZleXJ4a3FVbnZqY0IybzBpMzNVL2FQR0VmWGVac1E2djJQOVJaU3lka0xwVGFTcnZ2ODVmeHBKcUdPaG9YY0Y0TktOVkt2NTQwZDBRcmhFTm5pVE5teGdCaGxHZ2VrNVkvM3NPK2VRUnA4TDVNaGN3TzdQVzNKK3ZVN2R4K3dmenpNQnpRMGthcnF4dTVFNkRidDdGdlovSWpUc0NIYld6cjBmYTNUY0g4emllNXY3VkdrWWtDT0pDWXBIcDVyYVhjbnI1c0V4STVqVlNLRjBsdnVwc3pRNW9uQm53TE94U0QzeXp3VktJNUR1VVRWZ3RvdzR1L0w2RHRsSmFhT0NNQ1BTOXlhbjBLT2hRek41bldzOVF0dDZVeDBMejYybEJOenFCRGh3N0xxZngrRTl6U0pEY0c3ano4VTFxTkdnRnQvVnNTTVlaZjFzdGM2WDcwYzk3OXVLMG43K3IzMk1NdnBHbmsvZ1RPakRwckc3OFZyNlF0UUhtdXdBcUk1UmJLK1dScGVPTSt4djEzbGhQV3I0anZ5Y2N4N1ROMjVnOUhjb1AyZmYyZDRJSmtOZStWaDVwenZ2RkdXL09RYmx5VXNmSTlPWXJtRDdpZng4N1ArVFA2bnpYb3c2V3NPTjFFR0htMGhiN0kvU080NEpVdGRZZnRNNVVUTk9NQjNyQ1BtK1dzN3QxR2trcjFRaGpaM0JnTTVvRjZQRERMTkRGT2NPZWIvbzFRZ2FaWDhIbVI1dWtQY0w1NFlPRHN5RVU5VkQrK2lqeU03S3p4bFZxK000OEg1Y05lM1UwTHFHdEsrc0lka0ZrSjFwdUk4NXp4ekhDQm1BNTc1aG5aUG13ZkZ6MFFPdW1nZkhlbmZ3QWJLK0VIa0NIUzFHL3QxT1RuazdsRVQzVk5iMTM1VEZPb3V2QTVCQjM0MzhxSU5GQWJMNHV6VTlSSFVpcFl1RjNyU3RYeUlYN3d3QU56bGxPKzJqQkFhTGMrSjlUZU85cnE3ZW96c3BuZVNlVlg1T01QVlNmcE1PeHFzVFd1dGNLejM4ZkJJL3E3Mjc3WHZrK1UzOGpMcTBmMzgwenc0eDZzeEc4S1lBenlxZnRmcWl3R0VUN2lzblA5ZDU4czlWbHRoQTVyMWplQkVjQXpJTnFkbmNsSityUGxzVTFRVzJ6RzJmM2EzMkhta2I2Njd1Q2Q5RFJaUXl5ak90YmFxZW0yaSt6RzFYd0FmNU4rZDZqWHd0VVhJb0ZabC9KSHRmczJIRnJBRGNIMGtHOGVlbVhvZnloS25vVDhyVGxQNjBaQkd2czJoSEhsRm5BTTVQcEcxajJQNUw4cC9NbDRLcmlTZUUvbEdQN3JxV2ljOGtRRE44Uno1VEsya052QTdLTENvclR1Ylo2WDFmdTZYYVE5YnlHZnVhbkt4VXpwYTJGQ2RoWnRnMVNqMHNPYmNpeXd5VTg3bjN5SmVwUHkyQWRKZDhNYitxZzhXNURIVHp3RDh2QWlUMktTMEEyQUUwZXArcmdBRWdSUmlPR0lISnRNVVZnSkVlTi8vVzYvb1NER3o5SVF4NHBWRDRDekNRN2R1dzZNZ3JHRUI0Q1l1YUJDeGkrRjh1VGsrZURRQXlTYlFtOHRsL0tYLy9OQXdNZmhOWjJJM3pjQUZiOUFzQVk0a2VwU0RWbVU3b0dpVXR1TS94YjhPQVhucGZBam1sY1YvNWZkZ2MveklNMEx3RThMbkY2Y203RVREMXRlUG1IY01pUXZmeWN2TjE0WDIraklnNnE2elgreWlWbGFjd1VQc0RBQk4vL3AzRjZja2ZJaC9DdDJHRTQ3K0JSZTQrQVhCcmNYcnlMb0EvRG5mYWptSFIyZlJnamVXYk1ORGhBcFlXZTcwNFBabkIwbXQvQ0Z2YkpTeEs5OENmZlEvWmllR2UxM05WaTBJV0lIZ0NjMjc0bk5mOUJ2SmRsRCtGRXNUL0RRQi91RGc5K1ZNZk0vWUI3TDFORWxjcXBTOEEvQzhBZnMzLy9odEcwenRRL21OYklrRHljZmFGZmRqQlFGVjlmOC9ub2dHSmdxVkdoVzJ0WDRTZEtORFRPSFp0Yjg2T2RzbWdvNGRaNTF4MmpVbVVUQ3I4U3U5cTBYdjhhYVdyNVA4dUdHNXF6dzBwMTlrVEhOTys3OTV3VVZDTXdoTmd4Z3NLWEFRcFhnSHdnZmM5Um1kUWFFcUNadlBnZURGZ25LcVlKZ0ZQSDlCOTBWamt5TlEvNzdvbmpvTGJCYktDazhBQkdraTVocksvenBBTlpCZklRcUI2dE92K1d5TUxodHAzQlNMQU52VzNmdTRHRDAybmM5QThPRzU1K1lwaW80VUcwbVU4UDJLZ29OSk1JeVhYdGpqM1BlMnBFWm1HbmFqUTlCbGJvckc5V2tUSjVEalc0UjAxanF0RENMK25BRDl1SGh6WG90ZW9TRVVsTFNxdzBmZy84dnBJMDZqVXB2U0tFRU40VTBadVJzV1laZXdHd1piWGVuaGVEUnNyZVlhR2lSaHBzUW52MEJsakFSaUlKb2FqSXFJZzlyWEpVWmQ4SmhvQVlyVFFCbUtBYlhLVUI5ZUtSaHo5WCtkTzcwb2NvV3lUVWUzSkkxa01PbFhqYUpNanZnbmFKaU1PTW5CU00zaHduV25jcGVIaFNuaEdBdmU5THh3YkRmQjZ2ekpUYytzOXdVeTVyUUFDRU01SDRGOThqd1l4R2pBdXdydWNveFI1Mm1GdzBibnFkYXBCWGdmcW1hbWRHaStrRWMvcmpNRHR1WCtuaGdUeW5oR3k4VVdqUERiTmcrUFpQR2RQb01LK25KZlpEcGpLV3JQNzlKWW1SMXR0ZFJEdTRQc3BUWG1mY2RxLzZ3WElkMnkzVnVMWjRSNGJ3Zllwb3lxNEw4bWpZNXBxOGozdFE1K2NxSEtYeXB3UnpJcmptbnEvYU9ScjFlL2ZLWjF2eVltVi9SMVRQK3U3U212VkFBdWhqZXo3UnA0ZFd0UUpKTkhwampNUzZ5WS9aOFJ2alo4bmtOUGJJaitQeHFrWTdUT1Q5elNOdmM2RjdwOWlIMHY3MGVETyt0TmE4eHo0OCtxOGs4YUlQTytraGR5ekhFTUNEdDJnRnMrT1JzYXhYK3piTk94WEJTNlZiMnJXaXFtM3NZSmtCeE02RklGcnp0OElaZ0JkTnRuWlFJMjNiQjhvWlRIYUo5YXdmVUpnbHZ5Y3p5VzlEeDVCT3ZmbzZQbmpSMmNWZnE0T1d5ci8zWUZIeWNyNG1RV0hZK1crbjhMMjdFWDRqbzZmN011WjlKRk8rQnc3RGNkNmZ0UDh5UG1rak1XK1YvVXhNWTV6UExwZkNlSkdzQm9vZ1owaitOcDYrMC85Y3oxVGRCUmdYVnducmhYdkpGWDZvVTVyMUlXaURsL0xES1MwZU9yeW9Ob3FDZm9CbVo4UGNkVGM5a3h5QVBTeGJzSjN0VHJwQ0JSMW04dW1USVdad0d4ZlU4MkF3K2RXaldTR0VGbVJ4bjBDN2FTZGc4RnYwU1AzQmN4SnYway8raHkwOTgwWXNvdjlvSStmVTQ3ZHdKMUNvajdpaFk0R1NjNlBJRVZQdTVHZjl3SEhCRHFBN2toVnBhR0psL0JzaUg2dWNxdksvM1MyNERvcnVGWFZOV1h2c1ZSbGtvNytSa2VtU1UwV0VwMGgxc0hJMjFhS2NpL3FHRU45b2hYbzBhT2Y2enJXOUhNZzc1OVkrTndFS01IdFJnQjV0NU9zWmY4a1hVSE9PZHNCOGxwY1NSdkpPY2IzWHN5ZXRrYk9ac2I1NFA0NENITk92Q0tkMWNhY3JLa1hyQnU3em9YbjRTcTBwVTdMNnRUS01hUXhrb1p4ckRwNUtsLzZzeXY1VzRGaDNSdjhuZlRwZVhhNmFhMlJ6RzNxaDdTdGNoalBReno3YXZ1TloxZmxmTTRUK1RIbm1QVVhXZWJRM21QRnZBeTE5NktrTTJvUHFla2JlaTY0amhwb1FidWs2dFVjUzNKc2xQWTJNTjQ3UnI2aVE1MU1PTWZVNy9zY2o3VE9aQk9ZbStNUTVaWURtRnk4dHcyNEJRQUR3T3ordytlTDA1T0Znb0VPZ2xJZ1djbXpxOFhweVVnakgyR0MyeXV3KzJEWEFINE9lWUtaYXZtZkk2ZHRnM3hlSzY4RCtPOEEvRTh3QUxHdjhFNVhoUHAvQnhacC9HOWgwVWRMR09qOEFqbFNtT1dMTUdCeWd4d2gvQXlaWVUwV3B5ZG5BRjVEOXA3ODRUV2piQms2cm9EMFUrK2ZqdU1EdE85SzF2SlhNTVBaRTFnazg2c293WEFBZ045eC9JK1JvNXIvd244L2pjL3VXaHdZVGVteEdZRzhPRDJoZC92L0FYTUMrQUpzanp5Rkt5cCtQekVMRDg5dFdOcnJXekR3OVBOZXo1ZGdBdTZmZWp2cTJkclZ0L1hpOU9TNTEzWGhxYXRuM2dkR3FLL2huaHJJVWI5SC9zNVB3QTczazhYcFNjM3hBWXZUazd1d2FQYlhZU0Q4NStYcjM2MTBpMm1tN3dCb09UbEkxSG9WZEpheHJRQThEMmR4NC8zOWYyQ09HbnAycjdOZmY2VEtqa0l5Z0pzQjFvSXc4RkxBdWlGakU2V0podVpld0daZ1NZcE5xRnY3dG5mcXBGQ2lVTG9OYUs0Snp3Q0tzVmFCTmFBbEVFWEQzaGltWUNlbFJJWGJYUWMyOUoxb3hCdGE5dTJYdE1rVU9kc1VWTFpCVUlGR05iNUh3SldDYXBlQmxzSU5CU0FxYWRYMmZYOUZqK3AxOCtCNGdiYVFlMGYrQnZJZU9FVHA4US81UGdtOVhsLzBqRndCdU52a3lFeWc3cWpGS0NuMXZ0WUlBTTRiMnlxOHF3ZWVjNmJ5VSsvZEtaV2llUm1KR2ZsRUVzUnI3WWdoV1lWWnlQLzAyb3lLakxaRGhaVGZxUkdWcFpxS1RaNXZuVzFwSTkwZlBCZVBTcTBEd0RJb3AxMVJRVFFFVUFDL1lyODVaOXF1emw5VHYvOHo3V2N4dmxOSmFza3NUUVlsRmVoTXdCWXlmVkpqUjVxZmlsSk5jSW1mYVNSeU10U2lOQ0tNNFBmY3h2N0pmTEtvMFoxblJvM1kvSnpmYWVTQlJ0OXdmRlR3bzNHZHltVk1hYXdHZndWT1NJZDR0alpjSHpjT1FwN3RNa294VWlvYWl6YytQeEh3VTJQVXFqSEhqTWh2NktYTmVqUUY0QUZNdHFYZXhERnJxbElxa0JwbHhUWGVJQUFYZWc3blpTU1plc3B6YkVuNW5PZVVwUWZJQnBlWU5wcHJ4OGhtdGxkejNFbVJrTWhuN0FBZG9CM3kyaFJGK09HaXljNERuTHNWeXBTWDZhNG0xaWswZ04veEhzUkxQNTlIMkQzcVorM3REakVZSDNnZkV0OXhIdHZKWjBtN0svdHRVQkhacFJXRlZDbTZSa29UdURjVVVPaVRTMGdIRk1EcUJNbWRGcmNNbG42RzRuZ0lEQlg4Qy8zWmpVYklvQkhrSGEwM0F0YWRPaVhyOHVkWVAvbGJTNGJjUlJialhBaFAxZjdFNndCcTQxUVFOZGF0L0p3R1A2NzFwTW5PSUpRZk5Kb3hSVHMwT2VxRmthaVJuM2RsY0tFUkxCbmVmR3lNdG1RYmREaHFSVXI3dU01VXoyZ3l1QmVkVmxPVVdHT1I2K2ZLejBVV2lXQTl3YzNvQ0VJYXJHbXV0OTFOeUJUemFqZ0VTbUJBblF1VFRDbjhmQ1ZyQUtualV0YUh6cFpxeUtZUi9kem5zcFVXVy9ZSjVUczZCbkFleUY4SWtpcFAxanVleDhpT1N4dGs0SlJqanZ4OGhKd3hSODhMaXdLMkhEdmxmdFc5a3F5TUlKT0ZNcFlmemhYSFdVdHpUV0NhZEdNVm41RzVWekFKL3ZkcS92alJlZGlIYTNsR002cFFSNkFOaXZ2eGlHY3RHTHczYzNmR2srN28zaUJQM25qLzlicVBROWRqYTlkQThNengvSGZ4ak9UY1dabXpWZ2xybzFGWkJJZUtsS3JOZytPeDh5dXRUL2N6VU1vSG5DOEZnZm4vcm9YNjNsWTVvSEh3Vy9mRmZFdktVZktIYmMvMXZFOWEzWnRWdzR2eVNKVTdWZmRNNCt6UnoyTjlLbWUzeXJ6aXlDYjhQT3B4ekVKQUhaajk2ZUxucWxNb1BkRzIxczJENDFtVEk2ekpZL1JacGFkQUthc0FtZGNxMkpjK3I0MjdWdWJaSVVIbFZZTHZ2THU4R29FYy80L3RxcDJnVXY5SXZ1ZmE2NVVXTElrbmlUNnBaNnZQUGtCK1ZmQi9IdzkxWHRyVXEvcTVmMzQ1UUQ5WCtqRnVIaHpmZ1dXZ2lQeWM1MTVsMEExS2ZoNXRPWWN3Mmh1dnlDaUt6NXM2R3JQUXlhcTFobjE3UmZSMC9sODRJUGwzQ2dDemJ1cDRXMm1VdGkvencvMFNIVDdqMlZSd04zNFhaVkR5UVA1ZGMyaFFYVUxyN1pxdlRwc3V4S1lnL1dEOU5lY1UzVnQ4cG1vUERySU1rSFZWMnJ2V3lQUkJiUWlVcDhuSHlSZkl1enAxbEhucDNLV3lPWjI4a3F3b2NpL3JyRG1VSkJsU2Raa3FBQXdBR2xVcGhlajJYUWRBMlpFMVBKclNuM3NCNE1YaTlPUXRBTDhPQThKbWxmbzYyKzhvYjZBREFIYVFiQUtiYkNvdUg4S2lNQUVEcEwrQ0hFRjZHd2E2UmZBWEFIN2UzL3RyV0hUeUhSaVE5MDJZVWVZYlh0ZFhBSHdkRm5IN0JQdDdpYkZ3L3BZQS9sakdzSUVSbWkvRGdPeXU4dnV3c2RNUTlCMEEzL05vMkZSOHJuNGFCblRmOHpIZGdtM1EvMnVmanRmU1RBc1FPZlZvMDRuMzcyM2tkZm9lU3EvRW41TC8zMFVteE4rRWdhOFh5QjcvSzFoMDgyUjIvMkdLWGw2Y25uUjZ4dnZZUHdWYjB4ZklESUtSeVVsUlIwNS94SEV3Z3ZjSXRwL2U5Mmo1Q0taU1diaU5FdnlOaGNvdkdWR2hGQXFnZmVEOS9hQ25ybFMwTHc1U3R3d3FQeTVGRFNIK2Z4VWtHU3Fra1Fudkl0UU5LQXJ5ZE5iYjFmZHRaY0E3SXlINkxZTlExL3ZCWUZ3OHI4SzBsSm93WFBYY29zQXdSTEdLWXdHMnBzN3A4bjdyN0Vmc3U0eVIrMHNWSXhvQXFnclNEZStkb3J6TXVqdEtBVEp0S1JTeTR4MnlQSnNYY0dCMC92aFJsWS83dkMrUkJTN3V3ZHZOZytOekFTT1NKMTJYSWJ1eUIyNGpHOTlpWDJzUkxnckdrdWZRT2Fqb000Qm5WSFFnWHRVd0hxSUFPSkNOaEYxMGVRMHh0dTZ4cDZnTXFER1RSaFY2dXRZRTRpSHJUT01pMzBtL2cxRUtLQjFFMXFnRHUxeUhVZmhkTFRXbE1TaXdnOG9BK2tkRmkrMnA4VEsyV3hqamtPZERqZlRKZ0loeTNyaS9hczR5ZkU2OVZDbklWOEVMblovWVB6R0VNVHBrRGFQUFkzbU9CbDhGVnJaNTZxdm5MOXRjelV2Z2tIM1ZWSXNxbDJyVU91ZUZOQ0JlandKcGoyc3psbWRZbHlxZTlHYU85MEFwY0hPRmp2M3Z4dHRER0EyaEVuWUl1UXM4RlBhTHdPd0lIbzN2MzlPSmsrazBTUnM0NTVxaWpIY082YjFHckRORkI0dUJtY2JlTlR3MVBuSWsxc2pIeXloWnRoV2p3eFc0WW9uN1hVc0M0K2NHeUpJK3B3Z0hNVHhSN2xVbGVZTU9XUUU1bWtGQkltWlhXQ0Nmc1RYS2lHSWEyamxuQlpBc3hxL2FIdCtacHJCT0ROQURwZDJ1czk5VnBrRHJ1b0N0YmNtY0p1UGZnRmYxV2VYbjdMUHltS3JPSlliZUtRTGRhK1NlNUVZaXRIdjRlYVQ3S2FJZUphMUNIRi9GY0V1amF4V2NERVlWcGYyRnJvRndSanFNbWwxR3FNRkZqSU5GbTAwL01NMjIrd3IxeXhwZllsczA2TkpCUWpPTkpLY05PVS9xcktSMHVUYW1LNkJNRDQzU1VOdVNmd0pmVFJGRlVtK1hUQlVkWGFJQnJzYlBVeXJtSmtkeXJsSFNrMlJvaE1nelRmdSthZ1hsQ3VPd0cvNzVmM1UvQ1Q4Znl6dGNGOUpJSU5OdVJ1Z3pMWHVpeWVqbjU0ZklmSVZPTU9meng0K2VlUjl1bzdTMTBUbnFUTlpwZ2pKekJlMXpCOGhHOVpyY05KSHZreU1Uc3R4K2haeXFtb0VEclNJeVYzWC96ODBSa3YxbW1RRDRzSWVmcy85TUFVNG5NczdKQ0pJNVVONkJqeWs1SUFJWi9FTzVOemtmVi9NTTZ2SThycEJsaUttMHVXa3NIVFFCTmFielprbU9EMmdibkJXRTFuSUlvNUYwaUtMalVNcEFJUHRSUVIrdVdTZGRrcldwZ1VTWGdaNm9ycUZyVGRsQjVVREkzeU5jM3g3YkNWTEZJdXZVYTRlcUZOS1c2L0J6RE9rajJnNk9sTmNJRE9vNXJUbERSNUJQK2NYRSs2VlIySXo4M3dweStEc01nR0xmRk15SitqbWRoRkw3TXJhVy9EQXZuUVFMUUZCMEtlNG5kV3JyMmtPdDlMaERTd0Q2dUg1Y0E3M0NTY3NHcGovM3Rpa2dVRHpUWTJRbkhNM3V3TFRlMU0rNzlDeVdYdG1SUEttdm54ViszaHJYQVAyY2E2NzZZb3hZcGY2MWtXZVU1bEIrWE1QMnV6cE5xUTFsRFpjWEsvTlRwUTl5VHJiYTdDcnp3Yk1WNzlLTjhuU1VUVHZyUjhWcEllaStwQVZWZlVUcVNPc3ZlNm5RRDFEdUVYNnZWMXBRVnRHMTIyQjdVRStmWFlpMkRiMlNhWnVqck80Wnlwa2NHeDJ0TCtmbUxLMWd0c3BhTmNlTFExamc1UnFHTVkxOGJId3VaZGtLTWtSeVVFZnBETDJTSDg2RHpyZVdyck01Z2UzaFMxM2piY3FERmdKYWQyQVJ2YjhFQXlTLzZuOGZ4QmNjaUhvYkVnMTZ6ZkpiaTlPVG85b1hBbkpOWVpHbHY0Y00vckw4RFF5c1hjQUU0aTV3N3M5aGdPQnQyTjJ2dkNkMkNnTmtML3ozZXpDUThxMTZOVHNWRWg5dW92ZTlyd1FoZVYrczNrV281UWYramdxOWE5UTlVbW4wK1E0c0twcWcrSlZIeE81VFJvdlRrNFBGNmNsZC83bURra2h0WU1MeE0vOTVDd2FrUHdXd25OMS91SnpkZi9nQ0JnZy85NStGUjZ5K0QrQS93TmJ2dWRlemdFVncvd0RCa2FBcnN0VUIxWDhFVzNzQzZ4UVVTZHlvMU5Hemg0eGdnWHduOGZlOEQ2T085cGIrYk90TWhQSkRIOU5md2dEdVN3R3hwekFpOGdwc0Q3elhGLzNiVmZaTjZmMGpWRG85OEs0am9GMnZTNjI2a3FDNWI3dU5lY0h1YkpTc2dGSmRJR2pyYnk4cWhHdGYxMEZJdTV4MzNNUFRNNjdvZlFnQ1hyRS9vaFFtNWh1ZjNWWnEvZUQ2ZEh5M21sdmFseGE5N1RBYXZ0UTdvNlBRdk05N2U3UjVOVGVQOGRaNGZVK3FETEdHQ1V6UDU0OGZ2YWpNeHdwMjMvbmJXNXBkaDc4SmR0enlkaWxrcVNDcS9lcWFHeFZpeC9CVS85N1h1TVkwOVBEK2p6Ti85cXpySE11ZVdDRXIwRFJRTHIwT1hrMUFNQ2s2eHFXSWkzZ09ocTZqMEJ3SzRtcDQ1TitVRTZJd3VVMG1qRkVoTlVXdFJpLzY3aHN2M3F2UmtiNFMycTA1Zmt5YkI4Y3hOZE8yT25udk1vMXFyU2dBb1IycXpFVERCV213ZXBJemtsZ05uVjNqV3FJRWpyVnVLand0M2lES0NOdWV1aEtqYTY0ZXE2d3ZwUmlUejRZNEJlaHphVXlpdk5Kb1RZUFFBaWEzSFRUWm0xdm5nbnRNNVVjMWR2RTdsWms1Rm82Wjd6RjZtNUhNQndCbXBGMytleVo5cnU0VDN3ODhUelVqQzNtUzN2dkdhSjBVZVkzU1FZYjlwdUdLYTF5a3ZQTTlkSVNjUlFESVNqUU5HUEJuMU1PWWhySm9LQmlUaDVQR3p4OC9XdmovSzdqZU1TK2pVNWZleHk2bG1nWkVwWVZIc0xubS9hQkhLS1BRRnNoeU1vM2FSZkUrYVRRdm54M0Y1MUNtNW9xOGgwcDRTaVh0ZFM5Z1VWODZyaXY0TlRFZFk3MVc0Zm1mNTR3TTB3RmdIcncvZ3lLU3RDMzV1NCtmSC9oUEFVN0I1bzJHQTUzVHRYKzM3WG9HTmNDUlJtdTJEQ0NERTYyNzg3YlE3UVFpaWJ5MjdEQmthaFErNytNZXFsT2x2YzB5ejVIS0d6LzNUSXNkMzdzVytDdWxheDQybGJWaDJSYjFSdWNhNVdHcXJ4VDBYK1R4dGUrSm1xR2F6OU1CVERPREZLVW1GL0NNb2hMTjRIWE1ZQTZCZysxWGZzYlBrV25YUlVYbTQ5Z2puUWRLM25ZRWNZd1Uybm1EM1V3QUFDQUFTVVJCVk1TNnEzcS9QOFBVZ0RYRE1lMVhYZEZHeXQ4T0hDemdmSy9nQmtXVXpsU2NUNlkwMXF0WnVvcnlUdktkTy9JZDk4eUcrd0FtMjA2YkI4ZUhzaTdrNFpRbnRGMk5nZ2F5VFlvOEVNaThrVFl2QWxObkFKNVNqdkwrM09iKzhyUElZSlhPRXVRY29PUE93eVk3c0hGZkFPVzVVa2N6OXB0aklXZ2RBYXd4YkU2NWZud2V5SGNGQXJiWG1UbVAvRkhUWVhPT3BvR2ZQL2VmamRQRkZ6Q0FQbWFiV0tDYm42ZW9kS0VGUndCdUNRQ1huSEI5N3ZSZTQ0bk1YVkc4VHpyWFhYUkt6NTIrdndiUzNkd3JQY3MrL21UbzlzOElNRndiRks2VkRuNitWZC93TmRocUc0cHR5ZDlYckNNK1YrRkhwR21VaGFQREk4OXFsTFZpaVhxZUFqa3M1TGUxZm5YeU1hbVRldVpsQnorbmN3dWphUy9tangrZHl6NXNGZm1jY3VKSXZ1TVo1RDZhd05ZdzdsK2U1NzBjajBOUmZTYitKTmtDc3ZjcjhrVXNVY2ZyS3ZFOERkSFBBYUR2dVZSWCtFaDE0eHJJRitYT3JjWDVPZTBwZ05HMmFEY2dQZUpWRExUeksvK2xMU2Fsay9kOXRQSDNlRyszQm9McE9MWE4xcHdDNlVxTmFoR2VwVHA4V2p2aCt3bkE5WHAxYnd5Vkxia0dVZGVvMm5jcjl0VzBKOE5aMmtpZnRCMmVzM2p1bHVGWjZoRnB6SEdmRDlqM09pOUtsMW9seUNma0I0bC9pMDFrQXVUN2VwRmxwK2l3eUhVaVBncXBrdzV0cEJtcWo0K1JlYW11YzdLWCtMaldwRzBjNTl4c2xpOGlqNXNIdTd3VTZsM0ZXdThDQUg4R0ZqSDdCaXk5N1QrRTNXUDZLN0NvemJ0QUVmWEpza0k5Y25Id3ZVcGVybURwZ2x0OTloVFVFeGlnK3hzQS9nVzZVMHEvQ2dPSVB3c0QxMnJsV3pCQTd2c3c4UEZmdzFMb2ZzTy8vM1hZUXZPWnB3aWJyVElQMndvTkt3bnRkMkNSQkFxd2Vmd3pBUDhiZ1A4VkJvcWVBL2dqQUY5RGpvNU45NjNKbmJUYUg4N2hFeGdSdlFlYmo5ZGcwYm83Z2NEKy9DM1lmUDZNLzh3UVFGU1AwdDM0enlXQUY3UDdENjhVUVBWbzVmY2dnS2QvdjBRR1MvOGNsckw2KzdERGRXZHhlakx0bTNOUExmM3JzT2h1S2pDYzd6V3lNSHZnL1U3MzB6aUlTc0wxQVhLMDhLb0RiRDVFamlMdks2L0RJdEMvQ2tzTi9TdUwwNVBYRjZjbm40R3R4ZHJucUt1ZHYvTWxFcnZhL3pka2ZObTd1TEl6V01EdkFEWjNIb2NZMzhsNG85R04vZHYwL0wxVjRMdEc2UUl0VkRCdmpWbld0QXBPMTBxZmNQbHg3NCtQb3R5QXN0SlZDa0VGR2ZDb3RjLzBsZFg1ZHBDTzlIY05vKzMwcUw5Q2p0cUo3VWZRNEVBODlsS1oyMTFuUzVoU2ViYUZOaFIzZFZVTUZsMUZ2WXRmZUY5NG51a1VSWUdQNTBxZDJsUTVKWWhENzczcXVMb01xLzZuZW5WVGlJNkdOeTI3T0ZYbytZdUdsUkVxRGg0RDZrbWcvcTVPRGpYaDEvZUxBb2s3RlRHZ3RReUQvcjNTUmxYRytMblNYNkE5VDN4MmhJckJyRkkvNndTeW9WbnYxMDM5bHVkVXVXQWZkTytudmNEMjNGQjRBVHNyMjFMTHFUTUJFQ0x0Wkl5UnQvQ01xY3k2OFhaWDNvY2xjaFlZMGhEZXp4cVZYeHJzb3hHNXVIOFFlYjUzMFg5WWVLZmVKY3doUkkwell4Z1F0WlQrYzN3alpOcEl2c3h6cUd0K2dmSWFtR1JJQ0dQaUQ0MWtqQmdtMEVHbGsvdE5qWEVFQWpwTGowR295MENlakR3RXc1Qzk2VlhaWDBHYzBQek12cERuVmwxR1kybXpGaEhPZmkvZ2h1NG95OUQ0cStQcU9NZDhmaWVnOVpwbEF3ZHcrZ3hHbE1tYUI4ZEhOVjRReXhBYUtyUTJPU3A0VzNTQVVSNGZEVk9kOVR1LzByVHBCQVBUbnFpQXpUd3ZXcnI0T2M4NVFhaStvangxRjFrNjhyZzBQMDJPNE5NNUtGS3NxWXpCZWRhZmdYMm9sV0x1Zyt5c3RHMnlaVThwajlEK01FVzgwdGdoamxuUitGZDEwdE5TbXd0ZjIwVmxYZldPMFVQc0lLOElMMTlFR3REa1NHSzIxMlZrSlUyajg1YW1lK1hZeVY4T0hJalVQcWhEbnNvSWdEakNkSnh0WFNPdThRWk8yK2NacENPSW5PUVc1MFZuTU5vNGhKOXJwTE02R0drbWpSYkE1dTNlUXViWEs3aXp6endEeGN6d3czbzA0b3BqNURwVGp0WnhSMmRqQlJqaWZHMHI1SmZQRUFKVmhEZGNldjhadVV0QVZtVWN5aWxqbFB5Y2RyMWFKQjM3cnJMUnhzZEhYblVPc3k5U0Qxb2c2MFlFYnhjWWNCOThqWmZWZENCeExLQ2pBZm01anF1cVAzaDl2RVlOQUZyRy9GaTI4THQxRng4V1dYVVFMZitJOVh6Uy9Kck9Hc3ZhZWVWV2VYUVBucUcyRkdham91TmprV2JYUCsvVHo4blAweFVlZmk2U0kwV05uemM1Y3czTE5uNmVIUDU2MW94eUNlWDdvWEthbmp0MVZnQTg2bDNxSFhuL0Mxazg4STZ4L1BUS2JscGtYRXBESXIrdHJUWGI2dHNIeWlkWUgvVUQ1V3N0Wjd1ZXd2ZTJ6bk9GbDVPdkpyb216M0p1cWYvdW8vT2ZkL0Z6WkQ1TlhxYlJsQnRJOUttL3Z0VDZrWjF6eWMramZxN3p5VUlna1hycVlXMWZoTEhHTmRNOW9udUQ3ZElSWVdza09uVUdxU1AxVjJXOFdJL1FCajBQYWlOSXRoR3hzMFNaU2VVbTZnQ2F0UWUxdHZjdFh2Y0ZMSUsyTS9PQTZJT2tUNHhVWnIvSXQ2bWZjOHhMMkwyN05YNGVyNlRpdmtsMktlZGxDKy9iQ3NiWFNiOUluMXZuNURxbHlRNzJhZ01FZ0FuQnZsNkF5Y0ZWSUFzYUx3Qjh6ais3aEJrMlUrb0dCOXQ0OEg0Rk9WME0wNkc5Q1lzRWVnT1dpcml2WE1GU01YOER3Ri9QN2o5Y090QkhBd1BUNC80VEdDRGRWNzRJQTRBL2hmNzAwMStBUlNsUjJEK0hBWThUMkwyNVg0R0JwLzhmVEhBRWdNbmk5R1RsZDkyT2ZSNnFkOFRXaXIrM0FyRHh2MGVTQW5nRUU2b1BZQURrMno2RzkyREErOXV3S0Y0Q2w5eEk1d0tLSHNMdXZPVUdmUWY1M3RrWmJDMm1BUDRwZ0xjWHB5ZmZoQXVZWFpHbmk5T1R6L3E3VVdGL0V3NksrL2hyOTBSM1J1cldVa243M2IzZmdxMjdydUg3UGk5M0FUeGJuSjRBd0doMi8rR1Z6OTl0MkgzRFg0UTVDSHdCV2Rpbmw5a0xyM2ZtendMQUx3RDRnOW45aDhVOU9YN245VHIyYzNGNmNnQUR3QS85OXhkclkrc3BsLzdlTFpnRHdqTms1dlAzcFZKRVFmdXhBUERFaURPRktRV2FxZ2NZN3VuRlVoTk9kakpvWG5kdW0vSXVJWDdXQ1Q1MWZON1Z0eXJZMk5PWGE2Vm4vaVR0dDEzNjRQMU9xVGh2cWoyZi82N1VPSzMzbTV4MnROWkhScTZwMEIyOUI1T2c2b29EQmE3Q21XeGUzbThaK3pFb3VuU2UwNWdleGZxM2xBV01GL0UrdGpOa3dFcU5aalN3VWZnczBpODFPU1VtaldqZ2M0M2Q5NlFwYUtyZ0pQSzlZb0FvT1Z3M2RIdVExdTdjWWx1WFRVNERWeGgzNVh3VloxM1hvbUp3VUs5RTByNmxyL0YxRE9URmVQejNqWnhiR3Y0YlMzV1ZsQ0doMy9EUDBqejc5MVFJV3NvaVAxT2xSZlpBN0hmdHZ0bXVvdUFiczh4c1lQU0FuNnRIYkNwZFNnaVZIOUpmTldvM2trN0t6MmhxRHhuZ3BqSk8rVDBXNmcra0FVd2J5Ym81SndyTUtDREM4VEJDNExCNWNId1AyVWg2SU85eERuakdPdzFnUG1hTkV0QTVvYUk0OG5ZT3haQktBN0Fhd25pdTFaQk1uVVRUTmZFNzlWUmVoM2RpbEtvQ0VheXZ1R3QybitMallaUTBBZFlZc2Niem5JeE9YcGhxanRIbzQwQ0xMNUFOY050a0ZBTDlWY1BmRUI3WDVDd1NJeG5MeDFMQ21SOFNMY3Axb0FOQVg5M1Z1blRlNUptbGd4c0hZZTlWNjIwczVWb2ZQd2N5ZjBrMHd0OEZVR1NqNFZrWkl3Q05XL2o1SVAxb250T3NUWWZLQVA3ZVdveCtkRkNJY3VwR25sWHdOWlVBMENhRG5ORFBvWDFwR1lvRDc0bnpSTnJMU01wWTU0V1BUMVBVUlg2ZDVrdjRlUUdreTdnVmFCOGhuMU9lL1pvYzJiVkh1L1lmNStBS0tGTkJkenkvclV5UitUa05xaXNCTGtpcnlZc1VISTMwcXNnTW9UUlhaTllvYzlVaWwycGpxUmxWVXlyOXloa3B6a2JYUGxNZHpkZm9hcDd2aHlaUXl5c0k3aUx2djZWL1Juc1RVeXJIcUVQZU02dEdkOG93VEdkSkozemxHK1FIbENHZStYY0hqZDM1dVBEUGp5RHlzNjhmNzdudGxTR2p2Qm9LK1RGbFhnWUlKQ052VTZhT1BVTjU5alZMaGNyeG5KY0lBaWs0cFVYNStaSjltQnM0dkhkcHNyTXQ1dWFFQlFINHRCOGNyOHJSVjNLbUQxeTMxUEd0MEc5ajFhTEF4blgwODVhdDRlTW9nWjhQZVVVenR1d2FYZG41dWVqbmt6QW5FV0JTZmw3TERFSTZvTFFuMHFob0d4bkw1NUVPM1JRLzN3QTRuSnZUMzZBeXR3anRReURkNVUwd2g3eUwvZWY1TEs0eGthckk3NVFYRTFnZkNtaVJadkpzRitzaWUwZDFuVTU5emQrOWRENVQzQTBhMXJxbW45ZjR1ZW9RS3Rmc0szTnVtNU9ieXBReWhlbFBDallxUHdmeUZWdkptUUYxSjZLVWpoa283L2R1Y3JZTmx0WXpVcnIyTytlYmp2cXNoMkI0MTNuYmlWWUdXNDJ1Y2JJeGVSOVMzVUdtVEh1a1kzK3Jua281VDhIMU5iS2N4YmtnRHhrRkd0V1NuM2VoNlYzekV1MFd5TmxOYUpOSVYyUWg2L0VjQTIybzdOOElwZDVkNkRqSUFIRHZWWUZjZC84L1ppVFpxWWhPbTY3Um9iN3RqOFNzV0ZPbUZLRUhkaW9PMXZHSFFoMEZXRTFWY3VudkgvZzd2R3VFWWZPM1llbDIvd1EyWWM5Z29PTXRXQXBjb0EwQy93MU1tSG9MT1QxeHVtUFlBVkxBSWlqdndxSXRDZjcrd091L2piWUFjZ3Y1N3EyKzhnb01XSHdIZVFNY3lyamZna1dmL21CMi8yRTFmVW9OTlBYSVRxYXpHY0VGYTBuVEd6Y0tEV2gzWVFhcWN4OFhoZVFWZ08vNm1Ma1o2YWxIZ25FQUF6NWYrRDI4SkhSTEdJaDZ5K3RhK0xqdmVqM3MwL3VMMDVPbnlKRVBQTkFiV05UcTZ6QlErczloS2FYZmhLVnVqbU1oOFYzQmdPR3FvTE00UFJuSDcxZ1gwM3d2VGsrNEo0NmtMOXliS3dDdkxFNVBudm40WGtFT3c0L2VxWjlDTnBJZndrRHcxMzJzbHdCdUwwNVBYakJxT2ZaSCtqeUJwWmIrWFdTRmh1VUo2cEhBUC9DNStwUzM5MDNZT2RKbzhoV0E4ZUwwWk5NMVh6K09aWWd5ZjAyRi81TmExT0dEaWlZRm1Db1RRUmE4cTRiUWdRcklTNW5QQ0lqRXZsVSsyM21QNzlEbkNMenNVNllBMER3NDN2ditsNCtqVU5BWWFCaW44akIwZk1XelFZRW9oSkVlUUNrQ1FSUzRaaWpUNnAxTFc4K1JVL2NVZlcwNkFPbG8yTnkyNTcyL1oxM2ZkN3hEb0UvdldaMGhLOEtxSUpNZkY0YlJwZ1IvRlNpTlFtWWNYeUhzaVpMTTl0SytuZWQ3ajJLSlVTbTFNVWFGWHZ0T3dicExDRmVGbVVDT0t0OFRYWmU0UnVFN0t1N0pRQmJYWGNISm15aE5qbWJRZGRIQ3Zvd2FBOUhYalhtR2QvV2htcFhCQ3gwUVZTSFNaMmxrNDF3V0pheFR2RE5ZNjBuS3ZpcGlZYTZuTUtQSnBUeXI0MVREQ1ZCR0hDdkl6ejdja3IvaitNZXd0TUZjTzQxZVZjUEVGWURKUE4vUlE5cEZJNGdhYkZjb1V5anJXZGdJdlVwM21JblNYRFVzTmhuMEJlUmVRMUdzMVJ1YTM2dHNxTWJ1aWJ5emhnUFJZbnpqNTJvczR0bTUxVHc0WGpxWVF4cEFJSTJLTis4Q0hzKzNSNEMxU29kQlNBRUpLcnk2Rnk2YWNBK20wSjFJSDdoWExnWW8rN3F2K3ZwOGlKQktXNHFlbTF2WWtjNi9yREtRN3pLS3V0ZndxWHU2TnFjMTJ1cDFSejdCS0M3eTg0Vi9Wd1ZTbTNhcStRUUdOdGtKaHJTTjVRS2xzNUxXMStsZzFzY3JZcGtITUhPSEV1a1g1UDg0ZjExeUp2bUZmamRFSG91RzlWVGZQSUQ0d3MrMXI4bTIwRFUvY1IwcmV5S21yTmYrYVJ1a05meDdnMnpjMnRUNndMVnRNb0JNRUlUcG55T3RTaW5vZzZ5NVY1RzlxdnlLUmVrZHgzVUY0Uk5vN3d1TlRJdmZrYjdyUGhuRXp5c3kvTExKRGtiS1Y1UlhybnRrWWNxWHRFV3RoSGNrdzJXVDc2dWJJb05BVjdBOXdVaFlYcFBCKzRDQmRvVHNiWmRGbHhCNkZNN01HWXlmWHpibUxIcUp6TStQWUxZdjBvOUw3OC9DLzIvWjRacWNLV0xUdE9YR3FyNFplTDJlZS9KbklPOXRndC9LNTJuRXBYR1pzckFDQndsWVJnbjZjYzVtenMrdlpFM282SlY0UDQzUlhYUzRyNGljenYrNVQxVG1pdno4ZVNQM3R2dDNYWG9FNTYzWGtTZzh1NDJmUnlCVHYwdmdTUisvK0tqTER2eDhNbVFkWGFhcFJrUjMwUGNpQUVEb2NISXVGZjI4cS8wVUFTZGxCSk1wMVRsWm5aTHBOTkZ5K3RuR3o5blBiZXZvM3cwR2Y2VVFkT0daSlFqTC96bStSS003ZE56STY5VUJwV3RzUmRTeW5KMCt1YndsYS9TVldFL3NqL0E4SU9qcUZYNnVqclUxWGEwb0ZUcXI5ZGYwODUxMWtTM3RVNGJrR21uOXVsN1VoNmdYanVRWkxZd0M3ZUxudWw5cS9MeVR0a1c3V2JBUnFMNjFpYy9IMGlNbmRyYlp5TjNDS0NQZkp6STMwYmtYTUIwM0JSRE1INWVSK2p4WHpyKzRIMUpBazhpcVU3RlBxYXlpNTdBWTQ2NTIxekF2dWo1amxGZDVUR0R5REs5ODQxa21NRTVkaXUrY1NSdmM0d3h5NWJyUllmUUlIaEFpejQ5cFIvWTVHSkVXWE1PMnJOZ2Y1U0dPdTJXem5qOStkRDZGQWF0REZPNURHSkI0Z0J6ZCtBb015UG84Z0Y4RThIVmtEOGt6Yi9nUGtMMVBVNG9IMkVTOUJvdklKQUI4RHVCZndTSWdrd0RXMDc4bHpCRDhWekNnbUtrZ1ArVy9YOFgyTkx4ZDVVdklrMGp2eEMvRFVrd2Z3Q0tDMzQ4dkxVNVBic0VpWHE4cW9CM0JQVzRZR3JnVHNDM1BUbUdwbWZYZUUvNXdEci9wNzE3QUluVTNEc0pmd1VIV3hlbkpwZmZ6RlJqQStRM2tOREpVcHQ3eE9yNEs0UGRoYTcxQ1RvbXpoczNweXA5YmVDVHNENUVqd1ovQTFtRFRFZGw3NldQY0pwaHQzZnhNamIwNFBkRVVkelQwVFFFY3pPNC92Rnljbmp6eHNSL0M5aGtWbUg4UEE2MW5zRDN5YVgvdmpqLzdJVElJM0JtRkt4SGFkMkFwMFlIU3dQZlVmMTk1blorUi83OE5pOXgreTc5N0h6bDZXejJjcnpvaW92Y2xFcC80MG1Ydy95U1hvZjNzQXpUUWpvYnJCSGY5Y3hxSWU0MWVRYWdlTlJXajJTNXpMQWFYTVhxODlnUU1hMzArdEsxdC9SaGFWNThpMGVRN0lKbTJzOXFXMVBXSjJZODdDSDViRmVMbXdUR2RmNVpOSlFLSUFxTVliL29VTkwzWG9xL05LYkp6VUEwb29qenhJaGdlTmk2a0Z1bHZxV1ExMmFOT0M0RllHcmFZbm90bjZFWlNmczRmUHpwckhoemZSalpvMDNCRHdGcWpHZGRBam1LSjQwSHBESFFwWTA5QXE0eXpscUtORGtrMXhZM2Y2VG9uZXJJbjdhVkJTK2tZRmNsa2pKWjV2bXBLVURYUm9vclNEV1REVjl3cmF3Q2ptK1lYVFU3elNhTWVTMVZKa1VKd2xNcEVsWllIZzB3YVR6QnFLNGlpODlQcE1VcGpHYy9EM0ZJMUVkelVmWkxHRmNDZUkrOC9aYXcwM21DOG5Yai9XVmNhdS96RWFJQVlqVUI5Z0h1UmZhSmhmalF2ZVozZU9ackdpSnc1Z3dacHRybVVOaGpCVzV3SDVaT2tnODJEWTk1VDIwVVRrb0ZEZUIyQlo2YTVCSUlSRGlaL1QrUjlCV3M1VjZRUnFwaFREK0g4cGVnczVEdkxtVHB6TFhTQjBWQXhXamNwbzhoenpUdWFZMUZEdUVhK1gvV2R1VnBkOC9LdVhaWmkvMjhwS3ppUVVQdXllWEI4WjI3M0l5MmJCOGV6cGg3aFMrQ0N2ei8yMGxTY3BtckY1N3hYWjVkMXBUTVMwRFpRVG4zdGxnUWFhdTM2M2xid3FxOWQ3ckU0MzVFV0ZCRmpjbjYwMzhyUFd3WlNONnlROWx3QlJYUUJ6OEMxZWNFOFIwWVNPRnA1dXpYQXR6QUNDakNCOEZ6Tk1Gc3pORk5lb1p5K0RuVnFJZjNSTlNJZDdRT24rd3JYWGR2VUtGK09oV3REWnh3Z0c3b0xmaTdqQWl4NkVNZ1pJZmdlUWE2cWd5Rkw0RUZwZjlkb1VwQ3ZTSjhMcDVyd1huVG1KdTBsLzZCdEpwVjVHVGs3YWtxQUd5am5QL0VPZjdmRnorVzlLVXhXVW43T3U1VVZDR2JmV0Mrak5EVWxjOHA4NGM5UUxxQVJGSDRXYVF4bHBCUGxCblZlcE9NUHYxY0FkQ0xQMElFRU9rWnZYMm1PT2dQY2drWGZVZ1poUlBBTDF1bDg2RVdRbDdSc0dzdHFNSEorM25tbGtiU3IrdmloN3l0ZDg2SitsQ0FCZVRydkRDUmYwM3V3MVlHSjg1UmtIZitPc2tvQ2k3djRlZERuOVhxTUk1aERWUTBrb3p6T3ZaTDRPWHI0NGJ3Q0VuYndxcFNHSEZ0b2pwK1BUdDJyeVU3SnF4NmRVL1dOVDVKK3p1d3JmWE82MVVsVitNOGF3Rkh6NERqWmpZVmVUUnJQRHFWMG9xUEtUaWZkMEs1ZXpjTG55VSswVDdYMWkzd2owZjRtT0FiNmR5bmpncDk1VFIrK0FtNG1WYXpMVDNwOUErZEk5MndFaE5sSHpRQUErYnVRTlRyMGM1V05TUE41WjNSdFhLMzVROUFSOXdERUNPYXJQTkNTNjZUUEsrSG5OWWRuclh1RUxHdHlEaFhRRzZTZkQ3VnB5WGpJaDJmeVZaTFJwQjdOaUFaa3h3YlM2U25hMmVRb2h4NW8vd08vVWZCWG5mS0lzZFQ2clE3R2hRM1c2MVlRdnNYYnhHNDFoRzRBYUVWM0E1ay94ejFHWHFTOGNCTitpTFcwWkJhbEE2SE5jYWlEWTRnT2lGc2RnYkNGcGtxSnRJdU9IMXdibm1lT0VYTnpwS1l0UVBVUlhzMUUvVE1HUE5BaFJhK3dZeERuR3U1ZzcyM3A5UnhycWF2Z1g4RStTWWZtcml3TlFMNVNBMTczQmoxT3IyTy9jN1ZWQkdDNkJVc1YvRG4vL1Fzb0kybGZod0ZidndQZzkyRDNyUDYyUHorWjNYLzRQdXcrMXhleit3OHYvYzdYbGJmN0Rnd0UreHJzSHR2L0U4RGZ6dTQvdlBEbjFqQ2dMd3BkTEM5Z3dObTNBUHkvQVA0WWRrZnV1ekJRN1oydWdXOHB2d1VEUS84RmdQOGF3SDhQQTM1L1U4YjlXUUNmVzV5ZTNGMmNuaHd1VGsvdUxFNVBmaFoyUC9JWFVFbC80dU5memU0L1hIcmtNQVhIV3JtQ2daQWZBSGcydS8rUVViTTBKcC9CVWtBL2hZQ0V2RjlYNzgrZDNYL0lkTWNxd0w4QzRDY0EvQVAvKzAwQS96ZHNQamwvdkdqOTB2OS9DZ09hZWZEZTg4Ky83LzI2ZzBCTUpKVTFCZU50cFJjdzBIcVJqVzJhbm1Ua2ZlYllWN1A3RDg4QmZBOEcybjhkdGk5SStIaHdYL0cvWC9qN3o5Qy9QdXpyNTJGbklLWXlmT0tmRWZSbGRPODVER1QvQysvSGU4akVSZTlDQStyZzd5MEFYL1E5TjJaYTdUM3VuUDZSS0QyR3hVRmc2MDMxNDZicTZ1czNGWFprUmI1MnAyVk1xVHJJeUhXZGVRenRxOUZhRmRiNDNDZ0tOamRkYnJCZU1taW1PU3RLV1B1cm05eFgxeTAzTlFkaTRBVk0wTGpkWVdpTXhrNitIK2VFa1FpZGh1b21leUh6dVFpVTBMaFNnTC9oKzRVYUlIdytZanF5bW5DbG9ORWh6SG5zWHZQZytOWk5yTy84OFNPbWc2TXdDT1NVdEpvNnFERHdvaFJHK2Q0Rm5CYW84WjcxTkJaaE9wWDNFakNEek9OcUhvQVVVa2x6dUE0M1pUd25vTVI2VlpqVm9zQndWVmoxdnFnd1h3TmpPL3ZyOUdqcWM3WFArdGJPd2tqUGlLeFBWSlFTd0JyNkZJSCtsdUtFcktoZnpSOC9XdllCUTZIZWxHNFg3YnNJdVM2OGl3YklRUHdoc3JFWXlNRHNXZ3hMYWZ3b3o1UHVRZjJoc1lVOEkwWXJjUitxb1VUckhyc0NmZ2ZBRVJYdzVzSHhvWTlMSTVlb01GTVI0ajFKdkcrUTh1SnRIUXVORjJFcXAwQ3hya1Z4SXp6djVnUEtOTFlyK1p6UlU1eEhBcm1heW5lRU10dUhwaXpqNTl3dlJ6QTloSDBleisxK2M3aXg5N0lEeUx2U3o0V1hxeUdzdGMrYjh2NC9Pdkpxdlh2UmliRC9MOUVScWVyUFRwc2NuYldaMjcyTXJYYjlHYVVoQllEazlkQlFwTWI0ajcxNFB3YzVJQTJZY3pyeHFoRktJNzdVK01lU1pKdW1mYzljb3Q5ZDlMUEpLZDlaTnVFM3dZWmxqMkY2T1ErT1hxZzRKVFE1QWtFTDF6UHhkdUdMMXlyekhKbWdueFdHSmVsREp4Z0ZCMXM2d01sUk9CT0pCZ1pEV2hYRUVqQ1BScmtyWkVlSjVUYkRXaXdCdEV3NnFRQ1ZDcFJwNFhlMUNGNFcwa2tGQ0NQSWtPUWgyWmZKTU5lWW84NWRaTG1BYzFnODIxRTBVa2ozWjlxL1R0OHZJRkd5L2hVTit3dFpsN0h6bzdHc1F3SkZBaitmK0hjWFEvaTV6RTNpenc1cXNveGhORi92TnI3MFBwRi9jMTlPWVk0ZVZ5SWphajNrQ1Vjd2Zxc2dMdWRBamZyc0Z3Mk5YSHZ5ZHJiUGVXWDB5NlI1Y0h6WCtUcmxzMFBuZVFUUUw3ek9FYkl0NnR6bjdzckh5SHNaNzFiV20yMXlyL1hhbjRTdmNNK3k3elRXVTM1UEFEb3lmK0d6aHlpemdpeTl6MnI4MWVzdkZHeGl2ZU41enJLd1JQdk9ZL2FYNTVwN2tBRCt6SCt2MGI2ZWpjL05ZQUQ2K1h5SEZMcDlwWU9mZDRMdDBZN1JVL1Vtbko5WXp5N09ZeDkxNmRWTGRpalVJMmtEamxtemFtMmxPWTN6RFhIaTJjTFBJeENxT2lwZ3ZQbXlaLzFXOHpZZzFNZlBsYzhxUDArNmJrYzdPeFhuWVpGWGsyYXBmczcrOFRtMWVkRjV1NVlSanJhTkE2ZkRSY1R3dkhTaXJUcVpPajFLK2pqeXZLVU1EZnVNM1F2WFZPOXdqdklhQy92WHNxdUVvakpsQWg1NzZrMUY5UFBrQU8rZnBiOTcyaHloNU9lNlZzclAxODdQU1V1NWw2bVhuYW1jNWZ5SWRjWE1PUEdzVVQvdkJTWERtTGd2NHI0ZWVYKzR4c21PRnM0eCtWclZ6aXIybjVHM1FRZkdUdnVML0YrVDNYa3U5QXlvdkZWY1F4SDZXdEFSMlhOWDdMdm85VjMzeGl0LzJYWVBOdGlPMEIrdU5XMXQ4VTVvdFZlcTA5dUI5SGtCeTBUSWlHWFdvNDVmUytSTXZ6eTNETjVZaFQ1cFgrUDk0aU5rWHM1VTFhMHJzeHB4Yk55aVc3VktyM0xrRWFUbk1GQndCZ005KzhvbHpKQjZCd2FvdmV2MXRBNiszNW42OC83c04yRHBvTWNBeGhyaDZIMDQ5UFRGRzZtUElPaEdJb1NmTDA1UHptQ0E1S3ZlbDNPVWFaK2Z3SURBMTJGUnZ0c0szLzAxK1d3S3V3ZjRLLzcvOTJBYmgzZnl2b2tCcWFabTl4OTJQdU5nYisyT0QwWVd6WkJUUXYrdzc3NWhTZWQ5R3haVkRCaVEvd3MrRnFhVmZ1SHpUYzhTQ3YxZFh2S01FR1k2bmtOWTJ1UWZJaFBpSStRRE12Ykk2RDdHOVlwSExWL0UrZUY5MWRJbjluRUo1SDIyT0QyNWgxQWN0UDdROS9PVi9EeUZnZXd2WUlMVnAyRHpldysyTjllTDB4TUk2SzN6K1E4QS9DZXdhTjRYS0l0R25rOWhVZTY4Uy9xN3NNaDFLZ0RxalVmUDBYRkg1UHZTKzB2UEZhN1hIVTlYUFVTaC9MRXJaQWJCVUJMVFUrNWRMOXFlT1drUFhsTVFLK3AxSnRocENOeWxyVGdudTc3ZlVWVEFxOWJWWksrb3dZeG9TQkdRYk1pelJiVHFsckpDejEweTB1WSs2UU5mZXJtQk5RWEtLTDhSVUtZWTlIYmkvOXJ1dExFVWRTdjViaHN0VWtCUGhWV2V1UmM5Z0FBVnJNdndlVmVhUTk1QnJHbmNGT2pTMUhsM0cvTkFYdXl3MytoNXJ4a2Nsc2hSZVJUY3p1Y1dKY0lJQjZCTWs2WVJLVHIyU010MG5naDZSRjQ5MHArbWNxOHZCVmdxNEJYRlJzYzRDdS9WQ3ZrWlFVdFZtQlNVMW43UXc3OUY4MGpINWFOaWp5S3ZtVDVYNjFzclpWZU5QbGFLMGpvRnlqYW8wRURwTC90R0EybExXYWtZUm1JL2tzZnBMc2I3ZVk0NDRzOEdCZ2pUNno2MTVjOVJ6anlTNXhXUWppbWVxanlSWS9Sbm1YNWNJd2M1RitsWmxESW1qY2lVOHpqSGRDNWNJeXZMZWwvc3hzZkE4WTc5ak5Fci9NalBzNDV2NDkrZE95QklML3c3VWlmVExxYlNJV2NjK1ZnMTJvNTk0M21nTVkxWllTNWt6Q2xxRitVOTRURmpBSitocHpydjFTMzIxang3RkNjYTJiTi9kRzFhcGNuQStBaTRtUWdNcjVmMzd4SVFwQ0pkZXpaRnNEVVdFZGhwc0o2Yms4SVJMQkx4YU43TzZLSEcrMG44WHBUcDZkd3lPWEJ0UHBKckgycUcvaUZGNkNxTkNJd2U0NXdXUUZSbHZ1UGFhdmFLclpGaFhyWkYvbmFDa0QzOHZCcng1VFF1R2FQOWY0SlZRRW5qNk1neE9OSmI1WHR0STN3WEkyVkk1Mk4vYWRBYnNuODI4ZS9LZTUzcDRwVFB5bmV0ZG12OG9WWlhrN09zQUNLbkJINnU4dzdrU0lVdWZoNGRuMGhyK2IvS2dsTUl5Q1Y5UEFqdkE1bStuOWZtV3NZVFV6ZVMxN1VpbkpveWF3S2ZhMlZTOFAyWE1rdDA3TFVMR2M4dWpoNTB6dEtvSEkyaUs1d1RTTk9hSEIybEJzNFd6L2E5cERJTC8yYUsyQlZzZnorRDAwWmt3SkwxazQ5UnZpQ2ZWNW1iNS9VS3htZW4zdjRLeG91bnlOazZhRTlKdW9qejh5TjRpbVIvaDdJa0hkY3VuSjl6N0FmSXNySFN3ODVTTXo3elBEVTVoZjBLcFg1SnVaOHB3cm5mTG9SSDZ4M0hha2hmSVorWGNxTXpLd0FBSUFCSlJFRlVWa0NPeUJwMHhFcG5xN0xQcVcraytwVVdTQjFSQnI5V2Fjd2hZZHBZSkMvUFh4Yy9UNEJOMDc0N3VGWVNrRkRUWDVxY09yVjZuenBwemp4bmN0Z2FaWFpUWmQ5MlZPOEovRHc1MXlEd0ZKMmJ5cjdnbWIyU1o3Zk9lL2g3SGY3djQrZFZHMUNQZnI0V0dnZTBuWUtTMDRuUTVDSHB4ZGt1QVIzVmpYazNQUjFVUmw0bjd5aW04NFNDcmNrUkpvSTFOVDZOVEF2Skc1SitIblRidmlzYSt1d3VxZjF0ejNoSi9FOTVsT2hzTlg0K1FRL2dIQUJKMWNmNUdYbytpOTlwT1lBQmZiVU1QanFlYUVNaVQyelJ1Q1pIVkdwL3lTdUsrWEI3RWYrdjdYUHl0c0daNDZqbnk5cW5TTjZ3L29sUFYrVE9Ha0RiVjBiaHQ4cEMwVzZpemwwMUVEYktiNUF6eE0rdlpKN0pwMXBueGVreDlmbm9OS0RSMXNreHpmL21HU3pXcktzMDJURXB6WG1UVTA5ekRtSS9WL0k3eVl0QnJtTzBPL201MnUyb0wyNXpDTmgyWFVHWHM0OFdmbDhONXUwcnRVUFhLZzdXTXZyM0RiVHY3QVVNOGY0VDJLSGdQYXAvTnJ2LzhFbWx2aW1BWDRHQnhBc1lvUFdlMTNzQnUxdjNnMTBIdy90alBVcnk4OGlDNTgvQ2dMMi9nSUhaejJEQzQzKzdheHRieWxNWW1QMG5Idmw4bzhVam9iOEttN2ZQSWdPc2Z3bmc2N1A3RDU5MnZNZjVlQU1aZVB3U2dKL3lSLzRXd0YvRFVqdi9iWGozRG16dTNwbmRmM2lsNFB6aTlPU1hZS20vZjlMcitDNE1ER2YwRXlOMDlYN2lTd1ZUcFowUmNpcmxId0o0MDlNNEs2RjhBNllnSE1MMnpUTlU3aHRlbko1TWEyMTB6QTBKQ1hPNzgyNmJuNGV0cFJKQlRjdnpLaXdxSExENS8xVjAzeTk5QmJzaitRbHNyek82R3NqSzJjYjdVTHMvdWEvdm5Kc0RBT3ZaL1ljWE1xYlZqM09xYUtEbG1VZlBhbVdZMXdXQUZSaEpiUXBqVXVZeFZCZ3RVakR6ODEzNk9SUU0zV1VPZHUxTHJROWlyRjNqaGxMcTlyWFg4eXdORlR0NVJPMWJaRTljZTg5OUZLWEowVithS3BRR3J3UGtxTG1oOWUwODdxWWR4VU5RaHdhUjNycWF5cDFRdGZQYTFVOFhQTzhnQzl2MDhLT0F5ZWhDR3ExV2NVNmFET1Nxc2tyUTZnRFpBUzFGa2N3OTZrUEFsWFhmSGhWbElhYnhvVkNvSHNRMGxxbHlvVVkvS3I1eHpSTmdGV2tkTWc4c3dOWmRET3BoUEJTV0tWeGZWZWloS2lhcXRDa3d5TDJ5UmluTDZqeHhqeWtBekxHUDR2UFhLVUc1Qk1yOTBESmVoZmRlaWxGS2pDcnNGdzJWUUhZaVcvaDVvQUdkUnRoeDJDZmNDMlBrU0hZdG15MzcrQUJscXM5YW1uaktSUnQ1aGc0T1IvSk1paUt1MEFDZURRWHVhWmhWUXpjZFZDSXdySXJvV2RpYk13Q1lXK1F2ejg0dDVJZzdUY0c2Um80WW92ZXVHaXZZQnhwc2VmNldEanh5akF2dmswYXVydWFXWmFCYWZFL2Rsbll1MFVOVFJjbU81MTh6WXBDdWRSbGFENUFqeFE4UWpFemgyWlMxWnh1ZjhUN1FzRE9ET1FiZE9IOXRjc1Q4Q0xZbTU4aHpmdDYzdHovdTRxQUg5KzI1N05rWjhqd1BkZzV0Y3JUMW9ERUxiZEIxVWNlWFBpZUUxR2JsTEZOR0dTS1BGZ0FaQWowU0kzQXlLbmZzNCtpd284QllkTml0ZWUzdkpmOE5lVGNZZXF2OEsvQ2htSnB5RERGc1EvanNmTTlJd0NaSGlwSE9MZWNWL1FaNWJYUitsZVp1NUdjaW44VW9Sd0xHbXBWQXg3VkFYdC9yNkg2a3krd25nUmc2bDdib2xnQnNDWWk5eVNLME1BR0h5SE9wSU1hbXlkRlVTK29tRmRtT2thc0VEam1Ick9kRjNKZXlwb2N3L2tVRHFRWVRNTjJtWG1WQXA4c1hzSG04Njg4K1I2YTdYWTRENU4wOGgzVG91dU4vWHlETExhK2d6RGpEejFlUkJrWTZGNERhbGJjUm8vQTJNbmNLOHBEUFV2ZWt6c0EwcXB4YjJzZG04djVGbnp3dHNvZEdFVi9vbW9UMW1mcnpaMkZzNUJOczl3emQvRHc1QVBqOGIrYWU0cnlpOXpQNzN4VmxvNTZ4a005dXZPMlhGclFRZ0JiU2J1RDZFWlF2dFlnc0RwVHJ6TWp1MFM3MGVsY2RRL1JISVBOVDFRTzN6bCtQZldpUXZ0V1VHY0lBa1NkbGoydWZhcEhGVVJkZ3U5d0xkSEJLL1FuNk9iTTk5TXBCSFdPbGZwWEErbkJPQzFrRkpVQVhaWXBSL0R6TUErY2duZTFkN0RlaFRxVVBoVTVRa1QvWTc2ajNxdDFCbllvS21iSUM4bEhPVDN3VVRyK3ZxeDhIa0pKam82TkJWZjdaWlEvczJTZVZoWGd2dE5vOWxEZHRQY1BCdnFWbkZ0aHlaanZrQXoxZmNaMzVQK1VOT2o0dHQ1MXozZE1jazlna0M5bTh5VmRXcVhNSWRacWF2ckNabHhqQVJONkoxMzVjeVZ5cEhZSk9EK1RkcEJVOHh3bVVuVDkrdEdpeXc0ank4MjMwTVFYeFljRGF3SnlTby8zeEFEa0x6dG44OGFQekxqdTVyZ25uYVZCNkpBZmlQb0JGMWo2RjNRR3NHK3Zic0ZUTzM0VXB6ZWN3Y1BHblBDS1hndkJ0MkNSOVNqcDlEZ1BGRnY2ekFuQzQ2ejJuRG83eVFDOWhkeFBmZ1FrODMvTzIvMU1ZMFBrMnRrUS9kNVJueUpHdXRVS3dzd3JFN2xJSVpvZVBSekFRRk1qMzFxNEIvQnlBVDN1cTVYY0EvREpzZmY0RGdPL0FBTlh2d3lLeXFVRDhKQXgwWDhMbW8rcDk2T1dDZ0dwWWszdXd2WEFQd0QvMm4vOTVkdi9oTTdoeXNqZzlJVkc5N1cxTUpNSjRJMk5rdXVSeitGM0ovaHdCcFJuY2lPWDk1cDNDdFQweXJueFdMWDV2TXU5U3UvVDJGekN3ZHVsam04SFNaVk9oZVFLYjQ5c0EvaEFXOFgwQWMycTQ1ZCsvRHdOOW4vdDRxSVNNWUE0U2E5aGUrdEM3TXZKVTFZT0tyN1VDRkorR1JUanJmVFIvVndySE80RjU1ZkN1bjFaMHpFMFVJYTZKUVY1SE9LZ3BjU3l4Ly94K3FQS3k1eHpRKzZyWHc3R2pEeHVVcVN3N2dkdkFrSkpnMWpXMmdVcERGRVJmV3RGeGhiNmx1M2hlWnZ2WExCUzJnUExPaUNHUlBxMFNCTWRDQ090NUozNC95R0RtUm0ybWdhdldxY0pvVno5ZHVHTlVBYU03OU80MEFrMDg1NGUrNWxvbm5YNW9jQm9qZzFnVU9zbkhXTzk0N21rZ0c3LzNzTEhvYVZXeVZCRG1QWWR4SEVsUmxYZHJVNmIwQ3FoNy82dGlwQVlqeWhpcVBNTy9ieG5zdy9kZERodFVWR2t3MG1kcVNvYU9RNk4wMUJOVUZVMGRIOCtuZXFXMjJtaXlSK2hlWUhCVWFGRE9WV3Z1d251N3RGTURTUXFscjJjK1J3QU94TUJCT1RZNVhYZzlWRUtWL3ROUW5QWkhLRlV3Ullzb0w1cDJtaEdXcEVWeDdlaGxyVURCTGJpdVVGc3JVWEM0cDNtT0diMEZmNWNSYkFSdUw1RU5RcFRsUjAyK04wdU5yMm5jeURwSHplaHg0TzNRTUJ4bFV6cExVVWxkQy9DZzUxWWRINER0dkkxdHNSODBvRi9JV2lZYU9wZDc2QVJrVVhxaDROZTRxZHdSNzkrTmhINHBMK0NlVStNUzBCMGxwSTRMeVVDQ2E0STYwb2ZpVGxsZlkzVVFVSEJzQ1k4aWY1bkc2bXNXbnRmb25iOFhxRmNCUklBZUI0SjUzZHQ5cS93amhwTXVmczUrYkkzaUZickYvUlhsVldZbDRMNmFPTDFVZzJUdGZKSC9qU3U4dUNVVE4yM0h0ajVlV0x6YjkzMmxSRU9yRmgySHloV2FHbHpmSHpVUGpnLzJOQm9udWdBQmE2VWZhdWpXdnNhb0QvSVBCVjFwQ0Y3S1orUUw1QnVIS1BkOUF1Mzh6TzRzaHpmbFhhcnNxNWF1ZmNqeGJqVldDNTJNVGpkSnAyenkvYWRSaGtzOFUyaXJPbFRSSWFtcU0zb2JCQ1M1NW12aysrbVppYXdyeWh6SThucmk2eTdQY2c2QWRoVGZCY3h1OGlFeVdIb0hBbFIyRktaWHBvMkdQRGxGNU03ekZSVm4zaTRkTDhuTGVROHYrNlo4SlkydHlYZFk4amY3WG1TMkNiU1JZNDN2MHJCTjhDRkZZRFpsTlBxMnMwL25GZjdOUFgvbWUzWG1QSmxaaTJqUG9wekhlZUtaSTFoTlBiREcxeVlBZEp3anltdTBzVFQ1L2xLdVJWV0hFd083eXFJM3BwOTNnQmRLRTZJOFRwM3JJNGtFM3FOd3JRb255L2tXY0wyckJFQkVyMkNwOGgzL0xKN0hvYzVnbmZxLzlJTk9OSjExeW5sVzNWblQzVjRHZWtOK3JqeE1RUllnTzQ4QTlYUEg4MHE3MUJvNXU1bnkwUUtRcmVsZTgzeEhlNWVkYUNPL3Q5bHNSN0d1aW40T2lEUDBOdjI4cTh3ekdBZTBkU3dGQmVQOHhYRWtIUWhaYnh6Ui91RnRjVjdXVGM1RW9VQnRrbGxjZHRzcEd4Wkxrd0ZtN1N0cFZwZE95L1pyOXBKYUczeTJkaDgwSGZOanhHY0JPamFXcFkxbnBLaC8yN2pWRGlBZnJ5cWZWVXVOei92NTJsYW9PNitCZEYzVHRveEpTVTZhUzJZR2xHZEN4NkJ5cExhbk5wUlJmRmY0ZWRRMzZZeVd3TmRBRytGalVkckJjMGVlcWZ4OEk3Um9pSjFheDNNQXN5MWV5Rnh3RG5YOVZIN1JlU0lmdjVSNmEvTHBCRWJmT0lmYlFWQUI0U1l3b1BZdFdQVHBQUmlRK3kwWXVQZ2NCajRxZ2ZoQU9yZEJGamkvRHhQaVhvRUJ0Yzg5Y3ZlN2NDRnhqOGpGbndUdzZ1TDA1R3YrL3hvRzNMMEc0SmVRMHoyenoxL1lzZjd2QXZoMzN1ZGZod210NmxIMnhPdjlGZ1lJLzMxbGNYcHlGd2JvdmhsQTRCV0Evd2dUYkRldzhYMGFPZHIyTXpEaCtqbk15L0k5WkcrYWU4ajNxR3hnNnppRGdaZnZlLzlyd3RzYUdhU01KZDU5K3dNWVNKNktSQXVmb1JUNkVyTno4SDRFMnovdnd1NitWU0g2ZkhGNmN1SGo2azJkN2Q4bllYYWdJOEZyc0xGL0tQMTdFNlZRL0QwWTBQNkcvOXlCQWV2dklJUEYzNFB0cTZjd3A0aG55TXBVQXJzWHB5ZnYrcmllOC9QRjZjbGthT1N5ejljcnlCRVpZK1M3aEFFWGNuN2NvMytCS29HL3NhS011K09SWkRUdGViK21lRU1GU3BickFKOXNyMGVZMzFxRUNlN1VCMzJud3hEWTFaN09YVEk0UnlFM3RsMHpuRFQ1cmpjYWI5ZllzajdYS1gzejVFckRKOTBCWXhWK0R5NHF4RFloUXNmblpZaEI0enFscUwvSm5zSkFCbUtTOGFKdjc4NGZQN3B3d2UwT0tuZGJ1cEdHQXRVVU9jMlpSdG1xZCtRSXhvTVpHVEZDTmxpcElTVUJ6aEJQVzIrYTJTZ0FvKysxQ0ZtZzlHeU00MklxZWM3WFNINnZ3N05YSWxSR1pVL1BrQ3JqSXlEZE05dDFSMm9mUFd2dHV6Q2ZuQlAybndwYkJEam9FYTVLYVZJeWcwS3VhY2FpNHNveEZjNGJ6WEN2MjBLNURJWU9mUzQ2SVd5YWdkY1V1R0xGc1hYS1FMS1dhblJqL2J3WGtNYTZaSVRSTVZiNms5WmM1dnhhQnJSZzNGSHY5VVRiWmI5dllHZUtFWm1NME5UNk5DS2U2Wi9WazV4bmJEVDM2Q3h2Zzg1NVFNNENvKzBxRUtIUnY2eC9qWHlkeHdaR0R4ZisvWW8wU000aml4b1hDR2pRVUF2a1NBL3V4VFBwUTR4a2luUk96M0w4cllhUG9zaWEwSEN2OUpSOGZkeXhYem1HRnUrVC9zVUlUSHFPOHgwQ1NEUmFBL2xzNldjN2xVQTNLU1BvZDNSRTJNRDNsUmk0dVVjSE81WitESVdPRWdtazNjYjcrQXhLd09vQUtPNTZlNmtSVTNJdXR2Rno4cHR0L0p3R2xLNzBjTXA3eGtDWkloVWxyZVQvMGNDa1o1UU9EOG9EWTZUUENFWjNnV3M2TUZSazlCcmZYVGNWRUJwNW5YbjJvOUdaOTlQdDVBVFZKZk9Mbks0MGxJVnlSUUVLT1c5SkdRVDhod2I0bUZIb3NzbFIzVUJKMzFoMzRialJaSkMwMDBEcGJXdjdCRk1MK2NmWGsvUEZmaWxndUsyUXoweFEybDRpN1o2SVR0RmFlNUhITHlINjZwWTFWSDVPdytLUWRMeWRSZFpiZ1ZsR3p5UkFXc2JHTERsam1BRzB1SEtseVk1SWdObXVPSDZWcFNld2pCQkxHZk95eWZmaHN1MDRiK3lieW5yay9Rbjg4TjgwVWtmWk9kS01DTDZyRXpybHprUkhSZmNZNGl3YzdXYWNZLzY5UkYybUppMGw3MXo0czByenUzUlZwbGZsOXlxcmNjeVVlMWJJd0hoeVBoTTVOV1prQVNvcC8vY3RsYjJlZ1BWNTZlQVRkYUpQYXRIMHNydnk4MFFEbWpZWW01ejVJaThaVXYvQVVwd1RCZC9tMmVteVpldXBGWDllTTNmRVF2cE1XL3pVNlZoMEJtTy9nQXlhOHB4ckN0Y1VTT1kwbDdSWTVRblN0RTFqVGhjdGVodDBtK0p6T2Y5UnYxRTlYZWVneThiSlozVnRDNzYvNzVyVzlMb2VmcjVCMlgrdFp3V2s2ekdBREJMV0FrcFVQMWQrdDViL0Qxd1dJTS9pdXZXbHFDWU41UGZxTEpUMmxlNFhXYU0xN1QzYjVnelozdE82T2dqbG1wQkhLbGFXYkI1dWY5Z25nS1RZT3k5RFhrZnB4QmZyMTZ3YnZhQzV6eitBd2thU3dNdUszWWE4SnUyTnl2Z0twNUltWHhXbGNpSDN5anJvL2FqOHpiMlZkQVk1aStvVXpYNWUxbXc4SFNXZUYxMDd5dE5kZTQ1N2JPMzA4UVdRczdWMTJhWlJPcTV0QUV4NkFXQkpKVHNDY0Q2Ny8vQzVmLzZIeU1EaUdwa3dUbUNHMU04aGU5NGRTUjJBS2RkWHMvc1BmN0E0UFhsYkFjN1ovWWN2ZG8zODlmNzhESUQvQ2xtZ29NZi9GMkJnOVE5ZzZYeS9Da3ZYZSs3Ly95NE1yR082dGI3NStLSC8vaHd5K1BzWEFQNDlzdkIxNFczZmdZT1Ywa2NLck9zK2tNL0J2UU1ZS0Z2TWcwZXIvaFZNc0tXQitYV1lvZXY3TUFEelBXUmlkNFk4L3l0L2g0RGpud0Q0VTRneHBqYnZzL3NQengyY0hFa2ZDRGovc2ovMjcyREE3ZnZvT1BSZTkwYm1ZaVBmcmVTTzU2b0hoZStUUWNaR0FxbUwwNU5YQUh4dWNYcnlESGEvY2J5bmw0V1IwT29OeFBSNk5BNmRBZmdtYlAwdlljQXZBVyttb0RxRTdRbXVQUW5PTFpTQVBsUDVyR0JPQ3orRUE3bSsvaXVnTjMzekNOa3dRcUo3SU45MTNnZjk0MWdFZEx0Q2hUSHNRSlJycFU4NDNWYWZDbmRrU0txUWJ1M1AwRDczRVAyZGlyZTNqOEM0RjNnYzNtODkzL0V1RmY5Tms0SDB5RXlIR0VFNmk0NWxGM0RMdjF2ZjFIcThyTkpsdE50V3FNeFJTUFdQMDE3ZVovOUVrRzJBMG5JMUx3RzYyOGkwK3c2eTRqL0lXOXFGcUhNWXIyU0ViaEhsNS91emx2YVdxZDZTUVFubWZIV0lyQVJRUWRYMGZTb1RVWmJTd3YxODRBcXRlaWh1VUNxeEdyVVFCV2ZXTzhUd3pMcTR0b1hCcXNuZS91UTdsSmZHVGI0YjdicDNaVWFEZTR5T2lVWmtscG95VUpNWHlKTnI4NTJNVzdJSFI4aUc4UUx3REgwQlVFU3NSWTlqam9jMHF3VzJEdGozQmVnZ3o0NzkvVGhlTmE2clFxUEdVKzdOM2pMUEVTdDZScXZ5V01YbzFGVW53WiswUnlGcHY1cnNFYzUxSUkvbk83ZVE1VFFXR21jdTVuYUhLOGZNbE1OQThGS2VaMGVQVzlKT01nUTA1ZjNCQkFoNDl2UWVwZWpGVEJtZFpZMThibW13NHBrbWZkQitqaUFHVWhxMzR6dzZYZUE5eEd4empTeUhhaHJ0R08xYkdBeGxMQndmNlpzcWorc20zeitaU2pDMEZzQ003TldWL3E4R0hHOXIxc2hkbXRLZmJaNzZuY1g3VEtmWjVIalRHUEJNT1Jxb0d4WjQvL1FHd2VIZ2sxVG1sY3dkWEs4ZXd4am50c3RRQ2poOTJJV21ONUwrZTZEc0hmbTVSbndTek5VTUFyMWxucU5KeGszRjBWTDZ3d2pMcnFLR3JoSEVtUU5BbEhmVFhhb1YrUy9PYjZ1b1VaelBkYzNaRG11aHNrSGk1eWdqYlRXNmdjNE9kRkFyenZRMWlzbzdSWXJmSmtlNXFDRWJLT1VManFWV2VHZDZkTlFnWDB0QWlJK0ZQSkZ5VlMzU1hRRU0zdUdxR1RCaW4yaGIwWDAxZGhxNWJjK1NEbXBrRURNcGFOYUhHcURBOWtkTmVZM0hWanVKR0VDVkQzVHg4d0lvN2FsVCtiazZHcENYY0E5UUxsWUhnQmx5aExBV1p2SlpBR0E2YWdZMGNNelRwaDN0dG9iUmEvS01RcDlySkJPRm5GVTZJbEZXMHJFQTJkYkN3cnI1bTN5V1k1OEdnS2NsYTBVZXl0TGs3Q3pweW83NTQwZlBSUWNnNzBvZ2k3OUh1Wk0wVzUxaFJnQW0zcWJ5Nmxwa1d1VG42WDJVVVhoTGxBN0FsQm5XOElnMmxQWU9CZDJBUFIyMGcreWRzb2hKdjJxOGpIS3NSaVIrSW91dXFYeTIxUUVLV1Y5Ui9hV29WL1dFSWJ5a2thczkvUDl0ZllnTzRaUnZOVE5QNS9VZ3NRaFlOSVZsR2RESVVlM0hsZTRMb1VkYUtGT3pUd1NNVmsyWkluZ3N6MGNIRWkzS1F5RjBSWGtKSFErcWR5YUhNV3pWLzJUOFVjZFZPWmw5bS9nYTZGaXZVNVQzdFBUOXdNL2p1RlNtN3dJSVZiOGJ5Vy9TVkFMSVBPc3BjMVFqUUcyVG5UcTEvVFd5NHdOQjRTampBYVd6a3RyeitvS0JXT0w1QTlyOFBOb3AyVGNGbzlPNGQ1RDNocVpXMzlVcG9BYjRLazZqNENqSFJrZjZZcjdVMWhka0w3MDZLZG9YV1RkbHFhTHZ3czlwQitINGlIMlJuMTlJR3pVN3JmSnpkU0pNVHQ0aVMrdTZGWDFwelY0ZTkyaWVIUStTRTdkL041bVhqaVNGZzNLZ3B3bjNrWE9nWnlueXdxSnZZdFBZZEJxcC9aN2VUeUVMR210WXBPNmxwOHlsc1BNcXpOQ3doaGxqRG1EQ0dXQktOejlmd2dTeVN4Z0llUjBqSWZ0SWdmSm5ZSGV3M2dId0w3MWZYNGJkV2Z3K0xFM3Z1N0RJVFhwbkhQblA1MkhSdzRmK2N3L2R4RDZXL3dEZ2oyRUczM041NzNYWUhiWk1ZL3dhTENYMkt6RGcrUzNZZ3QxR1RsZkRSV1dwenBHUG1TbVJEMkVBOXdIeW5ianZ3ajFmdmM3WFlOR3NZeGlJdjdQQTVldjlPZGhhUDRHbDd4NEIrT2YreUJWeUt1UjNhcW1NdzkzQkNsZ3VkWncrdnAwQXpCZzV1emc5ZVhWMi8rSDdmbmYxcTdBMXZRZUx5djF3bHptUWMvQWNOcWV2d3VaKzRaK2RJUVBBQk5lWlR1Nk9Wek1COEp1d083SVpKZjhxYko5OEdoWTEvaUZzWDc3cTczMHIzcmtzZlZMRExwV0JROWc2UE50bmpYL1VpeEx5U0lSM1lONjFlbmYyaU85NlY0eWRoWkp5SGNCa0QyWityVEprTHVNekE0MkF1L1NoTlk5OWRZdlI0THAzZ3UyOUYzNVV5cmI5MU9TN3JIcnZyTHBHKzhrSUNSZXc1bVdxemlPWVhQRmliaDUzRXhodFAwTTJCQktnMlhnL1ZaZ2k4RlhjMGVGNzVEYXk0bmVCTE5pcW9Ib0VNMkt1NUIybWtxRjNQV0E4RWpDbDcwTGVaL3ZzbjNyVWJwQUJINmFXNXYwM2pHeFN1citXLzljd0w4RGxydWROakUxcXBLYmhTWlg1S2V4YzA5T1I0NGE4UDhhQSswOTYrcEtNNVZ1QWl4cWQ1L3hFWTJaVmtSSmpRV0Y0WngwS1lQaG5VeEhhVmZIWFBsT3BpTWJpV0dwcEgxdmVyNVZ4YXdwajBsY2F0QW9nQzNrdmF4U0dHaXZaeDR0Z2xCL1NGeW90WGZjZ0RqSTJ5RDVTWTc4YVhiZ25MMzNmVWFjZ0tIdXBmYUFpR0dnRzc4SUZTbS81Rm4yUVBoVUd0eVk3bXJDT1MrU29HdlkzbldVNTh3b0tzMitYc3E4T3BVNDloeXpuUUJGUjNuV2R3aDFrNHpublpXdTZZcWVuQUZKS2JGV1l4OGhwT2tkd0E1YS9zNjZ0ZmFpYkRpL3JycjQwK1U1U0drRDA3SEplQ3hEUzl3QU5QNHNoZktocFp3aWgvakdGemZIRSs3R01mZjJvWmF6cmxtQXcySmFtUDRFVzg0NzdIZmRvUDdVWmpLb0F5cnZwbWh6OWZTVThMa1V5TnlGS0E4R3hoTEpnYlE4MDJWRWp2WXNndTVLT0J3QWpHYnpDNTBEZ1M4R0FCQmxyOWYwdXVia3BveDBMdzFmdCtiNFNaQ2pXUitjMW5ROEM2K1J6bXNWQWphK2RxYjhIOXFkWGJ1N2g1eHE1UXdDS1BJejdSZmM2allnSnFKTHFSbk9MdU96aTU0d1VJUjBpaUhiWnRDT0lsTGNDV2VaaFpndzZnNDhRZUd0bFhqU0NpVEpsbE1kU2RCQlFST3dxUDArT0VnanJOWVFmaytmMzhQUG9GTmxWRDljbzN0bXJFZFVMNVBXN2hleWNzd0h3TE1qckkwaDBpMzkyRzlsWmkrdko2eHZPaHVyNVljMDMwbWNXMVMvMVhsQTFka2Q2UXBsNGpTekRwM3VqSWRrbHR2UnRodXljTk1Od2Z2NHBmK2ZNZFFIS0tCd2JnMlBHeVB6OEVHWFdoNzQremZ5OTZIakhaOWhmb0p4YjZHZGh6alN5YTVBRHFjaGxLcDl4YlhpT21ENzlSOW9lRm1sYzN6bHNKTWdnMHNkcnRLOFp2OVRSaGp4T3oyYU5uNnREbC9KejByM0lqeWUxdlM1NktpRFI2ZUY5UnNiRi9xWSsrZWUwajYvbjdUdC9sUVpvaEdheVJRanRvSTFBd1NTZUFkVmhWakE2dG1nNitGMVhFYjZtaFRSRmdibGl2emZaWVJ2eVB1ZmhXamJIWGZvdjcxRzJZLy9aNXcwcTU3UWlPM0tma2U2cUhqV0dYYmV6OEhlNVY3alBVaHZTRDdWM3NBN09ad1NUK1h5bkxCU2UweXh4dk90OWhKeTZPUFZMOW1SeW5HNHlvTGwzbHEybUFnSnFYM2ZZZnp3WFdoUUE1dG5ZTktYamIrdE83bzc2OVIwVzhvbkJEZ3V5My9sRG5KTDl2VVRXSmF2MXhua1J1WHdEMC85SEVDQjVDRStXdnJGTk9wOXZYVmVoTThrQlcvaWRSczFQVU43RlBJU2ZUd3Fpd2loUFpNL3YxNUNqSWUvNS8yL0JRS29qV01yaEkyUUE2MzJVeHB2WFlKdi9od0F1aDZTMzNhVXNUazhZQ1R1R0dWd1BZQURsTGRqZHRQOFVkdWZ2dDJEZzVHM1lSQkcwTy9KeC9acFgrVzBZSVB6VHNEdGZ1OHJYWUpIRWI4QUF2VGY5Y3hwZ2J2bmZhKy9YNndCKzBmdjNMb0MvOGI5ZjkrKzVpYjd0MzU5MUFhQ3lSdnhOWXdqVFdMeEFWbEJvWEhrR2RONlh1N1Y0Sk8zUGUxdC82L1UvQS9BL2hFZC80R1A0YXhqWS9UNkFkNW5pbUdtZEY2Y25oN0M5ODhKL2VNREdjQUZ6VzVwbjZkc1lGdW5OMU5PM0FSek83ai84bm44L2hhMGxRZHp2N2dxUWhqbm5QY0FqbE14OUl3RDNTSjU5RGRtNDlDNkFweDVGZlFoelVQaDU1THV6Ri83Wjl3SDhsVWRHSjROQ3BYN0FCSHNTcGlYTVNlTkh4bGgxMDZVbW5GQlI4ODkzV250aDZqc0xUVnVNUTlpblB4OW5FU1ZyR3pnd0tBTHNHdjNvVFJGZGV4NFNaYmFuVVMyQk9nRmMrRVFZaDBWZ3BOSzlsOFBEZ0hhMmdrUFhySjhHNldTc0pKZ2k3ZE9ZUktQMUREbHlqbDU3NUNrWFlqQWpJTUgrMTVUTVcxSVhvNnBvMENHNGZENHZRV0VBVlpwelQvcWdTcWJ5Wm81TkRXWjBKa3VHNk1wVU1lcVpTc1VVY3MvOERrWXdkY1lDU3FFZXlPQXpsWUN4akVXTmV1VGZFMTJ2ajdJMEpVQU82VmVWOWt2L1dRcURZakRlcTVPZTdqRytweURDcFBJOSs4TTFqa0JHTDBBUStxMnBpVGp2a00rU3g2cjM2MEw1b3RBS1FJd3pzczQwam5RYXI3MGZ0V3dibXE1dHE1ZC9rNTBva29FYjdUVmtPVU5XNktoRUg4bi9sNVUxSHNIa1Z0Wk5KWkMwNEZ3VS9RUSsrZXU2Ymp3bjZwRStrZSt2NVBNWVdVWmpVTHBYR0haTzB2MnNUc01JdEY1NC96Ynp4NCtleXpPOEc1aGpieGtqQkh6UXFJV1dNdDJVRVcwYm9QQklWZ0NGKzJHRGJEQldlWGlDQ2k4UUlJUEdrSzVJSjcxcmt5bStsd1NseE5DdWtmSzNrQ09USjZpQXRuMmxzaWJuUGk0NjdaelBkekE4M0hTUk04aHloWUYwdFNKejlocnFicEtmZDlDREdGWERmUlJwYXpJbSs1NGdyUVZDbXJ4Z01FdDhzcmJIeEhnYSthaEdIdzZLY0JiK1VwVWhtd3dTNi9rWVpNQ1R1cE1UMFM0eXJ0UkR2Vk1MNVNMMmlmTmF5TE5pUUZNbm1hb3gvcU1vUW8rNWRrVlVwdENyc2M4WkhYUzQzc3JQRXpBWWpaUW9zekZRUHJ0RU5tb3E4QUI1aG44VHVGSUFtRkh3UTBBN2xSYzR6cmhuS1grMkhHOUV2MDMwR0NneTZyRC92VWJIbnZOTFowTmdpek9BeUwzS2Z5aHYwS21RZTVEQkQ1OWkvL3gvQnBTMHpxWElDN3dQK0RieTlTd1hBSjdxdVFIYXFSR0ZwNmdjUkhsSjl3NzVlblRXSThoN0NMUFpBRzJuTTg0YjdUS01aRDRQenlRUVA2NnI5Sm44UERxWGFIdTBBM0VmTGViNXFvcG90K0k1S2NEeU9GK1ZmdERXbUp4YUs4OGxSd1RYelZyM1FWYjRlY3JvaFE2NVpsdHBjb3Jaa1p4RDBzR1hvcXNPTFJVQWhjNjZPOW5EaHdCdk12OHZVejh2bkl1VXhnV2F6ZFRwQ3ZBREhYS3A4SDNXV3pzUFdsZWtqd3FFRE9HNXpEb1FuY3c1UHA0WklKL2w5VHc3V1pOZjEyUUJPbitRaHV5cm45UHV4TUw1MGN4RHBMVUZZS2d5aGJ4YmRaYjdLRXBUQXE5MERFbzZzWnhieXYxMEpLbk5sUUswWFBjeHNyMUd6eHZwSytsTkJKWlpPTGNybFBQSTh6c29MWE9VYVZFNlcydm1UZ0wyVlFkazlxbERwOTNidnRmSTlTQUQ1VjUxbmxXNWFxMS96MHRIUWoyYnZmSjFrSCtpYzhoVmVIWklSaU1XNnBhcXo1NGp5TzlOQm5rMWExOTBMRWt5SGZKNWpzNnNQSVBrejMzMmNaMjcxdk9peDVQV0xVTi9WRDlRZTAza3MxVis3dDlQMHlHb1JCcGV3ZElqTXpMeEJVd0ErQ3dzWXZhTDNrRXE0M2Y5NzVVRGZTdFlhdDIzL1AzTjR2Umt2RGc5R1htVTUwMlVpOW45aHlzSEM1OGkzeFBDUmZwemY0NUEyMC9BSWxuSHlBTG8rN0QxKzhZZkFBQWdBRWxFUVZRbzNqOEE4RmN3TU81YmxiYWUrdSszZ0pSZWpZWlh2V01NeUlUK0RRQy9EUU1vRDd5OU05aTh2UTVMb2Z3Vjc5OFhZY0Q2VHdBNFhKeWVUQmVuSjdjRWZBUmdJSzcvclAzbkJTenE4OHo3dElHQmhaZmV2MHUrby9Wd0hRUmc3Q3l6K3crZnp1NC8vRE1BZndRRE1kLzE5cDRncDVuN2pvL3J0d0Q4Qml3NitMOEE4SE1Pd243Wng4TUk4ZGVSbzZKLzJjZi9KUjkvS3kxWHo1N1p3TmJ5eXdCK0QvbCtacFlWN0M1cUlLY0UycW5vbk1QQTZiWHZ1NnZaL1llWC9yL1dtenludmUxM1lQdnFoWXhsZ253bk01MHR6bUVwcE44RU1BME9HV05KeFUyUFpONEIvUnB5aFBmSERrWjluR1grK0ZHTjhDYkcwRHc0bmpRVkkxbGZmYWdMQy9ENnFuVUprOTVJbndna2JlYVdBdU5IRGZ3bE9CY1piVkhtang5MWV0MDJENDVIZmZQdjMyK2xTZExXMXYzdTg1OVM0K3l5L3FHZHdwQzlpMkh1SXlyY1gwRFArdXhUS0FUNjJsNHJJaVRVVy9SemJ2ZThYY0JvNFFYYTkvS3VIRGhaeVdlTCtlTkhIOEtjZ0pocDVBVThTbGhlMzhqdmx0RHRmVm5BZVAwelpPSDlDQTVTelI4L2VxNENsZENIZ2ovNTU4OVJTY3VKREZ5cElLMXAyU0l3R2Q5UFVhRElhMzZCekJlbU8renhhTFJPbi90ZW40aUFQbEpsUDh5dEdrNC9ycklKdjVVK0ZJS3h6NCt1RGRNK1hhSnVnS0pNcWRGQWZZQ0FLa3FhVW9vR2g2aGNqSkhUZGZVVzJYOXgzeVVqZ1BSQlU0ZXpiczBpVTlSQk9vY0I2OWhCQTlKWVlQc3dHczlyZGZDY3h6dDV1TCsxMzR3VzVYT2tCYnkzc1ZiL1VzWkU1VXU5c0xYdmgxSVgxL2tBZWE2dXZMOVg4bzRhYVhpZXRYMmVXUnFaajN4dTdnS0ZrV2VGckZjQWxwYnVvSGx3UEd2S0NFR2VSL2o3aHpTQXVsekJLQitPWVFyWlc3NG1iRzh0ZGFZK094Mm1rd0s5MXNmQ205a0h6bGx0M2prZll4OUQxOTZtYkhRQU8zdFhIWFhRQUhxT2ZCWUJ1ejl5N0Q5SHpZUGpYdnJuOVRKclR6UVd4ajN4Y1JRRmRHZ1VHWXVSdTdQSW5JM0QvMFh4ZmNXb3dKc3lGbzk4TDZiNTgzMms1MitwYmZsKzVmN2laNHgyNDlsUEFGdkZtTkZ5cXBReDB0aEozcW9BSHlOL0I0OTlMcW5USzIycHpLcjB0MWZlbFJMbG9JM3pxZUtzRDZ5blNwZm5PUVZ5TXJpcFBPdC9LOTlLWU9MTEtBUG1oYlN6QUF5UVFWdldRUjYza09jb1F5N1FIUlhLK2RBTUdpUFlIbzFHeTVIOFhpRWJDamYrdk00VDlhVHBFRjFHZEJNRmluUVA4WHVPSDA3cjFENUFlcStncG81VFU0TjI5YU9MbnpQTDJCR0FXd05vNnhueWRXamtNVHlIUE5lVW41Z3RrSFNPS2ZkNVRWYXQvZ3RwZzRaZDh1YkNlQTY3R2lISnNQUHNBS2RYWUJBMDRHL084NlcwcVlYOG5FYjhtYy9MWFhtR1VaaDBKaHJCVTlRS2Z5b0FBdUhQVStGMWRJQmxWUFdSdDNjZ3p6T2JZVG9YRUFjaXIyTXAvSnpYbmFYOTJXUm5tbkZOWnZNNTREemZhckt6UlZkaFpGS1g4WDhrWXl6b1AyVGR0OWtMcEg4Y2Q4M1kvWEh6ODFqR0FBYmJPZFFtMHNQUHA4N3ZCa2RSRDJ5M2tLV0VuelBpdnRBVG5KOXpmNlgxOVQxTS9yS0NaKzZwOEhPbDlhMysrRjZoUEFHVTlBbnp4NDlhVHFzOU5xVXVoem9Gb29ETWM5YXdkWnRXZ0JadGp6UlkwOGxlSU5Qb1hXeVFvL0REb2xjYUpCbEl4eTUvNi9zZm0yTWpNcjNUSDZXM0VKcEdXd0xubVh2dENuV0FmNE9zMzZuREV0Q21RWEZ2NlQ2bTQ1RytuL1RaSVlNVU9WR2Q2MVhmakdtR2E3SVExN1ZLLy9hMUhRdElTWjF3Q0EyaS9NRHpDN1RYajU5SFo0V050OU8zNTlYK3BUSmY2NDV5T0o5VXZpQnk4Z2lsYlYzdFk1ZHc1K3N0L0p5MmtkdE5kdUlBc2xPTkFyR3RJQkF2aFF4V3NYSHkzRkkzTHpLZ3VhMlZtVkVvMDlYc2l5eWt4Nk53ZmtiK1dkZStYZmNTSVUzSDY4RFRIWmhROXlWazBPcFRNRkR3QWhZQld0enJHMEFzMWpWK0dXbHFCY3c4Z0Jsc0wySGc2eS9BZ0Z0NmpYL0hmK3M5dlJ2djIrcytycStpakFMK1Y4aVJ2WUJGOGI0S3BQdGZWakRETWIza0xtRmc1R2Rod2lvQjJXL0FGSk5EQUwvamY1L0Q1dkFkYi9OdFpJSDU2ZEJvMkYxS1NPdjhOb0Fuak5EZG9RNEtwQmV3c2QyREFlMy9FQlpGellqZ1B3THdQd0w0T2l5QytMTUEva2xIdGQrQnBVcitCakxUb25mamUwQVp5ZXo3YStydHZRcUxubjFIeCtMUC9BUThnbjEyLytHVFhjWlpHWGZ2UGRXeUQ2ZXdPWGtHRVNCZ1VlYmNTeitON0pINWw3Qm9lZldPb3FKRWhnSmtveU1OazBld3VibjR1dzRBeHlJTUQ4aWVZU1BzSUNRM1BhazArdDVCanhmUXJtVVhzUEc2d0tRcW4vS1pldS9SY05xWGlraUYwdGI5d0QyS1RQTFcyamFHcm5YaCtJZk1nelBIbmU2NCs2U1dmZGFkeXNxQXRieUxIQ24wdk9PNTNuU1RYWFh2Szh6Nit6Rmx5ejFrK2xsTDUwbWdKS2FabzlQUUVudW1QS3owaFdjR3lNYVpFVEs5Vi9DWG5vT01aRkNESFlYU2RHY2JqSC9vbXZIdXo4UXo1am55T2Q0aG90NzNlcTRWUE5BSW0rU2hQdytlLzI1ODJuaWQ2Z2xPT3J1ZVczVE9nZmZwb2taZjVMMll3a3NCNnBiUnV2SytlcWNuQmJobUZCaENYMUFDaGtDWkNuS0RIQ1dVK014YzdubnBHbWZzQzhxMFNXc1Iyc243QzZlRHBoN1pSc1ZYamVZRTFpNWt6WS9nRWFiSUJwbnEvVlJEU2xPbXJvclJIT050ZFRmWmc1dXlITWRMZ3k3VFBnTlozZ1lzNVpmdTBVTjRWTkhjdkpGcFJHWWFZNTR4cFZIMHJvMEduWkU4cjNjREpyN1g1UFRGWStRb1Vub0dSL29DbEhlQTg2eGZ3WFFxS3B2bjBpN0I1ME52VjlOS0sxKzlqZEtRUW9DSEJwRmt5SnJudEpEUlVXQUtqL2lPUExISmFmMmlFVVZCa1dYYzUwMk9aR1dmRmgxbm51dCs0TzFlQ0EvWGxQbmtQN1ZJVDlKd2p1V1owSkJCZk1rVi9sWGtHVGRWU0pzRzlvVnJwQTQzdmVlenlkNzNFK1NyQTJyeWtVWVlUaU5OMStkMjRlZkNTL1oyRUt2d1VLWWxibm5jczQ5QUs1c0M1d0hJMFJ3dlRiNFRlbEcxcDlUbXNESk96U2FRN3JRTTlWUmxYZjlPK2JzNisvQ2NyZ1BkU2xGNm9iN2t5REp2cDlablBlUS8zR2Mwdk5YT2RyRStUWTR5VGdCejN4NXIydEc2UU5ZL1drYjRxR3VFWjlqbkRkb3BLQ21Ma2YrcXdaZGpUT1B2NlMvNVJqcS84NXlsUnZWNkJkc0pPSkR1citVem5SdDk5a3JXbkk0K1FPWnZlNE5BZ2IvUVFKa01pZ0NlYitIbkt2ZnlhaXAxd3FCdERqQ2F6Zms5Z0Vmb0lGOHpvN3lBVjEwdC9YdE5iL3dVMmJoZXk0ekJ2cE9uVG1yUGtqYktXYW5LcXVHY01jWG5Hc2JqTHIydm1JY3JXYngrWnJtZ2ZGN1lDcHA4elFYM2d0SjBScS94dXdYeUZXQkE2U3ozWVFjL3Y0VjhmUXVONDhyUHgzUEpUaExHekN2eXJ1YVBINzJJejhpekJEK0tLSzZtZEdpcE9XQWhQRXU2cjdyRklEMjN4aHR1c3ZUcE1aVm5VMnBZLzJoUUJGK1RveFdMcVA3d2pQS093OXJhU1YyRGJSMjcyR0w2NmdqbmkyZVdhMVBqNXpYOWZJWU04dDBJUHhkYXJYcXF5ZzRzZWpZSzJVcnFZT1lnOWl1bWdGNml2Sm9LODI0NU52THpsbU1yMnZ5YzcwWEg5Z1Qrek50UnprQ204M1NRNmIwR0pPbzNUZW1ZbWdDNDJydlNyanJ0cVQyeHlzLzVmNFVHazUvVGhrS2FyUG81Ny94Tk92WThSNm9PUFlQRUlLam5yT1ZjRXVoWFI3cE5VMGJLNi96UXlRanlYUzNhTkdhOXVSRWFGdlk4N1JXOStvN2FOcEQxeG5XWVYvYVA1eHNvd1c3YWxPSTR5VGZWYnBQb0hYcHM2Q0lYa0tmVTBvaHJWb0JlbTdEb1Jjd1VmQW5QQmhYbGdqQ0dYcDBuMEdlT2ovdEdkYkhOUEdmTllFWXc4dm56cm5WcVNoc2UwSGJ5S0dSNUxiMGVEUXFpT2JEMDNNRzBieUtuQlFOc3dtaW9tQ3pLbExrMFJHaVVaQjk0bG9UM1hjRXNnc3FMMDVQbDdQN0RDLzk3RE9CbllhRGsxMkhBNGdvMndaK0JSYkZxaEN5Rm1qalozNFlCZDArUjcvd0ZNcEhYQzZaZjg5K00raVg0L0NYLy9HdGV6NS9DNXV3SkRNQzdCN3ZMK0FEQXY0WkZqVjR4WW5SMi8rRzFEQk0rdDJOZjEwdFk5UE9ycURPWXJXVjIvK0Z5Y1hvQ1pHRC9HV3llWG9FSjluZVEwL1VBQnNhdkFQeWpubW9Qa0wzN1Z6REQyRThDK0RsWXBEWVdweWRQUFQyeU1sL0E5aVVqdDdTZm04WHB5UlBZUEYrYmtBN1lsM1FtdUVRQThMM1BWN0E1WWdyc0k0Z0hUTVU1WWlXUnYycmtZai9lUjdoTCtlK0xGU2Y2Q3A2dmtUMjBCM20zNzhsOGIvU3UyRjNxR21pZ29ERzFsV0tSVExYSkVSUzhhNENwTDFTSXFiV2hocXR4OCtBWUdDakVlTnVERkk0T1pZaGVjL1RXVkVOM0RkVG05OFhuTDB0cDNLWHNvbUR1OHB6VVQ1Nk41c0h4d1Z6U2s0V2lna2hYWFVjQVpzMkQ0dzNNK0Q2MHoxM0tQM2twby9Ib0pSNzN4bUh6NEZpTmlJd2lwS0VzdGxjek5xcXlOb1ZGRFhTbU9lc1pTelFrNlYyVjhENnBjczQycVVReEs0UWFramwrQ3RrWFBDUElaNUdHb2NMamwvdTRva3h1Zk02b3hGSVIwM1lUejNLaHRHdk1hcUFyRkFzZjA5VDdPdkoyR2ZrTS83eG1xSndnUnhCRTQzcGhaQ2V0a1gyazRKa2F3V08vVzBZL29KV3VrM091ZEpIMUpjVk9qSXV4YkZVd1pjNm9BS3hEZmJxUDE4ajBsSXFUam85eWdScHIyVmU5aDVyalphR3hMb0w3dXhqUWRLNTAvcXVaTHNSd3NFR09WcmxBTUFqNmMvU1kxY2huemdYM09CV25JNWpITVEzdUcyVDVrNGIzRkhuQWQ1b0h4d2tnRjU3SUgvSTl6U0l4bHM5U09qSXh5aHpCalo5eS9tam8xanVKSVcwQTJSSGxUTTQ1amVMd05uUStOZHNONTFRTnhIcUg3OGpwL0xMSnFmUlpOckR6cVpHOXl5YW4zS3VCdjczM3pIbi9tYzY2QlJDSDUyaU1UbXZjNURTYW5DUEE2SWs2UjZ5Y1RwUHVMRkZHRUIzQ29xV1lXYUt2WEhVcHl0Y3R3Zy9RUERqZWVrL2xOcU5NcUp2enp6MVBZK05GeDlyUVdObFg1eUVzQW4ydzBYaWVvOHRxOVhGdkVuaElRRmlZaTJuejRGalRsWFBkdVk5am16Vit6bk1KWkI2MDAzMWlIV09JQmoyT1dXbEZRZjlJendNUEhzUE9Xc3hRa1lCVWtYOVlDamsyakJXUWFFVS9TendEN0pNNkVLMTcrSG5OU0t5R3VvbkxDK3dQMTRReWQrVG5IQytOcGdvQXRVRE9DczlSNHhuZmE4a000WDg2NWRDUmpvWDdnbkoxbklkSUExWG1vTUY0MnprZ0wrTjhYVFhsSFk3VVJja3ZlUzc0dkRwd2taL1haQi9WWGZWenZ0czY0eFZacWF0d1hUUmlqMDZLWGZ4Y2VRU05sODlRdjQ5WXM2RUFwVTVKQjhoTE9OMkc2UlhjUjh4Y3d2azZnNlY5VmdlRDI4aDJ2RmpJYTF2NlRKT2pjbHY2WXFTRGZzNDRqb0pIZWowcjJKbTQ2M1BKRElJMDVsYjVlZlBnK0E3S3F5QldrT3R0NW84Zm5UWFpnVzhNWURaLy9PamM1UVRlaTV4a0pUR0FrNThUTEZZNWtITjVNYy8zdHJhS2ovbVp0MU1GR2FWdzMyaVVsTW9jUEFlM2hmY0RwWU9YbmcxSVBlVG5XL2Z4eTlMam0rd0FBT3BTZmM5SDRBQTlObkJwZ3pZK1pwb2tjQlhwSGM5UHRkNG1BMWdyOU14ZGxCWDg3NjZyTzVTZms2Ylc5UE11Zms2WnVpZ2RQSm95QTNuQTFHMUVlMmVuRUYwNDJSbDhIMFpuaUNpblU0Ym4vTkdHd3ZOSnB3NkNPM1JZUFVKSmIycjZJbENtalUvMk1GUlNHdk9mZWI0enRsVUNQOWN4SmVDV3RqSVlqejd3ejFJN0hmeWNzbUhVc1hWdVdzNHRYcUxNMU12UDJZNnZlZFRQMDc0U2ZxNzhWT1UyMmgyNjVyNVZtdkl1NGJYTWRaUmgwdjRVK1loajFSSWR0OVBjeXpOcWwyUS9yaDNVRTJSTi9qMkVQaDdBSEVYUEVNQkZrVGNWeU5YNmRheWNtNmpUNlZ6R2RPeWpwc2NSMWRjeTJrSDRYVXRlVkRtOHN1ZklxNWhaUlB0STJmQVd6RkdDOGtYdk5SOStuaWdmTEpCcDVoaW00eTk5Zjg5Z3N2VzVmN1pHeGxYanVCSVBFRDdFZmpKWWhMYVVtaTZSU3BWb2JDdXordzh2WnZjZlBvVkZLMzROd0w5QkJqVmZoWUZici91Z3JtSUs0cDc3YmRsNUZiNzM2Wi9XZndDTFV2NDBEUEFGWEdoRUZzQVZ0RjdEMGhGL1R1cDRBbHU4Ny90N1ovNGMwOXljZVovdndDSmdmeFhBYndMNEZhL255d0Rtc0dqUDM0SkZ2NjVoRWIvZlE0NFFmVTNxbWVDR1FUMnZTdy84QllEL2lPc0JvNWNBeGpKL0M5Z2VlQXFMYWw3QmdGLzQ1MzNnTDJEemRSY0dodCtHUlFzek9pSVpBQnpZbjhIMkM5TUlMZENScW1GMi8rSFNmd3Fod2RPUzd3V0FkeFd1bWYrKzhqYW1pOU9UVDhQbTRoZDlYRlJtRnJCbzZmZTJSR0hURVBvS2JDKzlBU01PeTVjUlVmL2pVaHpvV0JId1FHbE1RR05wbVZwZ1VhMDRROXFhQ3VRNnpMcW4zYjFwb2hRYUgzcU5ZYzRNb3pjOW93TFhNSUY1R3VldXE0KzdLR0xYbVR0Wlh5Q1BOZDNkR01lRFlJQzhvVG4rVVNtZFNtUGxPYzVsbDJGRmxiUmR6bEtmSWtSWmdBNUJMYUROamZxNnQzalBHQ09IaGhiMm1jNVJnOGJRVTNnMVJqSjArODhzUExlQzBYK210VXVHNDhwek5KamM4VDZlQ2FpaGh1a1dRTm5rYUVVOUd3QlNGQkFka0JnTkdvWGp5eTV3Uk1EZm9sN3BDL3NIWkc5ZEF2V0o5NHFpcGw2d25lZFJqRXJqc0k4SzVXTUhlaEw3cm9vcTIrRCsxcnBWU1ZDdjhGRlRwbXJzS2ttNUJCTDlpOFpuQmJqVjJCcmJwNHpYOGpJV1pXRWMzaHNqekdHVG80cVV0bXNLWUMwY0s4OHJrTTlScTRqeEpZRUgzcDlKM1BmT2h5NWdlNTNPRVV5TlJIMkJoVTRSdkxLR2hsNmRFOUlIRnI0Znovc1I4am9YWTJueS9UeFRJSHZYY3Y2YTdQMTkySmdqMWUwZ002aEJnblR1RXVWOFRUbCt5aTVoL3RSQXFLQ25qb05YVUdocWJhYkwyaUNuc3FheGdmZWY2OTFuMFFDV2dDNHF6SDNueTl1LzJBYSsrUmdYb3Z5VFRtamFNZjJNZTBaQmpUUDJuY0FieW5zZGU4dkxBbis5UkxtaktFNmplOU9sOXhVZnEyYUlVRm9TQytrYW8xbHFkU2tnUHlqMVhROTlBUEpaSmEvaHZvdjhQS2FGdkVLbUZWM0c3VmdpR0J0VHcrNWNnaEV4L1IzMGhnMlFVdEFOQWg5Y2hwNzZPM3JPNDU2dGpUM05TWkJyU2ErdTRFNE5GWDdlZXdXTkFIcUZnNUtPRTNsLzBNaTlodEJqblRNeG12STk4aC9Wd3hJL2w2N0VkZXNFTCtRMzM0bjdsaklVa05QZnNoK1J4OUtvU3h2UkljeEFkOUN6eDJNL3ozM2VhNFovNWMvcURLWFA2RnhWQVVzeHdxL0QrNlB3TElIQVVYaS84L3cwcGZNUHJ6NW9sU1pINkJIODNzQWRHVHVNckJmT0V5NlJIZmJwQkI4ZHRXZklNZ3VCUy9JQjhpOGR3ejBBOXlyNmZPTFhNaDRkUTZKRnNjOHFyL2ljSFlVOW9PczFoUm5MVjRHWGtVKzE2SUxzWFk0eEdjelJ6a0JEblNmZEorcDdZQTJUZWM3a2VkclFTSGVCMGtEUG54SEVLYTZQTG5qL2h6Z3dwV3NrK0QreS9CVmxVenJUS2JBQzZiUHk1Y0UyNjVjRi9ucFJlbHZsUzBQc1JGdUtybnVTdFNydHFmTnluK01ZejAyMVg1Vjl2NDJmSHlDbll5WnRiZkZ6bEhTTFlMWUdzTEM5UG51QTBrMmw0L3NXbFF0SkQycXlUdExkL2R4UlA0L0F5aHAyRm1lTk9XaGN3cklCTEVOZHRiOEJKSDdPdjd2NGVkVnBlaUEvNXptTCtxTFd4Zm1sUTg0MmZzNml1b0dPSWZKekZyYlp5ODlEUDJ2Nk9Ya2EweGtYTW92UFU1UTllRmEycFNhRzlGL3ZhSy9KMUVwTG8weFllNVlsOHVrb3UwYVpRSjhkWWx0SWRlcjYrWDdweTZRMkRUejBxb3NXQk5tVnpzclVtMW1VbjdHZXVNWWFoYzh5UmVWS3M2YThscXdtRzZYOTJYRXUwdmdxZTBCbDNtbGpBTFNlcitSdzBhZjdpdHlnTmt5MU04THJLR1NaSmdjdFBZZGR3YnVHWGJ0d2k0QnkwQlBpMlNzY2NmcjZPTjJXenJaU1JvRGQ1d3N6R0JEc2UwViszNEtsRmRhVUNFTUt3YXowemg3OXE1WC9uNzAzYVpJc3U4N0VQaDhpd2lOeUtoU3FNQkFrQ2lSSWd1d0IzUklwVXFZV243b3BNOG0wYUtOa01tdVpkZmNtZjBLdWNwbm15MXJJY3F0ZExMclgzR2lqRlNVOTlxQldrOTBjSkpJZ1FBeUZvVkJWeU1yTXlzd0lEeCsxT09lNzk3dm4zZmZjSXpOQk14RTRabUVlN3UrOSsrNTQ1dUY5bUZIM0RvQWJicnhlQVhna1VhU0UzNFpGQ3l0OEdubURSU0diaC9RSVZ2T1dobU0xV2thaWNnWlBBd05iOUxmODgxZVFtZHl2QW5pNk9KOS9nT0R4OHlvUW9yQTNBRFl2TzcrU0luenBkWDVIY0VFSjJaQUxtS1BBb1RDRjFRYitMcklRQUpneCtTa3lNL2haMkpwKzVPODZnekcvZ0FrZnk5cmU2ZGxQcDR2eitTNGFoMThUY0MzZjhmNXpmQzlnKy9LeDkvc2pES3l4cEdIZndBeS9id0w0T29DTDY2YnUvaWtBUUk2UVEvWXE3UE5BVkJqREJNRjloZTA3YVZlQlRtcVhROU1IRVVkRlp1MWxRSEhXcUMyakVBb1ltQXNhMk9ocEhkT1RBaVdUK1VyS3QwTWd6T2NPWmRwT05RUVVVREgra2xrYVNoWHkxMUw3OTYvakhaQjZrd1AzbkNJYkRQckduN3hVbXh3RlY2UTM4VDgxR05KN3VLWjRwMktIUnFWT3VpaUM5c1hYY3lGR2pnU3QxYTJxR1NPNFB6UmQ4MHZ2MldCb28wQkZiMzd5VFV2a001MzJZV3Nla2hvdEEyVGowSm1NYWRya2RNb3o1UFN0U1dsRUlWWE9wQXBSQmEwN0FPL3RBeFd5b3JER3lCdU41dG1GMzRDdTRwNENlVktDaEg3eVhrMEpsaUo4K2tBTVp6VWpPNXpoVCs5eUJmMWFHSE9FZHlvenJzWlo3V01WS1BBRUExOFV0Skt5TDN4R1ErNHVYT2YvRk9TWjFvaS9VOUJQR1IzYW5IS1Y4NnlSSk1jd09ublo1RFJhNUhNalQweEJlTnFhTit0R3pqMkZOeXFqRkFjejNYRnhwZ1cvTDFxTHF0RklRcDBuM2Z0c2Y0ZU1ZeVl3dyt4Umt6MmFWejZPNXpML2F0eFFvem1RNndFREhnblRXc1R4cUwxM253Wm1OYUtSajFYbHdFYmE1UG1nTTBodnlpYUh0Ty85KzVIOHI5ZjBqTE5mY2M1VWFGekNGZENWdmEzM2owTGJlNkhHQSsyNWwybXRyNUFqbWxSNVUydDdBMHRQeW4zR2JEbEFWbGJXM3NVOXZOZFEvUW93Z2ltNytpS25qckNIN3lDMHdTTSs4SlRxNUxPS2ZHYWJqYnNKYjFCeHBnb0RPUU9USmpzNHBFd0ozbjY4dncrdkFxVnhCN0J6Y0xWdnJFNFhyeW9HSGVLS1RXc1JSbEdKR2ZmNnF5cU1JMDJKMlJvR2VZWmdtQ1IrS3B4cmhBZEk2eUY3dXphbmZHZkhLQ0I4OEt1QUdpWlZLVWFqVktMM1RZNEVHVktPMHBoUGlQVWFheklPRFFaSzR4S0lrZzJPZTVYZWN0OU9tMXdMR3NocGhCV25hNHBjWm5xb0thK0ppL3JnQ2w2Q1FINkxlemZXMGdQSytZejRQU3FCcVc4aUhvNDZIYzM2b2diRU5MY2lVNDViaVdBTWZLZXVCZGQvSHowdm9yS2N6c1k2b1VyYlY3NXVqRGlPdEpOMG5oa0F1SStvNjZGVEpJMHQzRjluTU9NeWdYMW1acG5VenpZNzNtaGFWYlpET1dTTmZHN0pFNURYaklwc1JoUFNLZW1ndFAvSWZBb2pPdFg0RHFDUXM2K2N2NG44SC8vWGlHclZWWEFmNk43cXc5bTljQjBadU0wUnFPUkpTTU9UWVZ6NmxjRGIxOVRQM0p2Y3U5VSsrOXJScVAzamxLR0h5dEZNY0RnOUg4bzRwbGxkK2lLQWl6UHE5MFNhd0hNMWFYSmFjbldJQVB6TUNXMmFBdGkxOSs3WDVsSHArUWdXRlZjMVBsZmtjOUx6Mk9heGp6SFNjNVhwaU05ZUZ5UWRrZEJieWtBSmI4djZSUG1jZTNTRm5JRmxCSlBQeVgvUklLd0d5eG8rNFBVT3ZBWjZUdGxENlF1QlowbHBYYUd6a1RiWVQ1WGZrenhaa2Mrajh3cDFGTDF5c1JqbUJ1VnpsR1VjaUZjNC8xRW5NSmEveUhNTU9ieGNSbjRiSmI0SHNud081RFhrbk9qZk5qeWY1ck10VThRclRpN09jY0FuV2phQTd5akt1UWw5WnQ5MlFBcnNHY0V6dXNSM3NMOGlCMUF2T2xnV1J1Z2paQTdZUnRSTjZEakorN0pQTkxnbVF5eEtQYUh5blFVOWFMUGpHdUQwbzgybHlyVFdzNTVwUmllclBNaHpQZlU1MmlMTDUzdHhrTXdGeDhuc3RodnZ1NTZMVlpzemlrVGdlTWJTcHdpNko0c3pOd1JqV1BSbWI3U0xSeStlTE03bk45M29xOHpHWStTb3k4Zit5Y2lYMU5IRitmeDBjVDcvbExkenREaWZIM3RFNURFalIvMnpKa0RkcXZ5MkY3emZKQlprNW40UndDOTc3VnFGWXdCdkxNN25YMGJYK0V2NEo3Q28zbCtCTVpjVWRsWEI4QVFXSmZ3dkFmd2VyUFl0UDc4QjRIOEI4RC9QN2o3NDNkbmRCNDluZHgrODhMYStBcXRUL0Nac0RoWXc0K2IvQUl1a0hnUFlTbTFaSGFOR3hWNWJhZjJLeHZWVGVEM0QyZDBIYTA5MXpDaU5tM0xmRjYvWjdsZGhqZ1NBR1VZZit4K1ZseWNBZmgxbTBMK0UxMHIyK3hOeTZobGJzZGM5Y25ZTDROWjE1cy8zN3lGS2hiZGdCdW8za2M4RjAvcWQrTjl6T0RKZW5NOG5BLzJnVVBvV2dCL0FJc2gvTFBYSy9vWURCYmhqTXN2STNrbjdnR2UrdUZjVm5DNVEzaFJGUHBuS2svYmUvV014ZnAzbzg5cUdnaFBubEg2azc3NURvSEVQWkRLVWU0ellmZnQ3RGR1L0sxU0UyNHB3Y20yR3ZjMVJpOWNCblJzeXFQUnM1cHBWNTA2WWlCSFFuK3BOR0pSWFdvZEQ0TWZadmpDU1JVcFV2emFsVWtRVVNIcEdwcFcxdVlSRjZUMEx2NS9DY1BtWi8zOHNBanJYcFFQY3A4aHJ1Qy9sbUk1dEREdGJwMjZZMGZYdDdPdkdJbVFXS0ZNeXZ6UmU5WG5WU0tmSW5BSEM0S09jZ3gxeVRTLzJXYjBJeVNmcG1hUDNNZStmQWlnOEtVV1pzc0pBT2xhQzd3RkcrTy9OUHVCQ2h5ckVPTTZ4djVOcnpUR3JBSzFqMzhLRmNUbTNJL21NVU93aEdWZFMvT3Q2dDluNHEvZXFBRUtsNkxHTW0ybngxSU96bU52S2ZQYmhEODdya0VHc2lJSVFRWWp2MzhuL1ZMNm1OSDh3SGt3ZE8xVHh3T2pPSlR5Q3ZNblpNZUphNk41TVFpQktucGZycXdZUVhSUHRLNUQzeGxXVHMwblF3VUd6TlVTWXRmZnUzMnpMOUp3YjJGclI4WVQ3SnhvTHRBWWgyeDYzWllSVEZHclpGNllUcGNKTEJjc2xqS2JUV0tsbm5YUE8xRzlKNEpiMlZUSFBlMDhBVk05Ym04c3liSDI4TkpEU2taVGpXRFlXVGF2cm1RejRUdiszZ3Y4aDQ5d2lsN2ZoM0VYNlhjelhQbHJkNW5xQVRNZWNESTk3YUR5ZFpUanZVMjluRWZyVWlWYjM1N2ozb3pGYzRRdzU1ZWp4UGp6M2luRFU5a2NGN2ExdEp6eEh6UmhLZ3dScHBxN2hzZkNkVVc1bE5FNXNjd1dVZGVUOWQ5M0hFM2dVQlVyRlRnZWFISEdnTmEwUE5TQWszQnZvZVZTazhWMXJ4eTNjTDVvUyttV2hvd2dWSG1yZm51SCtqVGhBYVZXY2k1R01zUy9GT3AxRzlvNk50T3pRL2UyNFJmRVd6eHNOWndWT0VBWG1FRDFYSldETllFNThWQ2lNa2ZrZ3dQWXlVNitTbnVsZUlKOURaMFZtQ0puSlBab2xScFZyK3M0WVpjWStGRWJoMWlLK1R0a25IMmZFTlp5YmtjK0ZSdXlSRGlndFQ3S0kwMmJ5a3FwUVY0TUlqWlBMcG93aTUzd2tBd0t2QmFNTWxjaUtINERTQUJtVi9pcmJidUhwREpGeExZM0JWWnphV2lRMUkybkp0OUFaaTJ2VjV3UkZYcDE5MmFBYjBSMHo3WXo5bm1OWU5zQmJ5SHRuNHZmUDJudjNiN1E1YmFQaWFzbzlNVnFiRGdIa3FaUVdhVzNlRHZBOGhqVzVoT21EeURPdllielNSVkRTVCtFbFpuek5TVHY0M0FueXZxT3hITDVHMUtNbDJoaGwrQ0g1bHZvTDMvc2FJVmpsQXdSSEhpUFArVlkrNlloM0JKL2orUDQybDRNZ2poa3kvbkpjcnpXelh3V0crQmNxK1EraDU1MDIybXdVVmg2V2Mzbms5SHppODY5cjJhSG4vZ3pUbXVxWlVyeEpmdmNvR0ZBNlk2RE9UT2k1cHFEZUMwTFBWYyt3ajU3VHVZYzQ2blhRYy82bGQ0ZXgwZ0FYOTVyaUJ2YUhlQ0RTUzc1TDZYK04zbXVrNzE3ZWlMenpOZWc1OFdXMHM3Q3Y4WDNLMCtrNFVnU3k0SXpxdXFIL25PcDlVVDZ2NldDamZNN3NGQVIxS3VubytLU3Yycys0L256L2NXc1ptL1Q4eEwyV3pnYThKckQ4SHAyeVIrRnZqVEl3c3NhSDB4SGo0RnJYZ21OMUxKeVRZdCtGL1V6ajUwaWVBWEprZGxwejVMM2VnUXJ1VjBlam9haGY2clkxbTlvT21hbnEyU0VBQUNBQVNVUkJWUDlsR3pWSFBPNmRNLytqWGlYUmMxZzJFT3JhVCtUNUl4Z05pLzBpUDBINW5qU0x1SGFRbmxkK3BqNkc2MDU5NWpJOG0yUmR6b1hzMjB2azdDc1RmVlo0VmNJT2xRd0JmWGhpQ2xQT0xyeHVibXFJZFdlUkJUYkFERzZyeGZtY3FRcFgzcm1OZC80ck1HUFhDMy91MjdDRitZSi8va2Zra09aaldGVGs1ZUo4L3Y3czdvT3J4Zm44MDk3K1UyU2tXU1hpYmlTYmFuM1ZBRHVVYWVhK0R6TUEveXpNMlB2TTIvK3FqK3VYa0MzL05YaUNYRDlZMDZOTkFYd1pGZ245SnpER2NnbmdQZjl0N2UyK0QrQXF6UEVZRmwzOGZaaUI4QmhtT09WQk9BTHdPd0QrME52Nzh1Sjgva01ZQXp1RzE1RmRuTS8vWUdBZXFrRGpLSTJOZTlKeWsxbjdsUGZ4QlRJVEhnbi9HbWFjL0xMODlwbnI5TTNoeHV6dWcrL0I5dGNuM3M5ZjltdWZoYTNYVTFqNjZ0dXd1VHBGM3BPUGE0MzJSUG1PWWZPdmUzdlFPRjVKSlQxRmlLWmVuTTgvNCszK0tXd05TV3lwTkYzQkROeGN1LzhXeGd4LzRKSGZGOGhJWXdRei9KN0I1dmNIQUo3L05QWHo5Y0VOcVJmSXlCMFlVRjVWZ0VLZzdnRWxXRk1ZSGxpMzV0M01jOExhZjFxcmpjQUlrS3B4Um9URTE3cmVKQXg5QkVNRWtkaVhUWHZ2L2lWNmxGLzcrbGxydDY5L29xQ2dBTkJoakJxUGNwUjdPMTduclhsajBXQXc4bmEyK2p6RVE2NXZIZnkrM3RSUGZkZXVDM3VFUjJYbytveE5WQjVHWmQwSUp1aXRlcTZwb1pTTUhOT1VKQ2V3aXZKaUU5cmhmcWVCaUo5czQ1RGFTUytibHBQN2Nzeit0Ym11eGtYUE0xZCsvYUJha0cyT0hxTkJTOGV5UUZhbWtYR2tFRDZDTWFOWGxmZHdYVFhpamV0NDFWb2RVY1VIdXpiWFZlRnpHdm00UnZiNEhGY1VQU210WHVpTEtobXJBcXMvVDZaNjJWajlzQmpSeTZnTENrYmtiWkpBMW1hamJJcU9sRFBLc2RTaUl0TXpyWGxvcXVjcDN3L1V2WHhIQWJmd2ZsVm1LTytwM3J2a1RXdEtpUGp1dm5OTXhXME5xSGlJN1hNdnFDY3o1MkNFY2crUzlrU0REd1drYWxyaHhqeFJ4M0lmVUVhalhBR3BWcFFxaTNWK1ZSaFBmZkIzMUtMMU9COUpZVUQ2SUhoT2phVnFnQmpCRkxlYnhwdzQ0am1rQURxVlo1VnVKU1czMENRMUprdzRacFJSdXpSRVJzV0NDdnJFbDhRUkZEYlZRRWRlZ0Fad1ZSVHArakNGSlZxTHdOYTA2eHBaUnlHZGtVeGNDK0lIR2lHdlJNRnc0ZTF6dlZPMHJMOW5MZGY2REJ5VDFpTEordmhyem1kOGpsbElVbnBSZitjVmNsclFGYklNdXBaUGpvbnRUMkR6cXJTSWN6bmszSmQ0d0hBbXVIWTc1UHBOSjNCankwQjdOYUNqVmQrWlA0RXJZbXB0eXpyU0dVR3ZrYjVRMmFDZThScVZtNHdseUh1MEdvWGFpSE9BS0EvVXN6emljNkNIbml0UDFGekRrU3RBVkpnUlNGZHJrS0lHSzdpMENtMTJKb2xPalVyRFVnU2g0S2NxWDFvWmcvSk9mWjc2cXN3alB1endsVFVlVlJTalJjMWoyUStEMEdZSGhVaTNJV1BVbW9Qc2E4S2JiVGFTRVpkcDFFL2lUU3ByUWo1bTNGb0VpRG94cVlQdXVNMVJKdnBzTW5US3VxaWpEWTBscXZST01sc3JrYkRDTHhKVUljNUlKRlc0SHFOQ3ovMGVLcWlqWWwrVmp6eW51a1pxQ0UveWk0NVgrbGFWcFFKL3ozbmwvTVF6SHBXekdtMnB1T2NJTnNkVVZFY2pnWTR0dFIva09NWFJxaENuZzlvTlpFTys4aGhNODgvNWpzNHViSS9PVWh3clpYM05LTUZheFpUUjJXZEdHdXU0T0QrbnlBWng3dWxVSGlYTUt4MjkwN3l6c1RaSFdJSXl2NnpCUnRvbVhiNlFaMVVuUzRmYWhkRHo1ODZYYXhaQ3BTbDBqdG1oUXM4ZEIzQmUrdWg1alo3U2dMaHRIcjViV3hPZU94cnV5ZWZHZXNxYUJsdHhlK0lQMGFOM1FJbDNhanFOQ1FUM0VMKzloTHhPdzBXZkRvTlpDYVp4ZmtOZnVONTZqVTRySFg1WlpDVWduRWZrUFVrY3FQUTg2WnZDUG92MFhOdm82QWNpS04vMktpRDROa2I2S2F5USthK0RuSjZRUzZuRU5zbjdKSHJlNWdoQUlFZk85L1VsMGc4ME9iSTZ5dWZjNzV6ekhXeDlDejdqT3ZSYzNsMTlMancvUmxjK1R6ZzE4QWFrNDVSckdBMU8yZ3pVNlRscSs5emZQV3B6UkNmZm9XZTBseStweU9ma1lTSDlTWHlTaksyV0RwMWpLM0I3cEpIK2VZd3VYZEYyYW1lL2huY2lmMHgranJ4cDdJK2V3dzZFZFk0WkhQdDRFOElFdG5aOGo4b0RLMVR3b015L3lxNEZ5TjdSZmtRY3BmUWl5dWRqMWIzcXZGTFhXbmtmWlJpVnEwOVFscGtoaldIMHIrcEFTRDluS0xQempXQzBsQTZFZkk3WGo3eS9OVm1SdjNjQ29tVC9VcVpkeUxQa0JVWXdoM0xLaXNRaEN6MjNiVmQzcmxIR0hkMDdhVTFieVZxcUVZbE02OHg2dlRxeDlKaWtWVDE2Z1A0Y2dGOURyckZMK0MzL1hBUDRNMlJQZFhwbnJXRVJycnZGK2Z4N3NBVzdCVFBvZlFoVHhyNjlPSjkvWERIR3NiWkZuNkZ2dHppZm4zbDdkNUNOa0Y4QThJOWhSc3cza0NOTjk4SC9QcnY3NExuKzRFYS96OEVNM3l1WUlmZmJ5QWVLS2JGL2dCd3hwekNGYllqM1laSEZqSnJWZ3p1QkdUNS8yY2RCSWtnbDFHTUFYMStjengraFh5bFpCVGVxVG1EenZ4MHdlSkw1cDFjOUJlQUN3ZnA4M0FId3BmRDhtNGYyeVdFTmo4alZlcnFMOC9tYjN2NFJiRTdmZ00zL0cvN2NFMWpxNk9zcUdTNzgyYkczdndHd1haelBTUUNHNW9aQUJMSHhxT3hmQmZBUFlHbWF2eTk5dWduYkZ4T1k4ZnF4UDN1TXNqN3lueU9uaUg0Q0U0aCtGbWIwL2o2QUp6OU4vZnp5NEVpWkhydEU3Q01xQWRwS3FvczJleTdTc1NRS0p5UWc5Q0Q2UEd5dFAvWjdVbzFQZUIxREp6RHFZZFZyYkxrdTFKUkdOYWd3bmFxRUpoSHVpM0xyWXp6M3BUNGFWUWhaMGFjZWhkVVFzMWdvdkx3ZlRDZVNGRDk5L1lyTStNQjdCcjFkSzR6Qnl3aVkrNEFDeFFqOTBhb2pvSnFHcXFwa2xtYzJRTUZJSkVhWSszVm9QRDUzOU1EbmZXdGtCWEZTbklvaXROWU9qYmZYZFhwUVJrOE5DeGZlN3RRVkpKdXdsbFNZSE9yTnJJYkZHV1NlbXV4eHl6a2ovd1JrUVlRZTBLb3dpY2JLSFVybXJqUHZJbmlTbnF0QlpOcWFvd2FGM0RIS2RGZmM1elRnS0JPdmFkczY0SDJuWW9kS0pnbzJRS2xjVW9NYlVIcVNrbStoTUVMQmlHZHR5TmdTaFQ5VkFrZGhGeEFoVU9kU250RzlVOE52VmNHN1I0SGFkMFo2aFY3QnZiVm5kUTU1RDUwcW1DcGRhWmFtdWVTNFYzcFBtK3ZIVVFtdXl0WVZiRTdJcDZhOWdxeWtVOEdPU2tPdEJjaDJrckRyQ2hFMXpPcllLTGd4MVRUM0taWG9QQitreGNSLzI5YWl2Rkk2THRKeDZSK05pZlFRaHN5RjduR2RBNjZWMXZvOVJhYmh2RTRoa3BHME5CeXpIUUwzSHBVb1BQZFVzckIvRWRRWlpOYWFnZlFZYnZCMm9URXA5bVFmQVYwbjJoRXNPNEpHRmZXOUZ4QkRUZy90WXh0VnA0Ykcwb1ZUWnRnRjNOTTV2M3dtdExVUXhUZVZDdEVJcFFwTHJZMWVqU3FYK2VmMUtEY29Qd2RrSThMT2NXVWYzYXJWdnR5eGZTcDRaVC9SbVdLTHJFQ3Z6YlBPbVRwcmpaRDNVY0pIVGVra01FWldLbWhhelNvK3JNd0RjWXZTaDIzRWYyMmxwQWpYdTgxUmtnZEhDOG03Q29OU2s2T2F5T01kd1kyVzhwdzZmZXdGeGVFMS9sK1VkMEErNDhYWkZuNnZNTnp5dW95bkYwaUw1UGt4eW5WTmRlYTlMNUducGNJbi9rN0h2aW9QTExRQXlHZVpOSmw5VTNxdWRFd05wQm9sclBTYzljaUg2SGt5aW5JUE43bmNnRjRuSkR6UVE4LzVrL0pSTlZyQ3RzbXphYlNoR2t2aU9abklNeldaSjJWdkdUaGZ5ZWlPekUvVmNERjFERW9MaWoydk1wOG83b0hTNkZWVERrZkRNdStobm9sN2tQT2drWjhiTnk1d3JmVk1wTWlodG5SdVZzY3A3aG0rZzQ0c3Q1RmxhWTc5QnV6Y3p3QTg5dmVTdHlidDNRQzlXWnk0WGh5Ym5tUHlLbFF3Nzd4TmpwbHpYMXNIQUNuQ1ZoWG1MRXNSUWVlVkJvRXBIRWUzcFlPRDBuUDJTYzhxQU54bzc5MS9MbU5XM1VZRTZqdXVCdWk1S3FzTDhQTzRnODI1NHFua1dGMTVKaHJxeVJNd0Nwd1J3RWx1MG5hVUh3aThUYTF2M0V0OWRFYU5HdWtjOWR3N1JNL1ZlV0lzNTB2UDNiaEdTeHdLZWk1dEFTV2RxejBEWkhxZVpGdzUyOVhVc2JKT3hPODZqMnFnb2tHak4zMDVjV1J6ZlNkdHBlZnBXVGs3RTVmUFkyUjZkQUk4OUYxbzc5MC9ic3JJT1YwLzlrY2RoQUNqb1ZPVURuODh5MUZHRzVMUDEzS2VGYmR3WFVqZmFQUlgvWXIySmRKdDdyTys5YUg4VG51THl1ZkptU3U4UjNVSC9KMW5tcnAveWhPakp0Y2o3NE5SK05RQWtpSDV2SStlMXd5SjIvQ2RQRndzcTZFeWZaOU9pZGY2OUpxOU9BNWRuTVE1VTl5WXh1TjdRbkZlaDU2SGR4ZlBCeDR6blh2aEdmdjZkUVJ4d0lFNFRMSGZJanVvdzRucTdsS1ppeDQ2cSsvY09wM20rZVVjRXcrUnRtb3BDc29jNmIyVjluVk55VHVRTG5JT2lWLzQ3ak5rQXpIMUZOeHo3SWZxa1NtaktXOHk2ZEdGOHd3bitiNHBuUjc0cDQ2ajVBT1UzK1QvcXJ2Y0JCay96c1VFcU5mVGxuczZaWkNtL3BKT0hWZzN1TkZZcXh0S3ZlYU9ZQWJXWDhCd3VvMHBMR0x6ajJIR0xFN0lCN0IwSjR5VzBmdS9DRE9pblFMNHp1Sjh2cDdkZmJDU2ROV2QxR1JxMFBTZlBnTXo5RjdBRExOSDNnOGFFUTgxL3Y1ZU5QNDZ6R0JHbmtzZnc3SDNld1dyV1hzYkZxMzZBWUFmYXJTbTkzVU40SWV3K2YxNTVNMTc2WCtuM205NFcxUXFuU0FydWpUSzRscUtjbC9qd1JyQWJtVGNlSDhmSVc5aUh0Q3RYNXZCNXB0TStLdkFIOE1pWTJzS3BRdFlKT3dTdHJaZlFEYkl2UTJiOTBFRGNJeDZudDE5c0Y2Y3o1bkNQQWttczdzUE5wNHVmRWlaQzdhMU9KOXovbjhWbHFLYXlQTU5sTVJxaWh3Vi94eTIxbkhPdnVSalhVc2JUMkg3NVpQclJuei9GTG9nUkhnTjI3OTNZQXE0WjBBblFpenRkM1FqTUJTWms5Qy9RQllzM29iaHZaVXdNaGZJVENkUUNzUUhRNC9TUWNjM1dJZm1RTVBrMlB1YzZwNlJBUWtLTHZhSkF2OFFRYUtTbnlreDl1SXVybGVQOHFwalRCWWh2R2hqMzN1dWM5OEJ6KzAxL2c2dHo1NTdHSGsxZzZmOURIMUprUm95RjRYd0t3b1VYaHVqRWgzSTc2cndsZjhabmJab2NrM3Q1SWtNVnlUMmpISGZQQis4RHFyOEF2Q2laMitTVnUzZyswLzZ0VVhYS0R3RWRJWWJvOTlybVZHVnFrd2tYYU1CWXRUZXU4K0loNzRvMW4zbmc0SWw1MTBGdXFob1VFWlFoZkZ4bTZOZVdKK1p6SDR4UGhlRU5CcEk5MGROSU5UM1V3RFE4MW56d3QzbmZVN0RWelNhYTV0SkdFU2VseDJ5c0Yzc2FlbXJ6cHQ2RHZONnJjWVd4ellDZXV2RWFCOXFvTFNrNW9paXdoT1FoU2l1dndwS2VzOFMzV2lDUXRuUTVpZ01HbmdwRFBGM3BualVmakJORXBXbmFqUkllTjNiSnA4MmtyYTRMaE1ZL21DdDVlanRUcWRIUnVQcTJHZ2tvRUlSM3RZT3hrUGRRRlphay85aXUrcElvM3RmQlRjZ1J3aWdzYnBRVEN0RklaK1I5RFRJOHgzODVCeFNpS1p3dlpZenhFaU9qbkZKNXVWWTJxU3lXSTNoNUUvSXR3SWxYNkc4N0ZscnppRWNiMUpDb0FRVjB0VURtdzRlM0s5YkVmSnJhZXg0RnFtTXJPTE9OcWQ3M0NBN3EzRHZzUDhjRS9tSG1vS1c0NzFxUFYxZXVPL1k3MTM0bUtLQVRJUE1VbkNOWm96cFFHdk9BZVBXbkJlR2VCOWRrN2pYcVFCTmJmajdVMFNyekRPVk9GUjZYeUU3TXlhblZPUzlVdUM4UnJ6VDIyd3NTMG9mV1Y4Z3lDaGhMZ2Q1VjMvUFhqbEtRZmhNcm1FdFFrWmwvbWxiMWl2Y1lUaEtLNElxRjN1ZjhmWTBDa1poQzV2TFdsUm1WR2dPUWxCMm92SXVWWHBGSGlQT1U4M2hTcThyYlk3SzJqN2VScDJMaUxkRzhwdTJ0M2Z0bSt5VVMrWDBMbHlMVWY4Yyt3N0lhZk1yOUZ3VmhGRW0wR3Y2WEdIRThYY1daenIwcVkrL1RYeEU0QzhnL3l0L29YeEhqSWJUZGEyK0w4eVpLaG9uYlhZV29OeFdxL1d1dWlTbTJxZmlQOVpKVHBHNGJhNTVPMFkybXI2UWQ2MEN6bUd0ZWRhK1MwNW9mcysydlhmL0JZeDJremVtTG9RcG9tZE92L2pPTWJMQlZmZTNscHpSVDQ1ejRzOHplNFNPWllLdWJvMjZPOGk5eWhOenoxUFJEcFNHVFk3dnlzZEdoekxTT3RKNUdqR1h5TUVYZWo2VlZ4ekQwbDArUitiZGVaWWlQVmNlZ3NhbkkyUUhyM1MrMm52M2IvcnZNV3RTa2ltRW5xY1VsM3BqbXgwSVUzcGJueXZsVVRpWGZWbEVFZ3dZU09nSXNrRTJNQlZPNGExRUl2b2FWRk9haHI2bndJQ2UyeUlkNEhva0IwTGY3K3VtVHMvWmo1MzhjWDQzMGtmRnBlckVXNlBuaXYrWWdXZmNtTE93T3I0b2pvejBQT0pFR3A3NEczQ05nQ050dy9kK0xmaUFlM0dIN0F5bjh2bDE2WG5TYWZUZEpQUWNLSjNkZ0Z4SGZvYk0yeFBpbXU4RHRaRW9yU2FRTmlrOTM2STg3MXFubU5jNmVuSlplK0p1ZFpJYURCaEF4ak5xQkZiSE1OMHp2U0E4ZnArOE95U2ZKMWxCMm9wMHM0L25MUHJYbGs1MGJMdVREYzFCblh0cXdETlRjL0FqeEhQRVp3cG5NVWhHRXh5V0RTK05SM2hQMWNQVytoeU56T1RuTmloNXJHMmJIV2NnOTlLNWFnVXI4NkQwUDBFRlB5aU9JSkMzNE5oMS8zSWVsR2NoeE8rOFg4K0c2aElvVy9POFVtOUFHWnU2Qkk0VEtETkxjWTFVcHp4Q3Bwc2IxeHRHWHBCNmowbHJqckExbmRiS2VSN0szSXJyOVY0NkRsMEliV0FnYmx6bktiSWRJVG5SQU1rUk5mWGQzN3RzM0tHRnlHNmtkVWNYNS9PUjFEY2xBN2lDR2F1WWxwYkt5bHMrb1YrSFJTMHF2Q2YvbjhLTVhreHBRZ2FURzVOTUQxT24zZkw3NzhDaUpuWFJoenhmTnJPN0R6WnV1UHdXekpENFEvLy9mWmdSN1FJV1lmd0lGcUhIK3JHZmRKdkQ5MkJScFFYNC9KejRHTDRHTTFwKzROOC9CK0EzWU1iZmR5cHRZbmIzd2M0TndvencvSnAvZnVodGZRM0FYd0g0anZmOU9mSW1aOHFjNTM0L1BRSVBGcTYxSDBQWGc3RlVQWGEyeUhQTk5tYmVwLzl3M1g0RStCNXNmNlY5NmZQOTkyQ0cxVitFR1p1NXNYOEEyMStuQUJyc1NUbnRjNzhMdjIxbmR4K3MvSE1qMGJXcjY2Ulo5djYrQTV1amJ3TDRmMkQ3YlFLTGt2K0hBUDRXekhIZ053SDhVd0QvSXl5Nk44SVJiRTgrOWMvM0FUeitxZkgzdFFKckxUeUJuYUdmUVloQ2MxREZ4Z0tsZDQ0cUNxZ0l2NEt0MjhJL1QyQ0VnVjZGRkZTMG50MlF3YlFESkxvOVRFanFXNDJ4SUpFZGVKWkVhU3gvblhjUE1DMkZoNXFQZXlMUFVxRTdRL1lDM2d0N3h0SlI3alJTRTB2N2M4aTc5c0VoN1J5aTZIdVplMXhJWGlCN1pONnFDYk5OVGdzV2xZUEt5T3U4ZFdqcWtLS3B6ZWxMRXRQWDVGbzJqUGJZd2owTVc2djlSYVp2Q2x2N1NXdTFWMDUwVHRuM2lpSzBEM2h1Qi91T3pIZ3Q0V2ZBbWIzTHBsdWI0NFlvMnlQd2ZDUlB3VDd3Y3hocnBQR1pKUGczWmYwNVZhanVxMmVsdGEraVVvVzhVdnE5elFZbkhRc1ZOVkV4VTF2L0RXeE5VL1FhMTdkbi9Lekx5SDZ3elJGS1FZUjQ1eXF1aGZTOU9IZDZ4c005SGFFdk5EVkd4c21xVE9QL0ZBWlVLVXZsUzUrU0tnbTdQVGlONnp1RTV6VU5rZ3BJUUQ2NzNFT3FvQnkzVnIvb3BEVkRGSldpWXdTdlZTcnRLRmk3c01HNk0xUzBxaExvb3JFYWd4dzcxNUxST3F3N3JKN0ZxZGF4djV0NGdXZUdCdVFSekdCT1plUXBqQzZ3ZmlBVnFSUjAyQ2M2UC9JNU5WU2Z5SHNwVXdDbFVwMXJTbVZyU3JzbjEyaGc1N3RKdnpuL0ZEWkh5TXBuS3JEVUtNZTZQd3ZrRkl4Szd5blRFRC9VRkpNcTBJNjh2enpIS2xoVFJ1QmNxMUtiKzA4VnZWUjAwOWpaRjYxQzRaeUM4SkZlazc1djBjVlhQRVBLUzJ4Uk54U3J3VmtGL0RYTUNNUFUrVnpIV2V1cDZBZjRpREVzNm5uYVdzMU9Pa1ZRMFRhRDdkZGl6L3E3bEs1ZE5BL2ZmVjdwTTBFRjdqN1F2dk1jdkVCMmxMcUN5UXhGRzA0UDZRQ2hkSHlITEZlcjh4VVE4SDRmUDRoc0RLTGhQZEdSUGx6bmVJTzFOOU01SVkrcmMrbnRhRnJoUXlEVjk5NERQQThKcHpwKzYvRFQwdDhhSkJ4L0lFK210RmI1SDUyN3FGaFAvUnRxdXczUm13akt6dEN1Um5ZcHp1WTZ4TFBZeTg4aDd5SFM4NnFCeE5lU05DQXFlR3NSVENsTmJtV3NVZGxibytmcUZLTTBXZThiSSs4LzRockY1Y1Raa1JlSXFZYUJFdityWVZQN0E5ZzVKdTNyQTlJZ29KUXR0ZjkwbnRKK3cvbGkxdVhVUFRFSWJUYUc3Y0kraGY5ZVM5Mjg4OStYemNOM1Y0N3ZSckxYeHZJOHg1VFNPemE1SnYzWW4xT0hxaG4zb1grZXdHdVQwd0NESE1YQ3VkcDRlMCtRalpuVXBkQ3d3ZjgzY2o4Tk9tb0U0VHNZc1VibmVpRGpTOHFqTkRBcm53UDViZVY3bEk0MWErZWZOcFZ6eE9kcTU0anpsM2lGTnBjZHVJV3MwNXFnNUs4SXhIa2NIL2NPK1pWVjgvRGRSWVdlczErTE5rZFAwNkZOcnlmanYvT1R0VGFtMHFjK2VrNCtWUEVROTgvQzl4dlhEczYvTWoxMkZVOEs3Um5KWGsvNzNQZFlwMFp2cEFmQ3ovWUJjVzh2SFdvazI1Tzhnd0U2VzVGOXB1RTV5b1NLNXdsam9LZ0RyLzA1aEo3empGSldVQnlnOVhRTGNGekRjelZCcmduTU01em1nZlQxVmVUekNxZ01sb0lpbko2djRsNTJYRDlFejRtTDlocXFmUjlFUGhubzBuYmRMMXliUVVjQ1pDZkxhRUNPZkFMM2J3MW5VTjdXTEFzN2xHMXlMRnpybElGaWozek9rZ3ZxOE1mK1JPUGtEbUpFaWxDUnp6c1pSM3JrODFHNEora2U1UndvbmxPOHA4K3JicVhtcUVnbnZiUnZBcTBvc21RRklIL0lPVmY1RDhoMFVoMm5TTGQzMUhNaDgvYmEvMTRJZkxUeVZtbGZpdnllNUQzaVZUODcyL0I4UERmc3M4cnNLVkNBenpsdVB1TDh5ZG9VK21RL3MybnRxUU9RZlFhVTgxd0xWdUo4YXR1cTUrSmFNd01YNzZjc00wTjJzR0o1VURYMlhzSWQxWG0yS2FNRVdzRjE1THhWZGEyUS9TbnpNMEdtc1p3M2xnT0srMFpsS1kzbUpuOVJvNjg4UXlzLzR5ZklnYnBBbGtmSmQ2VWExMlNpVDJCMWNjZHFDQWFLS0VrU0UwMHJzZ0R3REdhY2VnL0F2NEVaVlRuSkg0V09maDVabVVNazlneVp3U2J6OVJiTStFdnZQM3JDY1REd05qWmlxQWFBc1JyMlpuY2ZMR2QzSDF3aHAyQzlJL2ZTQ0V3dnJFY3d3K3NqbU9IMXV3RCtOWURmUTY1QmE0TStuOS8yUHQ3MGRqNUJWbmEvZ0Jra24vbFkvZ0JsRkVVQk5EZ0MrRDhCL0w3UDR4UFlocjdwYy9taGoyR0NITDFNWmRLSGZzKzFESldIZ00vdHJjWDUvR1J4UGlkVHlqbmNodmR0NEttSllYUDM5Q1ZmdS9aMlBvSVROdS9IR1N3S21nZnZOcklCL2dld2RZTmZmK2NsMzkyQkExSS9LMHdBZk1uN3RvUTVCRHlCN1lXbk1PUDQySzh6M2ZkdFdOVDQ3NFMybnZqZkMzL3VJMWprNzJ0ZDQ3OHBzRStoMGdjQm1YNEFNN0p2NE5HTVFTbEJBYThXclV0bW4vY3hiY3dWYkU5ejdXL0JVcUxQY0EwWUd0OGh5cXJyUE50a0l4US9sZm10Q2gydFI5and2cWFzaWFTRVd4a0xaanJvZUhXMlhRLzFReUFxT1dxS054cDlqbFI0ck53M1pCeFA3Yi9zdnJzTzlQWFR4N2RBRnBZNmdwaXZDM0VtNlQwalJia2U2d29EbWQ0OTFEZG5NTGZvcmhVTkhpbENVNVJHM0JOVUhxaEJvV0NzaEFFNkJCTGozK1lJT3lyUjZIVEJ2WmVNQjhoZStBVzB1UzVtbjNMdnl2LzZhc1gwOVZHVjk4bDVxNUZVVUNnOVI0R3N6SzBKN1ZHQTBQT21xVUhKbkViaFJvMUsvSi85cTkwUEFHak1HRUdCaVV3bW81LzZnTHdlNzFtS0FvYkd2YjNDZXB2VGZsYjNQUEljNkR6cXZBUGxQUE83TXVHUU5oTDA0S1N0ZktwUXEvMmR3QTJ4QTBvYktoWVZvaUZBaFg3RjArcTV2WUh4cGdzZzFZRW16cXRsRTRqNGprYXEydGttenFEZ1JMcklXcVRhWitLZ1UyVEQ2QUsybjQ5aEF1RUZyRzZkUmpNblF6Rkt4VCtGT2lwcEZXZnQ0TXBaV01UZ2pUWTdxSnpCemdKbER5cUNGOUkrMTF3TjRGVDQwRkhyV05yakhMK0FLUHhrbXFad2c2b0l3WXdXNWx3b2pxVmpaekxBaERrbi9tUy9JZmVyZ29ST2JUdGsva09ORGZ5a2NsdU4yY1F6cDZJc1d2czhrOFlrWlVtYkRlK00ycVY4bVBadzVBRzR2MnVLSWVsZjBWZWZ3Mlc0bi91QkNoMEsyRFdhUlhtVHltZzZTSEF0cVB3cmxKU1I5a1krcFFKNmJncVF0azVoTkNlQnJLMEs3Wk00bGpaSG5xdmlpZEhueEIxY2M4NVpVaHJVNWliZ0kxVmthN1NDR2xtMHo2b2sxWDJrQmpUdGY4U3RRN0FOZmFBeU9CbUc1ZHh6dm8vYXNwNTFmUGZRR203UVRUczVDRTMyc0k5R25LaW80eWYveGozN2xGQlQ4aUQwTFNxcWVWL2YrQkovM2pNVzdobk5CREhrVk1IM2NVMUhLTFA1a0pmYlZ4dVpTa1dOVEZURHNCcVpJZzdqMkhVZCt1WlY2WEtjeDZoZ0pjK25UbnA2Zm1adHJyM2RteldtOGJyMDhwTXEvTFJmeWovRVAvZzdxRFJrWDZwN2lHY2xYS3M1QjJvL3F6SWR5bm1ucytTb3RZZzRHalV1VU5Memo1dUg3MzdpL1NPZW1zRFNGQk1uY0wyUDJseXZOc2trOHM2bHlOTFVBWkZtUFpPMm52djNCVHlyRGtwRDVoV3lrWDNoN1RIN0duR200cExvd01NOVV5aGdtK3lnV292V0p5OVpPT0hvczk3ZkM1Ujh1dUtKSzU5VHlzamNUeDMrRFpsSDRUakhiWGJFT1d1ekkrdEM3dFdzUVN3bG8ybXdlVDNKUUxLR2dQRHZBL1E4T1gwS0g3U055bXdmSDl1ZDlNd3JZU0tmSENlTlJkeEhPMVNjaUs0cHN3K2Vtelk3eWRRY2o4bWY5RHJyaHpFbTJ1RGZPVjkwUk9XY2FhclVRK2c1OGFMaUtNcktFVzhsL0lMc3hLMDhYNVRQcjBQUDFUREgvWldjWEx6dm5HdWw1NmVvT05TMXVaVEdQbm8rbEtLNEFESEs4R3ljd0huMUNsK1ExZ20rendab3BScmRrcndXNklZYXRmUzVpQk9ML1RoQXo1ZkllaGo0T0NieFBGVDZ5VDI0YTBvbnVoU0pQa1RQaVJQOVhIU01yUEYzZEIwY29xeFM0NTk0VFhGMjdSbkNCdDI1VktDajNORWUrWnc2cmRqM3lPdnArVlA1blAza3VsQlc2TldiOUp6eHlQZkY2NHByaVN1bXlFN1ZSZnV5SmtrUDFib1J0SG40N3BQR0lsSEpVL0RNSzg0anJTTi9vRGdqOXB0OUltK3dRejRMMUUrb3ZLSDZLWFhDNEJ3c0c5TTNYeURUUnRVejdsRHEyNU16V0lVR0RkSHpSUFBRdjQrSWMzU1BxRjZKT2hPdURaM1RZMkFFdkg5SnJ1S2FjTDBFMTVDblVWMUFzam1LVE1pL2xEMlpudXhUWkVNcnJlU0ZaZDdybW40R1pnRDhXRjVDbytBbGpLSDZ1cmZ4bHpDbTdnN01tRXVoOXd2SUNwTUZzdGZkcDJBMVVDOWdLVk0vaGhrUzA4WjBJK3h1ZHZmQjBsTkJqd0ZzM1RpNUFEQmRuTTluczdzUFh1aUt6TzQrZUg5eFB2OElGbG42TlpqUmRBVGd0MkdFaGNvcEFQaGRHQ01KdnlkNUNTN081MEQyYm44Ylp0UmpGQVE5cHkvOStSL0NETjQzWVZHK1ZZVGlZenFDUlF0LzJlZm5LOGlLbms5N3Y3OEppNENsSXVPRi8zM3M5eklWTXducjZsRGpKWityR0JlUGZBeHYrdjkzWUxXY1h3QllMTTduNDluZEIxczMwSEkvakdCTStoMjhIRHhDamd5bmNZQWVEUXBrSnI2RmJDeGxEZW9idUFiNDNoN043ajVZeW05OWN6SUViOEwyMUE0NVl2dHRtR0Z4aTJ5by9tOE9hR3NITXliL0VMYkd6My9TYXY3MktLcXJjT2g5ZTlwWXRwYVdwMmd2OXNPSnhIRnJhUjY0WjRhVURtUW1hU3k1QWVDTDdiMzczMGRXRGd5bUFLa0k1eVRFcitJUXNPOTlWUEQyMVF3alVlVDRWSGlJWG94VWFDWkJSdTZwQ2pHSERpSW9JZytCTVhLVXdqN0ZGSm1PNnZocjYvSTY5bUtsdmFFMms4TERHYmtZUWJGcHNyR2FqQWdacjE3aFNOYTMxME5hRkFiNlBYbi8rM3RUcEMzSElzb0l2b05qMk1wN0tYUWRsUEVnakpsS3NHU01FTWFYQ2g3U3JTdS9OODdkQ2dQS3krWWF0WTkwVFA1K3BuUURNbDRnSkk5UitZMEs1aWxDaVFNcWtseUEyU0t2ZDRwQThQWFFkWW9DR045SHh2a1lQaTl5dlFOY1o4NGQ4am1QeXVvNC84bXdMa3BDUmNJYjJRQUFJQUJKUkVGVU5TWjFnQW9lNUFnZ0NrNmRHdGZ5dnlvQk9SWlZjSk1wMzhHWWJCcVVhTWpRZWFJU05FWGlpSENzMFI1SkVLVVFKYzlUY1VHRFRRMnZzRjk5U21LZEJ4VXV1WjlWQU43Sk5UcGlGT3ZpZTZXSTVHck0rWWtDaE9KMFp1a0JnSlBHYTFlM09hWGZWdHFqWVlycnkzVFJhUzc4MlJGeXBBdVE5OEFLK1p4RVlUTVpoTnRjeDFRRmFTcW1aK2dxMHhuOXlRaG95TFZrVUVSV1d0SXhvK0N2a2MvcDJubUhxZnpHNTJNYU83NUxqWXBGZWx3SzI1RUhrWGxrcW4ybWUySk5SRWFJUXR1R0tYWjNLQ1BQZ0N3MHNoMGFZRGgrMWdYZndIZ0J6ZDdFZFdCNk1OWWk3dFFkbFAxd1VJWVRuMHRHZ3czUnZacVR4dHJITWtYWHNZeGo1UnFTYnlubWhPTnJjM2FEWFh2di90V2V2ckR2TkRiVWdCN1lsQmtqRUQvdzNHd0IzUFIzSzU5SlJ3SGlDZTQxeFp2YzIyUDVuNHFOWlIvdkFsSDJPaTlNZWg2TndVbEI1UE1UMXlJWmhpUHRPNVJ1RHN4M1BCZHFPQURjZ0ZFWjQ1QUM4QkRqZmdHY1cyUkZmOEw3UGZRb2pvZHB5VHY4VlZOUDA5dmIzNkRVaXdwUzRvN0IxS3JlcGlveWs5SzY3YWEwaStNZm8weExxczVqZlU2VzNMK01JaVY5MWRUZkN2eGVLQVJsWER6SHhMZWJTaCs1WDhieW1Xby90cmxPTGZGQ1lmeEM1b3UwVHpQSHI1MElOWWNaU3J6SmNXZ0VTSEptOExaNG4vSVYrazZWLzRwNThqVlFHc2JmT2gxVC9pVDhUeHdaKzBJK2dYTTJnZWs2ZEZ4b1N3T3hwakFtL2xPZTVSalpHRldqNTF6RFI4aDZvTFdNcVNoUjR2VHdGTUR0OXQ3OXA5SlA0cCtJRTdqL2RIMllSVVQzSEZDWGgycDRKZUZSOGtnS3drOGNvVXVITDVEcjc3Nkl1Z2NZL3Q3S1hIQ3VsazJYbmpQMThqSHNITk9KWU4xbXd4cmI1eHBkTlEvZmZlWnRNUG96eXVoRDJVSUthS3pFd3JTRzU4S2NjSjBWZjZYOVdGbTNtczZGNXlMaEJ0M2Y4dnRCK2dKUndOZjZxOGJ6VG52azY0UTJibUg4WUhUeVZId1dqVjJkY2t6U05ubjZvWGxWWjZ5VVhqWFE4eFFSN0w4cnJpQU8yVW9iYWlCUkErTWc3SkhQTmRxWnNnUHBGL1VIUlMzbHhsTGNEK213RHFibndsOERLT3FEOHJ1K2gyc2U5eU5wUnFjRVllQnArd3kya1o2cll4TGZ4OThLSjhzK2tEbFhSNTdwSHZtY09GNXB3Vml1SFNLZkp6bDBnSjREZVM3VFdPVzg4bm9LdkJFY3dXc3Fsd0VacDdKUGxPMmpISjlrUlprSDlqZlZtdTVacTZuMFErZEZkUXlxVTZGeFQvdXB1bHZ5SWFsK3JMNk04eFp4WUovdVFNNTJ3cm0raGpOa3VybEZwclZBbGczWHp2ZkhkbFcyVFpsS3ducm9HTW5MRlB5TmpxR3hWTWpxUkVFbytONDJsN0taK1B6b3ZPdSs0bnZYeUhJLys4ZUFTc3AvbktOYWZmWjR0Z0hKakxNSDM2WFU0cktPZE9CaDlITUJ6dXZUNXBYNHVpYnJVSlYrMFZtWk5rL2xkZW13d2ptZitGcXVHaS9oRUhBM1ZObjFBbWE0ZXdvejZyS3VMZHpJUjhQd2lkLzdCc3pJOXl2ZXhpZmU4YjlBbVJMdTM4STg5NzRBTTJEK3B6Q0drY1k3MWhQK0xDeTFMMnZmSHZ2MXQyQ3BjLzhNVmc5MzZnWkgxbnVsc3VnV3pIQzZXcHpQL3hSNThVKzl6VGNoYVMxOC9OK0NHWU4vRXpuRjlYT2dXeE1aZ213WDUzUGVSK1ozQ1dCYk1kQjlaM0UrZndOQ0VCYm44K25zN29PMS96K0NHYjIvQWpQMkFabVEwRHZrek9kNjR1TmxkUFVQWWRIQ1REdk5PclFqQUVkcXpEd1VGdWZ6VVlpZ3ZnTHdOWTk0L2dWWWF1czdBTDduOVhIZldaelBTYXkvQk5zYnQ3eHZMd3MzWUliWEhZQzF0OCsxVVpqQ0hCSnE2WjQvN1gyK2dCK3FQa091NzZVSjZrcWJPNHZ6K1lYUHd5RDR2TitFN2Jjekg4Y3oySnhRY0dIcW9UNzRmZVFvdUc5NDN4L0JuQjUrb295L2hKcWlTcTRsNWRhK2UrWCthanFZd0ZoSHdhSW05QzFoS1FWWHp0eDBVdUZJbTB4N1IzeExwNDFqZU4waGVXOWY3Y2dDUkdrOENIMXpjb2d5Yzk5OUZJN2FIQVVVNzZWbk45TnlqZjIzSzVtM0dySDlzUUFWSEcxWko2NEt1cWVRQlpWT1hiTFEvcUN4N0dWZ3ozNVc0WURNR1kyQVpMTFNYaUtqQUdNV2F1dFZuQU5SM0tzUXNPdHBrMENGK1E2MjlsemZpRVBKeEFEZFNCOHltM3NWbGdPUW1MeUtvTU1hV1hReTR2MG5FUHpjSi95Mzk3cjFwb2Z1OFRHZCtTV2RpNlM0RnFaNEYvWVJtZXFVS25jQXo5Rm95ZjVUaVV3dmVCcHBJNmpDamFBS2xzRTY0dEtHd2lnSUlFbko2dGRYMGo4S0h6djVUQWFKSnRjL1ZhTU4rOGgzUWNaT0FZSEtFZEo0M3E4cG16YmhUTE8vN0pNcVVyZlNOcVFOaFNnTVJXRyttRmZVY2NXa2NvMDROaHA2Z1ZMNFZIeXEzd3NoTzBJTkQzTjlYTEJRSTQ3T085ZGlpaHhsdzJjMUpUTG5qRWJnaFNoRk5NSjNoN0ltclJyaHQ5SkdWRkFyUHRQeURUempPaWNybUtER3VzRmJJTlZEcDRJL25nbE5QMzJCZkpaR01LL3FGY3I1MDNwSHZBNFkvcVNqMmNUeEJNZVR4aHFVZmpjZ1Nsd1lMNmw0aXZVRWg0eGJLeEdrKytxb01YcVYvWTdLY2hwRFZKR2hpaSttVGt1S1czbi90ZmpYZmZlMzJlRmdnVnp6Y09OclNGeTNjMldybmh0R3h5OWc4MGp2NnlMS293MU9LWWZ5UzN1QU5HZlJNLzlVV3FqM1BCMk9LYzlwRkRRVnVrdC9OamxzdEtVWFB2RVdqYldrQ1R5N2EyVEhqY0pCcE0xcFc0R2dXRWNYZDZuQlNlbTVPclM4ck1QaWlIMVhYT1Y5VnJxbStLMVFrcjVPWGxPVWhLb1E0L3Y3eHFoOTY4WEZoQjVaUlBrK05aam9mVkV4emZlbDV3L1l6d1V0OXVlVXAxSEhpUzFLNDYvUzF4UVY0dGNuZmthcHpDTCtLUENNODQ5S3o5VTRvUFJjOFJEUXBlZnNyOUpVTmZSRjQzMGZ2VTdyNVdkaWljeHJzejlvdTg0K1FPWXhWZW1iSE9BUTlrR1FQUWlSQnh2Y3l6MzBuTzN5SEVjSDRsSFlXN1dhcGVvOHFzcldpOEF2a04vZCtIWGVTeDViSTZ2SkQ5L3dmbDN5M2Q0Zk9pYlI2Vi8zMXhTVzBuQXA5N052eEl2VW1XbldEZTYvYmZQdzNjdldhdDBxdjYxem8vdGs2bnN6elV1VGE0aU9rQlhBeE9NZFhORGV1MzhtZmVNOVdsSnEyOTY3L3dURHpxZnIxbW9rRjhyeUFFclAxK2pTc1JQa0NFK2VOVVlKWGpqZDFIU1pmSGRWTGhxQ1pyL3hsN3crSGVsMkhKZlFxL1FiOHJuVDg1K01SZFRGQkJtTTk3OHVYUnIzUUorQldGUDE2alBrUVNLZm8rZCtHcCtWYzZzOGZaVFBnWExmRkpHcmdaNERKWjhjNlliU2MzWFlUMlYvYXVNK0VCS2RETHdDK1gvaUI1VzFPbXQzaUs2c0JoVWFxSVlUUmhFbVI4MmU4NlcvcWZHdkQ2cDlGWndiNVpUWXRyNjNvRmNIMEhOdG8rYndVL0NjWVYrcVhuTWMranh1Y3ExNTlqOGFCY2V0R1JxakF4WWdUdVA4dlMwZGxRcmNGdmlQYUFRbm41dnd2TGFEN3Rxb2ZFNDdram9UUnZxb3owV0Q4c1JsckxRSGhONnFBMVpIcHlMN2ZuQXZEK2pCK1U3ZFAzd0grem1CeVIwcUl5UkRMcnA4bGRMZkVUSU5qem9KWm1GVm5lQzJMZm5BcEc4TitpM08zU2kwV2VPaHFRL2taOEczQmYza29pMERURFRpbkRpRTZ6MXJ6Zmk2ajU3em1acHhuUGhxQ3MvYXBEVEJ4M3g1Z0M2OTZwZ3I5MnhodXZNUmJNN2pmYWxHTWZKNXArUFhrdU9DbkttcEd3MnBiTGxBTm82K0EwdkYrd3hJeHNXUFlkR3NRSTdTL0kvK0cydC9QRUxlVkRRY1B2Sy9Kd0IrRG1Zc3ZnM2dxekJqNFJOWWRLUXFoVDhOWXlKUEFmeS9NQU1nTi9sYk1BUHcydHU5Z2hsNEw3eS8zRVNuc01oaVRoUU5MbXUvLzlLZmVSOW0xUDRJd1BxQXlOa2xMQ3IzdG8relp2eUZ6OXNUaWN3RmdPUEYrZndFeHV3K2dVWFlNcDJkZW9UdzhMemhjOGk2eUZTMFRMM2ZGMkw0QmN4WVdFUkE5d0VOdmo3ZW9URXZZR3Q4QzdabVA0SVpuM2N3WTlZSnNwSDljN0MxL0JnMnAyK2hrbDV6QUc0Q09GdWN6N1VlODg3SGVJMW1DcSs2bzhYNVBLWElYcHpQcDk3bXhwMGIrdFo4Qm1DOE9KOHZEOWdUWndBYVpJSjBDdUR2QXZoM3NMMnNubFB2d2RJK0s3d1BtOE4zWU00U253SHdSN0E5OGlxR2tQL2Z3aDZDUnhpUndLS3JzQ2dJTVhvRXN2aXUrSC9yYVJkQ2Yyb0Nkc1FCU3VUV3NEclBNeGorWXpxR1duMk16OEQyeitQbTRidTF1dVNwRDBORTVVREc4SlZoUUxIRzM0K1JVMlRXREJoL3JUQzByMVQ1MG1RaktHQ013R0IvWDZlQzhVQlF3WUUwNXFBK0JLRXduWk00UnZtZUdNdzJlK0hWSUNwaWFlQ0owUkZrcW82QTVIV3BRdWhlaG5nUFZLTXJIVlFZWXBvendEM3hhK2NtTUppOS9SSUJPYzRUMTRVS1VDb1FhNElKSXliMFBVdzV1OFArZW5QeGJGRnB4N01YOXdqUHBUN0g3OENBSWtxQUREWGJvS0JJSXpEZlNRSHJXSlIyUU9uWlRIcEhJdzczQmxEaVZIMXVFcTZ6VDBreEpNK29NbWpTbzdUbE9GTDBhUkNJQ29pNFB5cnVGVGRJRzMxekdvWG9EVkE0T2tXbFR1eHZVbUtLOFd2VFZxSXp0YjhEYTB4QldCWGk3QmNGUXdwUmlSNDMyU21LZ2dlOVZ6Zkl0Y1ZTSkFFeXo2Wm5nektCcnAwcWFLTUhNZmNQaFVNNnVLWitOdy9mdldvdHhYR2NpNlZmcDZDbGltYjlaRlRNYy9JSHlFNHJ4R3RwcnpjNVNub00yL2RiVVJhb3dlRUk0aXphWnE5ckdyRXAvQjYxOSs2Zk5SNHA3SDJtRXUwSVpzenVPSUNLQUZnRldmOVZhNUcvSFY3S1FmZEFZUnlSOC95cURqd0Z0QkpkSUdlSnVEaG1STmg0SDVpU1hwVTZkRURnbVZyTDczeFhTa3ZtNzNzdENtTnZaOGdCTk00eGY0dTRKU251aEQ5SlJ1VTJPeUlXTkpUekp2aUhmMU5rNVlNcVk5bUcwaFRTaGVpb1dKdzVVWDRYOVB3VitORWhua1BmdzdQSVB2WENvZnd4OFVRWWI4TFBva3pUYkRmYXJ1NC9RczNKNTlCK0tnMnE0Zk5hbS90b1RnRk5XYXM1blhmcGk2NHJZRGhwSlFvK2ZhODZnWEUrcWFUU1BxdWNwamlHLzZ0UllCdXVFYVlSZDBrL2xQOGdudEE1MFQyVzZuU0w0WVh0ak9HcGIwWFJPWlN4Z0U1b0hDUHhDdWw1ZFBpcEdYclRHSlVQcUx5cjFrYnhPMHA2VHVVODM1WE9UdVNGSzJ1cmUzb3FlSlpuWDUyNGR2SmRVN1J2cEMzeUI3SEdvdUtXSFhLMkNlVVhiN1QzN2wraW5PY1I4cHF1MnpJcU9pbk5IVjlTd1V2ZVMza2NkYURSZlREeE5vblg0bk1UQ0w1dmM3cGNYanZ5NjlQSUV3Z2VQb2JoMms0UXdqNTVzN2FYUTEraXM1YU9iWXE4QjZpN09qamowVDZnd2FpcFp6OVloKzg3NU1oVDBrUGlaRHJ4QVhKK0EzK3Nqb3REY3VHMVlCOC9oUzYvVE9qSWxoV2RrNlo1MW1nM0xVc1dhUUkvbVdrdEdzRDU3cHFNUFc1S1BrY2RKclp0ZHVBdG5DSmVZUzQ3VG9neVh1MkhHcmIyT1FYdXBlZUNyK2tjcUh3Vys3RnR6ZG1GOGxKY1A5WGxLczBDME84c1RaeFZ1VTdlZGtoLzAyZUlQSFQrbzk2TjlMeVRvY3JIMEJjWnFYU1k5Snc0VGZkZ3hDdDhkOUtqeUhYU0k4WGJpYi9wMFRmcE82WW96MGFIbnV0ZWk3STU4dDRudlNjdTd6dmI4UXhSNWt2OGVJLytDQ2ozTU9sVE1zaWp1OWNPQVhVRWpHZWQ4dmtWZ0gzMG5HMGR3ODQ4a0xQT0VkU0JSZVVIeW9GeG5hSVR5eWkrTitBQnlpakpNZHQvNTc1Sno3VGRTT1VSa0l6ZUt2K3Ezb1A2QjZYbnQvei9vOVl5aGhBMzZkeHdmeVE2TFB3SHp4YWR4OGZ4L0FSYzNsdVQvQkI4NnZmMDBlSkkwd3RuUCs1UG52c3hrT3FjTXNyeVkvOThDdUROeGZuOGhoc3M0Y2JDcmY4dFljYmJ2NFFaQkxjQXJ0d1F1b1VaT09ubHVJWVpWNzhqSFgwZndQOEY0RTlRcHFKV29PR1FYb1kvQnpNd25pRWJiWUZjeTJrTVQxdm94ajU2dDAxZ2hyUkwveVFqdXZUdmZ3SGdUd0U4UFRSdHNvL3pLWUNQOTBWbmN0N2NTSnZxa0hnZlBnTHdIMkNSdk16TmZRVXpaRDlHSml5ZlJ5YUVYL2Y3azBFcjFHcCtiU0NHNVV2aytmeXM3NGt2STN1QVhNQ004ZC94di8vVngvVjFtTUh6T25EaDQ2Q1g1bEdzVFgwQTdPUnZYYWxYUEpiNjBYMkkvZ2x5amJoOThLc3dvKzF6WkllSDkyQm40d1pzejM0V3dIK0JydkVYTUVQL3J5R25RNzFFVHBmNHVqd1cvMFpBaFhsaXRFTXFUQy9BbWdScW5PZ0ZNbWp5WFpremhSMUNyYmpZanQvRDJoSW5zTFY5QThEZlFjNUlFUHY3V2IvK1N3RGVhYTEyVDJmL1JXYUIvYTZNditoZkcrcEd4ZkcrRHBCK2JKSHJ5QkRuYmxIV0NVTnI2YlJQYXVOOERYMUlNR1M0OCt1NzJ2OE8xWG4xZCsycjUvYmpCRTFEMVJFMjI3SUdNSDlMYzlQbTZOUTdmWHNIS0lUZHhLenFlb2xReXZxVFhIdWduaXBNYTRJQ3JxeHZjdjNvNWI3MTZnTS9iMU91UzJWdEtEVEEzMzhKaTJCWXl6bXBNY2FkOHhydnF3bmxWRURCQkEzV09xVkNpd3lwdHJGRTVtMDRqNHlhV1BReGlhb1E2dG1QVVVDalIyT0t3cFMyYWJ3Nk5HMHI3OUdvQVNBYkhDZ3dxUERIbWtuMFJLVUFRZVVZKzZ2TStBYWw4S0YvUlVSVVJiRFFlV0FmZEM4b3FISW5DdVU3b0ZvVEt1TFQ2cGxzM0RnNndPeXpmNlE5eDNEUDBqWkhKbXQ3N0FmM0N1ZHhyR2ZhejFXZjREQlNQT2J2bWlHblp0YUlWK0tjbXRGZGhSMU44VW5sS3ZlYXJodGhKL2V3bnlvSThucU16dWJuREtVVEFwQWpkeEZ3VW95K1N2dSt0ZnBWakFqZ0hHcVVjcUVNYlhKTklpclF1ZWFGQWxqdU8yN3YzVC8yOWFEaE4rMWRYd2VtME9RMW5ZTU5MUHZJVFpqd2V0UG5lNFJRUi9OUWFIUEVLUHVhMXJETnFTU0IvdlhUQ0JGR3czWHF0cjBDY0MrcE1hNVhJZDFrcjIzMlQrdHRwVWlnQ3QvR2trUk1sNmFLWkNxOFJzNlhqWHgrYXJ3ZitacWlOdUFlcUNuL3VMOEp0WEk0eWVqWjVqUmdkRkxvUkJRNi9pR09KaDQ4Z3UzTGlhNmh6d0ZwRkhGc3paRlNIUzc0Unh5OEFhNVhXMWVCdlBzQXI2cU9JRUE5MmkyMmVSMStyY1lUTU5QQk1zeFhUYkhOYzY5R01mWngwS2pTVkp6eTBOMGpuSGZ1K2FUb0ZaNWdCMXVQUWFmUkFJcHphNHE5WGZqTzFJaGNaMVdPSzcrbENsYnFReUo5NVdlaFJHdXlvMjlmZjRGK2VxN3pFWG1EYW5vK2tmOWlmMUprV0dOMTVCWVlsdE01SnVvMHhvSnpPL1JUK1duSW5FWEY2UkJ2VnBIenBzajBST2w1Y29hREdDUGE0T3pXNW13ZDNML2MxM1R1QmJMQlh3Mzhxb3dFeWhycEV4aStZZ1F1bmRWR3JhVW9KcTNuMnB6NEgvRWFnem8wWmJmMm03WHpTTTlIY2w1cGlLVkJtdnVkbVN6WVA5MXptOGJxMFZOT21RQTRjWVhxQnRuNWhlbWppYmRZTDVxMWp2Vk1iV0JSekp5SEcxd3paRngrTFlqMFhINmZPbTl4aHRMWXJlZUN6dW5zdzAwZjQ4M3I5bU1BcHBEOUxETFNFRVI4RTg5dzV5eUlyTVdTRUx0d2pmK1RmdmJTaGZiZS9hT1gwRkhFOWdwNjdudWxXRi9GT1cxMkxrdzB2c2U0cUdPbmtZWXlneHBQdUg5Vmhxb1orMUk1SWVTelRzTUZTMzVjMnlGQXppTGw4NDQrU3ZvUDVQTTRLSWNTVisyajZ6MUdjeUJuVDdtVStWSjVTdHVnN1VCbFpkS3g1UkI5UFVEbUk5VG91VDUvTFhvZTVQb28yL0wzZ2diTDJzUjVWeWM3cGZGQVZ6N1g4ZkU5cVU4RGZWZStvM2JtdGlpZFFlUCtqM1ZZQVJUTzEwWGZBbDBsTHpDMFZxUWg1TGNuZlRnMzZCVUxSL1FLUGEveUVEWGUxM0U1NVQzU004VVhOUWVHcU5zbUw2KzBpT2VQYmVrZTRhZnFJWlMzR1FuT1ZSNDA2YXpiMGtnZjliUzhwcm9xZmNjMnpMUGVSemxBNVduVm5WRSs1LzBjM3pQazRORTNZTTVrZEl6WXluZ1ViMU5IZFl3dVBkL0M2T1ZSZSsvK1RhZTNCSzdWYXdHUlFjbHZFRzhVdUNtY2hSbU0zemhXUnBsS3VHUFlKTnhHWmhLZjFLSWc1WHR4QU4zWTluaHhQbjhLaTVTRnQvVk5XQXJoR3pDRDZ6Y0IvSDNZNHZ6Q3dEZy9CenRrck9meENjekl5QVcvNmI5Ti9aNk5Hd3pYc0VWOTRjODlRbWIwRnQ2UEs1aVJzc3BBUktEUjBLTlJyMVVqVmd6dDRIeDZwT3NMbURIOFA0TXhpQmV3Nk0rM1lRcWVNY3pndTRFWjNUK0VHUnFmRFJsOHZhKzdnWHVtQTlHdkNzY3dvK1VMNUlQMEppeGE5VWN3WXp4UXBpQmczWkJ2K1hPLzZkY1p5ZlFKYkc5OEFiYjJWQmI5K2V6dWd4VmdSblpmUjQwQU9SVFcza1loUlBLM3hmbDhEVE1DVjlmUTcxbElHNzJ3T0ovZmdOWCtCY3hRRDVoancxUFlQdnNTYk41K1JxNUhPSVd0NnlldzlmK0JQMy8xdW8zNmZ4TkFoR1N0YjFvd2ljRWJheTFDWUFlQ0lLSkF2QkNmMnlIWEpnR0VtTE1QL241Tm1iaUNuZDhMMkRtNENhKzNMb3lKQ3NrbnNIUDJJUVpTM3dneHBIR3V5aGdLWTV2T3hEV1VRUVd3dnoxTU9aa09LckMxdmdHWkZJMDAwZHFFcnl2YXBxYTA2b3pod1BIWG1HQ0ZUaHR4UDdYWllGOFRRbmZBY0RSM0RacnNCVWVtYWEvaTA0RUNKNzNrNk4xN2hQNzZoY2t6dXlaazlRaWxxOWE4YkR0ZWdDaHBoU3FETkVYTkJNQzBxWGkvNzRIRUhJcUNsdSttRWtOVCtFM2M2RHAwSHFnc1VTL0dDY3dRczRNSnhHU3lDdTlyLzM4Smk3SWFJeHRUeUpDTzJwQ1czTnQ2TmpUSUhtRm0yM1J4SUJWYXFxU3ZlUnpyOTk1c0NRTjk0WmlBMG1CRlhrQWpPNG5uSnNncHR3ckJBR1ZhcHRSMkkxN3c0Ym9heVBRZTdyYzF5bmV3VFRwSkpLTnVZSmhqK3JOZGo3SlkxNkttMENZZTJIZldkUzQ0VjZsR0Q5QkpINVhHM3VSb2lTUlVoZlBXdDZZcGNxZk4zdTlwN01oenlIdTFyUjJ5RWtramN4U3VrRlBIa1hieUhKQldNTVVUTTl6UTBNcGExT3dURmMrNjd6bFBOT2lyYkFLWWNZdHJyWUl2MjFHRkUrVWkvc2J2N0ZjeWNQazZiSnVjOGxvVjBSMW9MT3FNTlVvNS9xM1BCMmx6VWxiNzlYRmowYjVNbTM0YldWazZBckluZjV2VGRPNEYyUmNjSzZPM2xRYlhGTVJVRHZBM2pwY0tkVFV1dmhad1dsTGdwS2pnY1VGN0s3aDgyV2JqZFhLY0NlTStiUzBUZ2ZhWjQ1MEJ1UEQ5d21oaUttZkh5Sm1iamxwTHgwazVoZEdUVzdnQjRrRGF6dHFWeEoycXhDRG92bU9ieVVDS2pQOTJNTnFwNzFYakhCcExsYWFLRVBJNW5icTBUWTV5WmNyeUJJRWZTRzBnS0MzSkE3MmtJYmpncmVYZHVqK1RvOFNRc2xqR1U4eGoyQmNhSFpUNGVYaytHYXBRS3B5WUFxNmdEOFRMb1J2VlBiRnZ2M2pmU2NPamNqcGxySUh3bGUwQjVXSXFRSHJMTmpsUEdvbW5Ca3pPQlhFWlVDcXcrK2c1eHdOMGNSZjUycmpQZEM4cnphVWg0QmhsQ21QRkd5cDdUT04xUXB2VEJBT2xjOW9XbWM3UnNMUXY0MHhCTjVEM1RKL1JLL0VwZ2M2emIzM3lLb0VHSU02ZnlvZzhLNHI3WXdRWDYrckdHdDY4aHlVSE9DNitRNVhKWEtPVUhoRW0rMnFmcUdQOEJGblhwV05RWmZ2U24yT3RlZVVqT0xlUngxT0ROL2NoNVFtZGU4WHJHNVJycFg5eHZwbldlaXk0YU92ajVQMDNrTmQ2N0hONzJlYUkrVE85NXVNalBTZnZzeGQwUHlOSDUxMkd2YTI0WHZsTEF0ZFVaWVpONWI1WGhUWGNnTVVmS3ZvS2RmWktXUW5hYm5SaTBoMDRINjluY1NkL0UrU1NWWFJTUzN1ZWVwUTJPNlZxbXZ1RVQ2OUJ6MW0yUS9ta3lGL1YycUdoaE92RytTOE1CMktrZ0xZcmZFQ1NFV28wMTNuUkRxMnZ5SExGLzlTdCtIeU5hN0pRSDNoL0VnMVErZHcvV1FhRCtPaGE5Qnh5UmdQK1ZnYzBPZ1BwM0sxZ21XOTRoamdINUhVTEhVUlRqOExyMHdNVnVEenVIVjhIMHZPNFYwaTdJKzZwNGFKRFFKOWhSS0RpclpwT0lkSlo5ck9XeFV5ejV1a3pPb2FoakZ1MS90THhPUmxJZFQrSC9UdGhIMkpEc3JhcTgwano0UGNrbkhPQUxranhwOWF4cjRIdUFSb1ZWUysxVHk4d2djbXdTays1WnV5REdoZEpOemp2VStmYlZUN1hkV08vcVJOVEhVREh1STRzQjE2RnM4ZDJtVUdna0Rua2ZjVjZCLzVHSFpGamxoYTJuL1JIb2dObHYxWCsxa0FMTllZbm11SGZlYzhWc25PU3J2R1Y5MmZYbW1QYVNOdDBYTUk2dTh4a1FqNXZoSnlsU3Ztc3ZTRHp3dmZFL2FXOGpmSm9LcnRFZlJIMWNhTnBhT2lPZDVDcGwyLzd0U1hNcUxxb0dhTVc1L054anlGMEI2UWF3anVZb1hBSlM4djhJMWpFNUcvNTcrcGRSb0pIQnVRN0FQN0srN05FV2JmaXR2OS9DOEIzUWpUdURzQWpwanAyWXlJUkxiM2NEa252eTBoWVJoUE1ZRWJwenkzTzUvOE93SXZyR09tOExTcEtPTTgvZ3RVNS9sbi8vTUIvbzNmaUV3Qi9lT2g3Sk0zMFV1cjBQZ2V3OWJrNDl2ZGVlZ3J3RlZEV21uVUQ4aEhNSWVBU0Z0SEsyaTYzWWV2M2oyREc2MHZrSXR0UC9Qb1J6T2grNmQ4WHNJanhSekJEMkhOWVhlYy9naG1DYWRpUGNGYjVqY0Q1aUllcTQ4R2pOWTZaK254b1BnL2NGNThHOE45WExuMEpacmk3QXpQa3JtQUcvU0g0TnN4WWZnc1cvZjBqMW92K0tYUWhHanBRTVI0R2dycEJUcmRFZ24vRTU5aWVFaU8vcjFaUGV3c2pma21aNFFwZEduUFV3THB6NVRBam9TNlFQWS9WQTJvRXp5b0FPek9md0l4QXRSVFVPc1o5QW9YT3cwdnZwOGpNRHNBSWRtYko2Rk9JVEF4ekdETmgwTVB6UUtIck9xRHB3M3VoT1R4MVp0RTJVQWhqVkM1TVdqT0t4anBvVEZFMjFHYnQzYXduT1NRa1JhRjFCMC9MN1V6QmMrUTFHZ1JwWjFmNXJhT1k2dWtUYVRlWm9jU2t1aktlUWduclZ5VGhMUXE5UGFBR1pWVkFSeU1UMTJUdlhBdlRudEsvSW52NWQ1UW9BK3VueW1JZ0MvYU12QnFzRlVMd3Z0eEVGcFpUbTYzVjc0b0N1eXFzcVpSUVExNHlBTEZmS3RqTGVsUWpaUnc0dDV3UHhSZjhvMkFBdjBabERXdC9KU1crOTRGR2M3YkxxT0dSdksvQUpYSzJ1RzVrMUJPdWwvNUEzdGVYRHBwQWZNYjlHUVUyOXFNajNLcWlxWEk5Z25wUWMrMjJ5RUljV3N1WW9LbTFxNHcvOGpwUDRiVjQybnYzVHhwTGd6eVNzOFlzUEVDdXdadjZqN0MvUTcrQUxsM1JtcUpVRnNVNXA3YzRuK1c1M0RhNUZseFNHa2piWS9tazBZd0tTeW9sb2tDcCs1RDdUNFhLa2V3clh0UDVXSHEvYUlna0x0RW9hOUlKM1pORnRIQ2JQZW8xSFhiY0QvR3NSRng2Q2VDb2VmaHVrVTY0TFEzYmd5RG5PVUlVMk5jeVZwNXI3aTFWMUtrQ1hIRmlRVlBhYk1STktTYjM5WlZRVTJKS3U1U3BKbTNwVEtNT0RQeU50Uk5UeEZ0cnhtTjZTajhUcFNUeEJ2ZlFtWC9TTVlGNGwzT2t5bHFlcXlQa2pBNGFsY1Q2eEJ6ZnRyMTNYOHN3YllFaVZheWVoVEhLQ0diU1lFMzFYaGlmZSthdk1ESVRId2h1U0k0eGZUdzJTdWNKem5VQm9uUXFhUGcxK0RwVlZtbWJOYVhhb1h1SzU1Nk9QMHBIQ3FYdFFCdGNaMzFtN0x6R3RxS3dxWUxzWDhvTENkLzJLTy9UV3JUWkFYVHNDa0xPbFVaWGRVcFhIS0IwcFBLVjN3dmxzTzhQNm1nSXBKL0VrNnBvSkQxWEJYT0tVR3NzQTR1dXdZNzlVNzVTNkhsVTV1ci8xTmZVWkRkQ2NrS2tVU0xJZ0JvdEVzOWVNYTZCZHdCWkdhaHRqR0E0blBTYytJUGowRGxJdjhsY0pPTi81SW1Gbm1zVXF6cjk2VHYwZjQ2SFNsNEZPbHJYNkRseEJXbFdvcDJ5dDlLNmkwd01sTHpyR0lhSGJzQjBSVXpYSHgyNlZINmdJVnJIUVdNeGRXeDBzRHFST2FCaGxQM1NLR0ExQWtOKzQyYzBPR3psOTA3RUUvSWVaSnNScnl4aFJ1RXJHRzJIUEgrb1hEWkdscm5WT1N5ZUFlb2NVMVFuOGo1amhoamlEc1Z0ZmU5bFNac2pYSU9lUnhteUJ6cXlXVk02Zi9JM2RSQVpJZU1VNGp3dDc4QTFqUHFIamJSTlhBeVVDbnZ5VjNSYVpadUo3d3FHS2VwOTFLa284bWFKdGl1ZVEzbE95TS9HRks0MXB4VSszM0c2MW5QYlpLTjZiUTEwM2hYUHFTRWhPWkMwWHVaSHp2ZWdIZ2NaYnhUeU9mSmVuWGg3MTgxa1F4bU9zcXM2a0Nndk9pVGpSWWNtd0J6OFdEYmtVUG1jeGg5QTZJVFBYNjA4UzZUbjVEL1YrVUxyNDlib09mZGdYLy9VeUt6OVZOcEsrVVhmczRQeGt0ejdPM21HOGpuWGlqWFMwZVQwN0VwemF2d0d6MWlVWFhiaGMxQStWNW9VOVZCOFByVFBscldXQUFBZ0FFbEVRVlNaOW5pYmpYMGRtYVVDR3VWY09IVTF1VlkyNWJzNGx1SzduS1gwM2pZNHVNaGVVbG1lVG5hNlZ6a0dkUnhSQnkzSU8wbkhWOUlIU0Z0QXBwdkpBVUQySFBVcXhMTkt6NHR4K2puVzMrTTZxTjRrOVQrc0haME5WZmRBdkhna1p5cWVJY1h6cWhkTStsaHBOLzRmTTFXU3JqRDZQK29sQ0dzZ2xUZUl0SWZPZG52QjUwM3ArVGp5ZWs1N21WMmtrQTJSYVR6YlUvbDhCR0E5QnBLaDcyZGhocWMzL0g1R256Q0tjUXhnc2ppZkYxNUlOSXd1enVlZE5DVk1mU3pmTnpEajMvc0EvaXNBLzVOZityeS9HOTdoWjk1SnBrMWxHUGNqV01yazc4R1ltQmx5K3VkZlFrK3FGRFhrZVorb0tOcGN3M0I3QTlseWZoTm0wTHdENEJkUlY2VDBRb2hLL2NnL1A0RVpmZjhjdVU3eGM1Z3g5UWtPTkRJdnp1ZWp4Zm44Tml4eThLbTBOWVdsMEw2NU9KL2ZBdkR6c0lqVXQyQVJ1RzhBdUwwNG54OHR6dWQzM0xENU9RQy9BcHYvYjhPaVd2ODl6QmovSVljRDROZGg2WXQvRFVBRDRKOEIrSzhCL0VNQXZ3TXpFdjliV0MzbmJ3RDRxOW5kQjA5OUhaN003ajU0ejl2OU5vQlQ3aVhmbDUveGR5alIvQVRBdndMd0x3RDhMc3d3L1YzcDR4OEFxVzd3U0ZJOVR4Zm44N2Y5dHdtQXQ5d1FmaTFZbk04bmkvUDV6Y1g1L0IwQS94Ulc0emNDbWVsZmdqazUvRGJxdFpDWjd2bERHQU4vQWpNQTBuRCtVN2dHUk9FZ0FCV1BrYkdrSWVmZzlrVFpOcEw3VXVxb3luTzh4dFJMSytUNnprd2pzb1BodWIrQTRiaEh5QVQ0dGFjWkprRUx4TDhYR3ZOZXJETDNvVzhxWkpFNVN0NlBRZmpiSXFmZzdVU1dITnEzbDRFRERJbTlNTlN2eWx3QW1YSFIvYUxDQ2U4dFBBTVBnYjUxY2NiZ0ZyeVd1YzhualJlYXduVFZQSHozMGhuMm83alBxQkFtb3lyN3BzTmtINmdBVUVVSUJad1VSZERldTUvNkRKa2ZLdVhrelBXdFFXSnc1RjcxanFSWDhRTERCazJkZ3hIRUNPTHYxdlJRQllNOTBKUjZGUkpvU09IMWZYMFp3NTI3a1BFRCs3SUZNS3ZOVFpzTkR5bzRrRmxNQWpucXFTbkpZRTViU3owVWxUQkpHWWhTNE9NNlV6bFVlSk9LQWxTTnM5R0xONDVsakt3ZzBRd0xBSkpuZWtxRjIrUjBzSkI3ZWRaSUQ2TFFuMEQzZXFXTmRBK3lNTFFWUEZkcmQwaWhScVVkQlNPOVYvZE1PaGN5OTNvT040Mmw3K2FjRjJuWVd6TjRNZktaZUpwdFVDbkxQeDB2MDdOemo2d1JCQ1VaTzRCT1NpaE5RNTJVMk1nQzJrUVVZWHhPbndleWN4K0Z0UXVaQzFYNFJXWDNManl2eWsvT3QvYUhBaUZRS2tVZ3ordjlLdWp5UEU1YVN3WE1kRjJxME5aOVRpWEt0bm40N3NKeEU1RFBkSHczYXhjQ1NEZ2hwZXZlUTUvb3lLSjkzNFY3amx6WWpITUhlV2JOZllaU0ljSzBoakd5aExJYUJmQzlxUzJIZUI3U0phQncxTnV4WFNvcm00ZnZMdVArQkpLRHl3dnB5NG5lNC9jcGZpQys0U2ZuUlJXTU9sK0sxeFhVTUZhQTlIY3A1NWZ6Y0FMeDltNXpTdGNKQUswTnVHaXM3dlFLcHJ4TWFhckpBL2pjYVlvNFZZcFRPVVNQY3hxRisvYVVPbklwenR1MU9ZVjRWTGpIaU50OXZIdnhibFZjeXR4dFVGR01Ea0NORHRkK0g0Sm9ORmFjYzUzeUtob2hXcnkvYjk0RGY2eUdnK2hVMGtrVkxJcjQzdjRGUHFaUTRxTE1JS1IwaHdwUVZkYU5VVWJseGJWVC9GTVl5YVN2M1BmRThVclB4NVcvUWhFY3g5NW1RMUR4S2Zkckg5TjVSRDdudWxhSDBQTmlUQTdScVdrQ01meWduTmU0cjFVUlBpSlAxbmFkSU9KZTFuM0tkV1JhV0tYbjhkM0Z1NUIxWVZlb085bm8rQWwwMEZGY29qSUFIYVJwdkpraE8zVkZwemlkVHpWbWtvYVRMNXpLcCs0L3BlZFU2dW85WEErTmN0L0NaUDZaLzUxSyt5Tkl4Z1hpTnVjRmw4N245dEVFOHRYcG5MYzVHdklJUGZ5ODNEdUcwUVoxcG91MDkxaVV4eHhMa3MxOUhFdWg1MVFrazE5YlE1eVl2TTFUZVBycnlwejI5WFhmV1ZHbzZsTDY1Q3ZmcDFvNnBOWWZwWE1xajlUNG0yaU1xam5yc2MzTzNwYytyWnRRU3NmUHF2SkNkR3hOdklIUTg1WHZuelZzbi9UUjgyallMdlF1L3YrR2JRK3NSYVNmMnU2a3pXVXRZbVFvb3hUWnQ3NzlRSnFRRFBkdDZXeWd2TWRnbXZ0S3U0cVBkYjBLdy94QUczRk9GRThPT2tNUTJ0TEplb3ZBdzlma1p6NFg4Q0tRalc0NnJobzlUekpqMzdwV3hxMTdaRk83cDhtTzk2VG5TZDhSNkRuN25PUlNlVDd5TTJuUHlqc1Y3NDZrblNuSzg3cHYvbU9mMGp0bHJPc21sMDlRdktvT0ExVUk5RHpLandycHpOVDJXMU9tZTk2aDVJL1NIcEZ6b1VCY0cvdTZoZEhqaGVQQnBYd3Y5a3Q0bDhyWFY4anljNVNISXk4NkJycWxXUUsvd0UrK0krcUFPbmd6ME5Db1cxS2VMZkZKbFQzUEFBL2xwemsrbG1LZzd1QUd6SmFuQVJVRi9TQy82R05UUjU2YWZBNkVjOWhtSS80VWdpTnJJSGlBYzZXeUl1ZW10aWYwM0l5OW4zRXR0akE2L3F4NStPN2wyQTI0ckh2RXRJUFBrRk1qdjRBcDZFY3daZkx0eGZuODFHc0QzMEMyd3FjT3VZR3RHS0JIQVU5aHhySy9EWXNDQm5MNllES1NOUDcrZStRbzBjL0JGdXhqdjg2TnZvRVpVVDZFcGN3ZFZDaEVRekM2aDdZQUg4ZUpSOU11ZlI1ZStQditFbWFFL0FIdkhXcXJBbU9mRHlxRW1EcnBGcnFSRVMvMjFSbjJQbEN4QS9qR25OMTlzUEdVeXM5aGMvWW1ySGJ2MzRZWmZ2OCtMTDN6VzM3dGl6Q2o1Yy9CRHNiM1lKR29MMlozSHl4bmR4K3dqdkpUZWZWTm1LSDJESGt2c1liWm1iZjdIWmdCK0ZHSWFtVnQ1RE4vNTJkUVJ1azhna1ZDTDJHUnh2OGF3UDhHNEk5aCsrTTltT0g4dXdEK0VHYWMvbll3bGs4WDUvTzNmVnkvNCtQK093RCtGdXBHMlY3d09mNVBBUHh6QVA5ZGVQNFQvM3NFMnlNLzhyOGFmQUl6VnY4K2dCYkExMkJ6L1Zjd3A0Qm4xMGt2L3BNRyt4UXJSS0xoUGlydTFPaGZNSGFpTkR4RUFiU0RDVUI4aGthc2dsRVJaY056Wks5bDFpVVlJWjkzQW9uMzJvWEhGVkI0Rmw4WDExUkJEQlNkT25iN25xc3hrOUlHcjFFUlRHVkJmRGVGa29PWS9FUDZlS2pDK0xwUUVVTDM5WmZqMjhwWXlWem9iMXo3TFd5TkQ2bDFjeWhRb0NTVE1vRXhPbmRnU29VK0pqa3AwTnRjeDNFQ1V6S2MrdDhac25LNUk5QU05YlBKaGp0QWhCclkyV0dFRmM5RkVzVDVuQmlJYUJndTZoRTN1WWJ3Q3RsUVVuZ0NjbzRiU1MvZDEyZFJ4aEMwQnRpaXNVaThxUGdhdC9YNjNacTZWb1dlTVE2dms2Z3AydFNyVWR0SzlkQkZrS0F4UTVWbmF1Ukw1N0V5ZnZaM2h4NUZqNjlQeEg4cUpPbmFyMkhSRnlldEdZWlVjUnNOME96dlZ0clNOTWQ2UFJsRVlJSUI1MEg3dzNHcm9rREh4em1MTmVWVjZJczRpLzJLaXBVNEY5VklyRFk3WG1nMEhabC9ubU4xa0NGdUtieGxWVGxFcU9CWHJZWGFFUzZrRDNTWTBuU1ZCZTV2SkZWV2ZMY290SWovZFczVkVZRjEvWTZCbFA2UXVKRUNOelBhc000ditkeXBLRWdZamFCS0g0NVB2WFpIS00raGV0a3JiMXBFSnduZTRmeXdENnE0VXp5ajg2bEdVZDNIakM1UWd5em5kZzAzUHFBTFNSQjBSYXp1VTg0cC9KNjRKK2dBUncvbHBieWJrUmRqaUxPTnZoTmRZeGV2SlNHN2VmanUxWURDS2VFZTRkTTYwUjRVbW11S3hEWWJSRlU1bnRKNWt5ZXJQZWY0NWtacmtmQzd4b3p0ZE1TTUVDTkN1T2FzelVqY3RVUGUwMnFZcGRJaGdhL25sWSsva0QvMktPLzBHck1mRk5GOTRYbitQL1cyYWVqbU9MaG5VeDB4MG9rdzU2cHc2WU80TjRCOGZrZ1RDbVVKbGVPeHZ4VjZ2b1licVlTSGkvaWM5eDRrTTRtQ0pmVTlLT3RyZTZmR0p5dnQwSEVRMSsrVkk3eE5wY2tkSldRUGZ4V05HVFg2czAvaFhUV1N5ck9SeHFsU2prQWVkdFdhb1VrTi9zVDV5dGZFL2lTbFlGQUc4MHdSTjR4bERZYjQ0QlRwcFQ5VzFrL3BlWXJHRnlWdk1XWUhLaGIxVEVSajI1SFBnOUlLM2Z0c1UvSENGaWhTWENaNlZsdlBNUDlzdHpCK296dlBHaDNPNXlJOTE0d0RVWWxKT3NjU0JlUkJObTJPRHVPWVZYR3Y3K2U4VFdGeUJQY0srWnVZTldvcXp5azlwaU1PKzA3NUpxYTczU0hUMWd2a2lPRVR1WWRPWnZFTXNsLzhubmcvWkVjQVJpcnZZRTQ0MHpZNzVoUm5xOG5HNEJoZHJjcjRVZXZPZWVHZHAzSlAzTWMwTmxHdmNJbTgxcXZXREhZVEdDMWwvN2R5ajlKdTdkTVd4dmNNMFhOOVBzb2JCZmk3ajJ1MDN1R296Y1pGcFhtOXhtK1pqMk8razNxWXlqeHJ2d2xzVzB1REpGNis4cWV5Sy90SnB3V1ZsM1hNZmFCNGhQdVgvOWVlUzdKTDg3REkzTU16eC82bDZEZlMwbkNXUndCNk0yL0l2RWQ2cEE0d1NzOUpQOWNvVThLeUxpcDVYTGE5Z0VYU3JvVFhUSHkyM0hkZGVrN1FaNWVOT2JkM1pGcVhQZVBlaWppYU1BR0c2eEFMcVBHRzMyc0dtNkkvS1BjWSs5S3B4ZDZ6YmxHRzY0T0k0MnBBSGRXNnpZNnJLbXZIZVloRzd1amtva2E0UXVhc3pIOU5ydWc0NXZuNlJkcW92S1hLcFVxSEkzOFVhY1VtMEEvU1FlSXNkUVpTcDZNeGNwcmYxRmZaeDR5U3Jjbm5IUnFNUEZlNkg0cTIwWFdrWnBhcXlNLzIwWFBPQytrTmtIa1FsV21aOVhZYTVrL0hUMXNXenp6WGVDTDMxYjRUQ3VlYWdUMmU5by9MVWFyTDBIRnhqZmdlOHFoMDZ0SnpzRUFPdUdROVlEcktVQmJScU9YVXgzMjZhK0kvNUgzTnVScHlsaUorWm1CSEN1NFF2QitEb3lMZkhIbVB5T050NEIyNTVZMS9qRElDWTRQczhjV0oveGxZNU90MzVUN1dMTjJJRWJSWVhJL0FQUEhuNFFQNlBaZ0JEL0w3UDBhT2d2MEl3UDh0L2Zza0dFRlRmVHh2LzlzWVR2ZFRnK1BGK1p5aDlCc2dSWTJTZ1R2enNXMkJWTnNZc0xUSktTb2F3Q0YxZEJOSVpPc1pyTzd2Ry82K1MrVE5RUVhIRVlEMXZuVEZBWjRqTUNtenV3K3VGdWZ6Rjk3bUV4aXplQnMyejAvOGs0STZFY0lXd1BOb2ZQWTUydXZ0NThBMm1XSTZIcGFmUno1Y2E5ZzZjNzUzQUs2a1h2TFh2ZjlSZWNjb2F1NVhWZGFQWVliZUU1Z2p3YWNBZkFXMjk0b1EvUVBoRkdZc1AwTFhlUHpFMi9zbWJCMHZZV3Z4UGl6Sy9mZVJuUndlSXlPQnAzNC9EUW1qbitUVXowUEt1MzBLbFhDOWc3RGJYQTlUZ2NMYUpkOVRhV3NJRXI3emQ4Um5tZDVyRFhNSVlOU3ZHbkJVNkZDbWgzM2ZTdCtZUnZoZ25LTVE1cEhFTVkzaGtIbHVTNk1LMnlGd1hKem5xOWl1S0NNbjdiMzdWelhEbHlxRHREL3k3azQ2R0JMSUhpUFdDV3lka3pCN29JTHVDRVp3Tzh4aERTZ0FpU0FVMDY2TTJNYzIxSDQ5cE8zUXQ2R1V5RlIyc005MHpKbkNhQStqaExUZnhOY2FWUlc5ZWNuRTBXbU0rL1dnT1JVbEJEL1podFlNVWFOdG9UU1dwamkvSFdYWFFCODZBcndLV0hwMlJjbktHbU5qQUM4Q001VnF3YlhaQzNlRm5HYnR1TDEzZitIMzhUb1piTUlTd1FOVTNuOUQ1b0RuNUFpU2JRQzJua3hIeW4wK2hobEhsaWdWTmRGak1Tb3BxK2V3dGZRK1hKUGxudm5kaHU4N21IS0hrU1lhaWNyeEFNaTFtQ3R0cXNKKzdNb0RSckx2d24xQXhrSHFlVW84VjRPb0ROWElrUmpoMHRmR0RsM0ZTc1NSY1kybjRWN09EZnRQZm5BSFQ2L2xRa2VuTHJhc1UwZG9ERUluOTdONnVxcmlDQ2lWMnp3ZkhTTmxnQjA4VFJmeVdtaUVqSjUzamxFVjFtbTkybnYzRnlocFkxUkk2YjdpOVFYSyt1WmFZNWd5VFJLdTJqSmRxcTZyMHNNcmFaUHpvdU9sY29UNFRKWGNLcGlxTUtacDAxU2hVUFBBNzV3elY4eVExK1g2TVZLS1daTVVHRjIvVW53WmVJb2phWS85MXZxaEtyaVA1VjdGUVR4blI0N3o0bDdad0kxQmdrK0lyN1pPeTlMNTkzZHZ2TDNvT0tIUjFpZkl4bHZ5V1IwUUhtQUVyNlBsN2RhVThncTY3M1N2Nk5uVWZxMGFpOEFkQXVMUzlGNVJrTlBSSXM0ZkkrTlNTakNVNTVOMU93RVl6K2huTVRtY09mL0w5M05zTkdDbzE3dnUxeXJQRXhUSzJxWXFzUFIvemxzSGg3QXQyWjhGRFBFVWh5cUo1VjNwVE80Wkc4ZTFneGdoa1d2Q3E2SlhEWjZyZ1hhVGc3YmNFNDNyY1k1b1dGRThVeWg3d3IzYTN0NjVPVVNtYXN2VWswVUpCT1hUL2J3bW8wb2ZYOStXYWFWVG03S1dldWFBY2g5eExRckZYNEJDTm1oek9ZRUpTc1ZwR3BmMExlNXJuY09VamhXbC9NYjMwQUJFUEtsT2pLVG5mTyswdGZJbTI2WW5MV2hici8vSWQ1SFhJRjFXL0J4cEpmY08xNG80djFNcUs4REUxeFFvNlRsUXBwZWtQQmZiWXRwQ09tNUczbERsU080ZHBsdGR3T1FVS20vVk9EeEI1bm5IVGE2anVkWHpqYXlqVzhEMjJVTFdpR2VLSlNRNEwwci9sWjdyV3Fpc1E3eXFUcFliNERBSEVNZlRGeUlqOEhueTdteVhNUFArTW4wMWVWZWw1OVRoa2ZhckFsblRFaFBQcWJFZC9qK3p4Q3hSVDMyN1JENjdMSWVSOUpaT1c1L0xPRW5QVDF3V1RudEI1TXRSZSs5K1NxV0tycU5sQVcwMklBSkk2WCtIMHVDcTdFbUlQSDNFeGJzYXZ4MkFlRmRsbXhGYzdrR2c1eklYTlhyTy9hWFh1RTlTLy94N2xGZFMyWUcyTEoxVFBGY2JRTUI3U3ZPSVcrakFPS1NuU2pJYVNyeVQwa2RYMWtacDJBakQvRnZVQmFuOGlpWmtyaEpaWHAyZldkWmtDMXNmbHAzU3VWTDZmNFYrK1Z6VFBOUFl4bjNBZmFacFhEazN6S1RRcDArS05IMVgrVDNlUDlwelQ5UnR4TnEzZlJuNmtxUENIdjFYNG8xNzlIQ1JKZ0dBT3Z2RmZ1dDQ0cG5XL2JVSjkzZkdMSFMwbHRsRXh4clhXS05BbFo2cmZKNGNPQnovMERoWmc3MzhtT2lKMkw3SzBFQ210NnF2VVhvK0JKR2VxM0dTOHB3YWdOV29yL1I2TGZPcVk5TitVcDZmd1BiV1dtaHZsQW1TTEhtQS9sbmw1VTVKQUdSK1NOZVY2MHpIV1hYRUpxMVZuZk9WeU9pRm5MWVBndDZVYld4UlpxdFRnL1VFNWY2Ty9FWGFoejQzMjRDcnRPeFYxRUZzNUhucXNWbnFDRk5ZSk9nUEFId2ZHWkdTd2VKRHRFSi83Ti8vTGp4S1VWNytXQXlVT3lCRlMvNERmL1lNT1pYek01alJpOGo0UFgvbi93SGc3d0g0YUhiM3djZmUxcU9CR3NOOHh4aFd5L2RnUWRDTjFiZGdqT0ZuQVh3SndQUEYrZndiTU1Nb2lSOGpsR2VMOC9randHcm9NbzN6TlEyemhLbS84OU93aUZ2QTBpZ3ozZk1hRmtWSzVXak5ZNktvYWV2endGVEpFMlRHV1JIUkMyL3JER2FZL0FEQXQyREU4R3AyOThGek4wNC9oaGxLbjZBZm9aQTUzcUEvQmZiYTI5b0JHTS91UGxoTHhQa0pMQkx0MTJIUnZOOENzS3JOcGZ6Mk1USkMxRFFGOExFd1RjcHplWGJqNi9ZenlFamhLV3hkK3hTNVEzQUo0Tjk0Rzc4VnJqM3hjVHoyOXoySEdZT1BZRkcrUDBLcHVMOEJXNHNsWEVBSjQvMkpoQUhrUDZZQU9VUWc5aGpGRXZGd3duR0dyTlFaQ1VFNUptTW83VWJDcElyQXBiUloxSmFsOE5DV3RZZGplcitDT1E4S0tNaHZrL2o3ZGFHSEFSL1ZyaXRqR0o1SnpLc0lmUnZrQ0UybW50K2diakJpZXFzUmJGMWY3Q0g2Q21wUWlQVnQyZTlJVlBYWmFadnJpSTJBVk4rcUptQlErS2FDY2tpNFRDQnJuOVpZbnV2dDkzWEI5K3NZRldXbU1pTGVCeDF6VlZFZWhISVZQTWd3TWMwbzhUODlIMGR0cUYwU1FSUXp5dFF1b2hDQ3ZCZDVWbWV0ZWNYek95UHBpem51bVI4S3cwa1kzYU13SHNrNVN3NWV5T2VjMTlVd3FONlN5dGp1cEUybW5LSGlhZ2MzWkE3TTFTMi9sL054MWxxTlNLRGtCVkpiYlU0SFI1eENwUnlOSGdqUDl3cFpZWCt5SC91VVd1U2JWSWhnK3gyQjE0VUM4amlzejY1R0VlMS9VdDRJZnRSVVd3cFJxYTZnK0xQUENGRHNRNkVMaGNPT0tEVVVieVA4ejdhb3lPZmUwUGxaU3h0VU5xaVNpT05OQ291ZXNVWGxsanJNc1A4VWd0U2dvSXJpS0FDeS94dVlnblVJYnlYbkhPUXp5akd1QWc1VVk0RkdWaEVQMDRDVjZtK2g5SzdubnFLQ1pZYnNoYTNHcUtuL2ZvSWNxY0V6cnVOVFJmU3hmQ3A5WnJRVDZ4TmVRWlJ2eUR5N0NzSHNRMUlTeW40cWxCR3QxMVBybWRzRWdqUDV2S1pRWjF2a2d4aHR5aWprWFZNYUtIVy9FRWRSU2FVS002NFZJektWZjZrWlFnc2xpT01uUnVkU1ljL25kdDVIRmJqMVhCLzd1WWo0a3VkRW82YU9BQ3phZS9mUFlEaU44Z0FkWTVRSFozM25QbGdoNDlCb1dPRys0eDZuWXVRUXAxSlZTSEIrcUVpbm9MN1FjK2I3SXRYMWJiTXhoZk5ZbytlS1N6blhwUC9jajJ3bkdnR3FiUXBFUjRBeEpEVmdXeHI1K01sOUJYbW1VTHdGQldRY0QzR2t0cnNYV3NrWTB0ZDJBTVdKbldmYTdOVVBTTTNOUHY1SGxNWEtFL0NzVnhXZllSNFZQeXVlaW5DUUk5NmhmR2RiT25xU0IrYXpIY1dZbit2RXgwVmFJVHlnUWpFbkVCa05LR2pua1BJNTBiMGUvbzd0N0ZDbjUxU01ra2VNTld2VldZdlA4UHpROEsyT04rcG9wMmRDYWQ3RXgzeGRlcDdrSDhIUFNuZlpOeDA3RlpHNmRoMkZkdytRVHFyU0d5anBPZFBaa200cTN4clhnd3BSQmxIRWNWSnZSZnJLL2hKZkVvOHpRRU1OajNSbUliK3IvQXpyNVNYRnR1K0Q1Lzc5cU1uT1dTTmtneW5IUzd5VWxPR2tzU0kvRmc1aCsyUWlnc3lqT2dxb1VSL3lyaGR0VHEwL2crMnZDMm1PdUlaN2cxbjU2UFMyaE1seEhOY2x5ajJxdUlveUJIVnIydWRVczl1ZjVkblhzZ1NjRDBZeGNROUZlcTc3VVBrQTRodU9neGswU005MEgwZWpSUTFvMEtyaGRlSUh4YlBiUTlhUHorcTlUV25rQlNyOEVOd3Byd2xPTnVqQmR4WDVuS0E4TzljcGpuRWZEaDNMWitJcEJGZXFZd1UvcDBBcXUwUCtnZjNoWEtZNjdsSEhFdVJ6OHFhRE9FbndIM211WlBBUW1Tc1pLNE04ejdrbGNNOVRqaVJ2eERiMk9ST3EvSFRjbXJORWxNM2hZMVZqRmZlYXlzY1JIeGY4eHg1NmZwRHRveTFMQkl5RWxsZjNYRk02R1F6UjgwaXplYi95OXdvNnRsRjRycmkzWjJ5S0YyTkFpOWFxcG55K0FYTEpQajZIY2krUFlYdVovVlU5STUxc2RtM1czWkpmUDVIN0N0MXVCTlV6S29Sem9USi96Vm1GWnowNUdpR2YyWDM3Z0dlV2VKank2dzVsV20vaWNLQkx6eU1vZnhBaDBiVTIxMFZXZVpIZnlVdXBmSmYwL1Nqbm90QlJvYnQvcUlQZU9UK2FlSG1aZjUyck5PZGhMeWtkVGUrN3BzNldlMG5QUVhFZUFwNDZRaVVLSFM1ck50bjVNaG1WZll4TWJiMkZPV3ZGZmNEMDB4ekhwbm40N200S2k1emRlTVRoMmcyQTlEelQxTVFqR01QRzlHMlhNSU1XR2JUaWhXN29Pd1h3bndQNFU1aVI5OVNmb3pMbU9UTGlXOEtpSlA4VmdLZitmQ0pJaS9PNVJ1QXlpcGJLK2RXaHhsK3ZMOHZEc2dEd05vQmZodFh5WGNFTWVJelFPL1hyRndCK0E1YkcrQnVMODNtcXgvdVN4cm8xekdCNVczNmpGK0xuNWZ1SHNPalZQL0Q3ZFJ3aitYL2liZDJBR1k0SnR4Ym44eWNTd1V1bDhndll2RCtHclFFWlJhYnEvZ0JlbHhNOUFvSWJWdCtIUmNORytBUTVIYzBGekRESzlYa2J3RCtCemIxNmVCNFNSYzEwZFdPNElYNXhQdC81YjR4Nkp1SlcrQURaaWVITE1PUHRNNVFwRzZyQWVRN09EWnhQN2hNQ280cmZocTBISThFQW14TkZQR1EwTkJyMFdwSGtQMG1nUWkvMkM2MnEvSXdRbitVKzNBVGlSd0VnS3FaU2Z4d1pVOGhNNzBhUGNOMWpEQ1N3amFqRVRmZUtRSEdkNk9RT0tMUFJaTTlIS3JYMVBoWHVJcWppYWd6YjV4c3lQeFJ1QnJwQmdTNHBZRkJSTmthQndTRUtjVXl6b2NJejd5UHd2S2x5azBiRmxSUFFncEVRNXBhZTVtem5sYzdvb2N4NkRXcnowZFM5NEdwd0JYUGNPa0pwZU8xamFzaVFBRjRmcXJYSXMwOGpLMzB2UkloVGIwa3lsZXI1ckV5MXZvUHZ2a0pwdk9SdnpBTENkVCtGWitZNDlCeDRIL3J3ZmNRclpMNlpxcGpDSTlQSDg0d3pzcDl0a0FuZXlMMWtjSXRvUXdva0ExMCtSaWxFQTZWaGlnWm94WXZjQzl5djVLM294S0VwRGhORFBOQUhVSUUxcEpTWGV5bEVSd0ZZbFNvMVVBT0VDbWhVSG1uR0R3b0twUHVLUTJMLzBoNlU5NnZBRHZRYk9DZ2d4Um9xS3VoUitRSDRYcXpNcHdxWTIvQmR6d0ZUMEkxZ3dwTGlLUUtmUC9FMUJvSlhkczg2S1o0ZXVTR08xelRWcFFxVEsyOTdJWUpKaW9RV0pUL0MrVllsRVB2UGRZMjRNeW9ma2tHd0I5OXZ3eDdlb1l4STJpR25MZVo0WXNRQzIxTmxueXFxYVVoVnhkY09wYktYZEhMUlNtUkJVMFplVU9panNNNTNxZVBJQ3A2VkFtSHZlenVjaTYyTUtRbktQa2ZKV0F0M3hKRzVPSUZIN3JTVzlwaDlvTk1RdmRXM3NvZXB0T1djTXlwLzBVY25SS2pXdVR4MkFUenhBRDRlT29veHNscVZlUnRYS3BObmpzcXlwUEJCYWN6Z2VHbFFZUFFTa0pXQ3Fod212N09YWm5wLzJBZWVEL1pQY1JybDRtcWtVRnRHT1ZBWnNJVTVkQUI1UGJmZTFtUklpUlRleWJPUitKWWVIaU1aclB4OUs1bExQWHRVU0RDNkhzZ0dnU0dGT09lRDExVjVBN21tOStnNU9iVDB5cUNSMlB1dWhqdFY0aWtlMnJWMXVVSS95U05US1JmSGhBUDdYWk1KTkkwYjU2UzJKM2tXMmFjaDJyMlBSaCtzd0dyTEtBT2d4QzAxT1R2Mm9YaFBtMnRVNmppSld6V1ZjSTEreFhNRGxNNExoT3JlYkxMRGlaNmZ5SSttakJHdFpRbXFHVWpWWUttNFBhNlA4czVVRkVQdUg4bHpzOVl5WG96UWplTHY3SE14Rm8yQVpNem11Mk1Fdis3OWNaTU4yeWtxVGZrT3RpZGpJVTNrbUpXZUt5aWZ4ZmQyak5jeUI2UmhrU2ZWOWR5aExEL0JPVmRqRGZ0Ri9NeXpRbm1QOTFKNXFrN0hTekVPQUJaUm0raUU3QlBTbE1pTGtzOGhQN0JHeWU4WFBGNlUzV3JHS3VTZ214MXlJQVBuNEJoWmhqbURHSWtyOUp6UnVWdW4vZXpQMU9uNWl6MzBQUDQ4YSsvZHYxVGNUOE5hbXgyNlNGUEpsNjk4djkxQzV0UFlqNXBUZ1BKa3lxdnIvQmZ2NXZ5aDNIZTlJR2VGRU04dTl4WFBTNTlEano2VGFIdWJIVllwTTZsK282OVA3THVXZGRDU1gzMzBYR2tYZWFlWWZsVU5EQ3FmSjRORXdJZFJSa3U4Ulp1emh4VFgvUC9vUkRiMlBxVitEOUdkSmppcks2aHVRd3dnU2tlVTMwOVpkZHlRcDN5RzRoQ2c2NUFjYWV1UW5rWmxTNkRrY1hiaGU3cmVaTWM5cFNNZFBadWZxYjE2b212UzgybjRxY2J2MUtENnU2eEQ3T2ZZNTE3SFdRT2RBNkJPTTZwenNFZk8xZjdSNlNEV1ExWGcrN2lmZXVWbjRvNktZWko5SlcwbGI5M0JJVU15bE9pVkZXOGtmQ1R2cEh4T1p4Z055TkZuYXZLNTF2Qk9rYmM5OHhKeFlnMi9Fa2ZIT3NaNm5aLzZidElueXBzRmZVUjNIV3BuUmZWQkJYL1haT052SVI4aDB4UFNLcjVMTXdUdytTdTVyanhyRmNqSHlKelRLVzRMczd0TmtUTlJKdnpvZEVQMUJCR2l2cDIwbCtYb3J0cjlqb1Fjd3dRbWQ2N29HWC9FYUZJeHBCSWhMOTBJTm9JWkdCY3d3eStOd1VzQUUwMFQ3UGQvRWNCWFlZYTJiOElNWUcvQ29qZy81b0RjNEhnS1UvSitDc2JZM0lGRnlIN1czL3NoZ0c4dXp1ZFhmdjhZdVdCenNXaDk0SWJmcWI5bjVXTzVoQ2tLM29RcHhqOUVHWGw3eCs5OUU1WTIrQ3NBM2dId1I0dnorYWNBL01sTDFtbWxzdUl2WUJHd1JNeTNmWjUrTmR6L1p6QkQ2NGY4UVNKL3g3QjAwbThpRzFTQnpFaWNMczdubDhqRzhzLzY5UldBTDhBVUZ1K0grc2lieGZuOHFiNm5CeDdENW5NV2ZsL0JhdGwrdzk5N0F4WXRmUVRndi9RK2J2MzVPOTcvOTJCN3JUZmEyNEdIZDcwNG54TnBITU1qd0gzdkZYMmUzWDJ3QlBCREg5TnZlSjgzSHBIY1M2QThGZmlXL2ZHMmJ5Q241WXdFRlQ0WGpiK0RRRWVIRDJEN2pJb2sxbzhadzg3Q1FZVDhKeGhlMmZnWkRHZEV3ckU5ZXFzbWlJeVdFSmwxTUw0cDg5OExGY1l0ZXRmRzlCckZlMnRDUVZSNkhjQndGOHJVaXRLTTR4bUtmaWJocGJCK0VMaGdxQXFGdmpNL0VpSVptV2kyeFVpeFdmUHczZWRVdGxUR3IxN09kUEJaSXl0ZktWeWtkOHYvZmN6UG9WQkVoZStEbnJVZzRTZURYVVFQN1d2VDc3bENWMGxOQmNlWC9Ra0FBQ0FBU1VSQlZGeHNZd1NKN0VaV2hqN3kzMk5kS0swUG9rcFZaY3lZZ2l4NTFYT3NUZlkycFhLS1RFL2hUZXgvU1JraVRQTWhxY3ZWMkVEdmZqcTVFVFNLVDVWSkcrUW93cWdVU29LN3o5TVNaZlExRGNjMTVVY05OT3FNNTJzTFUrQThiKy9kdnkzWFJrMlpPblhaV2tRY1pBeFhjcjJQeVN5QWlxQTJleHdXQmgwZkYrY3pLdGdWZi9BZU12dEpJZWYzcEtnM2xIdGEwK2hFUllONlZFYmxDb1g4RkpWWDZWZnlzcFF4VEJ1ckJ6b2tZRkxSQUpUQ1lzZUJKZUFwQ2k1YXUxZ1ZtSXAzcUlUa1BUd0hGSGE0MzJuODJ4ZWhvQUtTZWlEcnZIRnNLbXlTeGhYS0dWV1NlbnZIUUtyUk9aSm5tUmttT1ZPNUlXV0QrbGxJaXB5MjMzTThnYjl2MGVRc0NPcmxyK3VpS2JRMG80Nm12MVRjenBJUXFtQXM2bDZKa28yNFl0cGFhcVZpdlpGcG0wYTVhMVFROXd3RitJM2dNZEpsWmxEaVhsQUROdnZCMytuSU5ZSVpZVFZTVWM4WDB5N3pQRytRblJEMDdPaDhEK0VNT3J6c1UvaU1rRk5YOGw0cWpBbDBFRjdLUFR0ME14aG9wSjVtQWlDK0pKMmhVVitGK0VJNTN3ZWhuNHByT05mcVZIWlJteVBwbnlyNXViNXM5MFJ3UlRVbGJBVGZhOUZwai96QmtLTlpISHR5S0lyMFBOekw5U01mcnQ3MXlUZ245RnpUS25LK2F1K25ITS9VeWdmVGM3M2YvMWRqRnJ5Znl0Y2xwVmI0WFdrdHdyM2MrNHJmVXlUbmdUeGRiYS90Z0pTT1h2ZFpUVTRwMnVrelRPeURRK1dEdG5Ub2lIMVB1SzBWSnhXNW5xTGV3amhvckZLNm1mQnZtNDJZaWtONFBVYkZFUGc5WnVHZzhuV0lSMWJEWVZUdW5iUWhBaCtsZ1pGNGw2bC8yWmMrQmFuaU4rSW44b3hvU25vK0NFRTIwLzdGWjNYOU5PcTF3S1VSeDFHWnpET0lmQzZPNUw0Sk1tM1NpRU9sVHdsZlZHVGt6amlkamkva3ZZUjFlQzdKck1neUhJTlNpR3Y0UEoyc1NOdkl1MWRMNzNnZmFFUlM0MUdpazlJL0dwcTBMVHBsbnNFZHkrV3NrUTV0MnB6UmFBMTBzcXFza0oyeEtBc2RBVGgxL2tuM0U4djgzQUJTR1N1Mk8vVXhNenFvR084ZXZLWE91R28wVXhnRFJSWWpwZWVjTjhEMFh6ZjhkOUthaUUrcE55RlBIcU1ySVdPYW9PU0JsSzVmQnhkSGh5Q1ZWMGZOY1BSbmpaNXJmeGk5TmtLV0J3ZWhxVGdGSDBEUGErTWxib2w2cUZoUE52SGIvbjdpNTRTWHZBL1VOWEh0MUZFME9vTndYWThoNS82YThybEc3MnFVcjlJbFhYZlZRZkc4SkZrSm1WYW52aUJrUUd1elVmWlFKN1M0WndnVDUwazExVzJNREk5cDZvdnIwc2VEb1JVSGtNcTFQbWZIVWZqYzZuckpmYVM5c1ZhdDBuUE9QK2VFZTBOcFVKb3ZtUU9kUDcydmVCZnZQWkR2aVRJZHowTkhQa2ZlbzdGZlNxTVV2Mmg3ZklmSzUzdGxpZ2pLTDRkM1JQdUNadm9vbkJlYU10TVA1RDdxWE5aTktTZnZZTFlLbnAweHV2STU1VnQrNTVsU25YY2FiOXg3eW1mSUhsRWVXeDB3MlNlV2tJcHJuV2hqVzlZeVpoK3I1eVhRYXVValV1Q3F5QUUxdXNTK2RpSnoyOUpCKzFqdWozMUp0WmxGcHdCNE5qZDBhVndLTGhEWlFQZWdHdkdMc2RibXdFSExtS1UrL24vc3ZjbXZiZGQ1Si9ZN3plMGVIeDk3VWhSRmliSkVseTIzc3N1eEV5TWJDUXdVa0dvSDhTU0RHcnkvb1BCcThvWVBkMGdFd1p0bWRwRkphcEJCRUZRU0lKV0I0UjNFU1ZVcVZhWEdza1ZKRmtteEU4a252dmJlYysvcE12aSszMXEvOWUyMTl6bm5rbks1bExlQWkzdk8yWHV2dmRxditYM040aUlhQTJWSzRVclpnekh4VCtXM2EzQnJzaHZqcU1nL0RUUCsvaFVzMWU2bmNHSEkvK1ppeUlVL04vZm5mdHZid3pNSy96YnNuTmpuQVB4TDVQU0pqR0lkdzlJek00cTVVOXh3eDhWM2wyMkFHVldQWUdjYXZ3ZmdvOFBydHpoUTU1NDZXS044NE0vOFEzL3VCVGNTQW5aZThRcG1JUDd1Rm1lNDBydnZMVmowTWN1MTdxMTRFc0NMczVQak8vRThYcFRFN1JSbUdEK0RqYytoUDBzUHZDL0M1dVg3TUVQeis4Z3BtbE1SZy84b1JsNkg4dS84ZlJ6WG44S015bC93OTFCUVBZRE4zMWVSRi9GOVpNSHlLd0JtczVQamR3RThPenM1L2toU2dMTk5Zd0RmOVBwZWhrVnEzNEZGMjc0RzRKUFp5ZkVuOHNneVBFOGk4QUNXOXZ6dDJjbnhBc0JUczVQakw4SG04dzdNRUgwSWMyclFhR3FlZmN4SXdiZTgzVThBK0FHQVA0ZXRxYThqRytGWnJzS013bThCK04rUlFhcWF0L1BqTWxDMkZJeWlZcnhUZlJRUVcwbFpzNmtPTXJJQjBHM29uVlM0Kzd3OEUyZ0RXVE5Sb0s0SSs5WDNWY0FsaldKVXdFdmZtK3BEWnRnVU5wUWVSNEc0dDdqUWtyelFBekN1SUh1MTNiRXVaNlpWUmFueTJ4STVwZWlxNTc0b3ZBSmI5RTNYRE5zWjM3OUpHZXJwSzQxSENlQkNYZzk5cVlTM1daZDlrYlJMR044dTBpYjd2YlZvMnFRb1lDQ2lKd0pRb1JBczBINXFsTDBLckJwTnR5MXRJQkF5OWZXaXFjNGczeGxkTllGSFB3TkZxaXF1VTY0Zk5SWjFTblA3amJOdEFXMHZmRCtReDBHRi9nZklhZFE3YXd2aW9keEllcmcybjBGSW9abkdNUnBKNDFvZ09BOGdSMEhLR28vbnJXaDd0U1JRd3UvbkdXRk1ZY01VTnpVQVJKV3hGQzJHTGlDc1NvbUNNbW9VaUdEQ1dPcnBMUlhnZ1gwYWhkL1VDQkhIUkowcjFZTzhSak5WMkZjQVE5dFpVelkyRlNybVN5Q2xJbGJBYzQxc3pCMjM5WlRFcXNoRjRDMTZHTE52dGVnNXJqdCtWaS9WZlpUOVUzNUV4NHNMMHFWR29saVJ3V29xY3l0a1pUZXVKVTNucFlieWxJcTBDZWU1K24xMDZMaUFPY0xRK0VEUWRJSk1tL1RjU0Iwem50ZXIvUWJ5SE0yRGNzbTJVNW5uOFJWbnlNQTBJNlQwZnFXaHZLNkt0KzRST3RUeSthM1NXRHIvVFE1NjNqWTZ5MUJaVHZUTDcxRkhwSGoyYjRvaTR2Z0lMK1YxQmRGWVA4ZWJZUE1LWmFhRW1zTUJwSTJSL2gwaG5QT0dIR2xNNDhlQnYzdS9OVWNxVGNlcE1oYjVJZ3NCVloxM3dFR1FHcytXdGRCbndLRFRTUjgvcHplOE9sT3VVWSsrb1dNVDEyMGZVSm5TVWxmcVdLUFVjMGJ5Ris4dlFMcHRlQ1dCMURZN0NZM2xXcHJmNW5ZM0ZaeFVVOUN3WUlDcXlyTTFzSDVENlhNZzVEczdSdURLZmV5TGduMUZuOW95T3FvNmh1eGJiYzQyNkRzNmgwQ3BpeEFnSTlERk5kTXAwazZsZVZxdmpwWFNLWDdYUGtiOVNIbC9kZjBFSTRqU09pQ012OTk3SVBlcjBVZWZWU2NUNWY5eFBFbVRhbjNkbHAvcm1oekxmbzlySVBHYnhqSjVWUG01OEU1dEw5Y1VzNUdROXRXQWIrMUhBaHFiN095bWZJWHpFb0hVS2NTaE5OQXhqaTk1KzExWXNBaWtidjVYWjE3VlJTaHZyUnAzOHBQM2F4MXpxVU96VnF6Z29IRmJHdXAxZnBtU21lMk1OSVNwS2ZrODY2RFJtdzVVTk9yQ24yUEthNDdEQk1ielNTK1p6cG1HTjNWR3BRTXZTMGZQcmhYeWN4bUhRNi83ekw5VC85Sm4xS21Bd0RibjhoVDV1TE1hYlVxUjFiSS8xVm1QYTAxQmNaWXF6ZXFoYnd3RTR0NG82TGpzbndsNVMyVy9LRCtQamk5UlAxOUQ5S1pLRzJzT3NmRmRmWFFoNlowaUIvTytHdjdNOWlVOXB1ZWR5N2JpRUM1MFhZM0FVU2RSV2pacGNwYVJiZlZ6NGtxa3A1RWZrdjZvRTZtdVU4VlZJMjJxNmFYczJ5YThQaGJGT3BSdWtuNWR0SnNkZWtoamxSYnV4TS9sbmhGTVZvL0hPTldDbElaMHpoR3lMcFN5V3ZYeGM5bUh5czhqTDlYM2NKN0c0ZmYwbk9JTGJUYVV4M3A2aTZ3RjFxdi9ZL1IrNS8zSVBMekd2Mk9ka2RiSE5tN0VnNlZkY1o4d2F3WDVvMkp3WjYwZEE5Q2hLNzUvK2U0NHo2cHI4cmhRcnVIb2tMTkExZ3VpZnE1NmE2MGZCZVlvdXFrNnYvRjNPdnp5UFZ5RFF6cEZtc01ldWpyeE5peUN2RHhHenJvMWsvMlQ2dVY3NWQ1Q2QrUjF3UVM1LzdoWEtTY2tqRURhV0pNM3lkODRWd2w3a0xvVmIxK2hsTDAyRmg5SGRlS2ZBSmhPWVlMVVEzYkFEV1VxeUhKeFBPVXZmUVlXYlVvRDZoN002SGNYbHI3NURHWncvRFlzVXZnWkdGakpsRjlQKy9kMFpxOUhuTjczdHIzb2Jma3VNcVArTXN4UU9SWWo5ZEtOcjlkZ0JzY2ZvejhLbUNEZk5aankvc2piOGdBV2pjekJLWjUzWSt1Wkc0SlpucFBQMzVUUEgzdmZ2Z296WXY1cE5OYUtZWldiYXgrbDhiZXYvQkxLYUFWdDQ5cU5vMnVZb2ZIYzd6Mkh6UmxnZ1Bvci9uOE9tMittZng0RGVFSlNZei90OTdEUHE5bko4Vm1QWTBCS2wrZjNmd0tiKzVkaHd0NHZ3NHpTVC9pNGZBcUxEUDRRK2Z6bys3RFUybzlnZ3V3WEFIek1TT0RaeWZHKy8vNHlnTjlEQ1JBeU11S3FqK1BhNjluMzFOZVJ3TC9pOVl3Qi9ESE04UDhRV1puNDFOLzFGR3crYTRYejhBakFQL2Q2S2JEVEllS0hzR2p4T0ZhdmUxKy9nNUtvTEM4WlNmNy9tN0tENFdRbzh1SG45azR2dmZmM0NjRUMrdFFFckRWTUVhR2dIb1dSS2ppbEpRaUQxVFlJSTlQMFFVa0lkV1lZQlN2ZVErUDFYSVcyYmVZZ01IZ0NMUWs4M1hVZW0rM08zdU85VEdjOFpCeFZCV2VFaXFHMFQwZ0pJR0t0NkhrNFcvZXp5VjZYS3RoZktocEU2cXl1b1NnMDlKVXdCbFNhTDlxdWtLL1BWTmVJcjhYN2JrQWdlRE5DTjhzRTVaUmQ5eWxCRksyRCswZ042alFjVEpFQmViWkhvd29waU5GZzBadUdSZFlFUVpxemdiYlRBNTl0cGl4MEtuWE5FRUJ2WGdQd1VQYWpHbmtJbEN1NFFxVjV4TDZpTk5RVXNpQUJFcFNBY0tSUGtUWkZrRE1wRDJKNEtlU3ZOaHY2bUU2ZW53a0NVRGFkeU85UkdTTW94ZjV4SEZqVWEzZHd2MWI2cGNCQ1BDY0w4am10cjdiTTZzQXhVdzlXamkzclg4aG5qWXBJeGhzQnF0SitDa0N2enJlZUw2eG5OQ1dIQnRMUkpoc2Zhd0RZRWtoZXVoRkFtL2sxamtrNjRrTDZyWi9aQm8zaWpFQ1dubit6aDY3bk50ZW9uaStyWjZ0eC9XaUt4cFIyTUFBWnF2Zk0yNUluY3Y5R1QyeU9QWjFTVnJDSThuTlp4NXdMam1tTVhLZWlsNEFRR1NOZGMwTVJnenpUQ2NoMGl1L2tQTkdUbkhPbmU0T2ZMK1I3VEpYWEthSXNMMUE2N0xCOXl6YW5wZFE5UUMvcXBFeDd2MGMrZHF3bmdXQXlObXI4MTZ3TUZ3SkdYd2lZeUhvZy9hV3lUdmxqMHQ2NCtXaEFZVjgxM1N3SU9vYVRHc0FlbnRITUJqUmthOXJ0SVVNUWdkVmVucWNBV3Z3ZFBTbXFRMy9JejVVbXpTSGdTT1d4YVZzNSs2ekpXVDNVaUY0RElOUDdMaUYzSzdDN1J0NzNIVENwN2FZMlZSNld2bk1NdDJrTFFabzQ1MXFhN0dpajd5eG90b0Q5MWVmbGZjcUwwdjV3bzBRUlhVN2dkcE9NV1Zrdm5UR1ZheEVicXVrMEhlTkNBQVlWbkl6QVBPbHpkSkJXZnE3M1I1QjRHM2xhUVR2ZVQ0T0QwaHFDZUh4R0hRYVQvaTV0VXFBVUtKM0xsTSt5dm1UazRCeVIzd1RkTGRFVVgwdEpSZ2ozY1Y0bzF6S0ZmeTgvbDdicDNLVGlzanozQXAzMWVJNDYzNjFSbjNUSzBOVFIyaTVHdUhLUHBneFU4czVVVDVPTjBPTW1HLzhlZVA5STk5VnBxOGJQT1NmUmVRS3dPVTBwN3RHZFA5WXpFWEFkY3M4aERQZU14aFk2SWtXNnh2Y3VVRVpwa24rcGM4OU0ybndBdzd2bS9zNFVyQ0xqU3JubUNGbW5abkFJeDBMNVliWDQyT3kxWmdUbVhsUjVRN09INkhQcVJMVldQYSt4ekVVMVExSGhjTzdyUXAyMk5MT0tuakZlNHlQUjJFMkhPZDdUb1ZrRE5INE0wOU03R2QyQ3JxS1pLM2d1c2pwSzhMMjFzb0t0Njh2dzgySTlieXJDLzlRNVk2anZuVFhTNUl4M0hWNkdrazhrMm5BSi9WeDFzbHE3QUtRSWVUbzdjQnpVZGdHVWpwRzhQbGk4VG8xczc1U21USG11WlJIdTZjTUNhblFJS1BtNTBrMGFnTWpQNDdpVFZtcldoazNqdmhFL2xQYlYrRGxwNHR4bER6VmdzVjI2Ny9SOUJmYWxZMEE1UWVXM0xkc0lmNDQvNjNwVTNocnhpc1FyMm56K3IvNnVNb1U2ZU9qdjJyOENaNjNKa2ZxYjZMV0ZrNnUwRjhqcmxwa3V1TDRPVUpmcGsyNGtiYXpwNXpGb2c0Vk9VaXJyS1kva0dGQ3ZWNW1oYisxUlRsNzRPT3U2cDc2cFI5bjAwWUMwSm1weWJac041clg5b25pdXluNkEwWEU2Q0JGUFVrUDN0TTNCVXJXeURPL2k4MHBITkdNSytRUmxGNVZEMDFqSVBxQjhvRmpLMEhHWFJhbklsUWVqMmNueFYyQ0Qvd0NsUU1PelllRXZmdzVtUUxzQzRMZjg5K0pnWVpqaDY1NWYvNVovLytqdytxMHpJSjFWeTlTTjlHVFRpQUV1VmtaUVhnUHc2MzdQdi9LNkR3NnYzenAxZ3lVdCtWTUErNGZYYjFXTmRyT1Q0NnQrNzFkZ2hyMzdYdWVGditQQjRmVmJ2WXF4dit0RzMzVXZURU1EMkliOFp3QStxWnhickl2Nk5RRC81WVo2QWR2d1J3RCs2NW9oZG5aeWZBMW0ySHdTTm84ZndjYjRHZVNJMUplUkkyQy9MWTl6OFYyREdYOWZRVTdUL1E3TXNQdWdacUNjblJ6L0VZRGZnTTNmaDdENWVkcmZPNEVaVkpjd28rNGp2MzRLaXd4L3k2czVSSTVDL2lJc092ZGZIRjYvTmZmMThpdklCdnMvOHMvUHdZeTNjMy9teU92NEFNQzcvcDczZ0NKVjl2TUEvakZLSU9JdWJJMCtncTJGZDN6Y1hnYnczdUgxVzlVekl6Vk50WnhGVFdEd0NNQ1hZQWJnTDFjZXZ3RHdaN0QwM3lzQXA0K052Ny9ZSlFBZnZkZlJBNW9FQlY5Qm4rajFXWDFtaDNaMkRBa0Q5eFlHa1V1K0wvYnRLbkttaUU3S2pkb3pBMjJyampmYnZRT3dsd0NFcHVJbHF1M1pwVzZwdjVaNnNYWnYwYWUrUG00U0J0cDZsTlBuVWtSWUpRaTJEK3ZmRkpZZVU5UEI3QVA5cWJGRXNhT0FTbm1CUXR0Rkk1NzhPNEMxYkJNRi9XU1U4SGN5VXBCZ0NnRkFDb2RBRndBOUYwR3RkLzc5T2xPaGNlNVBCK2dDRFFOczcyd0laTzZwZzIxV01GWGZSeUdlL2FKZ1RsbEdJMTZBTWcyUkFsZFVDcWlBeHhRMUJFcXBSSEJNT2M5Y00veXJlaTdMR3FMc3gzWXpUVjZxTzlDV21BS1A3WTFHNHpGS2owMCtyOFl4SFNjQW5iU0FVUm1NaXNZNjFMT1c1MGh2V0JpOU0wSjJndUQ2NXp2My9MNGt3NUlPQk9XaEEyUzFjbmE2MXpmMXV1alFzeGYzcUNoWUcxUGJ5VjdudUM2VmRyVTVvbEdqZE9oVWtTSmZHbytnaDh5WmdqQUN2QldHR0prVEJlUjB2WEE5cTBjdDcxSFFVK2RQenlVRURDeGkrM2pHRDd6ZGo3d2RqTEptMjJkQzQ5UVFyQ0EwVUhvSVI5QXpnU2dWUGpSR3BtVUt6cThxYTVYdllkL2pXY3NiTTV2SU9tVDBPRk12cysxTUU1NHlJYlJpekcvSzg1T0JVaUhtR013cit6TE5SUjl0YkhPa05BdDF0VVhnSWZ2STBkTkE1ajhFOFpmb2tYVjhMbE02VWdlN3EveEE5Z1FqMEdta0xsTDV5MzJkZnN2MW9ld3gxYklEcjR6OFhOT0o2NXlSUHdQZFl5RllGNTBnQ0dwR3A4ZE8zM2Rvbys2SENDQWxQaTA4SGlocFBxU09uV1JaMHN0YUh6YTFkNWM1aytjVndFTDRYek9hTHNQOTBiaFhjMVRVT2pWRlhpSHpvK1RUNU9kUlA0bkFHK1EzUGVleW9JRk8wNVNmRjg0RmJUMnlpWFZITURJYVNka1d6WVNnWTZhR05IMFBaVGIyaS8zVTZIN1NJSFd3WXhuQmVNV3A4SFBTZEdaN1NMSlhVMFpVSnJsZTFuWE5JYldRNzBXSFNkR0pVWThSWHJCVkpGeWJ6NzIvVUJtanllZk5jaXpvZE1SK01KcG0yZVRqUGRJZWJYS0t5ckh3ODJnSTUvaHc3SGxOK2JrYWhDTElIdGNna09kWnN3bFJ6cVFNUG9HZmFTdS9Kd2VySmpzclRWRWVoVUQra1F6eWZrMzFEblZZZ2Y0bWZaNGdCM1E4OFAvSm9VL25VTjVEeDg0NDN0dWVMNXFpK2l1NjBhSDMrNUhjVHhsZ0lXdVY5TGVQbjhmMXk3bGQ5TFZSWk1ab0NDNWtBSmtqWGsrOEN4dG92ZlFGUUhhQzhNODFmazQrb1BMUEtPemh6dmowMVBQejR1ZUpGZ1ZlQ0FnL2Frc0RkalV5dVMyZG1TSnQ1eHE3REQvbi9tQTlTZWFTL1FWa3AwdDF4RmJIWU1vc08vRlowWmVCbmpXcWZVSXB5Mnc4K3EybkR1VkJoU3lEY2l5NDF0azJoTzk4SnRhblBHZ3BZNmt5c1JyVTAyL0l0QVRvT2lwekg2KzBEdTlYa1JsTTZsNERYV2M1a1RXMXI5cFB5UGNxZmhYb3U0NEphVmdmL1MvMHFWQTQ1am9QS2dlTmhMWlNQaTZ3d2o2OU5ORDN2bXd0bXJtQ1o0eFBZVFltNHJVMWZzNXJXem42UUhDUGluNU9mcTdaOFFCeHVHcEtiQS9zRDlzUzlmNUtHNHA1a1RXNnJqM1Q5NXdYMGk5MUdGN0tNK3p2dklkZnJLUzkxTnU1UmlqajZUN2dHa3Z6R2ZuNXdMZ1RpMEM4TjhqbGhleDlXZDBoMUg5MUNqL25WeXRIQnVISE1JUGVOVmlxM1dkaHhyd2pxZmUrZCtRSVpuajdCbXpRZmhkbTRQd2ZlSFl2ZkhBOWF2VTU1QWpRVTJURit4REFxOGlwVkdqb2ZRR2VablIyY253SU0yb2UrRHNmSWtRSWVYVHcwZzJBajd4UDMwWFhBM01NNEpuWnlmRlBCOUpmMXdoRExLb29IQUQ0cndEOHo3T1Q0d2N3NCtRK3pEQzZoQWx3cndENFIxdlVDK1R4bnM1T2poZVZkcDdCRExaamVNcE81RTM2Q2l5cW1vTFZNOGlHOCtlOWIrZkkwY0RQd3NieUtaaEIrWHV3K1NrV25FY3ovNjc4OURKeSt1cUZ0K2s5NUlqcGxiK1A3YVNEd1JJWk1Qc2FMREtjYlQ5RUZwYmg5Zk1kcjNwZFRJUDVvdjk5Q1diZy9nREFaSFp5dklhTi9SOGpDM1FYc0hYekE1Z2htV2Z4UHZMM2JmS1NUK1B2VWNwclg5TVU5c2tJbUhZN1B2ZXJzTDN3ZmVUNWVsdytwN0t0c0huWitvVHhySlhRQTNWaTM1VFJGSjNTZDUzMTZ2c2JpUkxvQVc4QWxPbWZhK01oekxWb3c5QzRCVUdHVFBuUzQxeDVGNVhKSTVpaGJOWGV1SGxmbGFoTjh4b1U0YjU5VmZWdURYVW9zRGdJaW9qU01vS05mUzhZSFVvaDlQZXRXNitmWitxc0drdHIwbGt6YkxmWDAzbS9ySlc5TnArVHZLdXhIOGhnU1FKdWFuWDVPaVg0UGtYT0txRjE5UlYxUGhzalo3WFF0YWZ0Nnp2SE9CWjZxcWFvV0FyUUx2U3BwN3dLL2ZTa2owclBoZTdORGU5V2IwQUZoSWFpZnFwT1NEdVVCQmI2ZDFXMENNcndQeFU0UnYzVzlsRk0veFhYNGNUM0t5UEE0N3FvblZuSnVsUXBwVmNwMnhtQmJScHhtSkZERmRkNGxxVDJZNDNTa0tHQU1SV2FRM2lrdFlLUWJZaUVsbmFyQWt1bEhTZzkyZlU1dmxjVlk1MmpqakxxNytmeEU2dXc1aTRpSHdnS2Q2TDFyYVh5VTBVdnRkZS9MMkZSalB0Tk9NZGE3bEZsS05IY0duamNsTkVjYXV6Ujk5ZFN2YkZ3Yng4aXAxcldzNnFVenUxN2U2S0NSTjFEUVlzNDcxelhkUFFZeWJNUlNHQzdxWjl3alhHODUzQ2pzSTRQQklodkRkQm5wREpRR3NmWWI4ZzF0b2xHbmtWalJucU96YVF0UGQ5NXJNNFFxTS94b1BkMUI1amNKTHVFK3dpRWtLYlJNRUt2OVhGNzQrWVR5RmtNR0VWVTBBLzVUdHFrNjFpTklDbnFGaEtKNTZESnBNa09FUkZJUzJDdDFFVlBlZ0lzSEw4eC9EekhwaElSSWp5YjYyVHMvV1FFMXJpOWNmTWlBUEM4dG9aNWxUTmlQUElCNm13SFBuNThwenF0akdDcHA5bTJQbkNzaUlvTlBKM3JzZ0FYZXZnNTI5MHhzbXdvVVI1Ulo1OWFoT3UyL0Z4QnVRN05oTXh4b0pIUlVRZlkzZmlyUEtRanE5ZktaWUNiU3FtQlhwd1RwU0hLYTNTTU9qSm5qeDRCWk1laHRPOUMvMkkwL0RnOHErMVRtUzcyZ2UxV2d6T3ZKV2VVY0kzWEovSmRqY3A4ejBUcVNESkptNk5RSW8xVEdZSDBGbkt2anEvS0FZeXNvMkZaMTFoUkFsOU1SaGIvUDQveklRQjJzV1lkRUZZampkSkhQZ2NnbjZ0WktjcnJ3SEVhV0t1TWRLbnhjOHB0cExOTHVjNDF1dWR0bXVzZVpYdWxIZnV3TlJxejZxaXpHSGtZNlQvZndRalpjeGg5WE11em5GZktkVXZrWXhVbXlQU1I0ODFJWFYzckNqSlBmVzJ1WUxJWXIxUHUwREhtTmNvcUN4aXQ0L3RIenM4UDJ6THQ2c3ova2pHM1V1aUljK2IvNS9IZWJmbTUzNnRHY01vMUsrU3hIYmMzYmw0RDhLQzVuVEtGUllPWlJsRHBmSEZNRkZkSk9obGt2RnB4Q3ZDZk9NZHh6eFoxTlRuS1ZkY0haYW1xVTVYMHZUaDMzZmZaeFBzOEQydUJCb1VWY2dhbFlsMTdJVDluRUZUcW43Y2w2ZGR0VHJ1K0NaTWhQNGM4VC9rMFlWVHNVM2c4OG9mNCs1Qk9xM3lHejZUMVdzSExKbTBsa3JxbjNob2ZWM21SZEYzZlQzcWdQRzVYNDYveXBDcmRyclNyeUlCMHlSTHhGZjZQL0J6b1lvNkYvQksrRi9zTHdndFZqOUk1aVR5aUxRMnpjYjdWT1R6eUVKVW5JMFphRzY4YTM5WjNBWmtlSi94dWc3eVZ4a1V3QUYwaldtb3lGZmxXVFNlTDl3S09MVlYwcU00YXJNd2hmQStUTnZGNjRpSGVEdExBNlFBZnFQSHphdHIvSUlla2RTUDhuSTRXM0c4TGVTN3BVNjV6MXpJQTZUcWhyanhFMDNRczByeTdUcWZPTmJ4M0pmOFZwK0VZanFWT2pndm5LVHFLczcrVUVTbUxyY083NHRva2ZWUDhKR0VGTGc4eTZ3Ym5oSkhBUTJOQjN0VnA3MlZLNVQyUHBqQUQ3MTNZSXZzeUxFWHZxWGZxVlpoQmJZd015ajhYS3JrR00rSytCek9xMFZoNUh3Ym92d3JnTHoxU2NoL0F3ZXprR0xCMHdmczA5dmw1clBETzN2WFBWSHozWWNZK0lCT0FYNGNaTTkveXRuOWxkbkw4ZnlDbmRyNEFNUGF6Z1RWa0d2NitFVXlRK1pxMzlXTlVDTG5mMXpsd2VZdHlBSXZ1L1JIc3JOMnZ3TWIzaDk2Zkp5NVI1dzFZU3VyL0RqbHQ4UngyOXU1REdCT2tzWHNOR3djcUl6K0R6YytUL3F6MmkxRUxGR3F1K0I4TnJ2dXprK01mSVN2c0k1aHhYOHZjMzNFWFp1ajlxZmY3STVoUitjRGIrQk5ZbE81U2pLWlB3NHkzZTM2ZDVSVEFYM2hmWGdydjI0YzVJOFR5SElEL0hHVkt0UW55ZUo4am4wdjlLU3h5V2FNcjltRHJvVGY5UnpUQWgrOWpId2NhczlRQXZJU053U2YrZDRiUExqdzhMcUhzQXVKc1dhSWdsWDV2dXlubEFBeDdkVzFUQWdCUUdDeGpuUlVoVGhYWlF1Z1c0SlNsS3JScnZXU09Lc2owQ2RhdUtORlQrTkV1L1JjQkVNaU1jdkQ1eWppcjRxaGVkZ21BcnpIUzBGY2FMQk9nVVJrYkJhaDBycVpTM3ladmVocmRrb0lXNTdMTm5tS2sxWnZxWENNSTlpTGNjSzVKdy9mOFd2U0VtNkJNSFZjN1Y0eE9SRVB0WWNwYUlQTnYxa2REeUZBS2JZS0JVWEVjRWpJSDk1N3ZqUXRrTC8yNEZrWW96L2VjSThzMFZXV28zWEF1b3hTZTAxV0E3MjAyYm4zZWRBdklVYll4VlMyTjBXdmsvbzU5N210cGdWUVI3WXVpV3NQQmtzYk85dDFHK2RiSVhWVzhrMmNsOHBoUmtDZmdza1ladVpIMmRvVitLc0RIZDlDSXJHZW0xb3lSVkdTWGJkZTRpTXI3a2tJaWJXVDl2QTdZUG8zUnp6WGxsS1VYRU9JZURXMUxvS2RmSndCRnNFcU5BdlQwWmFUTG9zM2V4Mm9VNHQ1TmFYdmx0NzRTb3d1b01HbzZKSUoxQ3N6UzRXSU41TFN1QkJ2MUJhTGdqNEdVQXBMOVVnV1dSdHNKdXVjYmtkYVNWaW9vd0hZdm1xNjNNejJHK2Y3b0FNUng3OUF3VWNEVmdFeWpBSlZ3eXFYOFBKUCtrNDdGdmFnRzBCVFowSmpST0htcWM3eFJNZjc2Yzh6R05FS1pXcm0zU04vWi9zS1JKTW9xOGk3eVhSb1JLTHNYZ0YrYkhhS0FERXdySHhvRDZRdy9uck9zamo4TGxGSCtuSGZsK1FTN09XLzdZaWdnWDkySHJRbDEwcGtpTzFEVHNWWHBDV2t0eDJnRUZCN3lXdGcrUmtPU1JxU29BSlEwZlFxanZ5dGs0Ny91ZXhwU1lnUUlRYVlDUks4VThneDFaQ0pQNVZoVlpXWGg1eHRUSzFmNGVjMlJxTGlYKzc5V3IxeGJ5cjBLbXNiN3Q1WGQxVkNSL3JmWkdQUzVGNDRqdWtaZXJsdTJTM21QR3U0N29IOEF2bG1xY3ZTV0FIN1VMN1RPRHJndU1qZmxCOTZyRVVVZC90cGs1eTdTaDdrL1grUGZ4WGV2VDg4WmowWmRqVmdFM0FqbzE2N0lmZVFOWXhoWWVDanYwOHdxdGJZazBESzByNCtmQTZLSHRUbjZmQVNnQXloN1B4UC9WcDJsSWs4WGFjS0gxaTlwaUxlQkFEQ2pubEtmblM1cU5LTWVQYkNOczNGMFRnTXlUUVV5SFVwUm82SC8xSmw0VGRjK2FXWE5XWGNsKzJ5RUVOblhTcVFRNndzOGpjNlBhcFRTT3JtR1JqQ01TL1VHbmlQTWZwQlc3VFZsdEszcUtKcVJoRHppdkVmUHZZb3M2ejNjaHA5TC8rakVMdGZnZHdBQUlBQkpSRUZVbEg1bnY2VHZjWnpVU1ZQbGV1NGJ5Z2dxeDhRNW9XNHlRbllJVTNsbmhSQ0JCZVAvU29kVWoxa2d5NkJSL2xDZ1hmVUV0amZxZmlwTHBiYjJnUFhrM1R3T2dHdGhJbnVUaGpPZ1RQdXJzbmJpWjAwMlZFZmVPOGpqMkZhUk80bzVKSThaME0vMTNQQkJ2dURYQmlNaTQ3MXQ1YmdFS1J4enluMTc0VjdWYXdibGgxRFVDWmZscjVPZlJ6NmwwYnFBcjcyMmRNVHI4SFA1SDhlRCswUFRzZy95YzFrZk5kN04zNGdYY0x3MVlsSXhsa0huUkg2V1M3clhhakpLOGJ6S2xsR0drN1ZhMnhNZCtjRC9OQ0phbjlYK0s4OGNsSitIOXBKZkwvZzV5blhNYkZnVFpBZnV0QzVxK0ZqNGJWdCtUZ2V0bGVOL3lzOHZVTTRoYWRVMldVT284eFRwN29Nc3pyWXphNFhxOFFCU2l1NmFmajVGZHJiVnZxWjFML1hWTUp5cTN1TFBNZTE5V3VOTmlaY0NPVk5mZEJSbUFLdjJZNEhBSTNTOXR0bG9uZkRodHVkb0dPYy81T2REUjhyVityVWV3NHh6cjhFTW9WOEc4UHN3bys5THNFaEZSa3Vld3d5S0g4SU1hTzhnZXlWZjhUcWVsL3IvTmV5czAyc3c0OXVyQUg3SDc3bUNmQzRGQ3dmd0FzQlBEcS9mZWdkbTNKM0JqR2FNVUZYQ2Z3bzdWL1YxZjgvTC9oc1ZjQ3JKZmVVWmFUUFAwZ1ZncVgzbCsyY2gvb3hPL2JKLy83cC9qb2IwYmNzUmdMOExvSUZGNEg0VDJSTlJ2YVAyWVNtVFgvTFBML2g3UnpDajdJOWhSbThGRHpSQ0M3Q0YrNHEvNis4RCtBZXc4NGkvQVROb3M2eThydThDK0RjQS9rY0Fmd0xnVFZnRWNRdUx0djByZi9kTWpLWUw1TFNZSDhLTXJ3RE1zSHA0L2RZaW5xVWNTaC94K1VNQXYrM3Rmd2EyVmgvQ1VwTi95L3ZLdFVud2g0ckVOa0p4cHh4ZXY3VTh2SDVyNW4vM0FQeGJBUDhUekJCK0YyYk1mdFAvM2tNNURvL0wzN0RTNXFnQkZjS3F4a1lGcFVWQjdBUHlOeGJXNTMrOTY3OEdobnVoa0IydjBSRkhvNXc2eFlVUktsRTBudXIxdm1jVEtMa0xNd3BsQnR1djk1c3RVcEtSc1F0ekw4NVdDZ0pzYngzK1VjRm1NdStpaUFJVGhUVFNZUUpaMVRGU1poL0hTUHNpNnlnWnd6WUJNMVFLMmM0MnAydWR3b1V2RWZoby9EcHNiOXpjRDBCZ1ZOaW96QU9XSGVJcG1PT09QbGRiRnl2VU15cm8yUFgycHlZMFZ3QytuWW9BekgzN1JqK3JVbjZPbkw2WmMwSVFLbnJxMWtyTnVNZzUzbzgzK3hxNE1yRFhxa1dldXdLa2xIK2NjL1dZVEFCWCtJeHduYUNMRmhYRVk5bGFYcEs1WmR2NC9tUjRRVGJZcWN4QThFVDMzN1M5Y1hQUzN1Z0ErQXBLNno0bmpWN0NBTE5aYy91Tmk4YlM4KzYxT2YyUmdpTUZZT1IvY1g2b3VKSjJSaHJHT3RRSW85L1YrSjBVdlFGYW41dzJBcDlTVUFySTZRalhjcDBSSlRTR1RtRDA0QXF5VEI3bnZqUHZtMmk5S05KSmVmTzUyaWZZMDdqVFFKZzN5dnJub3B6dTkrd0owaTA2SVNrSW9jNExYQStjSTY1L0JSVUplSEx2cC9XbTgrSHZvNExJTlZ5c0NWY0lLWjlmSUVUMSs3eXEwVEhSZWFGVnJEOTZXUk8wMHJGS1lLMlBQWG5aMUEwVTVGOEw0UmQ5L0tybVVKQ0swNXBwK0I3WEMyV09JMGdrYTNoRzl6ajN0ZW8xR21taEFOUGExNDN1MFFzWXJZNWd3Y3JISlFKNmRGampNd3VVdElYamNBRGJHL3JiQ0s1RE5MZmZlTkRjZnVPKzA1QmxjL3VOVTY5ejNONjRlYlcxNkdjRks1VjNkS0ptWE82Ym9UekgvQXF5UTlnZXNyekQrbFIyMmNUUEZkQ3V5aTFoVFJDSTZuT0lWbENtVS9wQXh5MzQrU0N3Tm5UUGtHemljNlJ5UUs5YzFsT2l3dzdweXFSbkwxMWFkbkZhU1RwWjVia1ZYa29lRXNlbVQrNktBUExPcFFJNktnK0t0RmlCeW81T0JlZG5GWDYram5WNFVkNjVkbDdDVEFuVE5xZVVYc1BsOXlaSDBYRC9FSVNORGcyOHRvZWNLVXo1OUJxMk4vZzg5eUNmNHg1YnlqeW1kUHh4dlhDUFZ2aTU2cUpGOUpub2krcDhSbWNZdHFGUEw5MUpWNVAyc3YvazUwZVJuOHRqcEw5ek9NOTBPV3V2c2wrNGh1bHdRbjVPdmtDZGhuT3F4bDVkOCtwOFJGcEwyamxHbCsvRjg3STdOTTJ2TDVBamJHY1Yyc0wzemRHTjhOWkkxc2pQdFI1MTd0RU1FR01ZTDkyVC8xT3VkYjl0MGtOcjRud1VKZkx2Tmp0bjZQY2xzbHorcUtjT3pkekIvbEZXaVJrdnVEWkh5UHBLS2s2anllUFZJSlRxRG1QSTlxdXpiU3hybUN3NURiL0IxK1BZMXk5NSthb3hoem82L3gyNUxCVWpDK041bUxFZmtaOHJueWJkU3J4WWZ0ZWpCaUt1clpnRnY2dURXVzhSV2FDdlhJYWZiOE0vdHVIbnRhTE9UVG9lbElQVTBZT1pka2czTjdXck5tOGRPcXlsSXV0dVZhZzdBbFZubkRXeTRVZjdTTDdFN3l3MWZxNi9SWDN0c3JpY3JqdmxpNFdkSk1wVWdyOVZkUXp0WjBVVzROd3VxYXMwT2JLeWMzWjJvTE1qa1I5aS94VTNpR09wdkZQSGtIdU1mOXV1cTBSSGcxNjRsbXRBZG5ibjlaWDNtZm9NTTE4Y3R2bTRHajBPUWN1dStybktVM1NpcDM3T2RWcUw0S2NNc2lUZDcrSG42WDZmazJubEhxVmhLa05UbmdGS3VVLzVlYUxGUS94OFlCd29MMWFQK2hNOXZCUHgzK1RzRFpFdW8rLzNwb3ZwRTI5UFIwWHRvSWNNNHFnVjJUSjluOEtNZ2svQkdQbGRsTXJkRlpnUjl3NkFyOElNWnUvQW9ubWVoWjF6K29yZnV3Y3pNckxRc0hyUGYzL2R2ODhBM0ZQRGwwZlpBcjZwNUJvOXB1NGpDNjZNZEwwS002SzlDNHVtbk1LaVRqVVM0SnEvdnhiOXkzTTlUcVhQVjd4K0ZxYjIzV2lFNkNudm81SSsrWE1vTkNhZndRenRtcTRJc0g3OUNvQmZEcy90dzBEN2oyR2I1eDNZT0QzbjM3L3ZkYzFnNC9zc2JHekhNTU0xWUliZnQyQUdaS1lrSkxFOEFuQjJlUDJXamlGbUo4ZmZoU2xITTc5bk1qczVUbWRnZVhzbS9yNlpQRWRCL1FoZEVCSXdSNFR2ZVB1L2dUSTErUjN2M3oyWWM4S25zTlRRSDNxN240U3QzVmRnQUE2ZEcrQjkveWsrWTNTdXIrUHZ6MDZPMzBRWmliQUVVbnJ5eCtXdm9kUU1TWnRLUlFEVGErbE1pWXBSN3QvN3ZEYjlucjFVWGxuNlBOQVhOV0VGeUFidTF0TmNoT2VXRU1jZXIyUGExNTRJN3ZCKzlIZ3doemFzYTNYMGZONldobXNrMWprcXRKc0NxSDlkSTRNUmFzRHFYUU5ick1NeE1paE5SWG1KRFA1VXo0cld1aWxJdHpsYUV2RDBWUElzdmNlQjBqTXZBY0grRzczU1ZRQW1iejVvUE5VcDN5dlBQWUtuMXF5c0gzcTU5eXJNM25hbXlGU2xyK09wSzZBSXg2eGpkRzV6TkRYQnVqV0FvOVlpRmRUQXpUcld5RWRSUUs0cHIrWGFYbFFFMmxoNEpocjVKY0V0ZXRCcVd5ZklxVUpqSDY2Z0p4cFBycE0zSDhIbWdhbHRxYVJwZWplZ1ZPZ2d2NUZlUkM5cmhPK3FTRjJHL3NWNmRLMVI5bFBEbVRwYjZMeXBNa1N2K2FTY1NQMDZIaEgwWTZRa2hmR0NEZ1h3RTBDS3NDbkFNbVRsVlZPWHhYVFNXcXJBYkkxZVZQaVpHanFVUm5BTTZiaWdSazZsRjVwYUtiVWRsYm1NWTlYZXVEbXRLVTM4M2Z1TE5xZmxJMDFKUm4zeUZIK1U5U2VRMXI5cmhOc1YzN2RxaE9GY3FSTFA5TVo5NThhUnp2TTY2K1Blb215dGM3UFhXaHBBUmpUdWhXZjRucVhNeFVVWTM4SXhnR3VudHFmOUhlZitPWTR6eno0citoVDRINTlQZTdRcHZZOFZnSTMxcDdPbVlNNElOSEtjZTFzWVNUV1NPaGc1c29BbzVqQVA1VDVkaU9jM0tpMWtpcXo0aklMSVJVU0Q5RG1OUFVwSGxsb2Y1ekNGZXk1ekZLTXkwanFUc2FXc2s2SUZXem1UV3VwUFlCRXlMV05iRHJ3ZVRRbEpNSUFHcWpWeTFKQ3VSWUtUZkZRajVuV2ZGbnNlZVh6cGtLU2dZa0dUQWorL2dNM251WTYzZ0tDc3J5cTN5VHFMUmxjRk5ua3Y5elBiVVpYZkF2OUtheUhRWXBVOWxMOUFuazJ5NUE1NlFxeGYxMjRCTEFvSTJpZTdiSEx1WWZ0SVU0dEk1c3F6NC9DZlpiRC9QZDh2VTRZQVY2RGVYd1g1dUNiaStpUTltN1JsbEJqSGZsV3J1OGtaTGRJOWNwbHJUZDlGdWtvWlFmbkdFb1lYTUMzaHd1ZUNrUjVqbE91N2FuVGpXbXR5MUlmcU0ycDBxL0Z6YlZPbmlPNnFmQTYxK3l1NlJEWDljOXdiL3AxNk1HblRGS1ozRUt4VzhGT2p0UW1ra2laZWFXL2NQSlYyS3ovWERCb3paTG9KR1lzMC80MmR4d3RrbVRVWllRTVA1am9qUDlkendsWEc3L1JkK1lzODA4a21WTk5oL2Y2SC9qbU9zMmEvaUhQSDUxZXRIVldqYTB2ZlF4Nk50cHVTK1F4Wk4rSVpqL3N3M2x6b0lhMGNiZVJyWW83c0FMUkdUNFl2Nzk4UVAwOUdCcllET1VxNGo1OXIxZ3AxdG8xMXNUNk9VM1RTVVo1ZThEdTJxNVZvSzY3RjBCNmxFNUhPY3N6MDdOOWtwQ0UvRi9rL1pocGdsQnZicDdKNnpmaW43eWJOVWd4aXlMaWI2R3ZjMS81Um81R0xJamdOTTQ2by9ObVJzWVJHOEo0KzNaVThyZGlieUhvZyswVmNSUGt0d3VjMDcxdnlkQjByN3Yva21ORFQxbzY4MDRaejJDdjlMQndxbk82a0xDWW9aZDV0OUdxT1Y1OHVIbm54WllyeVRKMmZOT2VCMXFrT1ZyU3RsZVBwOUFVQlA2bnFNaXlpVTlZQ0JEYnA1OFY0Q0ZhbStublU1WXY2c051NjRyTTFHVlA1NFJBL0oxMVNKODgrL1R5T1J6WDljNlN6UVhZK2hPQXFiWTY4aGJ5VDlKanQxelY3NkRxbnRxWEFINVFQcVB3amhmUEI3RnBKRjJOLzJtNm1BSTZOcHFydTBQQUtQOTlLQmhyUVgyZTFlcEJwc3RLUVdyM0ZzUitCSHRPcHRKTzkwcC9UdnRJNUxoNmIwWEdHYlc2L3NaN0NESjcwOXI4SDRDOWhCdDZudktIM1lRTERKOGhwaDErQkdYZ0pvdEdncUFiZzN3VHdmM3M5QkloZjhIcmVEZjNuaEJYbjJ4NWV2N1djblJ5LzYyMWpHODlob0taNnpOK0RHZFJXQUZaaVVPNHp2aklpOXVzd3crRjdNSVBmUzdPVDQyOURKc3VqZ0orczFNSHlFR1l3ak9VT0RIaDl5OXYrcm8vRGo1SFBBUDZEZ1hxM0tUOUFIaGVOVnZoMUFQOVp6ek5qbUJGNDdPM2grTnlCR1lBL2hSbFVuNElaUkQrR0VZT3J5SUxsMksvOXpOOUg0OENyQUg0Mk96bW1nS25SdTU4Z0crTkpHRlI0UFlkRkszOWxkbkw4TTM4ZkZiQnpsSjZHNzNvNzMwUUdZRDZHUlZyUC9UMS82dTNqM0N3QXZDM3Z2dkRuWG9BWmdKbGlnVzE1Qm1aZzNxcHd6ZFdNdXU1RVFLRncvdGp3KzlkZmRtRFVXei9YbEliQStFeXZ3VkVVM0tvaGo3L3RDRVp0Vlp4SnhKUm52ZmQrRHErOENvc1NQVzNFVUNpQU54azUrenFCUmROb0JGTktlU1J0RzNTcUVWQyttdko1b0tUTUVSVkRSeEpjWkd6NkZKT3R4MDdybFhwWUY0R1NDd3dZZy9ycUZsQzdBQlI4SGVoNVhaTTJHM0pvMENhUDVWRVI5MUFDTDNPRWFEYk9hNXRUN2lURGw2ejdKMUJHY0tablEvODRCc2tBZ1h5V1Jpd3FHUGVOeGJydG5wVTBsK2RVMFZUaGx2TkJBelBiTmdKeXV1MHQ5c3NaakY4VEZEbEg1anM4YzNZRVB5b0RtWjlUbUI0aHl6NFRGMUtqb1ZzakdoVkFyeHJGa1FFNElOTXNOUUt2d24rZ29nakpmLzYrYTFHQW1NOUg3L2o0L3RxNjU3TVJ4SW4zYUJ2N2FNbVNiV2d0VldBZlNLNTdTb0doQk5DSmtqbDFRVjVUREVaUWFqVkVzd2dndERkdXhpaG5GZ0l0akp6a21hUXN0WFVBNUlnSjBoMTZvVS9iZkFZUGVaT21KTll4MWxTMWV1NlhwcnBmQ1VDc2M2UEdXd1dDd1ArTkdWS1pXajQ2TDZnUklJNDc5emtOcjJ0NUQvY002MU53U3ZmL0JUSnRZRXBnT3NLdzc0ejZRV3RSMUdNWWplRDd3YmEyWmFxbklzdEdLeW1iL1gvVndVVEdRNEd3bWhGNWlBZDJBQzU1cnFha3o1RHBEeFZYNmdZejVCU0xDbkJ5VE9qVU9ZSTdzZmdhTzBNSkVDUkFxYzNHRlk1ZEVWWFZ4LythbkthUS9hT1NUbWNIUnFyTllPbGJkUzJ3S0I5WU5iZmZPSlAzTVJXc3B0NmkwOUlhUnRQSlQxa1hVRWFBYVJRaXBGMkZBY0lMYVRqVGZ3Sm11T2Jhb0VQUmlPUG1ZemhHZHY1S1J5MEZmbGdGdFlTZks3Q3JhUWlCMHBsaEtzOUY0RnhCWXBWSGFrWDNuVHFqYlN6UzFtajRMdFo1ZThub0hSWXhBZ0VvSEhzaTJNUTFsTDd6dWdCWVBLNmxLbk9pNURYcC9UMU5pMkJkb3RQeTNpai9LejlEZU9heWVrQ2M1MDA2UjZSRGFWMVcrcW95UUpTMysrcG41T0lZNXJBWDYxTG5QQnAyT1IvSmVDeUdvalhNY0VrYzVSeGxWQi9idFVMbGVCQ2hYNHhjbVRRNXJXczBPQUZpSEhTYXo5SjNGbUFoR3lpOWpEcUg4S0lPZUN4OXJxNEpwN04wRXF4bGsrR1k4bjh5b1BrWTg1NTRscW1DNG5xKzRscms0WFJrZ01ncTZodzRRbmZzYVd3azMyWFdFeG9zRC94dkFUbW1xODNaTXhocHFPbkdpUVhRS0U0NlhPdzM3cisrdmV2ak1VTUp3RCtzckoydHN0VDFyRG5sNTN1dzlYUFEzcmc1SXkveDliVXYvU2MvNTVFYTUxNkhwcmpVOUpkMHFrMXlXcUE5ZEFCZXcrU0E2QXhYNjBzNno5cnJqVWNVVFlBVUNicVMzM1F0RkhRbzhGN05xTUZDM2dua28xR2lmcVJ6V1dSc2EwTm1FOVVWblg3UVFLRDlaTnBkTlVDcW95V044bm9NeThMdlVabTVVNFEzcHZhaTFNOTFmS0gzS2c4V0dzWDI2ZjZ1MFY4MVdQWEttbTAyZmlQY3IvUkVkZjMwZTF0bWVOaTVOS1VUYkR5N052THpoUG0wcGVFczZTMXR6M0ZCMHJkQzM5MENwK3IwUytoM0hGZWw1WjhWeDlQbngrRnpaMDRyYTB6cjJVV202UEFqTGR6M3JSaHVlNTR0OUhPaEY5WDY5RjU1dnRnekcvUnpsZEZxYzVEU2lwTlh0UGtZTWFBL0F5bC9YNkUwZ282MTNmNWJWYmIxUFpMa0hGK2p4VHIxZmFBTzhrVWZ3dmpwbWw4MTJkR08xM1J0cUR3ZStaTHlocFgwUTdIRVFvYVZza0RPYkVaOVpSOVp6NS9BajZtQUhIWFVab2ZhaEJkSUthTFNaVTJyenBuay9MNzE3R041ampKSXFEcS9BM3VpVDBjcW52TTJYVVBtdVdmU2Z1cmllcjQwcGpBbDlWc3dBOW9VWnB6a3BQNEZ6TUM1Z2huZzNrT09HbjdDTy9LK1h6dEZqa3hsb1lIek5WaDA4UnpBSG8yQ3M1UGpLVXlKbnFIZk1IYnFIWGtHbG43NHd0dnp3T3NrUUo0R1NlbzVtNTBjVDJZbngyTTNEdE5RTjRZWmZuL2I3M3ZSdno4Rk80UDJlWmd4OHRUZjg0OHE3V0twR1g4QlMzZjhOc3p3ZWVEM3ZZbWNkdm5jMy9lckEzVnZLci9wLys4Z2U2VCtIc3B6WjJQaFFud0NHVEQ3RkJZdEN4aklQNGNacmgvQUJMWG52US9QdzRnQ3o3RDludi8rS214ZXJzTEdsTUw1eDI0TVh2dDk1N0FJNFRUUFBoL2N2S2V3eU9XSnQrTnRBSGNQcjk5YXVRSDEvNEd0bHp0Ky9hZiszQlhZMmNvUFlVWnhPamJ3ck1mdis3czFkZVRTKzdDQWJScUNkWXdRZmhVN0dJQ3hnVm41ZXg1SC9mNEhXS0t5ckdXVElMTUp1SXFNQlVqUk5JUEd2bDFBR1dkMHE4Q3N0amFLUnVIQzZ4azB3RXFob0RBTll6RUNVb3JwUFJnQVN6Qjlyelh3ZklXYzVtVFUzcmo1UUJXMjBNWUVWSWhTU2lNRTB6ZngzdDQ1Y1lHc0dQcytoZFRIbFFxeEtvMkY4VmpmMTRxblcyeURLSWVyTnA4cnVOR3dTSVkrMEtlRkFEeGFhSFFnWFZRandnUW1CQUg1SENjS2VuZVFBZm1Zcm90S0hNSHhKZHdBSW9KSVlkUnRzemZ4dUxWelJtaUlWZVU2S3EyeHFCRStHdXUwZlJjeW54UUFxVGpxR0tXMFk5dy95QW81RlZBQ1JzVlo0QnZXMWhreVdMSkdtWEdFL1JnaHB4bWtjWWY3Z2NKanpVREF1ZFpvN2JrQ1BSVkFpQ2xzT1FZc0NUanJXZjhxMUUvaU03WCsxMHFiUFcwVktGYWpNOGZqSWdBOVJUdmxjOGZ6dXNtR0RwYW9sUFhObDU2dnRkZWFFYmhtQ05jOUhzY3FnU215QjBmeVdRRlQ4b0ZOdEhVYTFuRU4yR2NFWVRRY1ZzOTY5VHFXYlpraFFQdEpFQ3J1Uiswejl4S2Q2M1I5TXFVVDl5YU56UXJxMEpOMWhVd1hHSFdpaXFpZTNhenlZM0xlMGZ1RnZuQWY4NyttK2tWb0wrY2lPZDVJUFhvUDMwUGF5SFpwK2tHT3l4d296amFLeHpERWNlOHpHQnpDMWprQjBIUFo0N1V6RFl2aXluRmhERVRYV05jcFRZNm9vVEsrRDZkamJZNUdaR1lGS3B4clpDZWlLVXkycHFGazMrdGp4R3dCVEh1ZE5Dem9IdWZlNFc4OGd6S2RWeVo5bVhrNzU5NythWnZQVHlRSVFtRDFDT0owZzlJZ3RBREFLTzZZWHZ6STI2eXBMWlBPMDVqUm1NNUQ1MDFQTkt2MEQraktGTG92T0NiazBYUjY0TnJrL0N0SUF4amRxUUZEZE1iZ2UvV2RwSUVhQ2E5N2pQUTVaZDVxelhndzlyYXhIMnhEUEtjelJiRld4aUdCMDBNOEZTaG9xL1piNjRMWHMyenJzdEJHcDhLZTk4OERNRjdMRnNGMW5IaGRUeHVxK29YVUFRZ3ZxYldYc24xYlQrMFplVmZmKy9TZVhad245YmtPQU52WGxvcDhrWURYRFFCNi9MeU4zTUY3eUoraUk2SWFxWW1QcUFGQ1V4TnlUK3pMZldjb0hRbVRJOVZBbS9ZYU8zWWl6VmZVSDRBVWhSbWRqbXRwR1ZuSGtER0UrNVBmby9HZytLeDZpM3hYd3p6M05la25uZW1qMFpHMEpwNGxDR1NuUitYak9yZmFGL0paT3VuUnlZcTZCV1VNdHBlNmxVWm1rczZ6Nkh1NU5tZ0laYUFCRGNhVVpWWlMxejZNYjdHdEVlanQweU1QZkR6bzdIWGhOUDRRYm5Tc1BTZlBSMzdPVk1YYjhIT09QV201NnRCalpEME95R2NOTHBDTnZ1Zkl4dDZESG40K2d2SDZoVHlyNitTZ3RiTWJrd09xOC9NMHRrSmZ6N3kvMUUyWTZscjVPV2tqNVViT2pUcGNVdTlSb3paZyswd2RzRGlYbFAzbUxtOVJ6dW1WcDZXa2RhNTdWZnBIM2gzM21tYldBTHJycDQrZjY3TTFmczR4U1BkempOdlNzTk14SmptOVdNbDF6Y3JEL3pXYVU5Uzd3V0FTYVRIbFNNcGJ1ci9WQ0IxcFJBd3UyS1lvelVMY2V6SjJOWDZPOFA0aGc0N0tlYjF0RFBSRjUyOElGMHB6VjlGOVA4dlJiRkdtVUFPcDd2WEk3eE1kMzZiTlcvNnUxOEYzeTE3VU1SNjE1aXk5QW9xVTFHdVU2M3drLzFXL2pYTE1wdkZUcDB3QUhhZEtPbkN3VFRxbVEvdzhPZDVVeG1BRTQ0SDZHeUJHVitrWDE2MGFXcFB1NEwvUlNTcnBFcm8zQSswQzZ2eWNCbVRscStvMGtJcmdPbXlQcHNKSHZGL0dKTzdQZmIxWDhFaldSV083SHBlYU1uNkVlZHJ6KzluZWlBOVVpL09HSmR0R1hNWDczNHROaHJGUVo3SEZOalFzWUhWMDBPYjhjSHpweURWcmI5eGMwd0Q4SWN5WVJzSkc0KzdieUl4NkJqT09MbUdHc1NkZ3dnRVYreU9Zd2JobTBMem1md0J3TVRzNWZnWm1kSDBTWm1UOEFKdlBYVDBGOE9jQVBuV0RJQ05wUHZWMnYrenRpNFY5MHJLRVJZZWVJYWNyWllycVgvUFBsejJqbCtYQzJ6Ynp2Ky9Bb3FrcEFGM0F6b2g5RFdZVS9xRmYrdzBZK1B1bk1NSGtKWmd4Y3NoUS9IY3UyVVp1dUN1dytTRTRjdzhaNEdicXdCSE1LSHdPNEk1SFo3K0Y3Q241a3RkekZSWlZld3FMR3J1THZLWmVBUERCN09SNExsR3hGS3llOHI2L0REUE1mZ3pnZ29aN24vUHZ3UndCMW40UGllSEgvcDZQWU91WTQwdmpOa0gzTlEyd25vTDZTZGdZUCtWdHZ3c1R1cThCK01MczVIaXk0ZnhoZUYwa0lxdlp5ZkZLM2pFS1p4MWZsdkUrTHAreFZJREJiWjloSWNNZU5MYkYwaVBVclpFOWpEUWFSaU15MHZ2QzQyVG12ZlgvSElvS3ZSdExXeHFNWitnYUE2aDhxcGNaUGVDb1ZFNlFVN292VVVrVkxFb0xGUlI2ZVJFUVRaNi9mWUFaMjZ2WGdoQkFReWNCWksyTCs3NklIRUJsbjh0YW9wRmdSTUZFUUowRVpOZmFPclNHdHhBT2t0ZGJVRlpVR09QOHFnRnVDZVBSRCtGQXZOZDFGdlpIOGE3V3ZONmVSRDd6VXM4MFpocTNQWlNwVjhjdzRmbWlGWS9XcG96azRscUloZVBlTVhKVzJyZUdnZm4wcGdheUVOaFpCMDAyb01QZnNXd3NhZ3pBVms0ZUV5Q2Z1VG5VTm5RQmRpcGRDcUtUWmxRak9admJiendNUmdFQ0xocXBGUXVCTkk2N2pxTWFlTFY5YW93QkJwU1hnYUtLQ3Y5SUV6amZGd0xjSDZGMERPQitTZ0JZejN3VXlvZlFud1RzeEliSkdJN2x0NlJVeG42MDJWak1kdldOeFVTdXAvVDRRc2NTZUZwcFUxV3AxSFlncnhtMlJWT05WOVBJOTlHV0FCWXBlSjdtUitwWnR6azE0UjVNYWRSb3h3aFdxUktXM2s5YWlJckMzV1pqQ01lUTc2S2g5a0xuUHlpOWFyemtPN2d2RWhCS0lFejR0SjRqcGJTU2ZaLzUzTzFMUGR4cmFrQlFSVDhxNkRFS1JDTm1DMi92OER5TEt1MjlwYzFwSGFjdVgxQWhqUXE1OHJZRDJOZ3krcFFHRGdWYno1RFBaTlN4V2lNRHJNd0FRcHFSd09JQTRuTHVhZFF1SW14WWg4enpDQ2dpV1BhY3RuUC9xdk9JanQvYzI2YmU0Z3EycHZ0Sjc5c2MyY1hyYTZtVC9UeEZ6dXh3MUZwazFWbWtTMjJPRGxvMlprZ2tuWjRQOFFuaFgzU2VnL1JWQWJPYVF3TnBONEZ6QWpkMEZLckpxNW9Xa3hGM2ZDZlhlWFRpaVFCYitoLzRlWXk0MGxKTm9kb3pKZ3FVRnNDZTFFVkFSU1AwNEczWVZTL1k2UDNQOThwbnBUM3E5SlBBM1o2K0pRQ0k4aWZiTVFRVzZucHZ1aEYyMnBiME9jaDBPL1B6OEh4YWErRmRSWVNIM0p2QUt5QkgyZlQway9jbndMN054cXcrT1VmcFBVdU5uM01zU0N0MUxla2FUandjMldESUk3U0FiQmdldHprVFJsRmtMcW9PQ0lGL3NZM2s1eXVaNTIzUGk5TStGbEZQdFRhb1RJWHVuaXFNdkU1eldVYnllNVFoWWovcExFUURhOHFpUWRDNXNsNjR0am51bXNXR2RXaEVWSnJmdU1iOXZ4cGFaNjA1b2g0aEg4TkNHWU5yWWd3VVIrcHdmSGhrRE85bFB3b0h2VUN2ZEc1WnFEdHZ3ODhKN1BLc3pBaFdKMzdlWkFkUk9wQlI5aVhtd0xHbXdWc3piN0F0S1FXMGYxYyt4S3dncEsvay94eERUUU1NK2F4N05zN1ZmcHV6bHFXbzNZQ2YwTkdJNnlnZG5jQjJvYVMxOFFnY2ZXODBQT3BSRndjd2VlSzh3cys1TnVpTWxwekR0K0RuNUwvY0F4eWJvZi84WEtRMmI4b0k2Qm8vNXpXbGhYcU1oNDRabnkvMERzV3BtdXdZeUdkcnRKZlhOem9JYy8wS2xxTXlGdWRVWlJjYXB0TDRiQ3MzQUNVLzM0S0dSbDRRNTJRYmZxNFI0c3JQaDU0cHpvcXY2RzdhaGo1K3ZyUHh0OExQdVJjMDZJN1paRlNQMGZIZ1hHMGxZd25OSm8zc1MyR3NzdDRJMldrWUNBNE82STZGeWoreDZHK2FkVUt4am8zajJNUHZsUTdwZmtucnVVK3VxLzBleGp4bHdXRDdtaTZ1ZVNIUHhQRklSemtKVFVyOFNXVlFhWDl0SENmSU9wenk1YUVvOXloZjBOR09RUmU5c25iWUU5VHhrN3psNzJSMGY4U1dsUGNtZVViV2lnWi9LQTNzT0diSTl3N2RwWHkwNWY2amJqMlhQdFRtbmJSWE0xZHd2Q0xldm5ENW1Ecm5Ib0F4QitRRGxONGNMOE9NbFFxUWpXRUd1ZVhzNUppQThBakczTDhJRTVTWTRsZTk1R1A1T3ZKNXNtZXc2T05ITUdHbkZ0MUZBT0Fjd0V5amUySEN5Wk13QTk1dnprNk96MkRSU1V6WlRFQWtNU1IvL21KMmN2d3RXRVR6czdESTRpZjhscythbHBubEQ1R2pUNThCOE1QRDY3Zk9aeWZIUnpEajl6MXY2MytMTWtYSm44T01xZjhKTElxWVJ2b3psR2ZjZmg3bFBzeG9lZzR6N2k2QVRocmo5ZXprK0s3Zk80YWxkVlpDenVqdkY1SFBIanoxdnEzOE53clQxMkR6ZVRvN09iNEdpL2I5RVV4b3BxRjdBVFBhbnFKYnVMNFcvbDR1OW5QWStOdzd2SDVyTVRzNXB2QjlCV2E4cUJVU0ZRSkJRRDRmNVFWWWl1N0QyY254NmFhb1hUZG1qd0NNK3U0TlkvYTRmTVl5Qkg3VWlnaXRXOWNiNnQ5SmNOcXhwTHJaem9HK1ZSa0NTMDFBckFGc080N2ZHZ0lZYjNPL2pDR2RTcXJ2YjNPRWlJTEhOQXFtS0ZnNExZOUNpUDlYZ3lYM3RTb3hSWW45RG1CWlZCNlM4aWZQc205ekFZRVNrRmFwWDhGcDNzZDNhVHZKNnhMWUg0VG1QWmd5Zk5IMFJFSVBsVFpIUnRON25yU2JkRnZUT2pFQ1NnM3YwWU41YVAzdzJRbXl0L2dTNWZtQkJQNEpsS1MrZTBtR0dSbjN2bjV2SzF5bDBwU1I3QjFQM3pEK1NSQnVKSlc1dEsxYUhCUTRoQ2tuZThpUnYwT0dTanBWcVFGUEk5T0d6dEprbTdpR0ZMRFhhTGZVVDJRaHQxRFNnNkRQdGtYd24vdHRDTWdmS2xHQjRIaXdMVXRrcjBVQ1R6b255UkM5Z2FiU0hXazRBQUFnQUVsRVFWUlJLR2ZVbktiaFhNZTlKZ0FXMTJROFd6SXB1RUdoNzFNcVkxOVRmMVZoNC9VS3VLVDBaMmp2RS96ai9DdE5JVGpKOVhjaDgzd0E4U0J1Y25TcHBtWFR0VEJxUWhwQ29jMEVBOU42b0JMbTl5V25HZ2lZQ3B2RGhYd2ZTUjBFRDNudXI0SytwS2Y3M3RZWnNrR1FVWjEwS3VJYVVBTU1peXJndXIvV3lMU1pad3JYbEw0SW5IR2U5S3hwQmNRWkRjWFB0ZjJ6Nys4NGJXNm43QkNGTTFTYm8xaTJjWDVaeXZ6d25MNit3c2huamdHYTIyK2NDbmpJOWpCTHdibU1FL3VWRkhLVVRsN3dhelN1azVid1hickhhNEJ4T3JPK01hTy9PdkJRMFFWS1paanJST1dGQy9sT0hVdlhuZW9IcklNUnpUVWdSQjFtK1Q2Q0dWTUhBUWhZSnVlM05rZEg3UUxTTVowdCt6SkdPTnNjZGZBNDBkZ0FFQTN4RksyUElQc2E3cHlEdkxlcG85S2d2aEFhRW9FY25lZk8rM2JsNTFJdjBBWEphL0xVR2pzWW1iMk9oSWUwK1l6bW9hTDBYdGM5K3orSmRMUldwRitGa2IydFpHd1FXYk1BeitSYTJtY0J5Q3FjbHk0Ny9tMTVoaVgvazk3QzJ3MTA5N1IrSHRmNkZrcVN1NVZmdGpkdUxpTm9MRFNQWTYvNlAva0IrMERqVUpUWnB5ajNGR21OR2lwV01EN0wrYVVNWEJpbEJRam1tYlZEc2t1azlZbWU2bGdUWUJSNm10cTZTVi8wZTZwN1VXU1BTQ3U0ZGpUekFQbjVucmVKL0ZMYkRTQkZ6WkZPc0Q0RlkwazNtVzU0Qk1QcExwQXp1bkV1NHhFTFVRZU9PamJuc3U4NERGMFRuR2NhcGxNYXpRby9UNDZvcVBOV0hpbHk3dnljeDFQRVBjcXoxcmZoNTVScERsREh6Vmc2UEtBeFo5RTA1aUsva1FlU2w2aEJsL05JV3EvZy9hVE56bGRhRDVBZEpHbzBXdGZodkRXbk8zWGsxbU9NSXIybUk5bXFMYlAwMEdHTjd5SjkwM21KOWFsekdsRHlwMFNET2VadG1iYWZQSEhpZXZRU3UvRXhQczk5cTA2RVNuZTA4TGNpY3RVL0QvRnpyajJPTGV1SzJjdWkwYXR2emdxOW8xSlNSTnkyeGV1c1BpTjhtTHd6eVdDN3ZFZnFXVHZQMk1TTGt3NnB2Nmx1dUdNL0MyTmpEZnNqYnhEZEpLNkRORDhWblVUMyttWDV1ZjYwUm5jZGNEOUV3OWNJOVRVN1ZEcG5CTGMzYnE1aXYxdHhwQ0ZPVWVGOThOOGozcUh0cTVWQ1IyOXpkaU5BZEphKzhkd3cvNFhNS3pSdWhYeDBETWRjOWNVcFN2MWNIYTlVSGt4NDU0QmN5M2xaaFhzVk13SktmajZGMFRYcTdKRW1NTzJ5SHErZ3FhQnAxQVRFQ2FUTjJTblZ5WlM4dEppZmdmRm1Kb2crNXhPVm16aldtbUdpNWloRDdJZTh1UnFVZzh3WDZlakY0eWwwclJKZjZaTTFZdUZlcWdZbUREeUQ1dlliOThKN0Mrekk2VDFwL21RME96biswdUgxVysveW9kbko4UjZBeHIvZWdhVjRmaExaeVBhelNncmZLN0Qwd0VzQWZ3dkFiMkhZQ014eUJqUEMvZ3VZNExJR1NnT2t0MmNGWUsxR3RObko4V3N3US9KZFdPcHBHcFVaQmZ3V0xPWHl2Y1BydDZxTHd1dStDak5ldnVRL2Z4N1J2L2NBL0hQWStGMW9uMllueDFjQi9DNXlDdXYzM0RETVRUNEY4Rjk0Zis3QWpLR1EvbTFiM2dYd3BmRGJtYi96WmRpWS9nQTJUcDhDV09rNllKbWRITzhkWHI4MTk4L0o2OUtObmw5QUZnNWZnWTNkUTVoREFVRXFycHVmSUcvb0NXeE4vU0ZzdlJDYzQ5OGo1RlRNQndEK3pNZUxhVEhUV3BBMnJVS2E3Ni9CRE1vRVBybjUvMThZUU1oTmNBWG1RUENFLzg0STR0K0NuV0Y5NnUvYm1YaytMaisvRWdEeHJaK0pvSHBGMk5ySm03b0NLbDJxOUFnNGx3SmhmaDdsODJ5UENHbU12bG5DOWpicEg0MlBOQUJIRHl3Rmh6dUtqb0RCNm0zWFVhWTVkeEdBYnNwemdSSzR2Nm52RkVUOWEwZFJHbG9uYlU0blBXL3l1WW9qbEVJOUFkOVZjemtEOEJQSVkwNUE3R01FNEZrRUZucVU4ZDRSdGpBeXRQbk14bzdnRERPQUxzSzlJNkE0WDVTOGNJU1FZcXRuejZZSTIrMUhZN2dJUUU4aE9BR0RHNTVMSUNFRlV4aFFraUlDbWh6eFJyN0VOS29wWWdTbE1VRUJBZXd5OXc3STgzbDFVdEJ6U3JtM1Z2SUhsRjZpQkN2VmM1NkFCWldSUVRyWTV0UnFvNlo3eGpmQklqM0hVa0dvQlhLRUhmdWovZW9UME9PN2dheTBwRFhUNWhUWXZFZWpOeU5JRkJYTVdyUUZpM3IyeHNpamRiaXY2c1FnYXpHdEM5MHJHOEJkTlhwcXVuclNYWFh5Vk5EZ1ZOb2NsWHZPVFRScTdzbTdWcWg0K3d0dG9ZTEZNZGVvNkFRU0k4OHh3VVlDbkRRSUE3WlBkSHlZOFNVQjBVMTUvcndhT29DU1RuR09sbUtvaXhGc1FKZGVxcU5SVXBDYmJKeGtKTzlGbTUxZUtMc3VaRjhWNlJ3NS9odld0aG9UTnZKbm5hdHRhTnBBSFpydW1hbTNhRkJWT3FacmpPT29HUTNVS0RPR1I4VDZlelRhRy9KL0w4eXBHcHpWTVNEU0xVYllWSTEzd25jcGkwU2FvZlBHZEsrUXZuSS9ITXA5bEczWU42YUhVd0Q5b2luUFV4N2s4Zkk4NlNCcGVLS0xRWjdVL2FYRzlvMFJPVzArbDFqVGNDZWEwTVBQaXhTZUtLTVVvckVqUnJRa2NHK29YYnNXMmZkYkczMXJPZ095VVNRNVMvbTEydDdsR3RJNTB2VythL1J4Qk44QUZCRUp5ck5WRGxGNWVJaUdKVEI3aTNXaGRHNFpmbytPQ1drdlN0c2pBS3MwZURENldJSE9NQTVydVI0ZFN0U0lwR3RaTTFvQTZKd3ZyczVqM0FlYU1hV1FyYVRPZVdWY09POUhjdjhzQU5sRHRENFo2OEw3U2Z2VVFTL1J6QTB5Q3NjaDBneWR0MTdkcjgzcGdwVnYwL0JHNXl1K1ExTU1UK1JhNFZTQzdCQzhSdFlEMC9FS1RabUJwNkFYQWJCUDBkbGhiYVEreXhqVitEbkhsdXVja1pwSHNQa2xQMmY3Q3gwbjh1OXRjSXR0MWtIbGZzb1hsOWFCMmh5eHl2Nk13eTBxQy9PZFFONVBwRDJNdmlYdG16YzVhcGY2dlRyQmNGM29NVTJVVjlWSmtHVWg0OHR4NytXWFFiOVgyWlZ6eTc2bHROVUlPbnViamVJSWJkS2pKMVNIV01iZmgyUXQwWG5YOGdma2ZWM2o1Mm93WWRrR3ArQlkwR0ZFWmZ0eG9Ga2RITUovSDh2dm0vZzU5ZGF0SGEyMktXMlo3blZRLzlQMlZmcEJSL01KU3RwZm5Ba3Q5N0pRaGxXOWFDZU1MUEF4c0s1QWk2Qy9hVjlROHRDcUFYZ0hPcEtpd1lOTUYzbHA1T2ZxVEZWZ2N5ajM5Njc4Zk5SMGpYU3hYdVc3TERGQ2VkVjBaVGlXTkdkaEgwVCtTTm05VHo5WG5hT1FxN2JvdDhvTWdHQk8wZzlkZHdrRGtqVVE4WVRPbUFkZHZqY2l1ODFINUdoR0ZXMGI2YXpPTi9rNXMvdEZmazQ5YmlYUHA3MVhvVG5WUFNCdDc1dFA2TE8xT210N3FwVmpFb09zREhTeHlaM3REdGlCbi9zem54bHZEMnVMWTAyK2ZnWmdPa1ZPeThYeVBNd2dSayszT1N4Q2RnNHpiUDVvZG5MOGlhVG1YYzlPam1ld2xMd1hNR1gzSG9DL2paejJ1YTlRQWI0QzRKR2tCVTZkcHZHeFVoNEErQXFBMzZtMGZ3YUx1bjNCTy85SnJZTEQ2N2ZtczVQalJ6QUQ2SkhYK1pUM2U2anRIM2pkYXVSbWRPb1ZBUDhNd0lOZ3lLYkEvaDk1dTQ5Z1kvb25zNVBqOStFUldGN0gvK1hYM3BTKzdNTlNLdTloY3lUd0tTeTk5Tk1venloZXdTSjVYNFF0aHRmOTNvbi9UdU1wejkyY0FYaHBkbklNbUtHQVp4bFBaeWZIOXdCOEV6Ym5QL0l4K2NDZmVZUXNJRTZBZFBidDJ0OUI0WkJFamd2eVNXU1BXZ3AvejhBTTV1L0FvcU5yR3lKRmlzMU9qaWN3WSs0dmUzMHZ3T2FFNVZYdnkvZjkvNzYvZXdsYkJ3Lzg3Lzg4dkg0cjdvM0g1VzlRMlpVNGt2anp1U0Vtc1V1OVc0RHcxWlF0NFJsR0ZLeUNZTGRKVWFTQytabUVhMmVBekp4d1A5YjNlWUZ4SEt2V1BNRU9JTkduTU5wM0p0K0J2TGNwdUZ5QmdhV3p0ajlTT2dxblZIUUtaVno2cEFKVTdQZTYzUnlKb1BlcUI1Nm1wR0ZLdVFoRWtNbXY0RUFRNjVJeDRGeW5xTkJ0QUxwS1VhRjREZU1qVHdQNHFGTFh5b0ZxQmZLM2piS2xvRW52ZndYU2oxbzdCM2ZWV01xbEdqQjFBUGU4NnhHNGVkYWxuZ2tiZ1RZQ0lyWFV2bnZZb0RCNjNUUUNBbHVtUHdlS0NDZCtWeEIwMHBvWEhnMXdYTmRVUUJVVUFiSXlzTy8xRG5uNDF3cmxPRUNVZkZsUDJrN3liQUtjVlB5NFB0RmF0QitWZzYyTlIxRlpEZXUzTUZBMytVeFR0cG5uc0FHbGtYTGVONGRSNkc2NmhsNEN1dkRyYXRoV0FGMk4wVnhuL0QzUkM5M25LSUVsSUVjRTZEM3NXL3ErNWQ3aTJsWWxyTzg1QW5rRXRzNmw3WkQvakQ3ZDAyZmJmTjVyTk9nUWlGMERLY3FIOWZGZFRKbEg0OThhYm5ocGMxVFFTTzZOaW5kY2UwdWdTSmZQT2pSU21QdEl3VWNBT0pmNVVRTUo3MTFXcmpGTmJKeHpqV3FaQy8xaE85bW5BeDhiVlo0WjFjTEMvVWQrY09SMW9iVUlvY0ZVd0ZKWERlQ25FeFY1VEFKSGZaMWR4b0VvS3VJMGdxaXVxT2UzczI5SzY5aHZqaWZCQWZJbUJXR0IwcmpCNS9jQUxFbUwzQmdReDBrQklrMGp5akZKKzFiM25mRGRDMWk2dEN0U1Q2UTFoM3gvbTUyZTVtMU9SYXNSNHhFczVGN2gycDhLcjkyMnFETU0yOWRuUEtOc3FVYkFiYU9UMkNZRnVUaVdlMjJPVnVqajUzU2s2bnNmSTZrMFRYY0VsUXRBUHI1alMvbU10R05ydVNuVzIrU0lDeUR6a0lYc1JjM2VVR0FaWGlnTEZEUjFoL1p3RGxrb0QzSnNWSGJnTlQxM1hJdEdqQlJ6dDROc3FlL1ROaXJJbHM3REV6a2NFTDdBNS96M2FzWWlsUHk4TUtqRjR0Yzc1K1dpSEpzWVlaaGtYRm1IM0ZkcTBGUitSWnEvbHIrMHZ5cGpwWVhYOVN6MWFuOTBES1F1cGFQc2syWnpTZnRWZFpnZWdKVnJSZHV0L1NyMDA2QkxwMndKZm4wcWRTZ2Q1anU0VGxXZm1BdXQ0TDVaSWgrOVE3NmJETW9CcUIyN3JNR28yUFErYjVjNlFhaERIdWQxRHFSVXN1cllTRnAwaUN6SGtVK1BuZFluT1VQR2k3THl2dGM3YXpha21KVjkwYUVMem9jNGxuUFZheTdMejZWdTVXL0tseGd0eEwxQ3VVdlBhcDRnNnd2N1BnYkVsVm1ucGhGUE9naEtwNHNWKzlpWVl4Y05CZEhBa2ZhMThQTmtyS2p4QWwyamJ0eGdVWmtOM202bFYxT2ZYODdGS242V2Q0MUNYVHhpUVEzTW0wcVVNUkpOcWEwYm9WT2pvZnQ2M2dONFZqZVVqa0tGMDBJUERwSGs4aTM0dWNyUXJDUFJxYWFlblc2amZ1NkZzaWJRcGEzVlVwT0xVTXAzNU9lSnhzdWFVa2ZRMnZNN0cyd3FlTjhZUnErckdRd3E2MXMvazU5ekxXekVCSldXRDl5bWZWNDMyVkdSUlRFaTFYRjduYmdHK0xuS05pcEQ4SHF0WFZ6L3FwTW5BNnIwVDNsbkdpY2dSeDNMZXp0eTRoWnpHMlg3d1NKdFVubGE1Y09JUzNLY2F3NTZFVmNrZjRLMFJXa29NYUJpajNrZDBkR3p0alpxN1ZzS3ZiandkMDlSdnBmeWxlcm5LdXVudnBPR1JMbEY2b3VHM2VTZzBVcTZaYTZwSUx0TStBNFpWeDdMeHhMUEJDYmRRaXZwbWZ2S0JuNStCTU95RndBZXhyMjZxMTdRVTFRV3BXeEZQbjRWd0dJS2k5Z0VrSXhuZ0JuSGptREcwT2Y4UVo3NXV3ZmdCMjRFbmdPQXA0WG1lUlgwelBzSXcwYlVCY3o0K0FITThIQUhaaWpjdHVObjZFYnFMbURHT3hwSlg0RUpKRlVEc0xmOVluWnlmQWNXR1R1QkNYb2Z3UHIrRGRobWlQMkl4bDlHanRLUW1nYmVvNHgvSHlZMFBmQzY3aU43RVgvVjI2aG4zbjR3T3puK1g1Q0Y1anV3YU4xREFMOEhBKzIvUERBMmg5NTNwdG9qVVhrQ0ZuSExNb1laY1Q4QjhCMmYveS9ENXVOZFpFSjY3dThjd1l6SGU4aU9BZ1FONy9tNDNVT09FRDVIUlFuMmE1L0FJbXkvaEp6K2UrSC92K3R0dmdzejJCSkFXbFVpY2NjY1V6Y3NmeEhBYjhLTTJ4Ukt0YnpvZGY4YWJCNFlGZjBRN29UZzl5WGpiempMOTNINUcxQXVZZndhZkM0SUNQeU54SkpNb3VQVmpRMUNYMDI0Q2d5TmtaWXJFWWFZaW5lYlVnam9RMlVEVVBZa3loVE1uOG41UWNZdUFRckt6SkhCVVJxVTZIU2kzdUtGcDFxYkl5U25EbkRUMHpnQ1FlcTFxV2xKb3djYUdUR1YxQTVJQW8vU2RHRmttMVI5SFFNeXNpRkF3U0lnQzU4SjhHeTdIdU14d3B4MTdBUmtlcG5EeHBkait4QTVPa3Y3L1l5MzZ3RXljTC9OK2JYYVJucE1MbnlNNmZBemhnc2ZyWjBYR3ZjUDU3Z0FKRG1Qc3A4bUxtRFNhMzBaNnVDN1lwcGF5amdIYlU1dE9tNzZEYXVGUWRkQkhRcVVuVDBTQlRkdkx5TVVFMmpRbHVjYnNZMXFHTDZBclQzS1ZTTmsyV3FyNHVPa1Jwb1ZTc01ZallOcTlLUnl4RDJ4VjduT290R1M4YXkzVlhoT1BlczdxY1NGM2tYbkRMUTNiakx6UjRxa3hFQjZQS0hsTmNWRmpmR0xDazNVUGlUQVNhODViZW1qejBON2trb3FpNzZuVjJFTVJnY0F4WDZvR1VUb3djdTBzdkZjT0kxc1ZVT2QvaDM0dFhOdmd3SVY1QlA4WTlSbk12eEN4ckdSeUE3V0pXMU5FWVB5YnE0YmpRVGxPZUthNmpPbG1VVUdSbmxObFIrdTV3aitjUXdXS0ExMEMxbVRJM2xlZ1hVOVU0bzBrbUNYS3NWOFZ3SUtmZjBrbzJSN0k1M3RwWHhCUGZDWktVQWp2NU9TandEK3lyN25tS3BoZitmaTc3b2k0MEJhd24zQWRhSXB3R0xVcjlLRmd1ZWdYRGZzSDJsNDNFL3FFSlpTdFFyOVVRY0EzcVBLUGNlV0lHTWZzQWJBSEc3YTRJM3Q3N25tNzlwdmM4b3YwbHJTVzBDeVBQaC9uaytzb0tNYW13b2pncnl2bHNaVW8zNmpzcS9QRTdUZ1Q5eGJ1L0J6QXB4ekFkRkpZOGJ3OU5ZNlRsNVNHcmdBcGtSK1RyQ3FaZ0JYRUQwQ0tRU0xsTmIzUnZoR2ViemRFQkhlVTlReFRQZnNtdS93MzZnM2NDK1NkdzIyY1l1aTRHVUM2SVNHUk43THd2WW9iMHlPRmJWMUZnQzI5RnhGSm8xbGpSTGcxYldyWnphU1J3dzV1aWhQTG9yTzU0QnVvK09sQnAyazMwVWVoVHlPU3J2VzRUL3hFZDEzdkxjREVBYmVWRVFvVWM3djRlY0tZRWJuUWo0UFZQYUh2R1BhbWhGNEdkcENHcTFqcERLcU91bXJvMEdxUTlxakRyQnpxVS81T2VkNVFiNFg5Z3YvajFCM09DVjR2WUxoV1NOa0J5VHFGWTk4amZIKzFHZi9qVTZZdkJiM2lrWlJYNFB4VnhxZVZhNmFBSmcwRW8wVjZFdVNHWUxNa3d5TjhodGxFVVpGZC9ZZ01oM2VKVFZrcC9nY2FZYW1sT1lTYmpocXpaaE9HWkQ4S3dIYUtKME5pUE1sK1FrbUx5U1ozL1VtR3BWNUQ5Y0crU1l6SGltZ3IzTkQ1ekFhTjdqbktOdk5CbWdBdk42TEdxLzM5cW5oQ0NobE9xNUpPcEF1Z0hSOGkrcmtMUHpPL203RHoxa1AxNG9hZ3ZUNWlmeFBlMjhIbzRIMm5iSVg1ZnNrajFBL0RtT1Y1aU9zYWVYbkFEcEhlMmpia2t3UTUwS3dFRHBMam1COHBDOTlhdFRQVTJEUk52emMyOHU5clAzazJveVlsZW9DcWovdEZPRVhpdXJXUTFoaHJlMnFoNmtlTmNqUHZlZytVdjJ6aG1Gd1hYVDRPZks1c3FyejllcXpLa2YwbEJyV0VLOTM1QzY1MXBjSllTMzM2SCs5UGc3WE9TZTk4b25vNTZuZHVoL2kvZEwveEd2OVV0VFA0NzdSUHZETTk0WEtCTUxQTlVOQW5FUDJyU3A3VmZnNWVTeGxvdVR3TEd1K05qNEx1VFpHbDUrckhFN2FTbjR3aGVsS0s1UlpCMnRPSjZvRHFleEwrWVJZNmtqcUJFbzhsdlNkKzNoSU5xOUdJRmQrbzQ1ZW8xME1TcVF6L2FYeDlqRG5kTXppMnVPNm9NN0xNWjdBSTRDaklNRXpVNi9JQTZjb0kwbGVBekNablJ4L2NIajlsZ0o3WTJUajVETWIyajJIcFg4R1RFaytoRVdPYmx0cW9NWWFKckNwZ1BQbXBvcThEMHVQZnYySi83eEVUcVA4QXN5dytMRi9Cc3g0U01QdzJ6RGo1NmZ3czdoZ1ViSmptSUgzZGRobWVBdG1iSHpLbjZmaDkyY0loRXdNNGN2WnlURTMwaHhtSEgzS245dURHVHRqR2Z2dkV4akkvMVBrYzRkaldtakFqTGxQdzlKZzA0aWRvaGo4UFFjd0lWRFAxRDJIR2RxLzRIMi9BaFBDYVFUWFRWa1U3OTlQWnlmSGZ3SmJPd2YrdHdmZ2h6NWU1N0E1QUlCeGp4R1dCcDJSOStGMVpBL05TZVgrQndEK0VyYmVub1dOcFFxV3RZMnZFVGVQeXk5bVNVeFppRGVCZEhxa2FoUUxnTzBNMFlFeGFCVG9Ibks2NDNOWDBCZDk5YXJ3cGt3NkNwNTlnTWlHdHA3Qzl1NFNPeHFhS3UxVUwrNmtITFhpaGU3L0g3VVdEWG9Wb21TSlFCTDNvbm9FTDJLL1VSSENwYzhxckxPZFpJUUptSkM1WHlPbmlLZkFmdzhEUllHYXl1V09jRi81WFFHa2ppRU01Wm1OWXdWalFqc0tJekpMVU94UElhbTYydXpScG9BbGdXb3F1VXRkV3ozS0d5QkFnbjlQa2N2SS9HUUVtL2NMbE91TmMzemsvVXZuYU1yKzREN2svaHpEUUIyTjF0MUQzVk9TU3BMT1JWVzViRUlraTVmRVV4dzBLS0pRQTFpNWNpVmc0WUNUcmtlQ0xpcE1VakdtVjczS0JCMyt0QW40REdDVWdvWUpGUFQvTTVTUkZ3UjNWT0ZWZ0pQamxTSlAyakphZWlTZkUwalRERGhRNkRXbkgxUFlHaUtvUThGMkd6N2NVVEFGakZDQmY0Z21wajRJYmRoa3BGVUFNSUx3bWtKSkFaNmF3YkFvYlJrVnQwQXdwbFQ2dVllc1ZKd2pnTDkrajZaaDBsUk5iQXZsNjZrOFEwVTRSa0Z4REM1YU0xWnk3amVlVmQ2VVp3L3ArcVBSanZPMGd2UG1jRitSWGxIV2V3Uk42U2pDUGl0b291QXdlVld4aHFoTXRmbjhYYzZWcHNwUDZkOGhEbVBJWjJwSGcrYWUwQXRHM1l3UVVud2pyeDNTQk5LbWRPNFFLeFNGWGZmaXBXVFhOanN0YVJZaGRjUlFrUDdjeDRZNkEybitmblA3alFkYW40emxmcWgzRGhUbkRoTnNyM2xRSnhEUnY0OEFUSnVjb3BQUGF2YURFUUZnbEU1Z0hWQzl6YzU1TmVjZ0JZUlpMNk5BbFo4WFh1NENObksrQ3FEQys5NDVWeHNaaUkvenFQM2p1N2t2RlBSZzBiYU5rZmw1RmJ3TS9EeUNlc3BydWNmNG0vWWhyZXUyUEpjMVJSU2kzRE1LUUVkbm9yNElMNDFzNXYyOUpUeXZQQ3hsRnFtTVE1SmIvWHJCQzd3Tk5iQWMwcTZpMVBxeVpZbWdwOHE0Tk9Dazd6RFpTR1Z4bGhGc2ZldVJJNk0yUjNwcUJHbW5FVU9BZDVDSnlPUFNHcXFBbmtPbEZ4RGVKQVBKc3dwNEtpaFdmVlpvRUpENXJ2THFCSUtpTkNpbnVhaXNCeGF1VlRyRDFCeGRPdmY3ZWxtMndTSEZpMFl1a3cvRi9jb3NSSEFRbEJHN0JIVnJZMEE5YUkwdG92SmtQOGVJblJHeTRiWndCZzc3b0JOMUdPcmcrK21RQkpUanFHczg3dU9PL3V4clFPa2ZIVENYOG81RDVDalhjN2p6WVlXZlgvWHhvc01hblZtamZwRU1ia0VmN2hnbmd6N0JkWE1wL1Z6NE9iTmFBRm0vbXlBZmpRYW5DWFJJVFhRRVp2QitxUFY1ZSttRVFEeURQSFlsNzZFaG9jYlBsZGF3YlhUTzA3MUd1WVByVW8zeVdsL25hQzZuNzhYeE03d1htVGRTanErbEFrM0dZWkU1RmY5ZXl6MUpMa0MzcUR5blpZbFNCMlFocjFRSEM4cmloYnc3UkE4RFA5WDB1dXpiV3VpQnJydG9IQ1E5VW40K2NSMkQrNS95UUpKMTJoekZyL1JHNVIvOXJ0ZXJlbU1QYlZYOWZGdCt2a0ozUC9KczdWcmJ0QlI3OVpMOFhPdUplei9SeXA3Nm8yeWg4NXAwbVNablpvaTZjYXF2R1hEQ0NucGFpdmdOL0x5SzlWZEtSeDZTdmFiNlRWVnVrallYc3F2dnhUNUhUaDFYYlVlUzRmMjN4SjlVYmtFMlRIWktrRDE3MnlCRkhjOVd0VDNiMU5PT2N4K20vU0g4UE9Fc3lGZ1IrOGc2OWJpN05lb1lhbEg4dXFhYlpwM2s1OHEvT0I3c1AzR2ZHcmFobUFaNWtPcERzUThiOTFXVGpkd2F5Sk5TT3lQYk00R3NuNmJBbGdydlZSdWp5bjl4ek5SNUxyVUZPU05XS2lKbjgzalRTK1B0MGw0R3BSUzRVeXRSMEQ0Mlo3QzV2TWIyampTNjBRMldJNy9oR2t6eHZ3Znp0R042MElWM2lsNXdIM3NuYVBEOUpWajY1emsycHlvR2dMOEE4RmN3SStxamJTTXRaeWZIdndiZzc0V2ZINkVVYmg0QStGOFByOTk2ZTVzNmU5NXpGZGIzZit4dC9kVnd5eG5Nb1BnbXpKQzdnb0hyaHpERDZtditmd1JMWTh6emtsK0JqZHVIQVA3VTY2RXl2WWFOK1F1dzhXVktaVWJwMGJqNVBJQy8wOVAwKzhnQS9yK0ZHWUFmd2FKOS93aFoySHZhNy84eGdHLzdNM2Y5WGtaU1ArdjlJVEI5ejl2N0I4Z0c3NlZmK3dITTZEeEROc1QrYk9BY1pvM1dtbnFmMys2N2Y2Q09QZGpjdkFZYnc2OVhibDBBK04rUVV6Ky9pTHdKUDRRWnl1ZEFlZWF2UjBiWG9vOGZsMStRMHBaZTFtU1NQRzlJR2VBWWRTK2t2bm9MNWg2RUdocVpsUkZlOUNnTlJYMWVXUGRsUFE4SGpaYTdDTFI2YnlzcGVGR21Id0c2d0FXRkdETGJpOW85K2g1djcwNTdVZVpVbzM2U3gxa2phZXFrak9FcDd3RThhdnpjS2ZhMU1yZFZ3NnN3ZlkxNGlTQ0ZycTNxZkFwZ1R1R29Lc0QxZ2JvQ0RoRnNUMkJKVUJxS2Nlb3IzaDQ5NnlnSlFtRXRVSEJpMmxqZU80YnhpZk93UDQ2UW5XN29lVTdCT2hwYkdjR3Rub2thb2JtT3owbTdEdnpkVys4Zlh6TkZKSSszalVZZUdxV1R3OGcyYTdYTnFXSlZPU2EvaGIvenJOTC9DWXczbnpmMWROY0s4S2hpcit1UDU3WWN5RzgwYXVsWnE0RFR3elliSmdoQ3FQZjhxUEovaFMwVURtOHp6ODhFNnRFNWV1ODAwc3NhalJEd2dldVA3VjMyakttMlh5TTVoNXh6b2tGU0FjSjBSbW1UalZUVFVFMDFyWkNzS1NBN0RReEZUSTFSSG5zQmxLbDFOVDBTVTR1clFZeU9lRFM0Y3cxTnBRNnUxelVraFZHYk15Mk1JSHVMU3ZLR2RyT1B1bDRUbmFpTTY1RzhoL1NiODZlMGdJQUYxeXIzSnRzS2xHY1g4VG1sMDJwSTVuZ0NwZktuQ3FMTy9VVlRVWkRiZkg0ZCt3aGtHVURQd3l2T0loc1lPN2F2Y3g1ZW0xUHhiWnU2aWtacHdPZ0xJMTgwZ3dUOFhlZlNwd2xNZDJGWlljQVJRTnJGOGRZSXdYZ0dHUHU0OGpZdFlJRDBtWUJiYkRQbktSa1drT2twd2VOa25IU2FScWRoOGcveXE2WElnS1QvRTJTOVJ5UGlDWlNOcGE0NTBEbGJiNHpNdTRBc0h4U2U0RzEyNk9oRXdiUVM3WUxnbkJob1dtRXc2cE9ob3Z3aVk2NkFTblNzVlFOWU1yeUg5YzV4MVBNUzJjN1lCcDAzQllPSysvb0E3bDFsWWFIREt2c3RtL0xJQVBhemtHMDIxS3UwaFBLOTBvcHhiVTlzSTM4SnJ3RzZBR1p5dkFzQVpreXhEV1FBTE01M0xWMDR3bnY0cm0zR2d1UEFkVGRFeDJxR203NzFXcXlqbXI0U3hvcUZ0SHlJbjNPYzFySm02WUJKK3NHOXNaQjFwR1BVeDg4UFExc0d6MjZWTmFIeVZBTGJBMTJoNDV6K1JobE9NMTBvVDJTZFhKL3pRQ3RJaXd2ZXZhMStxR09KVENlTGM1WkZkcDZpNVBVMWZrNmpMT2Yxa1kvRkZOa2hTek5KcVY0ZjlTNDZMRkYyMXNncE9nQ3I3THlFSFpGVTBOY21wNmsrUXVuWXR3QndHdVNyWHAyN01tN2svVFdqSmVYWFRmeDhES00zbEpIMmtXWDlHVW9ud0VXUVBWU1dKUDljeFBiSS9WTzVUMlVuUUhnZ3h3QjVMWE1lME5pUkNzUkdkSytPcFM3TzkwbytuNk4wZ2tsN0ZPV2VYWVIycExHVXVyVHRxck1tNTc4bzA4bHpTbHRxTko0eVJ5MDdsUnFRMC9vSSt5RmhDZnl0aDg0a2ZoN1hmdERQMVRCY3V4WlRvUlo4UmZyYnA1L3pQdlpMKzdhS3o4bXpOT0R1b3A5VEwrRzdnTkxCWDUxNGtyRnZpM3AxWGtmeWw1elhhalJjK0U4dlpoam1SdHVOVGUxVCt1dy8xYkxZc2QyYmpPNGJhWW5YV3h6WnM0RjNxWk9BdHJubXVCb0wyeFZsMXpnUGlVWnNNOFk5K3JucTc1b2hTNi8zblFHc2VqemIyN3RtaFZiRWUwZ3pvdk5jamNkVEYxZCtIZ1BZK3ZqNXVGSm5vVzl0YUh1VUM2dk9BeUozWERTM093RTJVYzlXWFliSFlSQVhUdnBzWER1VjcxRVAxSGFTcDZnRDc2cHhYTGVucjByVDJlYnpJUnlqcndoTnE1NEh2NE04RlhWalJoSFRCZ2NJSDZuc3YzMjQvRFFGQ3NNdmllSjlsSmJyUjdET1ArZlhabDdCa2Y4SGJNQy9CSXVVamNiZmI4T01ocy9EakhSM1lOR3dyOE1pWjMvbTkxRmhIaXplM3Q4SVA1K2hCQjRBTTVqK01ZRC9abE9kQStYQy8zNElNK3plUVpsNitnaldwM3V3ZmpCU2xzejhFMWc2N0VmZXhnTlluNzhMTTBCK0FPRFR3K3UzVm5KTzhGTUF2Z1lUdkE1aFVja0VGV2JJVEdjSkc5dHZJRE85TndIOFMzLy9FV3pNUC9ZL0Nrbi96cC9kaDBYdjNvV04zUVVza3BjQ0daQlRhQitBeUwwQUFDQUFTVVJCVkYrRG5WMTh4Mytub3Y0Uk1uTmh2d21Tdk9yUGZEZzdPZjZ6SGdNcU54Y0YwZmV4blZld2xrTllTdWZmUjVubVQ4c0hBTDZETXBYTkJ6QUREOCtCcG1GbE5UczVWb1B2WStQdkwzQlJJRUVLalpjcWhHdXFqMTNXUS9MQ0M4TDFHcmJueUpRSXR2ZVd3T2dLSmFIV3J3M0NZeTlnUmtDanJhZjE2MjJYZjE2aDYvWGMrM3lUSXhZVWdOMzRuaHBBS2RkVVVLSFNGK3RkeVI5UWdnTVVxczRnREx1eVZ0TGMxdHJCTnJlZXBrWGFGUldyTmR3TGRRdUFRQldQdmxLN1J1WHJJaWlGT25jVXltckMxUmdXMFVVRmZReUxJbm9DZVMxU1FkYnp0T2dGcjZubUNPcHlYSk5YSkd6TUNUUXcvZmE2dlhGejBvWVVkSzE1dFIyaU5Nd1VnbjV0TFB6YVpkS3VFQUFrZjJjZmRVOFhTcG12YlRWQXp1T1lldDJjVTBiU0xaQWRyS3I5UUU0eGV0Q0t4NS8wTTZXOVF5bTRVMm1pOFoyMGpkYzQ1dlFBcFpKN0lmWFN1RmJiUTV4TEJVV25QcGViK0R2N3JjQmNwN2lDTVdxN1JtQUZpcUtTck43cEFNbzBaSUhHYzQwcUFNZzFtS0ttZkMxMWxDSitsckZTR2hDTnZ3cndSQVZ0anRJNVFJSGJPQ1pzSzNrSm93ZlYrTTh6QWJuZTl0cnlUQnVPRGNFd3JubktvT2ZJR1lHV1hoK0JSVWJKRkx5bEF2QXdtaVNlVFl2V1BMblgraGVlNXpqVGdLY2dzcjVHNitCek9rZnN6OWpic21nOXFqYThaeDIrMHpuc0FqbnlpRTRodXM1SUQ5SjhPZDhlK3o1WXdGSlc3a1BPVkVhWC95MEJITFptb0R6dDRjVjBhS0ZSTXBaa2JQYnhMUUI0bE1wL2xIbG1LTk04cnBBQjNtakFYTFkzYmo1RXppYVMxbk90K0JwWFhqRjIwQ2dkNytCRlUwSXIzK1pZS1hDN2grNCtaQnVTQjNnalVWeUJML01zdzBRUDIyemdBVW93VXgzNDFsNnZPaU1vZmRkNTBiWEpjZXh6UkJtekRXRWZjSTFwVm9HTy9CajNYdUE5akh4TzY3WXRvNnZaaCtpMG9oa2Z0RTgxaDQvQ0FLN3ZGOW1KaFhSRkRUR0Q0RjVmUDdjcExnZXBkeitBZEx5RUF2S0ZVMWtyRVdzVjBKdlBjVTVKTXpTcW9hOHZVL2svbE9ZMUFxSHNUOXo3QllDS1RNZUJyclBodXZJL3RyTUFqdHN5SlhGZklWMEVCblI3N3NHMmt0bW1SNzVQOGpwbDFhanpCSDYrMGoyUHpNL1h1bWNIMXBHdTM3bnduRUtlWUp1MFQvNGMrMzZPekMvR3FPeFo2YWVDMUVySEVqOXY4eG5jM0g4UkNGWSt4bXVxTzZhb2ZIUU5RTDFnZHRERmhzWk8xeHp2cTYwWmRTS01KZW84N0tmK3BzNDNiTXM2MUtFeUdjZFdNeDFTZjZEeDhRTFowVXlCWk5LNWZYZ0dKUmp0djkrYWdmOUp2LzhjWFg1T21XdUNuclRGYlhaUXZhanNhU0Nuamx5NExOYzVCcUttVy9wdjU2MGRTNk02RitYRmxUN3Y5UEVVT1JQV0FaQ1ByNGlORXBtRy9KeEd2SE5rR1dpRTBvQlBPcWs4UDhwc3BKMGFGY3k5TS9aeGlzZHQ4Vm5GRktqcjZKN1Y5MFZuSURVSXFUeWpSZ1l0T2laUjV0VzFYWE5ZVWYyTDlFbjN2MFphOXVubjZreEhmaDc1OUFpUy9hUFM3azUvRkpQdzhWQlpKTFZIZnhmWk1SMmJCSWxhbG5WZHhVeHdpY3cxZ2lYcGtTTGs1OFg0eS9YQ3FOMTBVN09yTVdVdGRhMVF5bjYxa21RS2JMWnQ5STFEYnhIZGZSVHZWeHBISEFWZFhxUHJTNk80TjdWVDkyVzF0RGs2ZFZBL2w5S1JaMURTM1lpaGNXK21QclJpTUExajBzRzYrRm54ajFoL3ZOZmZvYkl0a0dsVHNhWjZ4bVFrYzhHeFVEa3JwbDVYbm8zS015cG5zaFRPeVJWK1hqaGg2aGhvT3hHY1ZubGZtek1FeExtS3BXOWZLTTFSbVlhLzZmTXIySmgwVW1wSCt1bHRabjFUbE02TjZrQ203eTlvVnR2RmxPZitMR25ZT1NwcnR4VW5xOXBBdERsZzRxSzJ2L3dkMU0yM09WWlN2eXZQVGI4TjhHaWV6M3cxZXNyRXlmd2l6QmdKR0NOL0d0bVFlSWFjL3ZjbmZnK2pRMThNOVRDRjlDZXdLRmllaWZjUnNvY2RBT3pOVG82dmVQMVhBZHcvdkg3cmJtVU05dEE5QTdjdjJ2aWpudCszTFd0WSs5L3g3NC9RUFh0NEg4RExNS00yamF5QTlma0RaQUFOTUFQa1BiLzJJWUJUcG50MkkvQVUxcmM1Z08vQnh1cFYyRGgvMyt2Z0Fub0E0Tjk0UGEvNnUzNE1NMlp5VTcyUEhHS3VYaWVQL0IwditlOHZ3Y1p3aHF5RW4zbzlOQXgvM2UrNUJqTjJMMkZ6eXBUUE5FNHpRdnloditkbEFGK2RuUnkveit0aVVFM25nUjFldjdVSWh0ZFVaaWZIRTBrM0hzdmZSejIxOVFJV2tmd0piRzRZcWE3Uk1VeVhTT01FMXlLVmdjZmxGNmlvUU1UZkl2TVRnYUFXZWJBVHlCVHJqdldJOEVMR1ZZMW1rN3BZTmtVSUhNQUV1ck8rTm04cDZQRTh1MDBnejA1RmxBOTZJMVBKL2hSWndkelVQZ0syTmU5UktvZ0VDZmJkeUtHR0ZucWZxdEk1aFRuRDdNT1UrRThnYWUrM1dEZmFCbmo5UmVycnRudm1TaHlUcEZCVkZNU2twTmRBc1Nna2FhRkFFMzdtT25sWWVXNE1BeXIwL09OeGUrUG1RV05SWDJ0MEk5aXZ3UFlPRFFaVHVjWnpiZFhMT1FyN25YWkt1MFpBa1o2VjgwVWpGZDlIeGZlenBHU3FGcTl2NFVJd3ZkWUpkaENJajBxQUNyZ1JrQ0RReFAxUEFUUTVJeUVyTDUyMlVGbW9YUWNLK2tLREJvMVhOV1dGSU5BRStZeGtSbzdTVUpKUzZqVGQxTmJSbzFROStMWC9CTTZxbnBCU2I1OW5lRy8wR2dSQWIyL2N2T0IrY0lDT1BMNEFJeUh6RVVFUlVYZ0FBV3RiaWI1cnpmQmVnQ0tpUlBJc0xEWFNLQUFOU0FTUTkyUGZQeStiMjI5YzZINW95N09HYW9YdDUvcEtSbHJrZGFYQUJkdDUwT1lVMTN6ZkhCa2tKQmlqYzVLVWpEWjdvYWJJbTFaUy9sZksyTy9oR2xjbFYza2h2WnlqUjY3U2hDbEtVSExlbHVlc0VsU3JBUUNVelpQaTMzUzlsWFZjdUVmU25tN0s5R2gwaUIyRi84V2FBSW9VdUJ6blJXMC93R2dxeC9VSm1GeGRGRjkvVmM5a1VZdzV6bkh2SzZCZG96WEp3YWttUC9uY1Q5c3lTbzdIK1Z5QjhaY3I2UEdjRm9DeUEwRDdaeHAwbVlhVFpSOEdadk85YXFCVzV4UFNLSUtoR3BXZzgwbFFYQ01jdUhmMHVBR20wb0pjMCtoeTBtYktJRnhmZXpLL25BZGRYekZsSzU5Tlh2NnRwSlZ0SkQwYnh3eVpKdFV5cmFUcllSN0lQL25lenZ5MzNjaGNmdFl4cjhrcUhkNmc5YUlMWG5KZmFRUlpCTWsrMXlKclc2TVFPRC9LZjlsZW5Sc2FRVmZ5M0FnbGJkVitiQ3JxT0RKVVl1UW00ak1DOURIOTVnclpDRW8rRnRQUVZ1VlozaXZ2Uk8xYUQrRFUyZE05SllHS2JXbWs1YlBSTVlYUEZPM3AwUjJpRVJ6SXRKajhDLzV1R3I0aUlNeFU1cVF2dFRTeEk1UVI1QWxUOEhiUjhXUXVkUS94YzlKbW5XOHROWm1UYTFUSFd1VzR2cWl0S0wrcDQ5Sk9zblJjVjVTTndsNUpocVcyVE1zNVFTbS9KemtUZVc4cC9XWGZ5WjhMaDR6UTdoaXB4d0FQWGIvRXNwS1RZVThmT2JlTWRIcUU3QUEzaFdYc3FkRTlZcFZqR003NUlON2dZMVUxL3NvK3BINSswWFpCYk8xemJYOXdYR3Y4ZkFMak5XT1VtV0NBYk5TZHRqZHV6amJ3ODMzNVRlZEJqNXRSZVdlL3lkRll1bjcxT0J6MmhXMWlOQzM1N3J6TlR0VFVDVWtmbFM2ckEyYVV1VlJHaXZ3OHJiVTJIR21BY2gwQzVUcWNWSzZyTHBMNGtEekROdmZKMHBRSllrWWdkZHFNUEljeVZYUkVVbHFMVGFVSG0xRit6cjVxUmhYTzNaN2Z0M1VtdlYySzg3MFZ5bU1pMWFsVjc0MU9BekV3Z210QitSSVExc2NXcGJlZnluZGpXL3BLNUxmc1I2UjNrV2RxTzRSSDFQVHpUdVNwMUJPTnE1MjJOZG5veXIyaWp1QTA2dW44cXo2blk5cmhRK2pLZ3dVK3BPMzN6eXVucHpYOW5PdGQyeExsSE0ycW92cGI0dWNJUVJNRHBaQVhBeTFYT1hxRWNrOHFQYVJjbWh5bXFJT0crYS94ODlVMisxdmVTLzArT25hTTRuclMvb1N4VExwOTRPYzZsK3JRcGJMTVlBQlNaYjF6NzBlc1Z1ZFBaZnJZQjdaM1Fobk42MXhBTXBPRU5oQ0Q1UDZyWVZwcjE4Lzc2QURibzdSN3B4THJGdjFaY1FjZTU3b0hXQXJvc1VTZktxUDhJb0RmQmZBYXNrRndDak15dm84TUVEMFBNMmplOSt1LzVMK2RJeHRLNzhDRUkwYm9mZzltV0g3ZDYvMGV6SkQ1akQ5SDRQQzl3K3UzT2xFNnM1UGpBd0QvWk10eGVmZncrcTMvZnN0NzQzczAvZE0zWVliTTE5QTFOajhFOEMyWUlmd0xNR1BqRENiY25jSEdWUVViUmpucFdiOTg1d1RBcnlBYmZPL0R4dVUvUmo0Ymw0YjIrLzdZQzM3UE81QjB5MzZtY1NxUzZ2c1pXSVR4ZThpTThXOTV1MC85dDErQ3BlYitHRmtwZlFFMmgxK0Z6ZHZyQVA0MWNrVDNHVElSWTczUHc2SzF6d0g4S3dEbkliM3ltR1BnN1owZVhyOVZiQ0NmaHhjQnZCK053MjR3LzZlb2w1OTQrLzljeHVyMWNNOHBTb0NjUU5ESHU2U2hmbHord3lzQjBDaUUvYi9tZGhEVXBxQlRFN3EyYWxPYmpiOU1rZGluaEc2c1o1ZDM5b0JGRTNTakRIaDk0bTE4QXRuWXRZUXB3MlRRZWtaR0JDbXBSQzVRUDRlVjcxY25wNHVtVkpMSDJqNEJrcCtGT2Jrc1lYVDc0eWFrSVBINk82bHBRbDNGUGFIL3lUZzlvT1R6N0pZRWh0WEFOR0h3TkNKczdhVFEzcmg1MWZ2TTgwTFZjNVJyNmFDNS9jYW5mcjhxc2djd1h2MFFObWVIS00rUkpnK1lJeHN3S0h4d3ZwY3d3V3JaVnFJQ0srMmRJaHVSejF6aFYwQUZ5UHdLQ0JGejdZMmIrMFAxNzFKa2pjZG9mQVVwdUpZVldOZVVWRFFpVTlpUDREcjdOV3B1djBHamlyYUJlMkhkVkZJbGl5SkVua3lRZTRTY2RVT1ZaY3A2YkVzMEhsS0k1RmxlZlI2UE9pNjZad2pzczEzTHZqcjZpaWdsbW5ZMkt2eGpTR3B4ZVZZTjdvVVNJR3VRdnl1QXhPOXhQUG1aRWRQcVpNZDZraUZIOWhiL2xnQmlaZ2dhRWVlTlpCNFlvc2VSSGtoYkFOdWp5YURTbE9rSXFSQ1EvM0hmTGtoN2QrQURIRnVDNVIyRG45QlBya1AxVnVhWWtyYlBPR2JTVmdYTk9OYktGL2orcEVRMjVmblMwUmxELzNPdnJtUmRrUS9GeURGZDF3WEFqRzRFYWdRMFdPZzQwTXNybkxiUlNEd0NjS1h4TTNWajRUN280VGRxY056a1BNWjF3MmlQQlBwNkd4K0daNWdxazlHZUxPUVJMTlFaMC9uQnlQdGpMcnh1SDJYSzhyN29hQUxNdW85WnI2NkRJaFdycjFQUzVwZ1pnWTRpQ3BBcVlMdHV6UGtwQW9wN2VsM2V4ZlhHT2dsYXMzQXZraCtTTG1qVXpyblNPNm03QThMSm5sOEQxWFNBRXlDbm53eEFjS0xKL2wxVEdNZWlxZWRJVHhPSUpjRHFvQ05mVzZhOTFQWEdQbW1iZUkvMmQrZTB6ME5GNURJZ2p3bHBvL0p6dHBIalRMbE01MWIzZWdSYWUxTzZid0pYZVUzb0J0K2w0eEJsb1FpYWpzUDlHM1dmUUR1MVgzdy8rL1daOUNlaHM0VWhxMGVQaUhzLzBmSXdSbnArTHVjMDh2TmlIWHI5Q3BMcjNDcmZVUmtoOG5QcUZFQXA5MjNOejhPNEFNRXhNUEEzdGxQWExQV2NuZVpGNWF4TmRiQnRVVDhKNEdOTURSOXBhSXpvTGVSZlhsT1pvbWROZ20wSmNsR3FKOUpUQmU2bDNXelROV25EQWxsRzBqVkRQWFFUUDJlMklzcVdlOVN0WW1rcjZWUDFHcmJuNTlwdk9ycnN3NDhnaU8vM3VubVVucWJTSHNGa1UrNDNaZ1k1Z0tmdTltdWF2WWR5SG8rYzQzVzJTNTNyS052eE05OUR3Mmppb1dFTkhLQ1VIOUt6alRtVE1uSllpOUtWdWE0Ti96bEZBZ2Q1V2RjRjI2KzZuYWJnak01REhNZEZYSDlhZHc4L0I4U0lFakNPeEV1Q2ZwNTBHeG5UUG9kaXBlUEtKNmJJT0V5eHgyc2xqTFhTSDc2ZmE0UHpIby9nVVNlNXoxeUUzbk1kS1I5VUJ4OGROK1huS2d0RWZsNlV2bkZwSzA0V1BmY1ZjN0poVDhlUzlCMzl2QVZkMEtLNmxkS01uZkhEOEs2Q1Zrbjl0Y3g5cEtzc1NwZFhsZjFROEh5VXpuQXFrK2g4UnBtRlJXV0djWHpXbjFmK3VrMDJzOTRpODlncjU3UmwxcDNQek0vOUkvdlg0UnVoVFpSbitJelM1VVRId3JPNkRsVUcxZStrbmVUblVUK3Y5cXV2cmJ1TWc4aGpTdS9KaTJNOWVsemdVSnA5SG9YR1ozcmwrcUg5V09NSkEzMEEwSW1JMy9QMzE4NGRacEFWNlM4QVcxalB6MDZPVDJIUnZVL0FJckFld0JUVGV6QUQyaFBJUmsvZWR4ZG1KQ1l3L3oyWU1lMGNGb1g2c2Q5L0JYYTI2a3NBZnN2citVOURuNjRBK0IxWUpDdmZ6ek5zYTJXRjBxQzg5Ty9YS3ZkK3lZM2JqTkFCQUF4RWsyb2htRDMzTmoyQUdSWC9BRGJZZDJGbkYvOFZiTHhlZzBYdmZnS0xIbnZTKzhNMlh5Q25pRjRQcEJYK0VEWWVyOEhPckQzejkxeUJqVEdqY0wrQ01oTDZJd0RmbjUwY2Y4dmZ0ZXg1eHhjQi9CN01HUG9ENzljWFlZWmNSdmErRFpzRGpZTDgyUHZNZE1sditqdGZoQW1HZXVqMUdEbjk0RSs5RDdYbzNoR1FqUHBQQXZqYTdPVDRMd0U4Q01ieEJ6MTllYXJ5RzJCT0N0LzJQaEV3bzhIcHk3RHhHUU40MS9zMGdhMTN5RFY0MnhLVGlRYjd4K1hmWDlrRm5LNDk2eDhMRUhjSHNMdlA2TGxSNktxQUFCUms0bmtJQkJPaUFKSUFqS0Rjc2o4ajJEN3NTeC9WMnllMmY1ZHg3UmtIRlFScWhZWU8waGNxbEpxT1VPOGR3OGV1elNsSWtyTFk1a2hJOVhSY3dhTEJlSTVFTk01cTFCa0w2Y0JEWkdlUVdzcXIxRDlST2hNRGJ5UkNvUzNUZFpCaEU5aFhzRmhCazVIWFI2VjN5ZnJaOWpaSDdQRzNRZHJVQThpZXdtZ2l3WDFWK01telZEamwyazJSdDY1a0V6RGcyRE55YjRXY1lVR0JZaFhXajN4T3ozdkdtdTJmK0xndHBRNUFVc0dpQ3h3ZSt2Z3ZrVDJQOStCR1o2K1hCdVY1Rko2MktDck1BbDFqVWdTMTRwa2NhbkJRRUgwcy81V3ZjdXdaaGJ0c0J6eXBCVkJYNEFiK1A1NlR5ZjVvSkREQkt2YUJhNDZwZDVmaFdmWlA2MVJsTEFJc2wzS3kwalVpd0M1TFJ6bVJ3c2hBYlJ0ZysxU0JFdGFqOTlSU3dYT2VsSDVHNzE3V05SSGFsWXpHMnJnbXB5UUZaR3hxTkRhQ0Y2Mm5zZ3ozTG1HT0VsejNvMHE3MU9GR28xbHJRQVBrbXRKUEd2WFM4NUgzRUdUeitkS0lTZFpGSFlON3V3YmVBbm0vcGJUK0RnSUM1Wndwa0FWdmt6b1VhZnRTaEJ5UW9yYjVwNUhKU3NlNGIvWElGOTNyYkk4Q2IwQjVCaDFwNHdoRysyanN1NEpzZ0NMNFNjZUx2aExYQ0dtNkFoV2I1RmNkQnhxOXRXODFwd0R1OStoWVE5MndCampTK0hvQllDbzhpWE9tTkhHSmJJUm5XNVRtS3RBUVFjODFMRnBwRmVqRVJKN2xPTk1STFdiR1d1cjliVDZUbTA0aiszSmRIYlpvK05IMjZqbnJmSytPc1FLM0txUEdLQzNXaWRhUFNKQzJjajNWNkt2eVhlWG5FL2t0QW0wNkZxU1BDclRwbWgvNUdGWDNuNVlBenNaM1JGbUNSV1c5RWRDTlNoY1FmSnQwaHRvZTdsVUZpZm04T2hTb2syWk1rYnVVKzJMZlU1MFJPTlB2UTdJM2FYNEErb0ZNWjdTb3ZzRzFyMnU3OW15TUd0bllIcjMzOHloQ283VU02UktSdm5BTjZyekV5RFR1cVhuYjVZZWQ5Z0NBOEc3dUx3V3JsNmlBL0Q1ZkhkcTdDeit2dEtVQXM4UDZZZjhJcnNiOTAxdTBIaDByYjFmZk1UdWFhcmtZeDdaTUpWOXJBNTlobTVmL0gzdHYwaU5abHAySmZXYm1ZMFRrVkZsWlpNM0ZZaFZaSkl0RFM2VFVqVVlieEthMEVDQkJFQ1JBZ0hZQi9RTFh4cGNCWDhZcWZvSURXbWdsQVZwSVdnam9WdXMxUlEwY3U0cFRjU2l5S2l2bnlvek1tTng4TURNdHp2bnUvZTU1OXo1NzVoNVJKRnQ1QVllN203MTM1M3VHN3d5M2NvYjVmdUpKbGZtZ2M1anFRenMrNzNyVmpUcHphRlRuV21qZURQbWVlMGEvcHJ0bGtlOEZadDh1WVU2bWxBc0p0TzdBZEVoR0VqTlRFdVZ3T29veE1LRldvcEU2MGJrdCtMbnlVS1c1VERGZjQrZmM1elYrdmtESlh6Z1crSGdvQzlGWmh2UlFyeUloUCtlOXlmeU83YW1zQjVSOFlRM0xTalgxczV2a2hDNW5mVW5udXlzZGVsaUhPbTlTeDlhOXJ0ZjExQndxZGMvcVorVG5rL0FaMngzaTUya2VBejlYdnFQUjYrbk1vTTNQcVIvRk5OQnhicFYrcXJHTW56RWFmQm5lTFlyaUlIeE96aGpib3NFbDZZSGVEdCs1RXJ5R1krRjZETjZWWHVtUDZ0RTZuMm5jWFk0SVROOEhmcTd6RDNsWHk2YVVyYU53bWNybldrZFZQcEExVXZrSFVsL3YyY0FyWXVGMzAvRC82RktSWnpSTjgwUStyOVd0K3JmS2dlbXFBNVJ5VGlFcks3WXEzMnVmYXZzN09ScUp6RkIxaVBQOUhHWEQ1aHpJSG9TMkhlWkFhWE1zQlEyNUtUOG5yKzRxVjNmdy9EcWV0L0svWXdZVUlOUHdWa2t5aUxTdlBJTjFEUEh6WHJRMjV6MWdwRUJqai9NOTJSUGNnOUhKakFaaGppczZuVE5Mb3ZKNWRYYlhNZDhJYngraUl6cUc4QnpYaHp5M0tKVGZrTEdMcENkUEZxY24vdzNNaU1kVXVCL0FJazBCTXdwK0EyYjBCZHBwbGxsK0gyWncyL0Y2TGdCOEVSYTl1dWxkbHIrRUdSYi9yR1ZzOHlqWi84VC92WUlKWksramJnQUdnUDhleGx3ZndTYnFWUUR2SGR5OTEwdWxKbTI4RE9DLzluLy9GRFkvMzRNWk1nbU1Qb0lKZVZ5TTEyQ0c3bzloVVdTN01HTXdrQ09zZGdFc0dwSE5PejZHcndENDU3QjVmQlBBNy9namQyRFJ0TGZSVDBQTjhpSE1lUHNIeUFhV1I4aWIvbFVBL3hFc01uY0dpMXgrRjJiVXZ1VjlmK3I5Zmd1WldUK0VSVUN2WUVhRGo1R0JrYS9EOXRDK2ovR2g5L1dMc0QzQSt6OCs5bmtna1Y4aEE0ZXZ3ZmJhcjhMMnp1OTR2OWFvRzQ0NVp6OEw0TCtRajhnTTNnWHc1LzV6NGYzNUNvRGZSQmJ5bjhLTTAwdVkwZWRkNUlqbmZSOG52SThIQUhCdzk5NU5VNHAvV3A1VEdRTlF2SWgzaCtyY3BqNFZFb0xpcXdKbjRXWFc1ZnNDcVVURnlGU2dqSzRhNVNubWpJN3RYZHZKWWV5OGRuWnZMQ1BQZHYyZGR4dlBKZy9qQUp3blpSNFpaQmp0R1NjQ0FZS2dVaGhtZ3ZERXoranBxbmRGUmVOZXk2dDNIem5ieFdPMkY0VkZaSVdTU2lXTnNkRTdqK01ITmlnakltUkdROFl0WkRCakpYdVRkejlwSkNnOW1IV2YwYUN5QytQMU0yVGVjY3YvZmlienBkN2hDbjV6ekEranN0Y2RIYitNdk9ibjg5SXptMTd0RTNsR2hjMm9oQzU4RER4UFhOdHFtcGZLUEU1UUdxTlZHTlhJdG1ha1Q2Z3ZlcWxUbUt4RkVlekF3SUR6YnB4WDltM3BueXJ4cXV4UW1DMmlWR0I4VDBGT0Zub1Nucyt6ZHpqN3IwYmlDSWpRR0VtQWd2ZXZYY3hIUm1hM2FJd0EzSmUxNzhQN090OEt6QmZwcmJyUzhGZ29oUUZZVEhQWjZGY05HTG9jUVNlTEtGVDVuRkdtUmYvbVd6b3dkRG5pT0RrYWlPSzFCOXRuUFZtMU02Y0pWUVFKS3ZiT1QxRG1vbUxIdnFzaGRBMi9YMWZvWW96MnBLTEd2WGNMNWYyM0NrQ3N3cHB5WHpMMU11bUQwZzVHcW1wNmJxNDF6NUFxbEZRaytYZnREbWIyWHdHd095alRLNTY3QXM0N2g1UW5USDNNbEV1NVAzb0dKV1JEWTg4aldKNGh6Vlp3SnRGM2Y2NkkxbzM4VGVxN2pReWNxeUUyZXRXVDM2eVFhUmo3b2hIM0JVMmRsL2V5RldkQy90ZklPTzVONVhOQWFmaFZReDU1MWxxZUJZd3VVZW5uV1FIY1dVZytLKzVVOU8rb1UzTXVvcU1TOTRGR0pDb3drZVlRbGN3WU1tL2ttUVFBZEE2TGFLT3VqQkJtNlVXOHkvczF1cVdSRjRsSGhmTWNRYzFhdElIeTNWcGtuM3JwYzEyMXppVC9LWDJSdnFleFlVUHBjbVJBQkVjVjFPRloyd2p5MUVEZEZvL2VWaGNKWUg2dGNBOVAwRGMwS0kyTmV6MUdueFQ5a2pFcGlGdDE4a0VGN055MjFPVHVEYzlHb0w3bkFCQ2VTeEYxMmg0Q0RhdnMyeWc3c0xTY3p2VGR0S2NyNjhJMVN3NHQyeGc4UXYvWWhxNG4wK1hXK0VHU0l4VVkzN1RYbzg0cmRDYk9VU3Y2bHlVQzh6UytLaTlwUmNWVDlraXBuRkZHRzlIb3hFdzVyWWdqN25mTlJFR01pcG44WXNEQkVvWUJjcDVlUWRabkFOZGpSRjlsZEMzZnZaaExaaCtWajhJWUtXODFNengxT1hwT2FYQnhScjBmNUQzTjllMk9qbDlCNXVmVVoxWW9kVlcyZHh0NWZaNzRkeThqeTFjUmRFKzRoZlJiK1RscE9IbGFjajZEeVRXYUhVUU5zSVZoRWFWT3lXZFVucU8rRUdWL090b2xYdUpyV01zTW92UW04ZXJLbUVsWDBuc04yc2wzaTJlbG5XMzRlVFNrUVg2bnorYlpRRmVqUzlxMm50a2VUdVR5anZKS2xTTjE3bFJ2aUhVbng0WjVhWXpudnQ1SVk2WGZtcVdqeHZQSVg4Ync4NTVUMXd2aTUrdjQ5d1k4WjlMNEt0R3lWcitDemc3WVhGeklkNVRWaVF1TTRrVWI5SFBLM2R0R0o4UGZLUUlFWkk4RGZTd3Z5cTB0L2hFZEd2bnNHTGxqaXZwWnB0NFI5Zk90SW9abEgzUHY2M3BXMnc3dFIvcFRkZVRTK1F4OG1DVUdLY1NzU2pXanZPb0Y2bGpNNzVPY1dNRmMxT0VrMGkrK1V6T0dOb3ZzYWZJVElHUFFMRXNkVzNkMC9CSXk5bkFKNE1tODd5Q3JodFZSVHFlaSt6U2ZEN0pKS3JWNTM5U202K2ZrL1pSUFB0eUJHUkpmaHdrNGJ5SGYxYXRNOWhzdzQ5K21RdVBqNTJEQXh0ZGhVYWJSbTFqTEkyL3pkWmozMkM3TU9EczBvQldBZjRGODV5ekJGdzdzVlZnS1phWlMvcys5amI5RmpxYjUydUwwNUxzd3c1K204cmtERTJoK0h0bWcvT3YrM0RNQXYzOXc5MTRMcVB3SXdFZHV5SDJLN0JGSHcrL0svNTVLZW1adThCbnNIdHZmUW82K3Z1VjkrcGJQMHo4Ym1CTVdHbDdmaDBVUnoyQkc5VDJmbDYvTHMwdFlPdWZieUhjYkU3UjRCL20rM0ljK2RvSTBIK29jTEU1UC90TC8vQklzS3ZuSFh1ZlhZUHZxQ21ib09JUkZoeFBjV3NBRTVrdmtsS3Z2QXZqWHlIdmgwdWVyWlFST0RNWEwrN0JJWWpWZWM0Ni9qTkpia1JIZTd5TGY5Ym1FQVRvLzQyUFgxSmlYaTlPVGp6NU5EZjBQdjFTVTBTWmdNY1JvbEVtT1pVUWJubzhDS3U5NFNZQ1cvQ1RtclVvQkxPcTFGVVU1eERTcmN5QktRQUs4VzJQZFlnNVNDaXpZV1U5cExTc0NIdWRFaGNlTEFOaWtlYXVOdlRFZk5ZLzkzdG4ydVZWd2d3WmMwaGVtUUI1azFsS1lVZUpLMjV0blR5MTlqOTU0TEFvS0swQTFkdDRqeUhTSmJEaFp3anh5RlFoaWlpdW1LbzZSYTFRUW1PbmlDc2E3RGxDQ0hWTVlUMUFQWnUwVHgwZyt1ZXRydnhRRlZZWE12YzQ5dmwwQXB0R0dRRXNTc0dSdUZ2NTU5R3pjWnY0QUZHdWxCdFhwdkV6RFBGclluNWVSN1JHMDNhL1VPKzF5K3VkSlY3a3ZMQUFLUUY3M2lkUkRjS3dIR1BvWTB6MWI4cHZncVViNkpzT0E5UDBTVG91UURTYzZYZ1dSdHBwL0h6OVR2OUhndTRMZGg3YnIzL2RTd3d1dGpBcDlvaTlCZ1ZRalg4MGplQ1hqNEhsSkhzL2hlUVVpV29wN2I1eGVONk9IWStwVmpiQXNEQ2hqbENSLzVod21tKzNDenQwWnhERFZBQ1c1WDBnUEZNQk9wY3NPVFlXaHhvc0NORUIyS0ZRNlF5Q1pCbW90czg2OGdvR2NZbENCdjZYc3N5bVFJbnZWQ1FZb1FUMSt2d2NEWnlOUDRiM0hhdFFGYk0zVm9WR0J0Z2pFcVNJZEFUN0syRFJBcTdGdERhU0lGWTI4cGdPU0ZzNTNUQWZGL2JRalA1Y3crWCtLd052aisxSlBMU01HcEw4SmtPOHNsZVZWMTcrWExZRXlUc3QzNWZOTjUyUENma2k3bEE5aXZYcHVHUTNEZFZZSHBhblV6WHFVcHE0Ujd1djE4N05FTnJnL2szN3B1ckN1bUdKL0t0K3BBdzdUMFNlNjFCMGQ3MVRrRTQwQUlrMGdYVjhEK2E0MTZWTUV2R1lCTEZQd2hmVm9XdVoxK0U1TEM3aXVlZkFyMzA5UjkvTWNVYWdBV2cxNDUvZVFlbWJobVZIRis2VDltY0Q0dWU3LzBRYk5JWmtzMGxPWmo0MkFUZ1B3VmI1U3UrdFdpMGF6ZysvVjJxdndPcFd4bzdHVlJmZlY2Q0t5Zkl5R2lIZEV0NHJTMi9oWnJYK1VWUXF3VTNpbTdyZkl6L1dIejJ3eXltdWZ5TStWUDBXWmpQc2Izai95ODQxT3huTzVUc1YvSzc0MTFLOGs0OGgrcktXcDFUdFhlMkJrbHlQUVNGOTdWK1VnTzQ1QzM1ZDlTT2N2ZGF4U0p5RHV2d2xNZGlFTlZWbVh0Sk5PaGozbnRQQy84ajNLUlhRUXBmTnRUUGxMWHJvVUdnSmsya1IrVHVlZmMrUXNWeXNnM2RlY0FPbnU2UGhxM2svclhRV0x4VURBY2E1UlpneUtaMWpsaENMYXY3S3ZsQS9zZXQrbk1lcHRyUUFBSUFCSlJFRlV6czh2bk84ZFNCdWtYZXZ1NlBneE1uNnB2QVJvbjh0bDErZm5TYzZTTlZFYWR4Rmt4Qld5N2hkbDd4by9aNTkwNzVQZkFlWGRuaXQ1VDNsTXBLY3IrVTZqRXRVQVVkeXJLZU5XdnFWT2FoemJ0TXQzbE9zZTF6RXhXakxXVi90TWFWaE5UOUIzMVFtTC9Mb3c0SVQ2bUtsaUdkOUZTZS8wek13NFo4b1RHdU5vRm1JMm9UL044ejZpdnNKSXBkKzErSG1nNnh2eHc5WTRObjBmWkxja0M5VDR0N1pISGFiTEJqcUU3eUI3Yk52Q0RCQ2tXMnRwTDJVUGk3eEY5UE1DMDVQeDFSeTJnTForbmpMeCtUdkZQTWp6Y1p5OSs1UmI0MFI1RmxUZlRQM3kwaHZyaHJwVmg5bUJSK0xYTU1wR3FmSGRvb1F6RnM5SHpZR2s5WDZrajBBNXAzVFdacURHQ3VYVmZkVFBsZmJXenYwRWVXMjJNcWFMYktjR1lOVXhTTXMxcTU1aWlDdDVkeG4rSG5KT3E4blh0Zm5tTzVRLzZVVEZxKzU2ZTZhbEoxU0s2cmVBNGM5clR2UVpUSEg5TWN4WXlCUzRTMWlrNkJqajd6dGVLZStlL0NtWUliaG0vSDBIT1lYelgzbjczNElaai84YXdDTWFTR3RHdjRPNzk5YUwwNU9uOGwwaEhIcEtheHBoQVJNUUR3SDhDc3hJK3hac0UzNEZadnhqaEN3TjBROWh4dXd6R0dIOFM1aFI5UmNCZkJkOXNDV1dwYjhMWksvdVMrUk5wNkFPRitVckFQNnB0MzhCNExkaHh0cmJBTDZOOFFyR244RG05eDEvNzB2ZXprc0lSTjdMYmRoYXZRbUwrTDZFelErQisxdmV0enZJZHc5amNYb3k0ZnpUR0x3NFBYa0h0bWwvQXhtTSt4bWZpenN3a083LzhjOC85RDcrMk92NW1CM3l0WDhaWm9SL0d6Wi9yOEFqMC8xN0FwWnI3KzlqSDh1YnNQWDdKN0ExK3p3c292eFZtQ01Ea1BmN0UrU0RSc0g4TmRpZS80YlgvNFkvK3hac1RZb2k2YUdIVW5wL1d2NStsNlpYMUNZQjdhYUZDcTRMUStuZVJYa2tDbkpMWk0vYzRydlczeFZ3cndmY0RRQzlaSmlhL3FNSmJnMlZJSFJkU0YyWDh3ZTkxQzBzRkNLb1JHdWZDUkFWbmxKRGdsV1hvOG1TQXJuRkVHaVV2SU5zRFBzRURlR3pWWnhwUC9YK0tGT21zQkFGdkRWeU5nY0ZSblpnQW5YekRxaEsyeFNJTDFFQzVRb01UcnNjMlVSakVKRFhUQjJ1NEorOWdwek9qT3RGeGU5bGxON2NMQVIyZEgrcThyem5mYUdqMXlOWVpvMDFqQ1lmd0lSQlJoWnpqM0tQTCtEcFcrQlpLT1lTUFlkU2VhOUZmelZMVjZZaVRVSnFWQ3k2U2tSNXE4VDlMTUl5MHdGZThMbnU2UGdTMlpHcUpYaHFsRHdGMkZuNHJBQXhvbUR0Q2cyUUhRQW1NR0crT0RjMXdEdUF4TDFzQkFLMlhNSkIxZ0hnT3hrL1pQOVA0YW4rS29wOVZlRUp6MmdwbmhWZ1RSVVVCV1JwZUZlSGhwWDNoM1BNZFpySk05cXZTUmRTTWNYOU15OVRWSzZSNzJMZG1LNWNhTVJWYkVlTHIvRUNHY3dqMktkQVZGd1hkUkFGQk5Uc0pJWGJYRkpLVjBwYU42Vm5LTy9TMDJldlJPRWs2RWNRRWpCYXBRb3REVnNFeWZnZWFRNEJlRFVJNnQ1aFNqQUMyd1F5V3ZQSWZibUVaT2xBM3lpczgzR0J6SThVaEdjcThJSzN5RHpwSFBUNjRmVVdjb3gvVHNCNkJWdGpHdjk3MFh5dHduWHB6QW1JNDdsQU5saFBrZSt0WlYrQkRGU3JJcTJGUEtnSFdITGQ1OWs0dUpiNk9TZHJlVWJub2xZSU5DVGVnQXdlc3k4S1RxWjVKY0FqKytHOE0wY1pJTk5jam5lTjhoNTZPZzVSZDZGY3d6MUMrbkVwNjVFY09ZSzhRUEFWNkJ0dytCbUJXQVZwZUI1VXptQmZPUS9rellDQThDalBWL3E3SVNjcmVKTjBYUjgveDY0T1FEdGVWd0xKVVJwNWk4OEpLTEt4TURmSkdGSHBWNjhFSUtzQWpjTnoxNzV6V0lIQkNPYUlydEhrV1RLK1d2OTYrb3ZXSGRwUldXOHJXVDd3b3RaN3ZHdDA0NTFuNGVNQ3BLMThOOVRQR2toWmswZFlWNHBXRTE2UExsOU5RUHBFSXlxQWxHWlc2MWxqb0c4VmZxNThUVlBVYW5UUVVGMDBIQSt1bWNodFUzanFXUCsvTmZjMTJVd2RSeUM4cjBsVGhVK3BmRm5qSzlIUmptT2ovRUc1VUEwQkJJaUJ6Q2VtOGp2dE8zOG0wZ1BTUVJxWnhnRHB0LzNuQUticlhhQk1BVTNza2JMQ0dZeWYxb3lYVno1SE1kTUJ4MExaam1PSHY1djR1YnpITmFRVDF3UVphOXgxK1h3YjJxZjhYSFVuenU4VDN3dmtVMEFaNlR6MWQ3UXdYVFFkMXRMZTRWbFVmdTd2MEZpZmFKekt1UTNhcS95V01pSGxFTlZSSStaQkhvVHU2SGhLdXFOZ2U1Y3o3WENNUUJuOUZyTUVZWjZqaGNsN2ViNFQvaXY4UEJxTFNIK1NVd0RQb2p3M2xYMnNRUzZGNFZublMvbzRrZWVWenZXS25FdU9OZjVQWHNZNlNCdTU3M3VHRlg5UHNTVGxhVEhLVk9sNXkrR29XZ0tmaW5YcGM2UDV1ZElya2ZWNWRtcEc0TWduWXY5aUg3ZkcxRnB0RGVrb2pUNFVzbTRvUzdnTU9xQ2ZwKytrUDl5TDFJbFlDdG14MGFidTQ5WXpHaTFmT0pLVFozZGw4QVNBbFBhYlp6UGlUNmo4cmVPczhYTitUZWZTR1ZCbWJtd1Y5bVdJbjg5TEk3RE9kY0tjS3U5SEdZSG5hNjF0YnVEbm1zS1oyTkVhL1NoOHpvWHVMVFhvMHU3RURCMUpycGU1STcyYzZqTXFmeURRQU5WdFkvc0RoZnVSVjV1cExZNWowVDJ6a0g1RjUrSnFJSlQwVi9kbHNROWIyRTJYZ3pwZThvK0l5V3pNRmxlcFMza3NzVnRpUnhjQU1GbWNudnkzTUFNbkFQd2V6REJIZ2ZoTEFQNnprZTM5anpCaktqZktQaXdDOWFjQi9CbnlKbmdiT1dLSzZTSVBZTUF1djM4ZmZqZGlMUkxZalc2dkFIZzBrQ2I2QzdCbzJtaTgvaDdNa1BncURGQitHem55Y3diZ1o3MXZURm45TFgrZWpPbFBCeUtBWXg5ZmhXMmNUMUI2d2xFNDRjYTZBNXZubi9MWEh3UDRYMkVHOUMvQ29tcjNNVnplaDYzamQ1QkIrMStDcFhzbVdOb3FTOWc4Zk5uLy83OWgrK0FLdGdlKzdQVi9GMlpjNVIzR1N4bnJQc3pZK3lxQW4wTTJCbnd6dEhVT204L3ZBbmkzTlplTDA1UGJQdmFIeUE0RjMvZStmaGsyZDU5NC9UVHMzb2F0NGR2Ky94bXlGOFZUQVA4SWRoQWUrN3VmK0RzdkEvZ2pXSVQ0YlpqUjk5RGIvUllzTGZTbFAvTlU3NC8yZE9Sajc1VCt0UHdESzJPWXk1WU1LTDVMUTgwU2t1SmpVNTJ0N3plQUxoUzhhK240ZW1CL1lPaTh3K2h5cEdEVEE2QmNtVW9lMFkwK1JLLzhRbm5xU205RkNrVlRXTFRXS3RZWFFHamVPL1FTc3JKMVhoT0thNEp1bCsrOXZRMmpEK2N3eDVWbU9pMFJ6Q2wweFNoTkJZd3BwTlVpT1dsVVlkcEozaEhKY2NSVXBUMkZSZXFqVXJ0R0ZsRDJ2TTRGQkpTZVMvclhya3dyUTgvNEE2bUxmQlErUC9SRWZ3WFpzRVQrUjBINVkyU1FnQUtpcGlxaG9FU25LdlU0dnUzamZ1WmpvaUdJRWMyc2wzMWVWUFlpaGFJSmJHOXJwRzFST2t2RGh2bUQrN3pYNjdhTWw4bzQ1WVFlZU5hcU43VEIvVUJ3WEIzb3psR0NBbnZJaHRtWXZsZWROdGoyTW56R244SXczTmpIYW13YUpZejZmS215QjVSclFHRzg4QWdQQUJscEFOUDNjZTUzNWJNaVJiRUF1bHlURnIxVFkxUlBhUXZucFBEaTdQcDMya1R3bnUvRk5NYjZmQzFxZXcrTk5IKytCcFFEenlwMEMwRGFHeHcvbFE4Sy9rMERPOHJvMjZRWU5wU2NWcXBDeW9JQTZ1bUhHKzBYU2p6bkxDaUFIQnYzQTVDTnJSUGs2MFVJY2dHbDhYMHR6NjY0YnhTQVJybU9LcHYyZUVMb0g5OGhMK2VlNHBVeENuclJ5TWFTemxha1A1MUZ1ZXVkd1R3djVBbnc3K043R2owS3lCNzI3dzZRbllEMjRhbi9VU2xkenZaQVdzRjB4NlMzZEo2TkJnd0N4RFMwN3lBYkZtblExL3VYTk9LRlowOE5NaFBrTEEvcjhEMEJFZDVoTlpXeGt2ZEhnQ0lhZStsd1F4cCtNUStHcks1TXpRMUlWRm1YNzZndlFFMzB6K3F1MU1FTUN3cWE4anZPWjNUYW80RllEVWdLNU5RQXRqVlFwb3VUUFVKZXF5Q0hndEpBWG45Tlk2MUdZYzUvQVVCWCtxSGZGZEhacExlK2Z2SGN4cjJNeWxpS2ZZQUdMd3Z2YUlUV25uek52ZDZUaGJjdFNyOTBERFY2QWxuTHh2ZXBSTnFvL2F6SjM2MStiU0diS0gza0dzUW9UalZva003VytJU0NVd1VZUGNCWEJ0TkJWK2h4Njk3c1FzNEpPc1ZnbVpkWDdxanp6UlFWdnQwTk9BQ0tuRklGQkhWOXBPODhDeHNqWUZyejBIcDJZSjhrSTlvMjUyQ296a28vS1U5UlZnRWNBd1NLZmExelRwMkNjNXdNa0xJK2xMdVdXaDhHOXBMTTJ3U0dCWEZ2UElQaFVaVERTTitqTTF4eVNKcjMwL2J2UWVUTXJqVE1NUjFsN3pxVW9KK244Yzl6Vk5NaFNnUGdZbUE5bWVVUHlNWmUxc0U5ZG80eTlUTWdNclhRNkpRZVUvZzVJN0xaUG5tY09oRHZTVHRGU214a2ZzaTVPWWZyMTRKRFJMMWQrVGxsck1nVDBoVUxnZWNBbWFacDJtTFZvVktwckkzZUdaemtFVG0zWEYvT0krY1k4djlTMWxJejQ1RDNGM1NlMzgzN3FiUzFEVWcvbEM3cjkrcVVyZnRIWllpbzQ1QXZhcDBjZTNSK25zenpYYzBjenpxMEE0aE1JKytxc3hweG9LYlRCdWRhenBZYTc5UDRic2pMZGJ3OUdhdUdKZkdaQ20rSThreVRuNC9zMjdiOFhKMDVXR3FwZlVtYjE2aXNnZkNtSkErSVhBcjAwLytyUE04NnExZ2dTaU55dk5LZ2tCRXI4aUNMMXExWW0rNlZ5TThSMi9QbmRtcWZTeDFWZmw3UllRczZqaEd5RGZzKzlOeVlJbk16K3BvT3hVdkd5QklvZFNTZWZkS3FpV0I0NnZDcldOeXFRbWVqczlmV05wZWdlNjNtT1pPazZqUzFOUGdNenVsaHN3TnlPbldxbWx3WStUbGxmdEtBTzhqODdIR2NpMUFYMjJFZGRES013Uy94akUxM1lQZmJ2b2tjMFVOZ0FEQmg1MS9DN3FNZEtvOWhSamNDQTBzWU9Ic080SC8zZXVnaGRPVVJ2SngwalJCNENXWjR2QUJ5UkNXalRSZW5KMlR5RTVoaDdwUEY2Y243QjNmdmZSZzdkSEQzM3R1TDA1UC9BUmFOK2tYa1NNNDNZY2JKR2N3QXFHRE1udmVCUnNLUGtOTW4wMk4wRktERktHV1lBWG9QWm9BOEE3RDA3NERTZS9FSE1FSHNaWml4OVRYdnl6TUFQL0wrdjR6c1lSakxuOEFpWFJVTWZRK2w0dHdxTTJUakwyRDNBUVBBdjRJNUJUQXQ5dWRoODNJSHdKV1BiK0w5L0ZtWXdmK3YvWWVIL2pHeU53T1F3Y0dQTUR5WEM1aERBWUg5YnlQZlZmY3RiK01DRnJYODVmRHVJU3k2K0MyWThYenB2NEc4M2d2LzdEWXM4djA5Lyt3TVpwUTRrTy8ya1kwYjA4WHBTUUlaUHpYOC90dGRha0paN1preGRYWDFTRlVGU1ZmaHUrdTBTVS9XM3I2YzV3aXFxbkkrejU2bU5VL0J3WHMxSzRWS01sTnphaUV0clRMWlduK2tVS0ZYc0hRRmk1d3BoRmY1T3lrckR1RGVndE5pLzN3ZEdIbDFqRDUvYTMrWDJRT2l3U0VXcld0SDE4YkhYRVFjTk5hTjN1TTZUK1FkUlZxMGVla1pxRjc3NlJtVWtiSjd5UGNka1VlVFJwN0xlenN3T3E3M1hXbTZWUVhSVmpBQWd2dHRnV3prV01QNDcwdnlEaVBST0JhTkRLWURWWXhNWFhlV3FuYXZPenErZzFKUlZZV1o0NkZDb2hHYnJGOE5HOVhpYmF3QVRMcWo0NWZuRCs0LzhqNVBrZTh6NXB3bUFYSUFoRkdRTko1WFRYdXRDdm9COHRvdWtOT0owaURHYUZoNkxTYWppZ0N0bDFLZmVuakc2T3lDUnN4eld0SXBSa2FoSUJ0VkZNeFFoVm1CazJnNFVGQW5nZUxjNDY1Z3RlU0h1TWRyWjJvdG55OHJkQVlvalIyMXNhbmlVRE53RlB2QTI5RDVpQUk1N3pyZjY0Nk9uMWJtbC90WGdSTGQ5MVAvakdOUjcxYW00eTBBYVZFRzFmaEdJS1dwSE00ZjlDTzhnaEt0ODV0NFgydlB5UHlzdlovVmRvVVg4eHpUS05WVHp2aGM0TitNdHRUK3F3S1ZvaGpDSE5mR3liVGN5V2tLNVQ3Z09sMTE1aTFNcFpjZ0FtV0xKZW9SVVRxZnliZ3FJRXR5M0tnWUd1SWVVME1MKzZ1cEV2Y2h1a05YR3NjNFJ6elAzRmRzWjRLd1gwUXBUVzBqZzdMNkdWTlFrMTZ4dnp4N0NpYkVPWjdCUU5CelhTTUNCZnBaUmRaWkFWZ0lJQkF6bkNTYUdkWkZqWjZBbmRWejJVY0tqcElQeGoydjg2ZnJ3ZlZTZnNXLzlYd3FvS1lBczdZVC95N29qUUIwOGN4RUl6RFBoYWFyVlZyTmNhb2NvSHNRNGJQVVptVmVybUJuU3FPUFdZL3V0N1NYcFE3dEQwSEZJZU52eWdMalBPVVNjcysxOHVjeElGa0UrUFM3Q2gwaEQxZURKTzkyVE9QcFF2bzQwb3VHakZ1VTJyTzFaOWl2a1hJOTZRMUxrU2F4Njk5SFdlTnhLdmZFY2JSa3BXUm9xQUZ1Y1R5dHVvVCtzdjMwbnN0RnlzK0IwbGdCeUo0VWZ0VUNtaFZnbjNTVzFqZjJhWUtnOXdWZWxlVDRXTC9xRUpFSGg3VWZ0Y1lqNU5TdERTZGJQcTludFFmQ1NwM3hEc2pFcjJYczZoUkRvOThtZms1Wmszd24wdmtKREl0amhPaEtudGxGanE2aW5oS0JZdExvNUl6c1grbmR4OHJQYWZDcTZjT1IxbE0vVjRQSUhrcjlUUjB1MXNpeXQ4cTRCVTlxOEhPVjYyaG8xZkhzeU9kOFJ1V3FOY3BzRTZUbmxIVU9VV0tZekh6RjZQQ3FFVS80T2ZXRmFQeHRwYytPZXNlT25OWENRT2VsWm9Da1hKTm9kMFVPZzR3ZkVENkZjcDFubFdlanNTaTlKMk9KY3NBNi9CL3JwS09WNmcvNmpJNkhkZFV5azAyUitXWThyeXNZNWxMajU1d0RkUnBVWFcwU250OWsvTjJWdjJkek01aXdYeW1EU3V2OVNuMEZud2g3UncwMVdwTE1TZHhGK1YzazUrelBHSDQrcGx5VG56ZHRBMTNPcmhObHEvaU0vczgwenF2T3NwYlYrcUU0Z09wT2NTeTYvMm84UC9MZitCM2JxcDJqbnZ6UmxWSDJRSCtzbXFYbnZESTIwcG5vd0I3bFBxMjcyRjlSdmdsNzdFYk9DNndmZVQyTGRqYkpCNTFrQkJuUmp5ZzNyUUpOVEJrWU9FYXZHeWo1ci9MblJQK3g0U3hYNWozcUNlUkpLY0k2WUNJRjFvZzYzUWZRdnlJcllHckVERnR6dGtaL1hTbHJwT2pqTGx6L28zUG16eHpBN1ZTaVE3RCtucDVIREdNSHdPL0NETFE3TUFQZmI4Q013aC9CZ05jL2g2WEUvWlhHQkh3RWk1RFV3MGhEOHF2ZThET2dUT2ZzUnRDbEQvTFM2L2dNekVCYWRGWlNEYThXcHllY2hDV0Ezd1R3N3VMMDVIK3VSWkllM0wxM3RqZzkrU01ZNFB3M01HTXVJOUFPWU1ibUZGV0RmRmZ0QmN6NHlJZ0NwbWs3M3pMTkx3WEJ6OENNdHg5NG5heVhDL01KZ1A4TGx2TDRaMzArM3ZENSt4RXNXdmJYdlE1Nit2RitrcmRneHZjZitXZXZ3SXpISDN1N0xRQnpUUGtQWU1hU0QyRjdnQVlDM2h2OWw4aUcwaDNZWGpqM2NkTG8rNG44L2JiLy9Ea3NrbmJUWEhLZWZoNFdYVHoxK2w5RnZrL2xjZVc5cHpBajlhOTUyN3lQaEpIUnQxRXluNCs4dmtOLzk4cnJQa01KYkNqai9qVGw4LzlQU28xd2J5RmtwZWRSS2dnRWRTNGNmS2c5UDZpWU40Q1FRZVlZNnhPQnJTZU10dDZwdFY4QnBsSTBwSXlGaW5QUGk2M0ZaQU5vdy8rWjJsOE53VVAzRWxPNDJvSFJnYVNjeWpva2dYRUlPUFR2VWhwaE1RYW9ZbHdyS1ZLMGN5T3c5NWVnYWpOU3dqK1A2VmlTb1FhWmpoVUtXMk0rTk8wbG81bGVnZkVMR2hUVFhicmQwVEVCYkJVaXFKUXo3ZWU1LzkyTGFQUkMva2xqTEhsZTlNRGM4VDZSUjg4QVBHM05DMXhlUU9sTXNFSjJNcUxBU0pDZjBZTnJIeU9mdTV4TDlFQ2xMZTQvdHJQc3pDQjhQczhSSVp5anE2SDlJMzNYbjdVclN5dVVxZDgwL1M4QktxNzVqaXZ3NThqOGw4TG03dHdCYlFyUDRad1A5VTlCc2wxUjNoa2x3SGIyWEZpUGFidTA2THBRU04wRmNDNXp3TzhKUk8xNlgvWGV1Z1EwdE1EZnloaTJWcW9IRk9oSjVmTWFrTjFUa0ZtRVRyQm90SFlQbEliZEJYZUowb2hjYzFCUVQydUNNYjNJTEMvcnJyd0RTUjFvVW1yTDF2NGxMZUxlQUZLS0o5NlZ5NzE1aVFBZ2VyMkQ2eUR6VVRoZUJlQzJGL25rZldqT3U3YnJnSEc2aDlYcFFZeE9pTFNZSUw2dWMwcng1NTl4cjZjMHgzNEd5WGQyL0x3VUVla3l6Z1RZVXFrVFJiVEYxM2l2YmdMT3V1d2drVURseXJ4ZlV1SDF0ZytCZEwrVUdtYkpaOVl3bnFlQU41QlRQUGIyNWp6ZmFZNHdWdEoxOW9sT05ORnhRQTJSUUJtZFQ1cTdEM0ZNYzVxaVk5ZjlYUzFPWS9XK2JJSThORGpwSGlTb0hNR0UzYzZjenk2NmJKQ1l6T3YzTDVPM2NaOE5wU0JmK1JxVDFqQktLRVllRWtpTmdLU0NIeWthUS9yT2N4T0I3aVRQTk9ndGRYMDZkYXg0TnNKWlV4cWYrSE5Mbm9ha3ZaUy90ZS9zWStxdm55bWVoUVFDYitMQnlQb2NBWllpMGg1OTRLaFpCR3dpbnhpNlUxZHBtWUtOM084OVVGTnAyRTBBUUYyUGViaXJycFA3bVZ2dit4bExUcFBJdEM3ZTE4anpUMGNNN1hkMEhCaGJsTmJlcENRQU5OQzdNUWFDK0wzS0FEV0hPTzF2ejJsdVFKWlJtYWVxTDlWSzBKUFcyK3lidURkQ2ZkdXMwOVpGejRXM094aGtFY1pDMlhRSG1aOHpraGIrWFkyZk0yVXovMmMyaTVSUnl2djBrWCszbk9lTUljeThzL0xuYXZ4OFoxNm1MaTZjdldwakVUcWE5Tm1HZmw2czVUd1luSjJXa1NjVlJtcmt0WHdrOVpCdW52bTRFUFdoQVg0ZUhVZDVkUWlkVXBYL2NFN1g4Q2hpZitlWno4MHRsRTZkektDeVJKa1JxZW1vNnp4WStTaDFQODVOalorejhHK2VWZkpleXAydHlFY2FZMU5FZGxkRzQ3SnV6VjVGL3E1WC9xZ3hWZzM5a2ZhcG93Q2RER3RHWFBaVEhiTnIvSmN5WkpML2ZSL0diR3pxaUpmMHV0cWVERHF6WWhScUxLY2N6YUw2dVRwaTlPYStVb3ArZGYxSXpldndjK1VWTk9xcW9hZm1VSkQrOW5tSlJzVkpQTk0zS2JxZmxRZHpUMjFvSTJKR0tSZ2w3RVVnTzVqTXV2SU9hcjZiRE45OFlhQnRsZUZ1Sk5Ob0NicGV5K2hYbFNHQy9GbU1wVkh2cnV0UXpmMGd6OGRBRVoybk9IWTl0Mms5VlI4ZVU0UnVyZWQ5bkdFSjA4KzNtdmN4c29UTVZkUzVCK1ZLK1hjMU40ZmVtWXlmVGxPQU93c0hQYU1uOThqemNRN1R0VE5CVDl4eG1xYzhVc2MxcStBT1NwOWI0eXJrc01yWjc3MHIrNGh5MkE1TUJua2lqNmwrQk5nVkRZL1pWLytNQWJrOW11Ly9YMDRXcHlkM0R1N2VlK0twYkYrRnBRMitoRVZZUHZOT2ZNVS8veUw2MGFkdkF2Z2hMRDB1NzdtZGVvZS9Eak11LzVCUnY5Rm81bEc5Kzk3T0xvQ3pnYlRPRXdBVE53Ui9FNWJTZHczZ0R3RDg0T0R1dlNxVFdKeWV6Q3BwZXlrazh2NG5JQlA4R1lBTDdldmk5T1FRWnB3ZWZXZWs5L2NObUVHV3FUVVhCM2Z2ZmJnNFBXRms2eHZlL2l1d05NZGZnQmw2Q2FUOUlTeWE5VmVSNzZkZCt1ZnZ3d3pBQkZFbU1GRDhOMkVScmQ4QjhCOTZuU3lYL3Z4N1BzN1B3Z1N2cGljUXpJRDZIVmlVOFpjQS9BTE13UHB2dkMrdmUvOS9CcmJlWjk3T2JlL3pQbXd2ZlFkbXFIN240TzY5TXpTSzNLczdnYVhCL2s5aGUvT1B2ZjdYQWZ3TGIrTVhBUHpIbFdxdVlLbkhnV3k4ZmdhTHRQNjhqNWVHNmpWTUlMNkFDZncvaGtXcTgyNWpGU1N2V3Z2czAvSVB1MFN3K0xyUGk3QWNCZjRhRVc3V3ZlbVpGMUcybllPYjFqUG11YTd2T1JtL2I2WlpxOVR6RW5LcTNtVFFFd2JkYkNzb0JrbVFVMkU3TVB2b2JSZUJUTklWS2tGUGtRRTBwbkZsNnRib1ZhaHBPU2N3WTJUaElWWVRZTHVqNDBOa1pYd0NvODhVMFBZQlBKby91UC9FbGNZN0FEN1c4UWhRenNoaGppMkI4RUd3Mm9kRTY3VVVPVzh2UlVBaUt5VHZJeHNQaTJncVg2dFh2QjhMR0w4aEFEOUZqajZuTXNsNk9OY1RtQ0RjNjFPWERTTUVlUTZSQVF6NC8wK1EwNWNCeUdsbGgwcllSOXdUemZTODhoN25aZ3FQc1BiUGJ5UFAyUktXenBWS1hESzJOQVJZMGlYeWY4cHY5S0tuUXNRb1owYnJhZVlDR2pGV1llL0g5T2FzajQ0RGwzRGwzdGMvblk5NVR2Vjg0TzJleGY1dm1Lc2VDRmQ3UnMrSXR4dUJESUluRlBSMWZxS2l3ZS9oejV3SHVxSVJVdXdYMC9UUVk1MFJERHB2TVlWc1BHTWFNWjhBbzNsT0Z4OVR2NUx1Y0gxbzNHZS9hS2k2aU8waTd4Vk4zWHNWYVE5ODdydHM5R0s5MDdnbXdpOTE3amdlTlF5VDdoVm5wY1pEdW43YWY0SjRFYlNaSWFkYUFtek5WdklkSFVoWUNHaWxxSFQvdkFXdVFmWTJhVkZ0bjFVVnRkaHZyNnRsbUt2dDZXbFkrMWJLcWdONEdzZjRiQmZTTHZyYzF0SmgxZHJybmF2dTZKaE9XQmUxL2lGSFNBL0syVTRiR09YRU5RR3lZVFVCakxybkJEQ0lEbFR3M3pIZE1RSGVtQ1pXWlRyeVllWHhlc2ZVR2hrUUx3RDJMa2RhNk5wUDRmdWNkRnpvZlpKUnV2TGVSdlpKKzZNcGxhZHhIZ1F3U1lDQ3lqRVZXcVBlK1ZXbk5lbGpBcnI5SjYzMUFLREM5d2dVYXhhRHRZdzdnZlVRWTN0dGY0ZDVKbzFPZDhCNjNidnpCL2ZQT2pPZXBETzlhUStHdnF2Y3Y1Rlh5WGlCdmd5YWpOeGorMUNwT3dKaW1uMkNoaHNGTmdmVCszV1M2aEVsbUVyWk5vSDFYZW1rc0E1N2FHTmJyZlkzeVVnajZvaHBMd2xzUi93am51MGFEZEhJU1g2bkVaNHJsQVlPSUVRSU5mb1krNUtNTVFOeWlxNU56OERZNEpGNi9oTmdqRG9mVXVldndqQjBFMzNSMTZNV0hSMmZvOHkxM0RBUGpDSWwzWGsyTDJWUzBtSEtUTlNETktVejE2L2FMK2M3bEY4dlVERzBkQU1HbU1DanEzeC9hQjQyeVQ3K2VaRnFXcC90Y3BUc3d2K3Y2cnlSNzhobmtaK3JuaFF6Z1ZDMnVCcVN4ZjNaMjhqclFSa1RjTndVMlZDL25NdVZGNEVYcUZHV3RKNTBqNDUvUEpzeC9UT0x6b1BTTzliSDUxVmZVZHFnam1Lc2w4N0JhZDJWRjhxemFxeGxIUVYrNUhJMTliUExlTWFEUEIzSHBqeVkvRHpSdVFIOVBPb2twUG5Kc1IwQmcrbEt4elk5VjRydnFrN0ZaNEZNVDRkU3RmTU1jNDNWWVpBcHd3dG5xckU2WktDSmlHTWJlS2ZRV2Z4enJRY285ZVJyNFh5eTU3V29vYXVvTjlJSkdWOHMzSWZjazFQZmI4bzMwNzNjc3Naak1vTEYvczlhKzIyTGVuVC9Bbm5QdHh5NmtyeFQwVHRVdjJXL3lNK0prVVZaZlIzcFdrVUhLODRZOGptdThsQlptNFFOOGJzaGZsNTVQODFKalUvT3M1UGVySVVWU0gzSzgxVVdpQTdhTzZpay9HN3dhZUpIVFZsQzZ1VGVVM3JIZmhSWWhEOVgwNE5hODZWWVYvTzZqcHZJT2EweXR0NnVnbkVMdmQrRnJTRXhzMUd5QjJBVCs2M0Y2Y2xiL3Y4dG1DSHNaWmpSOXdOLzVpbk0yUGRqV1BUbUlRdzRQb1RkbThxb1dSSzlsMkJwZVg4WmZxZXZwenllTFU1UHp0UVk2OGJlczhYcENlOFVuRWxrTUJsR3Nabjk5NC84Nzg4aFJ4di91RFo1bFlqaUpZQm5jbjhySjRUUDFZalNTd0FXaTlPVHl5MGpQM2RnUnNzcEREQStYSnlldklJTUhIL0orLzRGWk9CdEQ3WU9IOEkyOEJkZ2MvRTJET1RlOWUvZVJ3YVZPRWVQWU1iZDd5RURlN0UvNXpCajdtZGdBUG96NURzZGErVWxBUDhVbG5yNUhMWS83c0FNOEQvdy9uemU2MzRGWnRSbWVSdVdSdm9KYko4Y0FOajMvWEFSMThZZEF1NGdBL1F2KzFqM1lRYmtGWUMvb1FGNWNYckM2T0lyMlByZjltZmZnOTFsUFBYK3pHREczVWZJNmIwWm1mWmxtSFBEQ3JZdUsyU0RNUGZIQlowVkZxY255MCtqZno4dEd3aTNNdnBDSUdzSWI5dlVQYXFvSW5DZCttNGduRVp3Zk9nNUJmZjFYbGE5MDNjR2dON1JQWVZnQ3lHU1NpcVFEUklFNFlxN1c2V1BxcXpzSU44cC9nbWZVd0VtdEtjZ0daQlRhQks0VnFWeUpjL3VkTmxycmlVYzBSQlhhMmNvcmRBVnNuSzhoa1grMGx2N0FPYjllZUgxZjF4YmV4ZTYxUE54M1puSDNxSDNsY2E2TlhLMDhKTU40QjNuZjRGOHR6QU5yc3d5c1VKNUw5aXlPenArNlA4cTRFeGVTOW5oQUdWS1VUNHpGUFVSalh5cVRLdXlPa0hPeHRHOFAxakxQSHNHcG5YYkF0amt1aWxmWHlBcjBaZXc2QVlDS054bk16OXZWL05zeEw4VjNsY2xuM01UQVFpMm0wQVhIOGV1akdsZGVWNmpGQ2huekdEUmlGRmhVd0N6aUVUb3NyRUVIRXR0a255T3E0Q1RqLzAyaktaY3ppMTZjZUx6cHFuODFzaVJCeXhxS09mLzNBZExlVGJlazd5U2Q5Z0dNeGdvbldWMDlJSFVyZlFKUVBLVVo3MDF1WFhTK0J2SUdYcUF2Rlk4SDR4c1lkdTZGcW4vUWhkN2dQWThlOW9DT2VOQUF0bzdpMG94TnhMN0FBQWdBRWxFUVZSZGh1ZGpoZ1B1aDVoaXFRcFN3cUxkRmF6ajM4ci9hbmR5cjZSdjBhQkZNSVg5MFRWay8xTEVwL1NwVU1EbXcrbktXWnI3dURzNlptbzVPdjFjZFVmSEZ3M2FySjl4YmdqNE1lbzVwaERuK3NSMTFLaFk5UUJ2OGRzZGxIdUQ1NXpycTNPUTluYm5LZEhtT1hLWjl6S2xJbXNiUGFUNWVYRkd1eHlsQU1qY2R0bVlyYnczam92dDgwNWF6aDhnZ0NCS0VGajNIZ3ZuVmdIcGljL0hyZ0M1dWxjTHdEYlFvVFFQNFR4RWtCZnlHYzlQRVNXbXhmZll1dkxlcnJkSk9xdThaOU05OEhwbWRINFMrTk9GU05uS09OZnk3cFdjaFVRYjJHY0ZYMnVsOHIzS1d4TVlMOUMxVlhCN1l4SDZBdlRYb2xVaWpWYWF4UEVWYVl1RHJCbU5MUVJwRTNqZTVmVEJOYkMzMXdmZmI2dXViNFNNUmVWNzNiOHhjMGVoQjlUNDlWZ1FiRWhHVXAxakEwaEtmcTUwZzNPZ1RoUnFRQ0YvaklYZmMyOFd4bDdLSUFKaUFwVjl6NzdLTzJ2NW05KzNoaDRkQ1FxZFUvZE9WMFppeDBqT2VBNkxJdjFONXlqdzIxR2x3WC9qTXpXQW1YSUVNS0RQdWs3QXpHM3hPZVhueE0zWS90by9vNk1qZGM3azNNQTVjSmsweXFVeEE5YWdQQzk3Z3JMZFJoMDIwakRoSGJWTUU3Mm9LeDg3K1htODNxWFcxZ0dNRjNLZDZheTRGcmtaS1BuY3JMT29ZUEx6TllDelNFOGEvSnhabVZRWG9XNXhOYzhaeE5Sd1E4eUF6NlpNR0NKdjBOQkJ4ekx5ODZoSHFTRXlscVR2SU91RE9oNDFxQ2hmaVd2R0NEQTF3aXFHb0RxOXRwdDRyOU9aSmZyN094b0FGWFBpK05tSGhIZHdQTFY5VUprYnRyTURKR2NmdmFwRDVYcktndXBzcEpoVXNTN0lhNmp6MWpMYXhMbHRuVGZLZ1RFaWU3RDR2Q1lEOGpVd01EMWZ5azlWN283R3MwanplOCtNNlVlZytTclAxV1NrZGVWdjFkM2pGVHBBV09QUXR1Ny9JVHFkWkwxRy94TS9rMzFVVzRmb3lCWWROaUorMGRvditpejFjNzFEbXJJV0RhWDhidElGWjBZOWY3NzJLYXRNWE8rQjB1TG5lbzZhY3p1Q254ZEJqNTA0UE5UazhpQi9yTFVmblZ3MTE5V3YwcG9pNjRYNm1jcFpyWDRTUzZqeWMvOU4ycUZPbEVrSDUxcDBrbGtzOE9xbWJxVDlHUHJlMjB6NjloYlBwM1hrMmFtY3FXSnMyaWYvN3JhM3UvRFBoNXh5QzMxaEJ4WkIrVm1ZOGV5SE1NUFl5N0FKZWVxVmYrenZuUHYzSzJTajNHT1VRdjRNWnNEN092TDl0MzhBQTJTdmdIeW5MenNTSWl6aGJSOTRYYytRZ1VwNjNISEJ1UEN2QUhpeU9EMzVDQmlmbXBmR1IyOGZHOTU3Qm9zQUhzMElQT3FaUmdlbW5xT0FzdWVmZndpYm0xZGg4ODBvYWhwNUwySHJ3WFNkak9ENk5qeE45OEhkZTB0dlp3S0x2djAvdkowM1lOR3lUUGU1OXUvZjlOODBzdS9CRFB2ZlJsdFJSS2lMLzc4TDJ3T1BZZEhJSHdQNDkvMzdEd0g4RG9BM0QrN2V1d1NBeGVuSkkyL3ZGUURMeGVrSnc5cnZlTjFjNjJmK3pNc3dRKzVMWG45Y3ArL0JJcWQvejhkeUI1YWErdXRTN3gydjl3TWY4OXZJd2o5VGdiOFBtMzhhR1FpUXB2M3FrZWVqN29EK3RQekRLcEZKM0tRdVZlS2xVS0JxM2ZYWGpIQ1ZaN2Z0RzBIV3BxZFpqYWtNL2EvOWJvRTV5TjVVbXdUdUlyVlZsOVBMS1dpS2VVNnp5eFEwdmZ1SUsyTkxZR29BTDZqQTBlalZXNnZLdkNoSU5CamhXWm0veU13Sk1oQjBWNE1tRFRzRThpSWdwVUlVd1dzK3AwTGNrSWZwRmNTb0tTRDBHa2IvQ0VxdzM4c3VHMkIyT3dmeTU1WnFpMUdOek42eGkyd1FvV0RPS09hekx0d0pFNVFrQmNzMC9UNlZUUVhiZS9NZGdJQW44d2ZGUFprRWV4aGhDZW52dERzNmZoVG02dzd5OVFPY1U3NmI1Z1ZaZUNOb3NWWGhtS1hkVGVkYkRZeXFQSzJRbmIxbzNGUWdnZnhzZ3B4R1JzK3BScEVSUkZHRktpcmxLcmlxVWxVRGhCUFFGb1Z6UGpQUDZlVTRCeTNGY0lvc2UweGcrNUh5SUlDMmw2ZlVNVUdXTVdhd2MwUGo1d3o1THZIa0hSdkdEL21mODhTem1BeHBEVHBLNVpHQ08zbENRU3RkYVdTVWRFL1JVMFdycFVpN3NraXYwYXZ3L3BXRHBJeUd1SnhuSTlCdDZkT3NzN3VPZWpKUGE0M0NlT0YwZ3VmOFFtaEowZGZLdXVrZHVRb1dhcVJGTFFWcERhaFdaWHJpNDlMMVl4czFuZzEvcnFkY3drRlVVWHFaZ25MbXoxV2oraFdNbTRmVXlhcWt5ZmlCVEV2Wkw2WVp2SlRudUZkWHJwQ3Z1aktkSnNlc1pRZDVuK2s5N0N3RkVGRVpTd1RxcUhRREdUU01BQmJ2TnRJTUFURnFPS1ZNN2JLSE4yQm5SOU4wcVlGUmFWSWhYNFY1Vko0Zjl3MkFBdlRRK1NyQVV1R2JDanBkU1IzTEx0ODFHMmtIMTYvbXRNQ1NES1hJSUQvYlpORW9WczFJb3VjbWpUOEFJTWtZSmZTT1oxL25VNDFoa08rYm9Ja0FxR3gzMVdXRFZBSW9XKy9MZHdXZ0V2cXZqakE2bC9GTWFiUnZtaXYwNzIvbjJCZ1J0N1VlTUNURDE1N1YrWkhQNHg1TzhxZnJKeXRrV1NkbUpGdWpsRmVCK2pwRk1KajdjaFhXQ0pYbm9wTmtCUGYxZkE3T283K3J6aFVLekkyYS95NUhBYVV6UnI2aDRKbk1wUlkxYWxEK2lRYnRWZ3E5NGo1YTVMMFQrVGxwVnRNeE5nQ1NMU0MwYWdBSUlHblVxUXFEVkZlL0VtRDBYSWQ5ZWkyWlY0SGdlVDhLcTNDOENETEFMWmdNQVdTWkN5aHBlSlJCZTlIUTZQTnp0am1iVy9wSjNnZE5SN2tEbUNIa1NkVG4vSDNLb2pWK1BoUzFuZ3lYTmZDNEV4QmIraC9icnhsZytGTkx2Wm4weFZxSHd0bFBaMTNrVmRZeGxYVWtQMmNHSjk2bnJuWHlidDFWNXltcS9ldFZaOWZZS0U5UjR3UjVYM0Z0U2VEbmNSL1UrUG5LNlVUVW05YklSaVoxRU9ZNXZRcDFKTU5QbUtkcFZ6cUlyUkhvbWZlVk5GekhxRVhYVTQyWHlvK0x0b1V1OEJvUFpoN2hPMnE4WGFOdkRHVC9lODd2Y2UvSkdpd3I5ZlQyVk5DcnlYTlQxTjg4RzBkSk03a3Z1SWNwUjJ1L1lyUnZHZ05LQTRmSy85Zmw1MXM1Z2JYMGVPWDFrSG5xTXQ3SWVXelJsL1QzaUhGRWZyMnAxRkxxSnAzVzlVWFdOWlNKcjlEVmdPTGU3dDZjREl5bGNMN1NQY2EreVZ5MzlsNXgxN0wwYmVoNmptaWtqSEl3bjExMU9aVXcwSjVqbnAzbWZMbWVWdFB2aWRQVitEblBCWFdSbS9CenBZZFh0VFZwckpQcWVXbCtLdnk4T0pOaDNUaU9LQmNsdWlUdFJqMHpPcEZGekRQSmczcjJ1b3docjlITzhOSGNLNjA5U3g0MzlHejhYK1Y4S1RYSFFCcm1hNFpsMWRlcUpjaGJoYTR6aFJuRmJ2blBTOGlSUURPWWN2RVF4dGdKdkMwWnRZc01vaWZHREZQcTMwQytKL0V0QUUvY0FIaUZ0b0gyczdBVXdueU8wYmxYTUdDYWc1MjR3WmFnNTVtM3hidGdwelRvamkxdTNOdDBZR2g4M3JhOEIrcy8weUl6WGVXUFlNYlQ3OFB1K1AyWEFINGZ3RjhBK0cyWUVaZUcydmVSbzMxWlhvY1l6V21naEtVb1B2ZDUrM2Y4bVI5NlBSL0E3bDc4RGpJUS9CNHlTUDhNbThzT3NoSGt3dCs1aEJsKy93cTJYd0F6cXY0dnNIVFBDWVR5ZnA3REhBNFluY1RvcnJXL3h6dWw5MkRwcjkrRlJmM1cxdWtDWnRCOUN1QnJBTjcxOWo1Q1BoUWZ3SXpDTEZ5SHRjL0RoOTZmeDdDOXluR2xQc3U3bjBiLy9nTXRuZDNOMHFNTlZPRDhaeVpBMVhYYjZCRmpaL1ExWVhLTmt2bFY2MFE5VGRtWXNza0xyMW5HQ0JGeHJueWNhcFNwUGI4cm9KRWF2NWphNmN5RnprbHRMb0grL2JZVkFaWUs5V0YzZEh3WWhJN1VIb0x3cTRwVVpRN0k0SnZSVnpvZkZVR0tiVi9BMDZaU0FBelBVb0NoTXF5cHZHcmdYQUs1VUNwNHZibnh0dWp0eXp0ZUQyRTArQ0dNMWw3QnpzSytLMXVIbmFVOWk1NXlNOWhkc0ZUYXlDTm4vaDZCbFFuNlYwZEFuaXMra3o1ekRhbUlEM21NdnVyUDdnTjRoWDNpZnZUNkZCaFBudmVWdGFRaVNtRGpZRzZHSnhxbHovMjcvZm1EKzA5aDl4US91dzRneGxKVEJCclBuTU5TdDhXMk9EYXVFNTNONkV6SG9ucy8zZDJNRWpTSmdMaW03MUtRblduZCtFd0NhL3huT1g5dy8zeWU3N3RtU1Y3NnlNb2g1YjRoQjZ1YWtZNE9FM0VmdFlyU0FVMXBIUTFEYkMrZU42MUhvM0RWbVNTZHY4aEhmTjAwcW8vdnhlaWhxN21sRTYrbXZoN2FMMTFPdjYxMzRjVnlDTnNYbXZXRlY0R29ZWHUveS9meFhLc0V4V3hXb2VrSG5hZXlKUWpYR05zc3pPdSs5MzlIK0tzNlNiSU9HamtKUERJRm9vSmlDOGplSTcvb2NyckhBb0NBME1MUTF6VUdlTHJJR2xSRUU2OGcvZWJmQVRCU1kybmFOd29PdURMZk0yVEszeGVWczZoN2Q5VWRIUjkwUjhmNzBpL1N2UllReG93V3lUbkdsZXlKeXdHVUJhNThQbWZ6SEJta2lucHlVdk42SThCSVIxcXVVVXpsU3ZvVTU1N0dzajJDUEtpQU9uSGVmSTh1WVd0RVBram5KK1hGN0N1UTc1QmRBNGlnT2FSZnBNOEsvQ245NFZpdTVIOU5rYzk1VGdDUzB4WEtudVJ2U3BkbityMkFMbHIwTy9hWDY5SUR1eUpOYU1qTkxib3hCc1RrZk93RWVTYnVGVDZ2QnFEWUZnMGlBRklhVFBJOThwNWRYOStMK1laMHBjK3IrSGxzeXNvb2pibWtRWFI4aWZPdFY1dEEzMEZKNjFMRUJQOW5QNVFPeWJNczZ3cjlRSGlHL0p6MWJYUnFEWVg3ZDF0K0V3SENWdDBLVWtjQVdTTUp0ZDlOZlZEcHRJK1ZlM0FXbmlQdDJKanV1RllVK0cwVU5STHhuWnF1MEhPaXZFbHA2ZE5qNUlXS1BrNCtrblFBLy80QWhuZTlDc01KUHd2TC9QZWFQMDkrcjNTOWQ0YTlYOHlpRWZsNWNzWU42OFBQS2VmV3huK0liUHlNcGJYV21yWXlaU2dKL0hwUW4yaWNyMEwrY0YxN1I5OUJrSFZDMlVHV0RmWEtBZW85ejJEeXdJVi9wdnhjSFhZampWWkgxM1NkR3JKK1F2Nm14bHp0SjBGdXBuSGVGMzZlREFiSTgxMkxvcnFDOFhQaUR5cy9qOUVZcS93ODhaUUJmc04rMU9oaVdvdDVhUnhoUmlhK201d0YrQU1raDhKSXV6a1hsS1dwUjBlbmUvMHVuc2NldmFnVWxRVzBUdTdUeUo5YStnam5hb1c4QnVyVWVTWDFzWjRrRDFYb1plVG4zSU5YTUxtVCtBYm5jNUFQUGM4aWE5Y3FPdWRSenI4V1RxZHR4MzVVOU1UQytVUE9iaXdKVi9MbktDTU5HY1JiZW5LVmQ5WGFEVHBQNU9jdDJWTFBmZnE3Z29HcFhGNHRsYm5pZTVHZkwxMi9xVHI1YnREUG0zTWloVEs4OG5OMTdrazQxazEwODBxcDhlNWQwZ0ZpbUkyMWkveWNkcVdFcFFiOUY4ajJSdkpRSFo5aXFiMXNielYrTGlYS2NDelVpVnJYTmJGL21uRmtzTWg2QWdPT0ppUHd2WmFqWWRMeG5YZnRLbVlPczJFOTZWV0lwQ3ZjUXI3eUlzbG44d2YzbDVQRjZjbHZJUnU3ZU1pWnR2ZzlaQ1hwRlppdzlSYnY4d1hTZmJ4VDVMdjRkbUdwZ2wrQkNXeS9lM0QzM2w4RDdVaGJmLytiTUFQMFErL1BCWUJua3VvM3RTZnZ2T3FEZTR4OHgrNks5ZGZ1SEw1dThmWW1yTi92OEYzRkZNWTNxSitDMHk0c05mS1ZwemQrQ2JaaGZ3b0cwbjhMR2REOW4yQUd6emlmRTFnSzcvL0tQNkt3OXRldytYM0hmMy9SZjc2TlBJZWZSVWxZRmFRNVE3Nzc4QzEvOTQ5ZzgvNWxXQlR4RndGOEZjQ2ZBdmdiQUI4ZDNMMVhwTXVwakoxZWRVdFp1eW55M2NuUEFFeHJjKzFqNWQ2N0ErRGh3ZDE3RjR2VGs5L3crWHlFbkI2YUJtZUM0d25zbEQzTnlPM250bmMrTGMrL0VQeTY2WHRkOXR3aHM2VWdmeTJoVVpqMFZuZGliS2lQNE9yRys2UEN1K2xPbUEzQ3lHZ2hzL0p1T3J0ajVrc1U1aG55WGFYcXFRcVVkNVVWUUF4R3ptMFFOS2k4YW5TSHBocU14aDhxekl5dTR2NmdRYk5uQUphNXBvQ2tVV2tVOUdjK2R2WUZ5TWJHS2JLREVaWFRGdUNnTkJtb0NCMThMb0NsckZkVGgvQzlRd0FQdWIrNm5PYm1DdGtCN0pHTWk5OHo5ZkViM244NlphbjNKUGtheTVuTWJkTkxUb1JKenMreUJjeDJSOGVmUjQ2c1hzTWNnZzRBZkJUcUo4ajBiTjZPTk9WYXpuUWQ1K1pKK0JKeWF1cWQrWVA3ejdhaFJYRmRodG9mVVZjUktROWJUNTZqRkJXTHZHK25DSGRGUzEwYVFhMzNxTVNVaVl6dVVlL09IcWhKTUdPZzcxdmY1OWRaNUlBSzI0QVlzTWFDOXAybEt0K0g3UUZtRjJCcVdNRFR6M2M1OHJDZ1EvTjhaN0hTTEZWQUNKS01jaGdVZzFuVkEzZHNrZk9TOWtWanJhY3d1WklneWpOazRJL3lQa3ZCRTlIZ1FadjRTRVVaMTgvVjRiU2FXbGJvVWRwdnZvNjgwb1FlMDd5UGpqL2MrMXduN2lIS2diMzJBbzFOanE5RCs0djdPU2lEdlFnQzM4TWFlYmlRdjJ0em96U1VBQ2lBNGo0NWJUc1pDYmVrU1VCV3dPbjUvN1R5Yk8xT1dBVWZOZFcrcGdGWGZoY0JrR1JVSFpEUGdKSXVxYkdHMytrOEFSa2M1Zy9wSWxQanE2d1dJNUFwMTlTaTlsYUJCbWpobm9POHgzNG1oek9SZWFKQml2MWV5WnIyN3NBUzJwOVNJNk0wUUV3Z0tmSmxMN0UvSExmdVdYVm9VUnFyaHZVSXhMVkEybXFSczBXNXFCVWRvV2toU1lONmQ3b1RBTWNJK1RQS0ZqNXZ6TjdCODNldCszYWZrNnhmQStrVkVBWEtQUWswbkJGbFAwUUFVNitMVW1OUmtzRmJjdWZRR0s4ekIxM2RDVUZsMmxIeWdlb1BRWGJrNTh0d1p0Z0dlZVJGbCs5K1hzbDNTbCsydVErYWdPZHpNVHEwZUdkNEp0RkR5aEVvOTQ3dUxkM3Z6eDNqaUhyUHdETXhKUy8xQ1Ewc09ZUmxnVk9ES2NkQ2ZZUE9IRmRETXIzL1NSNTNNYlNlZ2FlbWMxVGg1NGZlUnpwZkZCbWlLcndzeW1qTVpyWFM1NFNtVTVhOERoYWh2SGt5bDN0elkxc2NNL0lWZE9UZnZONkdPalNRblV6SjB5aDM4T2RzbnU4SXJmRnp5bFJBNWpYc0orZjZtWCt1em1XTXpPWjdORWd4c3BlOG9MY1B1cHdsSUdhREFWeDNFQjFBSFdHSCtIbWlsVjAyYUVaNkRYbFc1em1OSTlDbW1IMnBxQ2ZvNXlseUhabk9hZVlpZnA2aUNhVS83R1BzSi85bnRQWkc3RWo2MlFweVlIOVQvYUpmeGZ0Q0tWTTFyL2ZSOWl1eU83TjlySkVkdlVhWG0rQmhqYnAwM3BYdkFuMEQ4Q0F1c0tHZFdtblM0Qkg2K2RiejBQVXpjYkNRZG03THo5ZHl2b296S0RLMHRxRjdLODUxYjQ2MjZBOGRrcDZMclVmN05uQzJlSFkxQlhiTTdNS1NzSjZiN052V21pdldzWUcvemxEU1JPcGlpWllnOHhLMmtjYnBQM3IxM1ppc21NUjRMemZ3OHhxdVdCc3IrUjkxc0NHZFArSWtoUXc2OU01MTFzbjN4TXZ3YTNubkQrNzNBallyNDV6QjdHTnJBSS9uT2VQakJNQnlzamc5K1hWLzl3cG1YQVFza3ZNRG1LRlFQWWozWUViWm92TitsKzdudlNGYW9ubS82aE9ZRWJBNVlMLy85NXNBZnQ0LytnUVdGZnRRbzBmRE8xeDhJQXVGVnlHMTlBNGFFWnYrSGR6UXV0SFk1KzFwK3NpWFlDRHpFeHFsbjBmeHVhU1JlWXA4N3dhTm9hOEIrQnBNR1BzL1BkSTNqdXVmQUtBQk5KYW5zR2pZZDJCM0FQOTdHUFlDK3dBV1RYc0w1aER3YzdENS9nNXN2M3dQMlFDODlPZjJBZnladi9jakd2RTNqSHNTakwvN01DL1BSL0IwMEFkMzc3M2ZlRmZUaGxBZy9TMlVxY08vRDd1dnVqQkdWKzRnbnZqYzcza2s4S2ZsNzJHNXFhQ21SaDZVeHQ4RTF0MFFpRS9HdHV2VUlYVXhxcEZHcHlqUVVJRWFBdE5tUTk5cnY3Y1UrQW9hWEZHNmlqVVNnZmpBKzMwNUQ0WlNaRS9xTlV4d09QZDNrMmZZRm9hZWxJNFRiYUJmZ1I0cWU3b2ZhRGlqVXJWSjBFZ2VzbDFPNTB3ZVN1V1hpaXkvMHpzdUxvUnhxOEpIc0NRcW5OdUFyL1N3anRIazNGZTlQZCtad1hRRm82WEwrWVA3ajBXQVNJSVNNcTJkd3U1SFpqOFAvYnNVdFFLajU4K3crUjVCN1ljQ01qMUZ5UUc4TzNDakx6S2R2dzB6OVBXOEI1SFRHNUhmWUc1Umx4ejNEc3hnU25CQWdYK216YVQzK3RNeDV3dVpuNThGMEVjOXEwY1Y3OU11YkI1MTMzQmY2OTdtYnpwZUREa1g3S09NK2xXUWhxVklNM1lkNEx6U2Z0cmpBcnhSV2VEOVlFblE5dGNHUFRxM2JEdEYrQ1BUZ1hYNG9ieWdzaWVRWlkva1BBSnNEd0ozRWprL1prNjcwaUJIaHczQTkzWjRsblBLdTM2cGNPbGVVY2NCam1jRk8wODd5RkdPc1I4OUhrTkZmcFBpN0RSaTE4ZmNNenJLYzF6L3BaekpmWmdzekxSd2FsVFFDSXRvQ0NtY0lTcUtreHFneUkrYWF4TEEzUUxZQ1FDWFJpZHJ4RWFTTzVBTmZuUllKSzNtT2R6M3ZpaHZqSElCMzFNUVpaTVI1eGJLL2YxVXhxRk9QTXlNUUtjUnRrOGdYc0VhemgwTDU0LzNYd1BpUmEvZ3Q0SThBaGdxNEFsa1hqcEZ1WTg1WDBvck9LOTBkQ1lQdm94N1ZNQXNqbG5QaFlLOCtqL2IwLzZsKzhWUjdzWGQ4SDlLWis0L0NieHNHRXY0bVJxNVdkUm9WUU00MlBlSjh3M09HZVVEUFNlQThPa0FYbXZkMi9LdW5qRTJmSjlrbEhrLzdYdFZOZytHRTRKMk1ZcU5SbStWMC9UdjVMeXdhVHkxZG01U1JNWlZPUzhhak9MK1JzMndFK3JWMUthYUZsYWRNSUJ5Mzl3WTA0Z3lqWXlQb0dZMHNxWStQQWU5aVdjT0tCM1c5T3lTeGdLWkg2cURDdVdiQkV4dTI2L2FtbTdxdDg3WEp0b3RmRWVkTjJJcGVCTkV4aG95N2p3SC9YY1RnSnRvM2p5bjFOOUhsalZXTUV4Ujc3YWV5ZjhYeVBUcUhPNVEzR2lMUEZmbHlxWXV0d1UvSjk3RlRCY2NiOUk3cGI5bkZaNlc1TzE1eFdoYUFabTMwZmMwdTh1TXVvMS9GK1ZkOHFTWWFZSlhoY0NmT1VRcEQxUFB1b1VzYzZSVTJSdjQrUjFrZnM2NUk3K2NJUnVqZVJaNVB6TXpuWENOVWpZV3RQazVhUUZwWWNKTlVEZUN0dWFZY29NNmhxcWNvOUhFaWl2RSs5b0xKNUdLek5tamlRaHJMKyt3enp3amlsZFF4bFE2bjJnWjlkclFUcEtieC9LQkxmajVXczljVnpFQ3kzYzlKNHg1NmJpZkhMOENEMC9uVkkwZGYwZjhuR2UyY1BCb3ZNSitYNHYzU3IySlR0Um8xblVMWldJNTIycThTOEVWNkorbmF6bXdoTFpWcHRhb2Z4YU9VeDBrMkw3aWk2bGYxNWtUMlhlamduRUNEK2Q3emFBYzRUdFJqMk9wN1oza3lEbkV6NEd0MG5Eck0rUVZ6RUEzOUJ6UDJrclBLREs5MUVDUU9FNnVGV2xxRXg4VW5aZTQxQXdibkxyR2xLNTBta3FPY2lqeEVmTHpSZTJNMWJDUVJsdmI0dTA3TUFQd0JEWTNqOEozNlpwWDBXVjJZYng1aFJ4WW04N0dGR2JnQTRCZkJ2QUY1TFRQRCtFUnJrd3RqSXJ4RjBoR3RJOWh3T3NTbGxMM1hWaWE0L09HQVhaL2NYcnkydUwwNURWWUpPOEN4dXkvQ0JQNktHaTBDcFVaZW8zZDBpL2RZTnRNMTN0dzk5NFZqYWRqSWozOUdhWWdZOHJqd2NqVzZ4U2Y3N1gvdllJSnR1ZXdkWG9HbTllL2dxV0UzbldETWVmekc3Qm8zcStobmFyaEVEYmZ2QnUzSmV3dzh2WmRtSkgzTC96blQ3MC9Qd2J3dS83M0VwYUcrYXV3U0xBMXpJai9DV0FwdS9uVGF5UkUzYnJ4ZDlmNytBWnNQL3d5Z1AvU0hRVnFKUXFQaC83dTUveDlGcWJ4NGI3dXpaRkVkeC9FN3o0dHo2OE1DRUZqU3dTOXJ0dU9DZ29rK0JvbHVYV1pQN2pmU3BYR1BrMXJuMWVlb3lMR0ZJd3o1SFJKQ2d6dHc5Sm9WbE5jWXppYXROYnVxSEVQQ1J1dVdCekFVZ1R2aERwSlJ3bGdSV1pKd0NVYWV0Y0FtR1o1NnIvVFQ2Vi95N21sODZ0RjdNNlFRVlpWM0ZmaGg0SUplZUFRb0JFakdoTGdoUXpjYTZRVW40bEdMYUFQOWs2UTA1TnJ2ZFgxcXMySkNLeU02S1hBZGVCekVlZUl5dUVLN3V6a1h5bUF6YjZjK2M5NVdFc2FQS0pnTytyOFN0OFZXT250dTdtbEd2NFFsc21DNTJNRzQzRzNBeGdDbUdINE0xMU9nWDBJMjZ0VEY4eDRwMjQwaUdGZXBnR2w0V28xNGx4VFdDMDh1MzNmN01GU2JSZHBaM3dkZHp0THpScFQwcXlRNVpHVUJ0YUJKSFZlMHZhV3FLZmoxbk5JSGp6eCtsSjZMWm1MWWowN1R4TjhYWm9aRkR3Z2d5d3NhdHprK1RtSEd5UnZxdUQ2K0VpWG9wRkhuNHZHa1FUd29qVGlUU0NwazdZb0hQZEdIcUdBaFplVXdyT2hDQkdzSkhCSDQ1blNPSlVIVTVRaFFqcW5Sai9pV0JWazFPZG4vcHY4S2huUnU1Q3lVTjVSQTE4dElrUC8xNzBRNTFOcCtreDRVMXBuWDJONklKTVBWZE9mK1JoMmxZY0o4RlNrbXV6TVdRUW9VeWhTU2VNWjFjaHlPczlNWlkvVDRhRzRYeFhab01meGNaN1dQSnNOVUpualVPY2d6aHVmbzZHWCsvb1dzZ0UzR1kyUXp3NzdxRVdCSXNnN2E5ZzUyWGRhdk91MG1tZEhaUU1DbDZSNVYzSWVWVUZYZnM3KzFZQ0d3c2txbExXTVVSMElkTXcxbXJNTzMrdjhYTWxhc1UvcVdNTjEwenVQSVdOTDU4dkhYWk1odU83Rk9mWDlwKzJzVWNwWEN0NXgvNldJWlhsTzUvSGFaUWdzOXU5cEVJbmZUV0Vwb2VQNGRtQjdobUR4RGlSMXRLK3hndkNhUGwwTjVkczZZclZrcnluUFhlWDdhVVVtQnNRNHh3OENQZGQ5cFJIckxiMjRXamZyUkQ4aXFSakRpRHFiUmNCdnJTZkpnU0lycTNHamxyTHlXb1U2R09xT1lXa1ArM2VrdWNvcmxINGtCNUt4dWx0b2F4dFpONExuQUpycE10VlpOVG9Uc1I1ZGh3U0VrK2NOR1NQaWQ2SjdqQzFOM1V6NkdXV2RKZm95Qm5rTFpSYTlZMWJCL1IyZXEwYWIzQk5NNnp5R242dVRTSkpSdlExaWpvOWcvSnhnNnkzcDB6NU12OW9IY0tjem8yY3lDdmk2S3I4cXJoSUs1eUcxWFp2TU1BN3VpY1RQdVhia3MvNDVkU1RLaGZ5aGZGM1R4VGsyWnRKVEhyZUM2VEczT3IvcjEzL3ZrZjhJZlhzSzB4ZWZ3TmZXeDdxRGpITWtaMkdVc25Ya1E0ay9EaGhteVArVW4wZCt6ZDhxeTllZVhTRWJTS1BlRXZXa1FyY1JlVFBLbktyZnFKdzBpZThMbjJNN2EyUjVpTzJxTTh0S1BxK2xIbTdSeUZFbEdEOXEzNU9mMTNqZVRwVDVaZStvenB6d0xlWGpzUStWTXhQSDJ5cXF6OGI1M3NUUGE5amJHaFZEMEFDUFMvaldobjV1S3IyMXZJbHVEaFNPZy93L1lqbFJCMWJIN0JzN2t5bE9OOERQdFcvNlhmeWZ6MTBuZlhJVkY2aVZxRmRDK3Q3ZzU0cnJGZWZWSDlHelhkQVpiNnVGL3dMOWJBTGFYcTBmcU5HSExxZXVyNDAxT3RsRmZVL3JpdmhxTENzZnozUm83d28vWnlhUVhtbkpMQlg1aHVQU2pHTHFjQWFZVHNqQWkxdXUwMGNkcGpXbW01YWsrMFBvaE5QS3ovblA2d0IrdXN0MzFkT0dxQUUzaWI5TTNBRDdMUURmZ0JuZGZnK1dLdmhqQUpkajArQzY0WTRUM1RTOExrNVA5Z0g4QXN5U3pidDdmd1FUb0w0Q005ZzlnNlVUZmpwUWp3cTRud0d3ZDNEMzNsdGordHFvYXdMMDd5ZjI3M2dvcVRRVkcveEZwd3FXRk1rRVoyOGgzNHZ5ZWRobWZCMDJoKy9Bd08xREFEOE5NNlpydVFEd0I3Q04vVXRlMXhQazZKb0Z6TGhMby81dit6dGZna1VmN3dENFp3RCtOMWpVNzh2SVVWZXZleHN6QUg4TU14d3ZBRXdZVFJ1anJjUFlnQndoOVZWWVJEaWpDbjRPd0g4SDRPT0dROEhVMDVIVEcrUnIzdlpYWVJIUGp3QXNOcVhzZGlQelBvQmJCM2Z2dlRmMDdLZmwrWmNhSU5UNkRMaVpaNXZYb1pGY0N1NUZrT0M1RkFGR1ZBR3Nqa2NZTkwyT0dCMUxBSm4wcVBEdUhBQUxiaHlSSE9xTVFpQU41L1RhVldIbWFsNm1EeTdHTCtPbHgxak4yMVdGSVoyN0JHUU5qWS83S1BSYmxZTmtWTlh4U0J0REtWdFNtaXg1aDhBNXZlWUtFQWFsVWVMUVArZDlVK3V3Ti9pc2VtZjM1akRNVncvZzluRXc1U3JUWUFJbXhKekpNNlRMUUVqSDFKV3BWK2x4M0ZOMHZKNDNVQm9QeUZkR1IvOVc2aXpXcHZMTXZyZjdESFptbnNMbTZteWVJMC91ZUw4ZWUzMzBSbGRlK0V3Vng4WThNeDJhcGtuYjVMa1lQYjl2UXp6SjV3L3VQdzdQMDNDMG1wdGh1alUzTk5veUdwaUczZ21NWGpDYWV6bFVqN1RiU2grbHhqN1NNdlZldjlpazlNbisxR2luV2Rpck1RMHJqWkVhUWZsY1V1MVgrcGU4WHRGWHdQVHNjaTllQmRwR2dHYnJmVjdqZDgraitMa2cwUGNNZVJ3cjVLaHY3aEhTUWthQnBEbXY4T0lVU1JIb3hCU2VJajdRc2dQays2UFZlMVhYdHhhMXovcG9qS1dSbFg5RCtoMGRhelFMQTlBSE81OUgrdW9WY25RVngzTTV6MWtHRHJ5OUN4a3Y1MXF6VGFpQ3ZZWjc5RXE3ZEJoWkk2Y3Ixd2d3QmIycVVYaG5DYTBBQUNBQVNVUkJWQWlWOFZGdTFvaGRwclVzMHVSS0g4L2tIUUxFbWxhWTBVVGs1eHJKU2RyRWMwemV3UE5PSGxsTkJSaGtOejF6U2JaQ3lXZTVoblNNNFhoNzk2a0w3V1IvRkl6UnM5RURjaXZ0QWhtNFV2bG55REdFc2lqZmp3Q0dSdkFvQ0t4QTh4bzVYWFJzYnhYb0xGTitjZzlHa0ZYblJXVWtsbXZMeUdQaytFN1NYU1BMSldzZ3BmYlZ2YUNSM1pTbmFIalltTkdwSzFOUFQ3RkZGRlNvSThtUjh6TGlTUTBDZzFFa0ZWbEJVNVJlSVdja0cweFBQNksvYWt4UUJ4THU0MUU4TnNvTWtZOEpIVlVIbnNMcDZFWHdQZWxiemJtRmZkQTFXODl6WkR4cHMrNkh2eS84UEVYVlFjN0NQRHNnMFFDbzlLK2F3V09MTm51cFEydXlvdklkbU1HekZXbXJXVis0UmtyN1hrS211elN5a2w2eHZSVk1ubUVieVNGeXcxaGE2WW1wRzZrQk9LVkZGanJPakJrWHlQZm1hbjg0LzVwMTRRb2VPUlRhdlFXNWtrTHBvdlpUOWVDUk5GUDFPTkwzUGZtTTlHZ2ZGckJCdVplMFVoMVA5cjIrQzZCTWo5bTVZUnRabnBvaXkwVGt0VUFqU3N2SHhYN0ZxMWVVcHF0RHJqcWFwYWp3dUw4RGZ3QXlqZU5lMDcwMERmK3pMWjJ2TlZDa1psWDluTTlPd3ZQUjhRdnluR1pwS2JMNGhIWnJxZXdwazlmNE9lZXU2dWpXWmFkYmxaM1NHclp3aFEzN2JpTVdJL3hSNlJPUVU4VlN6Z2V5WEpteXd2SHZNVHl2S3lQL3A5ak1jMXZSeTBudkMzTmR5RVJEc2tLVWRhSmUwZEl6cmxOa0hYUXZjNDIzaVliV2pGeHg3S3B6Y1EvcFB1YzVlUkc4TDU1VHhkWDBURStBNGtvMmRlN2FPa1c0dC8yaStIbFBWeE4rcm5xdDd1blJxZEliL0s0M0IwNC8wclU0d3BjNWQ3dG82MDJNeWxlY1ZUR2NxUGZVYUNjZ2prVTNsRmRTQmdDdmkyZXZoeU9LTHNVc1hJcXRLMDFXUGV0eVhyOWFZUThqMW1hTGNYQXVOWnNQK2ZsbjRJN2l5SmpOWTVqTml3N201T2RMR2U5c0J3Ykd2ZzBqdExkZ2FYS2JhZGhheGFOVkJ3ZTdPRDA1aEJuMVhrZjJsdVBkc3l1WUlUaEZZZ3daVnVXNzVlTDA1R09FQ09CcmxOY0FyQmFuSjQrUW1Tc0ZoVlZvVDRrckZZUnJseEVwcUZlQXpiRWJPSGRnZHdKL0d6a2svQTdNMExtQVJRZlBrQTJ5c1h6b2ZYNFZ3QStRbzZZWVFmc2FQTktYS2JnWHB5ZnZ3d0NmejhPTXZWOUdOancvZ2FYdy9qN01BTTNJMjdkaDg3TzNPRDE1NkJIWEU0OWFWazlQOVJ6NUhNeG8rNC85dTNNQS94cVdFcnhxL09YYytKOUxUK3Y5ZmVTMWVlUjlIeVRhYnV5bjkrYW41ZTlKcVRGYk1oaFZJSzlaUFpsT1QyakFpeEZlcWtCc1k0eUpwblpIeDZSRlZLcTAvd1FvTmhsc3BuQ0IrcnBDakFxeHZnYUFBS0grUC91bFFNdXNPenJXeUdvQ2JVbzdtNHJIUEh1MjFvb0tuTTNDZXRsdkZhem0yUk03alZQN3NVR3dKNU9OODA5RFJWSU9SQmxkeVE4Wk4xTVlyd0FzdXFOakdtbG81T0JZcThhWXhwcE93bmZjUTFSK21WWnJKdUFPYVRGL0s0QzVCNlA1YTMvM0l6RitSU1BlR3NhUG1HbGlCZU1WYkxPbndMa0NuSlNKWUZCS3hvYkdQcWZTZUFIamNhLzUvMC9EWEhHZTFiR0NmV0xFc3Q2dGVBZm13ZjVKQmJ5NGhJRlVWRTVwWUtzcXA1VjlwQW9KQUt3RHlLWktTeFRVTlcwbzkrQ3FPenFtY3dEUDROTDd0dkJueG9ERk01aG5Oc0hGOU00OGUrT3lINXgzbm5mZXNUbFVLTWhPbldZb3JTTVFCMlFBU2hXSm1JYnRSdktYakVNQmQ4b25FYXhKb0RqYjU1NElOSVRuTExhaFlKU21WcDBvZlhvZTQ2a1VHbENBYkZEaG5IS1BQVU9PdGw0aW40TldGZ2thTW1Qa1A1Q053bXMvMTVoYjZtYW1UcHJPUGJxOHkwWk5Lb2g3dmk5U3RMM1h2K2hLWTZmZUdhVEFwb0xEQ202dDVQTmFoR092NkJycDJmUXhNQnJwS3J4ekxrb2JhWCs4Q29VS2ZRSVZrV2tIbGN4TE9GK1ZmcEoyOHB5YytXZFV2TUgrMXBUMHdETUl6akthQnlpTjZRcXlLTEJKdnNUNUpkMVdQc1cvVnpDNnBDbjllSWFMcXlPQ2JCQ0IyRnFoVE1OM1ZHSG51NVIva3BNTkpLV2t6eGZCUis3RGxBbGdudE1PYXJwclRXUGJpMWhINXB2Y0F6T25wV3VwZzNOSklKVHl6NnFyTzZDb1lSSk81eFZVVVlDVWM2UE9FVDA1aWVjUzJiaWl3RFlxKzcyM0pucVc0eVFJRU1sbm80TklVMzhXZXN6K0pGQTRuRmsxc0hDdE9jK2F2alNPdVNacmtwY21nTnJQM2lqOVFrRGNORThWdWF3cXJ3YUFNaGtzdTZOakFrbEpWL0U5Y29GU050elVyNnJjNkgrck1VY05pM3h2TUxXZUFHb1QzK2ZGK0FJUXArZDBJalFoMHJublZoVEVob0Q1S0dWYzdyY0x2b1BNTDlZbzVUU09xOG5Qdlk0WEFvQjdVYkJkKzhSeFVSNUp2R1VFOEY4NEhRdzhwK09yUFV1NnhDd1VpWWFGdlhjbE5FTGxKOHJtL0p2MGlldEVlazlIUnZMZ2JWUFJKMzFGK0htUm5jcC9YOFJ4ZDBmSHoyUzlWWS9USHhxdXVmZFNQZExQbDFIU2JkWFBhZzRWemZFcHNJMjhQOVRJcG51bTRDZHd4enovakxTVzhsOXk1SUprSUJHZW9OZHd4SE1RSFRkYmhXZVMyU0RWc1Zhejg4U29keHFHbDhqUnBFdmZXNVJ2RWkrZWwybUV5WC9XODJ4OGpEeEREVXY4ZjFyaDU3V2l6ZzAxWEhFTkZCa1JLQXVrOTJXODZveXlEblhBeDhTTVZFeXB6cFRaNU9jN0ltL3AzSzJSamVqY2l6VTljU1puT2FZMjVqNXJYZEV3ZzgrL3lEZHNUODh0blJaMDczS3YxcklERGZGemxhMVdzTGx1M244YjN4ZCtudWpYQU01U000akZaN1N1WHR2YjRISmFmM3duckl2aWNNQUlmZzdSQVFKOVZobGRaWHgrSHgybW5xZCtYdkFja1NtMGZjVUsrTHdhLzdRdkxia3pHUUtGamlXYzhBWHk4NFF4Y0I4SWZlVVpvQndJWUJRLzUxaDZaeVBvaXNyM0MvbGFaQ2ZTa3dreU5wVHE5ZDlYWGNraldZM3FJVHBXMWMrQkRmTFdockdTdnV0N0JSL1hNY1gzZ3g0SzlCMXYyU2ZGU0M4ck9uVzZLclk3T3I3ay9GMW4zNFF4clYzblU0Y3ExY05aaUlYc3l0OTdrS3duMU9OMlBPWHRRMWpFREVHQUdRQThyenRRM2JCMkFBTlhIeU1UOFljd1l5SWpiODhYcHljL2hCT09NWGZ6ZWo4djNYRGJiSDlEUFhzQWZnM0FMOEtNcU84Q2VCTm1jT3dSQ1JvYnhSQjhvekppakd4dkFvc1crbm1ZOFpkVy83ZVJJeEZlZzYzalZ3Qjh0bExYSG9DM1lFTFc5MkdibU9ubzltSGVCSzhnaDhHelhNR2NCWmJlaDdkZzYvalErL2NSZ04rSHJlOFRtQkdYKzJjR1MxZE54c0FvRG5veEUwUy9BK0RmUlptMitSMEFmM0p3OTk0bVFKblJ4QVNoQ1BJVGRCc0VrOXl3L29xLzk4akg5V241Q1pjdGhKL0NTQ1hDMExaUnJoUmlxRmhRNlhvdW5qdXgzRUI0V0NJcnV5cVlLTERUcXB0emsralY4eEppaE1rclNFZ2VrcUpKMkw0TERVbWdGQ1V5S1Y1a21tUGFWOEJ0bXpISnN6MFA2eWpraGUvVjJ6TUtaMFZkTldWZFFBYWdWQ3lwNkFMWkM1MzhPQWsxRHZwUmNVMkNQUHNoU2luUU54Z3FRS0VBQWZ1eTQzMmpZVVVqZDFsZWd0SEhTNWdEMFc2WG5ST0F2b0xGS09NZDVGUmVtNXltcGpBNnZPN002S3JnVWNFSFhOajZQSXpYZklCU2tPUStqSHZqRE5sUVMyOXpBa3RNRDZlOGovM2RSVjl4aXRjb1ZQZWdBb1h6TWhJcEthYnlMdWtRd2U5bkNBcG1BTVFWOEdjOUN1eFBrQTNiYXgvN3Mxby9RMTlwNU54a05PYWFjanlERGlZaUlGTUpVRU5rbkF1OWQxblB1am9kdERKRUZIc2JjdGZvd0pqWHNDaUNOWUFMb1MrQUFFTUJITjZtUk1HZDg4cDBWQXBFRDNtcU4rL08ybERXc0xYbnRTbEtFK2pBY0tWNzFQdTE3N1RsUExTcHhzdkVsK2M1WlRIbHJ5V01WdXpPM1psQWFCcFRFcW9Ca2NyOVRuZDAvRFFvcERRSUZVNU5LSTFxeW9QNG5kSXBscTBjT0N2S1hOUDVyQVhXT2c4NGg4blJRRTVycVh4YTZYU1A5OGlZS1B0Y2hEbmlPMFZVZldXLzhIeXY1bWFjSjhpcWJSV0FpbnhPeFZOcEdIbklEako5V2lIdkF4YnlsVGgzbWlJL3lqbjg0ZHpRVUw2ZVo0TTc2WGt5U00wdG1rOE4wL3hld1VIeU1mTFVGRm5VNVdpNkFwRDMrYVREalFKUEtvOHBLS1dHV05JOFRhdGUweWQxenZrK3h4MFZmKzNERk81MGh4Sms0WGQ4YnpiUDJTQXVPa3ZCcm5WT3U2UGpDRFFwclNjNHRFbjIzSVh4ODdSUGF6UlU1TUFwU2llaUlUcEhVSVR0Y1YrcG5LUE9SVG9QOGV4cnhOeGd1d29LOHJNQWVtbC9WQ2JzZ1ViU05pRDhuMzBRQThHbC82L25aS3pERmNzbUFIaUZEUFFsR2pQQXp6VmlYK1dncXFIQ3p3em5YK3NlNUdXQkYvZWNXeHI5MHRUOHlYRXQ4UHNDL051eUtLaTVpeXd6SkYwRzJWR3MyZDhobzhTR2todzJ4S2dDWkoyMjJuWnQ3NDRwTXBmTlZLWEJRRUI2cXhGOEJhNG9BSE5oa0pOSExwQ2QxOVFRcUU0UjF6STRjTzRDUDIvT3ljQjN2TGQ0TFgxVXVzNSs2ZnhGZnA3V3FMWWZSeHFJMGp6NHZLcHNyZnljL2RJenVpL1BzUzk3cm5NeWpUV044WHFPMlBjcmlFd3EreURSMm5rWlZjYSsxUGo1bWNoNHVvODB3eEhmVjRjMXp1bWUwQ1ZlM1VTZXlESDJIQUI5enFKK0hnM1hpWGZLNTJxVXFobUVKK0UzNTRUMVRTdlBxS01NWUx4NDFmaGNyelNnd1dzcGM2QVlnY3FFaVZZaG56MlZEMkxSdFZnN1ZxTm5wK2Frek9mVktZL3R3ZnVxbnc4NXJSVkdzS0RuMWZnNTk5OGcvdXQxRmZ3aWxock44OCtxUmlicGwvYS9WNmVNZy8wWWN5OXJ3UXRiOVlkK3AvTS94Rys2TW9NSmdKVFpUMlVzcmY5UzNsa0RGbFhxY2xDVlpsVjR4eFFiYUMvQ1hsRGFMZndqalJrYjFydFd1dExZcmZzcE9lT3hIeStJbjZkeGRlVzFSK3BJMHVQYlhkdHhxemNIQWFOVS9YaGE2M2RYT3JseVhqV2l0OGdtVjlIWmFNaU9aMWoxS3BYWnRXdzh0NkhkR2daN25VSWNoblNyY09hRnlCOWoycmhCUHhLdTYzV1F6d0o1TFRUREpQWENOWExHTWNVQ2Qzd1A3d0E0NUdaZndCUjBBczdKczA3dmI5M1c0TGs0UGRuemxNLzA3SDhDTXhBK2h0MG4reDZDc0hkdzk5NmE5dzV2azFxNWtSYVk5ODdHc0hQOS9qWXN2Zkd2d2tEU1g0UkZ0MjY4VjhmNytFSU1SYUVkR3NodncxSWgveHJNME1zb0dhWmZZWXJtYjhIR1VTdU1CcUlBZE1VNVIrbGhwZlh6Ym1JYWdmOFlablIrQ3hZcC9PY0EvZ2htTk4yREFZdS9DNHZDZWdLTHdOTExweFZRSXZoM0NETWFmd001ZGVWREFQOHZObnNyc2VoenQyR2VsZHg3emYza2U0UUdhTTdObFh6M2FmazdLSjNkTjdBNzhJanVKL1dLR2FvenJlYzhlNFNsQ05BYkVPcFJiVzc1WGhSb2xnaDlGQkN0U0ZVbkFnUlFldTV1YW5Pbk96cmU2K3hPdmg2OW4xZU1vK3lIdEw4S1AveU1aejU1NjhJTUM1cFdnNGJOc1lYM2RjKzB2ejcrMGZQZTVUdGNldmVsaUVDalRnZFQ2WGRhbTFEbkpOYmZsWGREMG1sbkR5V1l5M3JveERKellKYkc2VjViNklNdFV5RGY2eXNDTVdudmxhelpFbG1JbU0zem5hOEVYblF2TGVBcDhyM2ZmRjZCdjcwdXAzRWkzLzhFMmJDNmk2eUl4MElqMUI2TUR5UWVGUGJkMUduRDUvMmpYUUI3Ymx6aS9mWWYrNXpHKzl5dllOY2NQSVFac3oveWNUMkdHVkl1dzd4Uk5xcUJyQkdBMS92SnRIQk0wN0MzVmw2djh0NWliWDErNDdtUFlNNFpnTWZ6Qi9jZnk1b3VmQjBWbEZCd3AxcThibFhXTDlubnJuSnZqdXd0L1JrcWFwQlFRNTRxcW11VTRLM2VONllLOXhRbTFPNkdmdkVxaHdQL1VZTlVyYkRkWW01STd3amN3MVA2dGlxcDBSMy9iRmZHeG5GSDcybCtOME0yQ0RkTGpWZHRlR2NOTS80V1Jobi9lekxQOSttc3ZiKzNSSmxTUUZQTEJVcmo0Nnp4M0E3Y0NiUTc2dDN4cTBaeDNSY3NWVDdFdmdzZDQva2s0RWU2ekxvSVFCYk9MMXl6R3I5ek9qTmpteFdnWVFnRVlMMmtkYVI3VkhaNXQ1NENqaGZ5SGYrbW5NeG9hOUw0UGZqYzEyaUQwOGZiM2RIeEhmOUp0TlMvcHlIb1N2N1hLQ1RPb2Q2M3FIUkVhVDdMREJsSXBxNUJHU0h5b2w0R0MrUm9ud1FDQ3BDY0luQmx6QXJZcVNHSzF5K1FUK3dBNmU1RkJTQ1VqbkpzYWtCbXZVbEdJZTl4V1VudmI5WjNXR2RyTDZ2alVjMkJJVG1WaGJyVmdXb3R6eTNuZGw4Nzk3ZW1MQ00vVDRadDJlc3FNeEpnajZER2p2QmJ6cEdDTlZOL3YwWjdPTStEc3AyY1A0NXhDWmN0dWpKS1hZRnpBT244WDh3ZjNELzMzMmR6YzJCWkFPVWQ4U0pIRjJPWEV2bHFGUkFXb0w5R20vVCtzQ3FBTmFCbkVNaTc4ckdRdHE3OE04Nm50anZHNEtWajBPd2R2VFVUb0FrSVo3ZFJkTi95blRodW5sVmRoeFg2TklEM0l4ZjdKSUNoTkJ4dndxT2Fzb2p2OFFzWVAyOEdPb3prNXl3MXVTQ0JjdGZWQTF0RmRBR1dnZzdKSEsrN3dOL20vYnRMMCtjVlBiTDNIR2x5aFpjRHBTNml0SlFHdU5hZVczdS91U2N1a0s4N1dxRzhjNWJuZ1hwdkR6eHU4UE0wRDhMUGU3cmVVUEU5eXJHa3VtRHlSM1FlWlo5VGVtZXZnL3ljQmtvRm01dnR3dlRsUS8vWkNkOVRobE1BbmpTSVBKWDhuUHhNTVJRV2xjK1pGVWtqUlpsU3YrREQ2RHNrVW02aFBLYjhuS204aC9pNVlqcVU0ZW5vTUVQbTU1cFZJRHFrUWNZNnhNLzNoSituS0RlWm8wbDRqL1BFUXVNSmRmT2FnYXRHSTlYNG9ZVjdYT1ZWMXNPc1Ewc0VPcTFGenBuTzZScDJib2s3Nkh1c2I0YU1iOFJDdVl4OVNudXdRc2RWQnJ5QzhmTmxsNjh5VU9jRVNEMVhNTGwyQWR1MzU2Ny9YWklIVnZoNVM2OVZPa1JqMUJBLzcrbTJ2Z1k4ODFYYXRZbHUrRE1GYlJWYWNDMitFREFYam1OVFhUV1p2ZlpNd1cvSjZ5cjFVeGRYdklDZnFkTkY1SCtzVzgvbUdOeXY2SGRGbnRqa2FGVTlKMkd2VTU1WmhYZFV4OTJrbjFlL0czcW53YzhqZlU1N0p2QzMxbnJHOVBDdDlxZHdXMHlGYjhaOXIzTFZKamtzR3B1VlY2dCtzK0s1YnAybmdiWGJ5aTdaS2lycnlINVNaK0NKNEZDUm4wKzdNb1UwT0tZTmJlNlE3OVRHSWJLTjZzZVJuejlCbGpzVTYrZTVvbjEzRnhsVDNnZXdPd0ZTYXVZRG1NSHNmV1F3VzYzMGF4am9ld2IwNzhxTnhRMW5iOENFQjNwL2YrSjF2UVlEWndFenZGMzZJRlNobk1JaVdDL1FpTVNWKzNsWEFDYlJHT3NHNndrc29sVHZCMTU3T3VXcDkrOFhZQkd6WDRNQlpFOWhCczd2SWtjVlRUYmRIL3NpaWhnZ2R3SDhET3orM2M4TXZQSUVPZHFuVnA3Qnh2UVJnTy9BMW9GUlFsL3g5eDRpWDZwOU1XS3RtYzZiWWVkZkFQQnZKSDMwN09EdXZhV25mZ1pLZ2Vkek1DSGlDN0RJWmdMNjc4SWNCSDRIbG9wNnEyaDB2OXVhNHgwekJocXVDZml2Z1BaZDFwK1dGMXRFU2FqZTlVRUZEQmtVcEpENVhPKzVIZWdiZ0hGM1NDampHdXBibHoydDZQRTF1T2UxSDdBejM3czNjZHZTNVhUR1U1amczYnF2cC9DSWpPT1NzYWdCT0FuZ0F1b1NVQ1N3bVlTQkxmdkt0ZGRVZGxWdnVUaVdJSWduOENyMlFSUUFOUUtvc0tqM21hYjlpMnpzM29FWVdwSHZrRklCK0JFeTJNOTdvZFJRd0RzbEowQ1pQcS9TdDhMamZNTjBKZ0VqN3VuS0hMMEtvNUc4NStKWmVKN3RreDg4QzBMb2JXUytuZTdhOGpFZitqZ1BmVDQvclBTVC9HMFhKajlRZVR1YlA3ai9kbmQwL0xyUDJTT1l3RVB3Q0xqbTNjTTZGOGpYQlBDcWpDS3lWK2RMM3FQQnBubVBiM2NOcjlGYVc1Vm5EcERQMmNMN09ncm9RdDdmNmtrTmlEZS9QSjhpL2hwMGc4WUlSajlveWw2Q0p1a3NZWVIzcGJmSmZ2SCt0QWpjd0g5WDZkbnpLa0xUMXZNeW5SRDdVa1JIUk1ERS95UWdraUsrV3NwUWVEL2ViMDQ2R3R2Z1BxUXNSbVBGZXY3Zy9sUHZLNTBWRnR5clEzUitKSzIramJ5SEZ2TXl3cGpnWGkxS2M0a042OVk0YjdPNFArUHpYWTRFU2RIR0NIY2JDY0M3a3YrVHpvRUJ3S0U3T3I0bGRUTUZ1NlowMUZTRFMrUzBoNVJyYUFSV0lQZEsrdExqWFpXKzMwYnArUE5VemdnTHN5RW9HRWxnVmNIUEduakE1eFFZQll6ZTZuMnRlZzkwT3Bmek1pSm9Eems2YkFJRERFbFRlYVlMSHE5alIzblBueHBPK2IvMmdmeWpCcUJ5cnFJQlNVR1lDQW9oL0s5MXFORTBqZHZIdkR1MzZHVWE1NW4rVTJVTkxUR1ZKbzIvUFZtTTh6eUNuKytoM004cVEya2ZOSjJjN2pOZDl5UnZkRGtpTVlILzh3ZjNZeVI0QkY4VkZOcVpQN2kvOEhPeW51ZFU4V2xkbm9lc3o3TXd6NmxCQnlPQi9CbWVpYWFzT29ZM1grZWRManNlVnZuc3lIWjRMcEtzV0tHaEtTVm9BelNQKzBqUFdoV29IZEV2TlNob2Rwc2E3WG1SNlJnTEhTYndjK3FlUS94Y25ab1V5TDJSL0ZucG80S0NTak91UkUvUS90NUlQNVIyMHg1RTJEdENXelY2azN0aWhmcDFFWnZhMnlobkNHM2dmTy9EK04xWWZnNE03S2t1R3dlQmtPcFk2Mlk5S0xQb01Cc2RhVEhYcXVsMFhwUHh2QjdPNTNKZXBxYm01eHE5cjd5SGZKcThWdWs2bjcrQzZXVEt6d2s0MDVIMkVxWnJxYnhKWHNNcnBqaG1kVzdhSmYxM3VaMVpiR0pXSjlaSGh6ZDFhRXFHUEpUOFhIa04rUWZyVWZsSHYrZllFbjlDYVVSVXVxT0dNNzZqc25PNjJtcHVFWkdxKzBkSElaVVJhdkxIRUQvdjNhZGRvY05GcE9hOG44Mkg4MEo1ZkJsb3JUb0txb0dkL0NEMXU0WlJDZCtZUUs3U1FKWjE5SDdmR0cxNjR5Q01HL0x6M2wzSkw3cU14UWMzdkIvNVl6TksxTnVwOGZPRWx3bVBpL3VlWmF4K1h0eEJMblVEZmZuMkpsZjViU3hDVjJMcThxcWNITjZOK2puN1BTb0xWK1dNdGh5NEZiTW81R3JGL2JCQjk5eTIrRHF4dmN0NWlkY1JaNjNwUGNRb1hnUnVSZG9kOWZQSUV6VkRZazhQM2xCL0drOThSOWZjOXkzNU9UR1NNOUZmUjdkYmFTUEpJRUhPck8wRDFaR1V6eEhYb1l6QTlhTlRtbjYvaG1HWGgrbndoVWhIVGp3TmUxTVlrUHBWV0dUbitWRGtxOWUxQXpQZ2ZnWTU5Zk9QdkROZmhSbitic0dNeEFEd2h3QitDTHRmOE12KzJSa3NVZ2NBM2xKam5CaXRsYkUrUXVsSjhvKzkvaitFcFJJK2h4bjFWbExQRkhhZjdzdmUxMS8xdi84S3dQZGdhWkt2NEpHeWxiRU9ScGVPS1RSVTA4QXNobXNnTHhpamY5K0FHWUx2WExjOUw0OWhSdFozWVZHMk0yUXcvU08vUjNjNkpzSjVjWHBDNTRFbHpPQktvLy9DVTR4ekxGeXJsWDgrZzgzNVQ4TlNXblBkbHdEK0ZjeEl2UTh6V0QvY0p0cmE2MTZQZmNmN3FBZDhGOEN6VHczQWYzZEZ3SUFhT01FVWxoUXlMMTRrdUYvcFc2RklibmgybEhBcFFGZ3ZOZEdHZnR5Q25ia3JXQlRneG5udytVc0tXNlVmNlI0ZHRsTlJtdGVvR053VkhFTldObnFwVTFSd25aZjM1S2ozYmhYbzgyY1BVU3AyVllBeDlxMG1pQVVGdXVpblBNc3hVN0ZXQlhxRi90MUhtdjVJRFFHWHlHdEdJeWlkcmhpVlJYbzg5ZWNmZTd1YXNySFloOUxIS1VKRStKajVHSGlHZTRIQ080MDFYSU5MMUFXejI4aDNUMUFJMFNnZUZXYTVqem1uanhVWTZMSUJsWE96bkZzcXNLOGlnMDBmdytRRjdyOExHUDk0elQ5TGUyUCs0UDVEcVh2by9zS1h2Yzg3OHdmM1AzRWg4Q1YvNUpNS3VNNUl4L1g4d2YybmVFR2xNeVA0VmNVWTBxTkxzaSsyZG82aGtRTGxtUVFHZ0V6dXFTNDdRYWpDdDBMT0JxSXBHTThGVk54VVA4OFM5MkFCaG91eENBaXBjWjkzVWVVZEFxVFY2T3FJZDljeUJyMkRyYlkzVXdwb2VaWjNmekhhOGFMeURxTXpnVXpybG5CbHh1ZjJ0bi8rTEJpRGhzN0pKa2NiOHVzVmNtUzZ2cys3ejBrYlpzak9Nb1ZCdmRGKzNQTmpEZE1LaG5FdWVrcDlXS3NFbmxYQU5YaGYxbjVHU2ZPajBheG0wS0JEbEtZRzM1cy91UDhrdmllMG1QTkZmZUI4WGhydFNWY1pqY0VJOEgzMkM1a1BBUmtFMXZPdWhtck9rZkxEYUtTR2Y3YUg4cHlTVDArZGRpdWQyUGQzRkdRZ3phSnNRTDZtZ0NoNTd6UzBUYkJlQWRzTGtUMVVHZFozZ2RKRG5mUjlKendEZVovdHF4T0w3aDhGb0NQNHBFNXlDaFRIakV4QVBnKzY3aE9ndUs4K0FkS29GSlhOWkY2NU43aW1RRGdEUXNzNW5nUitWK2FFUDdvZklxaWtNaUxweDlMUGpHWWJTTkh4WVIrd0gyc1lieTdPNGNENGs5T1JBL1hjUSt4alRjNGtmWG1SemtNME5JN1NWOGZJYmEzM1VOSi9BRVVxd0UzdjlyQUpBU1pUdlFFWTIrVDRtc0N6dUQvMWU3eGdnNi8yMTR0ZStUQ1duNnRPc0VhZlI3ZjRlZFN2aXJ0Zmdhb09wUEsrZ29IUmlhT3BSOStrZERudFowMEhwRk1YKzdhRU9VQnRCSzVyNDkxbXY0dk1TbDJxZHE0alA5K0RHRlFiOWRLd3RjUUdXVHFjRmMxQXRGUWROZXFnUXNkcDZDMXdEUjhiRGFQcUlFWStRa2N5NVVPYUFwbDE3eUE3R3dIWlNYa0owNU5VZndXTTl4QUxwaTZuUnVYa1dDcjhQTW9SeVFtaHF6dEZxbEdTR0FSZ01ndWRGc21uMWlqNStTSEtTT0NvY3dDbElWbFRsS3Zlci9xOTRoY3NhL21KZDlmcXZ0TDFYNGU2a2tGTW5sVitycCtEYmRUT2dPSVNnWjlIbVNqS245eEgvSXd5V25SUTBINXcvQk1JTmlUMVJYNSs1WFNQcWIxbnlQeDhPczkzQVhOT1dOOSt3RGlHK0RsMTA1bkxsTHFIYW5MOFQ0cWZiK1I3ejdFdHBmL3dkc2ZxUGpHRHd3VDVPcHBVN3p3NzN3SGgzRmJxVlYxSzk2Y2E1Tm5YRjVKMU1mUkhIWDdKZjdZSzNFRTJoc2QwMkZXWnJSTUg1QzQ3K2k0VjU2eGdSeW96cTVPSXpwM1NvK2NXN0JUays1Nk00dnc4MFNQMEhXQmVpT0ZlWkNydXFhdWh0Wk0xNnhuNks4OG12SG5NUE1yenpGQkw0L2ZHNEVUWkF6V2FSTnFvVnlTb282dGVENWd5ZG5uaDNERFR4aDRzUU9jakdKKy9nQmw3VlQ0SDdJenYxZEszS0ZqOUdkZ2hmZ25BMTJEM3M3NEg0RzhYcHljWFFFNjk3SGVva3NuTmtDT0thZFJqQjMva3YxOEI4RTNreWZ5QkQrU25ZWUxHRjczajMvVTJiOE9pVzFrWUhiWDB0cjdnZFN5OTNYOEVpK3dGTFByM1F3Qm5EWVBneHo1aDczdWRud1h3WnpDajhScHQ0eThYOWFhYi93NkFYMXFjbm53RWk3NGxlTTJvTDZiTlBJTVp5WjhDK0ExL1Z4ZjFDY1liaHFjd1kvSXJNTkQ4QjhpcEtGZEF2dXQ0cVBpNlQyQkMyamxzcmdvampCdDd2d2JiVDI4Q1dDMU9UNWphNTh6Ny9HVjVaUVlEN2I4RU0zYi9BV3dmTk8vbGRhTjVpa3pmTmxyYjM3dVFNUzArTmY2K3VESkdvU093MEhoT2hmMnJGeW5NTmZvMkdxaUJBSm1WN3pTTkNZMkEyeFJWSnNoSUJ1ZENCTCtkenU0V1NNTEYvRUUveFRBRmt5Nm45QUg2WUtnV0ZRQXBtS3BDQmFDOHM4SC9Wd0JrQ0pSVHBzZStyR0NwYXFtRWJCUytSVm5sMzcxNUNzQnFEZGpsdUZiaFdhRDBMS1p5dlVLTzdwM0NzbUtvbCt5VnZQOFUyY2pOdVkvQWYxTGFaQXhWNDY4Q2FYeStvcnpXb3RvbkFLWmVkeko2aU1CS1lTVVpIcVF2VlBBKzUyTi9Pbjl3LzhjUW51bHJ4blRZS3VobzJaZG5QcEF6ODRQdTZQZ09zckg4NWJrWmQ2KzZvK09Ya0xObE1FcDVoU3h6cEwzVUhSMXJaQjMzRUoyYUlQWFJTVWpUYjhXNXFnSGpXNVZBTjFwSy84ejdUUURsRmh5WTZmemVWQUhEYm1vSVRhRDdCcEJzNXYzaU8ycFlTb0E5TW0wQWZLM24rVzdYVFFhTVZCbzBNNTIvbjRBQ1RyQXRHdERHRk81MzlsSDMweWJESzgra0tqd0EwalVCRVp4Um93ME43NVF0azZlM3I4RVpndEhWRmQ2OTd1ajR2RUlmeUV2T1d2UHR2UHdKeWloTmZzZDcxOVJoaG1uZnhoVFN3cUxPMXNNVm1ZSk9DVURqL0FwdDE4aW51TTRGSDBNSmVMZjJJYytJT2t5dElKRXEydDlRRC8vV1NKdkR6dTdzV3lQclhIUkVZZDBFc2htRkUrdU1vQ3puU00rZWdxWDhYbm45QkNVNHJRQlYzRmRxME92SkFWMitrM1lONFVQSVFFU01ib29ScVZ4VHlqQWEvYTZBaXdLZU9sZHNqL0ptTEhxR2RYd1JRSjNDYVBOVWpGMDhqK3lubmtQdG05SnZSZytuQ1BiTzd0ZnFwVzlGZHVUVDh6Q0I3U3M2SlRKcVMrY3RPU0VFZnM3M1U5dmhuR3IwVXVRY0RBQUFJQUJKUkVGVVNQb01mVjZaMW1vdWpsNXp1L3RSMzkxMWZrTUFMOGxiYUpkcGQzUzhrajNNL25PZUtYZXE3TElwTGZPTkFhNE5Pby9LeUh4ZVU1NFhCcjBiNmp1NkwzdjNOc1krbzR3RVpFbG5YL1l6ejFBYXc3YjgxNSt2MHRXZlVDRnRySjNuVFVXTkdVQUpibS9rNTFHMkVYMnN4VlBYWFhsZmR4RTVLTTlWKzkvb1I5V2hxdEgrVld4TFNyd3lZckdwdmcxdGJiT1BFcGFEemZ5Y2thTVJXQzBjRS95ZDF0M2R4VHYrdmZKSHBWbHhiV3AxYWVhTS9lN29tT3RLdVpuR01UM0hwSTJxR3dKbGhEWU5yL3RTUDMrU2ZvbE1yemtPL2p4RGpuNVNlblhCK2V6SzZFODF2SUx2ZGtmSFMvbWN2SXYvcTNGQnM2SHdHZmFQZWh1UTVVYnV1UjJVWTFQRGhaNXZYU2N0YWdpbDBWTDFlc2gzeSs3b1dOZFI1UjJPUloyWGFyUkJyeGJoV2lSamsvYkwxNi9sUktKeURjZkJQWmZ1aWFlT0pYUENjUzFoL0piWkgxa3ZzUmJsRXpWK3puMm9WeWhkZEtXUmw4NWFxODZNdzZzNG5pN2Z3YXpqM3NUUGFhQlVKNlFoWHZzVHgzYVZWZ2JjNWRyM3hVcEpkRzZUN29QU01VL2xUdjZPT0YrVVNRZXpGdWovbXpETkY2MmYrOTZEeUNham5OMjg4RXl5Nko1U3pLM0dFNmJhcHRUVmRQSVRmcDdvVTZ5WHp6UXdvV29FNnRCM29WN1N6OXFheEl4T1cyVVQyY1EzTi9TTDdZK3BLL0dlRWZqdlZ2MUhhWlJYWi9WTjc2b3pUUStmYitIdDBnNzcyUnVYejgydVBMdEV0cTgrUW5sMnRmK1lQN2gvdnJNNFBabklIYk5Zbko2c2tJR0JHUXlvM29FWmF3RURXci9ralp3dFRrOGVvdlJXZmgwR09Kd2hHK3crZ3d3MnJiMWpiL3BuWC9ObnFHaVQyYjdzUHgvQTBqRmZzSzlTNXpzd1FlODFXSVRVMUQvL1JXVGpMMkFSdmorQ2dlM3djYkl1QWhYczExL0FqS3lQcGIrRDVUa1lDbjhOd0svRHh2NjNzSEVCTm9mdnd0YmphLzdaSTVneCswOWhhNkxLc3Y2OXFUQ2Q5eUVzVXZxbllHUCtFQ1lvakUyNVRDSG4zTk5xVHdBenlBWUQ4bTJZa2Zsam9Jak1mYkk0UGZrajJJYjlGZitNaCtFMTVGU2V1MXFuUkJYendQTyt5RjdLMExIRmpjZzczcitmZUxydmY5dktFS0crS2VQMzk1OWNsN0ZzVTdyZ2tYMk5NZzBBRHZ0TVFYK3J2VVloaStDQUE3NVU2amFlVzFGK2FSeEtnQ1dWR1JVYS9QODE3SXp4dlBOZXBscmY5cEhUc2FvbjdpNU0yYW5lV1NnbEtXZU5PU2R6VktaTTVaZ2VweERGdVppdjBOZmF2T2d6aFZLQmNzMVVFTkE1VmVHYWhzSmJQbjVHSjVIcDB4TmJ4N0QwT2R5QnB3MUZOaElycUZBQTZ6S2UzcHdGVURiMU40QkRNOWdlaUVvRTUrUVE1YnFya2h2QkU2Nzd3cjluMU95c1lZRFJ5RVR5WTFTZW1TS25VMk41aXB3K1dzOFMwNW50SU04bmpSSUEwdDZMNldoNUxjVTVzcGUwQ25vMFpLdFJLRWJGRFVhaWUxc1RWQXp1L3ZsTHlQdXNTTEV0NXpFV0JWMG1MaHd5OG1RZkdUZ2FYUnk0QU1ZTC9TcGthdVFCNTBVVnNkNmR5Z05nWlZUdWg0eUR6S0RRU2tNZDkvMU5DZzJYVk55R1BLT0xmUmNBMUFRd0tlMzEvdTZJTWtsRFVPRUF4ZmNkVkxsQ05zU1E3aTU5emk0QUVKUWhiZCtGQVZtY3Q2RzVWWEJNNTJCVUtpeVVVWldwT0xqSzhXek1YdEJaeXR4TDhxZGFuZUY1TmNLUkJwMHJyL04rck1MekJGVjBYOU5CY3lMdnJsSGVuNXNjbkdwOUVUQUx5S25RU2VlWkNub0NOeUlIa0pGenhqck9VVWJhSzA4a1RTQy8wQXdNcEhzeFVvWDkxS2dOZ3VUYVY1MFBSdlpFejNiU0tuVWdVWVVXYUN2UityMHF3OHEzTldLRnp5a2ZWRjZ0ZmYzLzJIdVhIOG15L0R6c3V4R1JyNnJxcm41TnovU001a0Z5aHFPaElGb2diWXVtemJBbFdOVENNQXhwSlFnUWpQb1RjcFhMUWk1clZYK0FGZ2tCWG5qbmpXSEF0Z3pDVjRCRVdpUEQ1RmdpaDBPT09ET2NubVpQUDZxcktpc2pJeklpdkRpLzc1enYvTzQ1TjI1a1JsYVBqRHBBSWpNajdqM3Y4M3Q4djhlaGpFQjkxL003L2I4RVB2UDdrWHRQLzFiZ1g2TW5TSnUxZnA0cjdYLzBBcmU1VmNOZmpMNlRkMGh6SWM5a3dMVUFLcXpmQXd3cXU4UWkvTnp2YVErS2F6WVNIWjh2bVl5bGUyYWEwbU9YMWlFRE1VcGxta2NhSy8xVVo1Y01BSlg5b09zRzVJNDFHMHROSHpGNnRUYVp0RlJYSCsyTVl6WDYzdGljZGZqbnBpSWc0elpBS1B1Zzg2OXp0QzJ3Q2lEYlU3MWduTkNWS2wvZG9RNTRoWnlmOTRIZEVTdzFmcjV3ZkNNNmZDQ253Mk5iQTQxRXl2YTVHTlJxVVgrcXp5emRlU3Z5aTFJZHBmcTNOVWFVMnBrbVJ6TFBQMnY5aVZtR3RsbkxWcTRTNFhudytxczkxOUgxN0UvaWx1U3pFVUJHQXJ5M2NtZ1FReHpuUVoyVHFwaUZNeTVFWGlhZkt5ak0vZFc1ZXhPNXJPMGRTaGlaUzl6ekFFa1BKWDg4UUhEQVc2cHh5dWJtQ2lsRk1Ia1Q5eC83cDFrdFNyeUN6K25kd0V2ay9JdUdlY3BhS3ZPU2ZrZVpadHAxU3ZaeWdzNlpuL3RHMmxkbkY1VWpsQzlvUnBPUnRPdWZMOGs1OFR3NHc5L0V2UnRsRlRjdXJVLzV1Y3F3YTNtSE5FYy9VNW5WeTMwbGc5WVN5Y2pBY2ZpaVBEVXpja3hUSkxBdlVmWnc1elBUTVFyOFBEcThWY2FSNlhkdGJuam4vQS9TLzNyNHVjcG0xOFk0U1N1OERIU2Rzc1g3bkd2TkhLTkdZZkswemh5VjJwRDNkWC8zNFpDc3YxUlhNVHIyQm9XMFY3R3pZbEcrYXI5WENQeGJ6NHpYenhza3AxUWRrenE0UjJONm0yZnVVbGtCVTdrajJ1bUlHZjY4aWE5WDlNU2hQTFc0bjQzR3gvTzJEVC9mMUdmM0hqSHBpQStWK0xrOFh6UytPNXFoZ1R4YjJSNmNmczgxVjhmaGpUaWZZR2hBTHN0N2ZkSHpESFVrb3Q3dUhYelZTWmo5NHUvN3NFRFM5dmhrSVhKMHJHTUVZSDkyZGpxaVFVMGlJUThSb25GL0RjRGZRVERHQWlFNjlpc0lFYmZlMHhydS84OFFva3YvQXNHb3lnamJjNFRVeXQ4RDhQdjIrZGV0alJmV2NaWTNySzIzQWJ4bWZSMGpHSHBmUnpBU2Zoa2hJdlkvQWZEM2tCdC9ZVzB5N1Fsa25FQlhHYnhBaUFhbTBORm40YWN4Y3V4U2FBOHVablNra1gwUFliejNyUjl2STZ6QlZ4QlNVMy9kWHJ0Q21NL3YybThXdlc5NVNLRWg0aERBYndQNCt3aVIwNzg1T3p0OWUzWjIrdnJzN1BSb2RuWjZNRHM3M1orZG5VNzhPQThmUEZ3ZVBuaVlwUVMzWi93aG15SGRBZTIvbXlQYzlmdG45djhGQWdEK0VZRGZRekNJandHTVptZW5lN096MDd2V1o2WUEveUxDbkgxemRuYjZ4UzNHei82T2JCMkE1RUh4cXR5d2JFSDArOENjcXZKdGdOaGd4dExYVHFsUC9JRUQwVGEwa1RsaFRBc2U3ZEpuTXZ1eHRFZUJzT01SWHFrRFZ2OFRBSjlzd2R6bUNMUjJwblBqR0xhMlAwWlF0QThSdkRpcGVQbytrb2tkaUpDc0NvMUdlUmJYWHVhc2RnNlg4ajJGVGlxVFMrUktXcXpUNW5saWMwdUQ2RWpYbWdDRWpKOGV5SjBvRUFxSVlvUUE4dWd0TW15TmNtS0tyU2ZXWjE0OVFBTW01NUR0TWMwWGdVTlZaTlJqbWlWR0luTmYyZWNsby9tYWUxYVVwSktScjBHZXpwTmxqWkIxWW9ZQVFvMDUxMGpyL2h5QjN6KzFjVHlyQ0tpcU1EeEZXSmVKOUY4ajJWN1RmV1B2ZjRxUUtlU1oxTU5VdzJvSUdDUFBKQktMMVhtSVpPaFhJSVB6c0VCSVVVV0I4cTc5M0VOWXd3TjV0bHJhNUNpeDN4NmZITGJISjBmdDhjbStBTkFzTmZsakJva0tLd0JjMnU4bGt2Zi9wajZWQ3UrZTlzTDNmbnQ4Y3VEcTFYUEEvUnJQNVBUeG82dnA0MGRaWFRWYVordS8zNmI3dmVLK1V2QzRVQm9Fa0NETGNDTUM4MlRUWEJUNlVwd2JPL3R6R1ZjVnBFYmFVd29RNnZOS2UybkFKVDBodmRLc0J3cktGQTJyU1BQdis2M25uSTRCZXdEMkttTWxUUzdWUlFQVm5xM1h2VFk0VXZqblZyVTVNb0NJUUs0M0lQbG5hZXlMdkxMMnJCU2RleHJoUnU3NzJDL3JJMU5taitRejN1V3JaMHhwL2RyMjdjaCs5b1FXMTV4ZlNNdko3d2k0OGN3VVFXejVqTXJpR0lHbjcrbjdVcmNDUE93dng4RDdDVG1uT2pkMFRHS2QvQzVHNmNpWUlzMFdtWUtabWtwQWhQSkxML3NvM1NaQXEwQ09ycWthTXlrVExIazJaZnladDdWYlF3L2VLSTlWZlZGMUdNK0RGZXhuOFlvKzU0N3p3akp5ejdKZXBrWStLTkRickc3Wlo2U1hUQXZ2KzhBNk10bEJ4a01qclBKenlnZVV1OGJ1ZlMwcUd5cUlYV3FyUTR0dHp5d1VoTFMxOG9iK2trT0tGdEpRNnZKK0Qzb1pkbDkreHZMT3htSnpUaGx6d3Zscmt3SFE4M1l0V2RZRzZYdXRiT0tCZmFVWTlhczBpcDhWK0pQK3JLYVBIM1VNMmh0b04ybUR6a212cmtNYVY2Ri9vOXAzZldVTGZsN2MzMjNLVXFSMzUzbkRvZ0xKM0gvcXhES1NOZXpvbUFVZHpMZVJmZWFBNjJhSXpyc0pUS2F1MUROZk5YbUhjek1FTFBZR2lJM0YrT29ld2ptZElNK0dBcmh6YTMzWWgxd3pZM05HUFZqWHlldm4rOExQSnpJbll6OHZzbVpxM0tjejZYT25LOWJtQWpJZmx6Slc5b2w4d2ZNTExaZklEWlNjRCtyRjZtZzJsbmZtQ1BvOVpURGxONVJkWGtBY29LWFA1Sy9jMytxQXhQR1FYak9yb2ZKVFh2T1R5V255UCtWSDVlY1pEM1Z6cS9xSG5qK1dqdUZBNnVLWTlENWsxV3NoejFGTzhQemN5d0dSYnRwNlRteHQxYmtxVzAvaDVaNmZlL21DLzN0K3pubGZjZzhSdDBBeUxOREJiMkxmbC9SenRzRzk0ekcxRWhhaGRSRERVRDFmc1pFOStlbWpGOTQ1UzJWYTFxbEdGdTZkaVR6ZnlaSlFLbTB5Tms4RUk5Rm93R28vSzJlOGhpTlMzN3VXRFFFb1IvMTZPY1NWbGZDTHlOTXBxMnYvYS8waVBVVGE1MUcySHFCZk4vNFo1UU03NU9kcjZycDl0RmZhSGxmbUs2NjM2T2VOekIzclVTY05kYXoxZW9QeTdDSS9sNzkzemMrTCtBZjErTXE3a1FZTjRPY1JXKzE3enIyajJabEs4bDVIRHJmbmxYNXlybXA0Tzk5ci9OK2ljNkx3THVVRnpzMGNBUU00M3dKdmo1aTFsNjlsM210cnkzdmZTL0tnOGlRNmFjK1JybmM0QUhBay9jendIZDdMdFVDSXNGMUs1T01SUWxRcURiOHNDNFNVeXBjSTBibExTL0ZMYjdTWk5YeUVkUGNVUWRsTGU1YVRRWUpCSStjZEJFT2VqMEI0Ui9yNlV3U1E5cmNRSW1jL0EvQTFlKzVyS0pjM0VGSUpuOC9PVHQ5M2thbGpBTTNoZzRmY05BdG41T3c3Y0ZFSXEwVUIyN3lNQWF5bERTMXJBSCtBd1BqZVJXTElRQURDait5N0JjSjhmNEl3bjNzSVkvL1kvbjdQM29ucExRdEZoYjBMZS84Y1lXN3ZJakhpYnlJQTJuOEo0QWV3TmU2cE41YWU1ejZCQ0FlTXdCYkRLNncvOUVaOEd5bnQ4NTcxN3hPa2U2bVpydUF0Kys0T3d2cFBabWVuVHdITUR4ODhYSnF6QUpYNWkxSms3elozQzc4cTF5OGUvUFNFZUNneHRmZmVRRkQ2bmlQZHhkS1hhbVNuYTF6cWI2Mk4ycmhFeVlwQVczdDhBaEhVYTVGWVdVcWM2NHh0bW50SWRmcmZKdTlSRmthUDdjRzhtTzF6UDdZMUFtL1lRNkJGNTBqZTFDTWtReWJielBhRENxVmt5aFdGWkdsclQ4V0lkSVNSeDlwL0NtSDBEbFd2MldoSVFEZmpBK3ZWbExVS21oZVZwWUp5eHNoZktqL2VrSHNQQ1JCV2hYbUdITGpYT3YyOUlPcjVxNUcrakRaUzRON3p0K2paWE5tcmRCS0tobkJyaytBWDc0ZGF0Y2NuZWhmd0pkTDhQa0hZRHdTOUdnUzZQSittRkNpZjJ2TjM3UC9vK1QwTjBSWG45djhMR2V1SXdyMG9hRFJXVTFEYlErQ1RWR0NMa1RPMmRob2x4R3NYR1BrY3dSMlpPd1UyS05OdzMzaGdsUGRTWGsxVHhPTkU2dEFzS0V5WFcvU2tyWng1M3k3N3l2V08zN1VKM0k5T0tBaHJvK2xmdFUrd3VmRUtBQUY4N3hqZzU4cmZmVWw2b005cEpEYjNUVk40cmxmNWx2RTIvbXlnY0lZSGxsRWJvbXF1NjVtczlGTFR3ZkZNMGNNVDBsLyt2eEI2eGM5NGhsZ1B6N3ltYzlXMDlLWHJYbXI5NnhRNW83RDZHd1NhTUpNMjlLNmFiWlEvZFM3WnQ3MnhhczFydGRDWFZSdWlYdU01ZFB5STlOSHZVNTZQRE1CeC9FRFhZTTU1bE0vVzdwa1luZGFHU0IvU0dNaHpqSDRvbldWVmxtY3lOaFRHVUNzTkFwMWkzM2h1MkI1cG1UcEowYUJMd0xZVVVhcGpiZVJkR29MNXVhYkdKSDFSc0JkSXdETlRveWxncVlaYmpSUlpJL0Zrdi9kTEh2YjhuTUFucEM5UkJpaklPUndIK2FBQ2RleXIzMHYrR1FBeHNvYzZET1FaRC83eERqejVLTjZWTnpLK3hqdHFEMTA5SHJ6Ui9panZqODREYmg5eGZyaFhWbzdlc3Y4eFc0dU5pMEJVZ3hRcHFVNlNZMm1UYXdkcGEyVTBWT2NwQTQxTDhwNmo0V3NFR1c3WmRtbDdxZWo2Y1g4VUk5UUtBSkFDZGhsdHNPZWpFZHpvbys2N05SS1l1SVFaRXFhVnlLT2VNU2pQVnFDZjQ4bWNRMVF1QW9yM3pPMGhyTmthOWF3TldRU1h0TWZTbWZjMjNmdTNocDF4cjc4NEFEMnJld0NkNjlNM3JoTUJUR2Vjb2RjTTFFcUpuNDhSenJMeURlVmpURmRhY3hLSjE3enNXbStWL25Sa0tNclNsVDROTG0xS005d2c3SVVZM1ZuaDUrdjIrS1RxekNqOTFVSTY3V1VtbHBLenh4d0ZSMGF2ajdZcEN4WjVWaW1UUmlhdnl0Z3BhMUYrV2NOa3NpMzI2Qmdwa0VObGxwaFpwRTNwb09rd1I3MkZ2TlE3WDdPdUZZSk94RHBMNzExd0w3U1dqcmROMXpGUVRyMUUwSXYya1l5a25HL1ZnWmcxalAyNGxQL2pmYkRTUHZrUGtBQnROYzZvanN6MlZBYnp1aTMzSHVVeVQ4ZThYS2p6cG55TU1pcmY4L1BxY1FXK0Y1M01wOGx3NngyNE9wRzloWkxKTG00UHE0Nm4vRnhsckpMOHIwNEUwVmdzK2puNU9Ya2IyeVR0aW9ia2Fib0NJSk9YSzVnZng2dHlXMXpYRFRxV3lvNHFxeWkvVW42cDg5T3JPd3AvSmQxVm5kR1BwNWI2ZDl0UzJvKzF2cFVpSU9rMENkaThTNTlZbjY1SmJLTndacFo4djAwT2hJRHhJNGNaNmhtTWZGL0dOSWh2T2JuRjR4WGJsRjN3ODdnL1pHNTRYck9zVkxydWdqMTViTWp2UDFnOVcrMGRtV3ZXMVNrRCtiazYzUTNldDRKYnJSRDA4K2drV2hxRHpVZVJuL2VNdmFPcmI1b2ZvNmNkbzM3dHZRSi9BRVIvS2RFZG9RbmtsVnRqUUtUOStuK0ZMc2J6MitaUnhyTTJPWjM0OFpBWDAzRnFoaFJBU2Fla1o5SmVsaG1oc1doS0lHY0dDd1JRK3JmUmphYjlJd0QvR2hZOVprWThUdEtSTmZ3TXlRSk5pL3hLallQMlRtUHZmTWQrR09IRGxJZnZJaGdnUDdGNjd5TVlDYStzYjBQdnU3MndPdjhRd0w5RmZvZkdtem9XNlJ1SkdabkxpbU9WNTBaQXZ3SFI3cE85aTdCQW4xYU13SmlkbmU0akdIRy9hUjh0WkI1bzRQMmZEeDg4bk1zN1k0UTUraWZEcGlHQzJRdjcreGx5NXY5dkVhS3gzMFVBSFg1NCtPRGhCd1ByN2kwMkR6d0VGQ0JVbU5zSDhCc0lhYTJaUnZ6ZklVUjFBV0VOUGtDNjYzR081REJ3QjhDdjJuZi9Ic0Z3elJUayt3ak9CUmNBL3VSVmF1ZlByK3hJWUNMWThEcVNrV3lKWUVpNlZ1VDJydnExVFh2SXZlWWFDRE50MDkxc2ZkNVl1TzU0cjFzS1lPa1NUaWkxWjVqdWVJbEF3MVRvb0FBMDZONlRJU0JmbXd5ZUhyeWdVRHFCdXdOVjFxQ2t1Q3FRUnNQbkNpNzljYUUrdHV0VGgwVURxMzFIa0p1T1V2c0krL2dUZVo4Q2h5b2hnOUtzMXVaTUZSemszck5VNUVyM0JmTGRPOWJYcHdKTXM1OXpKQVZ6TmMzVEw1RzIwK09jQm1QS0M5SHdQYldVTDZLOGtuZk9ZRWJmOXZqa0xRQ2ZWc2IyRm5MRCtScEJSbmlPd0JzK3hnWlF6ZXBoK3VVSlVucHBJQ2xUNCtualI1L1k4MGRJSU1jYXdXbUxlMlkyRlk5bmU1Wnl4Y3dFV0VZYnFZSTZ4L0NVdXRyM2FQZ1dKUzZDNzBCMlIxemNZOVlQZ2x3YWFRZmtoaUVxeDNROGlQZHBUVk1LVFc4QXk4NUFvZjI0QjkxYzBXc2JTREpLVk80YzBLM0tKOXNZeStjUlFOdEFSMnJwdmlJd3RLM3dYMnNIS1pVdWtQTUJvSER2dWIwWDB5b1pYYUpzcmV0RlpUTXFyVzJLbEZsTUs2bTUyblJQVi9ITzljSm5QTXV6YWM2M1dMekJ2d1pnakpDdUw5Q0loUlhDZWcwRkVqUlZJZE5ibCtoWTVFVkR4am13YlkwdUFCS3RWa2VaWXVwWG16UFNoUXZrcWZPMkFRZ0FNVEMxa2xKT0FRVHBFL3NGNUk0eEU0VDBqK280UU9NeGFTTEhTSVdTZktXNGQxeDNkWDA3b0pRVjBnYU5KbEorUG9MUkxXbUg5RUxmb1dNSzYxS3dFeklXNWM4ZTVQZjkwMzZxVXhWQkVaNC9CWnM5citWNE9IZCtIcGdtanNBU0RjQnFWRkpuWGcrS3J1U3pEaitYUFVsWlo5RjI3MFpXME1ZRGY1d3ZCWEk1WjNGZDNmNWozOVJnaXZiNFpLOEcyclc1VVZINUNPV29hc2FGUWoxOGw4QUtJR3Nsc3NmRWZSK044dWplVmFpWlhmVEtFKzhFVTB2N3ZLbmZVYTZWdWtrcnI2YTVBeURQTXZlTnlzU05vNDE2SmpYRFFEUk9PSDVPWHNvNW9jRkQxMWNObXFTdkdhOFJrQlFZSUlkNStWcG9FcDNYZXVkMEF6K2YyQmlHWG5YVjJ3N1NWU0dVRVlmd2MrVlpkS3FwT3BjVzJ1eUx3TjJvTnhXZTc3MG5jSXQ2Q0JpcmtXaUZnZWVWOVRpNW9oaTlkVXY4bkZmZ0FZbkd6MlMvNzZQT3owbXZSd2c2eTlienFmUlN6MlpCbnZLZ3Rqb0YwZ25CODNNR1Uxd2k1MThzcE1WOHJ5UERvYXRiazVlcEVWbDUwTDU3Um8wbDdPKzhRRThPcFU2ZVdUckhLUjNuOS90U0o0T00xTEZNNVROdnFDSC9aeDEwa2xNOXlNc2l2aDdPMWNxdGkvSnpwZFhxcUV0RHBzN0wydjF3bjlmNE9XbTk1K2VaN0RQdHBrZm1ldW56amY5LzJyMG1nVDhycExTMldlcFgxMGV2NXhJUFdyWEpvV0VqemJMeng3M0ZiQ1Jxc0dYRUhHbEh4dThnYStqMmR5YW5DYytGMUkwaGZhejB1ME9UdGY2K3oydjlRTzdvUXFjdjFjOHA0L241WUQwY3Y1YzU5YXdBemtEbW51Rjg4dnM0RnFlZnI5MTRQQTVWdlc2aHJ3aTkySVZERit0VVdZYjdpM3VtS0hjNG5jdWZjVDh1ZnoxQnI4TVgrN09GUGx6VHQxV3VING9sS3Y2bDh2aGdqTXJ4ODQyeVM0M1hYM04vcUF6YmNhRGhYdHdrSzJJTCtXVVh4ZTNCaU0wVmVMSm1XeU5mcFA1S1cyY0hBd2VBeG95SVBJajNFU0xyTHBFaVMzOFp3RmNCZk1QZStVT0U5TTBmSWpmb2pSR0EweGxDcE9XZ2cyaEcxSGNBL0UwQXY0a0FndndBd1hEd0xvS3grUjZDd1dmUFB2OVUrdk1GaEJUUW15SWNMcXp2ZjRWZ0pDUnpiNENReWxqNnc4OGJCSEJtaG53UktGQmNBYmpxTXlwYWZXOGl6T3ZQQVR6cmlSWStRcGp2MzBJd29qeXhkNEJnR0QwN2ZQRHd1VHcvc3JILzR3MWpaL20vckMrTW51WG01dDJKLzRlMVNXWHVZbGZSc1gyR2MzRUcrQ3JDL2RMbkNFYmdQWVMxbWlHbEd2MHl3djU4eS9wTndlR1hyTy9jbTMvTG5tZEU5SjhBOE5IZnhmNjlLaSsvRkJUK0NLUk15d1lsamZKYm8rRFpPNlNkejZNSVdCbHB5alpBQk1FZEQ3QzlySEgxTVV6N250a2ExZ2hLOE5JTEhqMU1QcXU3QUNBcmdLUkNadnhPMnVPZERmSGVEV21IYzYrSzBkSUxXbTFLZlVKbFVvSGNrcEdWaGxFcWtXT0k0R0I5T1VCeWZoa2g4TGNsQXIxaUJvMlZmRTlnR3ZKL1ZncGpLMFpYeTduaStGa2lnRHQ5L09pRmpFV2piUTVob0lDTWsrTlFPYUo0RmtXWXBBTVBsZlBSTkRmK3NXK3YyL09NNUgwSEtWSnlNVFVqck16cmV3anI5TkUwUk8rOWJlL3hDb2c5Skc4NTZQdWx2azZUSWJGQmNqeTZoQUE3MXRlNzFzLzE5UEdqVDlya05KQUJRSzJrdVVVZWhhY2dETmRzRGpHMlhyZDRZRkgyUUZSUUhIMGw3eWVnb1FvbTk0dEdDWmVBcVQxNUp3TEhBa3h6VGhjOS9XQTlWRGc4K0o0Wk1hUnZFWmdUWHNHenRLck5wNEFLeGZTWXV5NXRNcDVyZndqdVh3NEFRUTZSSXVPandWTVU4MUxFTlpVQWpRS25JYVdtZURLTm93Y1FNckJHZVZLYjd1VmJDTzFnNnNYbDlQR2pDNm1mYWYrQTNNakFPNHQ3U3drYzNzU2ZibElxKzUyUnoyb01uQTFwMzk0L1FwZ2JPbnhHcDR1ZWRZa0drZEpaTE0yQjhGTE9XVXp6aUFTWUFzaldsV3VYQWNQMk4ya0RkYUtWZTFjVmJ3VTdsVi9yOTk0d0MvbE85YStPOGE5TkdRV0FkTjcxaWdqcWV6VFVlUEJZMjFKYVY2TE5TNWs3SDQzTG9rQ0pncEJLVXhVTUxZRnBmRGVtZjBSYUkyK0VoWHMvOWxlQVd6MmpwSjlNS1VtNmZDWDE4SGZmUGFnMDlHVEcrb3B4eEJ0MHFiczFLTXNBMGJpZ2NweU1QM09jR1VLMzVRendxb2VPWVVyR3BGa0FhQUQyZEVabFBUVm82UHpGNzRjQ2VEMzlWNGNzTlFDUmhuYXVWMEJ1NVBEbkw4czBWSkxMaFRkbVB5SkxxT05BZE43d3ZGWkI0OHIreUJ5SStMc0NqQmVOSWZLYzl1Tmw4WFBLdGV3ZjEyUUlQNDlHUmM5amV0NHA2VXFqdnZGZVYxY3M2T2VSemhUQVZNNDk2UnlkRHpmS3NoWGQ1V1h5OHhHQ3JLOEc3Q3NFeDllaC9Kd1p2UFJlMmh2TmVhME9XWWUxMEFLOS9nSDZubzJQR2FmSWl5NlJHenJJVnlqalVhWVlJOG5yM09mcVJBMjROYmZQTkV1WHlndlVBWGpuc09wVWxGYzFPcGJYVzZ5UnNpM2RSY3BHQWVrSHgwRzZ6SHE4QVd5RWxIWFJnK21zVCtVUHloVDhyc1NEdFVTOUJLTHZ5cnZlcUt4MXJWd2Q1QytLdTJNYU1vbW8vbjRsUEV4eGcvaCtoZjZTbHF1OFJIN3VhVG5sUnZJREdpZVk0alRMZGlIeXhRaEpiem1ZSnNjcjNYOThmNGo4ejdtTFRsdUZ2c1kxRjlsbmhLN2U0REVSUFd1NlozYUd0ZFZvbS9DNWtneXZmVlFaa25zcnkrSlZlRDg2Q3lDWFdlaklIeDBacEsxT0ZDUHlzN21jZHVVTzdqaytReDNjNjZVYlpiZzJPWFR2UEp0anBUM0ZRQURSVlFieXNhZzM2eG9ybmxsWlY3L2V2WGRERCtVdEJWNlM3WCtWdmR3NmsrYXIvRWo5ZkJBL0wvR3MyK0RsdGZhUlg5TXhXQmFST2w0cTNsNDRzNXZ3ZHFiTzV4bFdiSmw4cHFTZk54TWdHdUpXczdQVFQ1SHV4eU9UL1NGQ3BPaFA3UE9QN1BjYkNBeDVnUUFRVUJuYlZ0Z21HUDQ5QkNQbkhmdWNLUnZmUm9xb29mSDNpVDF6QjhGWStLOFFJbTkrQjkyVTFRRHd4d2ozeUg0S2wvS2tZQkJjbXlGd0RRQ3pzMU1nR01hUEVBRG9aL2JEbEtpYmlCRVhiUUpMZ1YxNnlJeWdjNFFvVjFoN05GNyt5TWIreGRuWjZRdnBzeGNZTmhYZU8zbUlZRGhmMjJjL3NOK2ZEalhjYjF0MDNIN09MYkthNE1OVGhMdUE5eERXOGdtU0FmNEl3Ymo3QlFTd240YVQzME13N3I4UUkvTjNFUVRiZXdqcjFnQVlXNlQxSllEbThNSERsYnY3K2xYNXhTa2tYSDVkeUNpOXdYVFErdDBpMGZaTW5veHk0Z0FXOVpvOGdCa0kyNUI2ZGFoZ280YVZUWjdpTk1hZTd3b1k2QU9sN1U4YU02dnBudTM1ZlloaGgwSnZTZWsxSmh4QkxpQ2tFMlIvQlB5SUFDYnJOV1ZEaFdaTisxbWFrNlpOSHFtZXAxSFF6aFFDblpzMnBBNmp3T3E5NUh5YTRQdnk5d0dTd1pJQ1o0Yy9zWSsrZlJsakE2UTdaU3ByNnBVR0ttZ3JFVUJHTmhjVThQMzk4bXZrWHN2OGY0VENYZlEyNTlHNzJOYXF0SmZvRkRaRzRIc1g2Q3JkUnpabTNtT2xDdjFiN2ZISlIwaUFmd1R1a1VDRllocG83YXY5T1VZeWdIVHUvTEF4eFRWcFEwVFRESVZpWUxLbUV6dEVkMjlGcFJ2STBtc3lwZDVXbVE1azd4TlFuMDlUeXJpU000RWFJOVJJWFZSY1BDMncrVkJBaHArekhUWFNVTVljK1RGWlBZeStLaGtnQ0ZEcE9uWG9vcDF4YlRNV01UTG9IR1RwOVcrcjJMcDQ4RkU5N3pldGNRU1ZDYnFJc3JaRzl4b1ZBcG4rdkhsQXdaZG9iTEFTNyt4U2V1Q1Vvd043N29xMHhOWnloSEw3ZXJhQkxmU0lFazhieWtmN2xHdWpLd3FHUm9OYmUzeWk2ZUFKTG5tano1QTExUE9pdkU3M3RlL1hYU1RnVkNON1BEOWdldDZZTmhLNVF0Z0krQkwzRW5td0FEeFVLbWs0dllDQW9hNTkwbUtDZ0FyVzZoNWJJamVja1I0dTVQc0lac21jTHQxZTBqMVg4clJYWHFucHJqMndBK1RnSS85VzRGZnI1TGxqV21SK1h0ckxnS1JMbHU4VjFQVkFHZnZqUVczeWFlMlhycnZ5ZE5nWW1INHkwdlUyT1Uyb0RNMnF5MTFnQUFBZ0FFbEVRVlIzbFk3eWYxMGJYMkxmN0N4MTlxMGFSYVJlcmtIVzU0THhpMmRPNTZBRVVBNmwxOXluSzlRelFyQi9kTEFvMGlQam84eDBGZ0ZDZE5jNCsxdG81QWpoN0EzR1RLWjUxTzhZNlF4ZUFkMklEem1mOGI0NUFUZEw5WmZtZzN5NDlGd0dWRk91S01rb2xOTkxiU2pnTFIrWFFLOGFRSy8xNk9mamw4alBkV3hLRzRid2d1aUU0QXhoalg3bVNtbCtOcWFYTEFEUG5jKzFVR2R0ajArVzBrZktWcVhDTTYzbmN5Zy9MK3BVUTk0dDBBNzlUdlVFelJheDN4NmYwUEdLdElIOFNIV1pDZW8wTU90L20xSmtWc2NrL2FLRDhjTEpVUDRzaiswN3pSU210SStwZXpPSGxnby9aMkRFRlZLR0x2QTkyWGVIOXN5OFRVNTlhNlNVejN6dkNrbDNCVkxHQ3ZaZkRiNXpmVythcnJ6d3N1R1YvTlpvVnZKQTRuanFVQVg1VzMrcklkODc2cTJRZEhRdlc2aHppK2ZuSEkvU1JZNVphWm55YzAvam9rRlVmdlA3VEpkQmJxeFRSMTd1b1JYeS9hbno0V1hEYU56WE1wVnJsSUI2S21iWkMyd255bFFlWnhGNnpPZVdDS25FdVo4em1pbXZEc1hDdUVhZEt3ZWtaUFRPMnFzNTBhdVJ6c3RXMVhKZG81RFQvenB6MFZPZnlrK1VPenA5cU9BVnFwOVRKcDMzMFBUT1hoQTZSNE8rWHk5MUlOR01YS1ZTMU0rQkRqK24vSHJyQnNTQ3JCS2psdnY0akpTSSt6bDhVNTNsZk5rVlArL0lETzU5cFlrc3lxczcvYkxmK3YyZzgxbmg1NFBXcm0vYzFHR2tYNUUrT2o2cWREY2FSUWV1SVVzSFYrcnBNek5tOVRxQVYzaDhWai9IM3lQVGNGekVOUzhGNzhzY0Zkb1VxTUxzaUFBd25nQVl6YzVPVjRjUEhxN05NSGZKaUV6N2Z6RTdPNTNaeTFTaXY0UmduSHRxRmZHdVBONzNPTGI3aEhzbjJJeCtoMGpHbkw5QWlQcTloMkRrMjBlS1JINEQ0ZjdmR1lMUThvSDE0elA3L054KzB3QjhnUkE5KzNNQXY0L0FIQW5NeDlTYVB2S3pZQWhjSTREUnYycDltd1A0bHdEZVI0ais3ZDNNWnR6OEJNQ1R2a2hocTJjNU96dDlnbUR3dlM5Zk04M3hOd0M4bUoyZGZvUWtHSDBUdzhyM0VBeTl2TmY1SGFUbzRuTWJ6NjE3eXJxOXBZVXBzTjhDOEtkSXFYMEpIdEJUY1lWMGg4a2hnSDhENEttZjI4TUhEejlqa3piL1BKalovUzJ2REwrL0dLVWtxS0J1WUdQMEFJRy9XMWZ3Z1kyZU9GVENJak1TWWNzYjUvUnYvVDJvYktNUUkyVWZtTFhISis5UGQrakYxQ2F2VXdyM2E2UnhlMlhTdDhPMHBBMWNSSkZuL0dLbzRUeE5JR21IUmVHbW9EVkJBSDQ2MFJEV0o2Ym91a0t1TExOKzhnaE5aUVVnenRjbVF6cm5wZU5wNWtBNGVxWlJFYVdoa1lBRUJleW82SXN3Q1loWHBiVEx1YTRCc2FxUU5lNXZJSUIzZkpmajNKUDNGZENaSUJrR2x0YnZvdkhUbFRHQUE3OCtVblJlNWtqS0NlK1dudG1ZcVRTL2hjRHZHU0hGZmYvTWZoOGhHWEkrUUtJYlEwcEpHZmVGd01qYzJ2dXc5cUNOZHdaRVVLcmt3TVc5VEFjUktsTkxBSHR0dUtOc204aGdEMVF3Q3F4MGZ3cnYvZEtJY2ZhcHdUQ2pWcXdET1JCRW9EUUs3K3hIcFo0MWdqSEpnN3JzanlvbTBTRGw2cmprdnE4b3FkeERUSmNINUdETWJSYmVLOHgrYVFSVnB6aWEzZGk3T2w0MUdHVjFsSXdZdWhkclJRME9wb3hjT2pwUUt0NXhvSnA2MnZZRGpTRUtKdDBxUDdjOWVHajhtY0NSOG5ZRkQvbS9Hcmg4SC8xZTlFQlkxUk42R2h4RDR2Y2JRR3pTMm5GN2ZISTBmZnpvd3M2cE4veG5JRmFiSWpBb1UzZmFhbE9xY0k1SHh6eERBcHNpZUNER0pMWS9rZlBzamFzbDR5ZVErSjlQRVVqZXEvZVFSK09uZ0VxODFnYnlqajhEcFArUTc1UVAwSml1bVZsOFh6czB4b0U3SEo5dnMzTWVwWkNtYW1TU3RsOHlvb3hSMkdPdVJMNVY0T2RqbUdHNDBnNzdjWVVCOU43S3FMVEgrWjMyUzJUUW1IVkJ2MjlUbEt2KzBHQ2o2M1BkREJtYmFBdjM2d3BoNzFXejg1QkgyWGdvOTNrYXdMb21BZ0x5YkIyMnh5ZVgyNHhEenB6dXd5cS9LdEFUWGVkQlJpMGtwNDRNdEpwS2hBdmJhcE94dmxoWEJYeFRIazhncjZUL1JmMmxSRStSNzEwRnVWK0ducys3M1pTZnE2R3NVemFBdXlXamVDeERkZVlCNzJ3cWtTK3J6RkZaSDY1LzF2ZmIxcytwVHhudnlTSlhyU2o5NTVyb0ZUdktvL1E1ZmplNEREM0x3cE5YQ0lib3hmVHhJenAwOEU3TG1oR091bHhHdDUzZXpGVFdTb2ZJenkrUXNqQkVHVjM0V05TQmhkNm8vdTE1bThvVm5QY2orVi8xWnVvOVY2MXpuclZuN2lEcGNRdjUwWFdnZnFUdGNVMmpjNC9vV0VycitFN0hVWG1hc21Xb0RxcjhWOCt6bm12T0QzRUZ5a20rcUh5ckRtZEFWemVIL08weENDRHhac1ZHUmphbjNrbUtPczFnckdrRFA4L21SV1FuL3MxbnlidFpWTmVpY3hmM0llbjJOcGt5aHVqbkFMS1V6a05wWk9uTzBHSVV2amZhRE94N2ZIOVRHKzV6ZjBldHZyOVJieFg5bk9kODRYaldDQWxUTGM2QjFLTzBYa3ZwblJMZUVCM1UvWm83T1VmMWg1ZFZSdTN4aWU1RnlwOUF4UUM2WVMrUWRsU05mb1hQZTgvQmRXUUFKRm9jK1hrUDNzN3NRSjdXM1RZL2I5RGw1NzVONVQvTU1OZndmY0dmUFZhMFZka1NiMmZteTZQMitPVENZOHN5aGs0L3RNK2wvVkRBZUlFMHRrdWtzeHA1aDd6RGF4bWI5dmlFUWI0amVwOWxucnNhQVd0bGdXQWs1SDNCVEZVSmhIUXBSd2lNOUFBcFd1ZWQyZG5wTTRTbzE5b0VyaEVpamcrczdqZVI3dlg5QmdJeCtuTUVRL05UQkdNd0VBN1FCd2gzSmhKc2VoUEJHUHd4QWdEN1Ezdm1tZDZiQzBjZ1oyZW5CN096VXdVNkZDUVpJUmhMdjJaamZHcHRQc01BNHk4TGpic0RuMTNPems2L0QrRFhFQXljNzlrUEFQeEg5dk9ITnRaM0FQejZnR3F2RU83VEhTTVlrL2NSakwvdkk0RDJ6d0FzWDZJeDFOK2xyRVlUQ3QyY3I3ZnRzeU9FOVh5QnNCZlBFZmJnanpmZDYydjdidzVnUGpzN1picTdWMm1mLzhNdHZFK1VBTlZRWWJGYXRoRGNSa0pVMVdzNzBrd0ZPTHl5M09aMzFURWlaVkQ2NmczOUh5RVllaGZUeDQrZXlWZHZJWGt2VjVsZjM5alZjT2o2eVhURy9FdzlrRmdpUTNLZjgweHF5ak4vanFNZ2FvS0FLa3RVemxRQVpqOHlwY0FMWmNnRmg2YnRlajJxQXMvbnlYUTdnRmxodkZTMlZ1NFpaZHg4aC95U2RJK2U2bFIrMlpjRHBQdHlTeDc0M2x0NTVZVVBKS0JlZ1FDQ2s1eVRtZlNWWU1BYUtRdkh3cjNQOTNpUGNlODlMclkvU2dBTjU0bHRjbDQwZmQ1SEFMNklsTDZSZDVQczIyZlBwSTkwR3ZvSTRWeVFYMmpLdkhzSWU1REFBOUNOakxxeWV2dm93em5DT1J0a0lKVzVvR2M5RFdCQUVzNjVyenZlaTloQ0VXcFRDdWlsKzd4QklhcEJ6anJMMnYxTjU0dStOcldmRFpJekJtbGhCSEhiZEQ5akxUWHp5TjR2UlJXcFFGeWxuOU82MDBiMHVMZnpWTjJYdDFTOG5MMUdZVzdGQ00rNW92T0xHblhWYU4wSEdvNEw4OGp2SndnWksyYUY5L2Jia0tWaU9SMm1aS3BoZFZPWklXVnp5Y0Jtb0QrbFphMVVqQXhhMkE3VEp4RVU1UjdsUGVlUm5sdDlIcVR3eGt4QXpsdmI3elRtKzZ4OGl2MGltS2tnQkVzcFpTcExCTktFbnRNcGl4SGFCT080OWdmeVB2ZmFVK1IzMW1tVW93ZWZSdklNWmJPMSs1NW5VZTlOSm85VmZxNGdwbzdSRzI2cHI2bDg0QTNRYS9kYi94NVBIeithR1MxU3VrZGU2ZDlUMmdray9xbkdXMjFEd2MxYVg3U3YrdDBjT1YvWE1iSXRndXZlV1NFK1Z3RHdnWnl2bElvYVdmdjRlWFRnNlFFdHRPaitKUkE4c21lMW54eWI3MmVNMENvQXNTWCttTW1zMHhTMTI4ZlBkWDhPMWc4RldOVVV1RUFlQWE5cEUvbERYV1pqYWZPN2ZmWHpCaTdia0g1WEdHczBHR0FETmlGcnlLaXRqQmRQa3hNRXp3V0IvRnBkTlg2dWZSc0swbWVmdGVMVTFwcno3VzBiSDExUlEwMkhYMWkvdklGeGpqQW5QcnB6TGZVVVM1L2VXZ1BXN2J2QmZHbFRId3FGRWFHa2YycXd1TzQ5ZnIycE1LVXQ2dGZyTmpoV2NBNnZoTDZ2MGVYbks5bS9QQk9rdnd3ZXViYmp0SURERFlEbklrTXBQNmpKM2JCKzZucHBwQk4xSGRVM2ViVkc1SFAyY3lHZnIrVnY0bS9hUHZ2RHEzNzhOVWprdlhNRWZFNXB0ZDZacTN6Zmo0azBVSTJaNUdtdy9xbFRtN2EvbG1mSjg4YXdqSUZ1dlVkSUdSV1ZUeE9iWUlZbHloTHFETXI2MlpiU2NOYmRoM0d6YUdZdnRxWHlqc28xWHJmeC9KeDlZLzlLa2NpK0h3M1F2VlpFeitRMHBYRHU0K2Vad1ZHZW8yTml4TUhjMk1qclNqcGxKd09lakRPVDR3cjhmQk92V0psOGR4M2pUOVVBYW4yc0duS0cxSzl6N2VzcTZUQ0Y5blQvY1IvMDBtcVpWKzZaQ1EyZHFpdFQ5N2EvYS9lOWpoRE8ycVNpbjFPUHEvS2FIbjFTZVduTXFQRVMrWG5XcjZrRTlHaHBrOE1pNTVVWlV5SWRhMU4yQnFBbllHa0FQeS9xdzF2eTFXMnZVOUNydWdBeHV0NkFudzk1TDlOclBJYmtjRTErbnYxR3JrdG92VGZhUTliMklRSWZmdUcrMXJaOWYyRC85emtCMEJscWhlUmNTbjFVeDd5YXBpdHErRzdVeWR2dWRXN1U5OGRHNTY5R0NJYS9JY0lkQVIxdXZpY0l4dENmSUVSc2ZvaVVycGYzN1AweWdPL016azdmbnAyZGp1eW5ZZHBkSkVXQnFYcnZJd0FPQkhnL3RqcGZBUGo0OE1IRHBmMnNrUXpDVDVBQTRKOEMrT2NBL2dBaGpmQXptVEN3RC9ZMysvRWxoTHVILzNNQXZ3dmdId0g0THhDTXJsOEQ4RzBFSStSclNORjB2NEprcUw2TmNnZmR1eWlBd0NnbjF0Ky9pMkhHWHlETTM5Y1I3dGo5QXRKaFprcnR6eXJ2N2F6SW12TkFUMlpucC90MjczR0RZR2ovSmV2bmw1QjdZZDVIV01zWndrWitncEQyKy85R2lwWWJWQTRmUEx5RTdlRlh4dC9ONVRwQzAyMjNZWVR5ZlByNDBjeUVqaHV2NHhBbVprUmJpWHNwZWc4d3h1Z0FSWllycE5UeEpNaTdTTHQraUVDVDdyVEI2eFhXMXg4am5KdW5EclRaVmdqd2Qwb3FZOGtFU2xlM0FybU04QUZTdEdaVUtQaWVDc05TRDFNblUwbWlvc2IxWDZsd01IMzhpQjdBbWFCaGY3OUE0RGxMSkdGSUFVODFKR3VVWU1lSUpnb1JuL01PTENwSVo5RXJTTmNJOEk3Ynp4QWNvcTdrR1hvaWo1RWlTSHloOHE1M1hjVGkxb1B6djVJZkFMaVlQbjUwTGdZZU5RQ3ovUmxDYWhONmozTVBVRmtlSXpjaTZEekZmcHVpVVFLbDlwSHVkUHBzK3ZqUng5TThoVGhwUDkrOWo4Q1RPUWR2SUp5QmU5YXZRd1JlY2tlZTIyK1BUKzZhY01STUVxOGo4UGQ3QUY2blViSk45NEhkM3dBK0xaRHVidDZLSDAxVEZLWWFOdFRibmVCSU5GWmlPeTlHQWtkK3poVnNBQkFGUm9KSkJHa1ZXQnNLaUtzeFFvRnViVXVkdmRBZW40enNwelMyQnNueHhoY0ZmeWFGNzZ2RnpnVUY3QW13bGVmNWpZcTFGNlB0U1NNcWRMbEVnK0xacFdJSXl6aGc3NDhMdEdLRU1JODFCNElSQ3NDOTFjZTB4NXZHRkExN1EzbU1yY0Z6QkVjS0dtRWIyWHZYS1J0QklTUWVBT3Z6bnU0eE96TTBTcXV6Z2hieUljb0dTK1FHMjJMRVFJa3Z1ZWZvbkxGRUFpNFpJVTVlOGtMNjY2TTF2YXlpWjUzenVoVGFUQUJVamQ0Kyt3RDVyZkp6YndqbGV3MFFyNEJZdWM4NFQwcFRmUDNxUUxWQUFBaGpsSkh3S0tXWDVKbkt2MWluMGlDbFp5dmh6eXFmK0tLS3QxNTc0QjJ2MXU2NVVncEp5R2VVSFVyZ2VOYTJHQ3l1SE5qbWVUcHN6RXZkdjVVZnpwOXZUL2RBVmp5WVdqdm5NcTlyV0JhQWdpd1dRVEYwZVl3SGdDbm5OUEtkZ3FocStJOXlHYiszZnU4RDJPK2o4ekxQSFI2NXFkaGNrRlp5M0xwV3hEeTJpc1p5NzY4S2MxN2k1NHlTSDdVV1VXaGZVV1llS3Y5enJyMURvN1pGMnMvLysvZ00rNnRGRFN4QWJzQVpYSlNmWGtQSHVYWXA4WE14OVBwQytTamo1MzQ5VldZcnlVYlVQVGJvenpYUWZWRFdySUZ0K0xyWENMeVYxNVg0TTMrZDBpc0gyRnFya1JLUXMyL1ByT1JzajBSUDFyNWRJR0NMNUwxekJLeWh5cytCUVJpRzZ1UnFpSXp5L0RSM1BQWE9BN0ZOT2dkSW02eEhEVjFxZ0ZjSEtmSWF6aFBuVFBtVlA0dmtyYVJsbW9tQjJNV1Z2RThITUxZRHBMMitSdEIzTG15OFl5UitUdm1URG80OEk1UXJLQk14YWxmQmZiYXJrWTJVYWJKNVJzN2ZxQ2VPcFI0YW9WZkllYlNQcUZZSE9PVmxZL2V1TjBCQXhzeDIxUENyR01GSzNsL0tlZkk2VnVRM1NKa1NkWXpzNzZTd1Z6TmExY1BQaVRHc0VXU1E3UHFDYVRMa3FTTldOSUlnbC9QWWIrNDNHaG9qM1JlOFRkY3I0eXZrYjlzWXZ3WStGOHNHZzF6cC8rdmdtVms3UE9PdWZwWEpKNktmMDVHZ3htOTg4Ykp5aGluWUdpaVdSRG1xdEhkWUlqMlN2dXZlYTNyNFliSFlQb3lSMnkrWm40K1JkTkFvei9nK2lPNnRSbmlnaXlVMENEeWVFZkxqeXY3cDQ3VWxPZ0pnR0Y5VnZQSWEvSHlCbE1rcmp2TzY2N0hwUGZ1ZVBNcnJBL0VaeFRVcjhxTHlJSTY1TjBobFlLRzhPNlljWWV0OXpqWnZnQ1ZGZmk2ZmFSUjJ4SHR0SGRVNVRPV0dJeVJlTmtmaW04eld0TXBBT0Y4a01yTkJpcEs1UUVvZm9vV01GQWlnNlJJQjFKa2pBS3ZhaVRXUUdlQVdzN1BUSHdMNGF3Z0FjSU1Rb2ZvakJNTmZxVkJvNFYyeHY0b1E3Zk0rVXJxeVBRRDdzN1BUT1FMenZnZmdxZDNyQ3dSUW1GRzJta3FaUnRKUEVTYndRNFJvMndPcjV3NkE1UzFHa0w2MTQvcGVSd0RMMzBGSXMzMGZ3ZGp3WS92K0NvZ3B1VWVIRHg0dVptZW5rOE1IRC9rNTUva05oUDN5c1l1cTNsaGtucmd1Rk9iZVJZcmNlczkrdjRsd1ovTUN3YWovVXovUHRxYno2OHovSzhQdjhMSXJodHZuOFhPZE5ncEEwa3NwVkNEYml0ZWhDQVRLdVBnZEdaUUNOU3JzMzZSUU1mREdGcWFrV0Y3WFcwc0Vld0NaRnlnVkZ3cEFuVFNBMDhkWkdtaFZXR2dvWEVMdWlyVDZPNENUMU1OM0ZHaGRBWG42TlhuV3AzR3BSUVRHZFd0VENrdE5qOFcrVVdGUkFZajN3S3JTcHYzd0NqWGYxYmI4T0hWdUc2UjdsemdlRC83cDM0MDlwOEl6RlVLQzZUclg4YjVPSUtab1pMK29oTk5ZcW5OemhCVDVTNFYvSzZHSDh6bE5FZUFYS0hncFM3bEV5aHJDOUl3MGpOQnhURUVEemcwamZmY1FITHI0bVk2SE1ncTlDdzhRenMrbHpWT01XcEU1WmFHUTJYdTNjS1VvNktDRjgwMGhsZ2FLd1hNOHJSaXVLL09yQ2grUTByblNHeEVZRnFrVUJWSUIyY2F0cFR1V002SGdDWXVuaFptaFFmN1cxRVR4bmRaNUlqc3dvVk5hOGVURTdweHhoaFJQcDczQXI2WGtmVTBheVNpbnpwMi9mc3cyWjFVajk3U1NwdG0raXpTdlRlbnJGMHB2NVd5VTdvVHFMYzVJTXBmUG1iNTRORTNwK1doZ3JocG5odkE1NitPRjdRRkc1MlNGd0Q2NmdLem41d3A0Y0svWDVvSFA5WjBsN29jeGN1VldRYVo5Sk5xMG5oWmtJbjZubjAxVDVnRWdONmlwOFhjdGZ5dUlyM1JWRmZPUmZNY1U4aXZaSzBBM1dpU21DRWN1dTVEdlFkYWNBRklFcUdWdWw4Wi8xWGxNOVZieXZyWDdtK1BYMU9sY0UrOXR6YUlnZzRKb2NIL0RQY2VJYTUxYnJYY2xuMldBSi84V0FHM1Vwa2lFa2MwRkk5dzhvT3BsRCswejMyVUtjUzBsRUFKQWYxU01rLzlpMnozblVZRnFuWDhnbnl1NDM5b0hnbW5zYXpaV2FUdlNUTXFrUFhTSysybHJFS2RnbUdGZitEblhZNFQ2bmltV0h0cGRvek5hR0kwVG5STDZhS2dVVFFjSk9QblNQYXVBTW1WeXIrOTB4anRORVIyZE5kNVdaekdhWFdyN1ZvcjBXL3ZadDY1RmZ0N0tkUkNGOWV5Y0lUdUhWVjYzemJ6VjV0bnJma09MNDBXZWIyWm5qK2Vscjc5RHgySnl4Slh0Z1pMekZaMGNPN3FLMEVBNjVKTCs3cG5jVkl5Q3E2eS9MNW5NNjR4RmF5QkYwWlhtdy9Oejk1MW0zYXFsR2FYRGlmSnpQa2UrQ25sR2VjWUtGbm5XcHZ0ZlIwaDMrSkpuVTFaU2ZzNzJSZ0QycHBadEE0bWYwZEIwSVRTQStpYmJWbDZvNmFGMXpMQTJENUhMYXBRbEQ1QmozWHlYQmszbG5menhoZ1BPRjJVYWRlTHhSbC9PS3d0cGNlUkZ5cytscmpFQ3ZXVUdtaXhiZ0wyanpzQzZWcDZmSzUrSHZWZWoyVVZuRzdmZmVHYUc4dk9WOUtlMEgzVmUxSmxlci9mUWM4VnpFWjFpT01ZaE5HVEk5ME9MeWorVitSeFV0cVRkZnY5U1AxZUh4TUg2dWYybW5EdFJIUTVkWFloejdiT0dSZG1Odk5iV213NmVmSVpybG1WeUdLaWYweUgvcGZCektWNC83eFFiYThuWUYzWEFTcit2dzg4SHk2SWxmdTdrOHEyS3gxNThXOWlTbjIvUkpqR0ZvcDJTdUJ6cWVEdlBoVjVKTmk1Z3FINDhRL3BmaXJiWG9JYWI0TzFSNzdXUE0yY0tlYnltdzNCZTZCQjExMzYvZ0FRWVZRM0FzN1BUZllTSTBVTUV3UFVwUWpybExCS0tFYlZBOU94NkRZbEp6NUZTTHk0QkxHclJ4b2NQSHM1blo2Zi9Hc0ZJU3pEMDV6VkRvOTJ0ZXdqZ3Z3VHdMU1JqSWhBTWlGVHFueUVZTzY5czhHbzhlR2FmSGRrRU1kWHlCTUNYa2J6Mlh0ZzdQMFVpbkY4RjhLUFoyZW41TGcyS3M3UFRQWVQwejlzVWV2OW5YcmhTTGhBTXFoOGdyUGMzRWRib3l3aEdkaUJzamtNQWU3T3owM2NBM0oyZG5mNi95RDNqOWhHTXlPUFoyZW1IMnhxQnJVeXNiZjMvWFlUNTFEVmJBWFZqN1NzajduOVlaWmVDVjBVSjQxbU5ZT1d1MnF5VUZRSWowWlJzZTBoQThndllIVGRDb0Nsb2owVFJvMUh2NmliQ2pZRzZIeVBRTXRaTkpzRG9xcDBVRTFTb0JESFZWUFMwNGhvSmMxYkRuQXFTdkR1K2xEcW14cUNYNkFvYmVwV0JwMGtaV0tqZ3BhdGZBV0gyVlJWN3RrSEFPZ01RS0x6SnV4bHdRa1ZaMmxmRmhrcjdsZFJGUlJQSXZiY3BES3NTeUorb29DRVpkV0hqOTk2WWJIOHN6emNRTUIxSmNHZGZLQy9vZWkyUTZIV2ZaMTBuN1orZDJYMEFpemFrVHV3RkpPWDVGd2g3bW1tWENScm9YTkNZUjJHSDBjQ2ZJSndGdlJlWUVUc1RpS0dkWTBKUytBL2JjSC9HSGdJb1JLQ0NnTWpUYTlJY05VQ3NaSSt3TGxYSzRqNXBVMFRpeXZZWG5Tcm0xK3dIalRLcUtLaGlTWnJTUzZlY1FFcGdDQkRCbS92Yks0UDZyZ2kvQ3o4ZW9XOWExRmpBWjNwVFlzbTVaVitqVWpFZGVKZmJkY3EwYTdCVk9oV0JuSjRxQ0tMeGR5ZlZhYVhkRGhncis0M2dVK2RkTnlkcnBCU0tyTGNLK0xwNm9vRytUV2tLTC8yNWI0OVA3aVBSTktiVTBqdmNkbGFveENQZGRjNTJhVHdrbmVRZXZaTHpTUjZuaGtQU3k1S2lYSFhLY09VU2VhUVFhUklncWZpbnlVRGVVWUN0cmNnbjVUa1BkQ3JncWNDYjhqNENPZ28yQWJueFRubVdHc0hJUjByajV2ZjhUdmtzNWFMc1hOdDRkQXdSUkpMOXJJWnFuNDR5YzU2QXBQdVZmVHh2OHlnSWRZaFMrYURUTjZsL0pmUkY1MGJIclVDNWwwZThvWjJ5Q2ZlRDhuTUNlU1huUWswUjV2dENmcTRnY0l3UTdURjRrSllyL2FZc0d5TWQwSE5XMjVTaWpKaUNOMEw3T1ZtNTcvejFWZjczR0lDbVFQZUErTGhOZDlYN1BUd3EwT2loeFJ0NitWbXBuMnVZek5xbSs2ZVhPK0xuM2dqQkV2ZXY1N21sVXBDVEZaVGkrcGZrOG1LNndoNitXb3FXend4ckEwRTE2bi9rNXhsQXVldWlnSjB2R3d3RnZtVEd3WklCc05KMnNXeWFLLzErRjdxeW5yT0N2TVlyWkpqRkxjcGxxcFB0c0t3UmpCcjYveEhTVlRhWEFNN2I0NU45MDUxSk8ya29aS0RLSGFTcjdaNlVHdHBFNTZ6TWtHZnk0Rnl4MEdnSzlCaVQzZmxTR2FURXoxV0hWWnlXeHNzOUpOMTk3WjdWejdRbzM1cTd6L1Y3MGxYTkVzTG9UYTJYZTc0amEzR2VqQlpTajFoSmZhcW4wWG1YanI1QUxrUFBSSCtNZFNQeFZFWWpsekl6eEd0cXJDOXd6L20xNHBxc2tOZlZNUUs3NS9rM00xV3dIU0NudVNxajhSM094Y1JrV1YzUGFQRHJvWUdqdHVzOHExbFNhbzRwa09jcHIwUlp6aGtGZFkzVnFLejdHZnE5b3d0am9CUDVyakxTU0hDUmFDemVsVUZxYUIzNnpIV05RSlVTSFVLUjFqWHF5RWl5WHEvZTZuUnNsUVZqQUlmdG9USE1XYWxOZ1FJTGVaZnZkZlJ6NVBSdDVUN24rOXZvNTVUTmVtV0xYWlZDM2NxYm84SGI0VFMrOEg3cmpyTmNqMzdld1RuNDJTWlpiUmQ3emJWWHhTTGFic3I4NmhoMlZIaStsVTc2REV0WHJSbmQ5UjNrWjRYOGZZNUtzTWJBTTc1b2owK0kvYW1PVVhKazNXWFI4NzlFd25iSkF5WklBUTBxWi9HWkREUFR1NGtBUkFQa1BRUndsWWJJbjloblAwRXdCUE5aSHVBakpBYTBqMkFFZm9hVUpwbUMwNlpKT1VkdUJLd2VjRE5RZnh2QVY2ejlQUVJENzN2Mm14R3JQejk4OFBENzl0cUZxMlp1QnV5UHJPMHJlL2NjSVFLWnFVSS9RVENVWGlBQXo0YzJ6c1d1REpHenM5TUpRbVR1THlGRktBMHR2NDhRclh3RTRMOHVmUDl6KzU1M2Y3Mnd0bDVIU2wxSkF2c1ZoR2pxRCt6ZE1aTDNBQUQ4RmNMODdNL09UcThHcGcrUHhRejl2Q09HRzNZZmVkVHpCN0MxOTNjRnZ6TDh2cnppd09Hb3FPMlN5V3o1WG1Zb2MrVU5oUDI4QVBDVFhTcjdGY1o3Q0RPMkl0Q0ZCdUdjVUhCdkVNNFpvNFVwU0ZFZ29QTFJJTCtYVmR2ZFNuQ2RocnNJTkFYdHNqMCtlUXJVNzMwY1VpcUt2ZDZkZUltVUlvVHByem11TjIxc1RKTUxKSUU5RXg1RXNJOWduRk1BYUdSZXUrZWpJaWRycFczdys3RUp0a3NrRDl5cnFhVUdzM1hpUGZjdklQZlB0bm5FRkVzbS9LbENJKzlFNEZIQWVpQXhicjBMa1lvVythb0tNbU5ZNWdra0lYK3Vld3FpWENIeFkzVU80bnVxUUhIKzFkTllRV00rUXlQcHlvREtGWXl2TzZWeEQrRmNYQWlBU3Q2MmJvOVBucHJ3TkVFdWpCMXlUS2dYR3Q2cDNQTHFDRTB6dHBiZmpIN25tczBBM0pzK2Z2U3o5dmprRFlTelNubUdBaFZwQ0kzYVRBZEhoNFc3VmcvM1BvVStCZVFIbDdZYnViUnVrMkdYam1jYUlVemdWb0diUFFHeSt6eHBGUWdxQWJFOHB5cGtFc3hSNDhOZ3hjdVVKTzQ5YnpCY3VtZVZGakE2WURVdEszcTZoMm04aStOWFhyR0pmazRmUDJJVUtNL3NQcEtUeE5iUnJOc1dvUU1jQzg5eVgzU0ovcS96cGxFWXNIcHBVRkRqSk0vZFJPZ0hBWmE1UGEvR3IzMjJNODA5YzJtd20vZk5rL0I4ZllaM1grc2QzQ3hNcFVRK0UrOGxIZ2k0Vm92Tmc4K0N3SlNKQjBnMFNOc2hIVm5wKzBLdkNYYnkyUkl0NExuZWFGaXl2bVhwNUlXbmt2WVJ2Qy9kU3hVQkdMY3Vha2dHMG5yUUNNZjduc1pJWUQzM3hoR1NFeTNYWFpYS0xEdUdBSWdhNWFGR1BVM3g1VUZRbGttYm9nbkkvNk1qRkNUYmc5QkU3bmUvcHlMOVJJcDZ5b0JybGZXTWYybDBsY3AyQ3VMeWIrVUJyRS9wS0QvbldEVnlYSUhzVWVINVJuNnJmT1BueTMrdXNnRGtjODROK1RuUFpzbW9TOGNRN3JNWU1kYW1LQWVOVmlKZDZBT2NnWHp0YS8xWCtxZnJ4YzhtMDNRUFZ1UDZUdWV0ekZBNVRaSHBRRGN5bSsyTTIvcTlkME5MZ3dSWUt5aWtNdjhjeVlEUFBpby9MN1l2NEp6eTg0eXVURk1remtoKzJJKzRydWdCWUgwUlFMYnhuMnRmQzdLd0dsdEtEa1lSTEhicms4bjZBOEU1M3k2ektBRG9qVjdiU1drbEtrWEdvdU9vcld1bVowdGRDdXBIUUxiTmpXbmM0MXAzSnl1UzQzbWRQckIvMTVSNXRLKytidEx2dXdqNmNtZXZYcU05QU1Xb01qVThOa2hYck1UMHRVZzhZTlVlbnh3aDZIcXJOcytzY0FlSnBuV3lXMUUrR21LSUtQRnpxNFBPUzB0NXRpYkRleWNsOXRQemMvSUkvazM1Vy9WdHlqelBrWXlxeXQvMC9LMlE5QkxLcW5TQVZ5T1BweVhlTU0xM1ZWOGovbmlJdElmcGhIc0FTMms4ZmZ6b1VnMFM5dnNjYVI4eFBiUHFVaDY3MFF3L0RaSkJYdXZsMkNqdjZkenlDaVo5bm0xUlQrSzQrUnhwcmRMTGlBbklIR2w5K3B3L3A1UzlQRytrM0xhUzd3SGtmTUZrcERYQ0dhZWNTeDRZSFRSRmRtT3BPaGxLT3g2djhWaWZPdUdodFV4QlF0dFhQTXR0U0pIckRVL01jcUp6cFE3VDdLZW5nemNxTlpydERiMzZHY2V0bU9rbTNGTmxkcXZMN3dmdnhNZzl0a0M2V3lGSzNlVUFBQ0FBU1VSQlZIbUY3WXhQR3FtcmV5WTd5L1oveEdac2Z6REx3cEJNUnA2ZmI2T2Y2LzRsUFlQeDgwRlhHZHlraUk3THVWVityTTRxV21yNnVaZEh4N0RBQ2NIVmxLYlNpTndnNlJQWm5oZFpJTGJyakxqWDVlZEt0enlQbys3bW5UNXVYTm95M3M1MmVMNTEvMnQvaWJIU1dZZEdVUEk3amlremhMSmRZSGlrOWZUeG94a0VsN0MyNmZCeWJjekkwMUFyM0dla0VYck95UXZvMEFYa2VMRCtIWFd1OXZpa21TQkVjeXI0K3g0Q2FQOFJnQjhpR0NNbkNNRG8xZXpzOU1KU0JJOFFHT2czN0ptUEVReU45SjY3dEo5eit3MGFDM3NNZVFRZzlLNWhHcHAxVWc0QS9BMEEzMEdLSmlYSVBFZTY3KzgrZ1BQWjJlbW9KL0o0TlRzNy9SakE5eEZTSXY4VUFmU2RJL2VJWGdGb3JKNmRSZE1CTVlxYTgvbWQ2MVNCWUxoZUl3RFhjNFExZVk1Z1RQMCtndkQ1TFlTbzN5Y0ljL1JEaEhuZVI3N092QmRZUVZ2ZUxhR3BUNjVGZUczT0Z3aEd1NzlyZlh0VEhubmIybnNEd0l2WjJlazUyM3RsQkw3ZG9rS0tNTllHNWwyM0MyWTdwQTRsZ3ZMOEdtVkZqTThlNFdhNTkyc2w2NisxUi9DYXpFOE5neXVrdTF5ejl4VVlJY0RVeXVYMnJ0eFlpSjArZmpRNEpXMU5RQ1hvVS9oT3ZaWTVKdlZPcFdNTzZZVWE4QlpJQ3JFSFZPbDFTaUdUVEh0V0VReG82RndoZVgzejNVc2tvVTFCeW1qNGJGTTY3ejJwcnhQVlp1QUFCWXNpZ09MbWJkVjJRUmQ2VVNvSXZCQ0JqZ0x1UG9KZ2VHSHZLdVBuK0xRc2taUm9ndlE4RjM2T1ZGbmh1ckZPTldaR0QyQVR3alYxcUtZTDB2SzYxZmw2ZTN6eUdmSlVuMk9FTzZyUGtjN09IQ2xTTjViU1hyUTVvdlBWdVkzekFJbnZVM2FnRVk5am10bnpWSkl3ZmZ6b2lZR3U3eUR4ZWhyT3hnajhTTy9Ob01majJBRG5DNlFVMGhjbzc4MGhSYjN3YVdpanNlM0tqT1djUCs0TjdrOUdEaW5RVXFQUkdVRFA5M3lmVGZsZTJYaTkwSGhkdXNvNTNZWi9LTy9KaWdCUlFGSWd2ZU1Bd1RtZkRyb0dBRGRJRGdQOEllMlpGWjdmWlZIakMya2pnQzZ3THZRVktDdS9TeUFEaURXMXVDb0txdER5Y3lCRkVhalR3OVUwcE83cktFMUkreVFXbzFWNzB6eWw5QUhwYkJzTXpCd25qZTF4TDdiSEozZVIxbk9GWUZ6ZXBiYzN4OHU1OHdBSUZVd1diOER4d0FqN1RhTnNCOHdUNFBEYTQ3QTVlMjRnV1duT1BZK21Rc3grcXNkNk5EZzZBQUhJenp4cFUybU95Q2RVUjZCeXJVQTYzeHU3LytOZXRURm8reXlrandSVEtVY29jTXAzR3VTQUNXV1BOWkNsNzFjQUZrZ09VcDIxSStoc2RKRm5ZbW4vNzhzN2FrVGszSkZtSzJpdFNybWZILzlUQWdKUStKei9xM09YdHNXNWp1QzFuU2NDdmF5akJNWngza2R5UmpOZ3VFM1hYd0Rtc0xNSjdBUWlQeWVOSmU5bTlCWWQ5VGdXOXAxcnAwNEJNZFdlZ0dpUVp5bDd3SDFIUXorZEJYZ1dvak5qWC85TFJXZ3UwTjN6TkFoeWpORTRpU0JQTWUyYjdvRWF6NlNEVk54TGJTSDFQbVU4QVZ4WlBIaTJUZkVPQ0VOTHNUMHhjc1lzRmdWWml1OE9iclBOMHdaNklPdzJTOGF6ZFN3RmZsNmNFNmZ6YWhSVzVtU0RmQTlGR1VMckxSbCtlMlRWMmhxVmpKK1VwYU14Qm9WOUpieUZEamczZGF6d3hSdFg5THl6WGZhWC9PQkMvbzdGemlEUDRUbUNIaCtON2pJbUJlbXZYYVo1K3VaTlpZUXdWcTZmT3BkRVp3NmhxNnFqY24rUVp0RG94L1BnNVJMcVF0NjVZQjlwYnFsdmVpY3kxVkdWYmdPNW9aYjdtZnljNzVCdmo1QXlMUUZCUGxlbk5EcEFxeU1MNVVyeWN4cjVHM2VHcmhDd0FScVpyMnc4NUN0SzQxYnl1ZXFKYXNoUmZxNTdRK2tXZjZJT1hYaFgxMHY1dVk1UkhjY29hODhRcmdQUnF5dEs1NHhZdzhpZWpkaysyQWZoRlRRMkxiZllvMHFMcnBEa0ErOGNRS2VjeUpjVlUzSDhQSE9PRUZtNkFlSzFCSkV1MnZpVWwxeWIxc2k0MSs3LzBqTlZlajZ3SGI3YjhMTUNCcUxaL1ZRZW9tNngxVmluS2RwM2hPMzBjNWJHOTdOTm1VeFVmdkVPT2lNSWhpU2ZGUTI2clJoK3BmQTgzdmExVGZGODJKNkttS3JERnppR3lMc0xZNGx6NHZpNVJxN3pEQ2w5YnVTSGtkczhRelVuZVNESmhuNk5mTFkxcFVuUk9SVEppUXJ1V2RMVGVPWXE3ZCs0dUxNQkZPWUQzZnVDQVd5bG4zdDg5VnBsdWtYV29Jck9uamtBZXJsTkh2UDZOUTNjeWgvNCtSVUMzNlFqWEJ4L016czcvUlhrOSt6dUkzanBmWVIwc1BZUVV2UUN3Qi9ieXdjSUJycHYyL2NmSU4zbHlsUXZmd1hnaFRlKzFveDRjdGVzcHVhaVVzaERlTWY2OGxXRXUzcHB2S3lWbndINEg1R25YVmxwK3hiMWZBRGd3bEpjdjlSaUJ1QURCT1BzZjRYdEk0RC9PWUMvUkZqNGV3amcyZDhEOEVkSWEvc3VnSzhqek5uUDdiUHZBdmh6aE9qYnJ5T0E5NWNJQnVJWENITkhZWkhFZ0JGbFkyd1pBVzNyeXpvSXVQNEQ2NXNLN0Q4QThLY0lhL3dCZ0Q5RFNpUCtLdjN6NTFEYUxieGpTb2FGYTdaSnoxQUZoeHJJM1lQdTJkY0JQTitHQ0cvUkZ6Sm1NdTlENjlzbGNnUFN4UHAzbmZUb25UWnZrN0hlcExTNUVaem5tUW9na081S2Y4Mitad1F3NzQrblFrTWpNUjJHUEtCS2ZzSm5GazVvcEtHM2tkK3F0QzVnVVJiV0x6b00wWEJIcHM5M1dOVERqd3BNVlpsUWhsM2EvOUxYTVpMaXlqWUp5dEREbFdQbXZGSFEzVWVlMWxpVlNpRGRpM3NoWTFHaHFBUDhzSzl0OGt4VVJaeUNGbzJSTkJaNzBFbFRrVEoxNndUcDZvVTFna3l4UUVxOXZFQlN2dWZUM010emhIQ1dnWkJXZVNYdDNrVTRkMC9ORUx1UHdEY2JwUDNEaUhRYTBpL3NaMTB5V3ROZ1pYVm55cS9WZFlHd2owY0llL2pGa0hOcDlUTGxITDBTbjd0bnVDZlVJNVNlNmM4RU1PWitpTjZnU0h0Z05PMXg5QkNsbE05UC9GeTBLZVVZQVlLWWdrd0FBTW9CUlRCczE3U3FUZmU0ZVNOdUJOaHJ0TDd0cHRQa2V4RlFkYzlyZWpnNitPMGpPVC9vczlGSlpVZDhqdlgxS3VBQ3VrYURpNTROVVJiMDc3MUMvdytRbkF6aTJSUFFrSW9uMHdudEljaUU0OEk1UFVLQjN4VVVUdDdSVFQ1eGlaUTZmUVdYQnJvOVBua2RpVTg4MjhVOHUzNERTYmE0UXNwV0JPdWJucS9PSHVpcE95cWxCUVg3VnRLSzE4NWZuL3pnK0JYcEZPZGZvOGpaM3lPRWNTbi8xaWpja1h5ZUdlZVFqTFlLekplVTJURnlQVUN6UFNqZ1ZUSkFLWTFieXJQNm1ZS21mSmZQZXNQZ25ueFBrQnB1bkdyWTgxRXphL2NaMjc3U1oxemJ2cWpoV01lNGRqKzZqdDR3N3QrTGNvUGo1em92M2lsQUFSZjJsZlJEd1c1MUt2QkdkTTduUXVrVVVyVDVmSm9paVRXQ2llQ1l5a3F3ZWR4MGo1Zk92YzRiYVZ2OGZ5anZFaHBKeDVoTDkzMEdzQ0IzcUZPRGhVYmtjVXl4VDMzMHBzRFBPM3lxVFZsRU5MckVBL3BGZm41YlJZRERwZnNzeXBKOTlMSEFVemJSdDBiYmE0L0xEbUJpVU5qSlBFamJ2Y0NvMXhuczd3NHRjUHc4aTNibFp4QWcyY25MbldnZ3VEVndkUlhucU5KM09zekdyRXBJZTNqaDF1b0FRZDVmWXFEOFBMVEllZEJzSjVTN2djVFBOZXBza0g3ZXc4ODVqenVUUzRiMFpVdCtUa2RqNnMvVWg0bTlyUkVNM09RWFREbXZXV2o0VytuOUhnSStxSTZFeWd1b1Y3TmQwdG1GUEtmNnNEcVkwUmxMZWRaS25pVVBZa1lxalh5a1hxa3lBT3h6R3F2cGRFam5jeG9ZVlJaZFRVUEVzVjRCQWFUMDBwU1JhVWdtai9IT1Vldy8rOEMrcTlPVmxtaXNFSjFsN041WnUvZEl1NWJUM0NHWWN4VnBndkdBcGV3Umo3WDd2YVg2ZmNjcHp2cnBhWkhxWnVRenBFMmNwNlhRcEVHMFYzUWs1ZVhheDJoSTN1Wk1DdTJBamFkb2ZOeWs3eGJPSC9UL0xmQUNvREMzYlRMc1V6L25QdFQ3b3BXZisvVzZEZjE4MytyMWtjRnF5Qy95OHphL3NvVG5wc2c3N0htdWZ3TzNaMzBic3FmNkhKMEdselk1S1M0M3lDZHF1QzJlRDN0TytmbWswSCt1TFpEamJwbWpGM0xIeUlXMTUrY3RjNnpyNmJ2eVI4cmNhc2kvY3Z1ZFRya05KRlBpTG9vN0IzcW51ZlpOOVlGZDZPZTNja1oyVlp3OFE1bHJqcVJqVTc3aUhDbCtTWHNkOFhicXM3Tm1kbmI2RHdIOEc2dUl3QmRUYzZnbG1TbURmMkwvMCtEeUJnSnpuU0V3MVpsMThEbUFlYzNRVy9tY0lOd0V3VkI1aVdBQWZBTkpVUGliOXZqQytnVDcvajBrNFVITHp3RDhMMGplWGtmMit3T2tsSzFmUlVqei9PZUhEeDdlMnIxdnRXSUc0RHNJUnRqZlFMcUxlR2o1WndqOTUyYTREK0JYa0J0ZUxoR005YitHWkV6N1l3QXRnZ0g0dHhIbTRnbUFEd0dNRGg4OC9LNUVYL04rVTBaYUxZY1l5N25XczdQVHQ1R0E3VStSaE1SdldwKys1Vjc5SHNMZSt3Z2hNdnNqMkdIZk51MzBxM0x6TWxTcDFXZHZ5bnk5WWd1WGh2UmxFV3NGd3BSeEl6ZXVSY0piVStLQno1L0JlT0gwaG5WeGZVWXdyemdCbSs0akNlVkxwTHQrTmYwV2tPNU12blRmcjBVSjJwTm4xd0RPeFdqUklDbXU3QXNWRzZiUXBUQzZha04wR1pXOUYwaHJxSW9GSXpYbzdieEdBams2SUxRQU9JMjJaZjN6eXF4NmNkTFF5N2s0TDRINHlBM2I5S3lOU3BqclA4Y1d6d2tTR04zSWV4d2oveWZmcERDdmRRUHUzSXRRSE51d09sNUQ0dFZQa0FTNFJ2YUdwbDJrOHFwR0tLYVJIaUdBUlM5a0gzQ05DUUJjMlppL2dKQzVZeUxQNloxUWNSMm5qeDk5V3Boamp2bkE2cVF4V1BmUm9jeEpaNjE4c2YxekIyazlHZ1FIbFY3d3lSdUxSS0hYdExXZGM2d0t2cXRMUVJvcU1oMUhBRGdEbjN5bk1sVUVPQVJ3aU9tWHA4TWpiamNXRDJKclA0RjBYM2JoUGZZeDdpK0lJMXROS1VNQzlUY3BTNWt5c2dNK1IzcFk1R215OXdrQWxBQmdwVWswSmlzUXJLa2c2VmhGd0d1QnlyanQyZGVzWHVvRW8ybUlDRzdzNzQxeW9NMFpGUlMycWZQWU1hYXc3N2NBWEJDSUptaEhRSlR5Y3B4RGU2VjBCMUlSc0s4cG1LWHhiQnBiQldpaUlnZDBvNjNVZURkNDNvUjNNUTAyK1RsNW8yWWxJR0FUd1hTaytTSTlCaExQWWwvcEhNYnpDNmxmRGF3MExLL2xNeUFIa2tsTG1WMWlLYzhvNzJQYjdKZmViODY5cjJ1dGdMR1BHUFZ5UytUcDA1U0NXRUZhQXJrK2VzWUR4R3lEejBRWndyWGovMVlRaEhXc2tkZXY0OUhuWUgxVEFHVHNubWRkU2xkV2Z1L0tlOXJudGFNOUNsVFJXSzV5RGNlak1sOFcrZVA2cHJMSHFzWlBoYTU2WUY2anRrZ2JOd0pJUW9jMXdyZHpmM21sSDQyYjc2S1RyRGYyb2V0c3hUNXdUMDlRb04xZWhuRGY2ZlVWbEtlaVVheE5SdTRyMStjYjBlSVMyQy83WStkRzZDMkFkelh5N0FvMDdqUFdxU05EeDJEaGRRbVU1OHdiZHBYZTlocEJaTHpSNldYYk1ZdThSRHFzZ0RIbGxKZUMwNmd1TGdZWVJzTW9mNHJPUGdWK1RtT0NsNjFVM3QwSW9tKzdoNzA4Z0M0ZnlOTElEcXhUK2JrR3Z0Q0JWR1UvL2tRSEhlVDhuSEtTWHZuRWQza1Z6a1RlcGJHWU9oT3ZuVnNqWVg3c20wYTRFZFRla3o3UVlWQjVPdHRaSU9sam5EUGU0NnRSeFh4UGFUWVE1SnNSa3RNbjVQc1hTTG81cEo4MElHdWJIZjBldVpFMnJxTjh4KzkxdmRsZnI3TW9yZEEyUEQvM0RyMXFSRktaamV1dDlNZnI1NTZmUjNvaTlEcjJSM0FFSGJQV1RabFA1eVZpZVBJdTZWck5PU1Zpa01oMWFvL0JEUTFVMlFsT3licXV3NzlrUHJrdmlyeHdBeitQYWIyUjB3MWlLanpiZm8vY1ZEK1A5Mm5ML3VCK1pXYVdrajZyVHZaQVRvT3FUbUNrOHdQb01Pa044YmtiQmZXMTZUcXE2SUEvN1FaRGFLQ0l4MkE4djgzV3VLQ2ZVLzVWR2wzREJzajdJYzhXcjMzWU1FYVZCVW4zbFdiZStsVlkwaGNmemM4eFJnY1piTWJiaTN0N2szNStXK1VtK0wvb2ozVGNiMkJYTjRnT1JyeVVlMjBoUDZxMzhya2xnSGt6T3p2OUd3RCtBbmtLdlRXQ2dTL3JyS1pTdHJUUlIwaWJYdStzV1FGWWJ4dXBPVHM3UFVRd0hPd2pwR0I4aWhEQitrc0lCL0FkaER0cWZ3RGcvN1QyYUZSY0lJQTQvejNDWm5tS2tNNzVYUVNENDd2UzFNTEdmTi9hMlFQd2h3QytkL2pnWVJhaDh6S0twSUQrQW9JaDlMZTJlUDA1Z1A4QlFhQ2hWeHFOeVl5dTR6dytBL0RYRVNLbXZvWVEvZnUvSWhpQS94YUNnUFlCZ21EMy9QREJ3NTlaL3lpTUVkaS9RakRFVmducjdPeVUwV2k4RC9wdkl3aFdDNFIxK1FoaG4zd1Z5WUJQNC82bkNCSE41MGgzTVA2Wi9jWXJBL0R0bHhManVBMHdka0EvRkZTTFlBVmVrdGQ2cFU4RWpCY0cvc1VNQXJWK0tYQzdoU0lYQlFNeG5GVzlyV3FnVXEzdW1rQ3hwYUpKUUdwdWZXVVU2NXRJZDZ3cXVFWWF4VFJRKzBpR1gwMUg2a0hFQ1VLVUZwWDZGNkpjVUJDbDBEUkJvQjFyYVlkM1BKRXVBY2t6aWp4TERTbVg4aTZRd0cvU1FrWjlaNEJMS3g1MzlyZUM2bFNRMlI2TnRVQXlkbW9rajcvZlJvRS9qcGZLSXZ0TkkyYURRRzg5WUtnZ09vc3FzeDRjTGFaQ2RBb2ZDNVY2R2d1SzRLaTh5L0hQWkw0b29GekkzREh0MXdUcEhnK09lWTIwVmdjSWU0UU9iSmRJZStJS3lWSGdpUmhYeDlJUHY2ZVlpbllQSVpxWmM2VkthQWw4WlpvejNtM002TGxtK3ZqUkIzNCtDdk56ejhiNEFzbDdtNEJidkYvTktSbWNUeDhKUklHUjY1OFprb2VVTm85c1V5Vy81RDN1STd5dTdXamlGRVcydHltcWh1dk5kNm9HQW5sSERVTkR3RlBsU2NXbzh1c1dCVGtFa0ZFalM5SGIxUmtHTzhZR2RKVlduaGNneWU5QWVULzc2SUFqcExUWUpRQzdRY0V3M09ZT05VdmtCdUY1YVZ5N0tONVlLMkNYMHQ1REpQQ1BBT2tsNnFCdzBkdCtRejgwc3BiQTZFVVA0RlV5QVBIOGxZd0VhdlRrWjZTVkhacWhkZHA4a0c0QjZXelBrU0xCZllvNThoNEYxeldUQVVzRVJ1UTlUZFZMaDRWbG02SnUxdTU1NVRWcWRGQlA5SFhoK1hpdVVRWm1sVzlxNFZoVm9hWThvR3VnOVN1UXg3T3EyVFZLNjZOMzUzV2NybHgvMmNiSWZWK3MxODBMUHl2U2Z0bFhrSGNVdE9WNCt0N1ZDRHZLTGVvRW1FWHB5RGxTa0R5Q1dDaXZvem85Uk9DL1lFU3BSWnF5bnFXclErVk9yL2VRLzlIaElNNy9OS1RlN0MwS2xHcjlmUUNzMEdqdlZFVUgrVFZTZHBoNXFZNmUvbWcwbmY0d2c4ckdEQnZYS1dLWWd2M2U2TVNyKzNJYnZla2FPZ3pMVHJKNmFGK0FUaW8vbFIrS1VWTGNHL3pmOFlDTzg1SHNVVDFIbStpOU9uSDA2cVlWUEVEcEd2ZE5kQ3E3TGYyOEpsZktYbWtRWlBmbE5EaVBNb3ZKREhYbngwTWtYR0dRUENmN21jYUxDWHF1Z2hsdzNsbEtkSS8waWZQYnk4L3RUL2FKdWdwMVFzb2VwTW5hWDQxb3BjeE5Xc1I5eXo1Y3lQOEhTS2xSbWExb2pyQU9ySTl5ZURSSUlaMjl1YjJqOS9McXVKV1BSQU9USzhySDFiZ0U1TmtzMlI2eEI4cEkyaStmWlFzd2VpaHlISkNuNGxTNVJlVWYxcWxyeVQ3NmRlZjNYczVBNWRrRnlqS2lseWQ0UHJYZVBtZFl2azg2WFpKUjR2d1VETGs2bHJYN3pNK3JHb3FKZTNRTXpnVit6dnE1ZnJGczBCR3plYndPdmI4T1BycUJobWF5OUpiOFhJTUlJbTFBdnMvV1FINXRWNG1QYkZQRThNeENmYWh2RGpvT0YyS29ybUdTV1VhWUFmcDU1aHl3WS8xY3MxNlE3cXNNUGtJbGdsbk9VSW1mZTNsVkhXSDFySFQyaHBjVmtPZ3pmRnZ5VHQ5ZUJISThkSTNkWDl1UTlhWFVUOGZQRHhIR2Z1bms4Wm9UTm5XMWJmUnoxWmVpcnQ3RHo3ZVJNNnRqM0tJTzR1YjdNRXhVOEhZR21tVFg1eUx4SXBVSldPYU5SZDNTc0xZR2NrTnZxVWlxNXRjQVBEMTg4TENqSkd4N1Y2c1psSmxXZW8wQTVENURTSWY4T3paQUt1SC9Ec0FmSUhsOE1YcnMwSjdsL1pJTGhEdDF6eEVpVFgrR0VKVUVCTUhrYTlLRmZ3SGdUdzhmUFB4NGFKOTNXV1pucHhPRUNOMnZBdmdHVWdyTUllVi9RekNPdjQ0MDl0OUVpbDQ2Qi9BakJNUDVWeEFFdHk4aEdJTC9KWUt4NWoyRStma3hBdGk5cXEwcjBKK0cyWjc1Z3RWTGdlNnJDTkhqUndqR2Q2N0R1d2hHb3JYMTZTMkVGTlVYQUg3WnZnUE1LUHg1cE9oK1ZjcGxXNFB3VFEzSUFpajFLa0EzTFVNRUl3RlJGaGdnUkxhRjFGM3lYY2NMV0lVRkt4UTBxbURQRHVaM2hIQStsK2czTkZQUlVXTUxoWmpuVXBjcWJVQVhqRlRCN2tyR3JCNXNhdVRVKzIzbVV1ZStmQTRrWlV3OUFUK1ZQbFB4cEdCRkF4RGZZU1RZbFh5dVJnOTZsOGNVSE01d0N5UkdEU1R3bXdLKzk4SUZCSGl3K2Ixano4ekVjRVBES3BBTGFsVHFPSmRxOU5UMFZncXdVc0RMb2tvRkVLSlNzYkpuZk5ydDBUUlAvUk5CRjZSMHp4Y3dZRi9HeVRXbC9IQ0ZrT0tWZDJIZGdSbUQycFNXbHdZcUNxamsrMHczelRGVEVUeVVPWCtLNU9tOVFqRHlFcmhBR3h3Q0tITjhMSE01c1hGd3ZwOVovZnNJOGdhdmFYZzJmZnlJNmNSWTUydnkzRGtDVHlPWSt5RjZTcHVpNXdtWTZKVUxUSitkS2M4eVAwQVhETkJ6MEJ2ZDJoNmY3UGNaUzlzVWZhUjFlS1BGenU1Z0Z3TXc2NDk3dmdKY2xJRHROZnBwV1lOa0NDV1lVWXNvNC9nQmJIZS8ralpGQVZva21xZWdpVSt2R0lISUlZQzZuSEZQTTlsT2pNaXYxV0YvM2tFd1lIb0ZUQlhIVEdGM3ZFNmRPWllJRWVnN25WTlozM1ZmM2RZWDBwYmEvZVphSi9sRXJ6SXZnSWZTTHdJSFk0UzlXZk40NzRzaWkwWUVCODZ0M040aExYd2h6NWNNWEVDWFQ0eVJRRjRGUFd2R1ZDQS9yNlJiUUpJQjFLdGNBVTcxN0c2UTB4aTQ3L2srbllMMGM5Ym5pL0k5QXFIUjB4ejUrVkk1UmVkRG82RnF3RzBHRmdPWnZFUVFnSHREZ1NwZmovNzI1My9pM3VQNFdKK1BuRlZuZ1F3VVU5REg3OE0yZDR4aGYyclJLZW9rRkVHVFZxSTI1RG5LYyt3YndYYWZWVWNMNmI4YXdka2ZEMnF5M3dzNUMxby9zN0N3UDh3aTBxQ2NZWUZHVndKUWRGSXJaaTBvekEzNUN5T3hWTWJRL2FZR0pkSmZuM21GMlJzb2YxWnBmbHRJTDFqcG0rNHo3K1N4TStCUCtKUUNsaDBlNGQ1cC9HY0RlSnllNjAzWHRrUkR6UzZCWXQrTzB3KzhrYVFUYVkwdERST2xlWkw2QjBWNUVhU3UxQjFwL0FhZXBQck5iZW5uWTZ1N2lnWFptU1VndXVsWnlnaHplN2JQZVc1aXoxeTVlUmxpQU42WXd0bnFyamtCYTBwbE9xZjFHVXhVZGlUZlkyWVB5aDhOOHF0bFBEOVNvd0NOcGcwU2ZTSytGeDFUa1dNMGRQTHgxOWZvSEsyUlJ3OTcrZDBieWZnNTllOTk1UGpBV3A3bG1TYS81M24zR1U3VUVZbDl5M2dzOVViamk4cUhGbEtQNm1YRURvcjFTUi9Wd0tzOFhKM1RGUytZdUhxaWJOdm1EckRlTVVxenFQRDlqaTVWTUtLdHBua2FXalhZcXV3WCt5TmpLUldPU2ZsQVhMZUNvVmY3dW5hZmMzOUVqS2xtYUpNNjQ5NlNzNFhhODdYaXo3T2p3WDU5TnZFZzZsMjltR01maG9pMEg3M2paTWJmZDhqUHVaLzBySE5lUy9xNTZoQXNHekZOSkJ5TnNrTHQycWRNcHVyVFlhOWJLRE5Pa3lPSU9yS3lMS2RkWSs1V2N5OTdsRVhQd1NDamRsdHdJSFoxYjNLbVYzMjFsL2ZmcEhCK05zaXFOTHd2c0xuZmZmcDVBM0ZPVjFuQ25WL1MyQ3FlZFZQN1J5dlgzV3pBV3hSVDFuTytJdmJZNW80a3FwK3IzcVNZenhMQWFuTDQ0R0VIN05wZy9OVkt5TFE3cFJBOXpGVEFUZWw3Sk1EZ3FmMytPUUlBKzkvSU0xVDJmeDBoZ3ZUbkNNQitYR3dFb09OSFNGR3VkKzN6QzZSSTB4L0w1eXp2QVBoa2RuYjZTYUh2WXdEclc0NDhwZkhsRzlqTytBc0F2MXY1ZkdKMXZZNHc3bThocEhmK0NjSTh2WTlrL0QxQUFLdWZJMCtIbHBWSzZ1NE1QTFIydjR3UWJieUhFTDM3THNLYXZZOTBiL05kcElqdkZRS2crSmYyTTBZUThHZ2ttQ0RkNS9pcTNMRGMxRmdJYkhlL0JaKy9TYitzUFNBeDRPSWUzVUhacURBYnc2Q1N1NUV1YkJEY3REUUFSdTN4aWUvRGZOTmM3NEE1cXdMWHRNY250VG9wdkZPaElqaTZZaDl0VGhqVnFYVkhEMGNiZXdZcXlocDc0S0VENEJ2VEl4Q21hVmhvK09SOUIxRlpibzlQTkVLVml0WWFDUWhieUdlYTNwa01sWHptSHV5YUErc0x4OEY3N01nblNjZlVzL3BLMm81cDB4d0FRMlg1c0QwKzhjWnV6cm1telZTbFN1c0FrdU5VTkhxYmtyUUdNTFoxdnBJMVdOcDNWR29KMHJJUEl3Q2xzMDhEdVFLTGw3YWV5aHZ1SWUwSFZkS0IzUGhFUGtTRit4N1MralFJNi9vNjBoN2hIbmlLNU9WK2hNRFhHQTN0aFV5MlQ2VjNaTzFjSVRncDdTUGRyOEVVWll3d3YrUHJhNVBSbWdBTXBvOGZiZU5VcGdDNENyTE1jS0pHQWdVUWVPZFhSb3VtS2FxTzgxZ0VyS21jdFlVN1l3dEZnZUxNVTNRYjBIS0xva2J2a2ZWM0JLSFREdmhnNFJ5VlFBb0FrZDV3RHIzeEpKWTJlVit5M05wVklRV2EyeFIrYXdRcllPZStCdUs2dW1vS09oV1NqZjJ6Wi92dThsTkFZSzd2eWpNRXVSUWczR214dm00RUFxYkpzMWdCd0dxZHlMTmFhQ0V0NTluTjd0S0c3UytUSFhwQmZxKzQ2djkrL2V5N3BmNHZORnlCeUJvLzl5a1N5WmVZWXBaOFRxUEcrVDFwcUk2VkJrYk9pZjRHSFBBb1BGTUIzMmpFc2FMN1hlbVBlc3B6VDJrRVRnU2RqUjZxVE1KeGtBWmtnQnh5dnIyVzk3UjRRSnRqSW1DWGdlb0VadHljS0syS01nKzY5QXpJamRjNkRxN3pSR2o0R2trT0l6aFlBdUZLL0Z5emdjVCtVVDZ6UFVZUVRHVTV6NE1VQUdkNzZpRG93WDdkdC9wNU5Jb2dqOURTa3UwWkJiNm5JVnZQeU1hZ1kySWE4Ykd2VDJnaStVNHpGUWV5QVNWYmUrbS9YMzgxakZCK2l2YzZzdGorNVJydVRTc1J5TGJlVWJZYjBEK2xEVXBuZGduNDZmajltU2hHVkYyekhaN3BhaEhBbk9YV0hNdmR1UHlaOW4zaWR5T2ozeHVqMlV6ZktoazZVR3VyMHM4K3ZxZjBxVFpYYW1TN1RheHNpTDQ5YjUwalFNK3pheVRkeFplbzZ5REpLaXZacjVRL0Y5Z1E5YnlCbjY4THo1YjRPY2MrQnJDczZPaVpYb2xjVjE4aXlHUFVBMmpBVmQyZlRxZms5UXZrR1NKcDlGQmF2WUk1QXdyTjNaZnZmVVFzVXpqelhmSkpqY1NsanFzTzN1cHdTajdnTTh0d0RPb1FTcHJMakNaZXo2SnV5RDBNK1k3T1ROU05PSGJPTHgzQytUL3hCelhzYW4yZXpub2VyL3c4T21LTHZMUVVCNGM1QXEwb3pZODNCdXFZS1RlUnp2QjdqOWQ0V1ZOcGpkSUVYL2laTi9wclA1Vy9leGxCNXlNYWlvVkdOb0sxUU9ycDVSdnkzWTE1M0liM0l1MXVqMCtLL0UyKzV6d29kdVA3SGVXV0VwMTI5ZkNjSzYwWTB1ZkJSYkE3MWZtamJFM2E2K2lCbDJ1VlBoVjVpbzFMOTAyeC8yM3V0QURjRXY4aHJtbi9hbnNzYXlUOXp6dDJrRy8wR2ZsSDA4ZVBWc3BiclBoTVFrUDZ1a21tNFg2cVBjZDJxdXV6b3pLRW4vT2U2NDE3ZUlCK1Rqb1JneVBhNHhOdktGL3NHbThmSXNkVnZsYjlCeEJIMGdMZTdxUEd4MGg0ZThTNDJGYk5ReWRHZXNyL0pjYkxOSnU5WlhaMnVnZmdEVXNML0pyOVBYWnRySkVpVnBtSzZPczkxZDVCQWoyWklwSWc2UmNRN3BYOUNwTHhjNEVrN0h3TjZmNWdsdThBK084QWZHbDJkdnJlN096MFYyWm5wMi9Pems3ZlJJZ2UvczdzN1BTdXpNTk95dXpzZEdSMUhpSVlOMjhsRFo2VnR4SEcrYnNJODNNZllTN2VSVXJuVFVLNkVRZ0VvbkZjMHhRQ1NYRFpRekR5L2hyQ3VnQmhuUGVzN1hmc2I5NHYvQm1BMmVHRGg0dytmb0lRZWZVY1lXL2NzZlplbFJzV0FjNXZaRVFkU2dUYjQ1UFJUZHV5UWdPcGo1cmRXZG1Dc0h1ZzhWcHRGUUNDb2xmL2pzR1lZbCtRYU5Db3p4Q1BSRzhYQ1BUNkVtWGFwV0JQTmxkbWRPeDR4Ym4vS1VpVzVtTWxmU0ZZUzJHVEthbk9JVkVNeGlpcG9HbTZTa2FPQUxJR3NyY3VwWDRnMExIN0NQU05odWFKQ01aVUpxK2t6cWpZV1grb0ZMRXZxalJkSUNucE5HWXl6Y2ZJdlF0MHZRc3BuTE1kems5VXR1eTdFWUE5ZjRhY2tMcHc1NWRqbVpoeW8wcjJDSUZlcy85TDYvZHJTS0FFamFRS3FvRC8yOWw3M3dBQUlBQkpSRUZVUzUwMHV2RzlHWkl3Ukw1L2ppUXZjQjQvQS9CWDlqTkRNanJ2RlF3blZ3ZzhoZzVJR2dWM0QwSEJudGwzOTVIU1VPOEQrTmdEdEVpS3ppRCs2WXZOK3hNYkY2d3YrL1k1NTNObS9WS3ZmZlhxOXlXdTVRWmF5WDNiOTcwcUpsUnNTZ2Fld2FVOVBobmJUeU9mZWRCRUl4RXk1VWlVdjFJL2h3Q0E5T0JYc0tkcGowKzR2OVdoZzU2WHQyWUFycFRTSEt0Q0hkZWZjOWNlbit5SnNRdEFIZVFWWUdWajlHK2JJc2Y2OW5oY0V6blB2bVJBbWlsNWpmVjdaenpkZU13UUJaYkdzMnZ6V1d1TC9FYkJpQTZQMndDNER5b0VsNXd6QU5lVFlHL2MyejF5QmZuRFN0NGp2ZlYxRXR6MFlBU0I0aXpDVll5Z0xDVUhCSHBCczM0RkRvRnVTbW5XcDFHVjJSVVM4a3lrQTIwZWphdWdvL0pxOW5jay85UFFxV1BXUHFoQlVrRWkzMThQK25yZ3RtUXNiWUJNVnZUbmZpWDdpZVAwL0R3YkUvZU5hMnNzKzRsdDZHOGFkNk1NN3VhZ1FUS3VScG9pOWVsNitublMvYWZ6b3QvcCtqSnFvQ1E3Y2gwemZ0aUdpRmdGMXNucjl4RGszY3ZDbWN6bStwcWdEMldoT0RZNWMreXZuaEdWcjBvMGxtUFlSRDlVUHV3ckpSQ3o1aXl5c1ppc1dPTG51dWYxLzA0S1V3TGU3cmxCUEVGb2J5bmlvbVQ4ZlpuWENlbCtLc2xUZXE0ejQwcEpoeDdRNzhIUnZ4dDRia1lyU3M4S2JjcUEydHZRendldTF4akJXZndtL0Z4MVZOS3JJZy9kNVI3eVo4ZnhYaURzN1dKMGwrUG5wQytYQ05pcTZuNUFvcm5xeU1PMjV3aTBTMU0zWDAxRDFKRTZNUzhSbkFHMTdpVVNsa3NaUk1GcHBsL1dURnRBY21LbERBTHBqOUk5dHVIVE52TTU2b2VzUjQxSXpCYXBXYTU4L1hQa2RDZnFCVElHUFJPcW01QS9zZTZhOGFxMGx5S2ZjYnpJNDg3VVdkaU9Id3NRK1BtNFRRN0FlajY1Rml0NVYyVVE3NXpYMlpQb3A4YzhLMTZ1MGU4NFhpRHBBQ1YrcmdhM0JpWS90c0hCam5XeFAydjNibCs1RmR6US8yYnBvWU9EOU5TQnovQTVRR2p4VFlycFkvdE9oNHZuZ0x4RGRCQXZtNmlESU4vMXNtQzFpRDZxNTNCRVBWRU1veXczdnZkM1lLbkorSjR1cTNQbVRmUnoxcjF4YkhidWEydlB1Ui9KODdXOW1la2Y5dXhPYldCYjh2TWJ0VzA4czBQdlB3KzhIVGxPWEMwT2I2ZWV1Z2x2VjRkcTFuTWwyQVNBQ29Camh0bko3T3lVaFBVMUFNdloyZW1GVmJpMGFGNmZScTVVRjVrTmdRSE5VVDJabloydURoODg1SDNEYTJsL2pBQ0Vmb29RcGVyTEM0UkluMHU1bDVqZy85Y1FJbDIvZ21UMDNYUHYxOENyZjRJZzlQd1U0VjdnRndEK0drSjZ5THZXenFJVU9YM053dnUxRGhFaW1qOUVTaTg1dE14Z1FQRVc3N3lOQkdpei9HMEF2NGN3NTNleElkcFdqTDhzWE5jVmdIK1BBSnJyZmNidldaMDBEdThoUkhOL0VXRytBZURDT1FhY0k0eHJqbUJZR05tZWVWa0syLyt2eTAySTNDWVBHVDVqZjI1TTJ6Q1FFU3l4d3pRbU55eWxLS3FNV1c1YkhIQjg0OUtHaUowR0xnMnFnQ0NSK2NqMyt3Q3UydU9UMG4wVGZJOEtHSVY4alRvcEdYQVVjQjFhQ0xoMlBOQjA3MUhoYklNSHBOSWovci9YSHAvTWtBekJhdmhWSVpRS0tmL25NNnI0TjhpZG54UVExNGpFdVh6dUhXckc5cjBIV01kdGlyQWlLTWpuWVA4ZklBZmF2WGZzR01seis2SU4wU0txeVBvekZnR0FOa1V4MDl1dzVOVytobm1lSVJjaU5ZM1d1WXozRUVGK1dDTTVhaEhNb09LNTN5YnY5aEZDcGc3SU9IbmZObE53alJENDB3UnB2Y2o3bnRzWVZ3aFI4N3B2aXNMak5FUUx2TEQ2THBEdXUrZCtZVDNjNzNzQWpxYmRORC9zRHozQ0I2VlBiQzFOTEkzSk5QYWE0azdaQ2RZM2pjQmtsTFdDNXZSKzE4TDBzMVg2T2cwcDdaYXlmL3ZvR050aElXQ3daMk5aUUpTOFBtT3A3RmsxWm1zYVBFOUhHSkZYaWl6VDUzaW1odktLRlhJQVFwMTdQSjNmcVFKVUt6WUh6SDRTalZHcXdNZzg2UmdacFJmUGZwdThzR3NwalJySVhtdVR0NjEzSHFBYzNZazJGNXBNVUdtTk5QOTlVVVBlR1lkM1hlK3NsTVpUS0FwRTZudWo2eGo4N1V5ZDI5ODM0dWx5THBsKzloS3l0MDNoMThnVzB0Z1YwbDYrYWkxaWlHc2w1NDlyUktCaWdtUUFidHFVN3EwRS9HazBwNmRIT201L2h5NnM3K1I5Vk00MVhiQ21XR1BmU0lQVllBdVUwMEVydjFranBVSFVlVklubGd4QWxlZDhsaEhmRHFNdXRNMUdESGdLR3Z1LzlYdU5pZ1Z5L3U0anJ3QjA5clFhWWlPL0Z3TUMzMUc2b1ZGQy9NeDduRGRBekRyZ28yNjh3VHhHTDFwUmtGNUJNcjFXd29PRXNYNDVPMnRYYjdHWS9FSjZmaVV5bFg2djR3VUtqbE90ZU14akM0T29yVk1FSVVVK3pVRHFhWjY2bW5NQTVMeXdaR2liUzkrS1pTclpCcVQrRWgzSytLNzladVRPcUUxMzE4VjFIMEFMT2M0b2k5aCs4OS96SEdiWmhtUnY4dGtiRi9iZjZpMForVys5VEZNMFUrYklKdVAyUmladjBNaXVCV3FUZzAxdEh6U3V6ajZqUko5c3FORWpxbk5sUmVaV1U3VjJERE83S2dQd2h3NUEyaGJ1V3h4YXFGTnMrMTZsTHM1UGpMTDFCaiszVi9uM1dyL1hlYmEvNld5bmRJdDRHL0c4cGsxWFU2Z3hKdGFOcm54ZjR2M2t3Vm5HTUpNVnFBZndoNTh4WXdpUWRFQWdaY3FpSGc0RS9hWkJ0NDhOY3FPMHZ1TjV2L0ljbjMwZ1ppeVJQbkhlOVBvRGxWbFVEcUpzNVEyVVBDdktxMVZYVmlja2p3SEV5RDFiZjg0dm5ZSFc4aG43N09YVzZLUWwvVlBITjgxcTR2dm5kZjBvUzVBdXQ4azVSNHUvNmlWbWhYTFBLZTN3Y21peENQOXBoQzkxdmkvb0tsblpOVStwOURYalljUTB4ZWhYTW5JekcxdGZ2UjFkUzl0elJmY2F5eExtRURBTnhuT1Z0elFqbjg5VW9JNmV1dWU4YktJWW42ZXh5OEt6VWJmZW9KT3hyQkQwTUQ3TC9hVjZRTWw1OE5iS05GMGpvbTNxT2RCVTZka1pGUDBjUUk2RDlNeEh4RUZyK215YkcrRnIvRndqUmIxRGtDOHI1TGhtU2YvYlNSbkF6NHQ0Mm9EM2lvWFkzcmJ2OVpVMkJTTmN1WFBFTTVuaDdiTHVwTXUrUHAxdjVWMTcwKzRWZkVEWnVZSzZXMmVlc29XVU5NMzdBSnJEQnc4djdlODNrRkx4ZmhuaERsZmV6Y3FvRk5hbklJUXl4aldBdFJydXpORFhsRklyMjNkM0VBeUUzN1ErSE1rai94VEFjNzJuMWlLTkQ1RHVDLzc3Q05IQVJ3ajMyOTdGZHVtVi94aEplUGtoUW1wcEtyTlBkbUdFbkoyZGZodkJ3UHdYQ0pGSXY0RXc1aXVFU0taemEvTUxDSFA3SVVMRXJwWVBFYUtWZ0JScGU5MHlSN2dYK0tlSER4Nyt0UFNBR0g3dklXemVCY0orV09rOTBnalJ4citETk9kUEFmenY5dTZYRU5iajZ3aEEwNThpcE9hZUlSamJDZFlRTkJvakdPUFhxT3laVitYekxXMUtlVGNJY04ya3dIcUJ4QXQ1djRpRkJQdGw5N005UG5rVFFVRDZXRDVyRUp3OHJoRFNNM212VHQ2M3FveUVLVy9YRUs5ZVVTcUJYTEFnc3lGekt5bi9KWEIxSXlodVFncFQ3L3I3YkVwZ0JnMnRLb2d5czhHRkFXZmFYL1ZDOWg1dW12NjVjZnVhaGt2T1o3eVh5YzB4RFRjVUNoUkVtVTNUdlJPTjFFbDZ4Mzc1ZmFTcGJqeVlSR0Q4RHBJaUcwRjhKQU5RbGs3Y3pVbW1iRTlUNmsvMk1Rb3BUc0E1UWtxdGZTbDlXQ09sVkg1dTM3K0d0Q2NZNmNwN2Yra1F4ZnQzUDBWdTZHREV6bHN5dnBIVlAwZCs3OThkcStmSk5LV0VHMC83NzNobGlVYWZOaGxiNzFoN0I5YmY1d0tNSGRuOFBFZFpHZEIyT05lYzczMGczZWZobnUyNzkrY09jdkI5Z3JBSFM4QlhkdjlUSDRncnhwZk9YVE8yUGo1VkpvMTRUT25HUHFsbmRpd08rRllqZHFiOHRIbGFKeXFwYWt4UXhaV2ZVNmtsOEZ4U25IbSsrM2hUQTNGcWFkTTlrQnhEWjYxdXF5amdvdUNRQi85azNRQ25XRXYvNXdNQWZPL1FBSWlTVXRuVGpPcS9SRzRZVW1DYjlKQU9BdnVRKzhWdm95Z1FkQjBsc1UyWkNHSkt0ZXZVVSt0YmoreHphRzNONURQeU13S2dlczQ1LzByeitUbjM3WVZiaTBnUGtJT0dQT05BQW5EVnFNUENkMWcvbmZOS2puR2syMEF5WUxPUHVtZVZwK2gxQngyRGlQVkxJL05KbHhnZHd4K3RnMzNsbmlzNUFpOVpiNEgvbFVCTkJWYTUzMHBPSWhIQXJ3QXEvbS95OTFYaCs3aHVsQ01LZ0lNSDNaUitxRHpTMmRjT3dDVi8wWFk1SGlDL1V6a2F3Y1ZnTlpGM3ZLeWw4bytPZFlreXFEeUJHVXMyZ0tBNkQ0Q1R5YTB1T21xTllmS1krNTY2YlN3OWhpOGdyYzhlTm1SU3FQUlZJN1ZJOHp0M0V0dXptYlBIRUY1bS9WKzQ3OVM1aU9YSzVsZWRPdFJaTW5Qd2NQeGNuL1BuT2R0ektsOWIzL3o4NjU1VFkzcHBmRVAwQ2ErZnhqTnltenlvMEE5dGQ5TzZGWjhiS3NmSTg5NlJsclN5N3c3cGpwTkJZVDJaaXBXODRSZkZPYnRZWkY4dFNVTmVFaisvaTdCV0wrUXo4dk1Wd2puWGMwU2pMWU5tMUxqS3ZUc1hmczVuZ2E0eGw5RzlRSEtxVlIwNG84M0lIUjlYeVBVdnlwclUweFpJY2lJTlBjeXNFSFdSTmpudHFuNEw1UHpsQlpMUk56b1RJVVh3a2c1UWI2ZHh1NUcrK3lBWXRrVTZkeWwwaDIydDVGbit2V2Z0cXNPVHloUjh6OHNsWGtaUVBUM1RUZVI1SU9mVkN5Qzd5MWJsTWhiV1A1ZDl3ZnJWNlkzN2hycjVTTDdYdXZTc2N6NlZYcXV1MWNGMENySUgzTHdCRHV0VC9xSmpIVWpQaXZmdituMWErbjRvdjdocDJkUkg5NngzNnRzazAxQS85NEVSTlJtVnpoYTZ4dDVneXZWYXlEenFlVnBONjd5ZThwNEcyaTFsWFZVL1o5dWRURnFpdy9aR3VoYjA4MHlmNlh0MzE2V3RHTk05WG9tY2xuajluSFI5NmVlazBtWjA2a1V1bnhmNXVjeXJ6b3MvajU2ZmoycjEvYUtVejZ1ZmhyMTFjQ0E1TDFmVHNyNnhnQmlISFo2bTU0NmYrVEVwTDFocE96SVhQR1BFNFNJOThITTBBZkowejJhNG96Y1dyTVBQN1BkZEJJUGVmd3pnZjBLSVdJVTBlb0MweVM3RkdGaThQMWVqZmt2ZnpjNU9YeURjVi91ZWZjeUlHTURTbVVqZnFZQXZrVURsUHdId3J3RDhad2gzenk2cy8wUEt6NUJIT3hENFhlallkbEFtN3ZkbkNJYm5Gd2gzNTc2UElDUytpV0JJdlVCSXFRd0VJUDBJd1ArRFlDQWYyZmYzN1g4YXY3Y3Ard0QrVTJ1N2FBQkdFcXFZVW1ZQk0rN2JlcnlGa043NTI4Z043bmZzSFNCRWFUKzE4VTBRZ0g3ZS82ekNFNlBHZ0xER2R3QWNtaEg2WTM3M0tpSjR0MlZieGFpVktDUlZUbnVlcC9EUXk2aGRINjY5eGtQSGMxUGgwTjVUNG43cjRJSzFjd2NoQXU4K2dQZW5qeC9OVEJBaGdPekhRMFhZMzA4U0ZiTnBidndsUTZMUXp2VEVlbFpyeHZ6c084N3hnRFdoUXNaN2wySTBRZVY5QlUycDhKR1A4ZDRjQmZXWWZxcEI4TEJWOEpyN3VRR3llM0s0WnpsUDNpQ3I0Sklxczl3WGM2a243cGMyUmZvQkVuRWl5allaK0pVSURScmh4WGttWUs4S3RIb00wL3R2aFB4ZTZiVjlwNTdDcWlSU2VDVVBKTDlsSVFEQU5lTTlVN3lEZDJuLzZ4cHdiaFpJNmJQcG5VelBUblVvWVB0M2tjQUdLclIzMkhZYm9pd29LNHdBM0czREhWM1ptRXpvUGtBUW9tYjgzczZyZXVxdDJoQUJ6RHVBZ1hSbm1Cb2t1ZTV4ejZKY0NKNm9FYmdJRmd0Z1NRVmhnWFNXWmpZWFhOOUZDWFJ1ODd0ZGVmYThJWGFDb0ZCeFhENmRHQXU5NHhWRWlBcXAvTEFVbFJFUmp2bDhDU3pPZ1BVMjkyNEZna2N6ejUxNjIvY0JxMHIzZk5SRkxOWVhuVXROdWZaU1M2bVBudTYxNGhGdnhjOWxKMXNQalFnVmNEbXJBNGxlbFl5L0k0VDlyTVliS3YxK1AyYmU1cWlma1dvaEFES1FyeDRnalBHNm5yN2NXdzNNbWFnOVBwbFZsR3dhRFljbzhFM1Bkd1RyK0hlREZCMUQ0K1RhMFVVOTN4cjV4WDBML2hiK3dlY2g5U3RndVVaU1ZoVjg1cHdvemVQejNzQkVtc3Q2Q1pab0pGQjBGRzZQVDJMMG9mdU9KUUl0U09uMnRYNW14U0MvMC9UdUhoVDNhK0RwRnNFclA4WTFjdG9VaTh3NzI0SDdmdDJHYU8yVi9NOW50ZTVJRjkzL1kvZU1BcWxaaEM4UUkzWkxNbFpHVzlHVnhVdTBuSHRQdngrNWQyaGthbXB0T3puUUcvb2FxVWNqSHBXR2FWYU1rdDRCQWJGNEZudy9zck9FWEhicjlMZk43MjMyUmMrVEF2M1ZvbUNiZk16VXBLUTNWeFhqTDhjNWtzODg0RFFDc3N3RnhmNllQT25CV1o5U3ZnUkNxUnlsY25pRE1qQ3Q1MGo3R091czhTT2dteHJVanhNbzN1UG14K3IzTi92N1VvdnFpS1hTeHh1a0tOM0wzdk56VUtqUDZ4OUQrK0QzZFJ5SG5aR1hvWi9UNkgzZHRxS1JyMDNac1dyM2FKT1czTWlaVzNnNERjSFUwZGJJblliNHZLNnRONHAxUUYwN3YwcEhJZlVyVDE4amdjelVLOG5QaWJ2eE0vYkJad0VjRzc5U2ZnNmtpRjlJWFdOYlY5NjdxeEd2UHJNSHIrOGo3ZWR6cWcrdXJUK1VUOGdiZlNZdlNQK1ZicXN1cFh1WmJmSkhEYnRYenNCYWtobmlXS2JCMFpoeUV1dFFuZ2w3am11bnNnUUw2YkZtaEtJT1NxZWxyQjRyVVk2eU9sV25VcU53NUs4eWQrU0hYaTZMMlpsYXlSNVRHWXZPajVlVHdEcjR0enhYcEhjaUg1QlBSWnBWT2YreC9vcEJPbjdYSHRmdjVTMDlYK3JmcHFLR3dBRzRvdWVwbldzUkVQajUwcjNqaTBhdks0NmplcXZ1ZTEwSGRRSmR1bm1vR1pwaTMrV01zRXhzejNaMEJjRVpmSm5JdTFWZHFxQ2ZVKzcvUFBoNXA0L3VUQ2d0QUp4Y0xUS001d1BVODd4Kzd1Y2UyR3dFOWV2UE5jc2k4dGt2MFV1dVZSekcwL3VjdFhjdEhtdDlYOXA1N3NYYkI1ekJRVVZ3WkxUSEo2OGhPRlpyRlBySVBhODh5dXNYcE1lNlo1UXZaM3E0NDcwbDV6L1ZoZlg4RTVmTXlzUU12cHBxY0lKZ25QdExBT2RtMU5OMEcwQUFRbjRad1dCM2dlUXR4ZWN5aFdzSDBacmZ0emIza2RJanY0VVErUnJiTUtPZ1JxSCtFYjlHQXF0L2htUlE3aXZ2MmJQdkk0enZFbVlJMzdHeDhRcGhybCt6L3o5Qk1IcC9LR21tRjdPejAyY0lBdElCZ29GNGpqQVhZNFI1K01DK3A1SDRJNFFVMmpRV00zcXJsdnBheXgwQXZ6NDdPLzBYQUY0VXhrc0JUajM2TVRzN1hTSVludjliZEZOM002THRLd2p6ZUlHd2Y3NkZZQ0JnNVBLbEdKTGo0VUMra2I4SzRLL2JYSDBYeVhEOHFteFpha0xRTllta01vK3FKN0FJaWx0ZHNyNUpXZTM1Zm9JQUx2cDB0aHZidkc1eFJML0drTEpVY1Rjb2JJTk0vb3Z0OGNuemFZZ0d2Z1NLNDRyM0NPaDNCcjc2Vk00Y1J3YVdTVm1qMy9PN1kveEZCU1J6YTBraEx4Tnk1TG1TQUFQa3hrZ3F4aG9ocFVwUUJOdGhCcVZwbm1wTkRWMnFlTE10enVNSXdLRUl2Q3JVMFRHSmlqWlRaa1hBeTlwa05nMmxlMnhYd1ZRVnF0a245ZGFkSTNsQ3MvOXI1QkhHQkFDeTZLRnBubjVxN09pRFJsZXYzUDZsMFpWQyt3c1RZSG4zSFNNK2RHd3I2eWYvWndRaGpkWTBaSE45am1EUnQwaGU1Z1FJUG5OekFxUm8zQmMyQnQ0alNNR1RkeXJ2R1lCYTVTR20yQk9rV05qNGFVandSdUFZdWRZZW4xd1V6a1hqL202c3I4Vmk3UkJFMnJONnVjNk1ndE5vZlErU2Nld2F1ZXZQOEJKbU1MQjZaaVVRME5hUWh2RG9NWXpjZ0tIN1gvZW9DcVNzcjJPWUV3V25SRTlVSHREZkdSRFNvNEJraHVJMk9iZXd4SHNtU1Fkc0hqVmxYakdkenVkWXVPOVlTdmVCS3gydGdzeHFSRUhpNXl0dllKQm5HV0hLYU43bjl0M1lQYXRSbUlCRVk3ajZ1QjZyYWRtWm9ZRmR4ZElHUSt3bXVVL3ZjdHU2T0NOcngvam0rc1V6dWxFVzNiQjNTa0Q3SWRMZDMzQm5uWTRoMFdsR2FFRGs1OU1VK1ZJQ1NnaW9BdUxJNDlaOGpmeU1Vdy9nZDk1WmgvVlNscWZCVFlFbThqN3lKcDl1bDdTTFo5Yi9WZ2Nvb0J2bE1ESmo0RWo0aitvU2tIb0lJaWtBcnUzNWlJbTF2QU9JQVh1YTB2cVZ3QURPeXhxSVRsNXFFRllEZ0xaWFZPS1JhSkk2d01TemErMEN5Sno5UEUzMmdCUGxCZkozQXJEUk1jM2VVWDZyQm9FU24vSGpVcU1GZnkvZGJ5MjZ4MHVHdEdqVUZ3QzFlTTZtNlpvRnlvUXhxZ1E1Q0Q1cVUrUngxZm5qLzJQdlhYcGtTYkwwc0M4aU12UEdmZFdqcTNxbUh6UGRQZFE4T0RNYUV1SlEwSXdnT1FVQjFFSVNwQVdoblRiNUUzS1Z5MFF1NytyK2hJUUFyUVVRNEVZa0pKQk9RWkNnaHNqUmFKNHREbnY2VlYxZFZWMjM3cjJaR1prWkR5M3NmR2FmSFRkejk0ak12RjAxckFNRU10TEQzZHdleDg3N0hKTnhjVTJ2Q3ZkQTNqT1Z0dFhnSG9QclZHWjJNanJ4dUZhVko1YVZsR2Y3YUpLV1lsVmpMZi8zOXdMZGZVWjhLNVd4SzlHYkRQZmtHaDFNZWs5ZnBxYWZsMHkrUU5wZi92bk92dnk4OEhPaDAwQjl6NWYwc0E0NFBxLzh2T2hFY2U5VitsR1VCZlU5SlQxV2FWbVBmazU5YURCNzJPbG1XME9CbnhjZFFVSUxKa2pCenFQYUxvREt3YkIyOTVybnp5Nk1ONWRLYkpKUFpabkt3bGNVVDJKUW83eEhlWVptOG5xY29ieXIvTHlFRjlSeE5KT1l4OTBRbUpGMmd5UVhNaGlZQWJRVEJEbEc3WkhVYTZpZnNjMVNmMmluSnMrUFI4SzQrOGpQS1Zjb3oxRm5LTkRWWmZqT2ZTUzcwVTByam54MGRabXB6Wk8zVzJyUW0vYUIvTlE3QkxoK1UvSW1vNGZzTTNGeHo5N0hxZ2JxVE9mYzdCdXVSSjBHUVI2aS9ocDFlY0cvekxuY0pnYzErOVNSRzVEekFmMnJ2L252SEpPWFdZbzBlb2crODluV0JaMDVlMU9VZytUYW9PMXRERytvMGNjSzd5bEJ4M0hrMjJxUGpwVVBMbXZ2dERYMGpoKzlWKzFpUUZlR21DSUY2bVlWVytSM2p3TWFKRWxRWENSTUVIQnZ2NlRmSVo4SDJxaFVOaUd1ZXgwcHEwcjJlZUxueU9VcDBuUy9MeklIZGxzSVJMVHJYbmNoVDZ3Rlo2dmpVWk42QUxHLysvbnE0ZWR4N1N2MmxaaXNZRGFEb1FTdlcvRnpCMFB0ZUIxalYxRGIxaHJBUTVOZExwQ3FZQ2svNXp0amhSVGg1MXg3eVAyY1k5MDdHanl6UWYwb0w5WFJnY1RMaW12RkZ6MEE4QjBFeCsvdklwUWsvczdpN0hSaWpyZ044cEpqakFwN2pGRGVrZGtzS3dRSGJHYkFkbWU2amdKN2hndTJSSEFhZmw5dW9hRW9pNFJWbUIrZXJNMzUvTEgxOFR2VzU3SHdkWVFzMmg4aVpEdmZpZk4zY1hZNlhaeWR6c3hodlVCd1lINkVkTzdXUi82TTRmbmh5V1orZUhJK1B6ejVPVUoyN2djSTUreitHd0FmMnZNL1JDaFQvU2xTOXNYM0VKelkvd2VBZjdsbFYzOGJ3RnVMczlNOTZ5c3p4QjhpNE1pdklzelJPd2pPNkY5Rk9FZjRQWVN5M1hxVzhVY0lHY1gvTVZJRzE2OGo0TjU3Q0xqM0xvQ0hzdmFldWF3Uk1vZy9STWp1WmtBQUF4bStoQzNncnBoa3FaMkJkclg4MnRoM1ZCbWlFTklhWkVKNnp6dXFSdkZ0bVpUMWgxbVFOU2lXUzl3V1RKQjZhZStpc2pWdmo0N2ZSOFhKYm5OMkpRTEJ2bjFLaG1FOWp6YVdlaElqWTNiT2liNERaUU5jbHNGVTZwdXN0eHBuL1ZpeU5zend1cExuMkIrV1VxWWlwUHlKemd0dnVKeTFlUWxLamJMT0RNejIvUUhTT1VkOEw5L0o5eTV0cmppZkxMZXRvTTVyemkrVjUxSTVIZmFMNzZRZ3JHdEYrc255WDJ2NU8wYzRnM2ZQTzIzUWpTRFdzNGVqazAvV2lvYlVtVHl6YnA0LzA2eS9LUUtQNDNmMmwyVkx5WjlmMmtmWGU0RWdCN0R5Qk5kNFliZ2N5eVdhQVhabTk1Zm9ETmZjcjJrUjZFQ3dkejlFQ0VCN0c3a3pRK2RaNThpRGx1M1p3R2hFZTNUOHVEMDZmdXBwbmUxUlBlT0tPTXQzeGRLdUJoMWFiRFRpQ3NIcHRxRGd6VDFyOTNnRDBhdzlPajdRL2xTY0U2cEE2djRqN25wbFo5REloNVNwd1E4ZEVXelBCMENvOGFrdm9sU1ZmeldlOGNOQWtUM3UvelpsaXBRTWJKODM2Qmo1aE9Zc214UkpQMm1lUDlPbzdtbWJHMHMyRUFkZ1pUNnBPenhDYm1UanV0OGdOOHBzRU9hVGdSTnFOR043ZElqVUhCWTY3NzNaMk8zUjhaN2pDUnpuUVp1WEtoc0VhK01LZWVsaS9YMkRSQjkzQXBrSEdpRjFyQ3VZbmxWWUM1YnF2eERIMHdHQ0FkRHYzYWlueVVmM0tOZDlDY0RMUFZ4VE5UYXlyYXNtTDVjTWR3LzNHZmN0NmFZNlZiVnM3Z1N5bjVFYlBmUVpwZDNLMi8wYzBhQ3FCbUEvSHhQWER2bTBkMUxwUEhtamxNZkpTTDlnOG9vWWJEdVpLQVZubVRlcStybjNDbi9reWJyMmxNVkVadk5POXBMUmRBT2tiRkRmUnBzSEIzcWRqWDNUN0dUTlJ1ZTFHSlFsejY5czM2NHBXOXFja2Q5MW9NMUxCZytDMjJ2N0NIWU1IaGRDK3FTUitNb3ZQS2lCblhJU1RLYnF5TlEyZjRvWGFzTll3WjBmVnBIZlY3Q0tIL2FweWZqWnVoWmtQSUlQYm9nNElFYXFsZUl1Y2o1Y0JlSG5jVS9KMmlvOVVONjZKODhNNlpQRVU2VVIwVkRLUGRXR3pIczYzVE1qNnVjSkhMNFVzM280ZDhLL016M1l0WkVGbS9ENXl1czFnTEh6dmxKZnlWY3FPcklQUnV5RDN2VndkRWl2bDNTWFhyQ3hYQ0hvRGpWK1RwcDFXN2hDb2hHUjFyWWhHN2lrbjNOdHJ4c3ByMjNqakhNazlKZHk4VksrWjN6S2Z2TnJSSGxGbmNBcitZM0JxMTZmSmMxVTNsa0szTmswd2NuTnZiWkFTUGJ3TWpSbHFpbHkzVmIxVk9WVlFLcWlSRWN5bjZGVFQzazhwTjgrNDFyeGh2T2hOaHRmSWwvbEplNEp0a3RkVzZzaDZmT1JUNXI4U1p1RHQzWHEvN1J6eC91VkhpUFJiZXFhcW52N2VTYmVaZG1Bam1ZbzNaeTRkdGkvK0N4eTJxKzJna3dHZEx5Yzg2YnRaMUN6OXcyQjBxZ2VtMTNFcFpvVGRaZDM5L1Jwc0QzUnYva1o1T2NJYStScGdnWXYxdVJXL3VWZTJiaG5NdG1qMEJlVlhkaVc3Z09WNzRFays5TUd3ZmVXUU8xK0pYbExaVTcxQWFrOTRuUEQyMlh1MktkT2hSUFJ6eGxvUXB0TTFPVUwvRHphMXV6ZUltOUdtSjlPdFNQSzhyN3RQbjR1K3VQUXNSTnNlOGplWHVQbnMyMzNmNU9DSFBzQ0hZbTN0NFVyZFBYU3ZSSS9GM2xyMVR4L2RpbjJsejN1WGYwZ3IreTRrZy8zNGNTK2R4em5vaWY1NUErZ0lrZE96SEgyQk1BL1FIRGs4YXpkUHdQd1QrdytNckZmQWZEZklqZ1VmNEowRHZESENBN0pOZEF0eDh1emhVc3pLZStuZ1dVS1lNT3pmUmRucDh3Mlp0VFlmMldUL3o4Z09hTDM1SGZvdWNEV3h1OWFHOS9FZG1jQXc5N3hSd0QrQk1DbnQ4MW1Oa2ZxZXdoQzlpZjIvU09FY1g4TFlReWZBZmpBSE9sOWJVMEJUUHg5aTdQVEp3aGpQVWN3cUQ5RWNCcHZBUHczQ1BQODZ5TzYreThRc214L2hweEovd09FYzRqUHJlOS9nV0FJM0FQd0g5ZzRDSmNJNi9WUDdKNm5DRWI1cHdnTzQxOUhJaGdzTy8zL29odlJSbWMreC8zTENMajZVM3ZIQ3NEcXk3T0I3d2Z1MGxrTUtldFMrVDF6TURpaExnWURqT21QTUsyWTNkaHpIOC8yWEx2Zm1KRzA4L2piZXo2LzJQci9MaExEQjhLKytHemtQREVUdGlOOHFwUElYOTlpRFlBa3JGVWQzNG9mS0dRanFMTGlqVnYrZjNTVktpQjNVdEdSQmlUaGxZb1VIV3diQktXUVo1VmVPNGNDeDhSUysrUmp4RHRtalU0UkRQVE1RT1g1NWtBd1FtaTVTUXEwdFRQVVdHNkwzN2tuRnNnZGp5cndlQ0dad2dTenJqalAxU3g1eFlNMlpiejVNMGhtQ05IdDU0WG5WZWxsbnhpTmVvNUF6OWNJQnRCemNSVHhYTjhaMHZuQkQ1Q01Ib3ZtK2JOTDZTT04vTXd1M3JkK3h5emJOcHl4K1ZqbTdYd2tMcytSMW5PQ3dCOTV0dFVOZ05kT09OTnlyTnhqTXdSOFlYREZ1Umw2SGxtYjNxSExkMC90M1RTUzczd09iWnNDQ1NhUTg3WGRQWlQ3ZFA2MTFDd1ZNQXJmVWU0U1BDZmVSYU5JSHgwczRKZ3FUalc4alAxRXJ2ejFuWWREOE9VN3VYZlV1YUlHTURxamxTZk5nSEdsZis4S1BEL1poajhMelNwbW1mRzd2OGJuSFUzaU1TUVRCRjZqWjlhU1JqQ2pqcGxtZW53QXk3QXZxUHhXMWt4NVNDeVIxOE5IWmdoN0pUb203VHBwNXM1bG9WczVmK20rZUhxYkl0ODEwR1VmWVR4YXVqM1NkVm1yS1ZLQTNZM0hFL3VxZEttMnRyWE1LTzRmN2pzYXlqTzVUZnJ0c3d0SkM5VEFFUjBGM1BlRlBjYXhldU9BdnBQR2I0M1E5bzZoR0x4azc3blVlWkY3K0grb2krMVdBQUFnQUVsRVFWU3BmQm9nQmhneHFwSTJLLzFTK2NXdmhScm0vUGZNR01mNWtXY1Z0UDlxZ05pRzFwTCthWHVVMVd0SEMyandXWHgzRXlwbXhDb2tZdmlZeXB5UnZ3TXBVbDBkalZrLzRTTGpHOG15YlZNRytRYVYwc21WT1ZCSHdnU2hhdFljU1lhZ2JLYk9kT1huREc3Z1h1V2UwL1BxbHlXYVptM3dudDR6NzBhT2hmTlNvNG5FZDgxNDlzNkdLSHRDSENzRldoRXpDNFp3cklhelBYUEMrYVN6SnRvQ0JuZ0RaQ3ordTcrV09UY0t1b012dC9sR1lVdCtucTNyTGQvTGlqWnJGT1RDQXMyYUFwM0tEOHgwR2NVYnhSRGNoMGRSN3luUUJxMVVzRFdvemVFdWJCeVZkN0QvUUw3bk1sbS9oK2ZHNmxzRm5SRG83bXZTOXN4MlVyQnRLSDlpTURHRHZRbGNaL0lsclM1RmZRWklUbERBWkQ2am5ScXN5cjVyMXEzbkljcURlQTZ2NmhucUpLV2hYUFZiUFI2QThyMWVZMzh6WnhyeTRHUldqV1FmR1ZDc3NrRG1oR256MHAxc2svZnBHaXBvZ1BiR1BVZlE2MHZVNmFES1JjclBWV2JpWGl0Vlh2THJFTi9kcEtPbllPLzNSeXg0WE1yNlY1TkI1VyttUDdXNUkzUDAzcTdzbnhMdjdzaThxdmU0dmhkdFRyWDMrK2QyaFNHNkx2WWd5cHMrV01FRDI1bTQ3MEJPazFodXRtOHVTUXZVWGxXVWM5cFVFcDE3T1I1MTVuVm1HUk1oMmd4UkR6alFjWFJzRERZdms1SU1lMS9RcHN4OC90OXIvM1Z5VXNlZU1FWS9yOHc5ZzdrMmNMeVQvWUlFaU5ubHFFL0s3NzF5bnZZVFFwdHJ6d3p3OHpGTzVxRSszRGMvbnlIWS9hSU1aSitMa1RRaTZnc0YyYlBFdTZPdU5xSnZLcy9UVGxHa0lkeUljNFRNbG04aUdiSi9HOEEvblIrZVhDM09Ubm52QllMRDd3VkM5Z3Nqd1g2Q2l2TzNkZzJJV2I3dklqaUEzN1YyRmdDdXhHazhCZkExZS9jbGdwUHdRd1FuSXBVMEVwVW5BRmFMczlPbGxSR21JdkVld21KdDYveUZ6Y2NmSURpN1dXYnlOckNIWU1SK2lqQ0hEMjBjcnhFYzdOOUFtTmQvdFRnNy9WNmZRN1AyMi96dzVQWGk3UFJIQ09QOU5RVERPa3RDTXd2NGp4RG0vRzBFUTlsdm9Gc2UrbjBFQkQrM2ZzNFIxdUk3OWo4emQ0R1FuYjFFTGpoZUlwekIvTlA1NGNtUGVOSFc1YWs5VDJmSmdZMy9BTUJmSXAzTG90RjBjZHlMczlNUGJVd3FuSDRKOXdSOWluZU5DWldJVnBNaWRjYStzN1N1RTZCVC90ZjNqY0pRWkg2bFB1cTcya0taUy92dExySjA3elV3d2ZyL0FvSE9QY1pJWmlSUUt2V2liWGVNS1NNWm5TbzJOR3BmdDZsTURTQ0dYL3ViQ1hGdE92ZWcxR2JKR01vK0F3a0hHQ1MwZHMrcjgwb05yeFJpTkdNMjRvTGcwUXlwakhUTTFFVXkyUE05VXlCbXl4S3ZiOUFWa3RSb1ByVjVXaFgyZ2hwaUtJQThRc3BTbzlPRkFzWktGRHlXcUp3Z09XUFkxLzNXeWxpWGpHSUkrKzRCa3ZOeTJnVEhEZC9uczN3VVlzU3lNMVp3dlY0Qm1JbGhsMFpkN2VkYXhrYWxZbU9DcnA1M3QwRTZnM2htNzNvTDVxQkZIbDEzam5UbVRLWVlGNHlxMTBnVkxDaGMwOWtkY1ZibXpzL0ZCbUdkTk91TzYzOEpwTkxEY01ZMUpNT3N6c2R0Z0RoMDBCNGRkNHg5WGpsRE1uNVFnYVJpQmlRWlRNdkhSMk1nbkdKV1VpeGFPWC9heHE5T0VlNkZtbU1JeUIxTk5MaVV6dWZSK1ZXRGpnWXo2RDdsSHV6bEEyM0lPSDBqVHVDS1FhWFVKOUpVR2tuVmlhM3J6Y3lvdFl5QkpmRnBZTkNTZUp4RFpydGZWOGF1aG5abUlaY1VucjAybFRqeTU4aXlZb2dhNExqdmE4RlpheFFpZ3EzZlY0WDdSNE1adjJyQkJhTVZ0WUYzTEcwK3FDalNzWmdaQmVDY3Z3YmtMUjM1U1hqNWhFYUpzZnhkakhKOGg1NFhHSTgyZ0dUZzJIenovaXc3Q0lBYUdGVGhqLzJ6NnpRNDZqdWo4MGIrOThaWklNKytpWHRacmwrekQyTGtWSnFXeVJyeUxtZ2Y5YjJjTjUxckpMcEd3emhsbmpoZWRJSDBqem91cjNWa010bVBtUkZaNTdEUVBzZWdCdkdKYTB2bnF0Uy9EaitYZHkyUkd6QW5zQW9BemhqSE1VYmp2NTlYa1dIMC9DMEdiQ3FkWGpmSk9GM0RZYVdmN0p2aUVwMEE4YjRlK1gyRGNpQWNHaGZRVXRFOWRJM3ZBaWJlK0NqOThlOVFnejhkMlVvemxIZXJJNHB5a3plb2UyZmdETWlxQ0t5Ujc1V09rVmxrQnI3Zk8xT0srb24wd2N2MmZOYnZyejRIWmR3Nzk2MjNsYUNQbi90N0JQYzlua2RuVEpNSFhQaXo0ejFlckdFOHZZZG1rRTU0bWs3bzBPOUMvMGxidVY5SzlDT0MwU1RxVm5wOXREMmhCajEyaGp1REpoM0ZRR2ZvQklWZzh4Nzl1NVlKSDJWa3pwM3dsVTRmOUg5WkE5VlJKKzR2a0l6Ym51L2V5SFBxYUl4NHBRWjlKRWY5RW9IdmFubFh5Zy84eS9MUzVQY2QraXI5SUkrYUl0a1RaMFovcVNNQ2lkNzVPYVJPUlR1a3lnNHoyRkVsSXNjb3ZXYVZGZllQNk5JYjVhVjY5akdCZ1M0eEdFajZwTFlUL2wyM3JseTYwRDZ2TjJsZjJZZGF0bnlrbTByWDVUMlU2WlNmVHdwMDBzdWl0ZUNmck5LYjA1ODRocUt6MlkxYk0rMDZkcUVTRGQ5RlB0L21tZHZLL3dhYzN6NStybVBUL2N4MVZyNlo4WE1rSFZsbG9NeVpiSGpHK2ZlWnBNcDdLTnRsamxacmgvM1FKQWxlNitobkNQaXRlcjNpTC91dE9BNmdOMGlBODNqZzdUdjNDRm5nRFFyeXZkc1RVZGRHZ1oranJKOVAyMkFENTVyRnhCbTNaemVvQnlGbU9rVGw5d25mVmJxdjdUcnR1VDZiQW0ySWJiVHB1RHk5WHBNcFJzTWI0dWVyOXVqNEhNRW5CbnRmTVpHaTFEK1RaVHAwUW5YQ21peFVBNmNQYXZuME5ZQ2lUalJGTXBEZUlHUmZmaUJ0UGpFbjdkTEtEMzhBNEg5SGNJVFNJZnM5QUsrc1JQR296bHI1NDRjQWZoTWhtL1FmQWZndkFQd2VRcWJ1MndDK3NqZzdmUmZCS2ZnSlFnYnVYd1A0WHdIOGEydEtrV2NQNFZ6WTN3UndZRm13dndmZzc5bHpmdzdnLzBFcW43eXQwUGkzSVVodVl4aGRSczdLYWROZytwRmRmZ2pnUHdUd2h3aU8ya2NJSmFmM0VSeWtUMjVaMnZnM0VNNEEvaGFBL3hMQWY0MHdseDhpek1rZkFmam5DT2ZvZmxSNC9qRkNVTUMvaitEMC9RTUF2Mi85dnJTMmxnanJ4ZEtjUDVEbi95bkNuUDlFRzdXTTVaY0EvaFJoUFg2QWtFbjFvYldweG80MWtNNTFsamJXbHVtOWtudmV1TEwyTnhrR0RNc1VqcWZ1K3FEeTJnZW13RlRYMFF5V05Dd1Y2VTJib25Pb1FCd2dPRG5vd0NyMnNXTEEzaGtHNW0vV2hwS3ZidzNOV1h0MHpGSXZ2ZWQzMjl5OFFnaU0rR2diWVllS1k5OFlmRCszV0d1TkVJNUNxNjF6cHl4WjQwcWZ5UDh6cEd5TnFUSzBtdUtNM0RHckFpU0ZNblZhcXZHSjVhQlU0ZHUwcVlUY1RKVGJWZUU5YXBoZzJVd3RFMzBBSjdTSzRLSmxlV1lJemhFNnNUZldMK0sxS3UrdytlRzRnSUQzKzJZNHpTSkVDL1BHa3RUcU5KMjB3ZkdqU2lQN2RTM0NmalFnZXJ5ek5qam1oelllNHM0TXdOUDI2SGd1aGdIT01TUEtWU2w4amFEa2s0Znd2WnozT0VZUkpuV09uclJIeCs4Z09ielZ1YzZ5MzdIZkNIVGtIVE0yRTJkZklBODY0bG9POFIvRmZ3ck5NOFYvYWVPaGZXSi83UGRMaEt5QnJZVmtvem43WWlpNmFrTEc1aWpCMVVDTkROdzdHbDJ2U2luM1g4bEl5WFlpbnNsMXdsVGFpR2M2T3JxajMzbHVyRGNBZDBCb2cvYU5TaW1yQVdqWnVMNjFaZi9lV0Fhd2g0S2pZK0xvVkhRaVZad2l6TTZmR3A0b2pmU1pQd1R1b2N1bUc3MVBmT1c1dFJzSXJrdS9yNURPNnU2YysydnZKZDFVcHp3emg5WElrYzFIRTBvdTNZbnhSOGRWYXFNOU9uNW9kT1V0cERMWDFYYmFFV1dvYlU1Wkh2R21jZG5WcE44bEpSSXV1dGp3Z1RqQnRmVktlMVcrYUhQbm92Skk1WE9rdGQ1cGRvTmtnT0E2TTVDSERqMHRPVllxUjAvUWNzR2x2cXZCMHp1cytWRW43ajVNcGhBRGlyYXJkR3Npenl0UGljOFYrcXgwaHNCU3RONlk1cDlUNDVwZlJ6WDQ4dDJLQy9wYlZnNjZkZVdoNWQzS2YrSTRQVjBUUEtLQllTWmptZGxlMkRkNWRHWDM2OTVWZzZQcWNGRU9zMmM1OW96R0l3L3dvV3pET2RMNW43aHhUeERXK2hIM25yM2pISGtRNEo2Yml4cm9rU0xzejFUM28reS9mUVFjeStoQ0U4cndWNnV1OUlIZ0FkdGFXWHRqWlFQbGs4clA0M254aWxPVXAwUmU4dnc4MGhUaEg5eUQ2Z2pLQXVYY1BsQ2V2elRjSzcydkF6Mkd2N1g3OUdhbjBnZzlZdjNmR0hEUE9menBHUFI0TDVKdVBpazlVM3NIYkwvWDhGSHdvUlkweEgzTXRrbzZwZG9PaUJmY0c3MzYrYTY4ZTFzd09mbXhmV3JsclhudnhQajVRZTBlSU83UFN3UjU2SHdiL2R5ZUw4bHRmZnk4NXVpRHd3blZ6emZJNlJvZ1FUN1dCeDR2UkptWk5KeTZMUU0vdkM2dE9qamtYVUMzMm9sbVN6TUlXeXNVS0YvVlFCSHFzSHRHYzcwdW9MeVlheG96RXBIbWpkbS9HdGdZQTEva2VUcHVhV3ZpOHpIUVV1N1BxaXJZWHdZNWUxbFFuVUh4R3BJdW92cDV4dzZIUkdlVmQvT2Vqb3hOWGNIdVVYNU9XWFd2U2M0NTdvZHNibzAyK0Q0RFpxc2IyTHVrS1RPUlVUdjB2Q0JYMDdsWHRVMk50Vk01MldrUUt2VHZWbG1IdCtUblFCZGZQTTVtZWdGeTN1cURXaWtEQXVVZ0twV3RxZitxSXhMSTkrc1NxVnFuZDE1bjBKU1BlK0w3VkVhTnVrNnRMZVR5NVJ1QndqeVc4SmpWTmdEWjA3U0xGdTZsazMzV2grL3V1WTJYTHoyT3dlYTVncytrV2VUbnBYbFcycUd5SHZXNm9pNjhxOXhiZ3dFZXZkY2VIYy90MDh2UDdmNVoyOVVITTdEOWVZNkEwK2ZlZGpId2JPbDRGcStmK3o3MitnS2xQWTZQc253dGVBeVR4ZGtwczJKL0Z5bXI5eHNJalBSL2dwM0RKK1YzMzBVcWtmUVJnT3R0ejhXMU5vQlFSdmdyQVA0K2dyRnppZUNVdkVCd0NOSUE4c0t1UldXWTd6UUhOYjN3djR1d0dIK0ZJRFI4M2E1Zkl6L1g1S3NJVHRGYUdlUkxHOXUzNU5xL0JQQi9JNTNQOVJoaFFZcGxvYlhzdFRtS0h3SzRtQitlTE0zNS9jaXUvU1ByNzNjUklvL25DSE8rdFBkYzd1TFl0RG4rNzVHaWJtRHQvbzhBem5YTkZtZW43eUU0b24vRDNmOTkrL3NKUWhieEk2UTVCY0k4WGRoOWY0RlFLbm9PNEw5RENBejQzL3I2YnBuQUhhSytEVDZaZzN5R0VLVHdScFNEdjZsQW8rTFFQZkt2bHVlSUN2Mlc3MlFiblJKbzdZNFIyS2FJZlFYSk1VRkQwdzNNMlRGbXJMZUJOamhyTmJ1TkRKek05T3RJRWZjWENKbUp4YXkrTnBWMGhDbVFieFRzL1E5aDVZMUg0b2dxQ0JranE2MnBYMi9pbWhqUldJWTVNK1EycWJ4Z3lhQkU0YVNVUGFVUms1bUFxWVp6NU1LTmo2YWxBZ2lrckxPcHRKYzV1cEFyNmxjb1JPYlpPNW41U3RCN2FEeFhBNEJldTVCeGFXbkM2TGhGVnhoV2dYUUNLNTNhcHRLS2EvdGZoVHRJTzFTMi9abWJFeVNITXNkTnB4QVErTVZqaEgzNXNrMWxqdEhrSlpzWm1VM2p3RDRDLzdrR2NOQThmM2JsMW9yWnFCeVB6MUJtaWRSRmt6SWtubGpicjVwMEZzc2p1NWZsbmIxZ3pwTFVxeVlFWHd5Q3plazc5dTg1SFR2RWYzdnZVeHZIVGVQS2FiZkpZVGZhY1d2MGgyV25iNXFSNWFQYlBPaEVqYlBFSys0cG5wTjdWZHJmWm96eEpWK3A4TVF6RTkxajBhSHNoV1gzdjVhVUtoa2NpNGJTd2owYTRYeHY1WDNmQkNnTlZsb205RkVWZXhxczFNQzJzbWU1TmxFaGtmM2kxNEVCT2djSTgvZEtmcU1EZDRseXhtN2ZXTGdIUFQ5aDl2NGF1TitTbmFRL3dtdm9mTDVHb2k5YXRXWmVvd2V0WkRHaWNnYmhpUDVFSGlNMG81TU5KL3RORFRoSzV5K2I1L1dNU1hzMlJwYWpxNXgySElUdU9jMHc5dmhJbWtHREJ4MnpTL2tPSkZ4VlE4Z2FhZTRoL1lLMFI3eGV1WG5Sc3U4VGFZLzhYRE9BVlM1UVVCbUVOSkh6VWVMbkpRTnQ5ci8wY2VydXFiMWYxMERIcCtPS0lPdE0zUEFsUS9WYVo3L0xlUFNjUnY0bFgrV1JGR3ZoeVR5NzBHZUcrUFZsWlpLWjZ4dnZJWTFpbTd4R3ZPVDVzcHdMQnE1ZHl4NWhNRWtXVUNIOVlxQWNnNjBHb1UyQllrRGdmNTFxUSszUk1jOFhYdnI5SW5NMDJzRWxNdUlHMjVYYlZaeFFBeTZOaFd2WGRxMnNZMGxXajJWZjdaclBHT3J3OGtvZmZkV1Y0amkyMFVQdVU5ZDdFNkQwVzJsNllkOERPVzhuK0tDY3NYSlIxSHNLUnVST1J0N0lzVEI0eEFPZC9tOUNQeWUrYy82aUhjSnVPVUFLWE50RE9OYW1LRE1iblhsZy80NDZTcWJReG1CWno4cDZjNi9TZm5wUmtnZmN1M3lsSE9xS2ZLWkVud0RqcDlJK2VTajU1aVBrRGhrZUw4VHl5WjdlUjk1Z3o1R2ZxNDZwN1pGbmFKQW45VUZQMThqSHladEtSbld2VXpOSWt0ZWpqdVBrS05vVTFzZ3podFZ4dzJNQVZLOVl5VE9sUHFqOFVzclVoRnhYSjdYS3cyeUhiUzNkODU0UDh6ZlBDN3hlSHl0YUlQSEg0bEVrMG1kbW8wL2QvTVhmNVR0UWtZSGNIdVcxdGJ1dmFGY3EwYzB4VUhyL05yQUwvUkxuejFZbHI1SG1UMlZSM1R0QXNsRVY5VnFqWWI2Y2VkU0ZYUnRLTDZnblpqWWZSNmVHWklrSkJ2UTN3Vk0rZjZzaitYN1JJUHdtN2lQS3ZjNDJxZlJaYlgzWnZJK1JkUnpON3F3Wmt0eStMZDcyQlQ3ZGVCcHdIMURnNTBwemlZTzBPVTRSYklZMWZrNDljOVBzV0RhOHRQOUg4bk1nQlJUeGVMdFJQaG1uWnhONjhZR0d4RG1Ddy9VekJDWitnK0RVWTVsRGJaQ1QrQUs3TzkzZVFsaUVqKzM5TCt6NkhvQy9DK0RiQ0ptL2M0U3MwSFBMK056d0x4dXk3MFNzSHlCa20xTHgreERBcDBqQzNNY0l6c3cvUTNDNmZvQjBqdkhTZnZzQXlmRjVhZGRmMnB6OEhvSnovQ2xTbWRWYTFQek1uTk93K3k0QXJPM2F3dnIxRVlKVCtlZld2MnU3ZGpFL1BMbkNqczVmZzcrSGJsVFpBWUJGWWMxWTN2cjdDSE80c3I3d1RPajNyZit2QVB3YnBEbWpJNXNSZmlRb255TE1aUzl1ekE5UFZ2UERrNlY5MW41dGEyRFoxSHMybDFOcjZ3dkxERDR2TUpMd2F6UmZqS3FXYXdENm8zRWM5TDJUR1pkajIrSjdEeEQyNXh5NThiQ1RiWHBmMElUSVBUV0V2SVdVMFVkbDhRSWgrMm1Oa0dWWWkvQ2hjbFF0KzdyTkhKV2U1YWZTN2dHU28yNXMxUU1LRzlHd0JBd0s0VlZHMWFhSUpzMnkxV3dEN2E5R21CTlBtWW15MytabjlXaHBWekplblFjS25kcWVPcjNvMUtCaXBtZnkwdEFSRGRIb1pvRjJ4b29rOEhHdWxLa3o0OVU3cEc4UW5DSEVKLzVHWjZ1ZWowcW5MZzBiNnF4ZTJUTkx3MGNxM0ZvaW5PdEVZeWxrRGpnT1p0T3F3c2RJN3BYUWk2WDFtY1pZanZ2RzdRZG1HOFYxWTd1TkJVN0lPTlRBejdXak1ZZnJ4TXc2OXBkcnk3T1YyZDdDNXJVamlCa3VYeUNkbVRZVzFnZ3l6eHFXRFcwNCtkQ1VBUFpQczJzVk5OSjhMR2hwb1pyRFpzcjkwYVlzTVFyRGNlNWx2OUFJcUx5Z1NJZWFFTzI1bHY5NS8wcjJiOWF1ZldjRy9FU2U5WFJpallxZ1d6QndGTUh3OGFaNS91emFQbXViaDUzcDZpOFN1RTkxVGh6dlU2ZWJadUVCS1ZBaUtxWUkyYnNyaEF5QVNWcy9iNHAwemZOdDBqN2RtNE5nN3laTnBlR04rTEZ1TEN0bHJNSGtGaEFqYVdGWmhQYjNDUUpmSjMzaC9ycnFVWXhqWllNQlpiMEtqV1ZJMGhqclpDL09zWThXNTNwckdjckhmTDVISmlKZDFjd01ueVZVZ2xxZ0YvazU1MEVOMFdyOElQMGhIMVdISC9uZ0E2VHNtNVY4MUNpbWVPb05sY29MOVAwKzgwSDVzbDZIL0Y4YWF5bVMyNy9mR3d2MEhkb1A0bGZNd3VOdlFxOXJaWVlWVDFTMlVKZzRYSW1aRmJabXVxZDFMbGJFUjZSOTdrdWNsU28zY0o3aldLeVBIcWU4MFo2eUlPVFpiRHdpUjBXZTFLVHN0U3RVZUtCY0gxM053ZHBsRmpGbDBpbENkakw3VHFkRmFkN0p6MGZ6R3JmK1ZWMm1JdGRuY3k5ck5IRTRVbTNYeS9FaXk4VjFOc09tei9ZWm84K05NbmdOQWVsanhjajJoUUxoNTJ0M3pRTnhYcDFSYTV1SGJDOHJ6YS9wZjY3ZFRuKzIxYzhObEw0RFhicjJKdlJ6eFlzOUJCNUMzWnpHVi9hQmVGM1RmWm1vY25rTGZoN0g3ZTl0VXpiU3RMQk8xSGNvZHozcDQrZjJMT1VBOGxTVkIwdWxadFhlbzd5SlFQMkFOSTRsbVNIdlViMWMrZm5HUGNNczRqMGtQa0s2R3ArWFByRXFsdmFIL0Z6MUY1VmRsTlp1Q3RmNFhCK3Q1aHl3dXBlMjBhbWFnT1NFOEVIc2ErVDBrZTJxN1VEWGtlTlp1OS9VQnJkeDdRQ09EcmVweXBibnJiNnR0ZnN0UWdFUFMzeG1yT08xcEZ2WDNsVjZycmp2VlA0WTBZZFN1MXZ6akZ2d21Uai9mVzA3ZTUzdUMrcEVXZC9IMEZMVGZYWHZhL1l0WlFMaU90dm1Ic3V5SlFzNjU5cGZsL0VvZmVqckh5dFRyS2p6dFlWTTJDOENXSjlwTjQ5eUp1ZmZ6ZE1VYWU4cWZrUjluWFlhTCt0VTVrWjFyUWl5VHRXTTNjcFl2SDVGOFB6ODNweS9iRi9HcmxVVnlNOTFUbWwzcXZudUtNc09CU1QwOWFlRDY5by82eVB0YkxwUFNiTTNTUHB0TDBpN0dyUlN0WWtwN0NFNDk1WUlUczJ2STUzeisvOGhHR1lCWUxJNE81MmFNNUxuMzVGaDcycDRlWW5nVEgyRTRMUTlRSEltQXNFaCtSbEdPSm50bkdJeTdHc0V3OHorL1BEa0hNRE40dXlVRzRhTWVHUGplNFhnY1A0eGttUGpBc0JQclI5L1lOY2UyWDN2SVRtUFh3UDQ5eEF5bGt1d1JwZzNBTjBTeGdBMmk3UFRhMnZ2ZmFTeW9Qc0FmbVRQN1NRRW0yUDBLWUxEK3hHQ1kvY0dZVDVMYmI0UDREdEk1d0hQRUp5NHJ4RU1YQlNNUDdRMnpnSDhIWG4rYlFSRCtSUUpoMzU2MTA1Wkd4Zm5hQS9KRVgydnhPVkx5S0pNZEs0M1FKNHR1YTNpWmdiTTJqTXFzRy9UN2h4QkNXQlFBZ01hdG9ybW9ZQjFCOFpsQnFSUWFLZHhuV1dUV0ZIZ1U1UWRQcjNSOFBiN3FQa3BHSXNwUEZLWTJNai9hdXk5Z2ptQzI4cFp5V3dmVnVZWElZQm1nMkJZQXRCL3JvRUpkVFJpVXNnalE1eGJueTd0ZWxTZUJndzhrUkhTa1dIWG8wTlRqSVZrdkZINWEwTEcxeFFXbmR5a2FEMDZSbFVRbmlMUVNScEJOYXFjemc4Zk1UeHIzWGsrQnBuQnQvQS8zNmZscHlra0VzZFVNWjBqWlgyeFh3dUVrc3VxbkxOZjZyajNrWUw3MGdhRmQ3NkhaNFhzSS9DU1N5Ukg5RnFlMDNIU3NmUUVpWWRUR0NYTnVaUXgzelRQbjEyeUx3NGZOZXZucGcxbmJkQzV6QXhZVlpEbTdkRXhNMzI0bmtvbk9KOUZzSGQ4M0dQNFlTUWhJelVmd1FLeFlGVk5CQWVqZ3cycEpPVitHN0tIMUFITnFPNXQrRjdFWVFTY285TmFEUWE2bGxQM2Q0T2NGdExBN3cwRW8yWENKa1M3MGxIRnpBOEcxWTJtOXlPVUMxV2VSa0diemsvWkFQSDg3QmsraDVuQk5abzZ3Qk5JOHlnVDZ6NlAwZisySG5IK2hOWm1rY2ROS3ZmS1VuL1puakUrdjQvdDlRWFNHOUoyenIzdTYxRmdEdGtwQ21mdkRZR2JTM1ZJYjVCb2svS3NEZktvWS9hQjg5NWIvbW9MZmg0anErM2RWSHpWVVBNUXVZR1hjZ2ZwNlg0YnpuVXVuY21wU3FpV1FsZmVWdU8vNUFjVDJMNXhCaDgxb0hMT01tZVIzT2Q1SVlPVEZVaDd2Tk4xMnRxWnpVSnp5T1BVY2ErR1hZSzI1d05jMW9YN0o4YXoxUEJZbWhlbHU1Mk1TajRyYytiM256ZTYrUDNoSWNyUWJuMjlJNGF5R3ArWkdBMVErVWdOd3pQWFZoeGJtd0lnb3BPZmM5T2s4eGt6bzZVWlI5U0l5WHNvSThXU2hpSm5zSzkwa3VpeEZKNVBrcWNWb1VsQlhVVm84N1BVbGFiUVVlRU5UZnA5aGNEcjlwcTgvR3Nzc1ZkN2I2RWYzQU9vUFN2cm9ZNmZ6UGtoOCt5TnRBeXdHTjB2a2Q4NUgwQSszeG5POTdRelNKdTMxVE01RjhRL3hkWDdkamJlRnZvY2VnNzhXbVhHVjZVajdyNE9UZkNHMnhFT21GRlFvRGY2MlVvMmFFZGtpbzhFRFNwalFKeDNicWxUMDBOMjdtVUpkdEhQRFU5SlgxVHYwOUxHR25nNWdlbVk3ZEZ4cmRLWkhoMUVKdzlwSjdOS3RRcUU1MTg4ODVZQmNYc0l1aVhuUjRPTmVkK052QVBTMTQwOFIzNnVHYTZrM1lvdlFEQ2NzOUlBS3pLeVRmSno2aEZ3enpMQWQ0YkVIMHI5VWRtRDUzT3lYWlZWTnU0OXF0T3JIQU1rM3VVemdybHVKZWVhcnAxbStIcm5iK1lNa3Q4bTd0NkoyVTQ0UHFVSG1hM044Zk8xNCtjYmRPVXFkV1RVYklKczA1Y2hMdEdZckQrRnY2T2dqNSs0UG12QTNpaGVWWG5mcnZ5RU9EVTFtY3ZUWmI5bWdIUG05ZkJ6NGxrdHNLRTBobVdiemdLbW5hSTBOclpickF6VkRCK05wUExrS0hCNHJuTEg1K3JvQnFDNEJ6U1F0WGcvRXMzZ3VsRiszRUNPd2JIMUdLWDcyL29CU2Q3MHNLMmRYWjhyN2RPdGpzUnFwVXJtTFdVeTVUUGtTYVVrZ0NJL1YvcFZnMXZZMjVYL1JuNkdsQWpCZGVaZTU5R1BmZFh0WW5hLy9ZM0JJUlhiY29ROUFMOXMzNytOa08xNUErQWZBL2k1WnArNnMyZzFXMkFYMkVNNHEvZTNFQndmekY3Nk1ZS0RFUWhPMkUvSE9oSG5oeWZyeGRrcEo0QWxud2wwVGhMVzlyNFhTRm5BTEtIeU5ZUnN2YmNSSnBZbHNubnU3UTFDeGk1cmYzZUVUM05VVW9qQi9QQ2tieVA4a3JWRlo1Vm1GR0J4ZHJyYU5ndDRmbml5V1p5ZC9ndnIvN2NRSFBvZnd3aUpLMDg5UlhMKzN0aDhYTXIzbHdnR29Fdjc4SXpSanhIbTYxUHI4OXgrL3dBcHcvbE93Y2FsZ3VZR3dPckw3Ti83aHg0RDg2WjBUeC9SVVdPWEVhcXZJQ2d0UDNQS0hKV2RyYzZ5YlkrT2VVWTVtZWNTVzVhV01vSGlBRUhodVdxMlBLL0h3UTJDQXpVVHFKRkg3dTRCV2ZSOE5JZ2hPVWh1TGRnVWpIOWUyZEJvS1JxMUYyMDQ4RDZXMGhlRkNLNjl0NUVZOEg3ei9Oa25NdWZla2VoTFZnSzV3WXIvMDZITXZ2SnN4K3ZXS1EzK1BRWmV5ZGtBV1dsS2pqMGE4dG5uTnBYYjlhWDd2R0R0bFFZS0hQNzhJZ3ArTkJiNjhSS29LR3JmVlZtK1FUcjZnTzlRSlpaengvR3BBRVRGWEhraSs2ZlBhaFlvTXpqVmdFK0h3Q1BrWnp4eHZCUk82S2haTmMrZnZXNVRCcUU2SzlUeE40WHRYOEY1am9QVlBQZ09Hang0UkFRejY2NkJEcjR2RUhpVjR2dkcrc0NnREkvWG5LTURjNUowOW1DUDh6ZEdyTGNwWUlEQ0drdE4wOWdUczZ4TjBkNUhvQm1ja3hnb3NDTWQwRE9xb215QzNESGtCVkFnVnhhVUJxNlJqRUdhY1pjRmVmanZmTDlUL2xjeUQydWJLMjFYbi9jSytoUVY0ZGphMjFXUjE3a0NFajZQVXFEZkpHekJ6L3dab1ZrR3FjMjdaZ1d0a09oa3hqdmxIalU0TWxQaktkTCtQTGY3YU9UU1VzbDkvYVdUanJJNjVYa2FzODRSNlBTbzBsSnRjSXd5QUNUMmEwZmd2aVJzRVBqZXo3MnpyS0M4Y1crejRzK3RRTWZ1akNMS3p3R2hJMGo2QnN2V3poRG1zaFJNUldXVnRGeVBGMWc1UENCUEtPMFR6VmhnSUFBRHBpN2RjeFBYUm1lZURDZVhTSGhCUnpLelpxaWpxaEY3SXpRWkNPdm9qYVZxS05QclFGZUgxTi9WRU1jZ0h0MlhHL25kNzljTjBBbU95NTZsck5MamlDSHd2VVVEanhtQWxBWlAzTDMrMlZqR1VkcVBBV3cwL0xZcFFFYnhyek5mQmZ5S1RtWGhEeXJ6UjFuTkQ2Wkp3WG02eHVRSDBWSHNnQUZpTStQbm8zbUQ4aC9iNTVtaEJuSThTcE1xWEtnY3dQdEx0SFJiSHFWelhUcS9MUVlya01iYmRkWFIxdktkR1RXVUwvd2VIQXVaL0MxOFJmRW1Rc0hZT1Jod3U2TnhNTk0zdmtoUU0vd1ZybnZaMWVQRm9CTlpESWVxSHgzWWIxNytKVjV2ZGZhZDBlMk1McU5IaHF2ME01YVJ0cm5ZeXRqc1FJTWRTTmNmSWgwdkFlVDhRK25ZQWNKOGRVcTc3d0pPWDlGZ1dlVkJHN2xPZmo1QjR1ZWtpZjdvZ3dtQ3praGV5VUNOYUpNUVdzRmpLaFpJOHN4YTJpYmRVMzJVZ2RvTVhtVWdvUEwxTmNvQkwyb1RvWDF2aVhUVUJvT3F2YjVCUFpKeWd1ZC82alRWdWZHOFcyMENlajloenpsYnZNeWdXVnNibUV4czkvQUlvU2dmeURNK0dFTHRNVU9nY3ViTWRNaVNFMGZwZUIrdmlYdGVjRS81QVB2SlBlLzVPVzBaV1pDTjdjKzFmNDkvdVR5am9MeXkxTzhoZVdnSXVLOHoreE13cnJ5OXQyUHRDbTF5N3VxSHVBaDA1VWZQenlsN3cvcXpia00xTDY2N3JrOU5QNWxjRUlNQUFDQUFTVVJCVkM4NVVUZEFKMUNNMzZNOGd5RHpVcmFuWTVMN3RTcG5xWnkwSlhpSEh1Y3ZKck44WHFBdzlnNyt0NjRFTisrRE9QSnRUbFZIMDdXcDRsOUJWbEMrcWU4YkxlKzVQVWxib3VKSXBDVWo3Uk4wakxJZnQ5R05GUytwQjVJR2szN3RJMVRwOHZ5OFpLUGFHUXIyZHAxZnlobEE0bUdySmlTMzNDQlZtRlFlNVlGMlBTQlV4cmdVK3RzcHFTLzhmUUpnTTBVdzNyNk41QkQ5VXdRblh5YlVpUlB5SVZMcDN6M25HQjRFT3cvM1B3UHdueU9jd2F1T1dwWWgvbk9rOC8yMkFSVWdTc0pZTEJkaTVhUS9BZkIvSW1UaC9tc0Fmd0xnM3lLY2hmc2RKT2Z2SlVKSjQrOEMrTDhRenJwOU5UODgrWmwzenByemwwYmVUQmtxd0FUaHJOd2Z6QTlQUHBrZm5yeVlINTU4RDBIb2VvcVFjZnpXNHV6MDRiYnpqTENXSHlOa0tIOHdQenc1bngrZXZMWnhSMFN5L3Y4bGdIOEc0SDhHOE04Unpqditad0QrR01DUEVKenhDd1JuOEJVQ2Z2elU1dVViQUg0VjRWeGw4TGRibEs3dUJYT21MMkNaNFY4NmZ6Ky9VRE5XT2NIcU1VSW0vYmVSRkJpRmFNZ1llaGMvVFNobmN0R0VNNzRZS0xDdG9LWkcxRnNwZHFZWXZrSncrSnpiL3o5SFVnS1dBSDZJUXVZVXVncmdmWUFxbDZTZlVURzNNWkRSWDlqOGVnR0dqRjdidW1xbE5Fd0paTTAyOW9sT0I3dGxJNThWckRSeFNmRHVXMXRSUWxqaVZZMXZtYkNMWkNDTWltR2hTVStQcWFCZUlOQW5NbThLSUpwNXJJS0FPbHhqNlU2NWw4OHpBRUFqbFBsL0xDL281c0FiOGVoa1hDQ3ZpTUdTb05kSVorS3F3cjJINU95ajgxaExLR3QyTTNHRDg4RHNXaHBlQ1RRd2NIK3hyNHdFajRFRUlqanhlZTVIalE1blB4OEFlQ0FHNndnMmY2K1FLMDFSaVVaWjZGdkwzMHlZYTBPSjRKbTdwbVhpNlBEU2ttY1hDSHkwNzZ3dzR1a1N5ZG05ajFBaWVtczYwS1lvd1k1eWphNVF5WDNDandiN2xSUXV6bnRtOUxYM1RoSHdocVdVYVZTWXlyMmRpRjBiTjB0U1JXV2lRRi8yZkh0M0FjN1JyRGczSk05OW5pRmI1eVpVV1BCUjRwUENQZm9ieStmclBaVEhPQy92SU9EM0t3UWptS2ZUby9nNTVKeGE0K1V2bXVmUFhpQUZKM0pkaXNieFFudTZmM2M2MTBmZ0NrRlhlUUhnNHlhY1ZmNEtnV1k5UktxYWM0MkVvd1R1QVo4NWVSZmdIWkhrWDdyUHVSNHJCSjN2SE1GeDFUSEFpNEt2L0pjWmtDWGFwYzdUbGZDcnRXdEg5eGZiaklZazZXdG1BQkVhUU5xeVFzQzloVHlqamorK0s1YmJrcjZxZktFR2JUMGYwUnQ1NC96MXpBR3ZUZDNIdDVtTmg5ZEh5RFhlV1Z2Qy8xbmxIcVdmcFhMUHZ2M1lMNkhGUHJpTW9BWmkvcjlHS3Jlc3g3SG84M0ZPYkp4VEc4TkVlRVpmQlE0TlBLdkphZ3FLR3htb1hLblgzQmduN2p2bHFlc0tQdkJkM0EvTXNKdVVaSlF0UUxNVy9aN24zNndzbytCYmhtdnlmWUlVOUZkMEZ1Z2MyUnBsSlFNZFR2T2FsdW92N1J1Vnc3WXFRYmd0K1BXOUN5UGY1d0ZLOHpvMDFoTGZvUTRtOTdLaTBScmRpZ3ZlMlZZRnA1K3ZUSWZVbzNPMkJjWE5XOW1hUklhNVJOQnZyeERrOUhlUWpudGpTV0pmcnBTODdENWtVQVhPTTJsY0ZyelJwTW9Ga1o4WG1sWCtTNmp4Yy9KbXltRjBjSlBlWnJ4TStyTkJxaTVDM1U1cE13T0JlR3dBbjZNT2NZMVVMWXBPclJYeU1SOGc2SGgwOW5nZVIzMUwrUWRwRE0rQVh5S1hSVXRPU1RXNmM0M1Y4ZVRYbnZvNi85OURzSk9YWktEUzh5VWNVcG1FWXltTmVkTU8yRnFRbkh1cXgzUmtRN25YNHlEMzdUWFNHbXMvQVNRNjQ1MGZ5bU5xSGR5QkhoZGxvREhnbkw2S0I2TVQzTlJ4ZEVzNXZvOStaSHhlNVhMcnErSW9yRCtLVXd5ZzZQUVpRUzZtYlVlcnV2RmVQU0tOdE9ZYVNUOWZJUVhjS1kwQ2t1NVRLN1hMdm00MWJ4cHNnRnkyQnI0QStubVA3aFIvdDMybVI2VUJYZjNjbDN3dUhzZmczcmRuYmZzcUYyeS9kMzhLc0lROG1sQ2ErOXJhelBqNWx2WjI5dUZXYTJpNGVJWEFSNjZNYjEwZzZDQno1RlVhUFozemN2UmRnOWZsTWhvTzBYZGhZMmpjOFdtVk5qY0l0dkZPa0w2OEsrNGQ0czRlZ1A4RndOOUhLci84aVgyL2dpQ2xPVFluU0JGZXpGZ2Q3YVMxTnQ2MWYxOGdPQ2YvR2tId29nT1JKVVNpTXJnbGJOeGZuZys3a3JMS0d6ay9WaFhmaHdEK0V3VEhLMkZwZmYxckJDZk5aL1BEa3lxQzJyczRKNzJJYkU3U3pzTE9EMDlXaTdQVEd3U2owbExhSFExMi94aUZHUFBEazA4V1o2ZWZJbzhxNHZ5L0RlQjNFTmJreDBqTzRKL1ovVDlEY0FMLzFmendoSWExNmxtbENwcUp2QTNJMkw2RXp6SFVpRCtKbERqWUxoQ0NMVEtCRVYwbVg0dDhya1VQc3N5b04xWmxmWUU0eWRRbzNscHBXR2QwVkppZ0VzMVk2aDl5eHJnQzhBa2oveWhrdGQyU0RUNExqa0xhYmN0a2xPYU10SXRNdUNQOG9XZmZXVnV2a1l6RkUxZ1FUWHQwL0tyUWxrWStkbjZUL2wzQVJhYnRNbllmN1NoTVZSV25hSXh1VXJubjZyaExjeUtLR0pWZ2piUldZN0tXRXZUQ3dOck5rYzRKNUw2TTJXdDBGeEplVTJtTVpRcXRIU3FVWFBlVnRNSDVYa3RiTE90TUhrM2xWUjBkcW1ReSs0OE9rWGcySUpKeFFLUHZKL0w3QTN2WFo5WlhqV1RsM0svYmtQbkw5eko3ZlFMZ1VYdDB2R2hjVkw3MTY3V01uVVprdEVmSEIyM0llb3daQmZhT0szVDNPV1doT000bUJVa1FTQzhvRkd0WnNDcTRQdXU1VVoxemlJZWdUZEg4MFhuanhnQWtZOGdlZ21GYW5kaUt0d3lLOE00UmxUVlU1bEU1UW1XTE1UQ1ZQYUgwUVlNcHh0Q2pQWFFqYTN2QjhJM0JPQXlBWVliQkZ4WUtCdUFzK2hVcFlLVUVuT3ZTNzFNZ25xbWovS3BJdzVDY1BKNzNLZTBpZmZGOGV3RXh3aFhHUkJ5bWtyZWdVYnNOVlN4VUptQlFoT29BYTA4elBOZzdsWmFoQ1ZVeXJxeHYxMEFzQiszcGhwWW9KRzFFaVZidEFEb081U2RBV3J1RnlsNU52WFFsczBXNS82a3N6eEdpL2ZWTVpHWmowdUNhR1FQYlBMTVlDSE9nL0VYbEtONFh4K0pwcHZSZlpRSTFqQkxYZkRDYkwrMVArcTUwTVpiQUZONDhSODVUSjhnZHFKb0I1T21SR3V0b3FLMFpGeklhcVR5OXlZTmZ2TEhWeTFMeHZUVzUyS0JrL05BeGVJTVQ5Mm5wekZxVlhiTDlML0xLQVZKQVdHZWNCalJNRVplQXdBdXFaZEFFOS9oL1VXN2lHRXl1ejV3ZWprL2VTRnMrNDVIOTV2eXE0Nk1JVGtic0JGZHVBOExUZ1B6Y2E0TG56VE9UWDBrdk14clJTaGFKdTI5anNsQUpuL3YrNyt0M0JMZU9pdHREYlpCdWJTdi9leno0UXRzUXhvNy9ObnFTckJscFc2YUh5eU1ULzJ5cEh4WDlQTXRJS2ZVRnlRa1crWlU5RjQveDBUNFY2T1lnRkhqTVRYdDAvSW1NbWJUTUJ6OW56dEEyWkFSUGtDb203UVRrbStqdURYWHNNTUFtNm85TnZWSVo1NWUyT2VYbmt6WWQzY0g1V3hqOUpPOVRIVlVkWk9SOUQ1SDBTQ0RQSWxSK1hqenFBTG4rUjlwUEl6MnJtR2lnbGo1SDRCcXBuVWJYaC9MVkkrUTBVblZ3dHN2ZnRhK1pQbUs4SkdZZ0N5Nzc1OWJDby9yNno3bmwrL2ZjdllvUFhoN1JzZmg5cHU5Ui9ad1ZwL2JrZWYrTTEvTVUrdlFGQUozcUU1bURzclkvK3V5Ry9wNisvZTNwUVFHeThlcDlZK25HTFoyK2JLUG01L0M0eEgyb3dhUDYyNnhOZ1pINlBORGR0M29keURNNGU0OXFNNWk1Zmw4THpWTGM3RnNmcmVJd21sNktyQUxrc3ZxOUpKMjlJZWhVZGl2Z3IrcXFHWkMvbHRhc1lHL3Y0SzM4UC9IWFN2eFZkR2pmanlGK25nVzdpSjF0MVlZS2ZhcDNGZmZXbUwzcDVUdlRYVjRYYkI1ZTU4N3dWdmJhS0R2L1VKL0VscXg3bTN5UFNUcjZUSEc5WmExWjZaRHpQamQ5NjBxZmxmV2F3dVQrNXZtenpRU0laWUNuU0ZFOVN3RHIrZUhKalhmU0xjNU9md3RoMC80Y3dJdjU0WWtxZEZWWW5KM09FSndCK3dCK0Q4R28veE1FcHlxUVVxR3pTUmdvbjF4NkQ2TVVOK0tRNUcrSzVHcWNQUUR3MndqbG4vVnNXeUJrTTN3ZkllTC9od2pacmJjdTlUSUVObDlBR01jYkoydzJWMTlIV0xNVmdoUDhKWUJySzhVOEFXSlo1bG1mVTd6UTl0WmoyOVZaL0NYc0JpVm1zbzFDMWRjdWtER1ZHWUpBdm15ZVA3dDA5NnF4aEFyb0RKWmw2SXpLMndodFpENWtOQ3dKTVVVd2tIWncwcHdpZERKTjRFcmUza2JaMndiTXNMMFB5MlM5Zy9iVTBCYVZHLzR1NnpUcWZBWmRYL3YrU3dqODRxWjUvdXhubFdjOFU5YnIza0NQMHIwOTdWSXhYbnZjYy9leDFDWGsrNVVaQXJaUzZ1MDlqOWtHa2xPRVBKYktuSjZMU0ZCanVCcjhWazB1R0dtSnBrNi81RG1XMjR3S2dGdFRqaldlRDh1K3VUN3hMQ3IrNVhWbUE5T1pza0dJb2xmbC95dEk1Y1RvT05GU1h4TjdudVhKR0tGOTFZUXMvbXpQaW1ESWM0MVZXZGJTMWpmTjgyZlY4L3lrZjFQWDdpaGEwb2F6ZVpjbEo0cHpNSEc4WEhOZDJ4a3FodTAybGEybEFlNTFzNldUeU5hWXhpSldXTkN5YU9kaTJDZHRVK0haT3dQNG15cVpwQnY3TnBiWVI2R2JHL2VKRG9WS3Z6UGE3NHoxdmp6enB0U1czTGVWQTlpZWpYVCtUZEgyKzRRMm5EdTVsSG1sOGgzTHBWZWV5NXkwdGQrUkZKa0hNSnJTUEgvMjB0MUw1eURwSC90d1pmeGlMdTJzUy90SzJwb2dHQk5YdGxaQUNoeDlnS1JQblB2eEdWNHdLSVVHRTlLbVR1RFRYWU1veUVESU1Gb2hyTU5XWnhwWDJ0WlNXdHdmSEQ5NU8va1FZT1VnQzg2d3pHZ3Y4dFlEcE1vTHhZQVVXK2RTbWJPNEgrMFNlZGhOWmY5NlEwSTBualo1K1YrdFVrS2FFNnM5SWRmMXJwQU15dXZtK1RNZUk2R0dVZDhQVnE5Z1JwUTYvYkxNaHlZNWxQazdVSFkyZGpKa0lEUzIwZzh2RC9zMk9COUt2ejA5aDF6M0h6VXlSeWpJRnNRZG5RZFBCNkpzZ3NUclY5elRsVGs0UUQ2L1FISlVBUGUvTDdXQ1NlbDMwaThOcHZLeVdoOGVhVGJNQmpzRWNiWXBBSFNGZEFSSXpNNTJjcGZ5U2Y1VjNzOSsxUENOVHJlVlhDc1o1WWo3T3huakJXOEpSWDFxekI3WjVmMWZSUEM2dU03TmtMd3lwTWZyNzIwNkEzN1NQSDkyN3UvamQrRVZzWVMzNFk4UDhCbnNWOEZHb1B1bVF3UFVzQWtuWTJvNzl3a3lGeGx2dVlOMm81UEVnRFNWNzZOdVNUbjdHbVhlMjVuYk5uZndIaURZT0V0bCtxbERlcnhpRlNmSys2Uk56TG9xallmOGlmb3A5YzFyK1Q4NmJhMmZmQS9Icjd4dGdTVHJNVEdKZlM0ZDZZUDI2RmdUbkZRLzBZQTByY0tsRlIwejJkVDFqY0Y5eEZmdXlUV1NqS3RIUy9reXRodmtlcjVtMlhvYnlOcjlWWHF1ODZUOG5iQjBmRUxIcDdZMkwzdHRrUGd4TThmNytMbC9MNkdvMTkwMWpLRnp5TWU0TmEzWTFRWlo2WU9Xb2VkMXRSZDR2UmZveXJoQUhuQXdFUnRURmtRamJXbzdIazlxc2hCbE9zcEFLaU5vS1YvWU96dTAwTjIzM0VhMkU1d2RGVlQvZVFheDFXbXdQZGUwTDBnWHVzWTl2M3NuTG5YNnBidFhnMU9vNDAyUmprOWttV0xTd0ZGeVJzSGVyclN4eHM5OU5ZUE1hZm9HN2UwNzI1QXE3WEd0MVo0V3orNFZPeVJwd1dnZHdaNTdLdjE5MVhNZm11Y2hBeGdJanJnbGdLVTU1OVowdGhXY2JwOGlaSHd1eGpoL25lT1hHLzZSZlg1bTc5N0FzbWpNR1gyYjByNmw2QmNBYVN6MkRwNnh0NCtRZmZ5ZTljbkREZEo1dHp6ajR2VzJuUkxuODloc1hqSUVMTTVPOFNhZHdOWlhPcG91QUh6azE5cVZrZDdHK1J1enhPUnY2ZjFUSk9jelM3emR0blRmbHpBU1NrUm5wRk9rbHlHcEVpTEN6MlZKWVhERU1Bcm83QWQvSDlrdk5SWjYycUJSYTZWbkQ1Q01MVFJjMC9uckJmVDdCaTBMZkd1d3Vldk1QUVc4TmtVOFI2TnRLMW5LSWdqZU5NK0w1ZDNvL0xxdXJWWEYyRE5GcUJaeGdFQ0RXTHFYMldON1hqQnF1NDVrT2l4Vk1aeTBka2FDdnI4TjJWdkVFU3FqTExtcndrZkhRTzdIWk5kakpEUnkzRnJKTlMyTGxMMURnTFR3VVp1eW9XK2Fja1N4Z2lxaE5QeE5ZZXNuYlhQOTFiRjdXVkRrVkRsK2hQeE1PeURnSlROVk40SVhTd1RINDB1a1lLc05ranhBQiswS3dYRk0rdkFBN2t3YjZRdUZJejNYRWdqWlJleER6V0hGNTdQeXR1M1I4WDVKMEpiMVlSazBiZmZHNXBQWnhLcFljMTBZR1V1Wlk5S204ejNVYUZPU3BlaUVwT040bDhDekZjeUkyeDRkdjdKKzBoRjhVUmhQcWN5ZlFtYjBSamVpZE9yMmhPSkl5UkdSQVo4ZEVQRFpCbVdJR3ZUUzlRR2dNbmJRaGd6R0wzVDJMM0ord2IyN0FkSjU1LzRCMlljencxazFraWtQOWdFczE0MEw1cEkrY04rU0YydnAxQ3VJTTZIdFA5LzNBUUt1OFJrcXF1czJaVy9YYU9vajVNNWZCcDBxUGJoMXNGc05yRjNTT2ZLZEtyM2FwaC9HRjdLOWFYTkNla1BESjllZjU2MXlIOU1nekdqc21yR3BZenlUUHBTY3VUT2tvd2JZZnNTSDl1aDQ3aDBNa09BbHd3ZXRXS0hsdTlUcE1HMUMwQmFkdFRSU3FSTUI3THN6ZW5TQ2dZd1czUmcvbzBORGphU1pEaU4wY0t4TW1wWG1yVGpZYW80M3ZhN3Y5WGhmZEVCTEg1VXVlM2xFNmJ2SzlYby81RjQ5TzVUNGN5M09JTWgxTlVnQmFTN1ZDRVg1YlpURFNzZlhZN3prTzcyakpKNmg2R21QdEtsVllXWUl0SUs0cGdiY1VoVXNOV3B0ZGVhcEFCMGo2elprTWxNMjZleEZvd1UwbEViK2pGczR5SFJ0QlFhZkgzZ0grWXJxVTdkcHJ3cER1UEZGQk4zUFErTWl2V3NsVTJ0Z241Q2ZsL1J6N3VGcG04NmQwejFPSFNWV0l1aDVGNDk3MGYxZm9rK2w1NzN6cTJObnVPLzFscmtnWDdxVEpCR1Qyek01dGtsT1VjL1BxVjlwTlNmS09kZm9yclU2ZlRZSWZGUjFMcTZaRDZBanpXSEZoQWY2VGdSK2Z0QzQ0RnR4SUhBOVNROW5zbDdrNTh2MktCeXowNFFnTGRKWHIrOHlhRkI1aURwVzkwMTJaWmJ1RWtIWGVvaWttNUJtNjFFMmJFOWxCdThVMWZzb2MwNFIrTWcxcEJSMUFmLzhPRWo3V0pVQnlQbWdPaHF6S2pWdFhzR0VUaFhPcDNjeUE0amxvaWZJQTlpQUxqL1h5a3NiMmVPY013QlZlcHJKRWVvTWNyL2ZDNHpaODg2dU1HbmQrY1dRUGVlZmxiSDAwdEdoUG9vOWlrR054RG52L0dIZ21VSkpYdE9BeUkyNzE5TkQ0aGJiNllVMm5EV2RCWGtYUUxNYSs4by9LMjVzNjF3ajd1MjFJWnZ4QytzYk1CemduZ1hTWGk5VllQRkFtNUxLeUJFWEMzSnhkYjZiUEZBZzBnWnBnemFSd2ZOOWFXOVhXNlBjVDFwYkEwMWFBSEwrMzlHNTdobXlDcHkzQlp1M2pNY0NLV2paN01hYXpWNnl0MDlLK0c1dGs0OVUxMGV2VFlCT1p1eWt6NkZuRHJ3WjdBeld2c0V1ems0ZklpRG9Zd0RmdE84M0FQN1Fidmt1Z085cXBxNlVtZ2FBNmE3WnRvdXowNGMxQjdXZFE4eEpmZ3JnYjlsUGx3RCtOb0QzRVF6V0M0U291TCswZXk4QVhMRy9jaTd2YUlmMTJFeld4ZG5wQXdUSDlNejY5Y2syanRhaGQ4czg2OGFpWVBjUVlSTisyMzYvQXZBREFDOWROdmhXV2JucUJPYzdPU2FaUzVhVGVRc0JiNVlBUGtUQXQxdG5TSHdKZHdzRjQ0dVB4TTBVUUx1TlN2amFDSm9hVnRSZ04wYzZBM05NQkhFeDg0VDlCTEpvdU9LWlNaVm5EeEJ3VVNORkdWMFRJNlNHK3JBTlVORGE0Ym5pMk1ZKzZ3VGlMUE5VcnFzUytoUmhEajZ1ekIzTEJsOWh5Mnk2OXVqNGw1R2NGUitya1JjcG82VFBlSEVnOTEyM3p2alQ1a0VCUUM1TVA3THZWM3kyTWo1bWo2TTB2dFpGaUVJQ0JzU29IUlZ3KzgzakU0MzNmTmNDd1VuYmw3azNRWXJ1WmltdGZmbWZlNUhmMVdHU09SdXREdzhSOEo0bG9PbThaRmJWQmdGZkx1MCtub1ZKSlp1Sy8wdWtxT3FIemZObm43aytFNWhONnFNRG8zQm9SZ0ptKzFFQVpodm5LQVNpR0Q0K3NER3l6QmxwVUNsVGtFWm9LdmFNaHB3aVpYa3p1NW40b2xIcmpHYWYyLzlYMXM1VEpFSDdkVlBJL210RGhqR2QzSDFuQnNmNUU1eXEwcUFTTGp2YXpERjVCZmRhN3AwVTZBS2R4emZpUkZFREM5QmplRlpuUUIvdEs3My9Oa0NlVmNBMWptbFNXcDlmSk96S0h5cHRzVXoydXBVc09NRngwZ1k2UzVuRnI3STZjZjBCQU5ENForM1J5RURqSk9DeUVBcDltaUR0MDFxQUVwQXJremVPYms2OW9tVHRNaUFWU1B4Y25ZOUx3ZDhPRDl3V2FJaHpNczZra1RKYUE0cjBHTU4reVFsR2ZRdEFyRjZpSlc2NXp6azJQYWYxb2pSbW9Xc2JWREozZS9wSW5qcEJ5QjVleWpxemRMYnl2amoyTm1VZngvN0IwWXBXS25YWVBaa2hHSWtPWGFKdVJOQ2dLVDBHUXR1QlBNdDJ1SDlLUnVKU1ZoVWgvaitFWSsxUkowSmY5NTllOTFCeUFPdEgxOUFiQW4yMnRqcGlhR3htMXZPc0pwUFVlSkxJWUp3L090cVZybFNyM1FqUDhKbTR0VW92MFhHTFBMaUE4aExwbkM4RDdnMVBXU1l2VWdsVXlrK2xqQmZLVEwzVkRYUnNndnU3eXZRKzQ0eDYyVmg5Q2tEdTFBZTJMNUc1TGYyNkxmVEk2NTlMQi9CZGpsL2JLdkFGMVRjSXVyN2VtZUJwN0ZSKzkwZGtEUFVyeWhtbFBsczduUXpnMHJqY2RYV0trRzdYeHIvelh2SmpjYnhobER5NksvNVJoa0R1b095VXJFZk96elc3dFZQcHc5bzlRSkxicjBwMHFUYUhDTG9nWmJ0bDgvelpWWnVxYVdYNmtqNG5Pb3JLaGp3K2cvUitiZnJQQkNtWVJ0ZFo4WGlCNUx6TmJObElnY1FyQVBQR3NxSUVaeGlRVEg2cXdRUjBZSGtIS1FNRzJYNTJISVpkUDVCKzE2cWIrU3poa2t5aTc0N1htanlMMHgrN29VY2k2RHM0VGlZeGVDQS9YNVg0dWR1anZiWTJ2K2J1SFgwVmhZbzg1aTdvbzZlTHlPbGdKb2Rwdndkc1ROR1dlWnUrYlFzaWowRDZNSlNOVFZ6WHluT2U1cXRUMzl0T1dGRnVBN056VlBvMkFXSjFwcXF0Z2JSK2hHeWcxUi84bUdMbHQ4OFRUNzlqL1Z6cFpqd0tSWFE4dGJkemp5dmQ2T1BuU3RmMnBZMUJuWGVJQmlDM3QyZjQxTWN6Ulk5VFhVUDVuanBFNzhyZTNnbjRITlBtYmVpUzRvandUVllESzlGUHJkaDRXWmwzM3JQRWdJMkZEVUpMK2lJbjFoMm9uVnZyWVhGMnlvZ3RSbnAvaWxBTzlCR0Nza1RuN01QRjJhbVdFSG1Lb0lpZEExZ3Z6azRYT3pxQnA0dXowNFA1NGNtMTlZZlJXR1N5ak5oYUk1enZlNE5nVlBpM0NCT29CMXF2RVJ6amEydUx3dGpFbDVrZWdpMHptOTlIY0VqL0JNQWZJOHpoenVEZXpmVStRQ3JidHdMd0ZZVE1PMllHZk1YKy9waDQwcE1kWG9XS3MxZ0pKQjFGVXdUSHdSNkFEeERXNU43S2ZuMEpDYnhRTklhdytYdkVjS29RaWJZUlRLVWZwWXhjR21PK2lyQlBQeDVwZ0I5eWVNVDNGL280cEhDcXNFVUhGaGtxbFFXZ2ZoYmNhQkNqbHA1VjJIRlEzU1VZSTkxdjgyeTNqckx1R05OajVFcGNLYXJzcGcwUm82b1ErWGQzak5mMi94WHlyQnUyR2MrWmFGMDJyMEFXYVdyR3QyalE1WFgzREFWY05ZTEdjNUZzanZ5NXZUU2FzdzhSVHoydVdULzlIR1dHR1BhOVRaSDA1RlYwQUFNcEsrL1QyaDYxL2k3a09hNlA4a0JWVkhWZVpnWGMxekxwRDVBcnpIUHBJNVY1R2dFbUNMdytsaVcxZHE5Yk84TkxnTWJmb25PQmdxUzF1ZCttYURjdEV3a0FyN2pmQzFORHhYdHFEb2tYcUpTV0ZFV2FTcE1xV0krUUJ3NG9QYUJSUnBVMFhxUGg0QlVreUtBd3pxbGMzN1lNREtOQ2l5VmFLMFlnRFE0Z0RxdGlvV3ZGYzFiOXZKRnZxUE9NU3VVRUJTTzk3MWViem92c2pJdlA5cXh0NTk2UndHalZ6UEhjcEdoTmRXWVBPaHJlRUF3YTFKSDJKNTBlNmlCVlE2aXVvY2MxOGdMU0VINjRCcFNoMlFZeldyM1RqRlVESGlEUWcxNjUyZWErRXdIZEp1Y3BqYTlhaVVCbGwrakVrV2VqNHhLNVlZKzBDemFXVFd0bjVGREI3T3ZyQ0pnQThVeHIwbzc5OXVqNDVhNUdBby9qaFgybEdUTU0wT2tvaFRiSHBPL001UEZPUUFXdEVsQjF5bFg0ZVpFV3RTR0xtK1g4R1RVZVpRK2hKVUNpc1F4STBqNzRmdXNad0FSV1pOZ2c4UzBHOWFneEZoQ2VJcmhBWHJOTjFzS2tSdGRRTUVEV29NZG9wKzEwQXVNcVJsamxsL3ArM3cvS0hDWG5yL2F0dE4rb0o4UDNTWDRuWGt6YmRENFc1VWthanZya1hvN2xRWHQwdkd5ZVA3dXUwV1BCcDdYK2I2Q1ZMeUxkSk83SzNHc1FxRG9PRmtqVlIwcEJKNlF6VzlHVE5nVklvTWJQSzgrb3cxZURRQ2pMZVB3QXVvNEt6OTlpTUZlUDNMMFQzR1ZicElFbE9lRHpaQ1RlQnB5aHRsYy9ML0VGQWU0eDNiOFRKQU16bjh2MmlnUHVhL0tYc2ZhNVRJK3o5anN5bE5EaTZyajRyUEFWTlJobjgrVnNEa1U5ZFJzZ0haQjlmWUNRdlZNTW1ycmx1emhHNmw4TWxJcUJlRzR2cXl4RWZoVmxWOTgyRWordkJVUUJ3cjhLOUNFNllrWGZ2WlkyOTN2NE9kZHRqU1IvcVh5aXVnUC81L3M1VHZMdU5TVEFUWndscW5QZGlOR2Q5MGQrTHM5cHVldzlkSGtqeDF6cU81OWJvc2ZSMmFSS05kUzdOQURiTzJ5VXR4TDNwbTZlSWcxM3RJSVErYXpjUzl2YnhOMVQ1T2Z5N2czcXh4WjUybHVTK1VidFB4M2pYZE50Sis4Uk5IT3lhQ09Vdm5YT1ZSMExiY0VoTnVKKzdZdXVPeUd6MzloemE0Y2pBTEl5czl5RHNWMjNSejNFREdRdjMrczExU21IMW0za3VxcXM2aXNVUko3U2lqTndTUFo4QXpDa24zTk5veTJ1eVpNdWRFNVZMdk5qNmF3dmtnNlFPVjk3Y0pVMkkvWXBIdFd5eXhoMTc4czd2YjdRb1EzeW5NOFFKditMKzdWTldiRjNaVytmeUhmYXQrNHRxTUJ3bGRYbFZEL1AxbGZXalhiV29mMjBiTk5ST29Ocm1DM0t0bWU1bHNDeWF4OEFlQWZCaWZ2Sy92OGFnbU54Q2VBL3RjNzlFVUoyN1F1RXFIeVdXVjBnbEZtT1J2QnRTMEpiOXZFN0NNSVNKMkpsYlYzYVBjd3dYUU5ZYlhFZUxjdGF2N2pyYzJtdDdjMzg4R1F0cGFwNUp2T3QzeVdadjF6N1h3SHdMWVF6blo4Z3JNVVN3TzhBK0RHc05DZkMrY2Q2eGdYdXFrL1dyejBFNXorek16NEc4T3EyK1BnbDlJTXpycEhRbE1vRjdkcjJCRDJDY09YK0RRSXVQTFdmWGplU0tmZ21nSDBSQXN5emZaUVprVjZvMG5FbkVjYXVIMCtRTWdjQjdCUkJuRGt2M1c4ZFozWmYreUljTW9xWHBlSlZBVklud2R2MlcyL3BmR05jVkJaTGhnSVZZR2hJNHhtcEY0Mkx5RVplcG9yTXRlUlU1TmhwQktmaUhETlBiUDVZT3ZlMUNGZjdTQXBnaktDVzM2SUJyamFuTWwrUThmbXNuUWZJZWVUcjV2bXpUL1g1d3RpSXQzU1MwTGl2U2pYTElXdW1DNVZlR3N0WnhXTm1ZK0ZadmFwVTBoaDBqY0MvSHlFNUlTNlF6amc1YityblF4SFhwNmljMzl1bVNGYjJFMGhSemN3dzhLVkU5VmtlODZBbHU0b1pSbTF5cGxMaFZhWHdBVkp3QW5nUGNpZmJVNlQxWkdhMHgrTmFkRGhMbG0xZDJxaXRaRC8yM004c0FBMDZvTEpIZXJCeTk5UElBWG5HTzZKOGxIa3NFWWVrcFBRYUQ2V2RDWFk0TTNFTUNNNVhuUTJ0aTZ4RW5pbTR4aTlHeWN4QUhCUTBLZ0VwNnp6aXNOMUxSWDdsbmk5RmZqUG9nd2FERmV6OFY2OWdPcHFsRWVQdjJtVkd1UDc4RG9mTzkzWEdKTDh4ay92S2NJclpKVHBQYS9sY055a1RZcWdrK2JaOTVMbS9EUERZK214VDhrcTNmaHdMY1pNOHBWcDVRL2FYS3BoVVJwbUp3K0JaR2s2ZkFFRGp6bmd1dEIyRHR3b0dJNldENUxzckJENURISGtsaGhMMlFUTXdWd2c4MS9NdU9oQkpaNERFOXk2YmxGM0VOYjl1MHBuQ2FoU2pnUnd5UnhNazQxYmZPWWRxVkVWaERyd0R0aE1oWDVHQlZFN0lIRUVxczdwbk1obmMwZVkrbXFWR2JpMHpxWWI3M3VqNzFsWHNxTnlqemlSdnFCNDZvM3lHZ0kvY3QxZW9aQm5hL1VWblo1dFhjcUh4MjkralFXMTB3a1NuYUtsZGV5NGErbmJoRVcwS2VobHJPS2Zja3AzempiVEhyZ3BqajNnTlZFdGVLczUwc3RySGptMWJBL2d1TU9ZZHVzY2NUUUx1SUt2a0xzREpQNFFPYnU3UXJtWlFqdUp2VGdmTHprN2RSVTY5RFhpYzAvK2Q4eUxTTVAzdER2WHpLWkpPb2Z4OEs5d3V5Umt5MzlSejZDem9OVXkzS1dPTyt4MUkraHhsR3ZMSlJSTmxMQUFBSUFCSlJFRlVOUUxQblFCNE9hQ2p6cEhUeHJYMFVla2c2ZmxhcmxIMlVuNnVkSk80dEJJK3BlMG83VmxMR3pjMkpvNlYxK21FcGl4RCtZWnJwQUYvbktOT3hwVG9Zb3BUVWE1Q1NteDRZdit6RXRVQmt2N01jV1JuRXB0ZVRiN0szNEY4emNnREtlTm9oUXpLNEhzbzgyZElPOHBYbFg5NzZNWGRWczZoSFpCL29teENPbHV6VTdobnEvdTZkdit1ZTFuNnlmR01wZyszb1NNNzhzdm9LRVJhVDUxbnRYMXBoVk5DU1ZiTXF0M0kvVnI1bzFmbWtQMEJXT1d2TVdQYUJrYktrTndYUU5nL2VuNzJCajNua3I4cGtIVlVlenYxYWRLK0t0N1g4S2EwbGc0Zml0bldRcnVCUEdGalU3SzkzUmI2OE43THVHMzM2SkpNOWtTcU1uY2Y5dllZME1OMzdtQnZML1pMMWdwd2dVY0RiZEdXeTcyOVFGNk5rUGJWRFlJOE1yaUc3ZEh4TENxaHpKQmRuSjFPdFZUdjR1ejBzVG5uQnNGbDJWS1JKNEc5UU1oZ1phYnRXd2hPeHZmdDNtOGdQL04xYWM2L3JRbUs5WU1JODQ3OXZiSjJOWlB3QXNEMS9QRGtaZ3ZuTDQzSUMrLzg5SE4zVzVnZm5xem5oeWRYODhPVDFSMDZtcU9DdzlmWXRWOEY4SFg3KzAzN2pSSE56TWFjSXhub3Q4MW1yb0t0RngwR3Z3WGdseEVDQnZiczk0bmQ4eVhjUGFpQUd3V0xNUVN2UFRxZWxBeFpEb3FaRXZZc1AvSGNTQk1nYUhoYklBalY5NUw1YXU4dDlsLzZ3dThMcEZKQ1FGNUNVck1WMW83SkhyVGhYTDFhSHc3YW8yT2VOVnVEQlpKdzBMbXZQVHJlRTZXdkJoMmpXSHQwdk44ZUhkT3BTRVkwR1BWazgwSEI1UXJwN01hcE1EaG1mYjJEcnJPb0EySWttNVhlMzZTSXNYMEVHa1NuRlptb0h6OUxWZEpodUc2NlpVOEF4RFA0NkNSZVFxby9WTmFGZUUvbkxqTm9ON0lXZXM3bHhONWJvMkhFbjdnSEMzTndqUkNjOHhFQ0g5V0FpRWNBM21tUGpoKzNSOGNQSEU1ekxkUnd2bWU0d0RuVi9yRUtnL0pRelY2bGtYV0JVTTc1RmRLWlIrY0lQRlVWVVo3Znp2bU54bnJEL1RpL05tWTZxNGlmVS9zK2tmbFRweXVGSHlyQTA5cGVzdll2a09hWmN6NjNkWXZQaWRBVmhXUmIxd2RJVG5ncVRjd1NqOWxIYmNvMnBBeWpFZEcxakJzRmxwM3Z3NXNpTk9HTW5zNzUyRVpuU20zUm1jL3hlMGRJeVhIQisra1kzZE94Q0gySW1WTHl1ODUvQnVRSjd2TEUvYjFUa0wzUU45ZmFad2E5Nkc5RGZIQm5xTXhKRGVhd0RGT2tmYUdPUFlJcWZ3VGlkd1kyUCtSOTF6RERrL3dXRlhEYlJ3Y3lqOWZJalU1cXFOb2EvRHhRZG1oVFNjRWlIN1M5ZVdYZnFSeHhUSnBkaytHbTdhVVlGVzgwOWttdGJ6YjJnMEkvMVNGSVBZVDAxUFBsUFUrUENsRFNqUTRRSE5zTTBMaHVuajliOUJsbFpKOVM3NklqYmc4aFFua21iYktzUDk5ZkJUVU1leG9uZEpDNkJZOEtZa25KU01kRkhxVEJtbXRHd3k3eExRYWxtdkdESHlEdHpTa0M3NmJ4azN5WGNxQTZ3ZFRSNFkxSlZYNHVjb3p1cnc2ZFY1b2ovN09OMktjK0hLQTg2QXdyZm05RnV1VHVVLzdQUHBZcU92alNscW9uK0xHWGFDQ2YzM2c2SnQrVmZrN2Q5LzJCT2RDZ0lnYjhkZmFmRzBQc3I4a1lXdjBpeWlnVlkxbk11SkRmby9PNlIzYWxITnFoWVVOZ09rVW5jTEU5T3A2WDV0ekpHWFI4YUFDcnRxTjRTdnE4VjJtMzF4Nno3Ymkydlg5THlBeXBKYUJSVk9aQVAvZkd6OGVDNkZKZUZpMzJyY0liYS9LTXltV2R6RkRxeHJwblZTYzI4STZETzRVKytpYzZhUEYvZE9XYlNlaysyLzhkbWNmOTNrZFBOZ2d5anEraTVNY3hhQ2RCbDZhU044YVN5azFQaFFNQjhrZktYcHlMUFpHVFNJOVltV1ZvTDFJblBGQ1pTR2dONVJqMkZ5aFVPeEQ4SWY5V204b0dvZnJVZ3pZUFVLRCtTWnFtdnhFL1ZYL1JNVkwrcFRQNGdYMDhyNC8wMlFIM205SlUyak4wM2lnN2NjMUtaVm9QRUNwVnFPNndjUi8ybVk1cGxUY29oOURSckFIUUh2Zmg1dFlIS2tWN0MvSzlFdWxtQldlajNORER6d0ZFK3JvVkhhM2dkaTl1N3NKSGFqTFRGbzRldFF0c3k4K0xqcUgyNkhoV2FVdjFaa0xOa2UvbEtOcWlodlJ6dGIxVzllMGVXcWIydjd1R3VFOEhiR2pzaDhyclFKTGo3d1ZHMG5jZzM5dCt6M3U4SytubjlLOWw0Tll5QzZvWGU1VHFGTHBPU2plcnN2MXRvYzBEalR2Z1pWeXpYM0YrMUo3cTlYTnZiKysxaGRzZUc3S25yZEZUUG5sQXJpS1U5amo1YlR5cWFDUS81end3QVpQMkN0cEg2WmQ3akhRczNaaUF2S2t1eHRRYWVRTGc4ZUxzOU4zRjJlbDdDQTdhcjQ1b0RPYXdaY2xubHAva0FCajUvcDU5Z0dESWZncmdONUhPTm9UZHEyZkdUaGRucC91THM5UFprSlBWbk5YdklESEtGd0JlbHh5cDg4T1QwV2YzU24vMkVETGFIaGY2c1ZWN0piQSs3aVJReXptNmZlMnY3VU9oN1FQNy9CREF6eEF5Ynk4QS9Dc0Fmd0xneit5M0tRSXVmQTBwTTNObk1LZnVWSUlHTGhDeWtMK0xzR1lMQUhQTDVHYTJ4cGN3QXJaZ1NFQVN4UGw5ZzFEaWEvRDVna0pZK3IxbUtGS24xeFRCQ2FORWRZbDBCbmV4L1BPUUFDb0ducUlnZ3kyVmZHR3NHbTFUVllKVitLLzBnUXBENmRtOU5wVEEyWmhUbHVXZ3MvTlYycERKTWdmd1NJelBOU0hCOTAwajBYcVZ3QjdCamtaM2pXVFZ6d2JBaTJhZ2hMY0lNZFgzMnowc3JjdTJxUXhwa0lCR3AzTnQ5bVFjZXhTQ25GQk01eVlkd0pweHVFYW9TbkV1Z2dvTjFQejRPYnBSWmJud08zRWdFMVpsZmZka1Q2aUIrdHp0TytJaWphRDdzbjg1Tnl3RkJpVEh0czhDNHB6Rjl0b1VmWG1KNE95OXNQbFIvT2Y4c0xRcTM2c09GalZtQVVnT1V5ZFFNVUNNWmJ0NFA1VjZDay9zUHgwcDZyQ09hMDJseWo1ME12Q2VQV25uYmY3bTFvU0srQlQ1R1pTd09lSDRiaHc5VXFPSUJoNU1ZVkhXUFlJZkRRMmI5dWo0TVlMUjRMWUdTUnBBSW0xd1NyQ3VhMllNUUpkT2VtTkRkTmpvVGVyb2NYdWdwTGlTSnU5QmpQN2lyS2htZGQwRm1NS3hzbkYwREg3Mk93T1MxRGlqU3R4OUFZL29LQUx4VG1nUmtKUkZyaDJQVmdFUWVkbmFHWG1YcUpUcGh6bC9Ld29MRlJKVkpKOGlWV2VZSWpsV1NFZEs0MURIY2NlaFpBclVPODZBUm1BSjRlSTZWUGdYbFNROSs0aFF3alVhOFdyR01jb1VwWDA5YTBQNXdiVTVaVW5mWW5hRXJRVXpyYmtQSHRqSDQyTVdMZDZtTEJQMnMrcklzV2RVTG9wNkZoSU5JTCtoZ1RqamcwMmx5c0lZa0wyOVJsSnE5UU9rN0prSjB2bXF5bVBWRWF4QkdXdHBleVgzVVNkbCs5elA2aWhXbXEzalhidm4vUG5YQ2lyRHJsRnhDbEtXQXdhejc3SUFTY2c4aWVGYjIvVHZJTjJNeG5MU0NwRk5QTzV2NUcvSGlTTGZNK2R5YVJ6V1o4b0tYbGFuODFXTmR5cXJzRzh6OTF6OEx2dUZhMDlaUTJVZ2ZVN1hrcktyR3ZXSll6V0RYSFFFdE9sYzNYWHovTmxRZFlvSndwck5ZRWRzOU53N0JwZ05VQXd1TmZweWlZVHpwTzJabk9wd1N2dGFOSER4L29JeHVRTkMwMHJ5dzUxbGJmVDFrLzBZdUs4RTJ3UmRiUVhPQUZ1RklmbXdvbE5PM0gxRjJrSzVxbS84K3QzNHhVem9GdmRSdFhxRjE4OEx2dy9wNXpVYU93Yjh1R3JqcEp4ZDYwUEhpV20vN1JrLzM1aE1wUHg4N2ZnNWRUSTZrMHZ5WlhhMGlQQno5bUVmMi9QekdaTHpWQVBYMVdFd1FRamsvV3hnUDBaY0tzd1ZlUUg1T1pCb3FsWjJJS2dUaEtDeUs1TVNtQlc5RVg2dXpqRDluNEhXZTBoQnhMUVArTXhKUHNOTTRYaGNqNU0vbzd5SHRBNjBLMitRanMvVDhXN1F6VGIwL0hUZlpGa2c4YTRZS0M3Z2o2T2FJamttVmdoOGhQeUxnZXQ4YnlmQUMwbFcwcjU0dXEvNnVRWStxc3lXT2FidEhnMmtBNUFGeVdkNmNZVXZaMDVuL2M3MmE4L3B2c0V0WWNzMkpqTHUyNzZiY2tzeFlNL3d5YThud1R2MDRuVzUxcUhGc3BicWZGT2U0VzJHNm5qeStLQ1o5SGNLWXZjRHdsZzdQS01KVldJWW9LeWc4dkdkQlhXNTl4K2dKMUNSdU50MGd5czlUWXkyR2NybFRqK25QbE1DOHZNU3YvZTJidXBMV3Q2ZTY4NkVsdG80dHVMbjhyM3EvTzBCMGtTMTVXcGZTMUI5aDhnVXhkK29ZNWtzSDZ0Yk9MN013UG85Ryt0K0JSOHp2VXhrQ2VVOXN4NStydkszenVGanBHQnA2c2Ewczh3UTVMR0xabVFKYjMwNUcvc3FnZ1Axc2YwUGJKR0JKdzVRTW1JaTlmc0lHYjV2eSswSGR2M1hBWHlJNEJCKzEvNy9DcEszbkpHOUQrMzVxakVNNll4aGx1dFVwYjhYUm1TWlRtME1qSFNicVJQNHJzdEIrNzROWlJkdjZ6ZzJCL2hMaERPUS93cWhKUGRmQVBoekFEK2RINTY4dE96b0Z3am5FRDhBOEdzSVdjS1BGMmVuRDhZNG5YdUFtMXFOcVo4QytCRlN5YXFueUtQMXZvUmg4TXdsQXljOHFZR0xDdDFhQ0dEdjgyTUVuOEk5RkVUVktiUjA5N0xNWkRRRVZoU1BpVDFYWWpBMGdIWG13bzA3NjJ2RmFFSGdkV2J2Y000NlFxZ3hrM01FR3BSbDRBbERxT0YxYlExcHRHZG15Z3hobnp4Q2NtNk5wVU9NRUk3S2wxdmJHUlYvSkdXakJHcW9JNE9jSU16Ukt6cjVoanBqVEt2SXVEaS85dmZTUHRjSWh1SkxoNjlxR0taUU14R2xhNE4wRG14SkViOUdYc3BYaFYwdE82S0NNdkdBUnNTU1VhMUdueW5RUklYVzN1bVZZaXFMM29CSXg0cWVkNlRHVnhyMDZVUmwxQmlyTHZCOWRIUlNPT1M3dmVPVkpUQnB4S01oWGVmMkNpRWpXTFBFZ1JEb01VY1FtQisyNmJ5S0I0SmZ1aThaK0tEQklxcHN6NUFVZUZoYkxGdk5NYko4TmJOYWRSM1VBS3daeHNxYmFKQ2dFZ1lrUEtWODh0amVoemFjTGF5QkhTdHBwK1lnVXVEWU5DczlBOW1iZlFLNXh4RWdHZk9vdE15QXVKWTBodWhuZzRCdis2YkVFRS81MGJueVdkUWRRN0x0cnh1RS9iVjB0TlliTy9qTVNnSmdSb0hOVDViQk1nU21vS214cC9PN1UzaHJDdm10d0F5RWI3ZXBjc1FLUU4rWlZLcklNUnVmdElNbDJTK1I3ekdnYTlqaTN1MkFyZHZTNXRObnAzTGV5TTlKSTdTc0ZPbkJTMWwzUDhjVFdOQ283U0V2NThmalVGeS9Oa2lCTzB1SGcrU1ZwYUFvT294WVRwaHJHTTk5VnI1bDkzK0dFQ3d4YTQrT0h3ay9MK0t1UUVscDNWaC9sYlp6UGRTcDNvdGJUY293SkkxUmVUbnl1RFk0a2grMUlXaHNENEVXZXdPQTlrME5COFNQUlpQS1FnK0JucCtkOVZka011TE9FaUV3NEJXQ1FYclJwclBKR1dSRFdzMiswSmhOUE00Q2pKQU13SFNFMFhnNkJUQVZlamUxZmhHWCtGa0xQMmQ3WTV4TDN0QmNBdUpMaVQ1NUk1ek9sMitUYTZzOEV0TFBvdHpjaXFHMTBEZWRBNzVqalp6L0VSaFJQeFdheSsrS1d5cVR4SDY3UG5OdFBOOWNXWnNIQUI2MktmTjFqcUFmYWlDWEdxYzdZNU85a3AxNWhzUmppV2Y3c3JkSlB5aHZVSzdTS2k5RG9IcHU4WWlUSVg3dWdQb0hlWFBIc2RTa1RQaExHTCsxWjdJc0VPTjdIWHd0N2ZFK09iN2lRQ3F1d1M3TzMyMzR2K3RQcnd6Z0F5c0t6OThLMmhTSXFBYjV2dnRWTDRrNFUvaGIyOXN6azlVeUo0MkhtdVBFalZ2M3A2NDlzNDJHY0ovMHFhUlREK2xFUlJxNmhVeW5kTHcyVnNvTnJONmhkSkg5SzVXWkhlTG5xcC92eVFjbzdIL1hKLzZtZGxmcWNNclBXZjJDMWE2VW41Y2NwcDdPTW9DV2RLUnZUcW5uWGZOZXpoVmxRM0hVVE56OVY3RHpkOXR1UVBORTd0Y0FOdFY3dFEvVVMvUklweW5DR21sbTdBWTV6ZU80V2ZuRnkrN3NoemU4cTg2NXRqWTVSdkltdFdQTllKVlRDdnlQY3JhdUE5dzdPRjRHTkZLZnBkUDhRTjZuejVJSFJubXg0RGpYTVpmNCtRVEdUK3d2QXc0bXFEZzVSOURJa3Z5NkVmeFJXYUYwYis4K1Y5dGdxUy84VFdsR0s5bmxIQi9iR1RrbUQ3WDNibU1iVjE1RjNTamJrN1RMSWc4c3A1ek9aQUhLSnBRM2dJUVhKZWRjbHZqQnZRemJXMjRjdW1kVkwrSXhIZHZvNTNTZ2FaSkRGY1NXVmRXeEdrdVVRWm9mYjl1K0szNitqNkJMY3k5MjdNZ09WRC8zVG1ESTh5V2NVYm9CRk1ZTnBMM085WEo3VmZtVXlpQzY5c1NuYTJtbnRKN2tqeVhuWldmL3lsNGFzcmNQMFpZTTcydDlaQ0NBeUZ5cUgzSGNwYlVxVlduYUlOa0JOR0ZFOTREWHp6cFE0T2ZjbTVuK1ovdmhZUnZzUHRUVlMvbzVlZEVlQXA4Z0wyQmx4bEhRUEgrMmpFYVIrZUhKTllBZk9TY2pHYzNCNHV4ME1zYkJLU1dTZjhlZS9UR0NnK0lWZ3ZPVWhsTm1KdkdzNEpuOGRvUGdaR1Ewd3MrUUZCNVZFRXR3am1UMHB5QTJwczhZYUJjSTg2RVIrcVZJdHZ1Q05jSlk3cndjcnEyOXprTm5NODRQVDI0V1o2Yy9RbGpEUzZSSWhQWGk3UFRsdG1mMUNpNXRGbWVubS9uaHlZWTR0amc3ZllVY3FTL3YwN24rTndGVWVCa1NZQXEvRjlldTFzNDJBaEtGRFB1N1pQL2FvK01OUXJXQnR4RDI3QXRSSmp2WkRUREJ2RDA2amxrVjRvQkR5VUV3cEp6eStUWmxGSzBRQ09yTStsUUNLamFrUTFIUUVrRW1lNitNVjVrUmpkbDBydmw5WFdXSTdkRXhrRWZKVWxFNGFKNC9lOUUzWmdkcldEYVdueXZwbzVaZVZFTWpCWTRySk1PYkd0cFhFQU5CNHlMVGFnSzdDdUk2WnRldmVKYU9Fd0wyYlc1b09LUkE3QVZoaGFLQnZXQUVJZTZWRkpXYWdEbHRqNDdWcUp5OTJ5bnJwWDNyRGVWVU11bTAxVEd5YjlkeWpjOFJpT2NVNUNsRVVCZ2szMlNHTzZUUG10SHREZGZNWkg5dHo5Rm96MzVSVU5RTWV1MFREWlU4WTRyenErZWFUS1F0YjhoUTRZZ0dqWWZ5N0FhNU04a2IvSWhUZXlaOFhTRmxuWEUrMUJsUEF3QUZjMzdvOUozSlBkZENaL2krR2VrWUVIR2VnUndUQkNQRmE3OW5DbEJWdUdpRU12eUx4bUlraFRHT3YwM0dkRFdFMEVHcjU5M3V0VWZITis0K0xVVkdlZkdtVFFFNXhhalVKcSttTURGYzVocjNudUU0WWw2QXRGYmtHMlBQNkYwaU9JZjZTdFp6THBVVzNHV0FHb1g2YVh0MFRJTlRGZlQzNXZtekc4TXpkYXJyMldLYWpVNGpsaW8wUThvNGd6Rm43ZEh4ZVpPaVpZSEF6N2xYTGhBY2VkemJ6T2JndWp5QUdMWnN2bldjSlRuM29rY21XU0k1ZjVreHYwVEtZSzJkVjd0Qm9GdWtnNlZqSG1KZlpDL0hCc1FncDQ1SzdoT0NqMkptZXh2aDU0cFR2SGFKdE45S2hpWTFtbTZRem5sbm55ZENYL2FrTFFMMUdPS0cvcTlCTnpTa3M5eDlweVN0M2J0V0daUjRKdkxwV3A3aHZGRVhKRC9pV0E2UTh5SnZ0T1c0RmFaS0kyZ29jUGZzSStCZXJZM29PSERYZGI5M0hBTnQ3dUFaa3NPOTRWWG5LOTVUa29mYW8rTlNlY1dvdXhYRzYzVjY5dGRmTDhsQjhSeHMrWGlqdk5JYUlQRit5bU14aTg3NFNZMmZlMk1IOXlPUUFpU1VUcWxCVW8yaGNmKzBSOGM4STNwUFpFTTFtRytNejNuREpvM1RmRGR4UWZsNUxEL05jVG04WjNEVmNvQ2Y4SDE5L0R5VHU1RWJ4REk3aE4zN0dMbWpnL3RCendBRnVuUTJrNVc1bDJSKytzcGNaNW50OWxQVjJiV3R3VjMyUWpIYnZPZVpYWXo2bzlvZkNkSFEyaDRkajlIUHN3QW4wUjJqdkdodCtYR3B2S3M0VXgyTDZPZFRkTStpMCtESUc2U3l0dnk5UnZ2VUR1SHB0WTZ6S2pQcHM2NXR6bVd0M0hLZjNsemNYNVV4Y2Q1WXdjdG4rTmY0K1ZybW5SKzFDeXo2MXQrTmRZWEEvNW1wQ2lSK1R2MWZhU21RNkNJTittcW5uTXI5N0JQWFBNNm45Qi9JK1RsNXBvN3BTcDVqbjVpSjUvbTV5aCt4ZmVUMG9zT1QycEJwSGUwSWhYV2tqTzlsMXhpc2phVExkWFIwNUhSVTVXUFNTUEp6TmE1SFo1dXRCL1ZlOW5zbTkrbTRtQlJGZm5XTnhGLzh2Znl1UjExTmtCS3pWRmZtV05oZlg5cWVRRmxjSFdPNkZwNkg2cjFUdDAvb3VPbllOdHc0OUIxK25UdnJMblRlcjVVNmV0bVhNYkpXQkdrMzBpVStxL2FrVW52T3hub3IvcUI3ckVrQldBb2JkKzlNcnBNUHI4VW1wUm5rT2o2MUVjRytMMld2Rkkvb2svRk5rZU5TTWZCSHhrTmVNUVRzN3o2U250c3JJOW42cUoyZ0JqY0krcVVHV0l6Vi8zdEIxb0ovTnhnNHcxVi9OMWxUSGE4Y3l3WmR1WWEvNmIxREFZZVJOaHZQV3N0KzhnRTIxMEpQK1g2T2d6b1M3VEhjWnhwTWs4RUFQNC8yTTdHM0szOWdWUVVQcEpGcTU0ekJ6U2pJQXM1T1R1QVlpYytsSXlQR3lMVlRkMjhzOVYraEdWTzVkd003TGxGMERtLy8wNkJVcmhscDhBb2hRWElPQytoSGZneEFyNnhkK3EwVFRjQ3l5UFpaenc5UHJ1ZUhKNi9SbzV3VTJud0s0RGNRc25oWmdnUklxY3RBaXFTbllQTzNFTTRCL2pVRUJ2Y0s2YXlzR1pKaDV0WDg4S1NQd0d3UUptZHQvWGhjR21kdHpBUDNMUkhPWUh4aDcza0NZSEtYNS81NnNNemZCd2lsbDk4WmV4N3pMaUJ6MEJGczdmZExBSCtLVlBxUzJTYWpJNTFLNS9seTN0MzgweWkwMkxVazlyOUxvRWEzWFovbHB4MFp1ZVlZV1IvRUxETzVSb1dBeE54biszaUNSWWRpTVpyWEt3VVU1UHkxd25NekJEckZFckQ3Q0VFcGowcnpZTWIyS1ZKVzRSd2hLK0VBRldIS25sc2owU1UwejU5ZDJiMlh5RXNOODM0cUZrV0Z0Z21SeXhRTzFraG5zaFpMY2VpY09NV2dUemxXNHhxUWhFK2VaY05TZ3FYekduckxvaUFaUkdyajY4UG5UR2lYKzd4eXkraGpHcmRWS0k3OWFBc1JhRzBlc2E3MGtHTmpsQy8zd0JwSlVGWmh1KzhzUndvVUdpR1l6WUc3bjlsTVZPSWV5bTkwb0hqYzNtdFNGUFRTbm5uSGJybENjaGh3WHRieU41WVZrUThGT1JWS0g5bVltYkVZalkxSTJUV2NRNVlpdkpZMitlNEZja1ZtS20xdTVKNmxQSHRwNHp0SEt2M0Z3QWlDQ2xKcVBBYnlVcUEzOHJ3NlAyNlFSL096YjFwcW5ObGt5K2I1czFmc296Zm1JYyt5ZmdyZ1NSdWN6c3pLMjBOd1FBN3h2RFVLZEtOd2p5cEJkQVF2a2M3N1hpTTVIQjhnbmNlcHgzZlFDY09BRmVLOGR4Z3k0MCt6OVRKZTN4NTF6bURSclA5WWZxY3ludUkrTXBwMklJcUZOMENxc2FJWG1oUUIzWGNQRlpHNGI3WXhRTFFwc3I0R0xHdk8vYllWMkJ4ZU55a2pZbzVBQjd5aXlyWTVIbWJmOXNtWUc2UkFCUyt2cVpMMHlQckN0cjNpcXRubXF6Wmx3WkxuWlE2UjFtWHhHbjArYUYya3I0MkJjait6QStjQTNwTDdGUTh1a1BialRKNTdoRngzeVdRS28yMWFYWWg0U3hybStmbU5qVzBtMXpieWwzSTA1MEdOaFBzQUhpdCsyNWhwM05VeXVqUW16SkFiRk5SSnAwb3NEWjBIZHY4Rmtud1A1T3ZzTXp2anZFQUNpZHp2MFhCUTJkZFU0UGs3OFY3M3JsWm1ZSnZhUG8wSHhETXRzVWlJTWd2eURQNFlWTlhtVWUwMFZuZ0RhelkrTjFieW1HSjFrUUxRb0tJWk1iMVFVT1M5TWIyUGRxb3hlRk9na1hvdmtNYXFlTXA1aG56bmZPcitCL0xnRXE2cEQ1elJFdDNLMDI3a2VlNExuVTllSXo5Ym9zdnZBTVNzQ3RJUFBoUDdLZXVrZUJiNzFEeC94djJRNGJEUmdGZ2xBd0cvNW0xZW5XZHNlY2cxaGcySjBja0xjY29oblNYRzV4OGdyL2JpMjZURFlkV0dxZ0RxcVBKem9NYkRJbjdxK0x4eGZGZWR0Q1NUQ3hUMW9ocnMwSWRWaFZaMVFQaFAzOTY5MVh4d1RsVS9yeG4wM0h0bUdEZFhwZC9KRy9qUjhwVGVXQnl6MDFSdjZYdXY1OE5LL3dyMFZmR1QvU2xtckxKdmVpOTF1VDZkVW1nTy82ZE1WelJNQ3orZnVqYjQ5d3BkbXJxVTljdU92Qko5MCtzbnlnT1ZuMC9rTi9KcS9XM1A3cWNNcVBpc2U3MlcrY3YxTGxWN29XMnVGTFJPZlpGMkd2OXVqZ25JcTV4dzdFQitsQkRYMmlmeXNBd25kZTlNN2tIU1o5Zys1Vk1OVHVaOVdobHE0dDRSQTRLY1hLd1ZrblJ1TkF0NWpqellXcDBuRVVlRnZ5aHY1VHUwVDhxM2xOY3FiOXlndTU5VjcrUTk2cFJSZVl2L2V6dVdseEdVRDNsNUwzdTM2QUQ2akxhWjdaTUNQeW45UHNhMjUyVWV0aG5uc1dCM2k3VExmN0FGaUt6VUIzNjk0M3cwNllpT0RYSytxN1lSUGhPUDlFQk9QNmdmS0oxWUM1Mlp1clpKaDFSSFVWeGd1ZnVTamJNeno2N05rbjRlWlQ0Z0w3OWVBNXVUWHJ1SDZ6TVE2TzRZcDdUMnRWWUpTK25FRkNOMC93S09jUXlVZldzMm4yalhiRksxcXQ0cUxDanZVZjhkU0hLZXo5SWx4Q3h3K1YzWHQyaGJkdjlubFNMc3VsYkRvTjdLQ29DZDlXK1N2VjJyL1BEb0dPVjlIVkE4YlpMZllBVVVzMzFWM3l1MTVmRm5BNk50TnI3TzhWV09ueXZOaTJzby9kRDlyQUg3NUZuN2RqL3QvQndiMng2eWNSWHAyR2pIM2Z6d1pEMm1EREhDUXYwU1FzbGdJSnozKzVzSUdjRy9EK0NiQ0FQOEZNQlBFYzZjZlF6ZzJ3RCtJWUp4K2hKQmdIcUJVQnI2SllEVi9QQmtPY0pKeTgzNUxnYk9xaDA1SHQvK0RZSnorcWZXcjN0elRpN09UdmNCL0FxQS93akFIeUtVNS83YWlGTFZ0NElCWnpnZDhoZnlHWjM5WW0yUHVmOFN3Zms3RkRuOU54cElTTFlWUUc3eFBtL1lyZDJUUmE2SkFKYVZlbkxHSE1qMUZTenoxMzd2UGJmWUM0Sm00Tk96OFVyejQ5c3JSZmV0RVRLQUZnZzBoNWxMRzZReUg3NmRhd1Q2QlFSNnhYTmdzbmxyeXdmT1o0WXNZN0NYaGI0VCtvenhsOWJmMS9aM3IwMW5vc0hObHpJaHIyU1MrZmwxWTluT05ZSmphSTdrcU0raWplUzdabGd3cXFrRFpMamJHa1JxU3J4ZFYyY1NoYk5sazhyQzNEaEJnUE5maTV5S2lwSUlZRFNXUDBTSzJLS0FYVE4rUmlqczQ3amZCdmE0VnpSVnFWVmp6WjdjNncwSlQ1RktGci9ET1VHcXRFRW5xSGZPY2x3cWJFUURBYnBHMVZqdVRPYVZBaE1WUVJwUCtUNWVZOG5DRGV6TVpWNDNBK2ZhbEpCRkUwcC8rMmhBOXBmQ0lnVk40cU1hT2RYUnBrcXFHbllaNExCQW5nbWtpdGxWOC94WmRqNTBrOG9pWldCNFNpTUJRYVBrKzR6NHBDbHEyUEMvVDlwMDFpaU5WRm82bGVkU0t6NnA4WndsNnhmc0w2VDhYSzFmTUFlWThBUitQRjNQak9KaTNCeVRKWlVaOUZvclM0MjBuaDBlMHFTeXpnekdHQzN6RGtERWxiSEdZZ002KzR0bk53S0E0Y2VyNXZtemw1NHVWWGhLSHlnOVlCczg2Mll0OTlDaFFDZitnYzN2RS90d3ZXNFFjTVFiQXBieWwwb0wrZk1FeU02Wkl0MWRDVDFuTlpBOSs1OVZEblJQbDhiTnRqbEdCcGlRbC9Oc2F6cEc1dWdxdnhjSS9IeUYvTHhsenhleTg2OE1aaEJERXVXYUhyNVdQTDVHK2tGNnhNaDk0a3BVRE51VXNVOUhqenFCMWRHdS9KdzBYaFZaNVJjeHNycEpwV016aDZIOWZRaEhkMFRHQXdweVFXMHVTQXZ0czVacnhCVWVhNkE4VmMrZloxQWcrWVlhWUcrYVhNWlFSeWF6NmxXMlVvUHNScDdSZC9NKzc0aFUrVW96TmFyQU9SRjV0Q2gzcTd4YU1ueENaQS8yVzNBeE9waWxiWlVKaS93RFNaN2dlQ1B0THhoT2VDOE5lVndMeURWV3pDRmVrYTlTOWxvS0hxaXh5UnUyL1YvaW5mS05rak5jalhZYWpFbEhCb0h6dXpJY3VaYTVMQm9SUmU1azhJRzJvM05VQk9QWE5QRFUrUGxVMTlZNXhWajJVSUh5Q25VYUg1QkMydEtuTzJYT1BMbkhCM1RWREdaYkJ5UVhqUGlsSTFwaWYrNlFsMmR5NnBiOXBqeGQxZE1vaTVYd1oxdTl2dTkrNGVlY3R4aEFKbzRNYitBblg4bGtRcUViL092bHZ5RWJnVHJvZ0xMc1dNVDNnbDZwQnVvc0dMbGlHMUhETUhXZ0VtMHQyUnk4L1dLTklOOFhkVTVVMXQxKzQvNWphVVllUTdRUGtZZXMveHFnUWo3Q3Z1dFkyTDd5T2lEWDBUSTlRdlJmdHFGek1rZWRuMGNqdDg1SFRWODJlbjdSaE9EMkVqK1A1eVFqNFpXZTBjdGdGdEpUUUhoS1U3QVpXUHZxU1BIT1VzNkg2Z0ZzVi9rRDU0aHJUM3FzenZVWUFNZDNDajFXNS90YS9xb1RnUE8vMGQvYWxDV216bGVPaVRxcTZzb3FpL0N2ZHdhclBxNzdaNFl1UDQ4OFZ2aGQ3RXVUZEZxVkpmYVJPOTQzSXM4VFI1U21xTk9hVUtKbDhaNEJPdHl4UFZWb0kvdm1aYU5NSDFGd1BHOXIrbHloSzludnFuK3BYRmZaVzV2Q2gydFNtNlBPL1pTMzNIMDhiOXhuL2tld3ZxNUsvTXU5YjRaRWsyZmlTSTNCNEY1M2JWSTU5YnZXejZOdGJLRGZIbGg2dlhOT082RUordmtWUWtXcWJEN2I0V0JtY1QzRkFBQWdBRWxFUVZRd0QwWGVaTytKZGp4ck13YXVrdTk1ZTREc1c0OUhQcmdsMnEvVUZxUHQ2TmdvbzhyWVJ2RnpkUFdhTE5nVGVYSUljY2EzZllPZ0c1UHUwTGFZamJFeTk2V0FrajcvVTU4UGdrSHJNZURWOEhzZlNNbGZiUXFJVnAyY2RGZDVoZGZQYWMrbkRaMTZnU2JSWkxRWmlZK1J2OVhrRVMvUGg4bmhsN0Vsbm9kZ2NYYjZiUVJuNVRkc01OOUhjUHErNTI1OUNlQjdDSm5BN3lOa0RPOGpPSTcvMks2Zkl6aGJOd0RXMi9SdmNYYjZGc0ptZm1XWnEvY0tQQXYzcnJKVnpmbmJBUGk3U0l2NmorMzdad2lPc3dXQ1kzem5kZHRsM1JkbnAxOURRTmJYU0lMTVZ1c3pwbC9BL1o2ci9FV0ExcFhXMi9MWkNVSXd4cng1L3V5dnQzaG1wMGpsTmtXS0F5NWEzcmZicHJKeU5GNHllNjdYV0NMUGs2Z3U5VnBCd05IbjZaeGlGRkFXOWVQNk5rR0tvSzhhZE0wWm84NnlLVkprVUdZTWJFSzVqVTRmMjFRR2MrT3VUeENNeTRNQkU2Wll2bytnSUx5R1UxcGx2alhpOWJyMDNrTGI2ckM0YnNLNXhxWDdwa2hHYVRJd092cXBxUFc5SnpOMjdvS0Q5aXdGenI1c3dyRnRxUkxGckE0NlM2SWhzMDNSWG1vd2laa1dqU3VqaDl5Z29zSlpWSTVMK09MblJmWUIreGtGOWNKK2VZSVFHRFZGRUY0L0xJelZsN2VCalA5YWZwdlkvdzhRQXJqVWFjemZMNW9VSWFmR3kyaGtydTFCNlRQNGJNLzZjSjdwNVBVUnJtcGdWd2NWdjJzR084ZkE5U2lkNzgzeTBCVHdYbzNabzY3ZjNDdHE2TjRnN051aXdpS09IeURoVmNtb1NPVitMV3ZLdWVnWXMreWVoOWFlTCtsR25OWnlhTVJYRmZpVkRuTWRDRGZXbHdPNUhyTXJ4KzV6NHJNWXpOaU9LcTZkUFMvMGdIMzVoY2tVYmNqMm5say90anJPdzhieE5zSisrTG43VFNPOUlmTTBSNkJSVis3ZUdDR3IvRWZvSFlOK21OMi9JTjJYK1Y5Skd6UWs3c1BLT3lQcy80dWU4Y3lRY0duZjNuY2o3MkVacjA3VXJsT3lidXgzTGVVNkVicE1ZeDc3VlN5dmJzOCtScDZWUGtPaTM5RXhiTzlidFk1M3k5eDBNc2xGL3JqeFl5bU03VEZTaFljTmdNK1VyaU5WTnRySVBkY1EvQy94VUh2MkNSS2ZBa0lWaFpLQm5BNXpkY0pOa0k1Z1VId0FrbEdSeDNFd0d5aXVoMy9IRU5pY3ZXWHY1bG1tVlY1UW0xZG51Q0IrTTRwY25ZVks3M1ZQcWRGOGc2NFNyOVVnTktCbVYwZFlOSnlVWkNJMUdoSjZjRHByejZEWUw3ZVdSUnJ2K0xrR0hhanNXK0xuZzA1Umh6Y3hzQWRkaHpEN3BzRWRRRnFYRy9sZkRmdWRqQTJqcTF4allBY2U0WGlTUWxVR2xXZUlONnVTakZ6UVQ2S3pwOFpEekdDWEdYeWRMTnN4bE5uZmFNeVg1MVRHM0RnNnBHdTZzNnl0WTVSMmlVK2VuMmNHODEzZmVSZGdQQ0dUdTdkNHRqb08zV09GNjNEck9vWFExeG9kZExMZ3lxMXhpUWVwVXduWVFwOVNYQk4rVkJ4VDZSbC9Ydzh0QjNxeXNQdzdDKzBvblMzcVd6RDl3dk12em1lQno1ZjQ3Z0VDendiTW9PM2VRenlDOUVrcll4UkJaUGNvKzZIaXNMWjNVSWJSdlV2NTZrTGFCSEorVHRtRk9oTnhxQ05yOU9udUlvK3hEemVVRjByNFY5TjlIUTV3dmpScm1OY1k1S3lsc0ZjMkQzd2ZuUkZxdi9MQllVQ1NmOWpHRWtLREZSOWsvNmk5UmZ2RHZsUFBwNDdDZ0xlTXRqdDVWL3Vqam1jTmxxTXVPNU43NGp2dC9oSS96K2l3MTMzZEdrWDVhT1NlOXZJcTVQdlUvZS92bWJqZjR4eFVaTno0eks0OFF1MFB2RFlrRndoTllkOXFNcG5uNTcxOTVWd1g2RDduVkcyTk9qOEVyNS9ySEMwRkI3WHZ5NzY5ekw3cm5pUU5SY0pUdFJYUUpuZnQyaUR0VytNTzlmT2h2bGVlZVNUOTdpM1hYM2cyNmhNRkhxS0JIeXJuN01IWlJndjRVYlFCdHNsT1BTbTBrZUdMOVUxbGFOcVBxalpaV1UrbFpWR3Y3ZVBuTW1iYTJYekEwMFRhVmprZnFNZ1ozdTZnZXBMUU1jRFpRQ295VkkxdWpEcGV4T2IzQUluUFhMazE4Z0ZkRE5nYVkyL25zVlhjbTBVYml1M1h0NUIwZWZJVzJrT0tjNmgwSnpLNTJ6cmFMQ3YxSVVJbTcxY1JCdjhXZ0w5VGVlUXRoSXpnbHdnT2dvOFFKdWhqKzEwai9YWnhMbDRDT04vMmJOcGQ0UzdMRkMvT1RoOGp6TTN2dTUvMkVKeStqKzF6anBBaDNhdDQwRGtOWVdReW56TlV6bFBwQVJxaUdiMDNtSm05cmFQNTMzWEhMK0dXQ3U0VUlSQ2plbDVPaVJodHlmUmlHMFp3MVhCVEV4eEp1TmROT3JNUTZCcXBTdTg3UUc2ODFINnZsVGw2QlJmQlNCVFBRREVDcW1lU2NSdytrcWZhcnlZM3JLdnhYQlduZmRqNWhBVkZmNGEwbDByNzJCdDlhdWVQTEJGb2FYUTh0dUZjbWhqdDJLYXlKbXBrRzROZnNVeHdqUm54UGUzUk1Tc0VxTkhvQUtIY1hPL1pucENJMjVwUU1SSTNOUXR4TkF5MHI2WHhvaEpYTUZoUm9lTllOa0RNVmxERlZNdnpxQk9MdUVqbndyVE56NnZnLzNyV0ZQRTBSb214YjY3L0U0VEFvUW5DT2ExK3ZHcUFZUDhZaVh3ajcxVEI4Z1loSUluT0ZScURad2hSbENVaDA1OFBSdkQ3alBQVk1SQTQ0RHRWOGVHYzZudG9wT2JhMEFtZ2h1U1plMzRDNUtWYklXVjdrTytsMFdCenFTVzdhUXpwdzFtdkpOZmU2Yy8zNHh6VStMdzZObnc3bk1OU3hwejJ4VHYwQ0xybkZWL2pQVzA0LzJkd3I4cGU0M3IvLyt5OVNZOXRTM1llOXAwbW05dTl0bDYxckVhVUNGcVNhY0kyYmRNR3RHRnJZdGdlR0RBQkR6eTdnUDlBd2diU3M0dWMrY0tEQzNqa2dZRWNhRVI0NEprQlFRQnBieG1VQklPMFJNS2t4Q29WcTFpc3Z0NnJkN3ZNazgwNXg0TllYOFFYYTBmRTNpY3o3NnRYNEZ0QUlqUFAyVHQyUk95STFYeXJDWFUyVmU4M1E1YUcxcWdCZjB1WjI2VHUyZE9WQUJTN0V2VS9Iem5PZFIvTGR2ZnBmQ3l1YlgwL2tOOHE3eGpKU2dPUForL3NJMlVWTWRnaXZqTXhSQyt0ZjVkSVp3aGxjcGpVcHpMaDk1Qm5xS2tNMU16emcvN28rRnplalFZWVVaN2ZRM0srellSWFhUaGVHV1cwa28zbmxmUlJnM2pRUFh0NmFYTjBDT0RTK0xBZkcrZkxaeVlDU2VlaHNVcm5zYStPc2pVNXlnb1RjNFJqSnZqK3JoR0NheDlpQ1BSRU9kWUF4bGpOd0o5cjU0bjZQUU9meUFQNWJnKzZrTzBUK1d0L0ZNdE1LYWdEaFBjekNGNnFBYnp5LzZZL09uNk5GQ3lqWThuMEtjY2ZaZ2daQll5RzV4clhhZ2dlTEMyQ2NzaUJZdTRwTFhHL1JxNVBxU3dmQUtrRlhiajIzSXpjKzlTOXIzMnNVZlo5alE4cUNDejNSU2UzeVhPLzV1bUE4Wjk3dmh4bGI4djJrT2Zyc3dkUjgwZzhiNHVRa2NFTUorMEwzNU9YNS9ydVZXWmxUcUdwWlAzMlo1R055WkVCSUZlNVRyUFdTRlY1M3BDSDFNdXZ1M1FXM2FKd2JXbXRzazN0bzVmakExdHZDdm43YkM2QmltMGlhK1FYamhHWVRMaXBQQjhMN2wyWWJaenRlMmVma2pJK3FOOFg1blhBWXlwN2NRTmtKVU9iNVBRUllLaFRhcitXeUowUzFLTzlnNk5WcnRIYlZBTXE3RUcxOHptMkpSSlA4dGZINzFIZW42cUxqZG5uVnhBSFk1L09FS2M5NlV1MmsxZU4yYjBzT1F3MG5CYTJWaG5NeVhjYTU3MC9PdDd2ekRsRGZpN3luSUhkMm1kdGUydllqT3FGTlhtdWpzbG9QNXMrb0hKWUE0eTJDUHNoQnQ5Wm14cjhESm03V0drQ1EzbXYvSjd5L0tEUUJuR1BmZmM1KzNOZy9WYmVQZWM4SU9rSlcvZkQrZEpnS2ZhSDltajIzdVU2amtjREZHZklqMUlBY29kdXhOdVFiR0RPNTBDSDFXY2lKNy9QWWpCOFh6bG4zZlhiNnkrY1U2OW4rV2ZDWFZ2VWVRdjMzbFkrMU9haFNBWGRyWVZYRkhsam85MmFQT2ZjK3JMcEdhWnA3U2gvemZwWnNDVzFKSDlUWDVTL2xaL3lPY1JiQi9pVUVQcyt4VGsyMlQ3ZlZROHhPa2NLZk5uMS9pV0UveGJtTkFaTTlPbDhXdTdkNnRpY3ZGT1pSbjAzdm1mS1RBeURrb0hrNkkvOHJDWmJoQ2N6VUVadElOTFdyZ0dHdWd4MTg2aDNtKzJjOFFGN05zZFAzdGV5Znk3MWZ4bXZKandVZzhoa1hMUkxTKyszYXBzNUlpL2wvQytkYk9LNkozRlBYRTZRNXhFL2Fkbm5wc00vUjhKOUtOZUp0dzl3TlZrVGN3Q3pteXF1QTFxZG5uQlJQUUR3R3dCK2U0ZmJyd0g4UXdEZlJYZ0Jsd2laclRjQzR1eWMzRG1BcTE5V1IrTHE5T1R2SXN3akhVTmZBZkM3Q09ETklWSXB1NThpalBPbWMzV1RET0JIU01yVitqYlAvNHplSEJrRCt4eUFMM1hQbnY3eHhPdHZLamhiYmZwSVRnVWl2SkkvUlFrZ3J5azZEaXJQakk0ZWI2Q0k4UWtnTUZiN25pRHpIQk9qd2NRZ29UQWtlSHFCZWtUN0lMcXZNcVlZa2R1NFpnOUJBR2hXQzBzcWNkNmpjNit6OHRPbE9mTnRLemczY1M0MEduTGVOU0xrYTg5dmdhZUZaekVxK1NZS2UxUUtDa29ENTR6dklKYW9NcVdENzVqMzBmaFRSNms2ejJpRUs3Q25ZT2NjQ2R6YmsydlVjSTFPVmlSSENTTzVDZTdOdXhCZ1FVY0xIYnBVdUsrN2VzYm5Ga0dXYTNtdEZmZXJqSXRHTHJQMTJMZjQ5eFNGdmJKbkZZek4zbTBKSEpMOXlzK1l2VWc1UldYMDBNMGx6d0NtY1owWjVpVW5oVDJMNTRDdlZGRWpzTnJ0bU9FNVJuMXlyTEEwVjBtNUJmSTFvOEFHZWRCTTM3dmU2NHdHcmdjQ1RCRzBjVjBqTUR6dmtrTjJBSWIxS2JxV3hESnFPd1dnS1hnL2dSOFVnMDVLZk93bVBPU1RKT016OXhFeU5pOUZEaklpVnN2TThkMHZFSnlGUUNINzFMVmZtNU45SktjQno2TFJMRERxb3VmV0Q1WXVtaU5ValBDWkRBb2tNcXQ1aVZDRytiS3dydW44dXhTK3c0eS9LL25NWnhUVENHUmZXYjUvenI2V1p6cnJxNTRoQnlSSDVDVVNNT3d6ZXJNTWE5K204SThzb3Jwd0RmazI5enlmd1ZMT0QrUTJ5dnVWeVNTQ0xvUDV0R2NNZ0dieXZNYjZJQStnZlhYVzBFV0sraGFHL0hXZ1MvU3BXc1VTcVZRdmVZdzM4SDB3aElMYjVQMWI1Sm5SKzNMTkhLbDZoVHJuSWQrdjVYbGJhWU15bldlaks3OHZCYUdWd0V6WUhHaWtQZlErTDR1Y3ZxekJZRTI5ekwvemxxNkhYQmVoVGpDRHl4eHNrUWUwUk8vWHRqS1F5dTBqZmRkQUxzdVV0bktkbHMvTXh0bVM1L1kzczdXeXNzcHZXSjdUUWRDUzUvRWFKQjBlU0ZsclZadWcwQjR6MU1oL1NGdjV2ZUdhbXFCdkRaeVFiMEoyVHBINWhYdWFOczB2bXZ5YytqSEsrMWNkR01pRElXNVNHYXpvV0pYdlM3cGc1RXNUN1BQbXU1SjFveUIxMHdhV3VmQWdablJDVGJSSlBlWVpzUWpVN1hNUHZOZmE1UmdHbWNKTzVoTUlKN0dzcEFMZzBYWlhqS0ttSzlma2VhMi9kbzhHYWhQanFNMC9aYWJxWU9yc0liNHdzUGY2VkxtSXVJaVdBZVc4c2M5WGNvL3lLT1ZQNUpkZW52TjdkWHhkSWRtQjZzUmdYMmlyMzVjMnFHZlFHWFFvOTVka090OFg3VWM2TmZZTDkvRTdkZHhxNW1VMkJzVk0raFM4eHVmb3M2bkhiREdVZVJwa0JDUTdqcytZTE0rUjh5dmlIdGxhbGVkV0szclo3OHdSNm1XTlhaUHhIYStmanVpckE1NmhmYmxydVZDemUzMWYrN3l5akk1VjMvdlkzdlgydWVwV3FsdEc1eDh3eUxvc2xmbmxQVkYzM21XZWhDY0REZXhIMW5KUm42eXNud3czbnRxblQ0cjZFSUM4N2xKRmdKcDl6cjJvUnk5dGtmaG5kVDFYZEVTMXFUSlpKVHJtRE1rQnJOV01paFZXM0Y2a1hMcXNyT3VTUEk4WVZHVmZSN3kwUzhFOGlyTVc3ZGJLczRHY3B3QTVmeXZxMVJQMzJGaTFJdG9NeXI4Wk9FMTdSZm0wVmtXY04rVDV3RGM3VWUvaXMyYmRPTjRlaE90ZGxIOCtmUHlFeHRIbDZ2VGtueU9jK2Z2V3hOdS9BK0I3a0RQSWJ0a2ZLaVBMMWVuSmFIYnFwNVQrRllDUEVFcGd6d0g4S29EbjVtZzlONGY3K3dqZzJYTUVVQ2lTbm0wOE12N0Y2dlRrYmJ2L2JNeVJhKzNlUXpyYkpJTG1PNDJ1MHZZdjZidjZWSkl4bXA4aHJDTUFiWVhwVFFoVmE3TUVza2RoWVVLbGFWeHAzd3o4OW9vZ1Flb1lBZW1hMmVnenBXK2NweTJBTHdBNDY0K09uOXQzV3NkLzFvZXNITUFKTzljSEJtZThnTlRuNzFLSmxiMCtST1lvNDQvT0tMc0dGY0ZRZW1ZRXAyd2NOQ1puRUtlY0dwRVE4TlBOWS9YOWkrTEtzeGxISFRkT1dXZ2FHWDZkMkRQMkViSkkvZmx3SlZMZ2R4SlFaMk1DMHZ1c3JjRUlJRHNqZnRZZkhaOGpSZFg2VEExbXpXbUVzR2FMc0w5NkRSVWpHdGJxZkNzWm9CVHlGUHlxWUcxRWthRGhyV2N1K2ZGU21lSFpISmNJUnV6Uy9uNWc3VzM3bzJPV1JlZitpR0FrMHZ5cndqY2dYWHVsOSsvbnh1M2RUWitpMHlOdzA2ZXMydmc1OGpYQkVzcTY1blZ0YVRZazRMSnNsR2YxSVROdFQ5ck9RS2tDaitJN1ZPT2Y3M3JVVVc1dFhaUytrK2ZxMlZaOE4wQUNNbmc5enlMT3hpVktMUjBmV1prd2FVL2ZGOEVVZlplRC9kNmxFbk5aYWFES2VGcHlhb3F1UVQ1WFd1ZEEyci9LeDBwcjhGTkRYUWptV0FHNEwrczhPbFBGa09ZYXZvUUJXemJHTWI2b0FCaEp3WURvK0JVaUw5U2dqMnZVamZRRmdsM3czUHA3MVI4ZGY0VGtUT1g2ZUJ1aHdvMlcydmZSeDltZWtmRnYreENOKzhqYTU5cFV3UE9oOFc3eWg2enNsTzJEKzBpT1NKNk56WEpXMTMxd1F0K1g3MGkwUHlJSTBFbG1qUURxZ3pLY05wZkxQbVE3WHh1UFlTWUtuZDVjcDlISWxiOEhEcGtTZFNrU1BCck0vVWdtZnBmT0JpN3lJSGR0eWZoa2h2YWV5ZlJpLzdvVVZMV0JIZU1EeFBQMm1MVkkyY2g3dGtqdkhVaEFLK0F5SVpEbTZ3TEpvVTE1R1VGVWR6MkFsRldPeEx2aTNrQmF3L3pjQThWS0dmZ3BhNkxGZjFSbWJURUN6aFVBVUIxWGxnVmJlTy9rOVF4MllKOG4yM21GdmluUVA1Q3JCWG11NzFPSjhvWi9aNkNuYTV2enk0ejNZcllUNyt0ZFJwVFlLd09aSlBQSE9kV2pYMFlkYy9aOTdiZ0h5bUU5STgxWEhlRWFXdGgrYW9GSjdCT3ZvYTVhNGgwbDhHbndIankvZk1PZ3JJSm9nK2RNQmZVK1RVUjdvZzlWTXBSWEFmbWU1QnFPY3FXbVl5azE1bVNuc3ZRVjNUeDdqdGZOQzlkb1NYTHlMcytUeCt4UERiZ0JrbzQvZzluVi9Md0JWR3RBUy93UllQekEyK2RpOTdVYzFRTWIwdG5ibDJLZjBGNk13YXFDUWFpKzdwOHhKcy8xcUJOTWtPZTBDVWRMbDVjd0Z3RHYyTDE3Q01kcUZQVkw2eHZmTDIxRmRWaG84QTZKLzFObUFEbWZWN25KNjlrWGRZNXBPeDRiMHJMTEd0QjNqYUIzK094ZHJTcEZVaG1nTXIxa0ozblMvYTFqWk1DMXZ5OW1qeVBQNUNWZmpPdEozcjA2QmJoL3RBVDFiZVI1NW1qM2EwMTBYYlhQQjdJRnVjT2EvUzN5RTJlbk52azluMS9BekVwOUdIeXV6NXJDTDFzODJlbDNiTXZyRC94KzFqZXlidnM4a0c0dCs0aHJZUkFNVXVqblFGZm9oc0VYclJMV1JSN2JqV0M1UXNxclNuUEc2bmRxSS9sNStsUlI5K3pwZVg5MGZOL3NxdGZJTWFoQmtKN1pwVXVrdVJ3TmhCOWJpNFYzb3Z1SnNvYlZHR3Q2RkRGcXZ2OExXVitxbTZyOTdlVjVDVzlYMmJpRkpTcEpYNVJYSFppc2pQeXRzSSsxSkw2ZXphdlp3UXRiUXhrUDRWNnY4WkhHNTlIQlR2MWQ5RElHT1drMUJwVlAvdDFVQTY2dGo5SDNZUGMyOFp1SnVGaHNId2dPVXU5Qkh5WExzTVhoNHllREJXdmZQVUFvTlRubUFQNGh3bm0vMzBRWTRFTzdyL2JjU1E1Q2MyS09naFIzUVRaLytwS0w1YUJ2VUFMNUdtRitTUDljMitLZnNJT2l6ZEZkWXFReks4OGR6d3EyLzdmV3p3OFF6bC8rUG9BZnJVNVBWaGgzd0o5Wkg2K3N2ZVVkQlJGODZwajZMenQ1cGVRdURlUlB3T2l2a2pCNGxzVGFReWlUK0FMbFREVXFtTXNLVUVLbDZHc0F2dE1mSGI5Q2ZzNGVuVGZNc01tVXhUNmQ2YmxCaUJ5bHNuMWgzL004eFgwQUh5dlFSR1p2Z2tTRkJwVTlJQmxPZmg3V1NPV0NPVzRhTldkczN5Nm4wekVDcVB4dTdEMkswNGJrbmNjMDh2Y1FqTjFkeThxWGlNWmY1bVNyRUhudUlQb2FBaDZWakJSTWszMFUxalJtMlRmT3BZTEFtV0VsaG9RNmNkbFhyeWp3YjgzNllMUWdGUTB0WjBqSEVMK0xCaG5DM3RnaWxCL2ZTdnNMeURsUmZWNFdjNGJrOU9YblZGNVlPdlMrelFlam5Pa1k0SHl3MUhvVGFKckFPMmprRnBWVjVRRklTaTczNFRuQyttY1VKbjh2a0J2N2cvTXZiUjAvc0RaZm9RNlFiTHRoQmpXZFlTVlpUR1ZXTStsUXV2Nm12RldBSkQ1UFM3YjVkVnU3bjk4dkVON3pKZkxNcTRGeFdkdEh2WlRZRTM0WHgyc0E2RDRrRTdoa29POHlIN0xuVzhTMW9nYktLS2o2aXlaYmJ4Y3lSMzdPeUJQSWs3aUhwbEJjdXpMZk5FeHJjeDhka0JObHlSNWNocDBBbzh5b2Y0V3dYdzhSam9SaFNUM3lVUFpwMWg4ZEgzYXVURktmQjkwd2k1YTZNcEQ0NmFFOWE0MWh3TVk5SlB1RlFUaDdkdjJzUHpwK1pOZk1FWXpWRFhJUWJHbHIzMGRYYzg5VFJrZXl2WGRsWU91aVQyZEt6UkgwaUV0STFIQi9kSHlHNUJRRzNCNmo4NndDZ3UwanI1WUFPR0RGeGppM2NWV1BmcGhDYms5UGtibWNtMnVuUzVESDBzajI3VVFIck1nM3YvNGpVTmFsOC9xb3UzaDVEQ1FEUElJQ2ZWNUtWUjNCeWtOcVFKWGVwOWRrKzBmZm13TlNZdmxJL2F6d0hEN0xSOS9yUEFDNVkxdHRXZjV3dm0rcjY4ZmpWMHBmVnVRNWtMSldLYmVwdy9MOVU2OGxFSlNSN2JrSENHRFQ2eFpRMGcwRE11SnpDbk9zOG55T3dEZFJHOThOaUZsUDZyandQNnIzMUlqdlZBTVMyWjdhU2RtK2JBRFFCSWVMMTc1QnU3REtOeFRVYzMzNlZHTUtCY0E4OWxuSFkyQ3M4cDBiajZ2MWJtck9rY2IxMVNCUDV5aVlJd0RMSzBpbUd0ZUtPb0FhKzNPTHNJYlZBVVplUWNjNEEzaEtmZEhzSUVENGY1L094MlVna0E4VzhYdEh4OCsyUzhHaVdrMk05aGxsUDJXMUJzNUIrK240Zit1OXFVTmw0Q2l4dmoreXp5Kzl6alNGM0I1WHgwS3NpTldnZUhTWGsrZGEwWUR6cnJLYjU5cHVaSTFvdFRiYU8xd0RsMGdadTlUL0ZQY2crYUFYL2s4ZFlJdGtuOVVDWlB4ZVVYNnN6OUp5b01yVHFVOWN5NWg0cnorelZaMWxIbmRRZmhDZjM2ZGpZUGpETm1xVm5IWWx6Wm92NFNvay94emlLSEVPK2p5WXl1c2hHU21QbXVBUTgzcXYya2ROMnBVWDdrQTZQdisvam4vcy9URElWSVBFL0gzUklWWnFUL2hTUENaRlpaTG9RSjRmWnU4QWplb0VsV2NPSFAwVlVoM2pMakRGTjBwZENuTG4rTllBVkRkUnh6cjNJSVB0eDZqb3pQZTJRSVdxK3BxamhiL1dydC8wUjhmTFBnUW0wR1phOWltUnhkdWFZM2k3am4xUCtEekhTYjJhZ1ZNZWIxYzhtbnhFYldOaWJET0UrZmRqbXZmRDR6VXlIS1hFSTBRR0tZYW04bndtZldBQ2pXYkViN1dkR3ZYSnVaM1phRTRHTTBncHE3SzJDODFXcHlkN0NBNi9TY0NYblUvNzJ3aFpwOTlIeUM1a21ZMHZBUGdHZ2tPUjRNbGZJamhWU3ZSbkFQNGN3RjhoVE5SYkNKbkFXM1VHaXBQNlZtZnR2cWtNVTNQSXptcDlHL3QreCtjQVljR3hMRnl4ekxVNWVaY0EzcldmTFlCdlF4d2xoNCtmYkZlbko1OEg4RGNCL0FDaEJCL1BtTnRBM2dQSG9NL2dlT3haTWJyeThQR1Q4OVhweWVLVE9uLzVNN29aaVRMMGlSckovY1FJK1pFMnlJQUpVUElNR2xXT0w0QU1IRGhBTUE2ZWw1N2RIeDAvQVBBbGhNQ0xjd1IrZEI4SkZGd2paS05FNWJSTFVYTmE5cExDbjZEdEhsSW1FWkNFL1VjaTNHaTBYUGkrcVNGZE1wRHRlL0xiclQwekE5bmQ5UU1BWjR6NmtPM2tRU1k5NzRLT1FRcmRuOS9CK3oxQUtzbDNvNEFlTWZ4VitkbVpEL2NTK2RXbjBrZU1GcWF6RExBSU1GR1NGTkNOQVF1aUlHN2tQcElHSFpBWGF6YUlWeVpaZHBjS2tXYmprUmloUnVkYmRCYUlNc1ZTSm1wTUVyUzRSRmpQZEtqdytVRFlFeEhrc2Q4clROemo0ckRUTVRkTGtqWStaMWJiTlpJQ3RVWXF4M0xWaFVqTmZVaEdqTHdQanBzbHdWN0pmRVJGVHZxNzFiNGlLY1BNWUZQZ2d0K3pOQzhCb2htR1o4ZlE0VDlhZ3FsUEVjSHNtNzYvTElNQmVRWkVxOXpRUFRkR0JiblVPQjlrRWJ0MnVCNjJrSEoyam04TUFsSkd4anNLTVBmSjhkd3NlZnhKeTc2N0pQWmY5bzhlamFCbGxTYVZleFF3bC93Z2xyTWE2Y2NoR3ZMR1hYdGcvZEdzZVRwakdVSDdjK3ZIMjBoQTNBekIxbEIrZHg5aEx6MzN6N2J2V1Q2WmN2aWVYTUoxZDRZOEcrN2M5c3NqQkptdEFOb2xrblA2RVJML3BqSDd2RXZsVmZrc1BiZFlEVXlXU3gvb1FuYk5RK25yRmcwanI1ZkFvcW5ydVQ4NmZvaGhCc2laOEtwRHBDeFhudTEzWTMzZStrZ1FlTjdaMFJNM2FNYzdhcmNZS2RudTUxajRLekNVM3p6M1dvRzRZblVHVzdjejVHY3dsc0FPNzZUakdsakwvZ1V3ZEtUNXoveDNwZnZjOXg3RTlBN2VnVjJIWENlSjFTcW02azFPbmpNWXJCbUUycERucWlmcFBqMUFxbEN4OW5QbHhrOWV3RXd2dU8reWNYbEhCOEV2dU1BQzZSLzExSTA5QTM2djdySkhIVUJhQ3ZyMDVZRm5HTkVUK25RMGpiNTN3RGszT0pjTmVSR0IyOXJ6M29SZHFUYlFYYlg1YVNZSE1HWTY1RTNtZFpkM3Nzc3pTdGZLL285cnlqNm5mc0oxeUwzQ1Bic0E2a2NGcVRNQ2lSOXdYYytsVGJYUFN3NVk1WHZrM1ZxdUVRaTg1VXpzY3g3WFVMV3BSK3h6NmpaOC9yb3h6cHZZNTh5RWdveE55elUvUk1MMjdrS2U3eVBvWjV6djV6ZTBxeGxvRENSZWREWEN5L1lnNzZLWHltUklwWmM1RjhSZjlOMnlpZ21EQnJoR2FQTmRJTm5TV2xFS1NQb3hmd1A1ZXViYVlnQjNERlpFSGt4ZHNzOFZYMUg3WEIzQU1YaEIydUwvR2hqT3RhTnJTTWZScW5pV2tkTTFpczdqRWc5b3lIUGZML1lmUVB0SWk0SmVVOXdqWXphZjlxT2tjNDIxdHlzL1JjNlRCc2VmbE1ZMW90T3l2SGlOK04yWTNxVnI2OHBmSy9LZWVuQTFxMXB0MFltWXhRSVRTL2Yvc3BIVGdZRVVYRUwrTnNrK0gybDdhaUREWkx5OUwxUzRFUG1uTWhaSVBMSW16NWxJVWp4YXdMNW4xVG90aFU5ZUNTVGVTZDFiZWFMYUEwREM2RlVleEh2aGpsUFE5Z3A5bTlYV3VuMVBtYUwyVWEwNjMwM3NjN1VwT0VaTjJqbEFzR2xvQy8zc0p2SlhCUytkZkZtMmFJRU9FWUNYTHlPY0wvb1g5dm0vaitBODhmUmRBTjlDV0N4L3ozMzN0KzNuSHlPVWdXWW1YMll3WWhneHM1TXoxeHpJbndPd3Z6bzllWDM0K01uUHA5em5uNGNBK3B3ejg1VmsvUmpyeTFiYXVha3pPRG95RGg4L0dRTlFaZ0RlUXdLeFlpazk2VE1RQUxCL2JiOFBrQ0xoVndCZXIwNVBxR2hIcGZudzhaTnNvWnVqZDIxbHFlK3RUazh1QVR4WW5aNmNJVGlSUDNNRWZ6b3BDdlpkYnZKTXNhWk0xVWlZK0cyQmdxd01jUmN5WjlUUU8wU0l5cWZqakdjb252RXo5K3d6QU4vdGtsUDNESGs1MUJXU2t1MEY2a2EvczgvNC9SN0MvaU93dyt0Vk9Zalp3SDZROWhrRjE4UCs2UGk2eXpOeStFenVXMVU4QmpRQzNOU1VOL0lCTlM2OWNVRW5vQWUwYitydzM2SlJKbllLMlRQVjRUcnJoOUZnVS90QzBxamJSMGlLQ012MWUyY2crMUlhQjJVdWpVS3ZXR3lSMWhYN1FVQjYwNGRNTVMxZGRSOEdkRHFna05ublZ3Z0ttZTU1QXBkYmhFd1p0a1duQ2YrUFo1b2c3SzJQSUpHZmZZZzRKdkE1eFVsWFVwS2pJV1I4cHBvdFZHbVdCanVkckp6WDh5NVhIcmNJa1llTUdxZXptSUF5MytVTTZRd3BScFN2a09TaGo5SmZDdzlhQWpHRGxvWXQ1NXJBQUpDYzc2cFhSSVhiN285T1oyYzBhcGxuemlIblJqUDhPWThidVcvbW5xbDBpWFRlS1pDY1VGZDljckxUSUl4bnhCQzhGcjVjS3B2bTMzbm04RWZEZ0tReDBvZW8xNnJjc3Z2SFN1YmNTTzdJM3Q3cGZLUzdKZ2RrY00zVDhmM0tyaG5yM3h3aFcwRFAwcjBQQzBqcWo0NC94akJUeGZkalpmY1JVR3U5bDVLUlJQN3lDamt3K1pFWk9xekU4UmFBbGUwSHlxTWx3akVCVnhCUXkrYm0zTnFqUEdkMkNOYzBqNXlKNVh4bGpKZHdtUnRJYTVhWnZ4djUzSU5pekJxc09aZklKeDRpVkdnNGsrKzRKd2hRTnlQRVc2QTBYRGFKZmM1OXJ3WTgrVC9rTTk4ZnZxTzczVjhBQUNBQVNVUkJWR002L0hlSk9zNE0rNXM2TW96L2FHbElOZkF6S3NnWHRzR3NJYzNHNFQ1aWtCU1FaNW1Wd0pxc0VvZU1UL3MwZDljb3pVeG1WdlcrUG1TbjFlYXFDb0lxTDNYWGxPUXQ5ZkJyYzJDb2ZDbk9iWTFFMytEWXVUK2FnRXR0TFFnWXJMcnpHZ0lxeVRQbmZjckFqUUMrWGZkS3J0TnpKYldQZzM3UXFZTUUwRzlzL1RFcmsyWER0WXJIdk9BSWlobGhwcjl2Q3V0SmdTMTlOMXM0NTVQY0V3RXRXeWUxK1NXL0lXbEFCSkN2Qy9iL2luTXY3Vkx2S1dWOWVDQjc2Nzh2MFJRUWxEWlE3ZnZia1BLSlR3TVlMZjJaeSs5NGhNQ0VlNHVCSkZOcGx6bG84QzNBemFmWTU5eC96TGJsSlhPWWJvZEtWbUVmeWpseVhaRnYwMzZPK0paL05uS2VwNy9aRDZVU1gyM3lRZG5QOTZ5UG1tRWIrUk9rc2tXcnJkTG5JN3F4N3NzVzMxYVp5YjNINDdPbVp2RFJadFhuN2JUR1NDWnpLQi9ZVnJGS1JKK3FwM2c4V08xeHJnSHlPam9ZNXZMRGZoOGd0MzhHUndkZ21NbExHNWdKQnBRaDBkNlRhMmt2VW4vak9FdmpZLys1ZjVXUDY3MGF6SzVyZVlOODNmTEhsMWZlaWI5NXg1NjB6N1c0THZHWGxqeG51KzRySDZBSElKVkNMcXo5RXY0SS8xMnBYMDVHell5UHhDb0xPdTVLWDNrdnY2TWVtY2t4MFZ1MFR6TzlSL3VsMS9XaE1sYkxrYXBCaC9GOTIvdUlmaDNyMXdKQnB1dFp3WFM4Nmw2WkNSOHI4VTUxQ0dkNmh2Ui9qb0NyVkFOYzdQcGFsYlJiaytoclRZemdUUkwxbFQ1M29DL2xrcVpOVFNyZ0tVQnVSNVhXa08vTFpMeTlORjlpTDhYUy9mYlZaWjhjK1lBbFBkaCtVaDdOVEdFdms2K1FCN3FvcjBsdE1CVHV6UUlYalZUT2J2MzNpdFAxNWFObC9KaG5DR3RaajA1Ui9ZeDhuSWtSdGJhcVRtYmt1clhTMXYxNGZXZ0J3ZWNjWHgxZzhEV0t3dENjZDE4RThHOEMrTnJxOU9SZHpieDFELzV6QUgrRWtNRjdEOEIvZ2JMejl4emhMTXlmQXZqL0FQd3VRa2J3dDVCUDJBdUUwczlyaEtpeS9kWHB5YUx3L0QzTE5nV0FtWjV6TzBMTVRQc3FnSyt2VGs5K2ZYVjY4aXVyMDVQOXloaEw5QlVBL3kyQTMxbWRubngraC90dytQaEp6S1NsczNoMWVqS3AvLzZhdzhkUHBtWnI4NXFYQ0JtTlA2VGpXcDNQaDQrZnZFSUE4bm45UHNMQ2Voc2hjL3N0aEkzOU5rSW04Y05HdjYrUVNualRXZmJYSW1MM2w1RzZkQjdQbmRNT1J1ZXNkSzBCWDNQL25RTzhTNG9uRlhNcU8zc0lUSllDN0pHL1IrN2RxdEppQU9mSENPYzV2T3FlUFQzclF1My9MT09rVDlIMXpBd0ZVbllDSFZDYUtRUklOSTlkYzRVSlovRWdPWkw5bUY4aDhORVZLaEZYRTJpQklQRDhuTlBBMEg0dVZQRzJlYnUwbjFjRUxnWFFtc3d2cVh5YnMrRFNQdHNidWExSmZHOW9aejFXMTZMN2FJc0FGTCtGd0MvSk0va2RrQnd4eGVjZ0dYeU1nTjZ6TmcrUUJMdUN5QXhlMEVodnlQZGNkMmYyL1QwSHZORTVkTms1SjR6TjlSb3BRNGJyZVlNZ1AxNWpXQnFUMGVYWldWbElDdEdpUHpyZUx4aG5ORzcyQWV6WmU5bmFiN2JIZVNtQitvdFNtem9XKzVQOWpNYS9Bc1ZJODY3bmZFZUhqUUNPVzRROWRRa3Ayd1lMUHZGclNSUmlEemJFL25HdjJQMEVDdlNkeGl3YjkvOENWbHEyQUlxVHVJNzhPdUhjTVRwKzRCaHg1Slg0RFJLdnZrSXdJSytsSC94dVlYL1BiYndNak1raW42MC9OQ1RYeU12WVYvZWl6WGQyZHFxbnNUVnlSOFN4ZmhwSWpYTHk2S21VT1Q3NmxLbEpmcXRyYjR4bUNPV1FCOWYyNFlpRGUvM1I4UUhmYXg5S1NqMUVEbjU1aCtrRkF2OTVhUjh4K0VEQjNreTJxcUZia09kbkNEemhITURMN3RuVEsvdFpHL2d4NjRQVG1YMmljL29hU2FmMW9LZk92ZW9nWXc1UzZpUWxlWDVtYlZ4QmdsZDJwRDJrK1ZKU3NEUnpYTWsxRndneTR4Nk1wNXNNcHZON3NqeTI5YkR1VXREYURNRGhybzRKYTJ0dXNpSTY3MVhYTWQ2by9ESGFpN0x1L1BxQlhhZVpReG5JTEVCT0pKRVJDL21PZ0MvbFNsYUtER210a3VjMytkUUlDSmxkVS9uY0EzbWFPUTNrYXpnRHBFU2VNOGlpdHJmbkp1djNDS0tLVHNHU3JGa3duTnk3VjJxelFBcCs2M3l6N3dUZ0YvSjNEUVNoek9WUFZuYlVqMDJlRzhtQnR6RVRXZlpwYWUzd004b242dHR6MmpzWXJnZnFLSXVTWGk1enR3dTRYd0tmTlNOc0JuRXNRL2FPWFJ2SFVwUFJ3a3VuQkhxTVpUc043TUEzUUo4S2VlN0dxVHg2RWswQi9RclAyZms2cmozVnMyUU5rMnIydVQ4eVJ0ZElNeGpBclZ2cU90ZXdnQ1RhRWM0K0gvQnVJN1VGUGJpY0hZOUUvYURVSnlIeTkyeXYybjByKzducW5qMGRWUG1hU0F2Zk5wQ2NVTkozSVBFTkVoTThEcEhrT2FzNUxaRWNtMDBpS0k1Z3Yvd0VhVjdmbWNqSGZYc0xtMXNHM0YycnptWnJqR01tejl3aThDUStqM0tiUEV6blFwM0NrTytZblViZU8wTUtCR1FtR3R0UW01U0pBQXo2b1N5L3NKKzUzS2MybERybVoreXpzMWZKWXpPOVVXU3BubjFOdnFBeW5VVEhieGFBS0hORHgrZGdMUUVaOWpaM2U0QmpCVVRlcUk1aTh2eTJ0bGVtVzBzZlcwNWx0ZGVySk5pTC9wUUN2N3hkWCtJZmZONU0ybDJJdktyMXU0aGRPc3h6ekQ3UG5FUDJRNW05eGxDZTh6ZmZqZHJuZEI1dmxGY1daRkhVVHhveW1ieXphb09hM2ZjbTdYUE8yeTljbmlQZis1NFgzYWJOdVBic3M2bnpXZHZ6Yzl1N1MvZlpnYnlyZ1M0bmZFbjVncTU3WFYrRFBkYmxRWTNFSUtsUDErUjVTVWNpTHJSMW54ZDlISUkzVm9sNk1ZYjJPU3VZOGVlbTl2a1Nwdi9yaDMyT3QxTW16ZDExUE9MdUNpRlFucm9YYmY0aTl1eUpMNHRuNURCRDZNc0F2bzV3UnZDQ3prbzczL2NSUW1icCt3alI2Ny9SZU5pZkF2aVJmZjlWaEJmN2Z3RDQzd0g4endEK2dmMzh5UHF5YjgvZWc1VmZsZkxDQjBoWlRPejdjblY2TXAvZ1NLWFIrQkZDR2VSdkk1U1pPd1J3c0RvOWVXaE8zWGllbHAxcnk1OTlBUCtOamVOckFQNCtnQy9iNXpzVEhjS3V6UFhBSVd4amYyRDlLeHJRcldjZ25KLzIyajY2dFBjM2VGZDIzdkFLWVVGUitUZ0U4SG1FZGZIQVBqc0E4THFXZVcxalVvRGpzM045UCtVMHdhZ3AzZVBmYWNhY0p4cjlVYW1zT0ZIaU9aa0MzRVVGaGd5OHBFZ1lNeWFJU3RBV0NBcjZUeEN5RmpYaXNDZ1VqU0tJVlFHL29wTVp5Umk5Uko1bHFkbHdGSEk4R3pnRDRGcGs4M1dPdEtmOWQ5ZWwrWFQ5WGZaSHh3L3N4NE93N0p1bmZhUVMxbXE0ZTJjeFN5dlJXS0lUaWp5aFNRNWtJbW1aeGNIMXV4cWRMY1hldmx2WUhDMU1JYUpUWHhVYkt0bGNYMXhyVkg0SkJMTGt5RnpYc0ZNc1ZObm5XaU9wd2JiUjl1VWFiOGlROXg2NmErandxRmFPc0h0ZlF3eGNXVTlicEN5eHJmVFRyMXZ0endCNDBUMk1zdExLdFpWRkJJdVI3bzMvakhvcC9XdGpwdkdlbmNXQjNIam5lSHlVSDNuUWRaZk9GanRFMkF2NzByY3NzMGJtS2o3RDgxbG5tUHZ5cmlWUVNzYzdrM2RTQW8ydjRVclBTaHNjcnorTGkrTmV5cHFmSVFVRjBGa0YrMXdCZ2t1a2lnQWJZRkQyV3ZjL2d3TVVvT0E0dURhMHZBK2tIYzVYbFpmY0ZWQTh3ZUdpWU1nYjYwZUxaSTB5UXZVY3dJdXVVUzZmc2s1NDdRWldTY0QrWDFzNzVBRUVCNmRraHpBekw1dVhQamhVN3lQb2tlOGk4YVlsRUtQNnVjNldoYm5qM253QmMrRGFPMkFmWXlBSkFjcUdYS0JSUlJET0UvdTZSQW9rdTBEZ25RUnVLZVBJbXlNL2xMNXJhYlVpMmZwbmNGbkpPS1pqZWt5ZUgvYkp1YTdQWkxDV09raG5DS0R2SVZKbUdmZmZnVnNYREhyWjJqMTAvcEsvK2I1a29KQ3VLUS93WXhqMGd2N28rTDdwSmExNXl4d0F5Z3NVZEJQK3lJemxBeHNmUzJ0NUVJNjZEKy9SZnZJNWNZM0pIcUp1b280LzNxdHJ4R2NnUlpCa1RGZnV5czVKZlUrdGV6TUFSbitRTzRHanJIVk5hUERlSUpCUGVOQ0FaOHM5UzMrUDhpQ0VQVjhNS09pVEUxTEJvUmxDQUlGM05xbGorQUxDbjBYdm1EdGdmQjh1YUtVQU1KSFhWL1ZZSjg5OWVWVVAxSEhPb2xORDNzY0ExSVdWNGkrc0FYWDZGcXRSRk9aNnNKYTRqbVh2WDNjcHVLMFVOT25sZVJiZ0ptM0MydlhnVlVZVGJNVTNpaUZNa2VlZklLbGVSQkMwcFdjTWdQaVdNMk1YKzd6VUZ0dUFCRm9vUUt6M2RjK0daL2ZaZDF6WDE4aDE0MnNVQXB3YnpnWjlkNlZNUUxVSGxDZHpidmxjelI3bU9yajI3WXpwZEdLZm41WGVBZTN6Vmh0OUNxYlpOL3ZUeTZqUy9Scm9wVlVwb2o3UTVVRnBHNlFqTjhqM1NyYUFsK2Q3Tmk2MVFhbmZxL09UMXovcWo0N2Y2VlBwN3hLcFBQZk8zMmcvQ2k4Q2txdzU2RU8xbXNoTEhaNmlkaWhsQ0k4eXVrVFFjMW5wYUUrdUpZNVR3bVpZTHB6ejU4dVd6cEJrajNlODBlYnl6bWpWQjFwWms5U1Q0enAyZUUrUi83dVBOUGlOem1oUDZzQXBFZDh6ZFNGV0lXUGI4eFl1b3poUEp3RkZLcU5LOTQxaE4vSjlNWGhZMnZCeXRra1YvY3VUUGsvdGMzNm5QN1hLVVRQazhyekVlK2V5TDZKK3ludjBlY0lQQjhrbzNiTXNLNVEySVBrNnM0L1ZQdGUxVEoxT2VjTk03cW5haW9MaDNJb215b1JtUDk2MGphNjZhNWNTWkZaZC9TaWZtZkg5R0ZnbDlyblhTVW5VdnlhdFl4UVNZUHAwM3V3ZWdsNU5YWnpCV1pTSjY5SytsblZGTzRnOGlUeDBVREcwcGc4NmVUNTRQeUxQdVc2NUI3dzhCL0w5N1RHSlNlL2VaRkx4ZlhYVDhQYUYyYlVQelViWGNWUGY4ZmZ2STFVcW94eFpJcmZQdHdoWXlBc2tlYzVncmttNmJIOTBQS013QTNMQW1HYzdhQW0wR1lMejl6KzIvOThmZXdDU01LUGpZSTEwWnUwMVFtWXF6Skg2QUdHRC9BREphSCtBSUV5NXdLN3NlaktSOXhET3IvM0o2dlRreDViTldpSTZOdWVIajU5YzJQMGMyeUdDczNzUHdOck9SSDRmQWFoNnkrNzltbXZ2YXdpWjB2OXNkWHBTUElPWHREbzk0VmxiWjBDNXRMYVUzdDViblo2OGorQ2NKbEJQWi9nQjB0bG91eExQT1hzSHdLdEduN2xaK095L2hUQTN6d0g4R01FNS93Y0l3RnVMRk9UL05CaFZuOUVka2pjZ0RSU0xmOSt5YlFhQ2FQUWFuU2pxaENDMWxNVVNZUEs2MWdaQm9vTEJUUU94SkRUNGpIaitJdHk1Rmwwb2ZiVkJxdGwvSm1QVk5pWXJSM3dIVGlEbzV6N2lsT0FkZ2Q4dFVoYlBTdG9vUFovS1BVdmZycEZLK3VuMS9OdVhLcXFkZXhLVkhBSHV2Wkc4MFhzY3pYVE1yZm5hZ2FoZzhOa3pKSkI4YTMxWjk2RThPRE4vcVlnc3VqenlrZGZYbEgxOVIxeVRMRmxGOEo3RzZ3SkJlY3pXcnEzVnJBeFRGMHIzZmN3NXNmbWxISjFDSytUdmJJNmd4RjMzb2R4aExKMDFBbWpVU3ZDb2t6UlNuekpnb2tJcklIc0VyWHRYb3FqeS9wbXB4ekl0VnpKM0VkaTB0bjFHdnhyayt3Z09TenI2dVVkVkw0cEVIaVdHVlN6VElnWkJOZnBRREtRcnBJano2TFNGMjFmSWxkMFprdDZXdFduOTBqTlFhc1pSTEhXSkJJVE5JQmtSYm40RzJWRE9PSnU3OGRiMktiL1hlWjBqcmUxRkgwcTNOL1VKQnhUZGlHaGs5SzcwajN2T2JhTjQ3NEs0VmpqSFU4WWQxMUNmU2k4dWtRZWVNR2lLTW8xcllKVEgrbm5way9OWEhmejdDRHJtUldlbEVubWY5RW5iSEx4VFdZTXJsRUV6cnZObGdTZlRuaWlCVk9STjNMZVhrTE54alY1WmYzak9MeDNsRzNzdTU0dHJhQlE4c2owNk9FT1EvenQ1VHI0RzVFRldTMnZyUXNDYmt2SEt2YW44a0prMVNwd3JBcDM2SGxnS25zZE84UGxBS2cxMjJJZlM0dDQ1UG9QVGtWVE9XSnZGSUlZSmMrbDFHSFZRUlNBRHVUemYyRHZ6SmZXS2E5N3hRVThlY0ZqSy81cnR2Y1VFNTIrREp0OWIySk1FWlZqT21HY3F0L1FzOXJ2RUQra2tMQVYrUkFlRDZLWCszdXlkRmVUNUhQbFp6WFJDNkxpMlNHdTlKcy9KMTYrNzRLVGw4UVhSOGVQZnFlckUxRkVoL01iQXM2WmNzdWRjSVRraFZCYnFPVjlBcm1OUUR0ZGtrRHE0YS9JODZrOHlubEwvQm1lWHluZXF2eXlSdit1aVhWVFFGYkx6MUhRTlZ2bzlhT3MyUkoyeDF0WWQyZyszcFRoUEUvdTBCVktwVktDc0Q4dmV1NjE5cnJxZmYwWngvWlRha2MvOTkwVW5hV3RzaFRiOGQ2bzNEM1J2czVjMlNJSGMxNUNNRzdtZUR0WXhhc256d1ZtWk1xZTBEOGd6S1ZQMWJNV1NIa1Q3WE9XNWpwMUUzWUhPWXQyM2xPZlV6VFpJK3QvSytPU0RQcFIyZlduUGpnNC91UWZ5SFdrUFFTZkk3SC83dStpMHJPQUtRT0pseElJNGp1aDRNRjVML2E0a1I3UU5JUEZ6blJQVlY5aysrVFhmendXR3dRV3FLN0l2WHFaYzlYbDJMY3VtVGowbXkxZFU0bHBhOTZGVWE0dmYrL2tvNlFiRmUzczV5OUtlRjhzTFM5dGpkaDdZdHNqYTB2TjBqVlRiS3EwcG82cTlJamdDOGI3Qi9tejFYZnJuKzUrVlQ3WXhldm5vOTZUMlMvdFJlNjdLYzIxTFMwOEQ4bTdkZU5aSWdSSURlVjdvTDBsNW9QYUZlNTE3b2xsOTZpN3RjMHpValg2QnBQZ3JhbGlDb3hnNEl2dURtQ0NKNzdNWllGeWl3cDVtOEtZR2NTMlFqazd5NS9vV3o4VlZQVm1JT0ZOcDNHUEhmZFgyb05wbU01VGxPZm1nVmpMMFZXd203M1c5ejkvajVibjBtODltNG9rR3dwNUxQMHJybEcycGpyM0U4TmhGOGxzZndIUW12SWdKTE5IMkVwMWpiMlpacGxzRWtPWXJDTVk4RGY3djJvUG9wZjRxZ044Wm16QkgvOVE2OTZHMStWT0VNdEJLakQ0NG8yT1NaL3pxV2IvV1YyNkdPWUFQQUh6RDJ2Z0JnQi80ODNsSmxrR3JBQXBmeGtQN2VXSGovSGVRSE9DL2hnVHlsTWIxWFlUU3lnT1F4WjQzUjNCU2Y5bXVmVjQ3KzljY3p3OFJISzQvUUhDNnNnenpIa0xtNGc4QVhFdzlQMWpLWlcrUnlqaC9XQ29oYmMvblFwb2pPSXY1cmo4QzhFMEEvemFBM3p0OC9PU1BDL2RybHNpZWpSdUhqNS84Y0VwZlA2Ty9IbFFDQVlBTUFHWTBLK2tLRmFOd2wyY2lsYldjd3lKQUM4SndCbVJubW1ZQ3FpWXdqTEd5elB3RjhuTU1mZnNLUmtXZ0dNa1J4V2ZUd1ZveWtCUTB5czc5Y29BeGxjQjd5QTFMam9FSzFIbE5FUFlwWTBpTlBEb2NTbk14UXg2OU5MZHhFUVRXVEROL2IvVzdTdC8yTU4zeE1Zbk1DRmJId0I1UzFMUXF5ak9FQUNWZkx2UU16aENTOWFOZ3RFWnhidVM5VXphdHUzUnVHd1YzVTRHMGRUSHJHdVYzUnU1WFJjZXZGeHJBbkJOMUprTHUwL1ZkaWphc0dXd2E4UjNMZkNFUC9pajFlWUhnNUJrNERLYUNqS3E4dVRITkVQWTFBTHkyNzk2eS82ODZ5Nlp1OElVWlFuYWlPa0FXcmZmb0RjakdOUXBXYUpTdUJsL3diT01sR251ODBHZnRRd2tnSUwrNktyeGY1VHZic2ZGS20ycnN4SEhwdnJpTkRDZzhzOFdIMURDK3JkeDVvK0R5bERWbDF5MzlOUUxlRE1iWjU4RVlRQUo5TG4wYndoTmpkWjd1MmRPVjhFaktIeUNWVEtwV0ltaU1RWUVKbHJUbldydnc3N0pnQUJId1djdjNwWXk0SllLdVRGdmpkWVcvc1BvSGVlVVpjb0IxZzJTTTdVUFdzeHRUZEI1Yi93YjZoN3lQTGNKOGVvQkwrV1ZMbmxOWG9SNjB0dWNYendDME1UNUNMZ1BtQ0U1dzZnWnJlZC9xYkRpd01WOUllM0VmRjNUQlIwamxGSG0rdUY2VFZZWndjMWdDTi9SZFFPWTQvbmF5bWFVazlScWQxeTF5b0kyODBvUHB5cmU0TmlqUEJ6cnZKMEZPcGdINTJzbjRSd0hNaUE2R3doNXJ5WFBhenRuY3dBTHFLdmNzRWZiQXdLYjIrN2RHRStUNWRaZk9MZWRlV0UrVTV6R2dSUFprODFpUkVuRGtybEZka0d1TlJIbTQ3VUlBM3NMbVlKS081OTlsUSsrcU9tT1FPd3A4UU0zVTUwT2ZzUVBRUHBsRzV2ak9uL2VtYUVwZmJ6b2V0eDRtT2VBTGZIcWdlOTUyYm1VUEFCVzcxL2RsaDdablNNSE9WWHZDalkzZ2RSWVE3UForU3o4ZWsrZTZyM3oxQXdaYnNlMVM5cjgrVDdHSEtmS2Mrb002Y0o4ajhjZDE5K3pwdVdJUTl2Y0RtNE5YT3E5ZENIQWZZQ1VJZU9aVytzWDVXTXM3R1dBN3FwY1Y1RCtCYmczS2ovTkZYYU5QVll5aUF3WTU5c0xQbUprM1E5QlgxUG5PZXpZaUcxaEJoQlVwMUFGOFFkMm53a3YzVU5haEo5a0pCZjNLVTNRTU9aekN5L3dCUDlabmpNZ3B0cU5ZRnZXaW5mZnMxUDA4SXBPTFFYa1QyNzFUdTlMM0FVTTlQWnY3WFczRWlmS2NPa01KZjlHZ2VEcVdCblo4NVpsQUNqN2xPeWMvcEwxOGF4bExteFlWTEV1K0h5M2pPK0U1bjRSOVBrVm56ZXh6a1E5QXcrYVJhd0FNOFF6SFB5UGZjenlZZUE2ZmNWV2E5ekZTWFZmYUJDb3kxOHNNMzkvV2M1QUg2N1lTS3FKalc4WWMrWmlUVnkzOWVDdnRaTWtwc284NVh2b1p1RmNpdm04L2c0cGZibXlVTVJwWVhmU0JXTjhldW1lZWQ4K2V2ckR2cXhoNWYzUzhYTklaYUE1THpleWs4a1BRZjRaMHZ1c3U5R1VFeCtVU3dPY1FITUMrTkRCcmFVZHlaK2FTWmtnUkpoc0VwKzFmV05zdmFoMncwc2NMQUwrQ2tObjdtd2hadm4rSjRFVCtHQ0d6ZFluZ2dBWHFaeHJ2SWFWZWZ4M0ErZXIwNUVPWlJ5NEVwdFh2Mi9ndlJ4eTNxcEI4WVAzOU5mdWZEbW1PNXlONy92Ync4Wk9OT3NrZFVWQ3JNcW5uQ2l2b3VrUlEvbGdlRGdqcllZbmcvSDJPOEk1K2UzVjY4bTJFVEc0RnhUNW40LzArd3JwNUNZbHVNR2YwQnZpc0xQUmZjOHFVRnc4UUlKWHA0ZGx6Qk9FQVpFSkdtWGlObWRJd0lCaDVpRXBtQ2Z1RFliVFNZWDkwVEVDVnBWRjhGdWFtRDVtUnNYUkdIN0xWZkdRUys3MEhEQ0k0ZlNZQVVJN1FYQ0R3bEFzTUFjeVp6Qkd6R3RDSDdFVUtod2ZTbkovNzRwejBJVHFWODlpTVZPMVMxQ1BIQ1NDTC9zK0VycmJUNVk3c0tZYkI0QXhXcFJzcWVGb3ljNFl3enpRNnRaMDloTGxrbi9uN252M056RFoxTm1oRWNveEl4N0RFeXd3cFNuTUxVWjc2dHBOOGdSRHBwdTlySDZtYzg5ZzhzUHlQcmpIT0I5ZW9La09jaHhuQ082WkJzTFV4TVlvK0F1Y2pmZUNlMWpPWHh0N2ZGdm42aXNUMUJwU2RCMzBldmF3bDVXZnkvMnZrenZxWE51WkJteDRVc3MralhxUDh4YTBIenUvQ3dCUS94NlV4YitRYUJuMXdQKy9KZDF3SEM5dVhWVU5kK3VnVlpUVUNhWHpWMWhQbmZOdVYrV2xzVCs3UE1ydFFjRkxjMU5EcjA1azJhdkJxbHRXQXJGODNDcUlvdFBOR1NCMEIvZEh4Wmd4a1FYbXNOQzQyN2xyS05OVWI1L2E5ZDVwcVNVbG1YWkJIYmZ1UVliaEcwQzBKQlBvTU9xNDFac2ZWeXBTeTJnS1FBN29hTkJCSlpTRDdDdUJoZjNUODB1YmpBSUhmWlNVYnUrQm9PVWNDU3ZlTnQvbXoyZGI5MFRGTEFXN3NQZ2FhelJEc0JjOHIvWDVZV0Q4NE41UVgxTWszMUNYczk5WjBEZklrM2V0amZFTnBhL2R1VUFsWWsrdEtZQU9CM0N1RTdLSE1tTGYrcmtUbnlkYWdrM2NrQnM5UmRpaXdSNW5FWjBZUXE2R0xiT1JhTFhYcEhiWWNtL0pNL1R3Q0djNzRMN1hqNVRuNUlVdnlLVzhjQXg0RzMrMENjQlowQ3ZEWnJ2OVJmdllwSXdCSXBldjRmcGVVZWZaZHRVeWg3TDA1VWdXVldIMm0wZmM0THhWNXJzRW1nL09mWlV4ckdlY015Wkh4MnJWUG0zNW1ZSWtHaXhBOHVaYm42NW5pcW1OcmdBYmxTd1NkSnVndy9MMUZEakxSUWNRK2NTMU5XZ2ZVZ1VyN1RUNXJ5a0x5SGZ0b1ZDN3FuTHZ4K1g3dFREY0ZiZCtrTEw0TDBuSGRwcTlqYTgydGh5TFBtZkI4eFpVRy9FbjJ6MWoyWHNTRWtQYXRPdXhxL2MvYTZISm4xK0FhMFVQNGpIbGZxTXdoc2lxZUh5NjJMRERNMWhuWTUzYnZJYXlLU3BjSDlpNWdzc0h4TXBWSjNzazJaUzN3bmlueVBBWW1JOWtHMFVsaDh2S3l6K1VYZFoxWFhYSUdSMXUyZ09HUVdBMXQzU2NIRWZ2RmhKTkZINnBUMGFtYWdmbnVIVzJRcW8rcDdRUU01NHBWYmZpT1ZNLzBlQk13UERlUmMwTmJWaDNEZkRkeHZwSGt3QUVRcThERS9hRnoxS2RNV3RyVVhBdGpnZXk4WDllSTExVmcxM0NOYWRZdUhWR3hQOUtYcW4zdWVJTHFnL3hzYXVieWdKenR2UFc4QkNON29MS0hpL3lqeEI5YWR1VnRaSTNpWFRwL2Zjak9uZmxycHo2dkpzK2RMS2UrVTdLaHVCYjR6cXJsaUtWdkdsVE9QUWdJNyt1bVpiZVdua05iU1RFZjZvMHQrL3hHei9QdDFOYktiWW42b05tRU85dm5YY0pkeVI5S3VqRDFRNkF1TTB0NkdIRXFQb1BWZGZ6N1ZWdzU4eU5WMXRiUzlZZjN6RkhnYlZ6TDd1T1k3VHhSbmdObVd6WDJzZytXaWZaYzRmUFN1R0pDZzdQL2FKOW5KZCt0YjF6RFhtNU00U1hVZzVoODFFcUFvK3hnUCtmSWVVNFZJKytlUGIyZUE5SDVTeURqeXdDK1lOZThQbno4NU1xY20ydUVUTkJCOXVjSThUemgzN0lCUFd4ZGJHZjZMa3JuK2g0K2ZuSXQ1K2R1RUJ5eEh5TTRsYzlLMmI5MnJ1OFhFWnlxdjRsd2Z1LzdDSXZzYXdnZ3o1Y0EvSHNBL29iOS9ZRTA4WmNJMmI3ZlFuQnUvaE1BdjQ5UWp2bnJkdTJYVnFjbmI5bXp0RnphSVlLQitSekJVWnlOU2NiNmxqMzdBVUtXOVZjUjNzSGJDTUFaTTZRdmJNeDcxdThEYS9OQlpjNzB4VjhqWkdGdjdUbnZJTHlMKzBqbnNyM3J4djdheHZ1UnplRUZRaWJ6R3FGY3RUNXZoZkN1L3kwQTM3QzJ0bmEyTVpWcTNSQ2YwVjhEbWlCZ1l3WnJuNXlqRzRTMTU4OVNBUkw0TVlNRkxJaENyTStOemtxNVZnM09xZjIrUURBWTJTOHFMUmwxNlZCNEtzaXRkUjZOUHlTaDRLT3VhdVZIQ1VKNXBadkNlYUQ0ZGVFTVBwYno4QTY5NXZzUjVTUWE1aVhoNzk0Qnp3NmtjaEdGa0JOa21lTHIrandxS0tkZVkvMWJsdFpKcFUwcVFWUks0N3NWUTVBR0s5KzFLcTc4dktSZ1FMN2JJcysrODBENUV1bDh1TXpKVDNKengvSy9hdmlWenBpb0VhOWpkdDJzUytjMzZuclI5VTJlUG9PZDdTcjlVdVd4T3ZjeUJ1N1hyYnlIMnJVQTRucWFraG05aDFCaWZDNmZzWDhMNlRzTmUrN3hHZEs1b043NFdDQS9zNVJnT3MveGF2RUFnaGc4NytPZS9ZM09uU3RpNnpjekd0MDFHL244R3Vsc1ZHYmlNeXQ5NFFEejF0N2Y0NXpZT0E2Um56WG0rNmZuMXF6dDN1TFpYOVllenpuVE5jVjFzclYxbC9WMVYyTk5RRGVOeHVRekJpVkxmd2xKejIwNnNIY3c0SE8yTHJMZ0d1RWxQcGhwVUZvT09VQkYza0JTOEkvZ0hMTWxlRjcyRllLZXZyS2ZwZlNCd05zY1NTY3Q3UnMxaFBXOWtwYzJnUnhaT3p3T2hZRXhNNFRNVTAvbnlNOFJyZTFsemswc1B5di9yM1NQZHZXc1p3SXl1cWZKWjZJOGw5K1hYY2hnNUZuRW50ZTI5b21DZHhFTTByMWw2MmkvVDRGa2tYOGdkOVN6TCt6elRQZ0YzRmd5QTdnaXV5KzlvU3Z0VVZheTNEYjUwWmhNNTlyUTg0eFpsa3psK1V5KzA3TEVhclJybjB2ejdPVzVBbTU4VDhVS09DVnFPWU4yQUNXeloraTdRdTUwNER5cUU5WExOcytucTJUM01idUtFZWpYR0FaaHpYVi95blhWZVRHKzhoYUFkN2xPKzFTK2xMS2JZRDcxRmdYM2VYU0h5bk5lcCtkdXptSGdmeC9PMlM2ZVUyekV2WEVQeWE2bVBDL3B5MFY1N2tHeExwVngxMnd6MmdtN1pFUEcwcVUyNTVveEFPUnJHKzZkTUNDanlBUEp5K1dlakE5eFhDMmRaZ2RxN3BjYnRQZXBvRjNuNXFaOFFVSFY3bGsxa3pDN3ZzQ3ZLUE0yR0RvanRPOEwyenVEc1RqUVcza080TmJpQ0cyYy9lbHRVUUNScjJqUVpHMStQUWpPc2ZxTTJ0cFpsK1FuUGlzcDJ2d0YrNXkydmkvaFBJV0t1ck9UNTNQVEMva3VMK1RlaUNkWVh5N0UzcU10eDBCY2RSN3pMTnVzRkx5VEYxcVZKUUxueGtmV1NGV1VhRDlyS2RJQk9adVE3NVA4OFFJaE9HeGYxNEpjeHpHcFBLYXMxN2tnMFZiUURHSEZsSFNPS1BQcHpBS1MzamFYZWRmakoyTGdNZkoxMlNLdml5aGZuYm52aS9jMCtNb1VYaHpic2ZGbStneHdNeXlubDRCbmtTUEtEM1F0K2pQdGkvSzA5TG43cm5tbXQ4cXhLWEtxOXB6SzMxc2ducCtzOHpjNmwwSlJkb3NOcVBJODY1dk9wL0dhUlUyZnNmMjV0SDJ2d2JXY0V3WUFac0YzZlFxMm5rVE9QaWRHWXBoVTF3QUFJQUJKUkVGVXd6SGNLQXQxVjNyRE9vTldlbGphSEEzV25iZlBnZXpkVnpFS1p6OXdUUTNhVjVtUHhCTTFBVUtEV0tKalZmck81MUJ2THZIbzZDUXRmRGRwanUxNWE3Y3ZvajJwWkd0dmwzZW5kaWZ0N1d4ZmpqaFpTN2JZdXZSNWw4Nnl2OFJReGt4TlpJZzJWc1Vtams1OEJLemlIT0VkbmtOd2g3SDF6UmQ1Z0FDQ3ZHY05mQi9BWDdoU3dZOFFqSnEvTTNFQXBDV0NVL1V0V0FTOHp3QTFSK2llY3hUT3pYbFlaSUwyT1JuWTFlSGpKd05sYkhWNmNnOHBtL2FyQ0dmYWFyK1V2b2JndlBUZnZVYVkySGNSZ0pDZklKM1J1Mi90ZnRIR3lQT1V1VmtJOGtZR1orTThXSjJlUEVESW12MEdnUDhjd0g4SjRMOUd5UHI5aHJYN0ZRU243WjhDK0I1QzF1OEtJUXVKNzR3L2tjSExuQzBRM3RuUzVwd09pZ05yK3lIQ2V3R0NVL2lSdGYxWENPY3pxNEQ0TG9BL0FmQ0hTR2ZFSFZycGFDQXQ5UGNSU2tYL2gwZ083TGNBZk42K2U4L2U4MmYwQzZKYkdOL05Oa3VmbHhpUXUzYmpQdHNZK0o5RlJDb1lJZmRkSSt6TGt1S2hvQnNkdnl1N1o2emt5UkpoclI0aUJ6M1p4NFBLZUhsMjYyVk5lYkd4WFhTU1ZXQWdhb3pFTStaK1VERmtONTJkWDZiWEM4alN5dTdiSUFIYjV6WWZEUDZwMFJ5NVlsa2FkK2FZdEQ1ZWRzK2VuaUVaWmlYRDRFWlpmVlBKQ1VFdFlUeDIzMGJ2ZFVZV2xaRnpoREtZVkp4b0VMMkVaZHdDZzdXdVphc0FtMWRkKzhpZHd4c2dacWJBdnZQbFpLSWlUeUNCODJwcnJSVU43c2V0eHZvRmN1Y1FEWUVJQUZtLzJlY0Z4Rm10aHM2VVo3UC95QjBlTVlKZXFiQ1d4cDZocGF3WHpsQmhIM1dkWjJzWmtyVm96MzRIUWE1UjNoTWNaVDhJYU93MWxISE5OT2U3TGptOHRjeXMvMjVaK2x6QXJnMFNFS1VnSHFrbEErajAxU0NSV0o0VnVXR1NCWkwwY3E1TUJUUldzR0tEZk94UjZUZlFpZ0FpOTByVHlIU3lUZGNmMTlLVjU1Ky9qRVFaYWVNZzhLVDZab3RpV1NLUnRaRnMvclFjbmhvaXErNVpsbkZEM1piWGFZYmVESGJFQUlMdXpJellMUkRQM21Ld3dvWDkwTEhuU2RjSUhUd2M1OEJ4NklnbG5TblBlZWJwM1BwMzROZXBBS1huQ0RhQVZrZlM2ODRBUE8rZVBYMXQvN1BFVXl6elpHdjJYZ2x3c1RWNTF1VU9lcFplTFBJL3VaZnkvQXBKdHV3QnVOL1E3M1NjbVVOVDdza0NqN3BRVnZFRlFpRHJhNlRNR3UzTFZ0YWo3K2RXZnh3Z2tWMmpZNVBQcU5kUXA5b2lIY3ZRREJLaDdMZjVMWUdtWE5zTW5sSitwS0F0WlhHTFo4NlFBNzU4aGpxL0I0Q0dCLzFhei9EejFDTHBBekNVeGQ1Uk4zRGt1TDRwcjU0aTEyTVZHdEZINHBuZlFBWmc3Um9Vck1FZ0RJYldJMTRpNElaY1ovRUJmdXpEMjliR0FYS2JnUUdkTVZETEEyd0NWbEdlcTVPaUZwaTZYL2x1VVFHNzFERThxTDZnZlduTTJRSkJIOUdBSzdDdmJnMW1GUlVFcUkxQlhvNDgrSjd0TFFIdDUzM3VuSmxYMm12Ukw3WGNicEcrVjZSZ21rbk9oeWtPRGVkczRETUhRYXBqdHJ6eW9GSjdicjBPZ2xhRmRMeWx6MXRqMlpOMXFzNDc2dmlsWjlKeFVUM2F3K3lua24ydVZVdm1rR0RTd3YzblRwN1RQbThlVjJSenBuSkllVStOTkpBVmtQZm41TG1lT1h1RklNZGZJZ1hhZTNsT1c3SWt6OG5UMVJFSzVCbUJIbUQzOHB5MkJKQTdsTDFUeWE5cjZnRlJGN0IrVXA4ai8yU2dtSGNxay9kckpqSXAyMy8yTitkV0E1UFV2cG9oeUFYbDI5bVJJN0QxS0xyMkZvaUpEd3dzR00xR2RMSjRGejQ0Y0k2NnRnQzA1UWQ1aDl2N21YNDZkditVL2lFNWxRY09ucW1ZWlluUFdYKzlEVnpsbVU1M2FqNnJQeG9HNXJ2dkJtMVgrS2ZudlZOMFRSODRNOGpPaGVQQm9nUEU0STVDMjhwWE0zbU90S2IzK2hSd3pBRDdGcGJvSGU4Nng5ZGR3RUR2ekQ1L0V6ajNWQ0tQdEhHb25HckpRd0FwZTFqYktWeWpkcjd1VFo4WXBMd01RRllCU0hWaC9uQmRVRjZRMTVFL0Z6RW41Ty9TQnhVMnF3L2FtaURlNEFNYlVIa2VNRTJlVTQ2dDViUGFrVmVsK3dkMnJmRENaZ255TG1FSUYwaVlNUEdIR21YdkZlVzFrbUU4WGNMYlh5SGdBVk9PWEFNQUxLMDBMN05MWHlCa2UvNVl5eFd2VGsrK2hKQ1IrajdLenBZcDlFUDdpZWY3OG04Z1J0K3FrUTlVSWdMdEhtYXFmdVFmSk01aFJ2Wi9HY0VoZVJQNjJ3ano4aGFDOC9kTXZxTnptSURVVzBnTStBdkk1K3I3U0dBWHMzNVk0dmtkdTRZS3k1NDlGd2hLMmtkSUlQUUdDZWk3WjJQOGl2Mi9YcDJlckFCY3JFNVBHRmwzQmVEYTVvU01laDlKT1dkMDhUNUNKdldIQ0l0b2FaOS9IYUdFTmNmMVBvSUQvQnNJSmJXL3ZUbzkrYTcxZ1djOXYydDkrM1drOS9ORm02K2ZBSGl4T2oyNUtwMUYvQm05ZWJvTDRWcWlmdnA1R252OTBmSGFNVmF1VDgxR1VVWjQySWNTUkZ5M1pLNW5DR3ROejltTTBaVmRLcy84RVpMaEVmdUxjbVRQSTRUOSsxMUlOSTBwUy9kaFo3MzRRVTFWR2ljUUJmUGt0dnFKNStPWnduNHRJSC9NNXFuUXpIMWZHdmZBZ1NEOUlNOWhwTzZBcHF4SFVYU2JUdTRhMVo1Uk14WWF0QkZsZ1U3UyswalJ3b015a1gwcXlRd2s0YTFSZC92SW84VFdYU3BIdkkrazZKZWNoRFVBYmMzOWFQY3UrMUIrQ0YwcU04enFFbGRJY2kwQ21WMXk5RkRlK0d4OHlEM3pBcmc3K3A1S0NycC9Kd0lVRjBHbkNXMnp4QTJRTzltQmxDbE5BSUVaTnZvTVhiZVVuU3FIQ2RBUUpGaERTdXMyMXRnVmhsbmZKYXE5WXhvWDgvN29PQ3NUWSsvOVNqNVRCM1c4eHZySENIOVZITGtlQ1dhd3BHWjIxbzhhSzhnemJJRTZEMXV6RGVIWDVKMGIrVnhMcFhHOEE1NUdjdmV3ajc1czc1M0pQakdrZHpvcitBWThaNHl1a2NxSGo3YmROWnlLc3Rlb1ExOEF3eXhVSTE1M3Z6ODZQdWllUFgwSjR6dElmUDlLcnVWNzNnUHdRWDkwL01NdVpLdVEvNTBoT1hMaWVaeVFNL2lRZ2xQb25OSEFETXB6L3k1NHJNazFnanpudXIrSEVQaklZMjc4UE1XMlczUHF2eXM4WHdITzV2MHkvMUZIMG11OXppTHluSUZjQ2dLVlNQY2FrUGFiNmdnWGxIRWlkN21YNlhDN1JuQUlaMFNncy9GOFhrZWUyU3B2QmV1UGQxSkZCMTdodmN4MExJVnJQSytONWJLYzNJN2ZOK1M1ZDNCd2ZTNzZWQXFOYldSbGwvdFUxdHNQZDB3V3dQZFJlTEdXNm9zbG12MThPQjJaL1ZaQStBb1luRlVZMThBWW1HTjk0dmhabnExVVZpN2orUlBHSEFNK2tKeTExMGhsMEZWZXJKRWNyY3lVSnluL1k2QUtTNFhQRVBRaWdsNE02dFQzTWtNQzdIVnNsUDlhMXRNVGRZZVNIaFhCUXNwYjk3MStWblFVQTNGdnhmUDVwRzl6SkxuTGZaL3BCY0s3MVlta1lHSHBQZmsxRWQ5dFlkMVZNMFpMYThEejNqZGx1MHIvZG43R0c1RG5PK201VSt4TzRUOVRhR0hyUTQ4M0tXSnhYQjk5S01Yc1N6ZXUrNEp6eFBPdVBwVk1IS3lYeWh6RW8yZ0tmS1ZvQi9OWkU4Yy9SamUxendlNlNXRjliNUF3a1AySnorSGVKaUNlbFozdDBobTluajl2K3hDVVJwdm1WYUhmZ3lPdnBLOWJhNE5KSmVTalRRQzZJTStqUTdid2pxSThrKzlwbHdKRFBxcWxRWGtzbDFhRDJNTE9WTzdUT2NIRUoxUTNVcWV2bnVrTUpEbFBIWGRyMTJqMUVLN3RBUjhrL3lWbW96YVU2UVVNcnViWW9yMUtlYTV6VmRqWCtybGZXNmg4TjhvLzlGbHVuNm91TWNyRFhSLzBKMnVqd0xNaUQ2ckpoTkt6U2pKRXgxL3JuODcxQ0k5dnpsME5aMnpNSWIvZjZIZU9kMFI5amV0TTVibXp6M1YrVmMrcllUUXhjRTk0YXRSeDVYUHFPY1JCZ0NBTGxuQzhXZnJDdmNUZ2tndkhxM2JHOWhyRW83b21WL3VTdlRqby95MklZNXR5SEVoekR0eCtZTUIxc1QzWlg1VG5hbXZ4Ty84L2JZUDlQaHpoRS9rVWtxK0wxYk1VY3dHR0FaRGVkaUorNi90THYxZjJubVM5Rk4vRG05QzVwbExyUGJyMXZFYkNSTzVOYkY1eDFzSFl2VHgyZldHaVJEWFlUUHROUllvQytMdUhqNTlrU29DZG4vdDNFQngrNzA4Y2dLY2ZJamdSMzdiZmg2dlRFNDJZQmZMc0tEWG10cFl4dXBYTTRYMkV5ZndoZ0xVNGsvY0IvRGFDdy9jRFRKL3dNWG9Md084aU9VSzNoNCtmYkZlbkovOEl3WG03Uk1pZS9pS3MzTE04KzN0STgvc2VRaW04anhHVUxUcUEvN0hkK3cwRTUrb0RwRE9JZndlaERQVVBBUHdSa2dPWnBmTmVBdmkyZlA1YStuMnAyZGFyMHhNYXRTL3RJNDBzZkdEUHZrTEtiUHBUcEpKYUh5QzhtODhCK0ZVQXYySFhQRVI2ZHorMTMvOE13WW4ySHlDQWV0OUhjR2lmMmM4Y3dOdXIwNU9mZjNZZThLZUxqRkUvNkVJMHlhNDA1VjJxUXFFTVNvRVJLdVRLQ0M4UXp1OTdCUUVYK3VEYzFVQUxuaDI4a2VzR2pMQVBFVWVQckM4L2RsOC9SMWlubDQ3Sjd5RmtzcC8xUjhjL3FSbEdWQ0lLakxybWNCNlFBOS9HcnRVemFqd1J0TXdBSlpzN1J2NjJsSzVNcUkvMVhSUk96cmwzQkNnQXVRR3k4ODVhQVFRMDFKYjkwZkhMRVJDeWFuQzBsUERHZUxJeVN6YmY5N3RuVDgvNmRNYmxQbEw1WmFYQmVYOUk4ODNmNmdoYzJyVjh6aVhrVE0xQ0YydGxjdWhFMEhXMFJRNHUzRU9Tc3p5dmhEcUJybDBxZjFzRUp3UFBQajZ6MzRPU3hkSnVFOXl0R1B3YmZ3MFZ5Tkw2YUxTdlJzL0dmYWJ2UXRjcmVaTTZVN1Y5QlJqV3lNdCtLYTlhbGZwVk1GeFhRRE1DMFdmYkRyNHJBUHI4WHVkcURja0NxSkcxeFFqRlN5U0FkaTdPaW5sL2RMd25BTE9DK1RxdlJlZE9nYWVpY0cwMHhPeC9iN2pxWjdIZFBnKzJlTk9rQnRPVVlJZG9LQnN3dEpQanVFR3h6RkFCL0RnQThFNzM3S21YY2FYK2NkOXEyYnpXL3QwaVZicFo5bmErcHZFdHRqRkgwUHVaVFF1a1BmUnVmM1Q4Y3o3TDdvdmxYNm1MSUFHQTVLVUQyZGdmSFQrd2F6ZjkwZkdIcnMrczFMQnl2SGlKb0wvVG9WeVR1WHNtTzVpeG92YzNzM29FdkttVmY4NUlBUEhhbXFLQmQrVjR5YVkvT21aRmo5WTcwNGp1RWhnTC9Sd0pRRDIzWnhEd2pCbGxKak1JVnU5eEhkaG5nMkE1dTRlMng4S0FocG94eld6MUdNVnQvWWpPV0RHMkNVZ1BIQjBLTmhvZjJ5SUJQZHYrNkhqcDlMVXRVQ3l4cS9KODY2NVhSNkRLaEZtZkhHN2NFM0V1M053MHdSK1ZoU2c3N3VBK0g4eUY5QVBJeTIreWRHbXBJZ0NCeFVuZ3ZsQjArcm14S3JDZk9lMUxjeUI5NEhqT2tYUkw1Y1BaK2theWsvWHNYdTJIbGw1Vmh3SGYwd3pCRHJpQW8wNmNFZkwvQlF6VTlOZkxOYlhxUURIQWozcG40VjdTQmdWNTdrQjFsZWZVNldLWjVqNDVVQ0pBYU0wd3NHbURWQzBoTzhxbDFpOXhFSlRXa0ZJTGdLNk4rUk9oS1NBdHIwTnkyRk5XM2xxZWo5azJHRllCdW5XN1FzcEhTbVBoK2xFK0NJUTlIbm1vUE1zN1BMVWFUOGEzM1hYN1NPdlM3ejBHdkhsZXBPK2pLZ05ydG9TczNiSDVyenBGSzBSWlU1dlBCVnlXbFBGbzJvV3RkNjFWZVNMZzNyQnpPVC9VSHlKdTRPUTU3VGVlMGJ0RmtzTURtVVY5RmluZ3A3Z1BSQWUrOW4zdFF5WllKZ2VzM1pJOGowZktHYS9rT2Nyc3gySDM3T201NlpQRWhJQTh3QlJJUVVTVUh4cXd3SGVzQVR2ZTJSbDF0ZEtlTkp1NkZYamhIWjlxcDViMHBwbzg5KzBWbmFWQUppTW1PZHdtOEkzcXMwYnVWejJtcHJPUkpza0J6bEhCenZiWFRlTFRZMk9mZ0czRXRZMzJHSlFYUnRKM0pmOW5RZU1pejJQQ1RDOW5vOXUxMTdMUHVIZUs4c3A5Rm8rZGNPdWJPQzU1Q0FNbHVKYzh2dXZ0UXYzOFRjcDQxUXViWkxZTmRhVnRINExxQjNyZkRTamF0SVgzdTRjZ3o2YytaOWFsd05IUmdFemtXZHRLZW84bVFWQW5teUU0Z1Jsb0hRTU5PQmJCRWRrWHl0VFNYRFBZSm1KZVFreWM4VEtWYXd3VDVIbHQ3MHhhWDd1c3dSb2Z0bWZTUHZmeWZOTWZIZE5tR1pQbkVjTWE2NWZZZlp3N3hRTFZtUjdsQXZkM2YzUThvM2Q5QmVCY3MzNkZEaEdjZi9kYkhUSDZFQ0hEazJmTTNnZndIUVNnK0xuOXIyYzM2U1J5OGNXWGp1RGNMUUVubDBqTzJKazVxVGNJVHRQNzlueG1CaXI5SllMejljckc5QTVTQ2VReCtoR0drVzBMYTQrWnVEeWZsMWxoUDdLK2NNSHpHa1pVdkFEdzd3TDRwbDM3STd2MkRPSE01Rit6Ny81ZkFDL29uRitkbm13UkRHQ0NkYTlSU0N2M3psVnpXcStSd0M3dk5HTG1MaGZPZlNUSFA1bllBc0hoL0JKaEhuOWdmZm1wOVgxNytQakp4akxMUDBRNGQ1bU9idFpFdjBTbHBONW45QXVuSllDL1lZcnpkNllDbHlnb3JKNzZsQlY0QmNUejEzeXBJRWJMYkp3Q3BkRkhHakg2T245S0FNTW5HTWdQRUxKOGYxcjRMb0xNTkdxdDcvZVJNaVVQVVlpWWxmdUx4aDZDd2FMS21JSjZCM2JmUmdXSWdmakx3bGhoM3hOa0xpbS9tOTZpQS9rODVKRll6WGxxR0hMRmlDNEJaL24vbFNsOTNyaU5tVWZTSGczQTZ0engvbHAvYlM2S0FFRHB2Z2xnVHdTNzdma0V3U1BRMFI4ZG55SHdzMUw1bFd4dWtCeXdxcHh3SGdobzdnRTRsM21yT3JWcWZlOVNGREhCaCtpb3RjOVozbmNONExVQU45Y2xBOG9BNHdNazJVMmx2d1RlNi92ZlZibW44amtBM3BHaVM5bis0SnhZQlJPUUFJR1NzcVpPU3gzbkdoVkhzMTF6M1I4ZHY1UTJHZm11UVNlVHhxM0FPcEpPUU9XTWpyV3JNYkJwYkIvYnZNUzJLMk1pRUhVUGFjM041YmNDZDF6SCtwazZnL2RRcVpMZyt5WC8rbmVrb0VJUnFLdlE2RFB2ME9Da1RqVDFYY2ZNRmVUemV5dFNoUjRTWEdXZnZ3M2dkWDkwL0FoQmh2eGMrMVFBU3BoTk9zTjRadDRDcHZNaEJZZG9TWHpxZWc4ZzU4RVpMM21Cb0EvZmszdGdueXR4VDQyVmViNkhJSjlmVlByTVlJYTlMZ1JYVWQ0eUNPcnQvdWo0WjVWN1d6Snl2ejg2dnBCM29GVVgzclo3TDFVZTlVZkhENjIvdGVjeEs3RzBYck9BR3dHRU5xMDlUdW9xUjFQMGNoNlUwNTJ1a0FkbnZMVCthWENjQmdqcFdtQUdwbFpOMG5FMERYUWIyejJFZmNOalp5RDNESTZXcU8xdkFTOG9YeFJVeTdJZzVmNnFYTFByRktET0hETUN5RVlBcGs4TzQ0SERZeW9wY04zUU5ieFR2RVFFOUhWTVB2Q3IxUFpvLzl3ek9UOWVSK1R6RG1EQkE3YVBORkJRN1FOVzJ1RGZtcTNGSDVZL2k3eUxBRlpEbnE4Tm1HSC9XTUt3QlBpUGpoMUpweUp2cituZFRXcnh1cFk4bHpGei9qVElqNEdZek54Uko4aGExaWY1T3I4N1FBZ0FtYnBtU3c3LzJELzVsM3VsSmM4L01icUJYcENWeWtaWno3eHJtZ21QbVZweGF4S0pmVTZiSkFiSWlHMjVxZWdONno2VitNN3NlZmVZeUE5RzVudFByaTlSekpLVU9WQjlLZ3Y2VUZKY29VQkZYdGZuZ1pFeDQ4NisyMGZRclVweWpuMko3UlQ0bzVmbm5KOHA4cndZSUNyeTNBY1pYaU1QYkdLMVAzWHN4Z3d1K1UyN2RJWjZvQno3MU1JTU9CZEwzMDdsdnByamJDM2ZNVGhjYlRKaUl1cytPTERwblBMSEdzWDFqblMwQlg4V1hhb0NvNldrS1R2MTN1cDdxcXh6RFFTTCs2NXliYlhrdWlQdlRKMHN0MjlETnNkMDFNVEVMZnV1cGRzQlpmdmNIK096azgybWMzVmIyYUw0blBaaEYrZVNYVGNsMEttbXQycFFHSG1jMnVXNlR6VVR0K1dZSHkyelBQS09ZcENRNkd5cWQ5VGFVNmQvOGZzN2xHbFJGeHk3VVBoN3BnL2ZCVjRnR0ovYUhYd25pODRxNS9WSHg0ZWRxNkpYd0RCTCtHR05PUFk1RWw2anVuQW03M1VOQ3Q1SHZKMzNlQm5IZThhQzJja3ZhL3V4SnM5cEo0N0o4eHBWZVdDZkFpWktsV3FxNjdERlUyZ1Qza0tlRi9tQTJQbVpMU00yS1ArLzdndlZnNlEvT3ZaNWpDU3BPSCtCc0NrK1JuRGt0dWpQN0pvcnVmNEhDTTdDdjBCUU5ENUVPbk9DRVE5OENYUU9zdVNTbnZNUXlVb1owL0hKRlBHSENDRFRmNFp3anUvN3lMT1Z6NjEvZndMZ1h5Qmt0djRqQUtjQS9oY0Evd0FoQzdkR0h5SmxhYzBSbk00TEFIOGZJWE4zalpEbCtoRUNnSFVQd1hINjZ3RCtMa0pHTWdEOERPa3M1RWNJNS96ZVIzRDJjdU4veGE3NXZ3RDhyd2padEQ4OGZQd2tBbU9IajU5Y0hUNSs4aUdDdy9nbHdxWlVnT1RhWmY3TzVON040ZU1ubHdqWnZqOUJ5bmJVYzg1WWovMERtVWV0L2Y0YXdPL1pIUDZaamZ2czhQR1ROZGVSL2YxREFQOFF3UCtKc0NaZzgwSUQ5RFA2OU5FR0tXTW0yMzk5T08vaG9IalhOR0JESTFPOE1GQkdQY2djczdZWlFWTXNkV3hNY3F5OEpXa2Y2ZEIwVCtReGRDWlNFQk9vSG9DT3ZxOGw0ZEdsc3ptVkZtWkFIaUNCMkY2b01mTzFsaVdvRHBtQmNCTG1ydzdHbTVieVYwTnVEOENEM3AwalVsSmFhZ0twc0dhS2E2Z0xaeHk4N0o0OWpYeXdJb2pqT2lwOXo4OXN2Y3dSem44c0JqY1IrT2pTZVRUcTVMcHkxNVZLOW1WQXN4K251NTZaT0pxWlE0cU8yLzdvZU4vUGQ0MjY1RGpNUUFZZ2xqbGVJWnhYU1NPM2VNYWJLREVicE9BaHl2RlMxRE9qQUcraXlETVF3UGREOXlUZmgwYXZNL0xPODVTNSt5RTRmTjJsczBDMlNBYlRLT0JyYXpGRzNjdFgvSHZaSHgzZjY0K083L2VGY3orbEhTcDdCREQyQkVRajRIQ3JmV3E4WlhBV2NhVXZkT3JybWFLOFQ5K3BnbXg2SHFNYUExTkE3aTNrN0MvWFI0SXFMYUJPeDdyc1UrYkNzclJIN0xQUnVlQTdxUEZiN1grSnR6WDZxd1oxQzRTOEtXazJYd3lpUktIaWhzM0JXLzNSOGZzVmc5MkRaUm4xZVdtd0ZWSVo1WTNzSTk0L2NON1puTEVhako0VFNyQ1p4bmpNK3F6MFFjZCtnWEpnb2ZJT0JTaTRwbU13cXIzMzdNeTlybkJPc3ZXVCswUnAyWWR6c0hpbTZBTUVjRmhsMGdHQ282bDJYaFl6dXZVY1puMHVBYUdsdE5NNlZ3ank3TkxuZEJUZFIxZ1REd1hneWh6Qzl2K3FjMFpvbDg1QXBYN0VmVjJyWG5DTzRGU0twYjRMNjVEcmFJMndydloxREFxRTJIdGJJaHdWVXB4WDdsWHlmSk9QSHZRZW8reGNNZUhodnRKTU5OanRmdzE0Vm5sZTFlc0svUy9xMko1djZsb2I0WFcrYjBWK1MzbmVUY2g2cStoQURCb3JmVTZ3Zmc3aHpiYi9sMGpuZVZLdjA2eGY5dmVpZS9iMHRhMUw3aDBOMmh1VGZWZXlGcmJJby9CbjFxLzMrcVBqdDF2eVhNYkZNdllxZ3lqTGJ3eElpencvYU9ocFNnd2lZNy9VQWFPWm5odzdzL095WURaVU1uOUxOT0tvcU9uMnBUVzk1TjVvOEsxZjJCbC9EaHgvWTFoR2FZeXRjZDl5UGhUVXozaEJnZWNOcUFVQSsvbWF3TWVBTm5pdk1sdmI1bjNGdnJlb0JMN2ErdU8rWUtVTEQ4d3ZFUGhVVFZmWFkyR3lmZXZrT1hsRTdaekZTZFNuNHlBT0VJN251Q2Z5M0FQSTI4NmR1V2x5VXMva3pSd0ZsY2RlSXZBSmYxYXlVcVlEOStFTVViKzJxYVBOamRjZUFyam5yN04rODJ4bTZtRXMxVDlIN2x6bXVjemVjYzM1M3FNTmovU3VHTUJJNGp2aDJsTGJhTjJaRTlSMGxORjNaL09kemFuVEVlTjhLWDR6WVMwM25XenluQnNkcGNWbk5IU1dtdFBFbitkYzZwL09oWmFnajQ3Y3UrTDM1S0ZUNXBPNFdvay8zYlkvaFhrWmtNTnRsQzk3dTV1ZjZSelhNTU9iMk9mYUZuWDdtcHlQMTlvODMwZXdMNGhIbFBRb1lpQmo5dm1paGxXNS9tOHF1RnlKVkZmbmZONVpjSlU4UTM4QWxQZTEvWC9ZSHgwL3FQQ1RxbTBsOS9PK2E3bFcxNUlmYjd4WDhHN0FCWlNhN1pKaCtSWDd2Q1RQYTMybVBOYzlwVzE2dTIrVUt2S2MrejQrRDBPZDNQZGowQzd0dDhaejcxS2UwNmE0aHhDb250bTNOV3k5MVRmWXZDelJkdjRDUVpEK1AvYndNNFNNMVJKOUhzQWZJcDBCd1d5MTEwaU1peTlmSSs5TFpXQmozVzg5TDlob1lmZGZIajUrY21YT1RRSkp0V3plbnlJNG9sZjJjNFVFWGw4amdGYy9BL0N2QWZ4WGhYYitFR21oMEZud0FNRFhFSmpXSHlHVmV2NDNyRDl2SXpsUC94WkM5akh2KzQ2MXczTityNUd5SWU0anpSL241OEhxOU9TVmYwK0hqNS9Fc2dHcjB4Tm0xVjVOS2F0c2JWM2F2VE9iQTVhUXZyTCtYQ0psWk9pYy9EbUNRM2VGUEpLdDlKenQ2dlRrcHdEK0NZSWovQVVrQ25Tc241L1JKMHVteUg0SHVUT0tSSUJ0MGJsbzE0bENOb0s4QU5CYnRsMmZzZ0dBQnVqY3BWTEhqR2p5dGUrcndMb0ExaFJxTDJFT3NOSnoyTmZlU3ZiMUljcm1Bc2xKOHRxK0h4Vkd2WnlKNFlGa1dMa2krWis4VWVmaEhPbXNtU0oxS1FwNzBRL0xHWkkwZ3JXcDNJaUFWOFBRQTRaMFhLRS9PbjQ5RlNScTlIK1hzbHJWeU5vcHd0bXVBVXdHdXJYVWV0Wm9INlV0cnAwcDU1aXBneFVvRzJpVWZjcytaSG1jKzJzRXJPQmE0L211VjY0ZmE0UjFwV2Rva2k4UE1vRzZSaW5pMHZqWjN6NWtkRTk2cjMwZUljNXpFbGtwUUJXMXFMaHhUTVliNXZKK04rNCtLcDhsWlZYWFJLbWNOZVI3TmE1WmZvM25FUUpKSHZLK3JQeTV0dWxBQUk1TDIya0JZTTBvWkFlS3FTTWx1OGFCRHZwODM2ZlM1MER1UU9Pekp1OWp4MnNaMkZmS0hORjd0T1JaRldncTdPa3Rwb0haVk5wbnlJL1V1REYxS2V0TlpkUmRaKzlvQmd3amFsOGc4SU1IQ0ZVRk9DZnFtSG12UHpwK2J2YzJNMG5sZnZKckJUQ0J0TmZvcURsRFJTWWpnYUxSaVNmWHNSb0dBME45UC9pTzZQQjlidjhQQXJwTXA2RmNZTDlZQ1llTzR4ZkNhNXJVQnljTWcwZzhxSGdGYy9vaXpmR2hrNDg4Z3FVNHgrUzFwaC90R1YrTHo1RjNvSm1RWTMxZUl1eUp5RmVFRDdKTUxvTTU5aEhtY2FjeW8yN2RzSXBKRVJpZ0VTMzNhbGxpcFF1a3M2ZFVmOHNNL0M1RlF1OWpCM2wrQXhBMDQ2V096L3JyUEpEcjU1UHZiMjd2dWhqWWlCUkJuaDJGVUJoamxCZHlIK2ZiQjFUR1lJMnBlbHZmT01jU0dKYWx0YjNHTEhDdCtxTFpaSnhQZFZTU3QwUTlsbnNCT1FqS2FqOCtVRnpsZWViY3FNaHp6YXBoR1dpMmM0MDh1Q0piZ3pJdkhCc3hCV1pFS2IrRi9ONkpDc0I1cVIxbS9IRmMxSC9VcWV0dEFJSzRjL2MvK2RjUzVReitLcWxPb2ZyMmxIdnNQdFVuK05uT3g3Zm92ZGJlVGZaN3RiLzlzQVQ4bmVNWmhURjZaMEFrcnBGZDlyUWpYNDFyNjlaZEM4Q0ZYRGQ0LzBCVzVyMm1yOUsyQmxMQ3hTQUpoTGF1M0VjTUlZNWpRai85czRzQk5zWm5HVWdSTTBOZEU5Rm1LN1V2VHF3dHpGR3NOcEhNays3TjV2c1QyeVptZURsNVR2Q1p2R2lnLzQrUnM4azN4citMYTY2eTNtbzZuenJEMXhCNXpmWUwrckt1RGQ5UEhaZVhRVXNFK1JyNW4raXA1S09MUG5jSWtEY09aQ25FcVVhZGpFNEZwSFZCaDg3QStkVG5RZnBydVllVjc0cjdYZmVoN0NPZGc4bjhSL2dFTThxS09rZmxYY2Q1NHp2clhkYXZ2NmRrbjdmNld1TFJVK1ZJN2I3Q09FaGpPRFRINWUxallIeVBGdmRHQlpzYXZOZStYT0ZoYlB5KzdZaEIyZjg3OFFGbm4vTm92akZNSi9Kbkl3MEFwUDJSNFdMU3Z5bDkwejEwRnlXYTJTOGd0ODhuQjc3ZDVEazI1aXVrNENLdGFNVGZsMGhPOFMyUVY4YXNrZWlpR2hDNlFaS1Y1RmRYdkY3dnRkOXJlK2R6Q0g4U2ZiYUtUL1VKcDZmOFZyays2Q3ZLOGx6SHFUaGxrMGJrT1RHQWxqNWUwNjhIL1I2UmZ4b3dOSWEzYTFCNmJOLytwRzNPQ296Yi91aDRyQ0xhYU44QlhDOFJISTZ0OHo3UERoOC9lVzNuOEs1UmR3RC9LWUR2SWdBeUJEMHZrWmNxWUdTc2o5elhNbkl6SkdCbWZ2ajRTYW5zTWozaVYrWmdaUG14UDBiSUFQYjBMNUZLRkROYVRNKzdPYlIrbmdINHB6Ykd0MjFNUDBKeWxLOVhweWRBY0lhK2JmZGZJV1gxN2xzYjF3aUExTnRJZ1BiWHBEK2xzNVRmdDdab2JDbURHd1dsek9sYkxNMHk1aEMyT1dUSlpvMksvMHVFY1R5My83OWsvYnRBT0F2NEp6Q0ZUcDNSQmJxd3R2NEt3SExrMnMvb0U2S2FvZGpsMFQ5S1BCLzZYaC9LR0U4K3AxYmE5ZjlUT05HUkVCbXIvcGJiR0hRQVNIUWUyNmt4UlFKbW9wQTJnWDBxWHdRbVJYQThnUERMaVFyQ3dKRHRVM1FRZ3k5WVBuT05VRlp5RDZHODdxVUpZcUJoQkFtVkhJS0hTTHhZUWY0V1pRYkRsL1E2QUFBZ0FFbEVRVlFTRWwvMjQ5TGZ2M0N5OThSNUhTMmQyNGZ5ZjAzQXBBV285S244ZGhhdHBzQ3dWM0lyYlRGNnViV2U2TFJRdzFXVk1kNi9sT3MzU0FidVhwL09JTnhVOXU5QStibXAwV1Y5WTBUM29JUlNvOTBTbUE0a1hTS3VONmU0Um9OZGxFb3RVMXlNV0MwcHY5WU9GZk5ySUpiKzFpeUpLNFR5cmx1NTdob3A4MllMeVVoc2dKaGJhMGNOSWhvR0E1QytUOEVzeFRNWmRVMzJvWlIvekh6c1VtbndBWUNJQk16b0dxQkJwZ2FjL3MwU1BRdklPWjJGL3BRY0lKNnFUa2NiVC9FOVNmOGkyTWoreTFnajJOVHFnSUFjTTB4d0pPMUkxT1hVa0xzMU9ZQUtzQW9hZmNxaVpiQ2pacHBRNythUkh3OFFuS0N0Z0FNYVRtdlpYd29rclVWdWEvREpkUjhDa3pZUVI1SHdYODZEZ3F5Y294cm9kOTBmSGF1Y3JoNHBJbXRnYmZOQ2UyR0dkS3pERkdDRE5BaVFFVjRCQkhsK0g4bXUyUVB3NWY3bytFWDM3T2xMZS80ckJEbXZKZFQ4R0xsL2RlOHZZZm9YRWs5VGU2WkduQVBhVHVpUGpzL2tmWHVRczBwVDk4U3VCbW9GZkw5RU9Kb0dDTlVxV3NEaHRnL2xIbmVXV2FRU0tDcjdLL0k5V1ZPMVRCb0NYYVJTT1RrdFl4a2o2Z3Y3R2NoMUErcTlXbFlhaFhXa3VrR1JwczVUbDRKdVNzR1h6SUFyOGJRU1NPU3pVdVAvNGdEWUFyZ1NZSjBaWHFyYmFPbjRVVGxoZTRmWUJQbWo4dU5MZXlZZERwdk9BdWVRbk02bHZhcWd6ZHAvNXY0dkFkTGtlYlZNaWdYYnR2MFFzK1JvMTdDL01nOTAxdTI3NXNqN0dGQ3FPdEpHMmlPUHUvVHZkS284YitqTVU0NWQwZDhEdlhoSHVWd0M3MjlOb2t2ZG1OL3NRdTVadGJsWEovQ3QrSy83Yk9yNDlEcG0ya3lSRmR2KzZGZ2RnVTFzUWE3YjBuRWlOdlYxalFkVXFPYnMwcUQwdUw4UWVOMERoREtxbDdvdkt6eFF4K2dkbEFzRXU0eTY2UVoxbVZJaUJ0bWdQenJXeWh5VDVuMFhLdlZKUWZEU2QvNSs0NjMzRU5icGxlUDNnK2VacmxRTVBKRG5Gcy9FN29Qam52enZVdHBRQjVMeVFBMEV5b0Q0UHAzSFRIdHRyaGlSUFcrREhLdGQySHR0eVdES2ZwOWQ3TmZBTGs3TEpqazhvdFJXVTJmQWtKK3FveWE3VHNjZzlybktMZEtnalNtODFkbk1XYi91UWtlOUFmOXJCaHo1Ny9ya2pPTnZIMlN1dEhXZnExNjZMVndIcERMSWRONldnaEttMnVmRjczc1hHQ2lZaHZaSDhZYjR0L0JzNmh0TnU5anB4bmZHMzhSMklQNHhWdEo0TXJsMVBrTUtGcVF1eXl4ckpaMHZ5cDltMlc3L0hqMGVwdS9GMlEzTTd0NWlLQXVWRjFMdkJCS1BxdlVuMitzM2xPY3FnOW5YeWZaSzZSbjJuYzltejlhd1BadUJFODMxV05sTEREQ25QTitsU2x5VUJYMXc4a1o1WTlkd3JkekoybDhDZUdkMWV2S2FUa0xMQm8wTVNFcjZibGFuSjYxelc2OFFIQTN2SVpRRWZuMzQrQWtaeGhyQWVuVjZvZ2VFMHhBN3NKTEVrR3V4T2ozWlZCeVhCRFQzVnFjbkN5MDd2RG85K1gyRWMzMC9RSDcrNy9jUU1pRlk5cFVHM2lGQ3h1NlhFSnljMzdmcnY0K2dNRHhIaU5iL0NvRFByVTVQZm03WDNrTncrcDREK0JaQzV2QVpRbGJzendGOEE4SDVTMk54ckl6akdRSmc5RDI3NXlXQ280MEdid1NjekZFN2xyVmRKZDV2YmE3TitSc05TSmxMUmx4L0I4a3AvWE9rMGpJdjdFZWpLV3AwYWU5eWNoYlpaL1RKMEM2R3RCazZyMkJuQS9UQkNienpPcVFRZDhxaE4yclZlRlJocFVDbktzOWI1R2RRbEppdVY2QmEvWXNDV05xNVFPQnRlb1p2ZEM2b01lUU0wRXo0MlQxdklRUjlyQkFDS1hqdTN4N1MyWUd2KzZQajUxMG9rNmlPbHlwVkFEZ2dQMnQwU29aTUZwRUZaQ1ZhVmJtc2x2b1ZZTXFYUjZ4ZGUrdnpQL29VZWNZTTlwclNTakR3b3RXM21uRXJiUUREK1ZRRlhKM0JyYk5sdDlwT0w4RUt2VG51N0pvTEFRSDVITDViUGx1TlhTcHdtWkVCY1Jpb3dXSFB1QlBGbDgreDl2ZE1tUnFjTWF4ellJNk4yQmNCWDcxUk9uaTMvbDA1Y0pSOFpCZmptUVlUenppcUdjWXhTbDZBOGhtQU03ZTJkSTZML2JZMXRlbFMwTWNjQmlUSWZjVTFLZlBxd2E5NFJwTzdQek9XK3hRbER3Z1loUVNTc0QvOG5qelBad0Y3aWc0NEhXOEJJS3E5bCtZN3MvZXNmYUFSUjJXY0FCSXJ5N1I0a1JyVVU4dEhUU0pyYTZjcUJ6dTB5M1ZIaHlZeloyZHVYNmxSUlgxK1gzNFBNbWhGbm5yUWhoUWRCcHl2Ym5nV0RlVjA1anpxbmowOWx6WTNTRWNVYkpDaWZ2ZVJLaG9vN1FLUzBpaFR3L2djUWNkbmNKVEtoVXZaOS9OT25HdWRjemJiTmU4Z3lPMXJBRDlHZUE4Y3l3TWIrOFArNlBqSDNiT25IOXY3WUZadXJXS0h6MjRCOHV4MFppdVNQN2IyU0N6emJ4OHBBRU1lcTg2dG1JMHY0eVRZdklWRTNudCtidTh6VnA0bzlHV1hQZlVJS1NoZ0gwbkh5eHkxZlNpTHRVQ2hLa2F0bjRYdkl3amJoK29UcFhhVVA1U2Ntd0N5UFJtREdaQXlrZVlpejJNV0VaTE82K1djejRCaE5ENHdkSlpsK3V0ZGdWaENkSHJ0R2I4aE1EN2dxY1l2VmtqT1ZNNEgxejZRWndiRVRGTVpnOG96bmluT1FNakJ1aDlaV3hzRUhuWGRwd29Dbk91MXV3N1NMcC94U3VmVEFXc0QwakVJMk10c0hIMnZ5cE1IN2VzY3VQZnZnV0IxVXZFWmRFQXdjSkE2KzZYY1EvbkllMk1iSTN1Z0tjOXZTcUpUS0JDdTRQaXVkT2VBTWVrdTlZTVNPVm5aZkpiak9hVUtLSk9mNlovbjljcUdEcWZyUllGTC90L2l3N3ZhNXpHUXpMNGlMMW03YTV0MlplVTdadHpNRUhRaTdoUEZHL1pzTEJjUUc2VXZaR2pLczByMnVhN3pKY3htMnNFKzEvSFc5UENhUEdkMU1pM2RYSkxuQzRSNXZLMDhmNERFejZKTll2dzQ2b3Q5T0dxTXNtTGcrSEJZeE14OXpqVjNBRW4wNlo0OXZUUytva0hCRVJPeHo2SURYbTF3SlA1SVhHaUdsRTNNNE5mclBqbjROYkJMZVhYazUySno2VDRaOENwbm45KzFQTis2OWdmNkJFbmt0OXJuTlV3cUN6RFdaN0J0c2UvOS85a3pXNTEzMzA5MURrWkhVS3R0VDhyenBLL0VkM1R1bXZhNWp0SHg3RkkvL1RoSzE2bXNuTG5QZ2NSWGF6ekZ5L05TVWtOeHZoUWZMTFJMdWthd05hbHZzWSsweTRqVlViOXZ0YVhqdTFQWmErUGJLYWxwWXJ2a2FVQitOSk1HUWl2R3BmanFvTktEYjE5NFo5VSs3MTFBV0RlczZCZDFWYWR6WEpJUDJyTWo1b20wWGdhVmdXeE1tYzVRbzRZOGp3R3lNb2NEdmNQTHE5SWE3eE5PcjVXbUJudkdaUGRHK3I5cnNDR1EyNFlESDBhSm5EeVAxVDdkM0ZEUEtOcjczdDVvUFkvenlKSnBlOGdYL2g3QzJiYUhxOU9UYnlJWkNuT0VMTnQzRURKYVh5QVlibitLa0dWN0Jpc1ZYWEhlYnMyUnpNblpvbEplcUpHMVNtSDUwbDl6K1BqSnhlcjA1SDlEY05KK0VhbkVNcytmMWVlcTgvZUJqZmx6Q0tXZ3Y0ZmtsR1gwK2Q5RWNQNzhKOUxlNzhFY3BOS1gxNnZURTVham0zcCszKzhEK0thTVkyT09XcGFubXdOWXJFNVB2bXA5L01qS0twOURuTFlsV3AyZXpOMzNuN2ZmYXdCWHE5TVRPdUlYQ08rYmkrd2RtNU4zRWVicUl4djNGKzMranlIS1RLRlV0OUl1b1B0bjlBYW94TVJLQ3RjRTJpRHhqRDBVU25Eb3M2WVlreFVxTWpFVGR1b0kxcXd1VmVJSDFGQmdCdjNyWGFTdTNPLzVGZm5SMnZvMlJ6QU1Ma3BDU295cEpSSkRWOGNGSGNPdjdMdFpIeUo3R1NGZGMyNFh5WXlTTFZMUXloS0IxNThWeGxLNlgwSEtPUUpQNUdjRW1FcGxjem1tZ2RMU0p5ZVhaaXd3bzJXajM5MlFCbXU2ejh2MGNhN25DSUVNRjM0K2F3QkhuMmNYUjhPdXNINUsvV3FCejJvZzZlZDcxc2RWSjVsenlJMSt2N1kzZlRxN2l1MGRJZ0hSbVRMcCtVQUZBSWcwdHZiYzlTeFhHVXQ5bGNZcGJaZWl6TlZac1VWbC9WZjZGWTExZmE2KzN3YVlSY0FVeUhsTU52OUdMRlhKOHo0MlNCblhOQnByYTFxTmY3LzJJMEFzVGduMlFRMXNsakl2bGtEdmNrZlNWdHBGNFhNNm9MMUJ5V3RpSC9vOHE3Z29Td3JHQnN2R055TmE1WDZDTVZWandQcXdRU3BycEtVc1lYMGVaRE1WU0NQeGk1bVpkMDAxQTZQMU9ZQkZsOHFqY2w5dzNBZXdzZlloUzFiMVVCL1J5MG85OXhGS0ZhOEtlMS9mYTZtODNZRC9FeVNSKzJybGdQY1FaQndETS9tYkdYN3M4NEFxN1VWd1Q3NHZHdlltRzUrN2ZtNWh3YWw5T0xlS1R0cVgrcnlDUE5jeWtmY1ErTzBjd1NuOEZrSXA4U1dBZC9xajQ1Y3lwa2RJVllPbUVIV0dSd2k2T1oxaTUyaFhjdUtZMS8zUk1hdWZ6QUU4dEwvcEVGckRaZkxiK21GWnlRV0djeG1EZTZSZHZ0Y2xiRjN1YUVTVHFGOUZvTHRQWnh5dUVRS2lXTVZwaTNBKzZrVkZqdFQya29JakF3RFU4ZE10Y2o1WkJDTDYzSkZMWGt0K3hCSm4yZGxhU0xKcFVQcXZzQS8zWEx0YTNjYVh5Ry94a1Yza2VaeXJQbVdzOGJ2aSsrMkc1ZVJadFlKTzJEbnFtZDA2MTN3UERIclFqSzJvY3dxUVZpem5LbjNSNy94NTV3cHUwUkVFQlA1NHpyN1U1azE0RUFOREZYRGliK29JUlZ2SStPSzh0MUp2QlhudWRZUllkbG9BUmY2c3UyZFB6NnhmZTBoWlFkcEdER0NWOVY3VDBidzhaOGJDcEpLSktyOXIxL3N4MzVCMzRDN2ErRVhUcmdCa1Y4aHcyWVYyZVllZUN2eVV6Z2tmeEZKcXN5VFBCemFXck8vUy9TVUFmM0NlWDJ1TVloL1NNYUdCSXBSRDFCTVBiWS9xa1VKWjFZNFI0ajVpQlVIS3pzdktXREt5Y1Z5SXpSMnphNld2Mlg3dFU1QWI3N2xHcnV2dTl5RjRUK1U1U3lrVGpMNU5jS1JtMnBKZlVwNmY5M21sSmNxNVdvQ2N0a085Z0hvdGtPVGp0VjN2QTFZQnlhaHlkcEtDOXd2NUgvSTVaUmo1bjY1NzVUL2UxcDQ3dmR6dlY5cDdtVzQ2SnJPbjhJclNYbkI4ditvYzdZWUJpYm9uWXpCaDVmNWFpZlVZc09MNk9BTnVWb1ZwaEQveDcxS0o1ZEk5ZnEyVXlKZTR6K2FZNzlyMDVLWThGMTR5YzU5RmZjLzBlRHExZ055bW55RmZ0N1NMYXppd2wrZExoS0R6b2g3dDd0MGk2SExrRFhva2tPcUxQQnJVQi81cFgwZWY1OFo3NThIVXU1TFQrZldkTHJzVWRLdEh3dEd2RS9VdDBSZlZQNlc2UGZHNmdVeFh1NEIvVTNjVGVUbXdKUXI3bzRpcDlhbUtHUG1wRDZEUjN4bnRJczlSRGlEZG9pd0RXVmxCOTJWMUxZaHNWSjIyNXZmUUlFcitQemxwc1V0VnUzaCsvUXdCajczb0twVyszUDFiV0dDK3JZc0h5UEVMNnZNZW80bHlDQzZqM09ObVJqTUFjd3JpOTFlbkozdXIwNU43Q0k2L1h3SHdkUVRRNGo2QzA1Qkcxd2NJcFo2L2hiQW92by9nL0wwd1IyUE4rUXNBYzNOczBpblpjaHJXYUF2ZzJ0KzNPajJabVJOeURlQUhBUDRFd2JINkIzTFpGNUNpK2pZSVpZbS9aMlA1Vi9ZL25TSjBrTnkzTWY0NXdzVFMyZjB2RVp5aU00UnM1S1U1dG9FQXh2RHMzREZpZE16MjhQRVRkZWJPa0djRlBrRElSSDRQd0s4aW5LZjcrV0Z6T2FuejE4cDQ4eUIySUN6UWQ2M3RTNFN6aW4vTGZ2K25BSDRid0c4QytBMEF2NGJnZkg3TG5rdG1SZ2FoNDQ5a254MjQrZm1NUG1GeUlGWkdUaWxhVUppWGpFZ0NIMTNJYWkyMjZRUWlIYUpWZzlTM1lmL3ZWZTZKQ3IvMWc0RGxsWXl4Nm93bzBBeEJvR1JsMWhzSzVOSmZpOEI4MzBiZ25ROFJlTXhjN3VFZWdYMVBRUGhuU0dYWFk4WVdBcEI3amJBdkh5SXBUWU1ENVd2dnFVQTArZzc0OXcxQWdnTUUvbkVQd1FGeDJhVk1GcVdGK3hrb0crNHpYamVYL3QySWJEMWN3VEs0Z0V4SjhzWVQrMUZjdzM1Y3poQUFrc09scUNCWUd4dlpNNFAyYkwreGIzTzkxLzZrd2MxclMzc3lVN1QrNy84dUc2OHFQNE95aWRxRzdaOEZ3aG5EZTI1ZlVnN3QxL2dJeDhUbldac2x3SFVYTUV1QitFMWx2YUZQRHNMUy9ReFVJRkJKQUhZd243V3gyVGl1dTJkUEwyemRad2FidkY5ZFc5Y3RvRmp1WjNSNUJNdWtEYTZ2TFhKKzYvZFFTYW5XY1NtZklLRGorOEc1VXNmcVJzYWdZTDlHRjdNL1U0TTJZaW0ya2JYazMwL2NJL0lPbHc0VVlVQUszemZIczdScngzZ2U1VWsxazNBWGt2MWQrNTVHbTVjcDhYdit1SzgyZm8vSysxUDUrd0NwYXNzK0VNc2NjVzBSL0h0bDkyVWxROVU0NjlQWm5YdEk1eEtWWkdVbWsrenZBd2Q0eFhIQWpFL3IxeFVDRUVCUU5UcTRTdlBqNW9ycitnQUJtSjNpNE5ydmo0NlZweEhVK3dLU2Jud0kyUys5Wlp2YVBlOGoyRVRuQ01mTS9Oait2a0RRNjdsL3I2MWZqNURtbUU3Y0Eybjd3UFVuSTltSFBKZVVlMkpQUUtiU2VzbmFzSFlJdFBMbjNQamJXdHFoYzVWNlI4bFkzN2pQVk4rWnVmOTNwVmYyOHhvcFk1M3lqRHhmYlNaL3hOQVk2ZjRoSHk0RnRISGNhK0dKbmovTTdOMHhxNEhaVmRSVFZSYlBFZmpSWU44WEFCczYzdmtPK0FNSVlPUmtKUUdtZ2Y0dDY0UGxSOGZrdVlKV0pYbmV5dER5WTlNK2VzZUR5aW5PSVVuM0ovZlRIdEljUGtEWVI5bDhXbnNsL1c2TndHZGUyNXJYZnFrODN5Qmx6Vjd0S004OUtCVURKcEhMY3dYKzlGcXRxT0RuVjJYakFzSkRoSzRSK0JCQmRJNlphNWR6ZGRVTmdmMXFaWjhDc2UvRnVaWStEL2lTc3oxbktpLzlYTGZhcmhIZllXRjhiNHh1MHM5ZDJtN29CSkh1UW5jWjZVZVJ4Nm9PTFBzb2N3aE5uUi9aRzhydlJ2dFY2QnYxUDlxWUpXY1QvMmF3MHhwQmpwOGo4Q2p5Z0tpTEl6bFlOT0Fqa3o5ajlybkljMjJIbU1Ua2RXVHRLQWdNSkhsK1RWM0taQk1kemJWK2tlK1JOQ2h5am9STDNvUmVJd1g1TVhrZ1ZtZ3lYcTRPanlLV1UrSER1a2JZL2d4SXh4MzFLZWhJZWZ1bDllbkt6ZmtDUVQ4a0poRXI0WFM1Y3h6Mm5EMmJYOS9QdGV1djZnRCtQZmhnb2F3TjNsZXlXd3Y0eElBY0ZwSmwvRG9kZUhCZlJZNTZSOVBBMmFUNEJ0dHdiWEV2cWE1Q0orUXV1aHpuYVNydm00UkR5TGcyN25NZmtEM0cyekxlcUY4b254QU1wZFlQT3ZIb0RDSi81YnFtZnFUM1hXTjYwQVo1WEJNajdJZFlLSFZGenNNK2d0MjNrTG02UWdvUVVIdGlobW4yT2NjOEpaaDdsR3dNVFd5NnBrUEtXaTRkNzFLeno0RjhyWGdiVE9VbHh4b3hSbTh2cUgyT3BET1B5Y3VTL0J2WUl2YTV0ODlMZURzd3pUNlBkczlJLy9TZUVnK2dETktFcTh5KzBmdVJyN09TMDFxZHd2cXVvNzVRYXJ0QjFEZlVEbXppcGhYYVI3QnI3aUhncVplVTVhNC9HaEFMRFBWMnIwZHpuODQ1Z1NzazU5NXJCRkRpeXdnT1VIckEzN0lPL1FuQ0p2NjZ0ZmNqdUxUOVJqYm8zTnA1RHVUT3lhbGtKWXZISWovNDdCOGpPRkRvV0hnWHdXbExiL3BMQk9jdko0UVR5UkpUZklrZkk0enZFQ25yK2JtMXBabGdNenNqZUFQZ1h3RDRleE9HOUUwQUh4Ym1pMkFSenhKanRpV3pDOTVDS01rOGlRbUs4NVZqNGJsblZNZzJDRm5PdjRXOGZQYjdTT1hzN2lNNG9TOFJ5bDd6WGlxd0hnamkrNktpUnlmOUd6Vk9mcG1wSUVqZWFQdUZaeldqZWdyRXZUSjREaVl5ZVJVa0R1Q2NZWmhodkVWUURMTklaL3VmMlE5Wm1jTVJHaWk5ZlNwMVdEcG9uWVlLOS93K3duNGs3K0FaeFhyZnRSUCtNeVJlb2hGdEt3UitTbDUxZ0xCUHVhZXVnSFRlamMzWmdmVW5nbGhtNUdqWlpSbzdOR2lwZlBFTXVUMmdmTjZpRS9BenBIY2RoUzducUU4bEZDSDNBTW1KR1pYYkxtV3ZxZU5UblEwMzNnY2xRd1REVEF1ZTl6SFpZT2hTNU9iR3ZjK01hb0xlangzSjJSQUJRRGRtRmVnYThWYnM3eC84OS8vRDdJc2ZMREdmei9EaHg5ZWJpOHZ0NWovNm4vNUhyZ2w5dHlXblBDa0RJdVg5Uk9PMTlWNXNqckwyKzVSNXNvV2MrM1FUYXF5TGVlbDdNWlQwdlNpZ2tXV1VGdTdOSE5DVlBwRlhzY1QxSldUL0VkUndiVE5qTURObWVpazdnMlNreDdLNU9oNmxDUUNuYjdkSXJYWmsvU3Q0VURSb1c5VEoyWGxBODV5VlRFNzFsdDNsZ0E3eVUrMkhSaGZyTmZjUUtqV2MxZnJiM1dFWnFENWxKRERMdGtWUnBuajVYSkhaUEVNb251MWtYOWNxVk5EUkVubXhHbzk5S2tWMzBLZXpaN1FQMUlzVmxJMlpMcTZQRzZRTWg3VmNyKzhHY3UyaVQ1bmtjL3QvMWlVblZqVjZYY25XSjRFUU92NTUvLzArWkRmSHFHeDVQdnU3UllyYTlSVkdkTTlGdmFCUHpxcDdDTUZjQkFEcGZEbEgwS0VmSVRkRWdXQS9YTUNDUlkyUHZHZmYvUlJTUHQvR3AxSEFYS2VjRDJZTUVualpvckRtbkR6WG9CUFZxNjZsSFFXMEZmUm1lM1JtWitYamtNdVJKczlwa2IzdjBwcm1lV0hrU1M4UjNzRmxTWTlwVUxhZUNzQmNDU3psZHd4MDh0bVE3Ri9rUzZJUFU1WkdNQmVGQURJK1Z3Qkd2blB0QTlmbTNIMWVIWi9SclBKNTYzNDk2NUI4QnlqcnlMdklBeStmMlRldWwzZ2tndlNkZ0JqWEhyUGVTaGtvVmZsZWszVVQ1SGtwUTV0Z1R3VEg3SE4rSC9lQTJpM3lITDhPcDhoenlrTGlGL0VlYVMvakFjWlAyWCtkMDB5Tzd5alA5U3pEeVd1ckFHUVZlVVN0TDg1bW5QU2MyMUpKUnIvSjV6WDBsTkZuM0RXT29Eb29iTzAxZE9KWmJkL1p2WlBlV3k5bkZicm5ML3VRcFZxeTgvU1pQbk16dGwzNkc4SkhFUFlPOXlsNTdUVnlCNnJhbW5SdXFHMUx1Unl6MjR4L3prV2VxeXhRbVV6OUpiT3psVlNQeGhETG9JMnU1NERPM1RYZTJjd2dHclZkdEczUG4zY2ltMnQvbENEbG9WWWV1a0E2dG1PcVBHY1ZoQmlzQStGLzhqNzR2S3N1MStQMmdWUnhEZmtjeGNDbmdoMEpKSDJ6NUF6eXVvTHFxR3lYMmViUm5tbnNqd3pMdUlGandjdkZ6TUZ5VzNrT1pEcVBYeS9aM3BlNVV0d3V3dyttUG50TVR2QWF5dVJXdTE1ZWEzOTl1MnFqNlhoY2s1T2NyeFBzOHhJUFVIa2U5NnJKWmNyelhiSVlhWWVSejlZcWRXWFlDSFVBNFJtOHh0dWNQdnNYeURISlFVVStOLzQ3OFI4SUxyVkJvWkpsNGZyUktwcXlUcmpIbHdqT1lEcFJMOTI2MGZGbitwTmJSL3c5eUVpMXVWOGluOCtXREk2Nlk1Y0NVd2UyaUdBdWRBNTdIa2Y3bklHYXpUWG14dXVyRHN4UnlVSzIvbE1tYXpXTzB2eVU1TG55YUNYZVB5OWNDNWh2eiswNXJjU25mZE85U1g2bjczUWZGaERlRC9GNUhhZTN6OCtSVjVOZ1JyM2FrMzVzTVNqYThXQWZBQlNGemdzRWgrSjdDRTY5enlFSXpyK3dCaGtSQndTbjQwT0VMT0EvQi9EL3QvY3RQWklsMTNuZnpjeDZkZmMwT2MzaGtDSkJpaElFdzVZWDlzS0E3RTBhSnVDbGYwUXZ2UEtxVm1YRGhwcTFNT0QycGhjR0JBZ3dVRC9CUDhDQUY5ZUFEQUVFWWRpU1FGazJKWWhEV1o3cG1lN2hkRmRsUFRLdkZuRytpTytlR3hIM1psWlZqeWo2QUlXcXlyeVBlSjdIZHg3eFNoMTZjcVpzanRaSWpzZWQ2ZkRwc3pYUC8zV2Y2OFJyU2JudlN0c1pBYWRnekRXQ2M1UFBZK20zRlZLR3hCekI2VXNIeWhYNlo5dnErY2tBOE44Um5LVGZ0L2RyK1FPbFAwSytGT3REaERraHMvd2NJVVA1RTRUeC93UVp4N0cxUVNPRDEwaGx1VGNBUHVYODJMM1hkTml2ems1L2JIMy9UZlNkd0VmMjh5djIvNFdOamJhYkVSazVKdERKdXRoSmNmeWJTQTdrQVhEM1Jwc1NqWC9VRGZSSkFJQXdrcXpDSzVSOW56ZmVuVUcyYVk5UGFobFlMQy9JQ0U4NmZ4aWg3MHVTMUl6MW10RHl5bDRzNjJHZlVjRHp1cGVRY3hmbEhmcCtHaVNYU0tVam8yQzF6eStSaE5QSEhJZGxQOXFMODNtbDcyaERkaExRZHdyUUVGb2o3TzhHSm94RUlTNk5FYU8xQ0x5ZEl5a0t6SVJpU1VueVZGVkVQQ0EwQTNwbGZXS21ERExPeDd2WUQzN2M1RE5mb3FWS1ZIcHEzN3ZuKys5NmU4SEdYaDB6L3R3dXpxRXFPY1YyZnZPRFJmUGhrMFh6NkovL29GUk9oVzBaTzVQWlI0d0JTV2FPR2hMNmJGRlVWTjVxRk90Vzg1dTdua0F2OHM0b0pTcmxZRnR5aHJyYmI5VjIycnVQa09icVppa09DTm1QTU1EcVd2aEdWRDdiNUNSV25rZWdUY3M2enlmTTM0RDgvR082QTJEd25EYVVGWjY4WnlBWjZONElzYjlaRXJVSDRIdis3NHlGS2FUT096ckZnTzBjSUpQSTJzVzV2bDZHU00yTjhlZVNveUVhTWlLYi9YYzFJaGdaeDFYV0xIVjc2cDI1c3A5Syt0MmdGRFNTZk9ydE5TRnZHR2w3MW0wb25WcDZOOHZpVXMvZVE1QVI1MkkwTTN1L2FpaWFmTDUyNnpPWEdURURzTDk4OFR5ZWVkeW03QjllK3hwcDNGVHVhajhZRU1wekFvK1Fzb1VvWno5R2tuUC9GMzF3VWgwME53aDZmb01BR2pSSWdLeUNtVEdTSHYzQU13VkthMk90VGtoMVZCNGl6T1BLL3ZkQU44ZlRWOVlBa2s2Z1FFUnYvYlRCU1ZZTnVCSjVVVHdHWXVsSzFoR29XTDU0L29iUHVDMW82UHRYa09lOU5TWDdIWkJnQ2RuTGZuNG04YUVDb0tqWlNyVjluUU1ORzhnOGplakhDdGdwUDFld05nYjA3Q0RQdmUyekZ0N1Y0eVgrSFFaT0VjRHJrQzhoR0FIbkxlVDVFK3Z6T1lieS9BZ1dLSUhnL0NhZ3gvRmNJTXhONzB4TEk4cjZHTlNGcEFkc2RkekE4a1hQeVExc1dhYk9mc2Z4MkZLZVI0Qlp2b3F5MWExTHpSQ3JqZm1VZGcvMjRIM2F5d0tDOXdJKzcvbWRZMEZPOS9idU1YTHpPR28zdDFMR3RKWEF4UnIvejd4ejByWGtTeG5iUTlkaXpJU3RQSXIzcTAxTy9rdCtyWTdoQzdlZk5QT3VhMFBnYllQa09LUzhWdElnSDY2NW04TCs4cVFPV3VValVaNmpuMm5MZDZtVFRjZUYvWm9KZjFYY1V1MnNISS9ya1FMUU5aMnRIWmFQanlXbzI1QUZWanh1d2Iybmg0ZTQ3OVg1Ry9VUXg3LzFQU3F2Ry9jM2RVS3VENjZYMGZXYTJ6K20rNnBkVTNJT2xIanBOanpVN3hFZ3JlOUdQNzhEZWE2TzNjR3ozUE5wRDBjOTg0NzRuZktBWFBuVVhGdjBua0hnaitNdGVpYnd6UFNOSE41VXBJdzgxemJVN3VzNXROdmtlQnpWN1VyOTROL3lPWU5qYVh1UjMrVWNrZFFOMVFZbzdRbTJkWTBVVUFpNTk4NUk3QXF1YTlwUHhVb25HZnZjNDhIUTcvVmV1NTcyVUM2b084YzNhdjFXckdSdldTNG5YRm96QThjbEVpL2hrUzZsZWRJQVEvN05wQ05pRElPRW9CeFZjS3RldThtdmx5bElpbnRROFR0aUxEV2RpVzFtbTNMK2lBMFMvL2RZU3E3YWxiWlRzN2Mxb0l2M3NlTHdwYnUzMUY0R24zSnRYTWovQjdEUzdFajJPZHVrUVJVNURKRmpGTE4vQVd3SUJtd1FuQmVIQUw2RG9FVDhCQUhjT0VBNkorcnJDRTdBbnlLVVdlWTVzTDJzMzFKWlozTkFYdVMrMjRGNjc2Q0Q4ZkRwTXpvYjUwaG4rTDVuZldMazJYdEFQRlNaay9mUXZtUEs5U3VFQ1oxYm16c0U1emduZDdEUnJOL2Q2dXlVWU15bkFQNFR3cm01RndnVHhyOWg3Zm1KanBlZHlmc05oRExQUUppRHY3VDJmMkdmc1dUSjBlcnM5RnpPVlo0aGxhRWw2UGNTd0VYR1NUOWpOcTY4L3pXQUh5RVl2djhJNVZLc2Z3VGdqWnZuNHZsanVpNHNRL3FYbm1SRHZtdURMbXZzYjZ2d0xjWDVXUG1lUWczSU8rQnF6eStCZjNTYWNkOTZrTGZUK3czY21FTWNDNlNjMGNoNzdSMExaM2pFODBya0hncWtGUXpZdFhjT2pDTXhRbGc2K0JBSnZGMGc4Q1dDd20rUnp2YXJqWk1xOHdkSWdKZzNSSzlnV2MwSWZQRUxFWFMxN0xRT2ZVV09BcWF6NTVBL1V0QnlUdGhIbjFsTVpVOUxBeldaOTB5bVhZMFZVbUV2VkIwTkJlSTZLemxnbVZrMWVEZkJFcThvWWdpK3pnbWsyODlzYjlIZ1Y3KzkzejErTkdzVzgyYUtBVnJMOHN5TkJaMGkxekJGYndzUVJ5T2RlZjdmTGxITFJhSVJsSnVyaklFWmxhdUMwcDU3UlRaTFMrN2htczFkbzFHQWFteHJjQVlnRVpqT0tNKzFiMmVaWWMvdUFjQ0ZhMnJPOXFudlVtTVFDR3ZuMm4xR1V2NWRkV2JZZUt1UldicFdIVVVYVXd5VVhjakc1Q0VTcUxiWEhwKzhYWVlJMlNLd254bmZEbjFuK0t6dForNzcrNWx0djBaWU53cnFIU0JsVDZ6OW52ZHp2QXhSMytkSTRLQW44bnp1Wnc5UTlzNHpiZDI1NUNXZUk0WXk5NGZ1STVYbm1wRnlhSURob0h3c1FwQ1d6MkMrdGpIVnJLRU93VkhqTXpOb0hLMldMNTVmeWxndE1pQWxrT1QzRlN6REhFRjI3eVBvNGJpUVpMb0FBQ0FBU1VSQlZKVGxueURvOHE4cVFHZ0g0RnprSXVYckd1SW90cmw2ZzdUbW1Ibkk4UjZOWmtlZkYvRTMrVHhMVnlzb3FNRVUxMnl2emQwK0VtQ2NJM1VlWjNsS0JueXJaUjVraWM4cHlMQnM1WVFSeWptNllKK1Z6cUhVVE9nSXdra2ZmVVlTSGVPVUNhcEREUHFSMFErQVNvWlVZU3hZTHZqRzNyK0xQT2VlNVI3MDJlMjMwY3VVSjlXcWNIQzhOc2dFRnVUMEF0SHR4dmpSWmVFYUJhbFZoaEhNOUpINEtzOTdjbGQwaDUzT09UUnFrSUpPUzRGR00vUXJ6K2gzMjhoekJhZGlRS1FIUTlFUENzbUJhRDN5NE9wVTJsWGZuMEp0UHlzdVZpbTV6M2NhWmJOamIydmp2R1BTTmNEOVVxUlMzMHA4ZTVrY3F6NzRmRk1aSjYrZmxQWWJkUkRxQWtDeWJZbXBYY3QzMWNBTmtRZTAvWW1wcVR6ZkdLakxjK3o1enZoOTVSWGV2dEc5eG5lUlIraFJESEhNSUU1VDA4OFA3S2RYemxqdVU1dW1TdlpNVm5BcE92UzhYR3Y3UVNuZStUdERzSU05ejY4RmFKUHZkeERuc3J5UCtwOXZCNitMWTdmc094MThNTndNUWYrbmpJd1pXam44U2RjazB0d1ZaVk9sYjBCR3Q2cVJ3MTlVejZ0ZGZ4dDVQcVpqS0I0NkdYdVpJRHNWWThwU2dTZGsxM2hHM3UzU3BscGJxK1BsY1V2QmtDYnRTWGtPZFZSMWJQYXlpS1ZOTS9sZHczMlpDWnl6OGYyMVBWeXdoTlBlbG9UM2twcjIrR1IvR1hEUEtvYnQvNWU1ajRFNmxWZFREczZSc0dQRmV6d1c0L1hVWHRDVThhS1NQRlhIUHpEY1B4dkhhM3pmeHZSaGRiejI3bmQ4a0pXL3N2d09lYnc5Qmk0NHZKMlo2TndMUFZrblk1T3RubWFrTmxoTU1CQTdnUC96K2RWcUV4azVGSk1iWEg4dUVXVG9OUXp6bC9IZnRrSVZmeWlEOUgxekRQbW1kelRQRU96cDNub0F4TUYzK1BUWjI5WFo2ZjlDeVA2OFFIQWNQcktYOHR4S0lKd0YrM3NJenNnWmdObnE3RFNtTndQVkV0QjNScmt5d255bk9VTy9BdUNmSWppdGY0amdzSjRqT0RmSkRHaVFNOFA1Q3NEZnNXdGZJZ3cwenhaaXRtdmNDSlUrY2pQdUl5eW9qNng5YXdBZlNjWnRicHh1RURJR1h0bjcxNGRQbjExWXYxWklKWmRuQ1BOeWFVN2pKd0MraDVDOURRUkg4Q2NJRHQyVnZzdk9BaDRJUkd2VGE0UXkzeisxWnkxc1RINEZhWE5jKzN0enREbzduV1htcVNxSWY0bW9WdnJ5UGluT3gyMmRNR050RjJYZ1RnM1hFcENSZXdkQklDU2dDQ0tJaTRhcEFSdWFlYWVsRG1jd3dLa04yYTlyaEVoZ3ZwL25KRjRUeExSM1BrUUFkUzhSK09rTVlaL1RVVUZnWFEyUFNYTmt5aE96Q2NnZnREODBNbStRempXYUFvNVN5ZEdJYUFyTENKb3ZROVkxeXpaNTU0QzJReDM0RkdiTWt0c0pZT0g0NW9DVEhZbU9xd0h3VUxxaFRTVlNzOEk5Wnp4NThDTHpXWS9FbU9heEFMT213ZEY4aHB2MXVydVl6KzdNcCtxcFEzTG9zNHlZUnF4U1NWUHdOMzdXcHNobFgrcDlKL0pqTk1iSGRJMXpYMDBCSXVUZXNiYXl4Ry9PaUx4R3lycFRaZi9TQVFBM2JRb2NBUW9aY0FYZU4xcnBRUHJTVExrV0dUa3RvS2dHYkpUZTVRTjBlQit6dTVUNFB5Tkw1d2p6bGQxTHppanB0YlBHeis3YXNCUmlKUWVnN3lqZEpVdWJ4bndNbmxKd0lyTys5QjJVQVhHZWxxbWM3K0JkL25QWnY5bXhhME1RMFI0a2tNTzFYWWtBM3BTQUZPL0lwVU1qNjJDenVkOG5BR2lPQ1VieGxzaVhES1l4RlROODdidlBFWUJZclc3RDg1TlhJcy9wb0gySU1BZnYyN1dmMmpNSkZETkttY2VsMExFNU5pNFBrQUsydUc5MHpHK1F6c1hkczcrcnpoNTNyK28vQkx4WnlXQm1iVDYzc2JoQjVweFhJUEV0cEFocUdxZDhablhmVVg2b2c4WFcvaHdKNUIwRjJTWUNnSk5KOXNaa2dNL0pOanBJcVN1V2RGTm1uZk1vb1FNRTJYQ2Z0Z0hsK1FhcHNnZmwrWjYxWVFQUmFVWEc5T1E1VW1iQllMMXRBZURHSXhLVUova3hsclpvUlpyTDJyc0tuNCsxaTBlbDVPYVpWWWVvYTZzOG44bG5ESFNyeW5QMGo0ZUI5RzkwL25Xc1NnQ2VVZFM5bk43azkyd04vR2ZaYi9LTzNqTmRXN2lXZ0lrNm45aHBPWWY5bCtuNC9OS3dpdHZhNTE4V1pRQm1IeVJRSlFleTEyd2gzU01xeXhUMFpSbEh0VTFZVGNTZlRheUFMdlVESHJOQWZyNlc1MjRqVjZpWE1XZ2xKOC9QMGQrUFU5Yy81VzNNV0xjMmMzL1BqRzlmSXNtYWtqeG5VSnc2aTJuL000aDN6RW5vYlF6cUdsWE1xeVRQTTlmcldPbzFOUjRZczFDWC9Zb083Q1BiN05kSnhJSWdtVk8rVFZ6emJUcGptTS9VVEw5ZVh5dHRuVXlxcDVBUDZ6aTJmU2ZmV25pMTJ1ZTZib3JsMlc4aHo2czJkRVp2Mm9vbXRxdm00QnFjYnl4MlF2emYycXFCZmJuQWxNSGFhQXNPTVU5aVgwL0N3VEs4UWRkZGRDNFc3czBGK1NvUEpROG5MMUpINXBoOXppQnRQZDVNM3h2WG9ydHY2N21mU0RtY2Q2ZjlKL3VxUTdKeE5hTlhuYll4d0svUWpscFZoRUV5Z3F5ZlhJSUpzM2l6U1NpWk5UazVHTjdQOHhqR0luSjBHN3k5ZDh3WmtpMGZreTN0dXlzWTNpenRJZllhRTUrRXh6VnlUZVF2bWIycStQYm9PblQ0VnU0KytoYUpkVi9MZmRWS2trankxc3Z6R0JodjdiL0F5REdHeTRTVmNiK3puUjJBYm5INDlObW52TmdjaEgvb25JV01hcjlCS0YvMkFRSlFRR2Nrenpqck5hRGcvSHNuWkk3TURRSW84aEFKdkNaZ2NvRjBsaTdzTXk2Z1R4R2NNanpMa3lWUGdYNGFmSTFCYzFIRXN4NDVGcFh5MkxIdEdKYUcwKzl1N0Jsc0w4OEtmb0l3TjNzSVplVE9FVEtIVndqT3B2WHE3TFN6dmcraUVQVWQ1bWorMk1aaUErQm5BUDZlWGZKdGU4K1QxZG5wTlVMbWIrZWM3ekVidXRiWFgzSnFNQUp3M1FkNXhWb1VHaCt0ZWlkR3QyZE1PZURzTnUrc0NTTkhQVWNFbFpUYWZVNnhtaVB4dVI2alg3NTRIc0hpTnAwcndkSWZXaFpDZ1ZZYWdlZkluRmVENUd4N2FJWWJzM3A2WmFobERJQjByaTNCMDhXeW4zSEpmVDhLTE5uYTJFUGlrVytYN3Z3TmF4ZWROZ2ZMa0RFMWVuNm1VMjZpMDN1a1RSUzRRRjU1N0Nuc3Q2UU9FeU5RMjFUT1Y4dFk4enZ5YVNvL3ZiV1QyWXRURlA4YkFGM1RZTkYxbUhVZEZyTlpzM3I4YUw2NFdYZlliRWFqRXJjaWEwODhzNmtkWmlScXFjdnNmcUpoSjhZZ01HSVFibUZzUmdNK0J5QWFLVENyNE9JUkVrRHZ6NlhTWjFYYlVycFg3by9sT3R0K09hd0JpTkFPeStaTkFWQW5CVlZONll0ZWx6RVNJcUF6WVg1OFA2TUJzRXhPQkFVaU9vUU1lZTZuYWxhVUdGZTU5OUl3dXkrRDBwT3U2WTM4VEtLY0RPTjR1T3NHZXVmeXhmT1ZBQmgwZ3BMUHY3WFBEMHpQdUhiMzFpSm5CN1NVb0NocFU4bFpzUk12bmlqUHZZTkFRWWFzL0hIZ2tnWU9lTkJwdmJSU3d2Wjh5dWs1WEVrcWVkWkR1MllQUVFaL2xwSG5Od2g2K2tNQWI5cmprOCtzRFE4UVpHdFBQN0Y3Q1RMUEViSktXRUtlWTZ1bG9VZjVxY2x6QmlwY1pBeDcya0ZkYXhIeWJUaUtZNHBNMHVqelFjYTVlNDhDekExQ0tWMTlCOWQrZFExdG9TdE8xaWtkY0pDdEdpTWdVUEdvRHdGa3hnSzdhSXozUUpMYkFMRDJ2bXhXcnowak9qY3hMSUYzaUg2dzR5Q2JYT1E1OVdLZ292ZTFsVktocWhPSXZrUmk2Y0VvdTBXUHpSM2Y4QVFKb1A4czE1YUo4dnh0NWJzT29ab0VkUjQ5R2lQblZCa0VTNms4ei9TQjYyOEtNTGVOUEYrM2Rpek9zaC9vMDJDYXJzdjE2WC9pTzFSM3NjOFVBTVNVdG1hdTRkcjRNcHpBMmIxOVY1VGpDVjRIa0xIVDhielgwdGQzVFdQdFZSM1hmVGJKUHZkT3Bvd2U1YXNTOURLbE1vOG1vQXowajRsUS9ZbllHd082Q1BET0M3SlBLMnJRR1VvWnkvWVQweHRrSytmNkwxZ0RFTXJmK3lvdlBQNmpNMXRuaFg2Z2VvbVl0Y1F4clZheUViN050ZXJ0ZWM3QlhjbHpmVzZWakQvN2R2QTcyaHJaNzkzekk2OGNzY2Q4Qm1YUDd1UmUyQVhucXVnRXRXZXBMRmtnVmFuVHRubm5aZ3hBeUxVRFNjWVdjVHdrZXp4V0phcU1XOVorMVdkTndQZUtOR1lINnR3b3YwWGVMb3E4Sm1lZkYrVDVKRnRvYWg5Rm5tdUZBaUR4RjU4dDJTUFBMNFhpZW1oVHlXZHRtNVo0bnBLc3NORm5HS25ldjlXeEY3Y2c5bFdEUFc1cm4zc2JYNTExa091dU12WjU1S3VpejI1eTY3Um1uMmZzajV4OVhzdU0zV1VjZ0duMnVWYm5JTjZPMnZ1a2pjbzd1MlVGRjNIeTNLKzF4djN3czFqQnlyV1pSMUhGNEFiRjBOMDdlUStmeWFQWmJtUi9NYkhVdjZmSEQ0U1A3Q1BnQXhzQVA4L0ljMVllNmRwVUJueDBEd2xXRm9PUjJQZHN4THhtcFZyMjZjWHE3SlFHMVg4QjhNOFFzbVIvaHVEQStEaVR5WHBYWVB4V1pBN0lod0ErQlBEN0NBUDJFaW02R2toQS9CeUlad3F6dlBJZkk1enRxMHgxWXlXbDl4QUFtOGYyekpLaCtOQ3VKVEE4TTZkcWcrQThQVGZuNlFhVkNiUk0zVjZtc1R2amwxblhQSi80ZnlCa0JYK09VRzd1QWdtY1ljUmhCSXdxR2N6Y1pHc0VRR0FGNEErczdWOUZ5RFIrYVdQeHB3QStsdExPVDZ4L3I2WGZmQ1lBTk84aVEvd1hnRFRDNDUyT2hRcU9aWXJZbWRTR2toQ1lDTndDNWY1R1E5L2FWVzFQV3lpL1VDQTZxWmo5eHlpZ1dvU2NqOVM1ZE44M1NPZjVLS0JHTUdnRHhQUE1HZ051ZWJZZVM5RFBFUFpYem5GS1o0S1BGQjVFcUVLVWh6Wmx4aTFnVG1DWUFkZW1jbzBQRUhqWHBUY2cySWMybFRka1Ztc09sR0wxaEVld2lHb2tnM0ZzUGVsN3EzdEE1cHI5V3FIZjV0bnl4Zk9kTTJZeWltd0g1RXVsWitnQndqbzRoQ3Z2S1Vyd3BETmJweGdBODFuVGRlZ3U5aGZOL0dCLzFzd1hXRDM1eW1LenY5ODhXdDkwankrdk5pOS8vK1Jmcm4vcitiOGJWUmhMTkxLWHZUS3BqajdOY3ZYQXVYZTZqTGFoWmx6SXZ6Uys0cGw2cHV3UTJNdzZJOXArT2NOY05PeDlrQ3FvSlVPN1Y5YUpOQUtnM1l1ajA4L2hsdnVMZW9uWEF6VTZGc2dEdnBONFNHbDl3Z1ZpM0lhbTdCbmpyZWRJK3ZSMWJVNEtqcU1wUVA2Z1Q3YU9aMGhPd0JYU2VjY0VlNmozbFdod3JyVEpscGtIL3B4eHFRNmJITWlhQ3lMSWtwUG5ZM04zd09jdnhkSGFWa29HTzNrK0NKS3B5SE5tckY4akJDZ3NyRDgzSnM5Sk02UWpaODRoUnpjNEVHaUJQbUNqd1RVRWMyOEVHSWExaVdBekhlNVhiU3JYeURYQTh3Z0hRVWh0djF3eGVaNGZaNWFoUEVJQWUyakk5ektXUFpCbmE0eDZCd0dpR29ESWNaN0x0ZFJmRmdnUjNsUEtXR2NwdDcvYTRQeWFJdiswYkdZdTByNEg2TlpJOTVNSGdPVXlybC9xNExFNmkxMWZBNERpZDVrKysva2FsRjR6OG1BOUFWdk9Fek5zYy9JOEJ1U1Z4a0RXY0RheXZnRG9FS1FoaUVLQWVtUDd6Z2NNRU9oWFI4cTlrQnRuT245MWYzczlmaERjT0NMTE85d2ZNT3JCdEcxa3BHK1RCOEd5V1N2Q0s2WTZ0RDFOM205M1RQZiszcG9EUmI0ck9YMysybFBGMFZDOXJ0WjNkNDllbTlPTmNuYU1ZaDA5L1VSc0NKVzdETHp5cGZ1QkJEcjdzOTBIYlJRSEN1WEtBa0cySGlIc3k1WHBhWHNJY3Y2S3VsZEc1NktkcFNCK2pyOFNNS1kreUtNYWNtZWxSMXIyczhrNERsbWVKUEtjY3IrWDhVcUhrZGNqcDFKQmRoRVhpWHBOUVRkbWNDOGRMUWV3T2VDYzJQMmxha3NhY0pFTjZpekljdzJZN2VES1JNdnpjdTB0eVhPL0JnYlB5T3dKVXFQWFdOKzl2cTdyZmdxR1Y1UG4rbXpGR2RuLzN2V0ZzVkM3OFYzeE8yK3I1dm9ZN1ZmOXNJWlZ0UG1qWSs2Q05zdUN6bGNqd2FWNnptNDRIcHk1QnRqT1BzOVZGV0ViN3lSSm9hWWZDekdaUnVlM0d0QlNzODhMZGtTV2g3UXBBSVh2MjZCZmphQVV5SzRCWUt5eU03RFBmVDl5ZklMdmNwK3JmVDRhTE4vMmd6Mm40TzFxSzhXQXc0cDk3bm1hZDM1R1IrK3k3NUR0QlNZNis1dzJxY3F4M05FQlNsbTh5dHFnV0VhMDU2UWRDNXZ2YnZuaStZWFo1L1FGbmdNNHovQkhiNThySnVuM0NJT2lENjJ2bTh4NFRLSEkxMm9sMDNva0daNzg2QUZDT2VqUDdmTlBrRHJHVWtIM1JwVU00KzhDK0ZVQTN3THczOUNQY09hWm16TUFmeC9BLzBad1pHci9MZ3JQN1JBVWlPOEErSm85NjQ4THpidEdjSVRTb3c4QS84ZnVlUjhCWUZrQStBd2gyNWg5VWtIOEljSVkzNnpPVGo4eUozVXNIWFA0OUJuTHpHRjFkdm9YSTluVzFmSk9uc1Q1amRYWjZRMlNvZnUzRVJ6QUxLTjlEZURYN0lkbmtoMGdPSmVZZmZ3UjBsbkttb0h4cnJKei9sclNNbVdnM290eXM0VURaU3VnWDRFczl4VUIwQzhHTjZISHdIT2ZzMnpPR0ZDdHhPdUt6THhObVNZYmJNK1B1TmN1dkhBMDRmc1lZUi9vV1Q0ZGdDczNOakdxQ0VseHBoRG9FSGpDcGowKytTeWpkS3pNRUJ3SUlTTUNaSTBaZFZwR2tPY1B4dEw4U0R6c29kMmJ6ZTVvVTJrc2xzUWNCQWkwNmJ5T3l6WkZJbE1oNlJuOWJTb2ZkN1VVNTN0bURmaytVaWxWeDJGdWpkeDZENm15WkcxaktlNnh3QVkxd3RYaEhnMGY5dzZ2cEJGSW5WUUo0TUZSMDgxbXMrdjVIRGZmKy9iK1kzUjRmOU5oYjdQdU5tandjalpyTGt2T1gydmZhQ2tpVkJ3eEdkNXhxUXBsN21INi9TNUFZTVd3N1JucDlsSFIrYWRnd2pJNDdRWWxpdTZSQmxIaHlBUVpGUHI0Q3dINEtTMkhad0Z4RHIzYzl5Q2hLdlNSYW12QXZYZHdidVN1eFBYU1Rpdkh5dkw2d0xoRFpOWW1SMTd0WEVZYUwxbEhuQkdOQU1xVXRSazR2YXpXM0RzY01Ca2RaQUxxRWZ3c2dWVTBxcjNEaXZvaVN4bE5vV2pFbFl4Ukd6T1dNTXhXZ2FnOFA1WU5OT05RTXpsNXpNMWJET1g1Wlp1WDUrcnNWS1B0QTRRNStET1JBUjJDOC9nekFLK1hyZ1NoOUtOQjBLRTI3ZkhKdWJWempxQWpQRUlZNXpmb3kzTWVONEgyK0dSVldLYzZ6elFpL2Y1aUJZc0w5QjFwQklHVXorNGpySTByQWNicFdCOWtIN1RwakZzRjlnbGcrd3pVTlpLK3REUHZFM2xPSGJ0WFlyanlYTlUxdGowZnR3ZlFUK0hseStROEw1V0pycjJiZlJ6VEhiSU8wY0w3WHJjcDY3MTJuQVgzUlBXY1pxNzl6TDJjRzI5N2FJYTc2bnNER2RuMnoveStzbkhzQWU1M0xUdmxlUXhpVUwxK3oyVEZUZWI2TDUxdTB4WUMyWER5T3ZOTVgwSTBxK052ODk3YjNPOXA2cHE0ejNrYjBXZDlPZTA3YThjWUx5dTE2NWJ0cVdJY2JxLzNhT1JkOGI0Y1FJK0NIcmtjT3I1bThqZGxIajhuUHZxb1BUNkp3YjNVdGRvUTlEZG1HODVORDZZVGlMb1ZIUU9xTjFLZUg4RHBWZEorclJSRmtIdXd4OFNHWmxVUDlxMFh6SzI2SGdJdnB6eS9nbUVUd01DcFRYbE9LbVpVMDg2L0pTK09qaENrNEQxV2Rad2o2TWE1WTZjNkRJTnVlUzRqN1FTdGtNWTI2MXJhNC9OUkx2M3MrM3VOekxydzYxVEpPMnNtclAzQm5CZjRDYXNxeFV6Y3d2TUcyV0U1S3NoelBtUFE3dVdMZmxYQlNodmk4OHd1NmZ5emEvZmRsaHl1RnRlTjU1bTcyT2YzSlV0dUtjOXBuMnZXZDhrUnFPT2ZuWXN0N1BPcnU3YlA3ZDhpdm10cmlVZHhOU2pvclBJODJuZForeHpKUHRFZ1NQSWd2emRVWm5RSU5oaVRRcmpHaXdFUXNuL21ZcC9IOTVaa2VwdHc5V2JaRDE3U3FoRnFSMDZsSW41SWZaejk5TitQekRuN2xEczdtRmlEdHhWejhud2hmNWQrZUdTdGIxdHViVGJ1NzRYSWN6cVk5OUUvTWtLZC9ZY3dKM0NicWFZbDhueGo3MytOdkgzT2RjYWdycGpVNmRzcy9ENWlOOHNVQkFWOTlzQUJiRTVJT2hsekV6WUg4Sit0SWY4WXdka0toTW41QWtHaHViNlBETS9WMmVuN0NBN25HWUNEMWRucHBUbEN0ZTFmQi9BUDdhT3ZJMlFwLzdtMTdkZVF6dGI2Rm9LVDBwOVpYQk9TUndpT253Y0EvcFk1Wm5OWndNenMreERoN0Z3NmdWL0pOWEhzNWYwTmdvUDRrYldQNVpvZjJUbS9Dd1JIOHMvMVpmZFphdnZ3NmJOTGVmZlg3ZU5QRUp6bkM0UStNcHY1Q0tHdnIrMjZHeGlneG5teUFJSmJHWVYvVTJnYklUaEZhSG9CMGQ1amVlbGx4ckdGRERNU1VrZVpFc0dtQm9VeUdKVTJGTUZ6YXdPRlhiV0VVWUZ1S3ZkMHNITS9KeWlFMXpJdmpGemxtZUtYQ0h0bUgrRk1Rekx1ZlFDZkw0T2pTZzAxcjhUVEVUMUhjQmJ6L0VLZVRYaGsxeS9NV09YenIxQXZ4ZUVWM3V5Y2lIQTVIMUVBZTlrK3NsNElBczhOTk5Jb3FKenluelZRYkd3bm5iTlNJaXBvYllyeTZ0em5wWFhOd0JkbTd0QzR6Z0hzdWkvOTJscVVuQzBBOEtOLy9hL21od2N6L09adi85czFnTzdqLy9EYnpXTGV6TG9PNzg4NlBOcHN1azg2NE9LRGYzRmFQRGNWMDRNZ1NrWnFOdG95dDBaMFBRaFBha3dCclpZSXpiVjlERVNRejJ0OVZLQUN5eENsZDZjZ3NZSlBiaTRwMzVINTdGYnZyL1dCaW5DR1g4ZG96bDM2UDJYY2xxbVVWTXdNeU56bjkyeUhQQURDVE13Y2dKZmpHN2NPTUNQUDNnSXdydTR2WjVUc1FaeU5tWEVoSHllUDdPQWNsRWE5d0JNWWp6ZCt5akVZS1A0NTRNcTFNZkptT0ZuaDFvK2ZLNEtKMFJtNHhmaGxIZFZJNjVmeWZJTk04RktKN0JtOUxCN1hwalhNY0J1VDU2MUU4d3VBUXVjc3grNEJnS00yT2NNUEFMdzBucS9qN0t0cUhDRFlDemNBUG0rUFQxN1pzeDRnWmZwZUlzaUtGUndBa2V1M0g5Y2FDSWtrVzkrMmRYbE9BS0d4OTJnbUtHWGNYSXpPSEdESmR2VUE1bVZ5aU80ajhJdHIvYTdRN2g3SmRRT0g3NFJuVUlaem5JcVp3eFhIQ08rclJieHI1dGxPL0w4a1F6TnpsNTN6aWp3ZkJBejc5cmJwN09LbURZRUF4V01RM0xNNzJUZCsvY2RyNU44eGVhNDg3YlhPMVIyQ2pBY1kyaEFNS2xVTUpRdk03L0xPSGVSNUROcmJWZ2NtUHkrQW5aRXlNaUxYUnIrZVN2M0lIaDJRQWJNbUFjdFQ2YjdzNFNtay9BSkRSM24xdm5mUjdpMTUzRTdQeXp3NzZ6aWE4T3lhL2RvNWU3TFdQdFVuQVF2a2dBUUIyUS90Yys0ekJvWlRGOGp0Q1ZidW9JN0cwc29NbHVZMWpjaTVOWUlNS281SHhqN1Bsb21XL2ZvV0V0eWNlYVE2aU5WV3BTemNzelZJblV0MURiVjMrVHVYOWJkbitFZlVTYWZ3S2RwK3krU3dpaFhWN0JJR3lmWDZyM3BIZTN4Q2h6cDF5RnpBOVVMdUJaTERuai9WN0xlTVBOOTZyMHkxTll5MmtlYzVKMzQ4SzlUR05tYkoyZDZaaEJWd2Z1emZvaTA3bGM4Vjdua1g5cm5TbmVMVHBYbVI3NkRmZTUxNUc2eEU3aTlWZklrazlubE1RaWhjNnVWNXJpKzBFM09PSy8xTWJZVmJFZmVNZjJmcFdreXZyRElJbU1qSTRJVmNxeis5NEQrelpSYk9QaWNXd2pPNUI3WmJRU2NmNkJESVYzTGlkOEJ3Yk1qYkkvWTBrZWQweUZTemNmb1p4MjJUd1RmSHFJYjlVN1pVc1NvL3h5TFA2WlFtTlNJem9tT1ZXS1hjNzlmdUhGWWRDMEdlc2RvYXg1UnJadEdHODNuSkQ3TjRPOWVVOW50RXIrRjNGMjFkTDlaandMU3FDVEdkaUtYT1ZtZW5CK2JnSXhIUTJFZWVybTBRMWdCK0NPREhDQTVKWm5qZVMzbmYxZG5wQVlLejR3REJFZmtCZ0FlcnM5T0hjcTd1VndIOEE3bnRDTUJ2Mk0vZlJjaFlmaDhCU0dNL0RoQUFGZ0Q5OHRjRk9nZndVM3ZYNDlYWjZXSjFkanBiblozT1YyZW5lNnV6MHdWQ2x2Q3ZJempIZndNQjFQa25BSDdMM25rQnl6eTJNczhMZS9mR3ptVCtjd0Evc210ZTJUMi9iczk1aTNlVHNhVDBGc0dwK3pQNWJHR2YvUmpBLzBUSTlQMERBTDluLy84SmdJOEs0L211Mi84TFR4T05LVkpWQVRWbnlxejAvMVJxUTliUVBpeHliUG5pZWUxOG1XNzU0bmt1U3BNQ2ZKTFMzSVpJcUFPRWN3MXppbHJQdVlGTTFOQVVHaEUwR3dRKzBOalk3YmZISjN1aVJHZWZaZmRweE84bGdnTnhoVlJ5L1gwQTMwRFk4NTZpSXQrbXpDQ2VGVWptRHZ0OHo5MUhnWGRsYmU4RmtkaGN6dHhuamZ5OTF4NmZQTEw1SGlpbFhuZzY2cXl2T2FXQWdqT09uUUNRVkNSaVNXMk16S1hOeDFZSy9CVEF5aWtHOC9iNGhPVTRzWHp4L00weW5CUEZkbWVCTWJhOWFRS29iUGV5WDBYbjcrZS8rNFBGZTQvbTNYc1BaOTJudi9Ocy9xZi8vdDhjTmszempVMkg3eU9VRS8rVDJhejVDTjF1VlRkczdoZHRpakljS0dPbXdOSVJVWHFPVjA3MWY4M2MzcnBFWTIxOWtYL1o3K3l6N2ZQQmQ5c0FUMk04c2swQkhBTWdlSm5LeHZSK3RnVnJDMVJiODNUUytMa2h6YmJkTDl2SUNwczNSdXo3a2xXNURMQWJ2L2FNY250ZkRXVUY1KzZNN2hGNHZZSWRFV0R5YkYvR2RZYkEvOWtmZ21xbHRsQVcwTm00QjVHUFhIdGo4eXg3ZkxZTXp0SXZDb1ljMjNTOUhKYnFWVGswUlc4aEx5MVZJK0tlQXBLYzJ3b3c5a1pXNXZzTmdnd21EOWx2ajArTzJsU1N1ZmNzZDk4RmdneS9SZ2hPL1V2N2ZXM3QvUnFBYnlNRmdlcHpPcGlCWm5LVkRuK2dEOG8rUUwrQ2pvNHhBZU12bkl4U0kzQkFOdTc3N0tQdHU2bEFDdVVjenp2U2ZjZmZNWkRLMXBJZWVYT2p6MWdPcTRIRXNVSEtUTWdDRDNkQjFCblVJQmNndHdqSzVqNFhuamFXU1JNZGRidm9MQ05FMEg3ZitqVFFMZHFVQ1RCWTR6SWVtaDNuWldlSGxLMzIzcll5QVpXZ1RKMlBpancvUUVZWDJWS2VqL0ZEWnQ0elFGV0ovRmlCTmpxRmIwdGo4dHpiYTV5ZkdRTDRWTlRqQzdTUFRBQkppYmpHUytzL2MrMVdHSUMyOXg3bDd6c25iMmZVK2liNmJHNitKNU1ieTF2WndWTjRsT2ppcFgwYis3S0xvMndMaWpMRlpOMThyUDNMRk1SSCtVVGdsdjl2a1BTcnc4eTlrZHBVUmNHVDdsWGxINlFiMkZtOTdubUROZUQ2TTIrUFR3N0VKczFsTFpiMksyVTZxeStvM2tuZVJ5Y3diWG1PRGZFTXl2TnIxSFhOUVFDTDlxWGdETm5JNzRFZWJMcWR6cmZxd1J1RVFQMlZ0UzBHNFRueURuOTFWUEdkVlhEK3R2SjhnbjJyOW5rdVN5NG5wMVdlY2c5NG5ZM0VQbTVHMWxxdTNWVmJWdVltKzV5NzBIOG15SE1ObU16WjU4QndqOXdGZjZxMXErZnNkWjhCR2Q3dis1bnBkMDVmeVpMWVJvTnFUYUlMcTgxVHdxa0crMUxhbGV2am5WQkpEN2tENGo3WWI0OVBHTkRMdmRYTG1rYloyVXBTWFhzaC82dURmelBHTjBSblp3Qk1QSHZlWFJkdHc4ejNPbmZWd0RKckQvR0pnWjNBWnlEdEtlTFRXOC9IQk1ldVpsWVRNNmpxUkxUZnBEMXI5SDBDbEcrczV1T3BFNTZ1bWRQS1E5VDVyMnNoQm9vaEpKLzJLbnc2WHNUUEZHOWZtRHhuU2V0dGREZU9sMWJjcFR6dnJka0ZnS2NBZnJnNk8zMkY0SGlrSi85Z2RYWjZmZmowMlViT25lMFFBT2NEQkVmRi93UHdNY0pnc3RaMXN6bzc3ZTRoSy9XYkNFclh0d0I4RDBHUUh5STRNdlpYWjZjL1I4aEcvYThJQU13RmdtSHoxcTc3UGdLb2RvUytRNU9SYmxXeUVzd0hDSk41WlBjL3R2OVo0dmlyOXM2djJUUC93bTcvcmwzNzJQNS9oVFJ1RHdCOHcwcG92ekVuY0dlbGw0RXdrVng0NXloblp0OG56UkJBcmo5RTZOZFBBUHowOE9tem1GR3hPanY5Rk9sOE0wWWJkTURRcWY3L3ovL2RqZ1RJalJGaU9VTmIvMjRyNWFXWEtRcGZhZFRCbkhtZVJyMk03dmRDdTFreXAzaHVuTnhQd0luQVlDK0xpczlqV3dTZ3ZRODZRRmp2bDBnUm9qeXJvVFlXYTd1SGJhT2prOUZzcjVCS04wZGFwa2pMV1p0S3E4WW9McVQ5ZG0zM053Z0JKQmZvUi9lVmdONnhQVmxWNG1pQUZJQjJsbC9wUmQ2cW9vS004b2wreG1EOG0wYU1NM0xIc3U4MDhyY2FQVjY0WC9kZ1BIL0Q3enVVczZXWkRiWHV1dUYraFJ2L04vL3hCL1BGdk9sZzJlSGYrZWJlOWFiRHc4Mm1lKzhyaithUFovUG1TUU44MkRRNEF2Qm5UWU1ObXVZMk1qY3FjbTJLQ20zUU4zNmpnWnR4TmdBcHU3azN4akxQMFhHUmVjWldXUTV1UG1qd0VBQzk5SXF2alQvUDE5bzFVNXhPLzFqSzNMVmIyNTk3L2daOXBhL1lmOC96YTdSRFh6eS83bVdqdEpLZGs5dHJ1eEQzaGdBVld4bHV1ZmVUMXd1b2NaZE85VHNuRzA4YWdRekc0YnIxNVhvWU1NRTltSFVBMnpOMXJiTXNIaUFSK1ptMWxjdjRvbEhDYWdRbC9XRWo4K2lKQU9ZY0kxbTZpbEZ6VmdBQUFvTkpSRUZVTmhieHVKajIrR1RoMjdTVWJFUjc3OXQ3TXZoWnRwcHRQZ0R3c0QwK2VaMFpKeVU2ai9jUWJJR1hNQmxyYy9neGdnek9WUW9Da3FPWHg5TlFWbEtQdmtRNjEvbVYvVS85R25DT1g5ZXVNWXJybzlDdUdZWVo1N0EyN0NHc0lYVUVRNTZYaytlOGpuSXlBdlJJSmRSNjV6cFhpSUVyVlY1KzI3VXlkbjlOeDc3TmUyOUpuRHNnblM5Ris5MERuYm1xREI4ZzdNbjk5dmprRGNMWlZiN01POS9CRElRRjBsbmMxTTF6QVo4QWlnNFQ4bTZWNXdlMjUvMGV2SUpWNDJxUFQxN3VPTjVIN2ZISkl3UndKcFlDbFdmZElOa2JnNEJIMjkreHNnMUVIMnhkaHVzMitzMUUrZVVESnFoYjVYUzB1Zkp6L1U3NCtNNFpPZHZxYnNCMisrWkwza3QzU3RTcHhnRFB1N0RQcVJlMUV6T05iOU5tZTEvTWJyTDNVajcwbm9WKzF2NTl6UzByVWF6ZC8yT0JUaXFicm1GSEtOa1lySkZBL0p4dTB5SFo1N1IzNlpUam5tYlZnQVlwOEJ0SUFRRlRNb0JLN1FicVRwWUJYbUowQmROL2xxRmtNRE4vRlRUTzJhdFg1TnRJMlcyMEhYdnl2QTNIbDNpN0gvTC9udG1Sc1dwZ2pncjRBcEN5bHlrL0FNRlc3TjVlSnF3anpubFBmeEZjNXI0Y1RWT281M0N3OVJYdEhmbWgvZTdMd3NacVBVaHkyWmVGOWFUT2lBWWp4MGNWZUEvSFR3UEprT05IWW12ZWhwakVVTU80Rkl1b2ZkK3ptMXFYeGJ1bGZUNUZ0cGI2VGw2cTJGZXNGaWR6VTh3bW5VS3VuOEFPUWJhRnoveWV2N2RqRCsrSWFBZVNxT05xMVRyS0FXQVlBTmdqbTZPMXUwNS84enB2bnk4OGhpWFA0RjZzNGZ1bGRhREhlSXo1dmVnWXBmMVF3dHZqMzIyb0JuUWY4enREMkFjYitiOVUrajlISFN6SVFhNWZpNnlyVlhabzBBK3FpTW11U1A2NUdZS2R2MEpmbnk0ZGtUUEFmTjExWXdFVHRJOXkyQVRiUkJ2RWwzK096LzBycWFnSHQ3cVdVcjBBQUFBQVNVVk9SSzVDWUlJPSIvPjxsaW5lYXJHcmFkaWVudCBpZD0iX0xpbmVhcjEwIiB4MT0iMCIgeTE9IjAiIHgyPSIxIiB5Mj0iMCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoLTY0LjQwNzgsLTQwMy43NTksNDAzLjc1OSwtNjQuNDA3OCwxNjEuMjY5LDExNjUuNzEpIj48c3RvcCBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiM2NTRhM2E7c3RvcC1vcGFjaXR5OjEiLz48c3RvcCBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiMzYTIxMTI7c3RvcC1vcGFjaXR5OjEiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iX0xpbmVhcjExIiB4MT0iMCIgeTE9IjAiIHgyPSIxIiB5Mj0iMCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMTI2LjIzMiwyNDEuMzQ5LC0yNDEuMzQ5LDEyNi4yMzIsMTc2Mi45Niw4NjMuNjQ2KSI+PHN0b3Agb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojNGEzMDIwO3N0b3Atb3BhY2l0eToxIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojNTkzZTJmO3N0b3Atb3BhY2l0eToxIi8+PC9saW5lYXJHcmFkaWVudD48aW1hZ2UgaWQ9Il9JbWFnZTEzIiB3aWR0aD0iMTE4cHgiIGhlaWdodD0iMjA0cHgiIHhsaW5rOmhyZWY9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBSFlBQUFETUNBWUFBQUNtOWxjQ0FBQUFDWEJJV1hNQUFBN0VBQUFPeEFHVkt3NGJBQUFOaUVsRVFWUjRuTzJkNlhkVVJScUhueHRaZEhSbWxGRW1xS09JWkNOaEU3S1M0SHBjUU1nR0lRaEl3djh5LzRhREN5TXFXUWhKOURnSFIwZVJoQkRDY1V0SUlPUzRqRHF1SUt0czg2RWJTRHE5M2U2Njk2MjNiei9mdUhXNzZrZCtYVzlYMWExNnI3Tm0yZnlad0JxZ0ZWZ0x6Q0FDeDNFaUwwMHR4NEU0dDhRcmQ2NFhSQysvNXVBOHVQZncyRmR4QldTWnhnemdhMkN1dEpBWU9NQ0x3TitsaFdnakIzdE52VTVMN2NxOCtDRWp5elJ5dkc3QWlSZWprMk1oVUcxQVNxRHczRmhEdEVvTDBJWVdZNXRxUy9QdWtCYWhDUzNHM2c1c2xCYWhDVFBHK2pPMHlZWmpGMmpwc1FBMXRhVjVlZElpdEtESldJQVdhUUZheUFIRzA2bkF3SFRHRGR0clMvTnU4Yk5CcmVRQU82VkZ1T0ErNENscEVScklBVjRHcmtrTGNVRjJFSlVFT2IxSEo3NEU5a3NMY1VGOWJXbmVIR2tSdG5OOThQU1NxQXAzekFJMlM0dXduZXZHZGdLbkpJVzRKQnVPRTVBRDBIdDA0anp3dXJBV042eW9MYzFiSWkzQ1ppYlBZLzhSN1FZajB4bHZaa1RaWGh1SHljWU9BSjlMQ1VtQnJiV2xlYk9rUmRqS0RXTjdqMDVjSTBhdnRaUzdIWnkxMGlKc0pYSko4VFhnaW9TUUZNbUc0eGhNTWJiMzZNVDNRSStRbGxSWVUxZWFueXN0d2thaVBRVFFOS2U5QmRnbUxjSkdvaG5iQy96UGJ5RnAwRnBYbXAvZDdCYkJOR043ajA1Y0l2UmJxNFVpb0V4YWhHM0VlaDZyYVhRTTJVSFVOR0tHc0RYTDVnOEFLOVBaNVo5MGVRd2xVeFpINHBlZkJ1WjFEb3llaTkxU3NJaTNnOEsvUVZUNnY1Qi9BdXJURjVJNXhETjJOM0RSTHlGcDQyVEQ4V1JpR3R0N2RPSVhvTU5ITGVueVJGMVovbnhwRWJhUWFET2Jwa0dVQTJ5WEZtRUxpWXpkRDJnNnd0aFNWNWF2YmVlbEo4VDlJL1FlbmJoQ2FFK1VGdVlEajBxTHNJRmt2dDA3dlJaaG1Pd2dpaVFuR211WFAvUUJzRHA2Qlo2ZFpuY3pqNTFjZmg2WTEzbG9WTk5XSCtNayszdWs2Y0hBYlVDVHRBaHBralYyRDNER1N5R0dDWHc0VHNyWW5xR1RaNEUzUGRaaWtzcTZzdnhDYVJHU3VKa2F5TTFwVTF0eWJERXJRaGR1akQwQWpIa2x4QU8yMTVjVlRFdHRGQlNTTnJabjZLUzJ6VzY1d0RQU0lxUnd1MHJ6Q25BMTJadDlQbUlaamNBT29sd1oyek4wOGh2Z1hZKzBlTUg2K3JLQ3U2VkZTSkRLdXFxbU9lMU1ZSXUwQ0FsU01iWUwrTm0wRUE4SlpEaDJiV3pQME1tTHdEOXZYQkQvR1UzSTB2cXlndVhTSXZ3bTFVZGNta2JIRU1CZW02cXhROEFuSm9WNHpKYjY4b0xaMGlMOEpDVmp3M1BhbHl5WXppVExIR0M5dEFnL1NXZTN3Uzdna2lraFBoQ29jSnl5c1QxREozOEU5aG5VWXBRbzBlU1ordktDK3lTMFNKRHUvaUJOZzZnY1F0bktBMEc2eHI0RGZHZENpRSswMXBjWHFCa1lwRU5heG5ZUGpWOG10SDZzaFR5Z1NscUVINWpZcXFrcEhFTkFCbEZHd3RMemp5dzRDRlJNcnp6MUExbXV5cVBjTTIzd2RQT2ZaNERjanY1aloyTXIwNCtwemRXYUhnemNBV3lRRnVFMXBveDlnOUMyVDk5SWMzRWs0OE94RVdPN2o0eWZCdHBNMU9VVGp6YVVGeTZRRnVFbEpzKzVhQnRFdFVnTDhCS1R4cjRQVEJpc3oydGFHc29MTXpaYnVURmp1NCtNWDBYWE9aKy9BVTlJaS9BSzAwY09OWjNNZ3d3ZVJCazF0dnZJK0FUd25zazZQYWFob2J6d0xta1JYdURGSVdFamMxcWZudlhPQnByOWFNaHZ2REMyZzFCNm51U1FYNUxQeUhCczNOanVJK1BuQ0dXYzhZLzB2aHlsRGVXRnhZYVVXSU5YK1JxMHpXa3pydGQ2Wld3L01PSlIzVjZ3cmFHaWNLYTBDSk40WW16M2tmRnI2SG93TUJkWUl5M0NKRjZtem5tVmJMWnlNVHd6dHZ2SStIZkEyMTdWN3dGckd5b0s1MHFMTUlYWHlhNWlEcUlzM0pNOEE5Z3FMY0lVWGh2YkRmem9jUnNtMmRGUVVXamROeTRWUERWMjM1RVR2Nk1yVzNreHNGSmFoQW44eUR1WW5kTUs0RXZZV2JmaTRVSGdrYWtOZTdlUnpYWDUxSHQrZFhEdWJlc2I5bldyajJuOHloU3FhVTU3SjFBbkxTSmQvREwyZGVCM245b3lnZnB3N0l1eCt3WlAvRXpvSGJWYWVLcXhvdWdCYVJIcDRHZlNaazJES0FmbEI3ajhOUFpmd0RjK3RoZVRKQmRIV2hzcml0Um1LL2ROK0w3QkU5cXlsUzhBYXFSRnBJcmYzOGlkUHJlWExtb0hVYjR2bjYxYjhmQ0hRTFhrUERacUtIYWlscDhEY3R2NmhuK0xyc0plSkg1RE5BMmkvb0RTYk9VU3hyNEYySFdFTVg3Y1VobU9mVGQyMytDSjN3aVpxNFZWalJWRitkSWkzQ0kxblBjMEhIdndyTGZGZElWZUkyWHNoOEFKb2JaVFlYdGpaWkdxQTF3aXh1NGJQS0V0Vy9tOXdOUFNJdHdndWJMeUNuQk5zSDIzcUJwRWlSbmJOWGo4SzBMTGpGcW9iYXdzbWlNdElsbWsxMEkxaGVOWndBdlNJcEpGMnRoTzRGZGhEVzdZSVMwZ1dVU043Um84Zm9ISjJjcVRSSERyNnZMR3lxS2xVbzI3UWJySGdxNXdERW9HVVRZWU93aDhKaTBpTGxNRHhOWU5sWXRtQ1NsSkduRmp1dzRmMTNhQTZ5L0FPbWtSaVJBM05zeHJ3R1ZwRVM2d1BoeGJZV3pYNGVNL0VEb09vb1huTmxRdW1pY3RJaDVXR0J0RzB5QXFCOWdtTFNJZU5objdOdkE5V0hrU0x4bzdObFF1c2xhb05jWjJIVDUraWRCaGFTMFVFQ1ZIc3kxWVkyd1k5K0ZZdHM5WU80aXlMcFNzWDdtdzM4RXB1M0hCN0lHcnRNc2p5bjREY3ZjYy9PTGNkQld5Mk5aalFkY2c2bzlBZzdTSWFOaG83RzdnZ3JRSUYxajVZTUE2WTdzT0gvOFZhSmZXNFlMSE4xUXVla2hhUkNUV0dSdEdVemdHMkM0dElCSmJqWDBQK0ZKYWhBdGFObFF0c3VwdmFaV1k2K3c5UEtZdFcvbUR3T1BTSWlaanBiRmhka28wbXNhcWwxVnpXdXZtc1pPcFhabjNieHdlaTd6dTVUeld4WUd0eUhzdUFMbDdQdjdpVlBRYi9NWG1IZ3VPZ1VHVWYxL2RXNEZOdnJXV0FMdU5EYjJrU2RNUlJtdm10RllidTNkZzdDeWgxNnRwb1h4alZYR1J0QWl3M05ndzJ1YTBWZ3lpTkJoN0VEZ21MY0lGTDI2c0toYlBWbTY5c1hzSHhvd2U0UExoSWY1ZmdXZTliaVFSMWhzYjVsWGdxclFJRjRpSFl4WEc3aDBZK3kvd2pyUU9GNnpiV0ZWOGo2UUFGY2FHMFRTSW1nRnNrUlNneWRoOXdFL1NJbHl3WTJOVnNkaktuaHBqOXc2TVhRUjJHYS9ZdXovOVlpSnlOUHVKR21QRDJCbU9ZMzg1eEFaUlZqOEVpRVp0YWQ2UWc3UHN4Z1dERzlXaWxrZmM0N0w4RitEZXR6NyszUGV0UHRwNkxOamFhNk56RjdCZW9tR054dTVDVjdaeWtRY0Q2b3pkT3pEMkU5QWxyY01GVDIrc0tyN2Y3MGJWR1J0R1V6Z1d5VmF1MWRoM2dXK2xSYmlnZGVNcWYrZTBLbzN0SEJpOWpLNXM1UXVCYWo4YlZHbHNHRTNoR0h5ZTA2cWJ4MDZtcmpUL0FBNVZrNjlaTm8rZFhIRFd3Y2w5ODhCblo2TGZZQmJOUFJiODZMVW12dnFoT200SE5oaW9MU20wRy9zbW9iejlWcERFUTN6ZjVyU3FqZTBjR0QwTjdKSFc0WUthcGxVbEMvMW9TTFd4WWJRTm9scjhhQ1FUalAwUGNGSmFoQXUyTjYwcThUeGJ1WHBqT3crTlhrVlhyNzBmZU5MclJ0UWJHK1psZEdVcjkzd1FsUkhHZGg0YS9STFlMNjNEQlhWTnEwcnU4cktCakRBMmpPZmgyT0NlNU5uQVpsT1ZSU09Uak8wQXJEakNtQ1NlTGpGbWpMR2RoMGJQRTNwbHVCWldOcTBxV2V4VjVSbGpiQmhObzJQd3NOZG1tckVEd0JmU0lseXd0V2xWaVNjSHVETEsyTTVEbzlyZXdIVVBzTmFMaWpQSzJEQ3ZBbGVrUmJqQWt6bHR4aG5iY2VqWTkwQlBLcDhWeXBPOHBxbTZKTmQwcFJsbmJCaE40ZmdXWUt2cFNqUFYyQjdnQjBYN1ExcWJxa3VNcXMxSVl6c09IZE9Xclh3UlVKYndMaGRrcExGaE5JVmpNRHluMVJPc1VxQyt2R0FBV0RuNW1rZFoyVXlVbjNKdzVyM3gwYWZubzkva2prenVzYUNyMS80WnFEZFZXYVliK3pwdzhmby9GTHoyeFZnNHptaGpPL3FQL1VMb3FZOFdudHhVdmZoQkV4Vmx0TEZoTklWakIwUFp5b05nN0g3Z2Eya1JpWmowTTlHeXFYcHgycjVrdkxFZC9jZXVvQ3RiK1VQQTZuUXJ5WGhqdyt5TWV0WGVzVlRhRHdicy9hOFpwcjY4NEFNSFoycFA4TzlBVnNMeWlMTHpRTzRiSDMxNk92b0hFaE9VSGd1NkJsRzNBVTNwVkJBa1kvY0FaNlZGdUNDdE9XMWdqTzNvUDNZR1hkbktxelpWTHk1TTljT0JNVGFNV0RoT2NkV3JKZFgyZ21ic0FXQk1Xb1FMWHR4VXZYaEdLaDhNbExIdC9TUFgwRFdublFjOG5jb0hBMlZzbUZmUWxhMDhwVGx0NEl4dDd4LzVtbENlS0MyczMxU3orRzYzSHdxY3NXRTB6V2xuQWkrNC9WQlFqZTBpbEhJMlB1WXl4cVNMNnpsdElJMXQ3eCs1Z09GczVSNC94Ri9XWExOa3Vac1BCTkxZTUpyQ01ianN0VUUyZGdqNFJGcUVDN1kwMXl5Wm5lek5nVFUyUEtmVjFHdm5BT3VTdlRtd3hvYlpCVnlTRnVHQ3BNTnhvSTF0N3h2NWdkRDdmTFR3YkhQTmt2dVN1VEhReG9iUkZJNXpnRzNKM2hoMDNnRytTM1NUUlh1U1c1dHJsaVFVRTNoajIvdEdMaE5hUDlaQ1BsQ1o2S2JBR3h0R0xoeW5GZ2dTUGhpd0pyNUkwMUJSZU5EQnFaaHkwYjhEV2ZGRC9mVE5ibWVBM04wZmZoSnpxMCsyeDk1RTB5RHFEcUF4M2cxWlkyL3lCcUZ0bjFxSU82Zk5HaHVtdlcva0ZOQW1yY01GanpYWExGa1FxekJyN0ZRMGhXT0lzOWt0YSt4VTNnY21oRFc0WVh0enpaS29IbWFOblVSYjMvQlZkTDJCNndIZ2lXZ0ZXV09uczFOYVFDUUpWcjJpRHFLeXhrYlExamM4QWJ3bnJjTUZEWnRYTDcwejhtTFcyT2hvR2tUZENqUkhYc3dhRzUxMklPVWpqRVpKYm0xd1dqak9HaHVGdHI3aGM4QnVhUjB1S051OGVtbng1QXRaWTJPaktSeERSSy9OR2h1YmZtQkVXb1FMdG0xZXZmUkd0dktzc1RGbzZ4djJiYk9ib1lmNGM0SG5ydjhqYTJ4OHRHVXJ2eEdPczhiR29lM2c4TGZBMjlJNlhQRDg1dFZMNTBMVzJHU0lIWTd0MjZZd2czQzJjdnVrV1VaalpkRXM0QnNIWi9wUlJtOVNBYmtyQnh4blN2bG5RUFFuQTFsdTBuWncrSGZnTldrZExpZ0JWdndmUFI1QXdwWVE4ZVFBQUFBQVNVVk9SSzVDWUlJPSIvPjxpbWFnZSBpZD0iX0ltYWdlMTUiIHdpZHRoPSIxMzBweCIgaGVpZ2h0PSIyMTlweCIgeGxpbms6aHJlZj0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFJSUFBQURiQ0FZQUFBQ2hna25DQUFBQUNYQklXWE1BQUE3RUFBQU94QUdWS3c0YkFBQU1ORWxFUVZSNG5PMmQyVzlrUnhXSGYrMkVKQXFhQ0tRSmtJZkFnSVNYOW9iRXVMMWJaSGpLekVqWTdhMWJHaXR0LzJIQmtNQUU1SDBMRHlRc0QzaHBieUhSZUc5YklXUWlCWkpJU1JBeG1nd1B2cDVwdDN1NVMxV2RxbFAxdll6a3R1ODk5dnhjdCtyVTErWFl6WjljZXdyQUxRQVpBRGNCUElrQ1lyRlk0WWN1dm80WVVPSlRZdWN2aUgrOWR6WjdNRnUyTUlkdm5nVHdUd0JYcVFzSndTZ0FGd1JCVk1ITUVBREE3ViswL1BpNzFFVndvWXE2Z0FnOEFlQU9kUkZjRUJPRThsTUltWXoxdGxUVDNaMFJKbzhJQUJBSDBFSmRCQWRNRHdJQWpGRVh3SUhJUVlnUlBoYzgwcjB0MWM5U0YyRTZIRWFFNXdEMFVSZGhPaHlDQUp6MUZCd1JxQUt3VDEyRUFIN2UyMUo5amJvSWs2a0M4RXZxSWdUeENuVUJKbE1GNE5jQXZxWXVSQUNqdllscUxvODY1VlF0Ylo5OENPQVAxSVVJNEFjQVhxSXV3bFRPZjROS1BoNkVMQS9WclREZHBERWs1MEdZQi9CdnlrSUUwZCticVA0V2RSRW1VZ1VBUzlzblh3SDREWEV0Z1NreVdqMERZSmlnRk9QSm4xeTlTbGFGV0Z6TE9RU1BnckMwZmZJT2dDM0NXa1NSNkUxVTExTVhZUnFGeXkwdW80S2JOQWFrTUFpL0JYQktVWWhnUm5vVDFkK2dMc0lrTGdSaGFmdmtFd0F6UkxXSTVEczRFM0VkUGluV2lYT1BCd3NwRm9RL0F2aEFkU0VTdU4yWHFIRnlxMDh1QldGcCsrUUJnRjhSMUhLSmlGMU5KN2NHb05RbXpiaktJb1Mwb0l0Zlk2d3ZVVU91VUpsQTBTQXNiWjhjQXZpcjRscGtFQWVRb0M3Q0JNcHQyM0x4Rk55azBRZmxnakFCNEF0VmhVZ2szWmVvY1hKckJVb0dZV243NUFzQXYxZFlpeXljM09xRFNrWVBsNTZDMjRpcVFLVWcvQTBTNVZhRjc0bTQwWmVvdWFicVppWlNOZ2hMMnljUEVXTXphY3hRRjZBemZtUlBMbkpycHErMXhzbXRKYWo0ZzFuY09uWnlxd1g0L1EyaG5UU0s2enk2bmtJSi9BYUJqZHphMTFyajVOWWkrQXJDNHRieEtZRFhKZGVpQWllM2xpREk1Q253NmtHRHQ4d1h3L1VVaXVBN0NJdGJ4KzhBMkpSWWl5b1NmYTAxVG00dElPaHlpa3RQd1UwYUN3Z2FCRFp5YTdLMTFzbXRlUVFLd3VMVzhXVzVWY3RwUUVXYzNGcEFtRTZiMjRoaVNKZ2djSkZiYnlWYmE3OUhYWVF1QkE3QzR0YnhJN2xWMCtXaFg1emNta2ZZVFpoeGtVVVFNcHBzclRVNnphSUlGWVRGcldQdDVWYWZvNVdUV3oyaWJNdHltVFM2bmdLaUJZR04zSnBzcmJWZWJnMGRoTVd0NHk4Qi9FNWdMVlE0dVJYUlQxN2wwbksydnFjUU5RaVY1Vll6NXVRM2ttMjFQNlF1Z3BKSVFWall5ajBFbjFIQjZwTmJSY2ljSkhLcmhHWldKdGxXYTYzY0d2a2JYOWpNT2JtVkFhSitBN2owRkt5ZE5Jb0t3anlBZndtNkZpWEpaRnV0bFhLcmtDQXNiT1pPWWVESnJVVjRCa0NLdWdnS1JFNk91S3dlckd3NUN3dkN3bWFPamR5YWJLdTFUbTRWdlZ6aU1tbTBibFFRSFlTN0VDUzNFa3N2SS8xdGRWYkpyVUtEc0xDWit3VEFkS0F2a25laVdoU3NrMXRsZE5LNFRCcXQ2aW5JQ0FJYnViVy9yYzRhdVZWNEVCWTJjOXFjM0JvUnErUldXWnNzNDVLdXE1cXgvclk2TXpiU0l5SWxDQXViT2UzbFZwL1V3Uks1VmVhMmE5bWVna0h2aWJCaTBpZ3pDRnprMWxSL1d4MTd1VlZhRUJZMmM4YktyUVdqMVhNQWtrU2xLRU8ya2VOYXpvWWdPd2pMQVBZaVhVR1B6dU9OL3ZZNjFuS3IxQ0RNYng0NXVkVVFWTWlhcjRISnlhMzk3WFZzNVZicDM5ajh4dEdIQU42VWZSOEZzSlpiVlNXY3krT0JiVTlCVlJDMGtsc2pOTE9TL2UxMUxPVldKVUdZM3poeWNxdm1xSno4dU1lRHhpZ0x3dnpHRVJlNXRXV2dQZDVBWFlSb1ZDK0hYS2RSVTFRSDRTNkFyeFRmc3pMQjU0NGpBKzF4Vm5LcjBpRE1ieHhkUHJuVlRKNEhjSXU2Q0pGUWRNcWtQeDRVdVE2c0hnOFVRWGdMVE9UV2dmWTRHN2xWZVJEbU40NGVnSWZUeUVwdXBkcEVHU2U2cjJqR0J0cmp4amgzNVNBSnd2ekcwUkdBdjFEY1d6QnM1RmJLYlZYWGFkUUl5aUJ3a1Z2VEErMXg0K1ZXc2lETWJSeUdsbHMxVStHdmdJSGNTbTNjbU5GeXJwdzc0eDhQMUVHSUxyZnF3VXNESFhHajVWYlNJTXh0SEhLU1d6UFVCVVNCZWtRQXprNXVmVUJkaEFBeUF4MXhIWDZlb1NBdmZHNzk4RDU0bk56NmZRQTNxSXNJQzNrUVBNeVlORmJHMkkwb1hZS3dnRHk1VmJQbFlSQ1NneDMxUnNxdFdnUmhidjN3Rk1Ecm9iNVlyOHdZSzdkcUVRUVBJMVlQUGtZckkzc0syZ1JoYnYzdzd3QTJxT3NRUU10Z1I3MXhjcXMyUWZBd1lsVHdnWEdUUnQyQ29LZmNHcHlSd1k1Nm8rUldyWUl3dDM3bzVGWWl0QXFDQjVlZWdsR1RSaDJEOEJhQWYxQVhJWUNiZ3gzMXhzaXQyZ1ZoYnYyUTA4bXRJOVJGK0VXN0lIaU1VOTFZY0ZkemRMQ2pYcStXVndtMERNTHMrZ0VudWJXVnVnZy9hQmtFajFjMU9WRXRLa2IwRkhRT3dpU0F6Nm1MRUVCNnNLTmVlN2xWMnlETXJoOFllM0pyQVViSXJkb0d3WU5MeTFuN25vTHVRV0FqdHc1MjFtc3R0Mm9kaE5uc2dYQzVsVkI2eVZEZDJBOWFCOEdEamR3NjJGbXY3YzliMjhMT21jMGVPTGxWQWRvSHdjTnRSRW5HbENCY2tGc05Kam5VMmZCdDZpS0tZVVFRWnJNSDRlWFdTcWp0WGo0TlRlVldJNExnd2VYeG9HWEwyWmdnekdZUDNvVVB1ZFdBOTBTMERIVTJhQ2UzR2hNRUR6Y3FTTUswSUJndHQrYU5WaU5EblExYXlhMUdCV0UyZS9BcGdHbnFPZ1NnbmR4cVZCQTgzRWFVQkV3TUFodTVkYWl6UVJ1NTFiZ2d6R1lQbk53cUFlT0M0REZPWFlBZ3hvWTZHN1JZN3hvWmhKbnMvaEdBUHl1NW1kek9ZeTAwa1Z1TkRJS0hkcFBHa00wc0xTYU5KZ2VCaTl5YUd1cHNJSmRialEzQ1RIYWZrOXphVDEyRXNVSHdjQzFuUVpnZWhCVXdrVnVIdWhwK1JGbUEwVUdZeWU0L0JKOVI0UlhLbXhzZEJJL1h3RVJ1SGU1cUpQdi9NRDRJTTJ2Nzl3RzhxZUpla2wwSFVyblYrQ0I0YU5kVENBbFpUNEZMRU15V1d4OFBOTW5ocmtZU3VaVkZFR2JXOXVYSnJXb2hrMXRaQk1HRHkrcUI1UEhBSmdnemEvdnZBbGlucmtNQTE0ZTdHaHRWMzVSTkVEeTRUQnFWZHhxNUJTR1MzS3FSQ245bnVLdnhLWlUzWkJXRW1iVjlKN2VHaEZVUVBCNVBHclg1QlErRjBzY0R4eUM4RFNaeTYzQlhveks1bFYwUXB0ZjJIb0NIMDZoVWJtVVhCSTl4NmdJRU1UYmMxYWprQWNjeUNOTnJlem1va2x2bG9reHVaUmtFRHk0OUJTV2RSczVCdUNTM2F0UW5DRUpxdUx0UnV0ektOZ2pUYTN0T2JnMEEyeUI0R0xNUlZXRzBrdjU0NEI2RUZRQzcxRVVJNEdlcDdpYXBjaXZySUV5djdnay91WldRak15THN3NkNSMm01MWF5L0I1RkpkVGM5SWV2aTdJTXd2YnFuVEc2VnpJdVFLTGV5RDRLSE1aUEdDa2piaUxJbENJc3dXVzU5VERMVjNTUkZiclVpQ05PcmU2YzRteXVRSWFpWkpVMXV0U0lJSGx4V0QxSjZDdFlFWVhwMWo0M2NtdXB1RWk2M1doTUVEeTZqZ3ZCSm8yMUJNUHJrMWp6dXBMcWJoTXF0VmdWaGFuWFh5YTBsc0NvSUh2NTdDbnAzSG9WT0dtME13dHNBM2hkOVVRTFg0ZVZVZDlNTG9pNW1YUkNtVm5mZHlhMUZzQzRJSHVQVUJRaGlOTlhkSkdRb3NqSUlVNnU3bk9UV05oRVhzaklJSG00aktnK2JnOERtNU5aVVQ5TTNvMTdFMmlCTXJlNytCOEFiMUhVSTRBcUFaTlNMV0JzRUQ5OHRaODFWK01nOUJkdUR3RVp1VGZjMFI1SmJyUTdDMU1vdXZkd3FZS0R4UnF0TWxHdFlIUVFQTmllM3BudWFROHV0MWdkaGFtWDNQb0FsNmpvRUVFbHV0VDRJSGx3OGhkQ1RSaGVFTXhZQmZFeGRoQUQ2MGozTm9lUldGd1FBVXl1N3B6SEV1SnpjbWc3emhTNElqN0c2NWV5QzRERzVzdk1lTkpWYkF6YXpycWQ3bWdQTHJTNElGN0YyVkhCQnVNZ2I0Q0czanFSN21nUEpyUzRJZVV5dTdId0tZSXE2amd1RTZ6eGVSVUM1MVFYaE1sYjJGRndRTGlORmJpWGc1WFJQczIrNTFRV2hnTW1WSFN2bFZoZUU0b3hURnlDSTBYUlBzNjlaaGd0Q0VTWlhkbklBL3FUcWZoS2xGOTl5cXd0Q2FheWFOTG9nbElhTDNEcWM3bW11S0xlNklKUmdjbVduc3R5cXRjYjRDRjhudDdvZ2xNZWFsck1MUW5sV1lZbmM2b0pRaHNubG5ZZlFmVlR3LzNqS2xIdlJCYUV5a2VWV1RkNFRVVlp1ZFVHb3dPVHl6a2V3UUc1MVFmQUgrNTZDQzRJLzJNdXRMZ2crbUZ6ZU9RWEFXbTUxUWZDUDNxc0gveFR0S2JnZytHUmkrZDU3QUxLQnZraUx4Y0lscnFkN21wc0tQK2lDRUl5aWswWk5sb2RCdURRcXVDQUU0eTZBLzFJWElZQTdoWEtyQzBJQUpwYnZmUVllSjdkZUJYQTcvd011Q01GaE9XbDBRUWdPRjduMVpyN2M2b0lRa0lubGUxK0RoOU5ZaFR5NTFRVWhIT1BVQlFoaTdGeHVkVUVJd2NUeXZXTW9sRnNsVWdOUGJuVkJDQStyalNqak9pRzZNTkFlZnhZeGZBVGdTc21HVXV6OG41Q3ZlNTlUN3ZWWUxQSi80ZWNBWHBEMkoyYTVjKytEai84WGYvSDVhd0IrYW5nUW5nYXc5MzlMbDE0U0xKUy9GZ0FBQUFCSlJVNUVya0pnZ2c9PSIvPjxpbWFnZSBpZD0iX0ltYWdlMTciIHdpZHRoPSI3OHB4IiBoZWlnaHQ9IjE4MHB4IiB4bGluazpocmVmPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUU0QUFBQzBDQVlBQUFBNm94cGlBQUFBQ1hCSVdYTUFBQTdFQUFBT3hBR1ZLdzRiQUFBS1UwbEVRVlI0bk8yZCs1TmJaUm5IUDFrbzVkNHhpUmFUMU5LaHUwbHF0Yld5RjVtT2pIaWxJcnZKS2pKZUJtVUdCeGtFQ20zNUcwVFFTc0VMVmJ4aVIyVEFzaGZHQ3FNRDRsaG9keGRGTjltNnV4R2FyT0ltMnd1OXR4dC95S1ptMDAxeVRzNTdPU2M1bjUvYTg3N25mWi85N25mZjl6em5QZWU4SG9BTmE2OWNCSHdPMkF5c3BRUVBIdkJRRVNIbGhYOVVLdCs0YzgrK3JaVmIwSU5udzlvcjd3YnVCZDZ6WUFYOXdyMEpYTFZ6ejc1VGxWdFJUd3V3bFFxaUNTTnY2ZXhsd00xaUFoRkhTNjBLZVlzL3RTQzJkTGUzVnZHdGVtb0taeE5XQTlmckRxSVVwd2dIc0VWM0FLVTRTYmhydTl0Yk8zVUhVY1N5Y0lySFFOdTR6a21PQTRoMXQ3ZTI2UTRDUkFtbnpuUWVZSk95M3FyUUFzem9Ec0lrdDNTM3QxNmhPNGdXNEJHWkhVZ1lBeThBN2hMZHFGbUt3aDNYSFloSjd1aHViNzFjWndBdGd5T3B0NENmNkF6Q0VQT051d1M0VFU4Z0JZcVR3MFBBck01QTZtQmpkM3ZyQmJvNmJ3RVlIRW1OQTA5VnJDVngxclF3QmdhQkx3Z014UlNsbHlNUDZBckNBcHQ3MnR1MFhJdWU3WFJ3SkxVWGVFRkhFQlpZQlh4YVI4Zmx2eTBudWs1TEdsWXUzTytCRVIyQldCaEgxL2UwdDEwak1CSkR6Qk51Y0NTVngyYXVNemg1S0hmZFFnUHJiNENVNGppczB0M1QzaFpWMmVFNXdnMk9wRTVUdUs1ekdrcVQvMHBUK2VOQVZtVWdBdmh5VDN0YlFGVm5Dd28zT0pJNkNteFRGWVFWU3NiQVJjQTlxdnF0ZHZINEtIQk1WU0NDdUwybm8yMkppbzRxQ2pjNGtwb0dmZ1NDYmcycHVkbDVHWEM3aW81cXBTdmZCczZvQ0VRZzkvUjB0QzJXM1VsVjRRWkhVaW5nMTdLREVNd1Z3SmRrZDJJa1FmNlc3Q0Frc0xtblEyN3lYN1B4d1pIVUNMQ3JXaDJiUENaUlNoaTRVV1lIUm44cjM1UVpoQ1R1Nytsb2svYThpVkhoL2dEc3JWckRkcWFqQzFndnEzRkR3czBsLzA1MG5iVGszOHdBK2pRd1VVOG5Hc2ZBRzNvNjJsYkxhTml3Y0FQRGsyZUFCMlVFSVJrcHliL1pLZnVud0g4bHhHR00rb3o3eFZoSGVKbmdTTXdKTnpBOGVReDRXSFFRa2prZkNjbC9QUmVKM3dPT2lBNUVNbCtMZFlUZkliSkIwOElOREUvbWdPMGlnMUF3ZVZ3S2ZGMWtnL1dtSmQ4QlRvc01SQUYzeHpyQ0Y0cHFyQzdoQm9ZbjN3QjJpQXBDRWU4Q2JoSFZtSlZFV0h6eUwrSXZ0bm9ibTJJZDRmTUU5RksvY0FQRGszOERCa1VFVVF1QlkrQktJQ2FpSWF1M1hteTFCbXVRTGJIT3NPWGszNnB3THdLN3JRYWhtSGJnV3F1TldCSnVZSGpTZGl2L0JybmZhZ01pN3BMdUJQWUphS2R1NmhnRFB4WHJETC9mU3ArV2hadEwvcDE0ZTkzU0xTZFI5K1YvQWZ5blppMTczZXk4T2RZWlhsN3Z5VUtFR3hpZVBFN2h2VmNuY1I2d3NkNlRSYTRFL1FCNFcyQjdLcmd0MWhuMjFYT2lNT0g2aHljT0FEOFUxWjVJcWt3ZUZ3TjMxTk9tNkxYSHJZQ3QzcDAzd0YzeHpzakZaazhTS2x6LzBNUis0QW1SYlNyQUQzekY3RWt5VnJ1ZGVHbXlLZDRaT2QvTUNjS0Y2eCthK0FmUUo3cGRtZVRKcndCNnpad2o2L2tLSjZaaFcrS2RFY1BKdnhUaCtvY20vZ1Q4dWZTWURaOHZLV2NkOEZHamxXVSswU1BIZFhKdmRocE93MlFLMXdja0pMWXZnNC9IT3lQcmpGU1VKbHovME1Rc3pweGhOeHVwSlB2TnV5ZUFqSkdLTmhvRGI0cDNSbGJVcWlSVnVQNmhpUk00TC9sdkFlNHpVa2syandHSEZQUWprbHZqWFpGM1Zxc2dYYmorb1ltRHdQZGw5ek1QNjMvMUZ3RjNWcXVnNnUzaTd3SW5EZFdzOEVOckdBUHZqSGRGTHFsVXFFUzQvcUdKS2VEbkt2b1NpQmU0dFZLaHl2ZlpIOFJ1Tjg5cmMxKzhLN0pvb1FKbHd2VVBUU1FwcklnNWllVVVQcnA2RHFxL29DRHRBV3lKWStDV2VOZTV5YjlTNGZxR3h2OEN2S1N5VHdHc0FUNVJmbEQ5Tnp2eWpmSFl2NDZQblR3SC9GMUR2MWE0cnJjcmVuWHBBZVhDOVEyTk96WDVuK2M2WFo5NjNBSHNWOW1oZ01tanQ3Y3J1ckw0SHkzQzllMGRQMG5oT1dMN2NxN084NUovblI4WDNRNGMwTmgvUFh5MXR5dTZGRFFLMTdkMy9EQ0ZkeWFjeEdMZ0cxRDF1L2Z5K2N3SHIxb0svR3N1SUNOZjJqZFdYcUdPcWZLeU9pVmxCNEJsUXA3QXJwZXhxWmtqNFlBM0JGd05qaEh1UW1EYURoOVFmZ2puSmYvM2FuVWN3TmpVVEM0YzhLNEdWdWwwVkszeXNyTEw3ZUE0Y01ES2YvbDFvQzJFNjlzNy9pcUY5LzRkZ3kyRW0rTUJHeTBSMXNST3d2ME8rS3Z1SUl5aWZYSW9NalkxUXpqZ1BlekJFN2ZqNUZCZWJpZkhBVHdKdktFN0NDUFl4bkVBWTFNenMrR0FkeGE0dnA2TFlKR09xbFZ1TjhjQi9Cakk2UTZpRnJaeUhFQnlLbmNxSFBCZWltZmhOL3hjeDFWbkd6YmZZOEoyamdOSVR1V09oZ1BlQUlWM1MrZmhPcTQycHZlWVVIa0JiVXZIQVNRenVabHd3THVLd3ZaNVo3RnlJNkJaSEFjMlR2NXRMZHl6ZS80NUJEeXZPNDZGc0xWd2N3aHpuY2d4MEFuQ1BROE1hK201aXM2Mm5SeUtKRE01d2dIdlFlQ3pJSGZkNFp6Sm9heU9reWFISWs4Qms3cURLTVgyamdOSVpuS3o0WUQzTkxEQkppdGRqbkVjRkhhcm05WWRSQkZIT0E0Z21jbWRDZ2U4RjNud2ZBUndIV2VTUjRHanVvTUFCemtPSUpuSkhZc0VmRXVCd2w3U0d0ZFduZVk0S0R3ZXBtV1BpZElMYUVjNURpQ1p5UjJJQkh4aDRIMDZGMnljNkRpd1FmTHZTT0YyN3RuM0dvVjFXRzA0VXJnNXRENzI3MlRoL2dqc3FWcEQ0ZzFoeDAwT1JaS1pISkdnYndhNHFmUzRxblVISnpzTzRCbGdYRWZIam5VY1FES1R5MGVDdnBQQURjVmpydU9NOHpQZ0xkV2RPdHB4QU1sTTduUWs2RnNNWEZjOHBtS2xxeEVjQnhyMm1IQzg0d0NTbWR6eFNORG5CejRFcnVQTW9uU1BpWVp3SEVBeWt6c1VDZnBXQW11RUx0ZzBnZU5BNFI0VERTWGN6bGYzdlE0TXFPaXJvWVNiUThrdHAwWVU3aVVVN0RIUk1KTkRrYm5rUHd0OEhwQzIwdFdJamdONEZoaVQyVUhET1E0Z2tjbm1JMEhmY2VCRzEzSG0rU1h3NzVxMTZyeloyWkNPQTBoa3NxY2pRZDhpUEh5c3ZFeEUydFhJam9QQ0hoT0haVFRjc0k0RFNHU3l4eU5CbnhlNHB2UzQ2emhqU05sam9xRWRCNUJJWnc5SGdyNFZ3QWVLeDF6SEdVZDQ4dC93amdOSXBMUFRrYUJ2SFJBRzEzRm1FWnI4TjQxd3YzMWw3R1hnWlZIdE5ZMXdjd2h6WGJNSjF3K01pbWlvS1NhSElvbDBOaDhKK281NjhIVFBLM0FuQjBQOENvTjdURlNqcVJ3SGtFaG56MFNEL2haS3YrM3JPczR3andFSHJUVFFkSTREU0tTeko2SkIveEpnUGVBNnppUVBZMkdQaWFaMEhFQWluWDA3R3ZRdkI5YlZkRnpoNEx6eVpuWWNXTmhqb21rZEI1QklaN1BSb0g4TkhxTGxaYlVXYkpyZGNWRG5ZLzlOTDl3enJ5UjNBeSthUGEvcGhRUHEybVBDRmE3QWM4RHJSaXZueVRmMzVGQWtrYzRTRGZtUEFMSGlzVm9Yd2E3ai9zOE80RTJqbFYzSHpaRklaMmVqSVQvQUo4RjFuRm0yQXpOR0tycU9LeUdSenA2TWh2eVhBUjkySFdlZWJjQ0pXcFZjeDVXUlNHZVBSRVArb0FmUHZPMmtYTWNabytabkpsM0hMVUFpbmMxRlEvN1Z3SHZQSG5RZFo1aXF6NXU0d2xYZzZkMkpxbnRNdU1KVnAyTHk3d3BYblYzQWF3c1Z1Sk5ERlViVDAwUkQva05BcnpzNW1PZEpDcHV1emNOMVhBMUcwOU96MFpEL0RHVjdUTGlPTThiamxPMHg0VHJPQUtQcDZWUFJrUDhTU3ZhWWNCMW5uRWVBWThYL3VJNHp5R2g2K21nMDVIODMwQUd1NDh4eU52bDNIV2VDMGYzVEI2SWhmeFJZN1RyT1BOby9NK2xZNGwyUlhlNmZhaDFFUS80cDkwKzFQbDc0SDFVR1JaZkhGSEF1QUFBQUFFbEZUa1N1UW1DQyIvPjxpbWFnZSBpZD0iX0ltYWdlMTkiIHdpZHRoPSI2MHB4IiBoZWlnaHQ9IjE0MHB4IiB4bGluazpocmVmPSJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUR3QUFBQ01DQVlBQUFBZ05zb0hBQUFBQ1hCSVdYTUFBQTdFQUFBT3hBR1ZLdzRiQUFBSHBrbEVRVlI0bk9XZDE0OGJSUnpIUDNzRUVBR0JiSVBBdG9DQXVQVkNLQW5nQXdFQ1JCT0VjZzcxZ1JkNGdBY1FUVVRoYndCQ0UwMTBBUUlFRWlVSlozb0hvU2psVEQvN1NNNjA5VkZ1ZmFTM08vT3c5dUU0WG52TGJQWDM2WGJLYjM3ZisrN003c3h2ZGl3QkxKZzNaeFp3RmJBSU9KRW1TRWdnWVFoVCtmb2Zkdk1mV3JwcTlIYmpGcXhCV2pCdnptM0FIY0RoaGc3NVMzZ3pjTmpTVmFNVHhxMllSeC93SUFaa0FXclVSTFRqQkxPQm0wVVo2eE5seUdYY01wanRueTNDVUZnSUh3aGNMOEpRV0FnRExCck05czl5YXNReFlRLzcrQnowSjRramlGSFl1M0h0cnNGc2Y0ZG5RbmVFNlpZR09BRTQzNGtCMXdtN2NNdmY1YVJ5SDFBVjVJaTcrUC8vZHM1Z3R2OWt1MmI2Z0VkRStPTXhiS3ZjQnp3TWJCWG5peWU0WWpEYjMyK25ZbCsrVVA0YmVGYXdRNlpoczQ5THdKMTJLallHcmZ1QWFjTlN2cjlPdDhWMWc5bitRNnhXNmdQSUY4cnJnTmVFdStRdTlnWnV0VnFwK2JGMGp6aGZQTU5OdWF5OHY1VUtNNFR6aGZJdzhJRndsOHpDb050MDZlTUhBRGRZYWFiMXhlTnVLNVVEZ2p0eVdYa3ZzNFZiQ1g4TXJCYnJqK3RJQTllYUxid0w0WHloWENPY0tpL09aV1ZUcjhudENyMEJyQlhyajN1bzkzRUZ1TlJNK2QwSTV3dmxLV0NKV0xjOHdXSXpoWXh1ZytlQnY4VDU0Z2xPeTJYbE03b1Zha3M0WHlodkFSNFM2bzQzYjJ0ZEp4V2RPdnJqd0VZSXhGS3RXVnlTRzVDUDdWVEFrSEMrVUs0Q1R3cDN5WDBzNnBUWmJTaC9BTmdoemhkUGNHMXVRRDdVS0xNajRYeWgvRHZ3a25DWDNNVXM5TkJSVzVoNVdIZWRWQVN3ajkrWUc1RGo3VEs2RXM0WHlqOEJ5NFM3NUM3MkJXNXFsMkYyMWJMNzFERndJbk5yYmtEZXB6WFJGT0Y4b2Z3VjhKVndsOXpGUWNCMXJZbFcxcVZ0VHlxRTlYSHJaaGJsQnVSZDRsRldDQThCUDFwdTBsOGNDVnpSbkdDYThORHcyRFJ3cjJpUFBNRGloUU9abVhpVTFWREx5OER2WXYxeC9iRjJJbkJ1NDhJUzRhSGhzZTNvYjE5aHc4eWt3azR3N1NsZ1Vwd3ZndEgrWmpsdjRVRG1KTEJCZUdoNGJBUHdxRE92Zk1GaTZMamh5QmdYenovaVlPQVg5TVZ3ZEVQK2JXK1NXaE4zdTVSQWo2eklleGk3WUl6UjhjbE5jaktXQm1iQ2xpRWdMQUY3T2dtSUw2RlRQQ3FZdU42V3dnQ2o0NU5WT1JtYkM4eUZVQ2dNTU12cGxvZEF4S09zUE1jZEVSNGFIbHNOZk9URWh0Y1FzYWtsVkpFS0VZUS9CSVpObGZScHp0eDh5OXNldEJvWUhaOUVUc1ltSmFRclhkNUdiQzdmb0V3alg5UStyZGVCTVVHMlhJVmpoUUZHeHllbjVXUnNCeElYRzVXSm1zSUF6d0YvQzdUbkNvUW9ERkFhcis2VWs3RzlnWFBhNVVkUllZREhnRTJDYlFxRk1JVUJTcFhxRmprWk93ZzR0VFV2cWdvRDNBL3NkTUd1RUFoVkdLQlVxYTZYazdHajBQYzI3NEpPRXdoUkNuYkxkMnUvZEdCWE4xMGgvUGFhZGQranIyTUhEbTd1aUxjMHFmQXFBdWttNFMrQnIxMjBid3V1RVg1N3picEFibkp6K3lPUDVjQ0l5MjNzamc2OVEvaGpxUm1sU3JVbUoyTmJnRUVJeHJxV0Y5OHR2UVNvSHJSakNxNHFERkNxVktma1pLd1B1S0JYRkFaOXY5ZS9IclhWRWE0ckRGQ3FWTGZKeWRnQkV0SVpuaXdEdFNuanRjS2c3OTNjNW1GN2JlR0p3Z0NsU25Wakpoay9GSW1Uak1wRVRXR0FKWDd2WXZOTVlZQlNwYXBsa3ZIamtEaW1YYjRYaXdCK2ZEL3M2K3VtNTRTWHIxbTdFdmpFNjNZYjhPc0xjZDlVOW92dys4QTNmalRzNmFEVlFLbFNKWk9LcjZkbGwxeFVCNjBHWGdQS1hqZnFpOElBcFVwMU9wT0tUd0VMR21sUlZ4ajBMOU90bjZMazROWEZONFVCU3BYcWprd3F2Zzl3Tm5pek51MjN3cUNmTXJIWnE4WjhWUmowZUZRbUZUOFlPS1ZYRkFZOUhqWGx4YnpDZDRVQlNwWHF2NWxVdkI4NDNsVDhTYit3bFI4VWhVRjBQTXJnWmdrTTRlV3IxMzRMdkFQWVBRREJGQUpEdUE3WEp4VkJJL3c1c01MTkJnSXhhRFZRbjFSb3dEVnVyVTBIVFdHQXBVREpUa1V6ZlR4UUNnTVVLMW90azRwdlJlS3lkdmxPVnk2RHFEREFpMERGRGNPQlV4aWdXTkdtTXFuNEhyUTU4QytxQ2dNOEFhd1hhYkJHTFpnS0F4UlZiVnNtRlk4QnB6ZW5PNTFnQkZsaDBFOUczaTdTWUdBVkJpaXEyc1pNS240NFRZZDhSMTFoMEwrUEVqWnZETFRDQUVWVm04aWs0aWNBUjBOdktBd0NKeFdoSUx4czFjOHJnTTlFMkFvRjRUcDJWZGxtcnc0VDRYZUI3NXdhQ2Z5ZzFVQlIxY2lrNGhza3BNdG5FbTJzYTRWSllZQlhnVitkR0FpTndnQkZWWnRXVW9scDRDS2dKeFFHZUFiUTdGWU9sY0lBUlZYYm9hUVMrd0puMlZubUNhUENvQjhDdnNWT3hkQXBERkJVdGMxS0tuRUlFZ090ZVZGVkdQUkR3S2VzVmdxbHdnQkZWWnRVMGdrRk9LNDVQY29LUTV0REY3b3QxWWFhOE5LVm93WGdQU3QxUWsyNERrdFR4eWdRL2hSWWFiWndhQWV0Qm9xcWhwSk9WSUdyRzJtZFhpK2pvRERBbThDb21ZS2hWeGlncUdvMUpaM1lSdjBVOFY1UUdPQUY0TTl1aFNLaE1FQlIxWFlxNmNTZXdMbTlvakRvaDRCdjZGUWdNZ29ERkZWdHE1Sk94Q1drMDJZU0k2NHc2UEVvdzBQQUk2VXdRRkhWTmlqcHhCeGdQdEFUQ2tPSDM2bUluTUlBSStyRVAwbzZNUjlRZWtWaE1KaFVSSmJ3V3l0TFh3TmZ0S1pIbG5BZHV5MFFSSjF3bmhvL05DZEVjdEJxWUVTZHFDbnB4RVlrRmpiU29xNHd3Q3ZBYjQyTFNDc01NS0pPVEN2cFJBMjRFSHBEWVlDbnFmOG9iZVFWQmhqNVkySzdrazdzQjV6Wkt3cEQvVWRwZTBKaGdKRS9KallwNlVTcWx4UUd1TzgvcDJtejZabnlxVUlBQUFBQVNVVk9SSzVDWUlJPSIvPjwvZGVmcz48L3N2Zz4=\"","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAFWmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgZXhpZjpQaXhlbFhEaW1lbnNpb249IjI1NiIKICAgZXhpZjpQaXhlbFlEaW1lbnNpb249IjI1NiIKICAgZXhpZjpDb2xvclNwYWNlPSIxIgogICB0aWZmOkltYWdlV2lkdGg9IjI1NiIKICAgdGlmZjpJbWFnZUxlbmd0aD0iMjU2IgogICB0aWZmOlJlc29sdXRpb25Vbml0PSIyIgogICB0aWZmOlhSZXNvbHV0aW9uPSI3Mi4wIgogICB0aWZmOllSZXNvbHV0aW9uPSI3Mi4wIgogICBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIgogICBwaG90b3Nob3A6SUNDUHJv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\"","export default \"data:image/png;base64,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\"","export default \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+Cjxzdmcgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgdmlld0JveD0iMCAwIDUwMCA1MDAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgeG1sbnM6c2VyaWY9Imh0dHA6Ly93d3cuc2VyaWYuY29tLyIgc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDoyOyI+CiAgICA8ZyB0cmFuc2Zvcm09Im1hdHJpeCgwLjgxMDM3MywwLjgxMDM3MywtMC44MTAzNzMsMC44MTAzNzMsMjQwLjY4MSwtMTQ1Ljg2NykiPgogICAgICAgIDxyZWN0IHg9IjAiIHk9IjE4MCIgd2lkdGg9IjUwMCIgaGVpZ2h0PSIxMTciIHN0eWxlPSJmaWxsOndoaXRlOyIvPgogICAgPC9nPgogICAgPGcgdHJhbnNmb3JtPSJtYXRyaXgoMC44MTAzNzMsLTAuODEwMzczLDAuODEwMzczLDAuODEwMzczLC0xNDUuODY3LDI1OS4zMTkpIj4KICAgICAgICA8cmVjdCB4PSIwIiB5PSIxODAiIHdpZHRoPSI1MDAiIGhlaWdodD0iMTE3IiBzdHlsZT0iZmlsbDp3aGl0ZTsiLz4KICAgIDwvZz4KPC9zdmc+Cg==\"","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAFWmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgZXhpZjpQaXhlbFhEaW1lbnNpb249IjI1NiIKICAgZXhpZjpQaXhlbFlEaW1lbnNpb249IjI1NiIKICAgZXhpZjpDb2xvclNwYWNlPSIxIgogICB0aWZmOkltYWdlV2lkdGg9IjI1NiIKICAgdGlmZjpJbWFnZUxlbmd0aD0iMjU2IgogICB0aWZmOlJlc29sdXRpb25Vbml0PSIyIgogICB0aWZmOlhSZXNvbHV0aW9uPSI3Mi4wIgogICB0aWZmOllSZXNvbHV0aW9uPSI3Mi4wIgogICBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIgogICBwaG90b3Nob3A6SUNDUHJv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\"","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAFWmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgZXhpZjpQaXhlbFhEaW1lbnNpb249IjI1NiIKICAgZXhpZjpQaXhlbFlEaW1lbnNpb249IjI1NiIKICAgZXhpZjpDb2xvclNwYWNlPSIxIgogICB0aWZmOkltYWdlV2lkdGg9IjI1NiIKICAgdGlmZjpJbWFnZUxlbmd0aD0iMjU2IgogICB0aWZmOlJlc29sdXRpb25Vbml0PSIyIgogICB0aWZmOlhSZXNvbHV0aW9uPSI3Mi4wIgogICB0aWZmOllSZXNvbHV0aW9uPSI3Mi4wIgogICBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIgogICBwaG90b3Nob3A6SUNDUHJv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\"","export default \"data:image/png;base64,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\"","export default \"data:image/png;base64,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\"","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAFUmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgeG1sbnM6ZXhpZj0iaHR0cDovL25zLmFkb2JlLmNvbS9leGlmLzEuMC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgZXhpZjpQaXhlbFhEaW1lbnNpb249IjUxMiIKICAgZXhpZjpQaXhlbFlEaW1lbnNpb249IjUxMiIKICAgZXhpZjpDb2xvclNwYWNlPSIxIgogICB0aWZmOkltYWdlV2lkdGg9IjUxMiIKICAgdGlmZjpJbWFnZUxlbmd0aD0iNTEyIgogICB0aWZmOlJlc29sdXRpb25Vbml0PSIyIgogICB0aWZmOlhSZXNvbHV0aW9uPSI3Mi4wIgogICB0aWZmOllSZXNvbHV0aW9uPSI3Mi4wIgogICBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIgogICBwaG90b3Nob3A6SUNDUHJv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\"","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nc = undefined;","import api from \"!../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../node_modules/css-loader/dist/cjs.js!../../node_modules/sass-loader/dist/cjs.js!./main.scss\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nexport default content.locals || {};","/**\n * @license\n * Copyright 2010-2023 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nconst REVISION = '154';\n\nconst MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };\nconst TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };\nconst CullFaceNone = 0;\nconst CullFaceBack = 1;\nconst CullFaceFront = 2;\nconst CullFaceFrontBack = 3;\nconst BasicShadowMap = 0;\nconst PCFShadowMap = 1;\nconst PCFSoftShadowMap = 2;\nconst VSMShadowMap = 3;\nconst FrontSide = 0;\nconst BackSide = 1;\nconst DoubleSide = 2;\nconst TwoPassDoubleSide = 2; // r149\nconst NoBlending = 0;\nconst NormalBlending = 1;\nconst AdditiveBlending = 2;\nconst SubtractiveBlending = 3;\nconst MultiplyBlending = 4;\nconst CustomBlending = 5;\nconst AddEquation = 100;\nconst SubtractEquation = 101;\nconst ReverseSubtractEquation = 102;\nconst MinEquation = 103;\nconst MaxEquation = 104;\nconst ZeroFactor = 200;\nconst OneFactor = 201;\nconst SrcColorFactor = 202;\nconst OneMinusSrcColorFactor = 203;\nconst SrcAlphaFactor = 204;\nconst OneMinusSrcAlphaFactor = 205;\nconst DstAlphaFactor = 206;\nconst OneMinusDstAlphaFactor = 207;\nconst DstColorFactor = 208;\nconst OneMinusDstColorFactor = 209;\nconst SrcAlphaSaturateFactor = 210;\nconst NeverDepth = 0;\nconst AlwaysDepth = 1;\nconst LessDepth = 2;\nconst LessEqualDepth = 3;\nconst EqualDepth = 4;\nconst GreaterEqualDepth = 5;\nconst GreaterDepth = 6;\nconst NotEqualDepth = 7;\nconst MultiplyOperation = 0;\nconst MixOperation = 1;\nconst AddOperation = 2;\nconst NoToneMapping = 0;\nconst LinearToneMapping = 1;\nconst ReinhardToneMapping = 2;\nconst CineonToneMapping = 3;\nconst ACESFilmicToneMapping = 4;\nconst CustomToneMapping = 5;\n\nconst UVMapping = 300;\nconst CubeReflectionMapping = 301;\nconst CubeRefractionMapping = 302;\nconst EquirectangularReflectionMapping = 303;\nconst EquirectangularRefractionMapping = 304;\nconst CubeUVReflectionMapping = 306;\nconst RepeatWrapping = 1000;\nconst ClampToEdgeWrapping = 1001;\nconst MirroredRepeatWrapping = 1002;\nconst NearestFilter = 1003;\nconst NearestMipmapNearestFilter = 1004;\nconst NearestMipMapNearestFilter = 1004;\nconst NearestMipmapLinearFilter = 1005;\nconst NearestMipMapLinearFilter = 1005;\nconst LinearFilter = 1006;\nconst LinearMipmapNearestFilter = 1007;\nconst LinearMipMapNearestFilter = 1007;\nconst LinearMipmapLinearFilter = 1008;\nconst LinearMipMapLinearFilter = 1008;\nconst UnsignedByteType = 1009;\nconst ByteType = 1010;\nconst ShortType = 1011;\nconst UnsignedShortType = 1012;\nconst IntType = 1013;\nconst UnsignedIntType = 1014;\nconst FloatType = 1015;\nconst HalfFloatType = 1016;\nconst UnsignedShort4444Type = 1017;\nconst UnsignedShort5551Type = 1018;\nconst UnsignedInt248Type = 1020;\nconst AlphaFormat = 1021;\nconst RGBAFormat = 1023;\nconst LuminanceFormat = 1024;\nconst LuminanceAlphaFormat = 1025;\nconst DepthFormat = 1026;\nconst DepthStencilFormat = 1027;\nconst RedFormat = 1028;\nconst RedIntegerFormat = 1029;\nconst RGFormat = 1030;\nconst RGIntegerFormat = 1031;\nconst RGBAIntegerFormat = 1033;\n\nconst RGB_S3TC_DXT1_Format = 33776;\nconst RGBA_S3TC_DXT1_Format = 33777;\nconst RGBA_S3TC_DXT3_Format = 33778;\nconst RGBA_S3TC_DXT5_Format = 33779;\nconst RGB_PVRTC_4BPPV1_Format = 35840;\nconst RGB_PVRTC_2BPPV1_Format = 35841;\nconst RGBA_PVRTC_4BPPV1_Format = 35842;\nconst RGBA_PVRTC_2BPPV1_Format = 35843;\nconst RGB_ETC1_Format = 36196;\nconst RGB_ETC2_Format = 37492;\nconst RGBA_ETC2_EAC_Format = 37496;\nconst RGBA_ASTC_4x4_Format = 37808;\nconst RGBA_ASTC_5x4_Format = 37809;\nconst RGBA_ASTC_5x5_Format = 37810;\nconst RGBA_ASTC_6x5_Format = 37811;\nconst RGBA_ASTC_6x6_Format = 37812;\nconst RGBA_ASTC_8x5_Format = 37813;\nconst RGBA_ASTC_8x6_Format = 37814;\nconst RGBA_ASTC_8x8_Format = 37815;\nconst RGBA_ASTC_10x5_Format = 37816;\nconst RGBA_ASTC_10x6_Format = 37817;\nconst RGBA_ASTC_10x8_Format = 37818;\nconst RGBA_ASTC_10x10_Format = 37819;\nconst RGBA_ASTC_12x10_Format = 37820;\nconst RGBA_ASTC_12x12_Format = 37821;\nconst RGBA_BPTC_Format = 36492;\nconst RED_RGTC1_Format = 36283;\nconst SIGNED_RED_RGTC1_Format = 36284;\nconst RED_GREEN_RGTC2_Format = 36285;\nconst SIGNED_RED_GREEN_RGTC2_Format = 36286;\nconst LoopOnce = 2200;\nconst LoopRepeat = 2201;\nconst LoopPingPong = 2202;\nconst InterpolateDiscrete = 2300;\nconst InterpolateLinear = 2301;\nconst InterpolateSmooth = 2302;\nconst ZeroCurvatureEnding = 2400;\nconst ZeroSlopeEnding = 2401;\nconst WrapAroundEnding = 2402;\nconst NormalAnimationBlendMode = 2500;\nconst AdditiveAnimationBlendMode = 2501;\nconst TrianglesDrawMode = 0;\nconst TriangleStripDrawMode = 1;\nconst TriangleFanDrawMode = 2;\n/** @deprecated Use LinearSRGBColorSpace or NoColorSpace in three.js r152+. */\nconst LinearEncoding = 3000;\n/** @deprecated Use SRGBColorSpace in three.js r152+. */\nconst sRGBEncoding = 3001;\nconst BasicDepthPacking = 3200;\nconst RGBADepthPacking = 3201;\nconst TangentSpaceNormalMap = 0;\nconst ObjectSpaceNormalMap = 1;\n\n// Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.\nconst NoColorSpace = '';\nconst SRGBColorSpace = 'srgb';\nconst LinearSRGBColorSpace = 'srgb-linear';\nconst DisplayP3ColorSpace = 'display-p3';\n\nconst ZeroStencilOp = 0;\nconst KeepStencilOp = 7680;\nconst ReplaceStencilOp = 7681;\nconst IncrementStencilOp = 7682;\nconst DecrementStencilOp = 7683;\nconst IncrementWrapStencilOp = 34055;\nconst DecrementWrapStencilOp = 34056;\nconst InvertStencilOp = 5386;\n\nconst NeverStencilFunc = 512;\nconst LessStencilFunc = 513;\nconst EqualStencilFunc = 514;\nconst LessEqualStencilFunc = 515;\nconst GreaterStencilFunc = 516;\nconst NotEqualStencilFunc = 517;\nconst GreaterEqualStencilFunc = 518;\nconst AlwaysStencilFunc = 519;\n\nconst NeverCompare = 512;\nconst LessCompare = 513;\nconst EqualCompare = 514;\nconst LessEqualCompare = 515;\nconst GreaterCompare = 516;\nconst NotEqualCompare = 517;\nconst GreaterEqualCompare = 518;\nconst AlwaysCompare = 519;\n\nconst StaticDrawUsage = 35044;\nconst DynamicDrawUsage = 35048;\nconst StreamDrawUsage = 35040;\nconst StaticReadUsage = 35045;\nconst DynamicReadUsage = 35049;\nconst StreamReadUsage = 35041;\nconst StaticCopyUsage = 35046;\nconst DynamicCopyUsage = 35050;\nconst StreamCopyUsage = 35042;\n\nconst GLSL1 = '100';\nconst GLSL3 = '300 es';\n\nconst _SRGBAFormat = 1035; // fallback for WebGL 1\n\nconst WebGLCoordinateSystem = 2000;\nconst WebGPUCoordinateSystem = 2001;\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nclass EventDispatcher {\n\n\taddEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tconst listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t}\n\n\thasEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tconst listeners = this._listeners;\n\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\n\n\t}\n\n\tremoveEventListener( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tconst index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tdispatchEvent( event ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tconst listeners = this._listeners;\n\t\tconst listenerArray = listeners[ event.type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tevent.target = this;\n\n\t\t\t// Make a copy, in case listeners are removed while iterating.\n\t\t\tconst array = listenerArray.slice( 0 );\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t}\n\n\t\t\tevent.target = null;\n\n\t\t}\n\n\t}\n\n}\n\nconst _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];\n\nlet _seed = 1234567;\n\n\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\n\n// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\nfunction generateUUID() {\n\n\tconst d0 = Math.random() * 0xffffffff | 0;\n\tconst d1 = Math.random() * 0xffffffff | 0;\n\tconst d2 = Math.random() * 0xffffffff | 0;\n\tconst d3 = Math.random() * 0xffffffff | 0;\n\tconst uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +\n\t\t\t_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +\n\t\t\t_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];\n\n\t// .toLowerCase() here flattens concatenated strings to save heap memory space.\n\treturn uuid.toLowerCase();\n\n}\n\nfunction clamp( value, min, max ) {\n\n\treturn Math.max( min, Math.min( max, value ) );\n\n}\n\n// compute euclidean modulo of m % n\n// https://en.wikipedia.org/wiki/Modulo_operation\nfunction euclideanModulo( n, m ) {\n\n\treturn ( ( n % m ) + m ) % m;\n\n}\n\n// Linear mapping from range <a1, a2> to range <b1, b2>\nfunction mapLinear( x, a1, a2, b1, b2 ) {\n\n\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n}\n\n// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/\nfunction inverseLerp( x, y, value ) {\n\n\tif ( x !== y ) {\n\n\t\treturn ( value - x ) / ( y - x );\n\n\t} else {\n\n\t\treturn 0;\n\n\t}\n\n}\n\n// https://en.wikipedia.org/wiki/Linear_interpolation\nfunction lerp( x, y, t ) {\n\n\treturn ( 1 - t ) * x + t * y;\n\n}\n\n// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/\nfunction damp( x, y, lambda, dt ) {\n\n\treturn lerp( x, y, 1 - Math.exp( - lambda * dt ) );\n\n}\n\n// https://www.desmos.com/calculator/vcsjnyz7x4\nfunction pingpong( x, length = 1 ) {\n\n\treturn length - Math.abs( euclideanModulo( x, length * 2 ) - length );\n\n}\n\n// http://en.wikipedia.org/wiki/Smoothstep\nfunction smoothstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * ( 3 - 2 * x );\n\n}\n\nfunction smootherstep( x, min, max ) {\n\n\tif ( x <= min ) return 0;\n\tif ( x >= max ) return 1;\n\n\tx = ( x - min ) / ( max - min );\n\n\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\n\n}\n\n// Random integer from <low, high> interval\nfunction randInt( low, high ) {\n\n\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n}\n\n// Random float from <low, high> interval\nfunction randFloat( low, high ) {\n\n\treturn low + Math.random() * ( high - low );\n\n}\n\n// Random float from <-range/2, range/2> interval\nfunction randFloatSpread( range ) {\n\n\treturn range * ( 0.5 - Math.random() );\n\n}\n\n// Deterministic pseudo-random float in the interval [ 0, 1 ]\nfunction seededRandom( s ) {\n\n\tif ( s !== undefined ) _seed = s;\n\n\t// Mulberry32 generator\n\n\tlet t = _seed += 0x6D2B79F5;\n\n\tt = Math.imul( t ^ t >>> 15, t | 1 );\n\n\tt ^= t + Math.imul( t ^ t >>> 7, t | 61 );\n\n\treturn ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;\n\n}\n\nfunction degToRad( degrees ) {\n\n\treturn degrees * DEG2RAD;\n\n}\n\nfunction radToDeg( radians ) {\n\n\treturn radians * RAD2DEG;\n\n}\n\nfunction isPowerOfTwo( value ) {\n\n\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\n\n}\n\nfunction ceilPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction floorPowerOfTwo( value ) {\n\n\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\n\n}\n\nfunction setQuaternionFromProperEuler( q, a, b, c, order ) {\n\n\t// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles\n\n\t// rotations are applied to the axes in the order specified by 'order'\n\t// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'\n\t// angles are in radians\n\n\tconst cos = Math.cos;\n\tconst sin = Math.sin;\n\n\tconst c2 = cos( b / 2 );\n\tconst s2 = sin( b / 2 );\n\n\tconst c13 = cos( ( a + c ) / 2 );\n\tconst s13 = sin( ( a + c ) / 2 );\n\n\tconst c1_3 = cos( ( a - c ) / 2 );\n\tconst s1_3 = sin( ( a - c ) / 2 );\n\n\tconst c3_1 = cos( ( c - a ) / 2 );\n\tconst s3_1 = sin( ( c - a ) / 2 );\n\n\tswitch ( order ) {\n\n\t\tcase 'XYX':\n\t\t\tq.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YZY':\n\t\t\tq.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZXZ':\n\t\t\tq.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'XZX':\n\t\t\tq.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'YXY':\n\t\t\tq.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );\n\t\t\tbreak;\n\n\t\tcase 'ZYZ':\n\t\t\tq.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );\n\n\t}\n\n}\n\nfunction denormalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn value / 4294967295.0;\n\n\t\tcase Uint16Array:\n\n\t\t\treturn value / 65535.0;\n\n\t\tcase Uint8Array:\n\n\t\t\treturn value / 255.0;\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.max( value / 2147483647.0, - 1.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.max( value / 32767.0, - 1.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.max( value / 127.0, - 1.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nfunction normalize( value, array ) {\n\n\tswitch ( array.constructor ) {\n\n\t\tcase Float32Array:\n\n\t\t\treturn value;\n\n\t\tcase Uint32Array:\n\n\t\t\treturn Math.round( value * 4294967295.0 );\n\n\t\tcase Uint16Array:\n\n\t\t\treturn Math.round( value * 65535.0 );\n\n\t\tcase Uint8Array:\n\n\t\t\treturn Math.round( value * 255.0 );\n\n\t\tcase Int32Array:\n\n\t\t\treturn Math.round( value * 2147483647.0 );\n\n\t\tcase Int16Array:\n\n\t\t\treturn Math.round( value * 32767.0 );\n\n\t\tcase Int8Array:\n\n\t\t\treturn Math.round( value * 127.0 );\n\n\t\tdefault:\n\n\t\t\tthrow new Error( 'Invalid component type.' );\n\n\t}\n\n}\n\nconst MathUtils = {\n\tDEG2RAD: DEG2RAD,\n\tRAD2DEG: RAD2DEG,\n\tgenerateUUID: generateUUID,\n\tclamp: clamp,\n\teuclideanModulo: euclideanModulo,\n\tmapLinear: mapLinear,\n\tinverseLerp: inverseLerp,\n\tlerp: lerp,\n\tdamp: damp,\n\tpingpong: pingpong,\n\tsmoothstep: smoothstep,\n\tsmootherstep: smootherstep,\n\trandInt: randInt,\n\trandFloat: randFloat,\n\trandFloatSpread: randFloatSpread,\n\tseededRandom: seededRandom,\n\tdegToRad: degToRad,\n\tradToDeg: radToDeg,\n\tisPowerOfTwo: isPowerOfTwo,\n\tceilPowerOfTwo: ceilPowerOfTwo,\n\tfloorPowerOfTwo: floorPowerOfTwo,\n\tsetQuaternionFromProperEuler: setQuaternionFromProperEuler,\n\tnormalize: normalize,\n\tdenormalize: denormalize\n};\n\nclass Vector2 {\n\n\tconstructor( x = 0, y = 0 ) {\n\n\t\tVector2.prototype.isVector2 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t}\n\n\tget width() {\n\n\t\treturn this.x;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.x = value;\n\n\t}\n\n\tget height() {\n\n\t\treturn this.y;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.y = value;\n\n\t}\n\n\tset( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\n\n\t\treturn this;\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t}\n\n\tcross( v ) {\n\n\t\treturn this.x * v.y - this.y * v.x;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tangle() {\n\n\t\t// computes the angle in radians with respect to the positive x-axis\n\n\t\tconst angle = Math.atan2( - this.y, - this.x ) + Math.PI;\n\n\t\treturn angle;\n\n\t}\n\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( clamp( theta, - 1, 1 ) );\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\n\t\treturn this;\n\n\t}\n\n\trotateAround( center, angle ) {\n\n\t\tconst c = Math.cos( angle ), s = Math.sin( angle );\n\n\t\tconst x = this.x - center.x;\n\t\tconst y = this.y - center.y;\n\n\t\tthis.x = x * c - y * s + center.x;\n\t\tthis.y = x * s + y * c + center.y;\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\n\t}\n\n}\n\nclass Matrix3 {\n\n\tconstructor( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tMatrix3.prototype.isMatrix3 = true;\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t];\n\n\t\tif ( n11 !== undefined ) {\n\n\t\t\tthis.set( n11, n12, n13, n21, n22, n23, n31, n32, n33 );\n\n\t\t}\n\n\t}\n\n\tset( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\n\t\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\n\t\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrix3Column( this, 0 );\n\t\tyAxis.setFromMatrix3Column( this, 1 );\n\t\tzAxis.setFromMatrix3Column( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrix4( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 4 ], me[ 8 ],\n\t\t\tme[ 1 ], me[ 5 ], me[ 9 ],\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\n\t\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\n\t\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\n\t\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\n\t\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\n\t\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\n\t\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\n\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n\n\t}\n\n\tinvert() {\n\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],\n\t\t\tn12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],\n\t\t\tn13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],\n\n\t\t\tt11 = n33 * n22 - n32 * n23,\n\t\t\tt12 = n32 * n13 - n33 * n12,\n\t\t\tt13 = n23 * n12 - n22 * n13,\n\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\n\n\t\tte[ 3 ] = t12 * detInv;\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\n\n\t\tte[ 6 ] = t13 * detInv;\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\ttranspose() {\n\n\t\tlet tmp;\n\t\tconst m = this.elements;\n\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\tgetNormalMatrix( matrix4 ) {\n\n\t\treturn this.setFromMatrix4( matrix4 ).invert().transpose();\n\n\t}\n\n\ttransposeIntoArray( r ) {\n\n\t\tconst m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {\n\n\t\tconst c = Math.cos( rotation );\n\t\tconst s = Math.sin( rotation );\n\n\t\tthis.set(\n\t\t\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\n\t\t\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\n\t\t\t0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t//\n\n\tscale( sx, sy ) {\n\n\t\tthis.premultiply( _m3.makeScale( sx, sy ) );\n\n\t\treturn this;\n\n\t}\n\n\trotate( theta ) {\n\n\t\tthis.premultiply( _m3.makeRotation( - theta ) );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( tx, ty ) {\n\n\t\tthis.premultiply( _m3.makeTranslation( tx, ty ) );\n\n\t\treturn this;\n\n\t}\n\n\t// for 2D Transforms\n\n\tmakeTranslation( x, y ) {\n\n\t\tif ( x.isVector2 ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, x.x,\n\t\t\t\t0, 1, x.y,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, x,\n\t\t\t\t0, 1, y,\n\t\t\t\t0, 0, 1\n\n\t\t\t);\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotation( theta ) {\n\n\t\t// counterclockwise\n\n\t\tconst c = Math.cos( theta );\n\t\tconst s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0,\n\t\t\ts, c, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeScale( x, y ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0,\n\t\t\t0, y, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\t//\n\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\n\t\treturn array;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().fromArray( this.elements );\n\n\t}\n\n}\n\nconst _m3 = /*@__PURE__*/ new Matrix3();\n\nfunction arrayNeedsUint32( array ) {\n\n\t// assumes larger values usually on last\n\n\tfor ( let i = array.length - 1; i >= 0; -- i ) {\n\n\t\tif ( array[ i ] >= 65535 ) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565\n\n\t}\n\n\treturn false;\n\n}\n\nconst TYPED_ARRAYS = {\n\tInt8Array: Int8Array,\n\tUint8Array: Uint8Array,\n\tUint8ClampedArray: Uint8ClampedArray,\n\tInt16Array: Int16Array,\n\tUint16Array: Uint16Array,\n\tInt32Array: Int32Array,\n\tUint32Array: Uint32Array,\n\tFloat32Array: Float32Array,\n\tFloat64Array: Float64Array\n};\n\nfunction getTypedArray( type, buffer ) {\n\n\treturn new TYPED_ARRAYS[ type ]( buffer );\n\n}\n\nfunction createElementNS( name ) {\n\n\treturn document.createElementNS( 'http://www.w3.org/1999/xhtml', name );\n\n}\n\nconst _cache = {};\n\nfunction warnOnce( message ) {\n\n\tif ( message in _cache ) return;\n\n\t_cache[ message ] = true;\n\n\tconsole.warn( message );\n\n}\n\nfunction SRGBToLinear( c ) {\n\n\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n}\n\nfunction LinearToSRGB( c ) {\n\n\treturn ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;\n\n}\n\n/**\n * Matrices converting P3 <-> Rec. 709 primaries, without gamut mapping\n * or clipping. Based on W3C specifications for sRGB and Display P3,\n * and ICC specifications for the D50 connection space. Values in/out\n * are _linear_ sRGB and _linear_ Display P3.\n *\n * Note that both sRGB and Display P3 use the sRGB transfer functions.\n *\n * Reference:\n * - http://www.russellcottrell.com/photo/matrixCalculator.htm\n */\n\nconst LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /*@__PURE__*/ new Matrix3().fromArray( [\n\t0.8224621, 0.0331941, 0.0170827,\n\t0.1775380, 0.9668058, 0.0723974,\n\t- 0.0000001, 0.0000001, 0.9105199\n] );\n\nconst LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /*@__PURE__*/ new Matrix3().fromArray( [\n\t1.2249401, - 0.0420569, - 0.0196376,\n\t- 0.2249404, 1.0420571, - 0.0786361,\n\t0.0000001, 0.0000000, 1.0982735\n] );\n\nfunction DisplayP3ToLinearSRGB( color ) {\n\n\t// Display P3 uses the sRGB transfer functions\n\treturn color.convertSRGBToLinear().applyMatrix3( LINEAR_DISPLAY_P3_TO_LINEAR_SRGB );\n\n}\n\nfunction LinearSRGBToDisplayP3( color ) {\n\n\t// Display P3 uses the sRGB transfer functions\n\treturn color.applyMatrix3( LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 ).convertLinearToSRGB();\n\n}\n\n// Conversions from <source> to Linear-sRGB reference space.\nconst TO_LINEAR = {\n\t[ LinearSRGBColorSpace ]: ( color ) => color,\n\t[ SRGBColorSpace ]: ( color ) => color.convertSRGBToLinear(),\n\t[ DisplayP3ColorSpace ]: DisplayP3ToLinearSRGB,\n};\n\n// Conversions to <target> from Linear-sRGB reference space.\nconst FROM_LINEAR = {\n\t[ LinearSRGBColorSpace ]: ( color ) => color,\n\t[ SRGBColorSpace ]: ( color ) => color.convertLinearToSRGB(),\n\t[ DisplayP3ColorSpace ]: LinearSRGBToDisplayP3,\n};\n\nconst ColorManagement = {\n\n\tenabled: true,\n\n\tget legacyMode() {\n\n\t\tconsole.warn( 'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.' );\n\n\t\treturn ! this.enabled;\n\n\t},\n\n\tset legacyMode( legacyMode ) {\n\n\t\tconsole.warn( 'THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.' );\n\n\t\tthis.enabled = ! legacyMode;\n\n\t},\n\n\tget workingColorSpace() {\n\n\t\treturn LinearSRGBColorSpace;\n\n\t},\n\n\tset workingColorSpace( colorSpace ) {\n\n\t\tconsole.warn( 'THREE.ColorManagement: .workingColorSpace is readonly.' );\n\n\t},\n\n\tconvert: function ( color, sourceColorSpace, targetColorSpace ) {\n\n\t\tif ( this.enabled === false || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {\n\n\t\t\treturn color;\n\n\t\t}\n\n\t\tconst sourceToLinear = TO_LINEAR[ sourceColorSpace ];\n\t\tconst targetFromLinear = FROM_LINEAR[ targetColorSpace ];\n\n\t\tif ( sourceToLinear === undefined || targetFromLinear === undefined ) {\n\n\t\t\tthrow new Error( `Unsupported color space conversion, \"${ sourceColorSpace }\" to \"${ targetColorSpace }\".` );\n\n\t\t}\n\n\t\treturn targetFromLinear( sourceToLinear( color ) );\n\n\t},\n\n\tfromWorkingColorSpace: function ( color, targetColorSpace ) {\n\n\t\treturn this.convert( color, this.workingColorSpace, targetColorSpace );\n\n\t},\n\n\ttoWorkingColorSpace: function ( color, sourceColorSpace ) {\n\n\t\treturn this.convert( color, sourceColorSpace, this.workingColorSpace );\n\n\t},\n\n};\n\nlet _canvas;\n\nclass ImageUtils {\n\n\tstatic getDataURL( image ) {\n\n\t\tif ( /^data:/i.test( image.src ) ) {\n\n\t\t\treturn image.src;\n\n\t\t}\n\n\t\tif ( typeof HTMLCanvasElement === 'undefined' ) {\n\n\t\t\treturn image.src;\n\n\t\t}\n\n\t\tlet canvas;\n\n\t\tif ( image instanceof HTMLCanvasElement ) {\n\n\t\t\tcanvas = image;\n\n\t\t} else {\n\n\t\t\tif ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );\n\n\t\t\t_canvas.width = image.width;\n\t\t\t_canvas.height = image.height;\n\n\t\t\tconst context = _canvas.getContext( '2d' );\n\n\t\t\tif ( image instanceof ImageData ) {\n\n\t\t\t\tcontext.putImageData( image, 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\t}\n\n\t\t\tcanvas = _canvas;\n\n\t\t}\n\n\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );\n\n\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\n\n\t\t} else {\n\n\t\t\treturn canvas.toDataURL( 'image/png' );\n\n\t\t}\n\n\t}\n\n\tstatic sRGBToLinear( image ) {\n\n\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t\tconst canvas = createElementNS( 'canvas' );\n\n\t\t\tcanvas.width = image.width;\n\t\t\tcanvas.height = image.height;\n\n\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height );\n\n\t\t\tconst imageData = context.getImageData( 0, 0, image.width, image.height );\n\t\t\tconst data = imageData.data;\n\n\t\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tdata[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;\n\n\t\t\t}\n\n\t\t\tcontext.putImageData( imageData, 0, 0 );\n\n\t\t\treturn canvas;\n\n\t\t} else if ( image.data ) {\n\n\t\t\tconst data = image.data.slice( 0 );\n\n\t\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\t\tif ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {\n\n\t\t\t\t\tdata[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// assuming float\n\n\t\t\t\t\tdata[ i ] = SRGBToLinear( data[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tdata: data,\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );\n\t\t\treturn image;\n\n\t\t}\n\n\t}\n\n}\n\nlet sourceId = 0;\n\nclass Source {\n\n\tconstructor( data = null ) {\n\n\t\tthis.isSource = true;\n\n\t\tObject.defineProperty( this, 'id', { value: sourceId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.data = data;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.images[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\t\t\tuuid: this.uuid,\n\t\t\turl: ''\n\t\t};\n\n\t\tconst data = this.data;\n\n\t\tif ( data !== null ) {\n\n\t\t\tlet url;\n\n\t\t\tif ( Array.isArray( data ) ) {\n\n\t\t\t\t// cube texture\n\n\t\t\t\turl = [];\n\n\t\t\t\tfor ( let i = 0, l = data.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( data[ i ].isDataTexture ) {\n\n\t\t\t\t\t\turl.push( serializeImage( data[ i ].image ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\turl.push( serializeImage( data[ i ] ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// texture\n\n\t\t\t\turl = serializeImage( data );\n\n\t\t\t}\n\n\t\t\toutput.url = url;\n\n\t\t}\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.images[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n}\n\nfunction serializeImage( image ) {\n\n\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t// default images\n\n\t\treturn ImageUtils.getDataURL( image );\n\n\t} else {\n\n\t\tif ( image.data ) {\n\n\t\t\t// images of DataTexture\n\n\t\t\treturn {\n\t\t\t\tdata: Array.from( image.data ),\n\t\t\t\twidth: image.width,\n\t\t\t\theight: image.height,\n\t\t\t\ttype: image.data.constructor.name\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Texture: Unable to serialize Texture.' );\n\t\t\treturn {};\n\n\t\t}\n\n\t}\n\n}\n\nlet textureId = 0;\n\nclass Texture extends EventDispatcher {\n\n\tconstructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace ) {\n\n\t\tsuper();\n\n\t\tthis.isTexture = true;\n\n\t\tObject.defineProperty( this, 'id', { value: textureId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\n\t\tthis.source = new Source( image );\n\t\tthis.mipmaps = [];\n\n\t\tthis.mapping = mapping;\n\t\tthis.channel = 0;\n\n\t\tthis.wrapS = wrapS;\n\t\tthis.wrapT = wrapT;\n\n\t\tthis.magFilter = magFilter;\n\t\tthis.minFilter = minFilter;\n\n\t\tthis.anisotropy = anisotropy;\n\n\t\tthis.format = format;\n\t\tthis.internalFormat = null;\n\t\tthis.type = type;\n\n\t\tthis.offset = new Vector2( 0, 0 );\n\t\tthis.repeat = new Vector2( 1, 1 );\n\t\tthis.center = new Vector2( 0, 0 );\n\t\tthis.rotation = 0;\n\n\t\tthis.matrixAutoUpdate = true;\n\t\tthis.matrix = new Matrix3();\n\n\t\tthis.generateMipmaps = true;\n\t\tthis.premultiplyAlpha = false;\n\t\tthis.flipY = true;\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\t\tif ( typeof colorSpace === 'string' ) {\n\n\t\t\tthis.colorSpace = colorSpace;\n\n\t\t} else { // @deprecated, r152\n\n\t\t\twarnOnce( 'THREE.Texture: Property .encoding has been replaced by .colorSpace.' );\n\t\t\tthis.colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : NoColorSpace;\n\n\t\t}\n\n\n\t\tthis.userData = {};\n\n\t\tthis.version = 0;\n\t\tthis.onUpdate = null;\n\n\t\tthis.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not\n\t\tthis.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)\n\n\t}\n\n\tget image() {\n\n\t\treturn this.source.data;\n\n\t}\n\n\tset image( value = null ) {\n\n\t\tthis.source.data = value;\n\n\t}\n\n\tupdateMatrix() {\n\n\t\tthis.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.source = source.source;\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\n\n\t\tthis.mapping = source.mapping;\n\t\tthis.channel = source.channel;\n\n\t\tthis.wrapS = source.wrapS;\n\t\tthis.wrapT = source.wrapT;\n\n\t\tthis.magFilter = source.magFilter;\n\t\tthis.minFilter = source.minFilter;\n\n\t\tthis.anisotropy = source.anisotropy;\n\n\t\tthis.format = source.format;\n\t\tthis.internalFormat = source.internalFormat;\n\t\tthis.type = source.type;\n\n\t\tthis.offset.copy( source.offset );\n\t\tthis.repeat.copy( source.repeat );\n\t\tthis.center.copy( source.center );\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrix.copy( source.matrix );\n\n\t\tthis.generateMipmaps = source.generateMipmaps;\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\n\t\tthis.flipY = source.flipY;\n\t\tthis.unpackAlignment = source.unpackAlignment;\n\t\tthis.colorSpace = source.colorSpace;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tthis.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\n\n\t\t\treturn meta.textures[ this.uuid ];\n\n\t\t}\n\n\t\tconst output = {\n\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Texture',\n\t\t\t\tgenerator: 'Texture.toJSON'\n\t\t\t},\n\n\t\t\tuuid: this.uuid,\n\t\t\tname: this.name,\n\n\t\t\timage: this.source.toJSON( meta ).uuid,\n\n\t\t\tmapping: this.mapping,\n\t\t\tchannel: this.channel,\n\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\n\t\t\toffset: [ this.offset.x, this.offset.y ],\n\t\t\tcenter: [ this.center.x, this.center.y ],\n\t\t\trotation: this.rotation,\n\n\t\t\twrap: [ this.wrapS, this.wrapT ],\n\n\t\t\tformat: this.format,\n\t\t\tinternalFormat: this.internalFormat,\n\t\t\ttype: this.type,\n\t\t\tcolorSpace: this.colorSpace,\n\n\t\t\tminFilter: this.minFilter,\n\t\t\tmagFilter: this.magFilter,\n\t\t\tanisotropy: this.anisotropy,\n\n\t\t\tflipY: this.flipY,\n\n\t\t\tgenerateMipmaps: this.generateMipmaps,\n\t\t\tpremultiplyAlpha: this.premultiplyAlpha,\n\t\t\tunpackAlignment: this.unpackAlignment\n\n\t\t};\n\n\t\tif ( Object.keys( this.userData ).length > 0 ) output.userData = this.userData;\n\n\t\tif ( ! isRootObject ) {\n\n\t\t\tmeta.textures[ this.uuid ] = output;\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\ttransformUv( uv ) {\n\n\t\tif ( this.mapping !== UVMapping ) return uv;\n\n\t\tuv.applyMatrix3( this.matrix );\n\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\n\n\t\t\tswitch ( this.wrapS ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\n\n\t\t\tswitch ( this.wrapT ) {\n\n\t\t\t\tcase RepeatWrapping:\n\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ClampToEdgeWrapping:\n\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase MirroredRepeatWrapping:\n\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\n\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.flipY ) {\n\n\t\t\tuv.y = 1 - uv.y;\n\n\t\t}\n\n\t\treturn uv;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) {\n\n\t\t\tthis.version ++;\n\t\t\tthis.source.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tget encoding() { // @deprecated, r152\n\n\t\twarnOnce( 'THREE.Texture: Property .encoding has been replaced by .colorSpace.' );\n\t\treturn this.colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n\n\t}\n\n\tset encoding( encoding ) { // @deprecated, r152\n\n\t\twarnOnce( 'THREE.Texture: Property .encoding has been replaced by .colorSpace.' );\n\t\tthis.colorSpace = encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;\n\n\t}\n\n}\n\nTexture.DEFAULT_IMAGE = null;\nTexture.DEFAULT_MAPPING = UVMapping;\nTexture.DEFAULT_ANISOTROPY = 1;\n\nclass Vector4 {\n\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\tVector4.prototype.isVector4 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t}\n\n\tget width() {\n\n\t\treturn this.z;\n\n\t}\n\n\tset width( value ) {\n\n\t\tthis.z = value;\n\n\t}\n\n\tget height() {\n\n\t\treturn this.w;\n\n\t}\n\n\tset height( value ) {\n\n\t\tthis.w = value;\n\n\t}\n\n\tset( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\t\tthis.w = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetW( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\t\tthis.w += v.w * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\t\tthis.w -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\t\tthis.w *= v.w;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\tthis.w *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z, w = this.w;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tsetAxisAngleFromQuaternion( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tconst s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\tthis.x = 1;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t} else {\n\n\t\t\tthis.x = q.x / s;\n\t\t\tthis.y = q.y / s;\n\t\t\tthis.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetAxisAngleFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tlet angle, x, y, z; // variables for result\n\t\tconst epsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tconst xx = ( m11 + 1 ) / 2;\n\t\t\tconst yy = ( m22 + 1 ) / 2;\n\t\t\tconst zz = ( m33 + 1 ) / 2;\n\t\t\tconst xy = ( m12 + m21 ) / 4;\n\t\t\tconst xz = ( m13 + m31 ) / 4;\n\t\t\tconst yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\n\n\t\t\t\t// m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) {\n\n\t\t\t\t// m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tlet s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\n\t\t\t( m13 - m31 ) * ( m13 - m31 ) +\n\t\t\t( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\t\tthis.w = Math.min( this.w, v.w );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\t\tthis.w = Math.max( this.w, v.w );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\t\tthis.z = Math.max( minVal, Math.min( maxVal, this.z ) );\n\t\tthis.w = Math.max( minVal, Math.min( maxVal, this.w ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\t\tthis.w = Math.floor( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\t\tthis.w = Math.ceil( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\t\tthis.w = Math.round( this.w );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\t\tthis.w = - this.w;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\t\tthis.w = v1.w + ( v2.w - v1.w ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\t\tthis.w = array[ offset + 3 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\t\tarray[ offset + 3 ] = this.w;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\t\tthis.w = attribute.getW( index );\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\t\tthis.w = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\t\tyield this.z;\n\t\tyield this.w;\n\n\t}\n\n}\n\n/*\n In options, we can specify:\n * Texture parameters for an auto-generated target texture\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\n*/\nclass WebGLRenderTarget extends EventDispatcher {\n\n\tconstructor( width = 1, height = 1, options = {} ) {\n\n\t\tsuper();\n\n\t\tthis.isWebGLRenderTarget = true;\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.depth = 1;\n\n\t\tthis.scissor = new Vector4( 0, 0, width, height );\n\t\tthis.scissorTest = false;\n\n\t\tthis.viewport = new Vector4( 0, 0, width, height );\n\n\t\tconst image = { width: width, height: height, depth: 1 };\n\n\t\tif ( options.encoding !== undefined ) {\n\n\t\t\t// @deprecated, r152\n\t\t\twarnOnce( 'THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace.' );\n\t\t\toptions.colorSpace = options.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;\n\n\t\t}\n\n\t\tthis.texture = new Texture( image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t\tthis.texture.flipY = false;\n\t\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\t\tthis.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;\n\t\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\n\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;\n\n\t\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\n\n\t\tthis.samples = options.samples !== undefined ? options.samples : 0;\n\n\t}\n\n\tsetSize( width, height, depth = 1 ) {\n\n\t\tif ( this.width !== width || this.height !== height || this.depth !== depth ) {\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.depth = depth;\n\n\t\t\tthis.texture.image.width = width;\n\t\t\tthis.texture.image.height = height;\n\t\t\tthis.texture.image.depth = depth;\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tthis.viewport.set( 0, 0, width, height );\n\t\tthis.scissor.set( 0, 0, width, height );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\t\tthis.depth = source.depth;\n\n\t\tthis.scissor.copy( source.scissor );\n\t\tthis.scissorTest = source.scissorTest;\n\n\t\tthis.viewport.copy( source.viewport );\n\n\t\tthis.texture = source.texture.clone();\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t\t// ensure image object is not shared, see #20328\n\n\t\tconst image = Object.assign( {}, source.texture.image );\n\t\tthis.texture.source = new Source( image );\n\n\t\tthis.depthBuffer = source.depthBuffer;\n\t\tthis.stencilBuffer = source.stencilBuffer;\n\n\t\tif ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();\n\n\t\tthis.samples = source.samples;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nclass DataArrayTexture extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, depth = 1 ) {\n\n\t\tsuper( null );\n\n\t\tthis.isDataArrayTexture = true;\n\n\t\tthis.image = { data, width, height, depth };\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n}\n\nclass WebGLArrayRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( width = 1, height = 1, depth = 1 ) {\n\n\t\tsuper( width, height );\n\n\t\tthis.isWebGLArrayRenderTarget = true;\n\n\t\tthis.depth = depth;\n\n\t\tthis.texture = new DataArrayTexture( null, width, height, depth );\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t}\n\n}\n\nclass Data3DTexture extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, depth = 1 ) {\n\n\t\t// We're going to add .setXXX() methods for setting properties later.\n\t\t// Users can still set in DataTexture3D directly.\n\t\t//\n\t\t//\tconst texture = new THREE.DataTexture3D( data, width, height, depth );\n\t\t// \ttexture.anisotropy = 16;\n\t\t//\n\t\t// See #14839\n\n\t\tsuper( null );\n\n\t\tthis.isData3DTexture = true;\n\n\t\tthis.image = { data, width, height, depth };\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n}\n\nclass WebGL3DRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( width = 1, height = 1, depth = 1 ) {\n\n\t\tsuper( width, height );\n\n\t\tthis.isWebGL3DRenderTarget = true;\n\n\t\tthis.depth = depth;\n\n\t\tthis.texture = new Data3DTexture( null, width, height, depth );\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t}\n\n}\n\nclass WebGLMultipleRenderTargets extends WebGLRenderTarget {\n\n\tconstructor( width = 1, height = 1, count = 1, options = {} ) {\n\n\t\tsuper( width, height, options );\n\n\t\tthis.isWebGLMultipleRenderTargets = true;\n\n\t\tconst texture = this.texture;\n\n\t\tthis.texture = [];\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.texture[ i ] = texture.clone();\n\t\t\tthis.texture[ i ].isRenderTargetTexture = true;\n\n\t\t}\n\n\t}\n\n\tsetSize( width, height, depth = 1 ) {\n\n\t\tif ( this.width !== width || this.height !== height || this.depth !== depth ) {\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t\tthis.depth = depth;\n\n\t\t\tfor ( let i = 0, il = this.texture.length; i < il; i ++ ) {\n\n\t\t\t\tthis.texture[ i ].image.width = width;\n\t\t\t\tthis.texture[ i ].image.height = height;\n\t\t\t\tthis.texture[ i ].image.depth = depth;\n\n\t\t\t}\n\n\t\t\tthis.dispose();\n\n\t\t}\n\n\t\tthis.viewport.set( 0, 0, width, height );\n\t\tthis.scissor.set( 0, 0, width, height );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.dispose();\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\t\tthis.depth = source.depth;\n\n\t\tthis.scissor.copy( source.scissor );\n\t\tthis.scissorTest = source.scissorTest;\n\n\t\tthis.viewport.copy( source.viewport );\n\n\t\tthis.depthBuffer = source.depthBuffer;\n\t\tthis.stencilBuffer = source.stencilBuffer;\n\n\t\tif ( source.depthTexture !== null ) this.depthTexture = source.depthTexture.clone();\n\n\t\tthis.texture.length = 0;\n\n\t\tfor ( let i = 0, il = source.texture.length; i < il; i ++ ) {\n\n\t\t\tthis.texture[ i ] = source.texture[ i ].clone();\n\t\t\tthis.texture[ i ].isRenderTargetTexture = true;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Quaternion {\n\n\tconstructor( x = 0, y = 0, z = 0, w = 1 ) {\n\n\t\tthis.isQuaternion = true;\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t}\n\n\tstatic slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\n\n\t\t// fuzz-free, array-based Quaternion SLERP operation\n\n\t\tlet x0 = src0[ srcOffset0 + 0 ],\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\n\t\t\tw0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 + 0 ],\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\n\n\t\tif ( t === 0 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x0;\n\t\t\tdst[ dstOffset + 1 ] = y0;\n\t\t\tdst[ dstOffset + 2 ] = z0;\n\t\t\tdst[ dstOffset + 3 ] = w0;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( t === 1 ) {\n\n\t\t\tdst[ dstOffset + 0 ] = x1;\n\t\t\tdst[ dstOffset + 1 ] = y1;\n\t\t\tdst[ dstOffset + 2 ] = z1;\n\t\t\tdst[ dstOffset + 3 ] = w1;\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\n\n\t\t\tlet s = 1 - t;\n\t\t\tconst cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\n\t\t\t\tsqrSin = 1 - cos * cos;\n\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t\t\tif ( sqrSin > Number.EPSILON ) {\n\n\t\t\t\tconst sin = Math.sqrt( sqrSin ),\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\n\n\t\t\t\ts = Math.sin( s * len ) / sin;\n\t\t\t\tt = Math.sin( t * len ) / sin;\n\n\t\t\t}\n\n\t\t\tconst tDir = t * dir;\n\n\t\t\tx0 = x0 * s + x1 * tDir;\n\t\t\ty0 = y0 * s + y1 * tDir;\n\t\t\tz0 = z0 * s + z1 * tDir;\n\t\t\tw0 = w0 * s + w1 * tDir;\n\n\t\t\t// Normalize in case we just did a lerp:\n\t\t\tif ( s === 1 - t ) {\n\n\t\t\t\tconst f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\n\n\t\t\t\tx0 *= f;\n\t\t\t\ty0 *= f;\n\t\t\t\tz0 *= f;\n\t\t\t\tw0 *= f;\n\n\t\t\t}\n\n\t\t}\n\n\t\tdst[ dstOffset ] = x0;\n\t\tdst[ dstOffset + 1 ] = y0;\n\t\tdst[ dstOffset + 2 ] = z0;\n\t\tdst[ dstOffset + 3 ] = w0;\n\n\t}\n\n\tstatic multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {\n\n\t\tconst x0 = src0[ srcOffset0 ];\n\t\tconst y0 = src0[ srcOffset0 + 1 ];\n\t\tconst z0 = src0[ srcOffset0 + 2 ];\n\t\tconst w0 = src0[ srcOffset0 + 3 ];\n\n\t\tconst x1 = src1[ srcOffset1 ];\n\t\tconst y1 = src1[ srcOffset1 + 1 ];\n\t\tconst z1 = src1[ srcOffset1 + 2 ];\n\t\tconst w1 = src1[ srcOffset1 + 3 ];\n\n\t\tdst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n\t\tdst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n\t\tdst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n\t\tdst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n\n\t\treturn dst;\n\n\t}\n\n\tget x() {\n\n\t\treturn this._x;\n\n\t}\n\n\tset x( value ) {\n\n\t\tthis._x = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget y() {\n\n\t\treturn this._y;\n\n\t}\n\n\tset y( value ) {\n\n\t\tthis._y = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget z() {\n\n\t\treturn this._z;\n\n\t}\n\n\tset z( value ) {\n\n\t\tthis._z = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget w() {\n\n\t\treturn this._w;\n\n\t}\n\n\tset w( value ) {\n\n\t\tthis._w = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tset( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\n\n\t}\n\n\tcopy( quaternion ) {\n\n\t\tthis._x = quaternion.x;\n\t\tthis._y = quaternion.y;\n\t\tthis._z = quaternion.z;\n\t\tthis._w = quaternion.w;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromEuler( euler, update ) {\n\n\t\tconst x = euler._x, y = euler._y, z = euler._z, order = euler._order;\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tconst cos = Math.cos;\n\t\tconst sin = Math.sin;\n\n\t\tconst c1 = cos( x / 2 );\n\t\tconst c2 = cos( y / 2 );\n\t\tconst c3 = cos( z / 2 );\n\n\t\tconst s1 = sin( x / 2 );\n\t\tconst s2 = sin( y / 2 );\n\t\tconst s3 = sin( z / 2 );\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t\tif ( update !== false ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromAxisAngle( axis, angle ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\n\t\t// assumes axis is normalized\n\n\t\tconst halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromRotationMatrix( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements,\n\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\n\n\t\t\ttrace = m11 + m22 + m33;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\tconst s = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = ( m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = ( m12 + m21 ) / s;\n\t\t\tthis._z = ( m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = ( m13 - m31 ) / s;\n\t\t\tthis._x = ( m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = ( m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\tconst s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromUnitVectors( vFrom, vTo ) {\n\n\t\t// assumes direction vectors vFrom and vTo are normalized\n\n\t\tlet r = vFrom.dot( vTo ) + 1;\n\n\t\tif ( r < Number.EPSILON ) {\n\n\t\t\t// vFrom and vTo point in opposite directions\n\n\t\t\tr = 0;\n\n\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\n\n\t\t\t\tthis._x = - vFrom.y;\n\t\t\t\tthis._y = vFrom.x;\n\t\t\t\tthis._z = 0;\n\t\t\t\tthis._w = r;\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = - vFrom.z;\n\t\t\t\tthis._z = vFrom.y;\n\t\t\t\tthis._w = r;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\n\t\t\tthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n\t\t\tthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n\t\t\tthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n\t\t\tthis._w = r;\n\n\t\t}\n\n\t\treturn this.normalize();\n\n\t}\n\n\tangleTo( q ) {\n\n\t\treturn 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );\n\n\t}\n\n\trotateTowards( q, step ) {\n\n\t\tconst angle = this.angleTo( q );\n\n\t\tif ( angle === 0 ) return this;\n\n\t\tconst t = Math.min( 1, step / angle );\n\n\t\tthis.slerp( q, t );\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\treturn this.set( 0, 0, 0, 1 );\n\n\t}\n\n\tinvert() {\n\n\t\t// quaternion is assumed to have unit length\n\n\t\treturn this.conjugate();\n\n\t}\n\n\tconjugate() {\n\n\t\tthis._x *= - 1;\n\t\tthis._y *= - 1;\n\t\tthis._z *= - 1;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n\n\t}\n\n\tlengthSq() {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t}\n\n\tnormalize() {\n\n\t\tlet l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( q ) {\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t}\n\n\tpremultiply( q ) {\n\n\t\treturn this.multiplyQuaternions( q, this );\n\n\t}\n\n\tmultiplyQuaternions( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tconst qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tconst qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerp( qb, t ) {\n\n\t\tif ( t === 0 ) return this;\n\t\tif ( t === 1 ) return this.copy( qb );\n\n\t\tconst x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tlet cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = - qb._w;\n\t\t\tthis._x = - qb._x;\n\t\t\tthis._y = - qb._y;\n\t\t\tthis._z = - qb._z;\n\n\t\t\tcosHalfTheta = - cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;\n\n\t\tif ( sqrSinHalfTheta <= Number.EPSILON ) {\n\n\t\t\tconst s = 1 - t;\n\t\t\tthis._w = s * w + t * this._w;\n\t\t\tthis._x = s * x + t * this._x;\n\t\t\tthis._y = s * y + t * this._y;\n\t\t\tthis._z = s * z + t * this._z;\n\n\t\t\tthis.normalize();\n\t\t\tthis._onChangeCallback();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst sinHalfTheta = Math.sqrt( sqrSinHalfTheta );\n\t\tconst halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\n\t\tconst ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tslerpQuaternions( qa, qb, t ) {\n\n\t\treturn this.copy( qa ).slerp( qb, t );\n\n\t}\n\n\trandom() {\n\n\t\t// Derived from http://planning.cs.uiuc.edu/node198.html\n\t\t// Note, this source uses w, x, y, z ordering,\n\t\t// so we swap the order below.\n\n\t\tconst u1 = Math.random();\n\t\tconst sqrt1u1 = Math.sqrt( 1 - u1 );\n\t\tconst sqrtu1 = Math.sqrt( u1 );\n\n\t\tconst u2 = 2 * Math.PI * Math.random();\n\n\t\tconst u3 = 2 * Math.PI * Math.random();\n\n\t\treturn this.set(\n\t\t\tsqrt1u1 * Math.cos( u2 ),\n\t\t\tsqrtu1 * Math.sin( u3 ),\n\t\t\tsqrtu1 * Math.cos( u3 ),\n\t\t\tsqrt1u1 * Math.sin( u2 ),\n\t\t);\n\n\t}\n\n\tequals( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis._x = array[ offset ];\n\t\tthis._y = array[ offset + 1 ];\n\t\tthis._z = array[ offset + 2 ];\n\t\tthis._w = array[ offset + 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._w;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis._x = attribute.getX( index );\n\t\tthis._y = attribute.getY( index );\n\t\tthis._z = attribute.getZ( index );\n\t\tthis._w = attribute.getW( index );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.toArray();\n\n\t}\n\n\t_onChange( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t_onChangeCallback() {}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this._x;\n\t\tyield this._y;\n\t\tyield this._z;\n\t\tyield this._w;\n\n\t}\n\n}\n\nclass Vector3 {\n\n\tconstructor( x = 0, y = 0, z = 0 ) {\n\n\t\tVector3.prototype.isVector3 = true;\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t}\n\n\tset( x, y, z ) {\n\n\t\tif ( z === undefined ) z = this.z; // sprite.scale.set(x,y)\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.x = scalar;\n\t\tthis.y = scalar;\n\t\tthis.z = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetX( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponent( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetComponent( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.x, this.y, this.z );\n\n\t}\n\n\tcopy( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t}\n\n\tadd( v ) {\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t}\n\n\taddVectors( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t}\n\n\taddScaledVector( v, s ) {\n\n\t\tthis.x += v.x * s;\n\t\tthis.y += v.y * s;\n\t\tthis.z += v.z * s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( v ) {\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tsubScalar( s ) {\n\n\t\tthis.x -= s;\n\t\tthis.y -= s;\n\t\tthis.z -= s;\n\n\t\treturn this;\n\n\t}\n\n\tsubVectors( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( v ) {\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyVectors( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyEuler( euler ) {\n\n\t\treturn this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );\n\n\t}\n\n\tapplyAxisAngle( axis, angle ) {\n\n\t\treturn this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\treturn this.applyMatrix3( m ).normalize();\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tconst w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\n\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// calculate quat * vector\n\n\t\tconst ix = qw * x + qy * z - qz * y;\n\t\tconst iy = qw * y + qz * x - qx * z;\n\t\tconst iz = qw * z + qx * y - qy * x;\n\t\tconst iw = - qx * x - qy * y - qz * z;\n\n\t\t// calculate result * inverse quat\n\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\treturn this;\n\n\t}\n\n\tproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );\n\n\t}\n\n\tunproject( camera ) {\n\n\t\treturn this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tconst x = this.x, y = this.y, z = this.z;\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn this.normalize();\n\n\t}\n\n\tdivide( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t}\n\n\tdivideScalar( scalar ) {\n\n\t\treturn this.multiplyScalar( 1 / scalar );\n\n\t}\n\n\tmin( v ) {\n\n\t\tthis.x = Math.min( this.x, v.x );\n\t\tthis.y = Math.min( this.y, v.y );\n\t\tthis.z = Math.min( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tmax( v ) {\n\n\t\tthis.x = Math.max( this.x, v.x );\n\t\tthis.y = Math.max( this.y, v.y );\n\t\tthis.z = Math.max( this.z, v.z );\n\n\t\treturn this;\n\n\t}\n\n\tclamp( min, max ) {\n\n\t\t// assumes min < max, componentwise\n\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampScalar( minVal, maxVal ) {\n\n\t\tthis.x = Math.max( minVal, Math.min( maxVal, this.x ) );\n\t\tthis.y = Math.max( minVal, Math.min( maxVal, this.y ) );\n\t\tthis.z = Math.max( minVal, Math.min( maxVal, this.z ) );\n\n\t\treturn this;\n\n\t}\n\n\tclampLength( min, max ) {\n\n\t\tconst length = this.length();\n\n\t\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\n\n\t}\n\n\tfloor() {\n\n\t\tthis.x = Math.floor( this.x );\n\t\tthis.y = Math.floor( this.y );\n\t\tthis.z = Math.floor( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tceil() {\n\n\t\tthis.x = Math.ceil( this.x );\n\t\tthis.y = Math.ceil( this.y );\n\t\tthis.z = Math.ceil( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tround() {\n\n\t\tthis.x = Math.round( this.x );\n\t\tthis.y = Math.round( this.y );\n\t\tthis.z = Math.round( this.z );\n\n\t\treturn this;\n\n\t}\n\n\troundToZero() {\n\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.x = - this.x;\n\t\tthis.y = - this.y;\n\t\tthis.z = - this.z;\n\n\t\treturn this;\n\n\t}\n\n\tdot( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t}\n\n\t// TODO lengthSquared?\n\n\tlengthSq() {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t}\n\n\tlength() {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t}\n\n\tmanhattanLength() {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t}\n\n\tnormalize() {\n\n\t\treturn this.divideScalar( this.length() || 1 );\n\n\t}\n\n\tsetLength( length ) {\n\n\t\treturn this.normalize().multiplyScalar( length );\n\n\t}\n\n\tlerp( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpVectors( v1, v2, alpha ) {\n\n\t\tthis.x = v1.x + ( v2.x - v1.x ) * alpha;\n\t\tthis.y = v1.y + ( v2.y - v1.y ) * alpha;\n\t\tthis.z = v1.z + ( v2.z - v1.z ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tcross( v ) {\n\n\t\treturn this.crossVectors( this, v );\n\n\t}\n\n\tcrossVectors( a, b ) {\n\n\t\tconst ax = a.x, ay = a.y, az = a.z;\n\t\tconst bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t}\n\n\tprojectOnVector( v ) {\n\n\t\tconst denominator = v.lengthSq();\n\n\t\tif ( denominator === 0 ) return this.set( 0, 0, 0 );\n\n\t\tconst scalar = v.dot( this ) / denominator;\n\n\t\treturn this.copy( v ).multiplyScalar( scalar );\n\n\t}\n\n\tprojectOnPlane( planeNormal ) {\n\n\t\t_vector$b.copy( this ).projectOnVector( planeNormal );\n\n\t\treturn this.sub( _vector$b );\n\n\t}\n\n\treflect( normal ) {\n\n\t\t// reflect incident vector off plane orthogonal to normal\n\t\t// normal is assumed to have unit length\n\n\t\treturn this.sub( _vector$b.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\n\n\t}\n\n\tangleTo( v ) {\n\n\t\tconst denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );\n\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = this.dot( v ) / denominator;\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( clamp( theta, - 1, 1 ) );\n\n\t}\n\n\tdistanceTo( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t}\n\n\tdistanceToSquared( v ) {\n\n\t\tconst dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t}\n\n\tmanhattanDistanceTo( v ) {\n\n\t\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\n\n\t}\n\n\tsetFromSpherical( s ) {\n\n\t\treturn this.setFromSphericalCoords( s.radius, s.phi, s.theta );\n\n\t}\n\n\tsetFromSphericalCoords( radius, phi, theta ) {\n\n\t\tconst sinPhiRadius = Math.sin( phi ) * radius;\n\n\t\tthis.x = sinPhiRadius * Math.sin( theta );\n\t\tthis.y = Math.cos( phi ) * radius;\n\t\tthis.z = sinPhiRadius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCylindrical( c ) {\n\n\t\treturn this.setFromCylindricalCoords( c.radius, c.theta, c.y );\n\n\t}\n\n\tsetFromCylindricalCoords( radius, theta, y ) {\n\n\t\tthis.x = radius * Math.sin( theta );\n\t\tthis.y = y;\n\t\tthis.z = radius * Math.cos( theta );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixPosition( m ) {\n\n\t\tconst e = m.elements;\n\n\t\tthis.x = e[ 12 ];\n\t\tthis.y = e[ 13 ];\n\t\tthis.z = e[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixScale( m ) {\n\n\t\tconst sx = this.setFromMatrixColumn( m, 0 ).length();\n\t\tconst sy = this.setFromMatrixColumn( m, 1 ).length();\n\t\tconst sz = this.setFromMatrixColumn( m, 2 ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrixColumn( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 4 );\n\n\t}\n\n\tsetFromMatrix3Column( m, index ) {\n\n\t\treturn this.fromArray( m.elements, index * 3 );\n\n\t}\n\n\tsetFromEuler( e ) {\n\n\t\tthis.x = e._x;\n\t\tthis.y = e._y;\n\t\tthis.z = e._z;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromColor( c ) {\n\n\t\tthis.x = c.r;\n\t\tthis.y = c.g;\n\t\tthis.z = c.b;\n\n\t\treturn this;\n\n\t}\n\n\tequals( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.x = array[ offset ];\n\t\tthis.y = array[ offset + 1 ];\n\t\tthis.z = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.x;\n\t\tarray[ offset + 1 ] = this.y;\n\t\tarray[ offset + 2 ] = this.z;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.x = attribute.getX( index );\n\t\tthis.y = attribute.getY( index );\n\t\tthis.z = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n\trandom() {\n\n\t\tthis.x = Math.random();\n\t\tthis.y = Math.random();\n\t\tthis.z = Math.random();\n\n\t\treturn this;\n\n\t}\n\n\trandomDirection() {\n\n\t\t// Derived from https://mathworld.wolfram.com/SpherePointPicking.html\n\n\t\tconst u = ( Math.random() - 0.5 ) * 2;\n\t\tconst t = Math.random() * Math.PI * 2;\n\t\tconst f = Math.sqrt( 1 - u ** 2 );\n\n\t\tthis.x = f * Math.cos( t );\n\t\tthis.y = f * Math.sin( t );\n\t\tthis.z = u;\n\n\t\treturn this;\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.x;\n\t\tyield this.y;\n\t\tyield this.z;\n\n\t}\n\n}\n\nconst _vector$b = /*@__PURE__*/ new Vector3();\nconst _quaternion$4 = /*@__PURE__*/ new Quaternion();\n\nclass Box3 {\n\n\tconstructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {\n\n\t\tthis.isBox3 = true;\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromArray( array ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = array.length; i < il; i += 3 ) {\n\n\t\t\tthis.expandByPoint( _vector$a.fromArray( array, i ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromBufferAttribute( attribute ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( _vector$a.fromBufferAttribute( attribute, i ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector$a.copy( size ).multiplyScalar( 0.5 );\n\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromObject( object, precise = false ) {\n\n\t\tthis.makeEmpty();\n\n\t\treturn this.expandByObject( object, precise );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\tgetSize( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\texpandByObject( object, precise = false ) {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tobject.updateWorldMatrix( false, false );\n\n\t\tif ( object.boundingBox !== undefined ) {\n\n\t\t\tif ( object.boundingBox === null ) {\n\n\t\t\t\tobject.computeBoundingBox();\n\n\t\t\t}\n\n\t\t\t_box$3.copy( object.boundingBox );\n\t\t\t_box$3.applyMatrix4( object.matrixWorld );\n\n\t\t\tthis.union( _box$3 );\n\n\t\t} else {\n\n\t\t\tconst geometry = object.geometry;\n\n\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\tif ( precise && geometry.attributes !== undefined && geometry.attributes.position !== undefined ) {\n\n\t\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\t\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t\t\t\t\t_vector$a.fromBufferAttribute( position, i ).applyMatrix4( object.matrixWorld );\n\t\t\t\t\t\tthis.expandByPoint( _vector$a );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\t\t\t\tgeometry.computeBoundingBox();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_box$3.copy( geometry.boundingBox );\n\t\t\t\t\t_box$3.applyMatrix4( object.matrixWorld );\n\n\t\t\t\t\tthis.union( _box$3 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tthis.expandByObject( children[ i ], precise );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ||\n\t\t\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\n\n\t}\n\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\n\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\n\n\t}\n\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\t// Find the point on the AABB closest to the sphere center.\n\t\tthis.clampPoint( sphere.center, _vector$a );\n\n\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\treturn _vector$a.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tlet min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= - plane.constant && max >= - plane.constant );\n\n\t}\n\n\tintersectsTriangle( triangle ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// compute box center and extents\n\t\tthis.getCenter( _center );\n\t\t_extents.subVectors( this.max, _center );\n\n\t\t// translate triangle to aabb origin\n\t\t_v0$2.subVectors( triangle.a, _center );\n\t\t_v1$7.subVectors( triangle.b, _center );\n\t\t_v2$4.subVectors( triangle.c, _center );\n\n\t\t// compute edge vectors for triangle\n\t\t_f0.subVectors( _v1$7, _v0$2 );\n\t\t_f1.subVectors( _v2$4, _v1$7 );\n\t\t_f2.subVectors( _v0$2, _v2$4 );\n\n\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\t\tlet axes = [\n\t\t\t0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,\n\t\t\t_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,\n\t\t\t- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0\n\t\t];\n\t\tif ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// test 3 face normals from the aabb\n\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\n\t\tif ( ! satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// finally testing the face normal of the triangle\n\t\t// use already existing triangle edge vectors here\n\t\t_triangleNormal.crossVectors( _f0, _f1 );\n\t\taxes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];\n\n\t\treturn satForAxes( axes, _v0$2, _v1$7, _v2$4, _extents );\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _vector$a ).distanceTo( point );\n\n\t}\n\n\tgetBoundingSphere( target ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\ttarget.makeEmpty();\n\n\t\t} else {\n\n\t\t\tthis.getCenter( target.center );\n\n\t\t\ttarget.radius = this.getSize( _vector$a ).length() * 0.5;\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t}\n\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\t// transform of empty box is an empty box.\n\t\tif ( this.isEmpty() ) return this;\n\n\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\n\n\t\tthis.setFromPoints( _points );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n}\n\nconst _points = [\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3()\n];\n\nconst _vector$a = /*@__PURE__*/ new Vector3();\n\nconst _box$3 = /*@__PURE__*/ new Box3();\n\n// triangle centered vertices\n\nconst _v0$2 = /*@__PURE__*/ new Vector3();\nconst _v1$7 = /*@__PURE__*/ new Vector3();\nconst _v2$4 = /*@__PURE__*/ new Vector3();\n\n// triangle edge vectors\n\nconst _f0 = /*@__PURE__*/ new Vector3();\nconst _f1 = /*@__PURE__*/ new Vector3();\nconst _f2 = /*@__PURE__*/ new Vector3();\n\nconst _center = /*@__PURE__*/ new Vector3();\nconst _extents = /*@__PURE__*/ new Vector3();\nconst _triangleNormal = /*@__PURE__*/ new Vector3();\nconst _testAxis = /*@__PURE__*/ new Vector3();\n\nfunction satForAxes( axes, v0, v1, v2, extents ) {\n\n\tfor ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {\n\n\t\t_testAxis.fromArray( axes, i );\n\t\t// project the aabb onto the separating axis\n\t\tconst r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );\n\t\t// project all 3 vertices of the triangle onto the separating axis\n\t\tconst p0 = v0.dot( _testAxis );\n\t\tconst p1 = v1.dot( _testAxis );\n\t\tconst p2 = v2.dot( _testAxis );\n\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\n\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t// the axis is separating and we can exit\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nconst _box$2 = /*@__PURE__*/ new Box3();\nconst _v1$6 = /*@__PURE__*/ new Vector3();\nconst _v2$3 = /*@__PURE__*/ new Vector3();\n\nclass Sphere {\n\n\tconstructor( center = new Vector3(), radius = - 1 ) {\n\n\t\tthis.center = center;\n\t\tthis.radius = radius;\n\n\t}\n\n\tset( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points, optionalCenter ) {\n\n\t\tconst center = this.center;\n\n\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\tcenter.copy( optionalCenter );\n\n\t\t} else {\n\n\t\t\t_box$2.setFromPoints( points ).getCenter( center );\n\n\t\t}\n\n\t\tlet maxRadiusSq = 0;\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t}\n\n\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\treturn ( this.radius < 0 );\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.center.set( 0, 0, 0 );\n\t\tthis.radius = - 1;\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tconst radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\tconst deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\ttarget.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\ttarget.sub( this.center ).normalize();\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\t// Empty sphere produces empty bounding box\n\t\t\ttarget.makeEmpty();\n\t\t\treturn target;\n\n\t\t}\n\n\t\ttarget.set( this.center, this.center );\n\t\ttarget.expandByScalar( this.radius );\n\n\t\treturn target;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\tthis.center.copy( point );\n\n\t\t\tthis.radius = 0;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t_v1$6.subVectors( point, this.center );\n\n\t\tconst lengthSq = _v1$6.lengthSq();\n\n\t\tif ( lengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\t// calculate the minimal sphere\n\n\t\t\tconst length = Math.sqrt( lengthSq );\n\n\t\t\tconst delta = ( length - this.radius ) * 0.5;\n\n\t\t\tthis.center.addScaledVector( _v1$6, delta / length );\n\n\t\t\tthis.radius += delta;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunion( sphere ) {\n\n\t\tif ( sphere.isEmpty() ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\tthis.copy( sphere );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( this.center.equals( sphere.center ) === true ) {\n\n\t\t\t this.radius = Math.max( this.radius, sphere.radius );\n\n\t\t} else {\n\n\t\t\t_v2$3.subVectors( sphere.center, this.center ).setLength( sphere.radius );\n\n\t\t\tthis.expandByPoint( _v1$6.copy( sphere.center ).add( _v2$3 ) );\n\n\t\t\tthis.expandByPoint( _v1$6.copy( sphere.center ).sub( _v2$3 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tequals( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _vector$9 = /*@__PURE__*/ new Vector3();\nconst _segCenter = /*@__PURE__*/ new Vector3();\nconst _segDir = /*@__PURE__*/ new Vector3();\nconst _diff = /*@__PURE__*/ new Vector3();\n\nconst _edge1 = /*@__PURE__*/ new Vector3();\nconst _edge2 = /*@__PURE__*/ new Vector3();\nconst _normal$1 = /*@__PURE__*/ new Vector3();\n\nclass Ray {\n\n\tconstructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {\n\n\t\tthis.origin = origin;\n\t\tthis.direction = direction;\n\n\t}\n\n\tset( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t}\n\n\tat( t, target ) {\n\n\t\treturn target.copy( this.origin ).addScaledVector( this.direction, t );\n\n\t}\n\n\tlookAt( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t}\n\n\trecast( t ) {\n\n\t\tthis.origin.copy( this.at( t, _vector$9 ) );\n\n\t\treturn this;\n\n\t}\n\n\tclosestPointToPoint( point, target ) {\n\n\t\ttarget.subVectors( point, this.origin );\n\n\t\tconst directionDistance = target.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn target.copy( this.origin );\n\n\t\t}\n\n\t\treturn target.copy( this.origin ).addScaledVector( this.direction, directionDistance );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t}\n\n\tdistanceSqToPoint( point ) {\n\n\t\tconst directionDistance = _vector$9.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t// point behind the ray\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t}\n\n\t\t_vector$9.copy( this.origin ).addScaledVector( this.direction, directionDistance );\n\n\t\treturn _vector$9.distanceToSquared( point );\n\n\t}\n\n\tdistanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t// It returns the min distance between the ray and the segment\n\t\t// defined by v0 and v1\n\t\t// It can also set two optional targets :\n\t\t// - The closest point on the ray\n\t\t// - The closest point on the segment\n\n\t\t_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t_segDir.copy( v1 ).sub( v0 ).normalize();\n\t\t_diff.copy( this.origin ).sub( _segCenter );\n\n\t\tconst segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\tconst a01 = - this.direction.dot( _segDir );\n\t\tconst b0 = _diff.dot( this.direction );\n\t\tconst b1 = - _diff.dot( _segDir );\n\t\tconst c = _diff.lengthSq();\n\t\tconst det = Math.abs( 1 - a01 * a01 );\n\t\tlet s0, s1, sqrDist, extDet;\n\n\t\tif ( det > 0 ) {\n\n\t\t\t// The ray and segment are not parallel.\n\n\t\t\ts0 = a01 * b1 - b0;\n\t\t\ts1 = a01 * b0 - b1;\n\t\t\textDet = segExtent * det;\n\n\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\tconst invDet = 1 / det;\n\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 5\n\n\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t// region 4\n\n\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t// region 3\n\n\t\t\t\t\ts0 = 0;\n\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 2\n\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Ray and segment are parallel.\n\n\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t}\n\n\t\tif ( optionalPointOnRay ) {\n\n\t\t\toptionalPointOnRay.copy( this.origin ).addScaledVector( this.direction, s0 );\n\n\t\t}\n\n\t\tif ( optionalPointOnSegment ) {\n\n\t\t\toptionalPointOnSegment.copy( _segCenter ).addScaledVector( _segDir, s1 );\n\n\t\t}\n\n\t\treturn sqrDist;\n\n\t}\n\n\tintersectSphere( sphere, target ) {\n\n\t\t_vector$9.subVectors( sphere.center, this.origin );\n\t\tconst tca = _vector$9.dot( this.direction );\n\t\tconst d2 = _vector$9.dot( _vector$9 ) - tca * tca;\n\t\tconst radius2 = sphere.radius * sphere.radius;\n\n\t\tif ( d2 > radius2 ) return null;\n\n\t\tconst thc = Math.sqrt( radius2 - d2 );\n\n\t\t// t0 = first intersect point - entrance on front of sphere\n\t\tconst t0 = tca - thc;\n\n\t\t// t1 = second intersect point - exit point on back of sphere\n\t\tconst t1 = tca + thc;\n\n\t\t// test to see if t1 is behind the ray - if so, return null\n\t\tif ( t1 < 0 ) return null;\n\n\t\t// test to see if t0 is behind the ray:\n\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t// in order to always return an intersect point that is in front of the ray.\n\t\tif ( t0 < 0 ) return this.at( t1, target );\n\n\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\treturn this.at( t0, target );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tdistanceToPlane( plane ) {\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t : null;\n\n\t}\n\n\tintersectPlane( plane, target ) {\n\n\t\tconst t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, target );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tconst distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t}\n\n\tintersectBox( box, target ) {\n\n\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tconst invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tconst origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\t\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn this.intersectBox( box, _vector$9 ) !== null;\n\n\t}\n\n\tintersectTriangle( a, b, c, backfaceCulling, target ) {\n\n\t\t// Compute the offset origin, edges, and normal.\n\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t_edge1.subVectors( b, a );\n\t\t_edge2.subVectors( c, a );\n\t\t_normal$1.crossVectors( _edge1, _edge2 );\n\n\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\tlet DdN = this.direction.dot( _normal$1 );\n\t\tlet sign;\n\n\t\tif ( DdN > 0 ) {\n\n\t\t\tif ( backfaceCulling ) return null;\n\t\t\tsign = 1;\n\n\t\t} else if ( DdN < 0 ) {\n\n\t\t\tsign = - 1;\n\t\t\tDdN = - DdN;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t_diff.subVectors( this.origin, a );\n\t\tconst DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );\n\n\t\t// b1 < 0, no intersection\n\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );\n\n\t\t// b2 < 0, no intersection\n\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// b1+b2 > 1, no intersection\n\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Line intersects triangle, check if ray does.\n\t\tconst QdN = - sign * _diff.dot( _normal$1 );\n\n\t\t// t < 0, no intersection\n\t\tif ( QdN < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Ray intersects triangle.\n\t\treturn this.at( QdN / DdN, target );\n\n\t}\n\n\tapplyMatrix4( matrix4 ) {\n\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.transformDirection( matrix4 );\n\n\t\treturn this;\n\n\t}\n\n\tequals( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nclass Matrix4 {\n\n\tconstructor( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tMatrix4.prototype.isMatrix4 = true;\n\n\t\tthis.elements = [\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t];\n\n\t\tif ( n11 !== undefined ) {\n\n\t\t\tthis.set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 );\n\n\t\t}\n\n\t}\n\n\tset( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\n\n\t\treturn this;\n\n\t}\n\n\tidentity() {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Matrix4().fromArray( this.elements );\n\n\t}\n\n\tcopy( m ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\n\t\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\n\t\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\n\t\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\n\n\t\treturn this;\n\n\t}\n\n\tcopyPosition( m ) {\n\n\t\tconst te = this.elements, me = m.elements;\n\n\t\tte[ 12 ] = me[ 12 ];\n\t\tte[ 13 ] = me[ 13 ];\n\t\tte[ 14 ] = me[ 14 ];\n\n\t\treturn this;\n\n\t}\n\n\tsetFromMatrix3( m ) {\n\n\t\tconst me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ], 0,\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ], 0,\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ], 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\textractBasis( xAxis, yAxis, zAxis ) {\n\n\t\txAxis.setFromMatrixColumn( this, 0 );\n\t\tyAxis.setFromMatrixColumn( this, 1 );\n\t\tzAxis.setFromMatrixColumn( this, 2 );\n\n\t\treturn this;\n\n\t}\n\n\tmakeBasis( xAxis, yAxis, zAxis ) {\n\n\t\tthis.set(\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\textractRotation( m ) {\n\n\t\t// this method does not support reflection matrices\n\n\t\tconst te = this.elements;\n\t\tconst me = m.elements;\n\n\t\tconst scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();\n\t\tconst scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();\n\t\tconst scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();\n\n\t\tte[ 0 ] = me[ 0 ] * scaleX;\n\t\tte[ 1 ] = me[ 1 ] * scaleX;\n\t\tte[ 2 ] = me[ 2 ] * scaleX;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = me[ 4 ] * scaleY;\n\t\tte[ 5 ] = me[ 5 ] * scaleY;\n\t\tte[ 6 ] = me[ 6 ] * scaleY;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = me[ 8 ] * scaleZ;\n\t\tte[ 9 ] = me[ 9 ] * scaleZ;\n\t\tte[ 10 ] = me[ 10 ] * scaleZ;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationFromEuler( euler ) {\n\n\t\tconst te = this.elements;\n\n\t\tconst x = euler.x, y = euler.y, z = euler.z;\n\t\tconst a = Math.cos( x ), b = Math.sin( x );\n\t\tconst c = Math.cos( y ), d = Math.sin( y );\n\t\tconst e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - c * f;\n\t\t\tte[ 8 ] = d;\n\n\t\t\tte[ 1 ] = af + be * d;\n\t\t\tte[ 5 ] = ae - bf * d;\n\t\t\tte[ 9 ] = - b * c;\n\n\t\t\tte[ 2 ] = bf - ae * d;\n\t\t\tte[ 6 ] = be + af * d;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce + df * b;\n\t\t\tte[ 4 ] = de * b - cf;\n\t\t\tte[ 8 ] = a * d;\n\n\t\t\tte[ 1 ] = a * f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b;\n\n\t\t\tte[ 2 ] = cf * b - de;\n\t\t\tte[ 6 ] = df + ce * b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tconst ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[ 0 ] = ce - df * b;\n\t\t\tte[ 4 ] = - a * f;\n\t\t\tte[ 8 ] = de + cf * b;\n\n\t\t\tte[ 1 ] = cf + de * b;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = df - ce * b;\n\n\t\t\tte[ 2 ] = - a * d;\n\t\t\tte[ 6 ] = b;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tconst ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = be * d - af;\n\t\t\tte[ 8 ] = ae * d + bf;\n\n\t\t\tte[ 1 ] = c * f;\n\t\t\tte[ 5 ] = bf * d + ae;\n\t\t\tte[ 9 ] = af * d - be;\n\n\t\t\tte[ 2 ] = - d;\n\t\t\tte[ 6 ] = b * c;\n\t\t\tte[ 10 ] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = bd - ac * f;\n\t\t\tte[ 8 ] = bc * f + ad;\n\n\t\t\tte[ 1 ] = f;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = - b * e;\n\n\t\t\tte[ 2 ] = - d * e;\n\t\t\tte[ 6 ] = ad * f + bc;\n\t\t\tte[ 10 ] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tconst ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[ 0 ] = c * e;\n\t\t\tte[ 4 ] = - f;\n\t\t\tte[ 8 ] = d * e;\n\n\t\t\tte[ 1 ] = ac * f + bd;\n\t\t\tte[ 5 ] = a * e;\n\t\t\tte[ 9 ] = ad * f - bc;\n\n\t\t\tte[ 2 ] = bc * f - ad;\n\t\t\tte[ 6 ] = b * e;\n\t\t\tte[ 10 ] = bd * f + ac;\n\n\t\t}\n\n\t\t// bottom row\n\t\tte[ 3 ] = 0;\n\t\tte[ 7 ] = 0;\n\t\tte[ 11 ] = 0;\n\n\t\t// last column\n\t\tte[ 12 ] = 0;\n\t\tte[ 13 ] = 0;\n\t\tte[ 14 ] = 0;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationFromQuaternion( q ) {\n\n\t\treturn this.compose( _zero, q, _one );\n\n\t}\n\n\tlookAt( eye, target, up ) {\n\n\t\tconst te = this.elements;\n\n\t\t_z.subVectors( eye, target );\n\n\t\tif ( _z.lengthSq() === 0 ) {\n\n\t\t\t// eye and target are in the same position\n\n\t\t\t_z.z = 1;\n\n\t\t}\n\n\t\t_z.normalize();\n\t\t_x.crossVectors( up, _z );\n\n\t\tif ( _x.lengthSq() === 0 ) {\n\n\t\t\t// up and z are parallel\n\n\t\t\tif ( Math.abs( up.z ) === 1 ) {\n\n\t\t\t\t_z.x += 0.0001;\n\n\t\t\t} else {\n\n\t\t\t\t_z.z += 0.0001;\n\n\t\t\t}\n\n\t\t\t_z.normalize();\n\t\t\t_x.crossVectors( up, _z );\n\n\t\t}\n\n\t\t_x.normalize();\n\t\t_y.crossVectors( _z, _x );\n\n\t\tte[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;\n\t\tte[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;\n\t\tte[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( m ) {\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t}\n\n\tpremultiply( m ) {\n\n\t\treturn this.multiplyMatrices( m, this );\n\n\t}\n\n\tmultiplyMatrices( a, b ) {\n\n\t\tconst ae = a.elements;\n\t\tconst be = b.elements;\n\t\tconst te = this.elements;\n\n\t\tconst a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\n\t\tconst a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\n\t\tconst a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\n\t\tconst a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\n\n\t\tconst b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\n\t\tconst b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\n\t\tconst b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\n\t\tconst b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\n\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tconst te = this.elements;\n\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\n\n\t\treturn this;\n\n\t}\n\n\tdeterminant() {\n\n\t\tconst te = this.elements;\n\n\t\tconst n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\n\t\tconst n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\n\t\tconst n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\n\t\tconst n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+ n14 * n23 * n32\n\t\t\t\t - n13 * n24 * n32\n\t\t\t\t - n14 * n22 * n33\n\t\t\t\t + n12 * n24 * n33\n\t\t\t\t + n13 * n22 * n34\n\t\t\t\t - n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+ n11 * n23 * n34\n\t\t\t\t - n11 * n24 * n33\n\t\t\t\t + n14 * n21 * n33\n\t\t\t\t - n13 * n21 * n34\n\t\t\t\t + n13 * n24 * n31\n\t\t\t\t - n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+ n11 * n24 * n32\n\t\t\t\t - n11 * n22 * n34\n\t\t\t\t - n14 * n21 * n32\n\t\t\t\t + n12 * n21 * n34\n\t\t\t\t + n14 * n22 * n31\n\t\t\t\t - n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t- n13 * n22 * n31\n\t\t\t\t - n11 * n23 * n32\n\t\t\t\t + n11 * n22 * n33\n\t\t\t\t + n13 * n21 * n32\n\t\t\t\t - n12 * n21 * n33\n\t\t\t\t + n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t}\n\n\ttranspose() {\n\n\t\tconst te = this.elements;\n\t\tlet tmp;\n\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\n\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\n\n\t\treturn this;\n\n\t}\n\n\tsetPosition( x, y, z ) {\n\n\t\tconst te = this.elements;\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\tte[ 12 ] = x.x;\n\t\t\tte[ 13 ] = x.y;\n\t\t\tte[ 14 ] = x.z;\n\n\t\t} else {\n\n\t\t\tte[ 12 ] = x;\n\t\t\tte[ 13 ] = y;\n\t\t\tte[ 14 ] = z;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tinvert() {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tconst te = this.elements,\n\n\t\t\tn11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],\n\t\t\tn12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],\n\t\t\tn13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],\n\t\t\tn14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],\n\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\t\tconst det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\t\tif ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );\n\n\t\tconst detInv = 1 / det;\n\n\t\tte[ 0 ] = t11 * detInv;\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\n\n\t\tte[ 4 ] = t12 * detInv;\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\n\n\t\tte[ 8 ] = t13 * detInv;\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\n\n\t\tte[ 12 ] = t14 * detInv;\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\n\n\t\treturn this;\n\n\t}\n\n\tscale( v ) {\n\n\t\tconst te = this.elements;\n\t\tconst x = v.x, y = v.y, z = v.z;\n\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\n\n\t\treturn this;\n\n\t}\n\n\tgetMaxScaleOnAxis() {\n\n\t\tconst te = this.elements;\n\n\t\tconst scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\n\t\tconst scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\n\t\tconst scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\n\n\t}\n\n\tmakeTranslation( x, y, z ) {\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x.x,\n\t\t\t\t0, 1, 0, x.y,\n\t\t\t\t0, 0, 1, x.z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tthis.set(\n\n\t\t\t\t1, 0, 0, x,\n\t\t\t\t0, 1, 0, y,\n\t\t\t\t0, 0, 1, z,\n\t\t\t\t0, 0, 0, 1\n\n\t\t\t);\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationX( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, c, - s, 0,\n\t\t\t0, s, c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationY( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t- s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationZ( theta ) {\n\n\t\tconst c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, - s, 0, 0,\n\t\t\ts, c, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeRotationAxis( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tconst c = Math.cos( angle );\n\t\tconst s = Math.sin( angle );\n\t\tconst t = 1 - c;\n\t\tconst x = axis.x, y = axis.y, z = axis.z;\n\t\tconst tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeScale( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tmakeShear( xy, xz, yx, yz, zx, zy ) {\n\n\t\tthis.set(\n\n\t\t\t1, yx, zx, 0,\n\t\t\txy, 1, zy, 0,\n\t\t\txz, yz, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t}\n\n\tcompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tconst x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n\t\tconst x2 = x + x,\ty2 = y + y, z2 = z + z;\n\t\tconst xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tconst yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tconst wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tconst sx = scale.x, sy = scale.y, sz = scale.z;\n\n\t\tte[ 0 ] = ( 1 - ( yy + zz ) ) * sx;\n\t\tte[ 1 ] = ( xy + wz ) * sx;\n\t\tte[ 2 ] = ( xz - wy ) * sx;\n\t\tte[ 3 ] = 0;\n\n\t\tte[ 4 ] = ( xy - wz ) * sy;\n\t\tte[ 5 ] = ( 1 - ( xx + zz ) ) * sy;\n\t\tte[ 6 ] = ( yz + wx ) * sy;\n\t\tte[ 7 ] = 0;\n\n\t\tte[ 8 ] = ( xz + wy ) * sz;\n\t\tte[ 9 ] = ( yz - wx ) * sz;\n\t\tte[ 10 ] = ( 1 - ( xx + yy ) ) * sz;\n\t\tte[ 11 ] = 0;\n\n\t\tte[ 12 ] = position.x;\n\t\tte[ 13 ] = position.y;\n\t\tte[ 14 ] = position.z;\n\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tdecompose( position, quaternion, scale ) {\n\n\t\tconst te = this.elements;\n\n\t\tlet sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\n\t\tconst sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\n\t\tconst sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\n\n\t\t// if determine is negative, we need to invert one scale\n\t\tconst det = this.determinant();\n\t\tif ( det < 0 ) sx = - sx;\n\n\t\tposition.x = te[ 12 ];\n\t\tposition.y = te[ 13 ];\n\t\tposition.z = te[ 14 ];\n\n\t\t// scale the rotation part\n\t\t_m1$2.copy( this );\n\n\t\tconst invSX = 1 / sx;\n\t\tconst invSY = 1 / sy;\n\t\tconst invSZ = 1 / sz;\n\n\t\t_m1$2.elements[ 0 ] *= invSX;\n\t\t_m1$2.elements[ 1 ] *= invSX;\n\t\t_m1$2.elements[ 2 ] *= invSX;\n\n\t\t_m1$2.elements[ 4 ] *= invSY;\n\t\t_m1$2.elements[ 5 ] *= invSY;\n\t\t_m1$2.elements[ 6 ] *= invSY;\n\n\t\t_m1$2.elements[ 8 ] *= invSZ;\n\t\t_m1$2.elements[ 9 ] *= invSZ;\n\t\t_m1$2.elements[ 10 ] *= invSZ;\n\n\t\tquaternion.setFromRotationMatrix( _m1$2 );\n\n\t\tscale.x = sx;\n\t\tscale.y = sy;\n\t\tscale.z = sz;\n\n\t\treturn this;\n\n\t}\n\n\tmakePerspective( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\tconst te = this.elements;\n\t\tconst x = 2 * near / ( right - left );\n\t\tconst y = 2 * near / ( top - bottom );\n\n\t\tconst a = ( right + left ) / ( right - left );\n\t\tconst b = ( top + bottom ) / ( top - bottom );\n\n\t\tlet c, d;\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tc = - ( far + near ) / ( far - near );\n\t\t\td = ( - 2 * far * near ) / ( far - near );\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tc = - far / ( far - near );\n\t\t\td = ( - far * near ) / ( far - near );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a; \tte[ 12 ] = 0;\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b; \tte[ 13 ] = 0;\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c; \tte[ 14 ] = d;\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\n\n\t\treturn this;\n\n\t}\n\n\tmakeOrthographic( left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\tconst te = this.elements;\n\t\tconst w = 1.0 / ( right - left );\n\t\tconst h = 1.0 / ( top - bottom );\n\t\tconst p = 1.0 / ( far - near );\n\n\t\tconst x = ( right + left ) * w;\n\t\tconst y = ( top + bottom ) * h;\n\n\t\tlet z, zInv;\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tz = ( far + near ) * p;\n\t\t\tzInv = - 2 * p;\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tz = near * p;\n\t\t\tzInv = - 1 * p;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\t\tte[ 8 ] = 0; \t\tte[ 12 ] = - x;\n\t\tte[ 1 ] = 0; \t\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0; \t\tte[ 13 ] = - y;\n\t\tte[ 2 ] = 0; \t\tte[ 6 ] = 0;\t\tte[ 10 ] = zInv;\tte[ 14 ] = - z;\n\t\tte[ 3 ] = 0; \t\tte[ 7 ] = 0;\t\tte[ 11 ] = 0;\t\tte[ 15 ] = 1;\n\n\t\treturn this;\n\n\t}\n\n\tequals( matrix ) {\n\n\t\tconst te = this.elements;\n\t\tconst me = matrix.elements;\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tthis.elements[ i ] = array[ i + offset ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst te = this.elements;\n\n\t\tarray[ offset ] = te[ 0 ];\n\t\tarray[ offset + 1 ] = te[ 1 ];\n\t\tarray[ offset + 2 ] = te[ 2 ];\n\t\tarray[ offset + 3 ] = te[ 3 ];\n\n\t\tarray[ offset + 4 ] = te[ 4 ];\n\t\tarray[ offset + 5 ] = te[ 5 ];\n\t\tarray[ offset + 6 ] = te[ 6 ];\n\t\tarray[ offset + 7 ] = te[ 7 ];\n\n\t\tarray[ offset + 8 ] = te[ 8 ];\n\t\tarray[ offset + 9 ] = te[ 9 ];\n\t\tarray[ offset + 10 ] = te[ 10 ];\n\t\tarray[ offset + 11 ] = te[ 11 ];\n\n\t\tarray[ offset + 12 ] = te[ 12 ];\n\t\tarray[ offset + 13 ] = te[ 13 ];\n\t\tarray[ offset + 14 ] = te[ 14 ];\n\t\tarray[ offset + 15 ] = te[ 15 ];\n\n\t\treturn array;\n\n\t}\n\n}\n\nconst _v1$5 = /*@__PURE__*/ new Vector3();\nconst _m1$2 = /*@__PURE__*/ new Matrix4();\nconst _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );\nconst _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );\nconst _x = /*@__PURE__*/ new Vector3();\nconst _y = /*@__PURE__*/ new Vector3();\nconst _z = /*@__PURE__*/ new Vector3();\n\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _quaternion$3 = /*@__PURE__*/ new Quaternion();\n\nclass Euler {\n\n\tconstructor( x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER ) {\n\n\t\tthis.isEuler = true;\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order;\n\n\t}\n\n\tget x() {\n\n\t\treturn this._x;\n\n\t}\n\n\tset x( value ) {\n\n\t\tthis._x = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget y() {\n\n\t\treturn this._y;\n\n\t}\n\n\tset y( value ) {\n\n\t\tthis._y = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget z() {\n\n\t\treturn this._z;\n\n\t}\n\n\tset z( value ) {\n\n\t\tthis._z = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tget order() {\n\n\t\treturn this._order;\n\n\t}\n\n\tset order( value ) {\n\n\t\tthis._order = value;\n\t\tthis._onChangeCallback();\n\n\t}\n\n\tset( x, y, z, order = this._order ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\n\n\t}\n\n\tcopy( euler ) {\n\n\t\tthis._x = euler._x;\n\t\tthis._y = euler._y;\n\t\tthis._z = euler._z;\n\t\tthis._order = euler._order;\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromRotationMatrix( m, order = this._order, update = true ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements;\n\t\tconst m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\n\t\tconst m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\n\t\tconst m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\n\n\t\tswitch ( order ) {\n\n\t\t\tcase 'XYZ':\n\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m13 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'YXZ':\n\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m23 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\t\tthis._z = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZXY':\n\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m32 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._y = 0;\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZYX':\n\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m31 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'YZX':\n\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m21 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = 0;\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'XZY':\n\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\n\n\t\t\t\tif ( Math.abs( m12 ) < 0.9999999 ) {\n\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\t\tthis._y = 0;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tif ( update === true ) this._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\tsetFromQuaternion( q, order, update ) {\n\n\t\t_matrix.makeRotationFromQuaternion( q );\n\n\t\treturn this.setFromRotationMatrix( _matrix, order, update );\n\n\t}\n\n\tsetFromVector3( v, order = this._order ) {\n\n\t\treturn this.set( v.x, v.y, v.z, order );\n\n\t}\n\n\treorder( newOrder ) {\n\n\t\t// WARNING: this discards revolution information -bhouston\n\n\t\t_quaternion$3.setFromEuler( this );\n\n\t\treturn this.setFromQuaternion( _quaternion$3, newOrder );\n\n\t}\n\n\tequals( euler ) {\n\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t}\n\n\tfromArray( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\tthis._onChangeCallback();\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this._x;\n\t\tarray[ offset + 1 ] = this._y;\n\t\tarray[ offset + 2 ] = this._z;\n\t\tarray[ offset + 3 ] = this._order;\n\n\t\treturn array;\n\n\t}\n\n\t_onChange( callback ) {\n\n\t\tthis._onChangeCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\t_onChangeCallback() {}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this._x;\n\t\tyield this._y;\n\t\tyield this._z;\n\t\tyield this._order;\n\n\t}\n\n}\n\nEuler.DEFAULT_ORDER = 'XYZ';\n\nclass Layers {\n\n\tconstructor() {\n\n\t\tthis.mask = 1 | 0;\n\n\t}\n\n\tset( channel ) {\n\n\t\tthis.mask = ( 1 << channel | 0 ) >>> 0;\n\n\t}\n\n\tenable( channel ) {\n\n\t\tthis.mask |= 1 << channel | 0;\n\n\t}\n\n\tenableAll() {\n\n\t\tthis.mask = 0xffffffff | 0;\n\n\t}\n\n\ttoggle( channel ) {\n\n\t\tthis.mask ^= 1 << channel | 0;\n\n\t}\n\n\tdisable( channel ) {\n\n\t\tthis.mask &= ~ ( 1 << channel | 0 );\n\n\t}\n\n\tdisableAll() {\n\n\t\tthis.mask = 0;\n\n\t}\n\n\ttest( layers ) {\n\n\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t}\n\n\tisEnabled( channel ) {\n\n\t\treturn ( this.mask & ( 1 << channel | 0 ) ) !== 0;\n\n\t}\n\n}\n\nlet _object3DId = 0;\n\nconst _v1$4 = /*@__PURE__*/ new Vector3();\nconst _q1 = /*@__PURE__*/ new Quaternion();\nconst _m1$1 = /*@__PURE__*/ new Matrix4();\nconst _target = /*@__PURE__*/ new Vector3();\n\nconst _position$3 = /*@__PURE__*/ new Vector3();\nconst _scale$2 = /*@__PURE__*/ new Vector3();\nconst _quaternion$2 = /*@__PURE__*/ new Quaternion();\n\nconst _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );\nconst _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );\nconst _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );\n\nconst _addedEvent = { type: 'added' };\nconst _removedEvent = { type: 'removed' };\n\nclass Object3D extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isObject3D = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _object3DId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Object3D';\n\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\n\t\tthis.up = Object3D.DEFAULT_UP.clone();\n\n\t\tconst position = new Vector3();\n\t\tconst rotation = new Euler();\n\t\tconst quaternion = new Quaternion();\n\t\tconst scale = new Vector3( 1, 1, 1 );\n\n\t\tfunction onRotationChange() {\n\n\t\t\tquaternion.setFromEuler( rotation, false );\n\n\t\t}\n\n\t\tfunction onQuaternionChange() {\n\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\n\n\t\t}\n\n\t\trotation._onChange( onRotationChange );\n\t\tquaternion._onChange( onQuaternionChange );\n\n\t\tObject.defineProperties( this, {\n\t\t\tposition: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: position\n\t\t\t},\n\t\t\trotation: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: rotation\n\t\t\t},\n\t\t\tquaternion: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: quaternion\n\t\t\t},\n\t\t\tscale: {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: scale\n\t\t\t},\n\t\t\tmodelViewMatrix: {\n\t\t\t\tvalue: new Matrix4()\n\t\t\t},\n\t\t\tnormalMatrix: {\n\t\t\t\tvalue: new Matrix3()\n\t\t\t}\n\t\t} );\n\n\t\tthis.matrix = new Matrix4();\n\t\tthis.matrixWorld = new Matrix4();\n\n\t\tthis.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;\n\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\tthis.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer\n\n\t\tthis.layers = new Layers();\n\t\tthis.visible = true;\n\n\t\tthis.castShadow = false;\n\t\tthis.receiveShadow = false;\n\n\t\tthis.frustumCulled = true;\n\t\tthis.renderOrder = 0;\n\n\t\tthis.animations = [];\n\n\t\tthis.userData = {};\n\n\t}\n\n\tonBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}\n\n\tonAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tthis.matrix.premultiply( matrix );\n\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\tthis.quaternion.premultiply( q );\n\n\t\treturn this;\n\n\t}\n\n\tsetRotationFromAxisAngle( axis, angle ) {\n\n\t\t// assumes axis is normalized\n\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t}\n\n\tsetRotationFromEuler( euler ) {\n\n\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t}\n\n\tsetRotationFromMatrix( m ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t}\n\n\tsetRotationFromQuaternion( q ) {\n\n\t\t// assumes q is normalized\n\n\t\tthis.quaternion.copy( q );\n\n\t}\n\n\trotateOnAxis( axis, angle ) {\n\n\t\t// rotate object on axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\t_q1.setFromAxisAngle( axis, angle );\n\n\t\tthis.quaternion.multiply( _q1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateOnWorldAxis( axis, angle ) {\n\n\t\t// rotate object on axis in world space\n\t\t// axis is assumed to be normalized\n\t\t// method assumes no rotated parent\n\n\t\t_q1.setFromAxisAngle( axis, angle );\n\n\t\tthis.quaternion.premultiply( _q1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateX( angle ) {\n\n\t\treturn this.rotateOnAxis( _xAxis, angle );\n\n\t}\n\n\trotateY( angle ) {\n\n\t\treturn this.rotateOnAxis( _yAxis, angle );\n\n\t}\n\n\trotateZ( angle ) {\n\n\t\treturn this.rotateOnAxis( _zAxis, angle );\n\n\t}\n\n\ttranslateOnAxis( axis, distance ) {\n\n\t\t// translate object by distance along axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\t_v1$4.copy( axis ).applyQuaternion( this.quaternion );\n\n\t\tthis.position.add( _v1$4.multiplyScalar( distance ) );\n\n\t\treturn this;\n\n\t}\n\n\ttranslateX( distance ) {\n\n\t\treturn this.translateOnAxis( _xAxis, distance );\n\n\t}\n\n\ttranslateY( distance ) {\n\n\t\treturn this.translateOnAxis( _yAxis, distance );\n\n\t}\n\n\ttranslateZ( distance ) {\n\n\t\treturn this.translateOnAxis( _zAxis, distance );\n\n\t}\n\n\tlocalToWorld( vector ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t}\n\n\tworldToLocal( vector ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );\n\n\t}\n\n\tlookAt( x, y, z ) {\n\n\t\t// This method does not support objects having non-uniformly-scaled parent(s)\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\t_target.copy( x );\n\n\t\t} else {\n\n\t\t\t_target.set( x, y, z );\n\n\t\t}\n\n\t\tconst parent = this.parent;\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\t_position$3.setFromMatrixPosition( this.matrixWorld );\n\n\t\tif ( this.isCamera || this.isLight ) {\n\n\t\t\t_m1$1.lookAt( _position$3, _target, this.up );\n\n\t\t} else {\n\n\t\t\t_m1$1.lookAt( _target, _position$3, this.up );\n\n\t\t}\n\n\t\tthis.quaternion.setFromRotationMatrix( _m1$1 );\n\n\t\tif ( parent ) {\n\n\t\t\t_m1$1.extractRotation( parent.matrixWorld );\n\t\t\t_q1.setFromRotationMatrix( _m1$1 );\n\t\t\tthis.quaternion.premultiply( _q1.invert() );\n\n\t\t}\n\n\t}\n\n\tadd( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.add( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.error( 'THREE.Object3D.add: object can\\'t be added as a child of itself.', object );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( object && object.isObject3D ) {\n\n\t\t\tif ( object.parent !== null ) {\n\n\t\t\t\tobject.parent.remove( object );\n\n\t\t\t}\n\n\t\t\tobject.parent = this;\n\t\t\tthis.children.push( object );\n\n\t\t\tobject.dispatchEvent( _addedEvent );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tremove( object ) {\n\n\t\tif ( arguments.length > 1 ) {\n\n\t\t\tfor ( let i = 0; i < arguments.length; i ++ ) {\n\n\t\t\t\tthis.remove( arguments[ i ] );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = null;\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t\tobject.dispatchEvent( _removedEvent );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tremoveFromParent() {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tparent.remove( this );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclear() {\n\n\t\tfor ( let i = 0; i < this.children.length; i ++ ) {\n\n\t\t\tconst object = this.children[ i ];\n\n\t\t\tobject.parent = null;\n\n\t\t\tobject.dispatchEvent( _removedEvent );\n\n\t\t}\n\n\t\tthis.children.length = 0;\n\n\t\treturn this;\n\n\n\t}\n\n\tattach( object ) {\n\n\t\t// adds object as a child of this, while maintaining the object's world transform\n\n\t\t// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\t_m1$1.copy( this.matrixWorld ).invert();\n\n\t\tif ( object.parent !== null ) {\n\n\t\t\tobject.parent.updateWorldMatrix( true, false );\n\n\t\t\t_m1$1.multiply( object.parent.matrixWorld );\n\n\t\t}\n\n\t\tobject.applyMatrix4( _m1$1 );\n\n\t\tthis.add( object );\n\n\t\tobject.updateWorldMatrix( false, true );\n\n\t\treturn this;\n\n\t}\n\n\tgetObjectById( id ) {\n\n\t\treturn this.getObjectByProperty( 'id', id );\n\n\t}\n\n\tgetObjectByName( name ) {\n\n\t\treturn this.getObjectByProperty( 'name', name );\n\n\t}\n\n\tgetObjectByProperty( name, value ) {\n\n\t\tif ( this[ name ] === value ) return this;\n\n\t\tfor ( let i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tconst child = this.children[ i ];\n\t\t\tconst object = child.getObjectByProperty( name, value );\n\n\t\t\tif ( object !== undefined ) {\n\n\t\t\t\treturn object;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\tgetObjectsByProperty( name, value ) {\n\n\t\tlet result = [];\n\n\t\tif ( this[ name ] === value ) result.push( this );\n\n\t\tfor ( let i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tconst childResult = this.children[ i ].getObjectsByProperty( name, value );\n\n\t\t\tif ( childResult.length > 0 ) {\n\n\t\t\t\tresult = result.concat( childResult );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tgetWorldPosition( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\treturn target.setFromMatrixPosition( this.matrixWorld );\n\n\t}\n\n\tgetWorldQuaternion( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tthis.matrixWorld.decompose( _position$3, target, _scale$2 );\n\n\t\treturn target;\n\n\t}\n\n\tgetWorldScale( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tthis.matrixWorld.decompose( _position$3, _quaternion$2, target );\n\n\t\treturn target;\n\n\t}\n\n\tgetWorldDirection( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tconst e = this.matrixWorld.elements;\n\n\t\treturn target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();\n\n\t}\n\n\traycast( /* raycaster, intersects */ ) {}\n\n\ttraverse( callback ) {\n\n\t\tcallback( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverse( callback );\n\n\t\t}\n\n\t}\n\n\ttraverseVisible( callback ) {\n\n\t\tif ( this.visible === false ) return;\n\n\t\tcallback( this );\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].traverseVisible( callback );\n\n\t\t}\n\n\t}\n\n\ttraverseAncestors( callback ) {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( parent !== null ) {\n\n\t\t\tcallback( parent );\n\n\t\t\tparent.traverseAncestors( callback );\n\n\t\t}\n\n\t}\n\n\tupdateMatrix() {\n\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\tif ( this.parent === null ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// update children\n\n\t\tconst children = this.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tconst child = children[ i ];\n\n\t\t\tif ( child.matrixWorldAutoUpdate === true || force === true ) {\n\n\t\t\t\tchild.updateMatrixWorld( force );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tconst parent = this.parent;\n\n\t\tif ( updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true ) {\n\n\t\t\tparent.updateWorldMatrix( true, false );\n\n\t\t}\n\n\t\tif ( this.matrixAutoUpdate ) this.updateMatrix();\n\n\t\tif ( this.parent === null ) {\n\n\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t} else {\n\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t}\n\n\t\t// update children\n\n\t\tif ( updateChildren === true ) {\n\n\t\t\tconst children = this.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\n\t\t\t\tif ( child.matrixWorldAutoUpdate === true ) {\n\n\t\t\t\t\tchild.updateWorldMatrix( false, true );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\t// meta is a string when called from JSON.stringify\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tconst output = {};\n\n\t\t// meta is a hash used to collect geometries, materials.\n\t\t// not providing it implies that this is the root object\n\t\t// being serialized.\n\t\tif ( isRootObject ) {\n\n\t\t\t// initialize meta obj\n\t\t\tmeta = {\n\t\t\t\tgeometries: {},\n\t\t\t\tmaterials: {},\n\t\t\t\ttextures: {},\n\t\t\t\timages: {},\n\t\t\t\tshapes: {},\n\t\t\t\tskeletons: {},\n\t\t\t\tanimations: {},\n\t\t\t\tnodes: {}\n\t\t\t};\n\n\t\t\toutput.metadata = {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Object',\n\t\t\t\tgenerator: 'Object3D.toJSON'\n\t\t\t};\n\n\t\t}\n\n\t\t// standard Object3D serialization\n\n\t\tconst object = {};\n\n\t\tobject.uuid = this.uuid;\n\t\tobject.type = this.type;\n\n\t\tif ( this.name !== '' ) object.name = this.name;\n\t\tif ( this.castShadow === true ) object.castShadow = true;\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\n\t\tif ( this.visible === false ) object.visible = false;\n\t\tif ( this.frustumCulled === false ) object.frustumCulled = false;\n\t\tif ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;\n\t\tif ( Object.keys( this.userData ).length > 0 ) object.userData = this.userData;\n\n\t\tobject.layers = this.layers.mask;\n\t\tobject.matrix = this.matrix.toArray();\n\t\tobject.up = this.up.toArray();\n\n\t\tif ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;\n\n\t\t// object specific properties\n\n\t\tif ( this.isInstancedMesh ) {\n\n\t\t\tobject.type = 'InstancedMesh';\n\t\t\tobject.count = this.count;\n\t\t\tobject.instanceMatrix = this.instanceMatrix.toJSON();\n\t\t\tif ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();\n\n\t\t}\n\n\t\t//\n\n\t\tfunction serialize( library, element ) {\n\n\t\t\tif ( library[ element.uuid ] === undefined ) {\n\n\t\t\t\tlibrary[ element.uuid ] = element.toJSON( meta );\n\n\t\t\t}\n\n\t\t\treturn element.uuid;\n\n\t\t}\n\n\t\tif ( this.isScene ) {\n\n\t\t\tif ( this.background ) {\n\n\t\t\t\tif ( this.background.isColor ) {\n\n\t\t\t\t\tobject.background = this.background.toJSON();\n\n\t\t\t\t} else if ( this.background.isTexture ) {\n\n\t\t\t\t\tobject.background = this.background.toJSON( meta ).uuid;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {\n\n\t\t\t\tobject.environment = this.environment.toJSON( meta ).uuid;\n\n\t\t\t}\n\n\t\t} else if ( this.isMesh || this.isLine || this.isPoints ) {\n\n\t\t\tobject.geometry = serialize( meta.geometries, this.geometry );\n\n\t\t\tconst parameters = this.geometry.parameters;\n\n\t\t\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\n\n\t\t\t\tconst shapes = parameters.shapes;\n\n\t\t\t\tif ( Array.isArray( shapes ) ) {\n\n\t\t\t\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst shape = shapes[ i ];\n\n\t\t\t\t\t\tserialize( meta.shapes, shape );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tserialize( meta.shapes, shapes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.isSkinnedMesh ) {\n\n\t\t\tobject.bindMode = this.bindMode;\n\t\t\tobject.bindMatrix = this.bindMatrix.toArray();\n\n\t\t\tif ( this.skeleton !== undefined ) {\n\n\t\t\t\tserialize( meta.skeletons, this.skeleton );\n\n\t\t\t\tobject.skeleton = this.skeleton.uuid;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.material !== undefined ) {\n\n\t\t\tif ( Array.isArray( this.material ) ) {\n\n\t\t\t\tconst uuids = [];\n\n\t\t\t\tfor ( let i = 0, l = this.material.length; i < l; i ++ ) {\n\n\t\t\t\t\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\n\n\t\t\t\t}\n\n\t\t\t\tobject.material = uuids;\n\n\t\t\t} else {\n\n\t\t\t\tobject.material = serialize( meta.materials, this.material );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.children.length > 0 ) {\n\n\t\t\tobject.children = [];\n\n\t\t\tfor ( let i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.animations.length > 0 ) {\n\n\t\t\tobject.animations = [];\n\n\t\t\tfor ( let i = 0; i < this.animations.length; i ++ ) {\n\n\t\t\t\tconst animation = this.animations[ i ];\n\n\t\t\t\tobject.animations.push( serialize( meta.animations, animation ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tconst geometries = extractFromCache( meta.geometries );\n\t\t\tconst materials = extractFromCache( meta.materials );\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\t\t\tconst shapes = extractFromCache( meta.shapes );\n\t\t\tconst skeletons = extractFromCache( meta.skeletons );\n\t\t\tconst animations = extractFromCache( meta.animations );\n\t\t\tconst nodes = extractFromCache( meta.nodes );\n\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\n\t\t\tif ( images.length > 0 ) output.images = images;\n\t\t\tif ( shapes.length > 0 ) output.shapes = shapes;\n\t\t\tif ( skeletons.length > 0 ) output.skeletons = skeletons;\n\t\t\tif ( animations.length > 0 ) output.animations = animations;\n\t\t\tif ( nodes.length > 0 ) output.nodes = nodes;\n\n\t\t}\n\n\t\toutput.object = object;\n\n\t\treturn output;\n\n\t\t// extract data from the cache hash\n\t\t// remove metadata on each item\n\t\t// and return as array\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t}\n\n\tclone( recursive ) {\n\n\t\treturn new this.constructor().copy( this, recursive );\n\n\t}\n\n\tcopy( source, recursive = true ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.up.copy( source.up );\n\n\t\tthis.position.copy( source.position );\n\t\tthis.rotation.order = source.rotation.order;\n\t\tthis.quaternion.copy( source.quaternion );\n\t\tthis.scale.copy( source.scale );\n\n\t\tthis.matrix.copy( source.matrix );\n\t\tthis.matrixWorld.copy( source.matrixWorld );\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n\n\t\tthis.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;\n\n\t\tthis.layers.mask = source.layers.mask;\n\t\tthis.visible = source.visible;\n\n\t\tthis.castShadow = source.castShadow;\n\t\tthis.receiveShadow = source.receiveShadow;\n\n\t\tthis.frustumCulled = source.frustumCulled;\n\t\tthis.renderOrder = source.renderOrder;\n\n\t\tthis.animations = source.animations;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tfor ( let i = 0; i < source.children.length; i ++ ) {\n\n\t\t\t\tconst child = source.children[ i ];\n\t\t\t\tthis.add( child.clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nObject3D.DEFAULT_UP = /*@__PURE__*/ new Vector3( 0, 1, 0 );\nObject3D.DEFAULT_MATRIX_AUTO_UPDATE = true;\nObject3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;\n\nconst _v0$1 = /*@__PURE__*/ new Vector3();\nconst _v1$3 = /*@__PURE__*/ new Vector3();\nconst _v2$2 = /*@__PURE__*/ new Vector3();\nconst _v3$1 = /*@__PURE__*/ new Vector3();\n\nconst _vab = /*@__PURE__*/ new Vector3();\nconst _vac = /*@__PURE__*/ new Vector3();\nconst _vbc = /*@__PURE__*/ new Vector3();\nconst _vap = /*@__PURE__*/ new Vector3();\nconst _vbp = /*@__PURE__*/ new Vector3();\nconst _vcp = /*@__PURE__*/ new Vector3();\n\nlet warnedGetUV = false;\n\nclass Triangle {\n\n\tconstructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t}\n\n\tstatic getNormal( a, b, c, target ) {\n\n\t\ttarget.subVectors( c, b );\n\t\t_v0$1.subVectors( a, b );\n\t\ttarget.cross( _v0$1 );\n\n\t\tconst targetLengthSq = target.lengthSq();\n\t\tif ( targetLengthSq > 0 ) {\n\n\t\t\treturn target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );\n\n\t\t}\n\n\t\treturn target.set( 0, 0, 0 );\n\n\t}\n\n\t// static/instance method to calculate barycentric coordinates\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n\tstatic getBarycoord( point, a, b, c, target ) {\n\n\t\t_v0$1.subVectors( c, a );\n\t\t_v1$3.subVectors( b, a );\n\t\t_v2$2.subVectors( point, a );\n\n\t\tconst dot00 = _v0$1.dot( _v0$1 );\n\t\tconst dot01 = _v0$1.dot( _v1$3 );\n\t\tconst dot02 = _v0$1.dot( _v2$2 );\n\t\tconst dot11 = _v1$3.dot( _v1$3 );\n\t\tconst dot12 = _v1$3.dot( _v2$2 );\n\n\t\tconst denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\t// collinear or singular triangle\n\t\tif ( denom === 0 ) {\n\n\t\t\t// arbitrary location outside of triangle?\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\treturn target.set( - 2, - 1, - 1 );\n\n\t\t}\n\n\t\tconst invDenom = 1 / denom;\n\t\tconst u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tconst v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycentric coordinates must always sum to 1\n\t\treturn target.set( 1 - u - v, v, u );\n\n\t}\n\n\tstatic containsPoint( point, a, b, c ) {\n\n\t\tthis.getBarycoord( point, a, b, c, _v3$1 );\n\n\t\treturn ( _v3$1.x >= 0 ) && ( _v3$1.y >= 0 ) && ( ( _v3$1.x + _v3$1.y ) <= 1 );\n\n\t}\n\n\tstatic getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) { // @deprecated, r151\n\n\t\tif ( warnedGetUV === false ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().' );\n\n\t\t\twarnedGetUV = true;\n\n\t\t}\n\n\t\treturn this.getInterpolation( point, p1, p2, p3, uv1, uv2, uv3, target );\n\n\t}\n\n\tstatic getInterpolation( point, p1, p2, p3, v1, v2, v3, target ) {\n\n\t\tthis.getBarycoord( point, p1, p2, p3, _v3$1 );\n\n\t\ttarget.setScalar( 0 );\n\t\ttarget.addScaledVector( v1, _v3$1.x );\n\t\ttarget.addScaledVector( v2, _v3$1.y );\n\t\ttarget.addScaledVector( v3, _v3$1.z );\n\n\t\treturn target;\n\n\t}\n\n\tstatic isFrontFacing( a, b, c, direction ) {\n\n\t\t_v0$1.subVectors( c, b );\n\t\t_v1$3.subVectors( a, b );\n\n\t\t// strictly front facing\n\t\treturn ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;\n\n\t}\n\n\tset( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPointsAndIndices( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[ i0 ] );\n\t\tthis.b.copy( points[ i1 ] );\n\t\tthis.c.copy( points[ i2 ] );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromAttributeAndIndices( attribute, i0, i1, i2 ) {\n\n\t\tthis.a.fromBufferAttribute( attribute, i0 );\n\t\tthis.b.fromBufferAttribute( attribute, i1 );\n\t\tthis.c.fromBufferAttribute( attribute, i2 );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t}\n\n\tgetArea() {\n\n\t\t_v0$1.subVectors( this.c, this.b );\n\t\t_v1$3.subVectors( this.a, this.b );\n\n\t\treturn _v0$1.cross( _v1$3 ).length() * 0.5;\n\n\t}\n\n\tgetMidpoint( target ) {\n\n\t\treturn target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t}\n\n\tgetNormal( target ) {\n\n\t\treturn Triangle.getNormal( this.a, this.b, this.c, target );\n\n\t}\n\n\tgetPlane( target ) {\n\n\t\treturn target.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t}\n\n\tgetBarycoord( point, target ) {\n\n\t\treturn Triangle.getBarycoord( point, this.a, this.b, this.c, target );\n\n\t}\n\n\tgetUV( point, uv1, uv2, uv3, target ) { // @deprecated, r151\n\n\t\tif ( warnedGetUV === false ) {\n\n\t\t\tconsole.warn( 'THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().' );\n\n\t\t\twarnedGetUV = true;\n\n\t\t}\n\n\t\treturn Triangle.getInterpolation( point, this.a, this.b, this.c, uv1, uv2, uv3, target );\n\n\t}\n\n\tgetInterpolation( point, v1, v2, v3, target ) {\n\n\t\treturn Triangle.getInterpolation( point, this.a, this.b, this.c, v1, v2, v3, target );\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t}\n\n\tisFrontFacing( direction ) {\n\n\t\treturn Triangle.isFrontFacing( this.a, this.b, this.c, direction );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsTriangle( this );\n\n\t}\n\n\tclosestPointToPoint( p, target ) {\n\n\t\tconst a = this.a, b = this.b, c = this.c;\n\t\tlet v, w;\n\n\t\t// algorithm thanks to Real-Time Collision Detection by Christer Ericson,\n\t\t// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,\n\t\t// under the accompanying license; see chapter 5.1.5 for detailed explanation.\n\t\t// basically, we're distinguishing which of the voronoi regions of the triangle\n\t\t// the point lies in with the minimum amount of redundant computation.\n\n\t\t_vab.subVectors( b, a );\n\t\t_vac.subVectors( c, a );\n\t\t_vap.subVectors( p, a );\n\t\tconst d1 = _vab.dot( _vap );\n\t\tconst d2 = _vac.dot( _vap );\n\t\tif ( d1 <= 0 && d2 <= 0 ) {\n\n\t\t\t// vertex region of A; barycentric coords (1, 0, 0)\n\t\t\treturn target.copy( a );\n\n\t\t}\n\n\t\t_vbp.subVectors( p, b );\n\t\tconst d3 = _vab.dot( _vbp );\n\t\tconst d4 = _vac.dot( _vbp );\n\t\tif ( d3 >= 0 && d4 <= d3 ) {\n\n\t\t\t// vertex region of B; barycentric coords (0, 1, 0)\n\t\t\treturn target.copy( b );\n\n\t\t}\n\n\t\tconst vc = d1 * d4 - d3 * d2;\n\t\tif ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {\n\n\t\t\tv = d1 / ( d1 - d3 );\n\t\t\t// edge region of AB; barycentric coords (1-v, v, 0)\n\t\t\treturn target.copy( a ).addScaledVector( _vab, v );\n\n\t\t}\n\n\t\t_vcp.subVectors( p, c );\n\t\tconst d5 = _vab.dot( _vcp );\n\t\tconst d6 = _vac.dot( _vcp );\n\t\tif ( d6 >= 0 && d5 <= d6 ) {\n\n\t\t\t// vertex region of C; barycentric coords (0, 0, 1)\n\t\t\treturn target.copy( c );\n\n\t\t}\n\n\t\tconst vb = d5 * d2 - d1 * d6;\n\t\tif ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {\n\n\t\t\tw = d2 / ( d2 - d6 );\n\t\t\t// edge region of AC; barycentric coords (1-w, 0, w)\n\t\t\treturn target.copy( a ).addScaledVector( _vac, w );\n\n\t\t}\n\n\t\tconst va = d3 * d6 - d5 * d4;\n\t\tif ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {\n\n\t\t\t_vbc.subVectors( c, b );\n\t\t\tw = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );\n\t\t\t// edge region of BC; barycentric coords (0, 1-w, w)\n\t\t\treturn target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC\n\n\t\t}\n\n\t\t// face region\n\t\tconst denom = 1 / ( va + vb + vc );\n\t\t// u = va * denom\n\t\tv = vb * denom;\n\t\tw = vc * denom;\n\n\t\treturn target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );\n\n\t}\n\n\tequals( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t}\n\n}\n\nlet materialId = 0;\n\nclass Material extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isMaterial = true;\n\n\t\tObject.defineProperty( this, 'id', { value: materialId ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'Material';\n\n\t\tthis.blending = NormalBlending;\n\t\tthis.side = FrontSide;\n\t\tthis.vertexColors = false;\n\n\t\tthis.opacity = 1;\n\t\tthis.transparent = false;\n\t\tthis.alphaHash = false;\n\n\t\tthis.blendSrc = SrcAlphaFactor;\n\t\tthis.blendDst = OneMinusSrcAlphaFactor;\n\t\tthis.blendEquation = AddEquation;\n\t\tthis.blendSrcAlpha = null;\n\t\tthis.blendDstAlpha = null;\n\t\tthis.blendEquationAlpha = null;\n\n\t\tthis.depthFunc = LessEqualDepth;\n\t\tthis.depthTest = true;\n\t\tthis.depthWrite = true;\n\n\t\tthis.stencilWriteMask = 0xff;\n\t\tthis.stencilFunc = AlwaysStencilFunc;\n\t\tthis.stencilRef = 0;\n\t\tthis.stencilFuncMask = 0xff;\n\t\tthis.stencilFail = KeepStencilOp;\n\t\tthis.stencilZFail = KeepStencilOp;\n\t\tthis.stencilZPass = KeepStencilOp;\n\t\tthis.stencilWrite = false;\n\n\t\tthis.clippingPlanes = null;\n\t\tthis.clipIntersection = false;\n\t\tthis.clipShadows = false;\n\n\t\tthis.shadowSide = null;\n\n\t\tthis.colorWrite = true;\n\n\t\tthis.precision = null; // override the renderer's default precision for this material\n\n\t\tthis.polygonOffset = false;\n\t\tthis.polygonOffsetFactor = 0;\n\t\tthis.polygonOffsetUnits = 0;\n\n\t\tthis.dithering = false;\n\n\t\tthis.alphaToCoverage = false;\n\t\tthis.premultipliedAlpha = false;\n\t\tthis.forceSinglePass = false;\n\n\t\tthis.visible = true;\n\n\t\tthis.toneMapped = true;\n\n\t\tthis.userData = {};\n\n\t\tthis.version = 0;\n\n\t\tthis._alphaTest = 0;\n\n\t}\n\n\tget alphaTest() {\n\n\t\treturn this._alphaTest;\n\n\t}\n\n\tset alphaTest( value ) {\n\n\t\tif ( this._alphaTest > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._alphaTest = value;\n\n\t}\n\n\tonBuild( /* shaderobject, renderer */ ) {}\n\n\tonBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}\n\n\tonBeforeCompile( /* shaderobject, renderer */ ) {}\n\n\tcustomProgramCacheKey() {\n\n\t\treturn this.onBeforeCompile.toString();\n\n\t}\n\n\tsetValues( values ) {\n\n\t\tif ( values === undefined ) return;\n\n\t\tfor ( const key in values ) {\n\n\t\t\tconst newValue = values[ key ];\n\n\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\tconsole.warn( `THREE.Material: parameter '${ key }' has value of undefined.` );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst currentValue = this[ key ];\n\n\t\t\tif ( currentValue === undefined ) {\n\n\t\t\t\tconsole.warn( `THREE.Material: '${ key }' is not a property of THREE.${ this.type }.` );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( currentValue && currentValue.isColor ) {\n\n\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {\n\n\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t} else {\n\n\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst isRootObject = ( meta === undefined || typeof meta === 'string' );\n\n\t\tif ( isRootObject ) {\n\n\t\t\tmeta = {\n\t\t\t\ttextures: {},\n\t\t\t\timages: {}\n\t\t\t};\n\n\t\t}\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Material',\n\t\t\t\tgenerator: 'Material.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Material serialization\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.color && this.color.isColor ) data.color = this.color.getHex();\n\n\t\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\n\t\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\n\n\t\tif ( this.sheen !== undefined ) data.sheen = this.sheen;\n\t\tif ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();\n\t\tif ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;\n\t\tif ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();\n\t\tif ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;\n\n\t\tif ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();\n\t\tif ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;\n\t\tif ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();\n\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\n\t\tif ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;\n\t\tif ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;\n\n\t\tif ( this.clearcoatMap && this.clearcoatMap.isTexture ) {\n\n\t\t\tdata.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {\n\n\t\t\tdata.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {\n\n\t\t\tdata.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;\n\t\t\tdata.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n\n\t\t}\n\n\t\tif ( this.iridescence !== undefined ) data.iridescence = this.iridescence;\n\t\tif ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;\n\t\tif ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;\n\n\t\tif ( this.iridescenceMap && this.iridescenceMap.isTexture ) {\n\n\t\t\tdata.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {\n\n\t\t\tdata.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.anisotropy !== undefined ) data.anisotropy = this.anisotropy;\n\t\tif ( this.anisotropyRotation !== undefined ) data.anisotropyRotation = this.anisotropyRotation;\n\n\t\tif ( this.anisotropyMap && this.anisotropyMap.isTexture ) {\n\n\t\t\tdata.anisotropyMap = this.anisotropyMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;\n\t\tif ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;\n\t\tif ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\n\n\t\tif ( this.lightMap && this.lightMap.isTexture ) {\n\n\t\t\tdata.lightMap = this.lightMap.toJSON( meta ).uuid;\n\t\t\tdata.lightMapIntensity = this.lightMapIntensity;\n\n\t\t}\n\n\t\tif ( this.aoMap && this.aoMap.isTexture ) {\n\n\t\t\tdata.aoMap = this.aoMap.toJSON( meta ).uuid;\n\t\t\tdata.aoMapIntensity = this.aoMapIntensity;\n\n\t\t}\n\n\t\tif ( this.bumpMap && this.bumpMap.isTexture ) {\n\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\n\t\t\tdata.bumpScale = this.bumpScale;\n\n\t\t}\n\n\t\tif ( this.normalMap && this.normalMap.isTexture ) {\n\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\n\t\t\tdata.normalMapType = this.normalMapType;\n\t\t\tdata.normalScale = this.normalScale.toArray();\n\n\t\t}\n\n\t\tif ( this.displacementMap && this.displacementMap.isTexture ) {\n\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\n\t\t\tdata.displacementScale = this.displacementScale;\n\t\t\tdata.displacementBias = this.displacementBias;\n\n\t\t}\n\n\t\tif ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\n\t\tif ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\n\n\t\tif ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\n\t\tif ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\n\t\tif ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;\n\t\tif ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;\n\n\t\tif ( this.envMap && this.envMap.isTexture ) {\n\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\n\n\t\t\tif ( this.combine !== undefined ) data.combine = this.combine;\n\n\t\t}\n\n\t\tif ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;\n\t\tif ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;\n\t\tif ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;\n\n\t\tif ( this.gradientMap && this.gradientMap.isTexture ) {\n\n\t\t\tdata.gradientMap = this.gradientMap.toJSON( meta ).uuid;\n\n\t\t}\n\n\t\tif ( this.transmission !== undefined ) data.transmission = this.transmission;\n\t\tif ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;\n\t\tif ( this.thickness !== undefined ) data.thickness = this.thickness;\n\t\tif ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;\n\t\tif ( this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity ) data.attenuationDistance = this.attenuationDistance;\n\t\tif ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();\n\n\t\tif ( this.size !== undefined ) data.size = this.size;\n\t\tif ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;\n\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\n\n\t\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\n\t\tif ( this.side !== FrontSide ) data.side = this.side;\n\t\tif ( this.vertexColors ) data.vertexColors = true;\n\n\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\n\t\tif ( this.transparent === true ) data.transparent = this.transparent;\n\n\t\tdata.depthFunc = this.depthFunc;\n\t\tdata.depthTest = this.depthTest;\n\t\tdata.depthWrite = this.depthWrite;\n\t\tdata.colorWrite = this.colorWrite;\n\n\t\tdata.stencilWrite = this.stencilWrite;\n\t\tdata.stencilWriteMask = this.stencilWriteMask;\n\t\tdata.stencilFunc = this.stencilFunc;\n\t\tdata.stencilRef = this.stencilRef;\n\t\tdata.stencilFuncMask = this.stencilFuncMask;\n\t\tdata.stencilFail = this.stencilFail;\n\t\tdata.stencilZFail = this.stencilZFail;\n\t\tdata.stencilZPass = this.stencilZPass;\n\n\t\t// rotation (SpriteMaterial)\n\t\tif ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;\n\n\t\tif ( this.polygonOffset === true ) data.polygonOffset = true;\n\t\tif ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;\n\t\tif ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;\n\n\t\tif ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;\n\t\tif ( this.dashSize !== undefined ) data.dashSize = this.dashSize;\n\t\tif ( this.gapSize !== undefined ) data.gapSize = this.gapSize;\n\t\tif ( this.scale !== undefined ) data.scale = this.scale;\n\n\t\tif ( this.dithering === true ) data.dithering = true;\n\n\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\n\t\tif ( this.alphaHash === true ) data.alphaHash = this.alphaHash;\n\t\tif ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;\n\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\n\t\tif ( this.forceSinglePass === true ) data.forceSinglePass = this.forceSinglePass;\n\n\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\n\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\n\t\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\n\t\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\n\n\t\tif ( this.flatShading === true ) data.flatShading = this.flatShading;\n\n\t\tif ( this.visible === false ) data.visible = false;\n\n\t\tif ( this.toneMapped === false ) data.toneMapped = false;\n\n\t\tif ( this.fog === false ) data.fog = false;\n\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\t// TODO: Copied from Object3D.toJSON\n\n\t\tfunction extractFromCache( cache ) {\n\n\t\t\tconst values = [];\n\n\t\t\tfor ( const key in cache ) {\n\n\t\t\t\tconst data = cache[ key ];\n\t\t\t\tdelete data.metadata;\n\t\t\t\tvalues.push( data );\n\n\t\t\t}\n\n\t\t\treturn values;\n\n\t\t}\n\n\t\tif ( isRootObject ) {\n\n\t\t\tconst textures = extractFromCache( meta.textures );\n\t\t\tconst images = extractFromCache( meta.images );\n\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\n\t\t\tif ( images.length > 0 ) data.images = images;\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\n\t\tthis.blending = source.blending;\n\t\tthis.side = source.side;\n\t\tthis.vertexColors = source.vertexColors;\n\n\t\tthis.opacity = source.opacity;\n\t\tthis.transparent = source.transparent;\n\n\t\tthis.blendSrc = source.blendSrc;\n\t\tthis.blendDst = source.blendDst;\n\t\tthis.blendEquation = source.blendEquation;\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\n\n\t\tthis.depthFunc = source.depthFunc;\n\t\tthis.depthTest = source.depthTest;\n\t\tthis.depthWrite = source.depthWrite;\n\n\t\tthis.stencilWriteMask = source.stencilWriteMask;\n\t\tthis.stencilFunc = source.stencilFunc;\n\t\tthis.stencilRef = source.stencilRef;\n\t\tthis.stencilFuncMask = source.stencilFuncMask;\n\t\tthis.stencilFail = source.stencilFail;\n\t\tthis.stencilZFail = source.stencilZFail;\n\t\tthis.stencilZPass = source.stencilZPass;\n\t\tthis.stencilWrite = source.stencilWrite;\n\n\t\tconst srcPlanes = source.clippingPlanes;\n\t\tlet dstPlanes = null;\n\n\t\tif ( srcPlanes !== null ) {\n\n\t\t\tconst n = srcPlanes.length;\n\t\t\tdstPlanes = new Array( n );\n\n\t\t\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.clippingPlanes = dstPlanes;\n\t\tthis.clipIntersection = source.clipIntersection;\n\t\tthis.clipShadows = source.clipShadows;\n\n\t\tthis.shadowSide = source.shadowSide;\n\n\t\tthis.colorWrite = source.colorWrite;\n\n\t\tthis.precision = source.precision;\n\n\t\tthis.polygonOffset = source.polygonOffset;\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\n\n\t\tthis.dithering = source.dithering;\n\n\t\tthis.alphaTest = source.alphaTest;\n\t\tthis.alphaHash = source.alphaHash;\n\t\tthis.alphaToCoverage = source.alphaToCoverage;\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\n\t\tthis.forceSinglePass = source.forceSinglePass;\n\n\t\tthis.visible = source.visible;\n\n\t\tthis.toneMapped = source.toneMapped;\n\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n}\n\nconst _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\n\nconst _hslA = { h: 0, s: 0, l: 0 };\nconst _hslB = { h: 0, s: 0, l: 0 };\n\nfunction hue2rgb( p, q, t ) {\n\n\tif ( t < 0 ) t += 1;\n\tif ( t > 1 ) t -= 1;\n\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\tif ( t < 1 / 2 ) return q;\n\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\treturn p;\n\n}\n\nclass Color {\n\n\tconstructor( r, g, b ) {\n\n\t\tthis.isColor = true;\n\n\t\tthis.r = 1;\n\t\tthis.g = 1;\n\t\tthis.b = 1;\n\n\t\treturn this.set( r, g, b );\n\n\t}\n\n\tset( r, g, b ) {\n\n\t\tif ( g === undefined && b === undefined ) {\n\n\t\t\t// r is THREE.Color, hex or string\n\n\t\t\tconst value = r;\n\n\t\t\tif ( value && value.isColor ) {\n\n\t\t\t\tthis.copy( value );\n\n\t\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\t\tthis.setHex( value );\n\n\t\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\t\tthis.setStyle( value );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.setRGB( r, g, b );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetScalar( scalar ) {\n\n\t\tthis.r = scalar;\n\t\tthis.g = scalar;\n\t\tthis.b = scalar;\n\n\t\treturn this;\n\n\t}\n\n\tsetHex( hex, colorSpace = SRGBColorSpace ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\tColorManagement.toWorkingColorSpace( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\tsetRGB( r, g, b, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\tColorManagement.toWorkingColorSpace( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\tsetHSL( h, s, l, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\t\th = euclideanModulo( h, 1 );\n\t\ts = clamp( s, 0, 1 );\n\t\tl = clamp( l, 0, 1 );\n\n\t\tif ( s === 0 ) {\n\n\t\t\tthis.r = this.g = this.b = l;\n\n\t\t} else {\n\n\t\t\tconst p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\tconst q = ( 2 * l ) - p;\n\n\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t}\n\n\t\tColorManagement.toWorkingColorSpace( this, colorSpace );\n\n\t\treturn this;\n\n\t}\n\n\tsetStyle( style, colorSpace = SRGBColorSpace ) {\n\n\t\tfunction handleAlpha( string ) {\n\n\t\t\tif ( string === undefined ) return;\n\n\t\t\tif ( parseFloat( string ) < 1 ) {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tlet m;\n\n\t\tif ( m = /^(\\w+)\\(([^\\)]*)\\)/.exec( style ) ) {\n\n\t\t\t// rgb / hsl\n\n\t\t\tlet color;\n\t\t\tconst name = m[ 1 ];\n\t\t\tconst components = m[ 2 ];\n\n\t\t\tswitch ( name ) {\n\n\t\t\t\tcase 'rgb':\n\t\t\t\tcase 'rgba':\n\n\t\t\t\t\tif ( color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setRGB(\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 1 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 2 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tMath.min( 255, parseInt( color[ 3 ], 10 ) ) / 255,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setRGB(\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 1 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 2 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tMath.min( 100, parseInt( color[ 3 ], 10 ) ) / 100,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'hsl':\n\t\t\t\tcase 'hsla':\n\n\t\t\t\t\tif ( color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec( components ) ) {\n\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\n\t\t\t\t\t\thandleAlpha( color[ 4 ] );\n\n\t\t\t\t\t\treturn this.setHSL(\n\t\t\t\t\t\t\tparseFloat( color[ 1 ] ) / 360,\n\t\t\t\t\t\t\tparseFloat( color[ 2 ] ) / 100,\n\t\t\t\t\t\t\tparseFloat( color[ 3 ] ) / 100,\n\t\t\t\t\t\t\tcolorSpace\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color model ' + style );\n\n\t\t\t}\n\n\t\t} else if ( m = /^\\#([A-Fa-f\\d]+)$/.exec( style ) ) {\n\n\t\t\t// hex color\n\n\t\t\tconst hex = m[ 1 ];\n\t\t\tconst size = hex.length;\n\n\t\t\tif ( size === 3 ) {\n\n\t\t\t\t// #ff0\n\t\t\t\treturn this.setRGB(\n\t\t\t\t\tparseInt( hex.charAt( 0 ), 16 ) / 15,\n\t\t\t\t\tparseInt( hex.charAt( 1 ), 16 ) / 15,\n\t\t\t\t\tparseInt( hex.charAt( 2 ), 16 ) / 15,\n\t\t\t\t\tcolorSpace\n\t\t\t\t);\n\n\t\t\t} else if ( size === 6 ) {\n\n\t\t\t\t// #ff0000\n\t\t\t\treturn this.setHex( parseInt( hex, 16 ), colorSpace );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.Color: Invalid hex color ' + style );\n\n\t\t\t}\n\n\t\t} else if ( style && style.length > 0 ) {\n\n\t\t\treturn this.setColorName( style, colorSpace );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetColorName( style, colorSpace = SRGBColorSpace ) {\n\n\t\t// color keywords\n\t\tconst hex = _colorKeywords[ style.toLowerCase() ];\n\n\t\tif ( hex !== undefined ) {\n\n\t\t\t// red\n\t\t\tthis.setHex( hex, colorSpace );\n\n\t\t} else {\n\n\t\t\t// unknown color\n\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.r, this.g, this.b );\n\n\t}\n\n\tcopy( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t}\n\n\tcopySRGBToLinear( color ) {\n\n\t\tthis.r = SRGBToLinear( color.r );\n\t\tthis.g = SRGBToLinear( color.g );\n\t\tthis.b = SRGBToLinear( color.b );\n\n\t\treturn this;\n\n\t}\n\n\tcopyLinearToSRGB( color ) {\n\n\t\tthis.r = LinearToSRGB( color.r );\n\t\tthis.g = LinearToSRGB( color.g );\n\t\tthis.b = LinearToSRGB( color.b );\n\n\t\treturn this;\n\n\t}\n\n\tconvertSRGBToLinear() {\n\n\t\tthis.copySRGBToLinear( this );\n\n\t\treturn this;\n\n\t}\n\n\tconvertLinearToSRGB() {\n\n\t\tthis.copyLinearToSRGB( this );\n\n\t\treturn this;\n\n\t}\n\n\tgetHex( colorSpace = SRGBColorSpace ) {\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\treturn Math.round( clamp( _color.r * 255, 0, 255 ) ) * 65536 + Math.round( clamp( _color.g * 255, 0, 255 ) ) * 256 + Math.round( clamp( _color.b * 255, 0, 255 ) );\n\n\t}\n\n\tgetHexString( colorSpace = SRGBColorSpace ) {\n\n\t\treturn ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );\n\n\t}\n\n\tgetHSL( target, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\tconst r = _color.r, g = _color.g, b = _color.b;\n\n\t\tconst max = Math.max( r, g, b );\n\t\tconst min = Math.min( r, g, b );\n\n\t\tlet hue, saturation;\n\t\tconst lightness = ( min + max ) / 2.0;\n\n\t\tif ( min === max ) {\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tconst delta = max - min;\n\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\tswitch ( max ) {\n\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t}\n\n\t\ttarget.h = hue;\n\t\ttarget.s = saturation;\n\t\ttarget.l = lightness;\n\n\t\treturn target;\n\n\t}\n\n\tgetRGB( target, colorSpace = ColorManagement.workingColorSpace ) {\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\ttarget.r = _color.r;\n\t\ttarget.g = _color.g;\n\t\ttarget.b = _color.b;\n\n\t\treturn target;\n\n\t}\n\n\tgetStyle( colorSpace = SRGBColorSpace ) {\n\n\t\tColorManagement.fromWorkingColorSpace( _color.copy( this ), colorSpace );\n\n\t\tconst r = _color.r, g = _color.g, b = _color.b;\n\n\t\tif ( colorSpace !== SRGBColorSpace ) {\n\n\t\t\t// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).\n\t\t\treturn `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`;\n\n\t\t}\n\n\t\treturn `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`;\n\n\t}\n\n\toffsetHSL( h, s, l ) {\n\n\t\tthis.getHSL( _hslA );\n\n\t\t_hslA.h += h; _hslA.s += s; _hslA.l += l;\n\n\t\tthis.setHSL( _hslA.h, _hslA.s, _hslA.l );\n\n\t\treturn this;\n\n\t}\n\n\tadd( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t}\n\n\taddColors( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t}\n\n\taddScalar( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t}\n\n\tsub( color ) {\n\n\t\tthis.r = Math.max( 0, this.r - color.r );\n\t\tthis.g = Math.max( 0, this.g - color.g );\n\t\tthis.b = Math.max( 0, this.b - color.b );\n\n\t\treturn this;\n\n\t}\n\n\tmultiply( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t}\n\n\tmultiplyScalar( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t}\n\n\tlerp( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpColors( color1, color2, alpha ) {\n\n\t\tthis.r = color1.r + ( color2.r - color1.r ) * alpha;\n\t\tthis.g = color1.g + ( color2.g - color1.g ) * alpha;\n\t\tthis.b = color1.b + ( color2.b - color1.b ) * alpha;\n\n\t\treturn this;\n\n\t}\n\n\tlerpHSL( color, alpha ) {\n\n\t\tthis.getHSL( _hslA );\n\t\tcolor.getHSL( _hslB );\n\n\t\tconst h = lerp( _hslA.h, _hslB.h, alpha );\n\t\tconst s = lerp( _hslA.s, _hslB.s, alpha );\n\t\tconst l = lerp( _hslA.l, _hslB.l, alpha );\n\n\t\tthis.setHSL( h, s, l );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\tthis.r = v.x;\n\t\tthis.g = v.y;\n\t\tthis.b = v.z;\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tconst r = this.r, g = this.g, b = this.b;\n\t\tconst e = m.elements;\n\n\t\tthis.r = e[ 0 ] * r + e[ 3 ] * g + e[ 6 ] * b;\n\t\tthis.g = e[ 1 ] * r + e[ 4 ] * g + e[ 7 ] * b;\n\t\tthis.b = e[ 2 ] * r + e[ 5 ] * g + e[ 8 ] * b;\n\n\t\treturn this;\n\n\t}\n\n\tequals( c ) {\n\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tthis.r = array[ offset ];\n\t\tthis.g = array[ offset + 1 ];\n\t\tthis.b = array[ offset + 2 ];\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tarray[ offset ] = this.r;\n\t\tarray[ offset + 1 ] = this.g;\n\t\tarray[ offset + 2 ] = this.b;\n\n\t\treturn array;\n\n\t}\n\n\tfromBufferAttribute( attribute, index ) {\n\n\t\tthis.r = attribute.getX( index );\n\t\tthis.g = attribute.getY( index );\n\t\tthis.b = attribute.getZ( index );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.getHex();\n\n\t}\n\n\t*[ Symbol.iterator ]() {\n\n\t\tyield this.r;\n\t\tyield this.g;\n\t\tyield this.b;\n\n\t}\n\n}\n\nconst _color = /*@__PURE__*/ new Color();\n\nColor.NAMES = _colorKeywords;\n\nclass MeshBasicMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshBasicMaterial = true;\n\n\t\tthis.type = 'MeshBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // emissive\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\n// Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nconst _tables = /*@__PURE__*/ _generateTables();\n\nfunction _generateTables() {\n\n\t// float32 to float16 helpers\n\n\tconst buffer = new ArrayBuffer( 4 );\n\tconst floatView = new Float32Array( buffer );\n\tconst uint32View = new Uint32Array( buffer );\n\n\tconst baseTable = new Uint32Array( 512 );\n\tconst shiftTable = new Uint32Array( 512 );\n\n\tfor ( let i = 0; i < 256; ++ i ) {\n\n\t\tconst e = i - 127;\n\n\t\t// very small number (0, -0)\n\n\t\tif ( e < - 27 ) {\n\n\t\t\tbaseTable[ i ] = 0x0000;\n\t\t\tbaseTable[ i | 0x100 ] = 0x8000;\n\t\t\tshiftTable[ i ] = 24;\n\t\t\tshiftTable[ i | 0x100 ] = 24;\n\n\t\t\t// small number (denorm)\n\n\t\t} else if ( e < - 14 ) {\n\n\t\t\tbaseTable[ i ] = 0x0400 >> ( - e - 14 );\n\t\t\tbaseTable[ i | 0x100 ] = ( 0x0400 >> ( - e - 14 ) ) | 0x8000;\n\t\t\tshiftTable[ i ] = - e - 1;\n\t\t\tshiftTable[ i | 0x100 ] = - e - 1;\n\n\t\t\t// normal number\n\n\t\t} else if ( e <= 15 ) {\n\n\t\t\tbaseTable[ i ] = ( e + 15 ) << 10;\n\t\t\tbaseTable[ i | 0x100 ] = ( ( e + 15 ) << 10 ) | 0x8000;\n\t\t\tshiftTable[ i ] = 13;\n\t\t\tshiftTable[ i | 0x100 ] = 13;\n\n\t\t\t// large number (Infinity, -Infinity)\n\n\t\t} else if ( e < 128 ) {\n\n\t\t\tbaseTable[ i ] = 0x7c00;\n\t\t\tbaseTable[ i | 0x100 ] = 0xfc00;\n\t\t\tshiftTable[ i ] = 24;\n\t\t\tshiftTable[ i | 0x100 ] = 24;\n\n\t\t\t// stay (NaN, Infinity, -Infinity)\n\n\t\t} else {\n\n\t\t\tbaseTable[ i ] = 0x7c00;\n\t\t\tbaseTable[ i | 0x100 ] = 0xfc00;\n\t\t\tshiftTable[ i ] = 13;\n\t\t\tshiftTable[ i | 0x100 ] = 13;\n\n\t\t}\n\n\t}\n\n\t// float16 to float32 helpers\n\n\tconst mantissaTable = new Uint32Array( 2048 );\n\tconst exponentTable = new Uint32Array( 64 );\n\tconst offsetTable = new Uint32Array( 64 );\n\n\tfor ( let i = 1; i < 1024; ++ i ) {\n\n\t\tlet m = i << 13; // zero pad mantissa bits\n\t\tlet e = 0; // zero exponent\n\n\t\t// normalized\n\t\twhile ( ( m & 0x00800000 ) === 0 ) {\n\n\t\t\tm <<= 1;\n\t\t\te -= 0x00800000; // decrement exponent\n\n\t\t}\n\n\t\tm &= ~ 0x00800000; // clear leading 1 bit\n\t\te += 0x38800000; // adjust bias\n\n\t\tmantissaTable[ i ] = m | e;\n\n\t}\n\n\tfor ( let i = 1024; i < 2048; ++ i ) {\n\n\t\tmantissaTable[ i ] = 0x38000000 + ( ( i - 1024 ) << 13 );\n\n\t}\n\n\tfor ( let i = 1; i < 31; ++ i ) {\n\n\t\texponentTable[ i ] = i << 23;\n\n\t}\n\n\texponentTable[ 31 ] = 0x47800000;\n\texponentTable[ 32 ] = 0x80000000;\n\n\tfor ( let i = 33; i < 63; ++ i ) {\n\n\t\texponentTable[ i ] = 0x80000000 + ( ( i - 32 ) << 23 );\n\n\t}\n\n\texponentTable[ 63 ] = 0xc7800000;\n\n\tfor ( let i = 1; i < 64; ++ i ) {\n\n\t\tif ( i !== 32 ) {\n\n\t\t\toffsetTable[ i ] = 1024;\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tfloatView: floatView,\n\t\tuint32View: uint32View,\n\t\tbaseTable: baseTable,\n\t\tshiftTable: shiftTable,\n\t\tmantissaTable: mantissaTable,\n\t\texponentTable: exponentTable,\n\t\toffsetTable: offsetTable\n\t};\n\n}\n\n// float32 to float16\n\nfunction toHalfFloat( val ) {\n\n\tif ( Math.abs( val ) > 65504 ) console.warn( 'THREE.DataUtils.toHalfFloat(): Value out of range.' );\n\n\tval = clamp( val, - 65504, 65504 );\n\n\t_tables.floatView[ 0 ] = val;\n\tconst f = _tables.uint32View[ 0 ];\n\tconst e = ( f >> 23 ) & 0x1ff;\n\treturn _tables.baseTable[ e ] + ( ( f & 0x007fffff ) >> _tables.shiftTable[ e ] );\n\n}\n\n// float16 to float32\n\nfunction fromHalfFloat( val ) {\n\n\tconst m = val >> 10;\n\t_tables.uint32View[ 0 ] = _tables.mantissaTable[ _tables.offsetTable[ m ] + ( val & 0x3ff ) ] + _tables.exponentTable[ m ];\n\treturn _tables.floatView[ 0 ];\n\n}\n\nconst DataUtils = {\n\ttoHalfFloat: toHalfFloat,\n\tfromHalfFloat: fromHalfFloat,\n};\n\nconst _vector$8 = /*@__PURE__*/ new Vector3();\nconst _vector2$1 = /*@__PURE__*/ new Vector2();\n\nclass BufferAttribute {\n\n\tconstructor( array, itemSize, normalized = false ) {\n\n\t\tif ( Array.isArray( array ) ) {\n\n\t\t\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\n\n\t\t}\n\n\t\tthis.isBufferAttribute = true;\n\n\t\tthis.name = '';\n\n\t\tthis.array = array;\n\t\tthis.itemSize = itemSize;\n\t\tthis.count = array !== undefined ? array.length / itemSize : 0;\n\t\tthis.normalized = normalized;\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\t\tthis.gpuType = FloatType;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tonUploadCallback() {}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.itemSize = source.itemSize;\n\t\tthis.count = source.count;\n\t\tthis.normalized = source.normalized;\n\n\t\tthis.usage = source.usage;\n\t\tthis.gpuType = source.gpuType;\n\n\t\treturn this;\n\n\t}\n\n\tcopyAt( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.itemSize;\n\t\tindex2 *= attribute.itemSize;\n\n\t\tfor ( let i = 0, l = this.itemSize; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcopyArray( array ) {\n\n\t\tthis.array.set( array );\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix3( m ) {\n\n\t\tif ( this.itemSize === 2 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector2$1.fromBufferAttribute( this, i );\n\t\t\t\t_vector2$1.applyMatrix3( m );\n\n\t\t\t\tthis.setXY( i, _vector2$1.x, _vector2$1.y );\n\n\t\t\t}\n\n\t\t} else if ( this.itemSize === 3 ) {\n\n\t\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t\t_vector$8.fromBufferAttribute( this, i );\n\t\t\t\t_vector$8.applyMatrix3( m );\n\n\t\t\t\tthis.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$8.fromBufferAttribute( this, i );\n\n\t\t\t_vector$8.applyMatrix4( m );\n\n\t\t\tthis.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$8.fromBufferAttribute( this, i );\n\n\t\t\t_vector$8.applyNormalMatrix( m );\n\n\t\t\tthis.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$8.fromBufferAttribute( this, i );\n\n\t\t\t_vector$8.transformDirection( m );\n\n\t\t\tthis.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tset( value, offset = 0 ) {\n\n\t\t// Matching BufferAttribute constructor, do not normalize the array.\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = this.array[ index * this.itemSize ];\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.array[ index * this.itemSize ] = x;\n\n\t\treturn this;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = this.array[ index * this.itemSize + 1 ];\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = this.array[ index * this.itemSize + 2 ];\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = this.array[ index * this.itemSize + 3 ];\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = x;\n\t\tthis.array[ index + 1 ] = y;\n\t\tthis.array[ index + 2 ] = z;\n\t\tthis.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tonUpload( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.array, this.itemSize ).copy( this );\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\titemSize: this.itemSize,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tarray: Array.from( this.array ),\n\t\t\tnormalized: this.normalized\n\t\t};\n\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( this.usage !== StaticDrawUsage ) data.usage = this.usage;\n\t\tif ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;\n\n\t\treturn data;\n\n\t}\n\n}\n\n//\n\nclass Int8BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int8Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint8BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint8Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint8ClampedBufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint8ClampedArray( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Int16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int16Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint16Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Int32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Int32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Uint32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Float16BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Uint16Array( array ), itemSize, normalized );\n\n\t\tthis.isFloat16BufferAttribute = true;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = fromHalfFloat( this.array[ index * this.itemSize ] );\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.array[ index * this.itemSize ] = toHalfFloat( x );\n\n\t\treturn this;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = fromHalfFloat( this.array[ index * this.itemSize + 1 ] );\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.array[ index * this.itemSize + 1 ] = toHalfFloat( y );\n\n\t\treturn this;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = fromHalfFloat( this.array[ index * this.itemSize + 2 ] );\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.array[ index * this.itemSize + 2 ] = toHalfFloat( z );\n\n\t\treturn this;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = fromHalfFloat( this.array[ index * this.itemSize + 3 ] );\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.array[ index * this.itemSize + 3 ] = toHalfFloat( w );\n\n\t\treturn this;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\t\tthis.array[ index + 2 ] = toHalfFloat( z );\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex *= this.itemSize;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.array[ index + 0 ] = toHalfFloat( x );\n\t\tthis.array[ index + 1 ] = toHalfFloat( y );\n\t\tthis.array[ index + 2 ] = toHalfFloat( z );\n\t\tthis.array[ index + 3 ] = toHalfFloat( w );\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nclass Float32BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Float32Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nclass Float64BufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized ) {\n\n\t\tsuper( new Float64Array( array ), itemSize, normalized );\n\n\t}\n\n}\n\nlet _id$1 = 0;\n\nconst _m1 = /*@__PURE__*/ new Matrix4();\nconst _obj = /*@__PURE__*/ new Object3D();\nconst _offset = /*@__PURE__*/ new Vector3();\nconst _box$1 = /*@__PURE__*/ new Box3();\nconst _boxMorphTargets = /*@__PURE__*/ new Box3();\nconst _vector$7 = /*@__PURE__*/ new Vector3();\n\nclass BufferGeometry extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isBufferGeometry = true;\n\n\t\tObject.defineProperty( this, 'id', { value: _id$1 ++ } );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\n\t\tthis.morphAttributes = {};\n\t\tthis.morphTargetsRelative = false;\n\n\t\tthis.groups = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\tthis.userData = {};\n\n\t}\n\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tconst position = [];\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst point = points[ i ];\n\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t}\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box$1.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector$7.addVectors( this.boundingBox.min, _box$1.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector$7 );\n\n\t\t\t\t\t\t_vector$7.addVectors( this.boundingBox.max, _box$1.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector$7 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box$1.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box$1.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box$1.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector$7.addVectors( _box$1.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box$1.expandByPoint( _vector$7 );\n\n\t\t\t\t\t\t_vector$7.addVectors( _box$1.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box$1.expandByPoint( _vector$7 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box$1.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box$1.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box$1.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector$7.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$7 ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector$7.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector$7.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$7 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst indices = index.array;\n\t\tconst positions = attributes.position.array;\n\t\tconst normals = attributes.normal.array;\n\t\tconst uvs = attributes.uv.array;\n\n\t\tconst nVertices = positions.length / 3;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );\n\n\t\t}\n\n\t\tconst tangents = this.getAttribute( 'tangent' ).array;\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < nVertices; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: indices.length\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindices[ j + 0 ],\n\t\t\t\t\tindices[ j + 1 ],\n\t\t\t\t\tindices[ j + 2 ]\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromArray( normals, v * 3 );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangents[ v * 4 ] = tmp.x;\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\n\t\t\ttangents[ v * 4 + 3 ] = w;\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( indices[ j + 0 ] );\n\t\t\t\thandleVertex( indices[ j + 1 ] );\n\t\t\t\thandleVertex( indices[ j + 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tnormalizeNormals() {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector$7.fromBufferAttribute( normals, i );\n\n\t\t\t_vector$7.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector$7.x, _vector$7.y, _vector$7.z );\n\n\t\t}\n\n\t}\n\n\ttoNonIndexed() {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// used for storing cloned, shared data\n\n\t\tconst data = {};\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tconst index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone( data ) );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst attributes = source.attributes;\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone( data ) );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = source.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone( data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = source.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nconst _inverseMatrix$3 = /*@__PURE__*/ new Matrix4();\nconst _ray$3 = /*@__PURE__*/ new Ray();\nconst _sphere$5 = /*@__PURE__*/ new Sphere();\nconst _sphereHitAt = /*@__PURE__*/ new Vector3();\n\nconst _vA$1 = /*@__PURE__*/ new Vector3();\nconst _vB$1 = /*@__PURE__*/ new Vector3();\nconst _vC$1 = /*@__PURE__*/ new Vector3();\n\nconst _tempA = /*@__PURE__*/ new Vector3();\nconst _morphA = /*@__PURE__*/ new Vector3();\n\nconst _uvA$1 = /*@__PURE__*/ new Vector2();\nconst _uvB$1 = /*@__PURE__*/ new Vector2();\nconst _uvC$1 = /*@__PURE__*/ new Vector2();\n\nconst _normalA = /*@__PURE__*/ new Vector3();\nconst _normalB = /*@__PURE__*/ new Vector3();\nconst _normalC = /*@__PURE__*/ new Vector3();\n\nconst _intersectionPoint = /*@__PURE__*/ new Vector3();\nconst _intersectionPointWorld = /*@__PURE__*/ new Vector3();\n\nclass Mesh extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isMesh = true;\n\n\t\tthis.type = 'Mesh';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.morphTargetInfluences !== undefined ) {\n\n\t\t\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\n\n\t\t}\n\n\t\tif ( source.morphTargetDictionary !== undefined ) {\n\n\t\t\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\n\n\t\t}\n\n\t\tthis.material = source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgetVertexPosition( index, target ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst position = geometry.attributes.position;\n\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\n\t\ttarget.fromBufferAttribute( position, index );\n\n\t\tconst morphInfluences = this.morphTargetInfluences;\n\n\t\tif ( morphPosition && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphPosition.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morphAttribute = morphPosition[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morphAttribute, index );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( target ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttarget.add( _morphA );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\tif ( material === undefined ) return;\n\n\t\t// test with bounding sphere in world space\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere$5.copy( geometry.boundingSphere );\n\t\t_sphere$5.applyMatrix4( matrixWorld );\n\n\t\t// check distance from ray origin to bounding sphere\n\n\t\t_ray$3.copy( raycaster.ray ).recast( raycaster.near );\n\n\t\tif ( _sphere$5.containsPoint( _ray$3.origin ) === false ) {\n\n\t\t\tif ( _ray$3.intersectSphere( _sphere$5, _sphereHitAt ) === null ) return;\n\n\t\t\tif ( _ray$3.origin.distanceToSquared( _sphereHitAt ) > ( raycaster.far - raycaster.near ) ** 2 ) return;\n\n\t\t}\n\n\t\t// convert ray to local space of mesh\n\n\t\t_inverseMatrix$3.copy( matrixWorld ).invert();\n\t\t_ray$3.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$3 );\n\n\t\t// test with bounding box in local space\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tif ( _ray$3.intersectsBox( geometry.boundingBox ) === false ) return;\n\n\t\t}\n\n\t\t// test for intersections with geometry\n\n\t\tthis._computeIntersections( raycaster, intersects, _ray$3 );\n\n\t}\n\n\t_computeIntersections( raycaster, intersects, rayLocalSpace ) {\n\n\t\tlet intersection;\n\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\tconst index = geometry.index;\n\t\tconst position = geometry.attributes.position;\n\t\tconst uv = geometry.attributes.uv;\n\t\tconst uv1 = geometry.attributes.uv1;\n\t\tconst normal = geometry.attributes.normal;\n\t\tconst groups = geometry.groups;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\tif ( index !== null ) {\n\n\t\t\t// indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\tconst end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );\n\n\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\tconst a = index.getX( j );\n\t\t\t\t\t\tconst b = index.getX( j + 1 );\n\t\t\t\t\t\tconst c = index.getX( j + 2 );\n\n\t\t\t\t\t\tintersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\tconst a = index.getX( i );\n\t\t\t\t\tconst b = index.getX( i + 1 );\n\t\t\t\t\tconst c = index.getX( i + 2 );\n\n\t\t\t\t\tintersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( position !== undefined ) {\n\n\t\t\t// non-indexed buffer geometry\n\n\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\tconst start = Math.max( group.start, drawRange.start );\n\t\t\t\t\tconst end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );\n\n\t\t\t\t\tfor ( let j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\t\tconst a = j;\n\t\t\t\t\t\tconst b = j + 1;\n\t\t\t\t\t\tconst c = j + 2;\n\n\t\t\t\t\t\tintersection = checkGeometryIntersection( this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\t\tintersection.face.materialIndex = group.materialIndex;\n\t\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\t\tconst end = Math.min( position.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( let i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\t\tconst a = i;\n\t\t\t\t\tconst b = i + 1;\n\t\t\t\t\tconst c = i + 2;\n\n\t\t\t\t\tintersection = checkGeometryIntersection( this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c );\n\n\t\t\t\t\tif ( intersection ) {\n\n\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics\n\t\t\t\t\t\tintersects.push( intersection );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\n\n\tlet intersect;\n\n\tif ( material.side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, ( material.side === FrontSide ), point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\t_intersectionPointWorld.copy( point );\n\t_intersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n\tconst distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );\n\n\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n\treturn {\n\t\tdistance: distance,\n\t\tpoint: _intersectionPointWorld.clone(),\n\t\tobject: object\n\t};\n\n}\n\nfunction checkGeometryIntersection( object, material, raycaster, ray, uv, uv1, normal, a, b, c ) {\n\n\tobject.getVertexPosition( a, _vA$1 );\n\tobject.getVertexPosition( b, _vB$1 );\n\tobject.getVertexPosition( c, _vC$1 );\n\n\tconst intersection = checkIntersection( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA$1.fromBufferAttribute( uv, a );\n\t\t\t_uvB$1.fromBufferAttribute( uv, b );\n\t\t\t_uvC$1.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\t_uvA$1.fromBufferAttribute( uv1, a );\n\t\t\t_uvB$1.fromBufferAttribute( uv1, b );\n\t\t\t_uvC$1.fromBufferAttribute( uv1, c );\n\n\t\t\tintersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );\n\t\t\tintersection.uv2 = intersection.uv1; // @deprecated, r152\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\tintersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector3() );\n\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );\n\n\t\tintersection.face = face;\n\n\t}\n\n\treturn intersection;\n\n}\n\nclass BoxGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'BoxGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tconst scope = this;\n\n\t\t// segments\n\n\t\twidthSegments = Math.floor( widthSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\t\tdepthSegments = Math.floor( depthSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet numberOfVertices = 0;\n\t\tlet groupStart = 0;\n\n\t\t// build each side of the box geometry\n\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\t\tconst segmentWidth = width / gridX;\n\t\t\tconst segmentHeight = height / gridY;\n\n\t\t\tconst widthHalf = width / 2;\n\t\t\tconst heightHalf = height / 2;\n\t\t\tconst depthHalf = depth / 2;\n\n\t\t\tconst gridX1 = gridX + 1;\n\t\t\tconst gridY1 = gridY + 1;\n\n\t\t\tlet vertexCounter = 0;\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst vector = new Vector3();\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\t\tconst y = iy * segmentHeight - heightHalf;\n\n\t\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\t\tconst x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t\t// now apply vector to vertex buffer\n\n\t\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t\t// now apply vector to normal buffer\n\n\t\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t\t\t// counters\n\n\t\t\t\t\tvertexCounter += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t\tconst a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tconst b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// increase counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t\t// update total number of vertices\n\n\t\t\tnumberOfVertices += vertexCounter;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );\n\n\t}\n\n}\n\n/**\n * Uniform Utilities\n */\n\nfunction cloneUniforms( src ) {\n\n\tconst dst = {};\n\n\tfor ( const u in src ) {\n\n\t\tdst[ u ] = {};\n\n\t\tfor ( const p in src[ u ] ) {\n\n\t\t\tconst property = src[ u ][ p ];\n\n\t\t\tif ( property && ( property.isColor ||\n\t\t\t\tproperty.isMatrix3 || property.isMatrix4 ||\n\t\t\t\tproperty.isVector2 || property.isVector3 || property.isVector4 ||\n\t\t\t\tproperty.isTexture || property.isQuaternion ) ) {\n\n\t\t\t\tif ( property.isRenderTargetTexture ) {\n\n\t\t\t\t\tconsole.warn( 'UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().' );\n\t\t\t\t\tdst[ u ][ p ] = null;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdst[ u ][ p ] = property.clone();\n\n\t\t\t\t}\n\n\t\t\t} else if ( Array.isArray( property ) ) {\n\n\t\t\t\tdst[ u ][ p ] = property.slice();\n\n\t\t\t} else {\n\n\t\t\t\tdst[ u ][ p ] = property;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn dst;\n\n}\n\nfunction mergeUniforms( uniforms ) {\n\n\tconst merged = {};\n\n\tfor ( let u = 0; u < uniforms.length; u ++ ) {\n\n\t\tconst tmp = cloneUniforms( uniforms[ u ] );\n\n\t\tfor ( const p in tmp ) {\n\n\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t}\n\n\t}\n\n\treturn merged;\n\n}\n\nfunction cloneUniformsGroups( src ) {\n\n\tconst dst = [];\n\n\tfor ( let u = 0; u < src.length; u ++ ) {\n\n\t\tdst.push( src[ u ].clone() );\n\n\t}\n\n\treturn dst;\n\n}\n\nfunction getUnlitUniformColorSpace( renderer ) {\n\n\tif ( renderer.getRenderTarget() === null ) {\n\n\t\t// https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398\n\t\treturn renderer.outputColorSpace;\n\n\t}\n\n\treturn LinearSRGBColorSpace;\n\n}\n\n// Legacy\n\nconst UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };\n\nvar default_vertex = \"void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";\n\nvar default_fragment = \"void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\";\n\nclass ShaderMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isShaderMaterial = true;\n\n\t\tthis.type = 'ShaderMaterial';\n\n\t\tthis.defines = {};\n\t\tthis.uniforms = {};\n\t\tthis.uniformsGroups = [];\n\n\t\tthis.vertexShader = default_vertex;\n\t\tthis.fragmentShader = default_fragment;\n\n\t\tthis.linewidth = 1;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.fog = false; // set to use scene fog\n\t\tthis.lights = false; // set to use scene lights\n\t\tthis.clipping = false; // set to use user-defined clipping planes\n\n\t\tthis.forceSinglePass = true;\n\n\t\tthis.extensions = {\n\t\t\tderivatives: false, // set to use derivatives\n\t\t\tfragDepth: false, // set to use fragment depth values\n\t\t\tdrawBuffers: false, // set to use draw buffers\n\t\t\tshaderTextureLOD: false // set to use shader texture LOD\n\t\t};\n\n\t\t// When rendered geometry doesn't include these attributes but the material does,\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\t\tthis.defaultAttributeValues = {\n\t\t\t'color': [ 1, 1, 1 ],\n\t\t\t'uv': [ 0, 0 ],\n\t\t\t'uv1': [ 0, 0 ]\n\t\t};\n\n\t\tthis.index0AttributeName = undefined;\n\t\tthis.uniformsNeedUpdate = false;\n\n\t\tthis.glslVersion = null;\n\n\t\tif ( parameters !== undefined ) {\n\n\t\t\tthis.setValues( parameters );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.fragmentShader = source.fragmentShader;\n\t\tthis.vertexShader = source.vertexShader;\n\n\t\tthis.uniforms = cloneUniforms( source.uniforms );\n\t\tthis.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );\n\n\t\tthis.defines = Object.assign( {}, source.defines );\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.fog = source.fog;\n\t\tthis.lights = source.lights;\n\t\tthis.clipping = source.clipping;\n\n\t\tthis.extensions = Object.assign( {}, source.extensions );\n\n\t\tthis.glslVersion = source.glslVersion;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.glslVersion = this.glslVersion;\n\t\tdata.uniforms = {};\n\n\t\tfor ( const name in this.uniforms ) {\n\n\t\t\tconst uniform = this.uniforms[ name ];\n\t\t\tconst value = uniform.value;\n\n\t\t\tif ( value && value.isTexture ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 't',\n\t\t\t\t\tvalue: value.toJSON( meta ).uuid\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isColor ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'c',\n\t\t\t\t\tvalue: value.getHex()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector2 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v2',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector3 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v3',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isVector4 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'v4',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isMatrix3 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'm3',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else if ( value && value.isMatrix4 ) {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\ttype: 'm4',\n\t\t\t\t\tvalue: value.toArray()\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tdata.uniforms[ name ] = {\n\t\t\t\t\tvalue: value\n\t\t\t\t};\n\n\t\t\t\t// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;\n\n\t\tdata.vertexShader = this.vertexShader;\n\t\tdata.fragmentShader = this.fragmentShader;\n\n\t\tdata.lights = this.lights;\n\t\tdata.clipping = this.clipping;\n\n\t\tconst extensions = {};\n\n\t\tfor ( const key in this.extensions ) {\n\n\t\t\tif ( this.extensions[ key ] === true ) extensions[ key ] = true;\n\n\t\t}\n\n\t\tif ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass Camera extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isCamera = true;\n\n\t\tthis.type = 'Camera';\n\n\t\tthis.matrixWorldInverse = new Matrix4();\n\n\t\tthis.projectionMatrix = new Matrix4();\n\t\tthis.projectionMatrixInverse = new Matrix4();\n\n\t\tthis.coordinateSystem = WebGLCoordinateSystem;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\t\tthis.projectionMatrixInverse.copy( source.projectionMatrixInverse );\n\n\t\tthis.coordinateSystem = source.coordinateSystem;\n\n\t\treturn this;\n\n\t}\n\n\tgetWorldDirection( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tconst e = this.matrixWorld.elements;\n\n\t\treturn target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tsuper.updateWorldMatrix( updateParents, updateChildren );\n\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nclass PerspectiveCamera extends Camera {\n\n\tconstructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {\n\n\t\tsuper();\n\n\t\tthis.isPerspectiveCamera = true;\n\n\t\tthis.type = 'PerspectiveCamera';\n\n\t\tthis.fov = fov;\n\t\tthis.zoom = 1;\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\t\tthis.focus = 10;\n\n\t\tthis.aspect = aspect;\n\t\tthis.view = null;\n\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength( focalLength ) {\n\n\t\t/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n\t\tconst vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t */\n\tgetFocalLength() {\n\n\t\tconst vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t}\n\n\tgetEffectiveFOV() {\n\n\t\treturn RAD2DEG * 2 * Math.atan(\n\t\t\tMath.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t}\n\n\tgetFilmWidth() {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t}\n\n\tgetFilmHeight() {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t}\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   const w = 1920;\n\t *   const h = 1080;\n\t *   const fullWidth = w * 3;\n\t *   const fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t */\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tclearViewOffset() {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tupdateProjectionMatrix() {\n\n\t\tconst near = this.near;\n\t\tlet top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;\n\t\tlet height = 2 * top;\n\t\tlet width = this.aspect * height;\n\t\tlet left = - 0.5 * width;\n\t\tconst view = this.view;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tconst skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far, this.coordinateSystem );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst fov = - 90; // negative fov is not an error\nconst aspect = 1;\n\nclass CubeCamera extends Object3D {\n\n\tconstructor( near, far, renderTarget ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CubeCamera';\n\n\t\tthis.renderTarget = renderTarget;\n\t\tthis.coordinateSystem = null;\n\n\t\tconst cameraPX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPX.layers = this.layers;\n\t\tthis.add( cameraPX );\n\n\t\tconst cameraNX = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNX.layers = this.layers;\n\t\tthis.add( cameraNX );\n\n\t\tconst cameraPY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPY.layers = this.layers;\n\t\tthis.add( cameraPY );\n\n\t\tconst cameraNY = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNY.layers = this.layers;\n\t\tthis.add( cameraNY );\n\n\t\tconst cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraPZ.layers = this.layers;\n\t\tthis.add( cameraPZ );\n\n\t\tconst cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\n\t\tcameraNZ.layers = this.layers;\n\t\tthis.add( cameraNZ );\n\n\t}\n\n\tupdateCoordinateSystem() {\n\n\t\tconst coordinateSystem = this.coordinateSystem;\n\n\t\tconst cameras = this.children.concat();\n\n\t\tconst [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = cameras;\n\n\t\tfor ( const camera of cameras ) this.remove( camera );\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tcameraPX.up.set( 0, 1, 0 );\n\t\t\tcameraPX.lookAt( 1, 0, 0 );\n\n\t\t\tcameraNX.up.set( 0, 1, 0 );\n\t\t\tcameraNX.lookAt( - 1, 0, 0 );\n\n\t\t\tcameraPY.up.set( 0, 0, - 1 );\n\t\t\tcameraPY.lookAt( 0, 1, 0 );\n\n\t\t\tcameraNY.up.set( 0, 0, 1 );\n\t\t\tcameraNY.lookAt( 0, - 1, 0 );\n\n\t\t\tcameraPZ.up.set( 0, 1, 0 );\n\t\t\tcameraPZ.lookAt( 0, 0, 1 );\n\n\t\t\tcameraNZ.up.set( 0, 1, 0 );\n\t\t\tcameraNZ.lookAt( 0, 0, - 1 );\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tcameraPX.up.set( 0, - 1, 0 );\n\t\t\tcameraPX.lookAt( - 1, 0, 0 );\n\n\t\t\tcameraNX.up.set( 0, - 1, 0 );\n\t\t\tcameraNX.lookAt( 1, 0, 0 );\n\n\t\t\tcameraPY.up.set( 0, 0, 1 );\n\t\t\tcameraPY.lookAt( 0, 1, 0 );\n\n\t\t\tcameraNY.up.set( 0, 0, - 1 );\n\t\t\tcameraNY.lookAt( 0, - 1, 0 );\n\n\t\t\tcameraPZ.up.set( 0, - 1, 0 );\n\t\t\tcameraPZ.lookAt( 0, 0, 1 );\n\n\t\t\tcameraNZ.up.set( 0, - 1, 0 );\n\t\t\tcameraNZ.lookAt( 0, 0, - 1 );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\tfor ( const camera of cameras ) {\n\n\t\t\tthis.add( camera );\n\n\t\t\tcamera.updateMatrixWorld();\n\n\t\t}\n\n\t}\n\n\tupdate( renderer, scene ) {\n\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\n\n\t\tconst renderTarget = this.renderTarget;\n\n\t\tif ( this.coordinateSystem !== renderer.coordinateSystem ) {\n\n\t\t\tthis.coordinateSystem = renderer.coordinateSystem;\n\n\t\t\tthis.updateCoordinateSystem();\n\n\t\t}\n\n\t\tconst [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\tconst currentToneMapping = renderer.toneMapping;\n\t\tconst currentXrEnabled = renderer.xr.enabled;\n\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.xr.enabled = false;\n\n\t\tconst generateMipmaps = renderTarget.texture.generateMipmaps;\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\trenderer.setRenderTarget( renderTarget, 0 );\n\t\trenderer.render( scene, cameraPX );\n\n\t\trenderer.setRenderTarget( renderTarget, 1 );\n\t\trenderer.render( scene, cameraNX );\n\n\t\trenderer.setRenderTarget( renderTarget, 2 );\n\t\trenderer.render( scene, cameraPY );\n\n\t\trenderer.setRenderTarget( renderTarget, 3 );\n\t\trenderer.render( scene, cameraNY );\n\n\t\trenderer.setRenderTarget( renderTarget, 4 );\n\t\trenderer.render( scene, cameraPZ );\n\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\n\n\t\trenderer.setRenderTarget( renderTarget, 5 );\n\t\trenderer.render( scene, cameraNZ );\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\trenderer.toneMapping = currentToneMapping;\n\t\trenderer.xr.enabled = currentXrEnabled;\n\n\t\trenderTarget.texture.needsPMREMUpdate = true;\n\n\t}\n\n}\n\nclass CubeTexture extends Texture {\n\n\tconstructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace ) {\n\n\t\timages = images !== undefined ? images : [];\n\t\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\n\n\t\tsuper( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\tthis.isCubeTexture = true;\n\n\t\tthis.flipY = false;\n\n\t}\n\n\tget images() {\n\n\t\treturn this.image;\n\n\t}\n\n\tset images( value ) {\n\n\t\tthis.image = value;\n\n\t}\n\n}\n\nclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n\n\tconstructor( size = 1, options = {} ) {\n\n\t\tsuper( size, size, options );\n\n\t\tthis.isWebGLCubeRenderTarget = true;\n\n\t\tconst image = { width: size, height: size, depth: 1 };\n\t\tconst images = [ image, image, image, image, image, image ];\n\n\t\tif ( options.encoding !== undefined ) {\n\n\t\t\t// @deprecated, r152\n\t\t\twarnOnce( 'THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace.' );\n\t\t\toptions.colorSpace = options.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;\n\n\t\t}\n\n\t\tthis.texture = new CubeTexture( images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace );\n\n\t\t// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\n\t\t// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n\t\t// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n\n\t\t// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n\t\t// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture\n\t\t// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).\n\n\t\tthis.texture.isRenderTargetTexture = true;\n\n\t\tthis.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n\t\tthis.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;\n\n\t}\n\n\tfromEquirectangularTexture( renderer, texture ) {\n\n\t\tthis.texture.type = texture.type;\n\t\tthis.texture.colorSpace = texture.colorSpace;\n\n\t\tthis.texture.generateMipmaps = texture.generateMipmaps;\n\t\tthis.texture.minFilter = texture.minFilter;\n\t\tthis.texture.magFilter = texture.magFilter;\n\n\t\tconst shader = {\n\n\t\t\tuniforms: {\n\t\t\t\ttEquirect: { value: null },\n\t\t\t},\n\n\t\t\tvertexShader: /* glsl */`\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n\t\t};\n\n\t\tconst geometry = new BoxGeometry( 5, 5, 5 );\n\n\t\tconst material = new ShaderMaterial( {\n\n\t\t\tname: 'CubemapFromEquirect',\n\n\t\t\tuniforms: cloneUniforms( shader.uniforms ),\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tside: BackSide,\n\t\t\tblending: NoBlending\n\n\t\t} );\n\n\t\tmaterial.uniforms.tEquirect.value = texture;\n\n\t\tconst mesh = new Mesh( geometry, material );\n\n\t\tconst currentMinFilter = texture.minFilter;\n\n\t\t// Avoid blurred poles\n\t\tif ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;\n\n\t\tconst camera = new CubeCamera( 1, 10, this );\n\t\tcamera.update( renderer, mesh );\n\n\t\ttexture.minFilter = currentMinFilter;\n\n\t\tmesh.geometry.dispose();\n\t\tmesh.material.dispose();\n\n\t\treturn this;\n\n\t}\n\n\tclear( renderer, color, depth, stencil ) {\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\trenderer.setRenderTarget( this, i );\n\n\t\t\trenderer.clear( color, depth, stencil );\n\n\t\t}\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t}\n\n}\n\nconst _vector1 = /*@__PURE__*/ new Vector3();\nconst _vector2 = /*@__PURE__*/ new Vector3();\nconst _normalMatrix = /*@__PURE__*/ new Matrix3();\n\nclass Plane {\n\n\tconstructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {\n\n\t\tthis.isPlane = true;\n\n\t\t// normal is assumed to be normalized\n\n\t\tthis.normal = normal;\n\t\tthis.constant = constant;\n\n\t}\n\n\tset( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t}\n\n\tsetComponents( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromNormalAndCoplanarPoint( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCoplanarPoints( a, b, c ) {\n\n\t\tconst normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();\n\n\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t}\n\n\tnormalize() {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tconst inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t}\n\n\tnegate() {\n\n\t\tthis.constant *= - 1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t}\n\n\tdistanceToSphere( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t}\n\n\tprojectPoint( point, target ) {\n\n\t\treturn target.copy( point ).addScaledVector( this.normal, - this.distanceToPoint( point ) );\n\n\t}\n\n\tintersectLine( line, target ) {\n\n\t\tconst direction = line.delta( _vector1 );\n\n\t\tconst denominator = this.normal.dot( direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\n\n\t\t\t\treturn target.copy( line.start );\n\n\t\t\t}\n\n\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\tif ( t < 0 || t > 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn target.copy( line.start ).addScaledVector( direction, t );\n\n\t}\n\n\tintersectsLine( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tconst startSign = this.distanceToPoint( line.start );\n\t\tconst endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsPlane( this );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphere.intersectsPlane( this );\n\n\t}\n\n\tcoplanarPoint( target ) {\n\n\t\treturn target.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t}\n\n\tapplyMatrix4( matrix, optionalNormalMatrix ) {\n\n\t\tconst normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );\n\n\t\tconst referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );\n\n\t\tconst normal = this.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\tthis.constant = - referencePoint.dot( normal );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.constant -= offset.dot( this.normal );\n\n\t\treturn this;\n\n\t}\n\n\tequals( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _sphere$4 = /*@__PURE__*/ new Sphere();\nconst _vector$6 = /*@__PURE__*/ new Vector3();\n\nclass Frustum {\n\n\tconstructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {\n\n\t\tthis.planes = [ p0, p1, p2, p3, p4, p5 ];\n\n\t}\n\n\tset( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tconst planes = this.planes;\n\n\t\tplanes[ 0 ].copy( p0 );\n\t\tplanes[ 1 ].copy( p1 );\n\t\tplanes[ 2 ].copy( p2 );\n\t\tplanes[ 3 ].copy( p3 );\n\t\tplanes[ 4 ].copy( p4 );\n\t\tplanes[ 5 ].copy( p5 );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( frustum ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromProjectionMatrix( m, coordinateSystem = WebGLCoordinateSystem ) {\n\n\t\tconst planes = this.planes;\n\t\tconst me = m.elements;\n\t\tconst me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\n\t\tconst me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\n\t\tconst me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\n\t\tconst me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\n\t\tif ( coordinateSystem === WebGLCoordinateSystem ) {\n\n\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\t} else if ( coordinateSystem === WebGPUCoordinateSystem ) {\n\n\t\t\tplanes[ 5 ].setComponents( me2, me6, me10, me14 ).normalize();\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tintersectsObject( object ) {\n\n\t\tif ( object.boundingSphere !== undefined ) {\n\n\t\t\tif ( object.boundingSphere === null ) object.computeBoundingSphere();\n\n\t\t\t_sphere$4.copy( object.boundingSphere ).applyMatrix4( object.matrixWorld );\n\n\t\t} else {\n\n\t\t\tconst geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t_sphere$4.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );\n\n\t\t}\n\n\t\treturn this.intersectsSphere( _sphere$4 );\n\n\t}\n\n\tintersectsSprite( sprite ) {\n\n\t\t_sphere$4.center.set( 0, 0, 0 );\n\t\t_sphere$4.radius = 0.7071067811865476;\n\t\t_sphere$4.applyMatrix4( sprite.matrixWorld );\n\n\t\treturn this.intersectsSphere( _sphere$4 );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tconst planes = this.planes;\n\t\tconst center = sphere.center;\n\t\tconst negRadius = - sphere.radius;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst plane = planes[ i ];\n\n\t\t\t// corner at max distance\n\n\t\t\t_vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t_vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t_vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\tif ( plane.distanceToPoint( _vector$6 ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\tconst planes = this.planes;\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nfunction WebGLAnimation() {\n\n\tlet context = null;\n\tlet isAnimating = false;\n\tlet animationLoop = null;\n\tlet requestId = null;\n\n\tfunction onAnimationFrame( time, frame ) {\n\n\t\tanimationLoop( time, frame );\n\n\t\trequestId = context.requestAnimationFrame( onAnimationFrame );\n\n\t}\n\n\treturn {\n\n\t\tstart: function () {\n\n\t\t\tif ( isAnimating === true ) return;\n\t\t\tif ( animationLoop === null ) return;\n\n\t\t\trequestId = context.requestAnimationFrame( onAnimationFrame );\n\n\t\t\tisAnimating = true;\n\n\t\t},\n\n\t\tstop: function () {\n\n\t\t\tcontext.cancelAnimationFrame( requestId );\n\n\t\t\tisAnimating = false;\n\n\t\t},\n\n\t\tsetAnimationLoop: function ( callback ) {\n\n\t\t\tanimationLoop = callback;\n\n\t\t},\n\n\t\tsetContext: function ( value ) {\n\n\t\t\tcontext = value;\n\n\t\t}\n\n\t};\n\n}\n\nfunction WebGLAttributes( gl, capabilities ) {\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\n\tconst buffers = new WeakMap();\n\n\tfunction createBuffer( attribute, bufferType ) {\n\n\t\tconst array = attribute.array;\n\t\tconst usage = attribute.usage;\n\n\t\tconst buffer = gl.createBuffer();\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\t\tgl.bufferData( bufferType, array, usage );\n\n\t\tattribute.onUploadCallback();\n\n\t\tlet type;\n\n\t\tif ( array instanceof Float32Array ) {\n\n\t\t\ttype = gl.FLOAT;\n\n\t\t} else if ( array instanceof Uint16Array ) {\n\n\t\t\tif ( attribute.isFloat16BufferAttribute ) {\n\n\t\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\t\ttype = gl.HALF_FLOAT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttype = gl.UNSIGNED_SHORT;\n\n\t\t\t}\n\n\t\t} else if ( array instanceof Int16Array ) {\n\n\t\t\ttype = gl.SHORT;\n\n\t\t} else if ( array instanceof Uint32Array ) {\n\n\t\t\ttype = gl.UNSIGNED_INT;\n\n\t\t} else if ( array instanceof Int32Array ) {\n\n\t\t\ttype = gl.INT;\n\n\t\t} else if ( array instanceof Int8Array ) {\n\n\t\t\ttype = gl.BYTE;\n\n\t\t} else if ( array instanceof Uint8Array ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else if ( array instanceof Uint8ClampedArray ) {\n\n\t\t\ttype = gl.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.WebGLAttributes: Unsupported buffer data format: ' + array );\n\n\t\t}\n\n\t\treturn {\n\t\t\tbuffer: buffer,\n\t\t\ttype: type,\n\t\t\tbytesPerElement: array.BYTES_PER_ELEMENT,\n\t\t\tversion: attribute.version\n\t\t};\n\n\t}\n\n\tfunction updateBuffer( buffer, attribute, bufferType ) {\n\n\t\tconst array = attribute.array;\n\t\tconst updateRange = attribute.updateRange;\n\n\t\tgl.bindBuffer( bufferType, buffer );\n\n\t\tif ( updateRange.count === - 1 ) {\n\n\t\t\t// Not using update ranges\n\n\t\t\tgl.bufferSubData( bufferType, 0, array );\n\n\t\t} else {\n\n\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\n\t\t\t\t\tarray, updateRange.offset, updateRange.count );\n\n\t\t\t} else {\n\n\t\t\t\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\n\t\t\t\t\tarray.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );\n\n\t\t\t}\n\n\t\t\tupdateRange.count = - 1; // reset range\n\n\t\t}\n\n\t\tattribute.onUploadCallback();\n\n\t}\n\n\t//\n\n\tfunction get( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\treturn buffers.get( attribute );\n\n\t}\n\n\tfunction remove( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tconst data = buffers.get( attribute );\n\n\t\tif ( data ) {\n\n\t\t\tgl.deleteBuffer( data.buffer );\n\n\t\t\tbuffers.delete( attribute );\n\n\t\t}\n\n\t}\n\n\tfunction update( attribute, bufferType ) {\n\n\t\tif ( attribute.isGLBufferAttribute ) {\n\n\t\t\tconst cached = buffers.get( attribute );\n\n\t\t\tif ( ! cached || cached.version < attribute.version ) {\n\n\t\t\t\tbuffers.set( attribute, {\n\t\t\t\t\tbuffer: attribute.buffer,\n\t\t\t\t\ttype: attribute.type,\n\t\t\t\t\tbytesPerElement: attribute.elementSize,\n\t\t\t\t\tversion: attribute.version\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\n\n\t\tconst data = buffers.get( attribute );\n\n\t\tif ( data === undefined ) {\n\n\t\t\tbuffers.set( attribute, createBuffer( attribute, bufferType ) );\n\n\t\t} else if ( data.version < attribute.version ) {\n\n\t\t\tupdateBuffer( data.buffer, attribute, bufferType );\n\n\t\t\tdata.version = attribute.version;\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\tget: get,\n\t\tremove: remove,\n\t\tupdate: update\n\n\t};\n\n}\n\nclass PlaneGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PlaneGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments\n\t\t};\n\n\t\tconst width_half = width / 2;\n\t\tconst height_half = height / 2;\n\n\t\tconst gridX = Math.floor( widthSegments );\n\t\tconst gridY = Math.floor( heightSegments );\n\n\t\tconst gridX1 = gridX + 1;\n\t\tconst gridY1 = gridY + 1;\n\n\t\tconst segment_width = width / gridX;\n\t\tconst segment_height = height / gridY;\n\n\t\t//\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tconst y = iy * segment_height - height_half;\n\n\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tconst x = ix * segment_width - width_half;\n\n\t\t\t\tvertices.push( x, - y, 0 );\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\tconst a = ix + gridX1 * iy;\n\t\t\t\tconst b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tconst c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tconst d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );\n\n\t}\n\n}\n\nvar alphahash_fragment = \"#ifdef USE_ALPHAHASH\\n\\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\\n#endif\";\n\nvar alphahash_pars_fragment = \"#ifdef USE_ALPHAHASH\\n\\tconst float ALPHA_HASH_SCALE = 0.05;\\n\\tfloat hash2D( vec2 value ) {\\n\\t\\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\\n\\t}\\n\\tfloat hash3D( vec3 value ) {\\n\\t\\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\\n\\t}\\n\\tfloat getAlphaHashThreshold( vec3 position ) {\\n\\t\\tfloat maxDeriv = max(\\n\\t\\t\\tlength( dFdx( position.xyz ) ),\\n\\t\\t\\tlength( dFdy( position.xyz ) )\\n\\t\\t);\\n\\t\\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\\n\\t\\tvec2 pixScales = vec2(\\n\\t\\t\\texp2( floor( log2( pixScale ) ) ),\\n\\t\\t\\texp2( ceil( log2( pixScale ) ) )\\n\\t\\t);\\n\\t\\tvec2 alpha = vec2(\\n\\t\\t\\thash3D( floor( pixScales.x * position.xyz ) ),\\n\\t\\t\\thash3D( floor( pixScales.y * position.xyz ) )\\n\\t\\t);\\n\\t\\tfloat lerpFactor = fract( log2( pixScale ) );\\n\\t\\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\\n\\t\\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\\n\\t\\tvec3 cases = vec3(\\n\\t\\t\\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\\n\\t\\t\\t( x - 0.5 * a ) / ( 1.0 - a ),\\n\\t\\t\\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\\n\\t\\t);\\n\\t\\tfloat threshold = ( x < ( 1.0 - a ) )\\n\\t\\t\\t? ( ( x < a ) ? cases.x : cases.y )\\n\\t\\t\\t: cases.z;\\n\\t\\treturn clamp( threshold , 1.0e-6, 1.0 );\\n\\t}\\n#endif\";\n\nvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\\n#endif\";\n\nvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\nvar alphatest_fragment = \"#ifdef USE_ALPHATEST\\n\\tif ( diffuseColor.a < alphaTest ) discard;\\n#endif\";\n\nvar alphatest_pars_fragment = \"#ifdef USE_ALPHATEST\\n\\tuniform float alphaTest;\\n#endif\";\n\nvar aomap_fragment = \"#ifdef USE_AOMAP\\n\\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD )\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\\n\\t#endif\\n#endif\";\n\nvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\\tuniform sampler2D aoMap;\\n\\tuniform float aoMapIntensity;\\n#endif\";\n\nvar begin_vertex = \"vec3 transformed = vec3( position );\\n#ifdef USE_ALPHAHASH\\n\\tvPosition = vec3( position );\\n#endif\";\n\nvar beginnormal_vertex = \"vec3 objectNormal = vec3( normal );\\n#ifdef USE_TANGENT\\n\\tvec3 objectTangent = vec3( tangent.xyz );\\n#endif\";\n\nvar bsdfs = \"float G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n} // validated\";\n\nvar iridescence_fragment = \"#ifdef USE_IRIDESCENCE\\n\\tconst mat3 XYZ_TO_REC709 = mat3(\\n\\t\\t 3.2404542, -0.9692660,  0.0556434,\\n\\t\\t-1.5371385,  1.8760108, -0.2040259,\\n\\t\\t-0.4985314,  0.0415560,  1.0572252\\n\\t);\\n\\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\\n\\t\\tvec3 sqrtF0 = sqrt( fresnel0 );\\n\\t\\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\\n\\t}\\n\\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\\n\\t\\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\\n\\t}\\n\\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\\n\\t\\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\\n\\t}\\n\\tvec3 evalSensitivity( float OPD, vec3 shift ) {\\n\\t\\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\\n\\t\\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\\n\\t\\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\\n\\t\\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\\n\\t\\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\\n\\t\\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\\n\\t\\txyz /= 1.0685e-7;\\n\\t\\tvec3 rgb = XYZ_TO_REC709 * xyz;\\n\\t\\treturn rgb;\\n\\t}\\n\\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\\n\\t\\tvec3 I;\\n\\t\\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\\n\\t\\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\\n\\t\\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\\n\\t\\tif ( cosTheta2Sq < 0.0 ) {\\n\\t\\t\\t return vec3( 1.0 );\\n\\t\\t}\\n\\t\\tfloat cosTheta2 = sqrt( cosTheta2Sq );\\n\\t\\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\\n\\t\\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\\n\\t\\tfloat R21 = R12;\\n\\t\\tfloat T121 = 1.0 - R12;\\n\\t\\tfloat phi12 = 0.0;\\n\\t\\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\\n\\t\\tfloat phi21 = PI - phi12;\\n\\t\\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\\t\\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\\n\\t\\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\\n\\t\\tvec3 phi23 = vec3( 0.0 );\\n\\t\\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\\n\\t\\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\\n\\t\\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\\n\\t\\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\\n\\t\\tvec3 phi = vec3( phi21 ) + phi23;\\n\\t\\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\\n\\t\\tvec3 r123 = sqrt( R123 );\\n\\t\\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\\n\\t\\tvec3 C0 = R12 + Rs;\\n\\t\\tI = C0;\\n\\t\\tvec3 Cm = Rs - T121;\\n\\t\\tfor ( int m = 1; m <= 2; ++ m ) {\\n\\t\\t\\tCm *= r123;\\n\\t\\t\\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\\n\\t\\t\\tI += Cm * Sm;\\n\\t\\t}\\n\\t\\treturn max( I, vec3( 0.0 ) );\\n\\t}\\n#endif\";\n\nvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vBumpMapUv );\\n\\t\\tvec2 dSTdy = dFdy( vBumpMapUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\\n\\t\\tvec3 vSigmaX = dFdx( surf_pos.xyz );\\n\\t\\tvec3 vSigmaY = dFdy( surf_pos.xyz );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\";\n\nvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvec4 plane;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\\t\\tplane = clippingPlanes[ i ];\\n\\t\\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\\t\\tbool clipped = true;\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\\t\\t\\tplane = clippingPlanes[ i ];\\n\\t\\t\\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t\\tif ( clipped ) discard;\\n\\t#endif\\n#endif\";\n\nvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\";\n\nvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvarying vec3 vClipPosition;\\n#endif\";\n\nvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\\tvClipPosition = - mvPosition.xyz;\\n#endif\";\n\nvar color_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tdiffuseColor *= vColor;\\n#elif defined( USE_COLOR )\\n\\tdiffuseColor.rgb *= vColor;\\n#endif\";\n\nvar color_pars_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\n\nvar color_pars_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvarying vec4 vColor;\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvarying vec3 vColor;\\n#endif\";\n\nvar color_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\\tvColor = vec4( 1.0 );\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\\tvColor = vec3( 1.0 );\\n#endif\\n#ifdef USE_COLOR\\n\\tvColor *= color;\\n#endif\\n#ifdef USE_INSTANCING_COLOR\\n\\tvColor.xyz *= instanceColor.xyz;\\n#endif\";\n\nvar common = \"#define PI 3.141592653589793\\n#define PI2 6.283185307179586\\n#define PI_HALF 1.5707963267948966\\n#define RECIPROCAL_PI 0.3183098861837907\\n#define RECIPROCAL_PI2 0.15915494309189535\\n#define EPSILON 1e-6\\n#ifndef saturate\\n#define saturate( a ) clamp( a, 0.0, 1.0 )\\n#endif\\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nvec3 pow2( const in vec3 x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract( sin( sn ) * c );\\n}\\n#ifdef HIGH_PRECISION\\n\\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\\n#else\\n\\tfloat precisionSafeLength( vec3 v ) {\\n\\t\\tfloat maxComponent = max3( abs( v ) );\\n\\t\\treturn length( v / maxComponent ) * maxComponent;\\n\\t}\\n#endif\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n#ifdef USE_CLEARCOAT\\n\\tvec3 clearcoatNormal;\\n#endif\\n};\\n#ifdef USE_ALPHAHASH\\n\\tvarying vec3 vPosition;\\n#endif\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\\tmat3 tmp;\\n\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\\treturn tmp;\\n}\\nfloat luminance( const in vec3 rgb ) {\\n\\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\\n\\treturn dot( weights, rgb );\\n}\\nbool isPerspectiveMatrix( mat4 m ) {\\n\\treturn m[ 2 ][ 3 ] == - 1.0;\\n}\\nvec2 equirectUv( in vec3 dir ) {\\n\\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\\treturn vec2( u, v );\\n}\\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\\n\\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\\n\\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\\n}\\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\\n\\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\\n\\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\\n} // validated\";\n\nvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t#define cubeUV_minMipLevel 4.0\\n\\t#define cubeUV_minTileSize 16.0\\n\\tfloat getFace( vec3 direction ) {\\n\\t\\tvec3 absDirection = abs( direction );\\n\\t\\tfloat face = - 1.0;\\n\\t\\tif ( absDirection.x > absDirection.z ) {\\n\\t\\t\\tif ( absDirection.x > absDirection.y )\\n\\t\\t\\t\\tface = direction.x > 0.0 ? 0.0 : 3.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t} else {\\n\\t\\t\\tif ( absDirection.z > absDirection.y )\\n\\t\\t\\t\\tface = direction.z > 0.0 ? 2.0 : 5.0;\\n\\t\\t\\telse\\n\\t\\t\\t\\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\\t\\t}\\n\\t\\treturn face;\\n\\t}\\n\\tvec2 getUV( vec3 direction, float face ) {\\n\\t\\tvec2 uv;\\n\\t\\tif ( face == 0.0 ) {\\n\\t\\t\\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 1.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\\n\\t\\t} else if ( face == 2.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\\n\\t\\t} else if ( face == 3.0 ) {\\n\\t\\t\\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\\n\\t\\t} else if ( face == 4.0 ) {\\n\\t\\t\\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\\n\\t\\t} else {\\n\\t\\t\\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\\n\\t\\t}\\n\\t\\treturn 0.5 * ( uv + 1.0 );\\n\\t}\\n\\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\\n\\t\\tfloat face = getFace( direction );\\n\\t\\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\\n\\t\\tmipInt = max( mipInt, cubeUV_minMipLevel );\\n\\t\\tfloat faceSize = exp2( mipInt );\\n\\t\\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\\n\\t\\tif ( face > 2.0 ) {\\n\\t\\t\\tuv.y += faceSize;\\n\\t\\t\\tface -= 3.0;\\n\\t\\t}\\n\\t\\tuv.x += face * faceSize;\\n\\t\\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\\n\\t\\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\\n\\t\\tuv.x *= CUBEUV_TEXEL_WIDTH;\\n\\t\\tuv.y *= CUBEUV_TEXEL_HEIGHT;\\n\\t\\t#ifdef texture2DGradEXT\\n\\t\\t\\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\\n\\t\\t#else\\n\\t\\t\\treturn texture2D( envMap, uv ).rgb;\\n\\t\\t#endif\\n\\t}\\n\\t#define cubeUV_r0 1.0\\n\\t#define cubeUV_v0 0.339\\n\\t#define cubeUV_m0 - 2.0\\n\\t#define cubeUV_r1 0.8\\n\\t#define cubeUV_v1 0.276\\n\\t#define cubeUV_m1 - 1.0\\n\\t#define cubeUV_r4 0.4\\n\\t#define cubeUV_v4 0.046\\n\\t#define cubeUV_m4 2.0\\n\\t#define cubeUV_r5 0.305\\n\\t#define cubeUV_v5 0.016\\n\\t#define cubeUV_m5 3.0\\n\\t#define cubeUV_r6 0.21\\n\\t#define cubeUV_v6 0.0038\\n\\t#define cubeUV_m6 4.0\\n\\tfloat roughnessToMip( float roughness ) {\\n\\t\\tfloat mip = 0.0;\\n\\t\\tif ( roughness >= cubeUV_r1 ) {\\n\\t\\t\\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\\n\\t\\t} else if ( roughness >= cubeUV_r4 ) {\\n\\t\\t\\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\\n\\t\\t} else if ( roughness >= cubeUV_r5 ) {\\n\\t\\t\\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\\n\\t\\t} else if ( roughness >= cubeUV_r6 ) {\\n\\t\\t\\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\\n\\t\\t} else {\\n\\t\\t\\tmip = - 2.0 * log2( 1.16 * roughness );\\t\\t}\\n\\t\\treturn mip;\\n\\t}\\n\\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\\n\\t\\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\\n\\t\\tfloat mipF = fract( mip );\\n\\t\\tfloat mipInt = floor( mip );\\n\\t\\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\\n\\t\\tif ( mipF == 0.0 ) {\\n\\t\\t\\treturn vec4( color0, 1.0 );\\n\\t\\t} else {\\n\\t\\t\\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\\n\\t\\t\\treturn vec4( mix( color0, color1, mipF ), 1.0 );\\n\\t\\t}\\n\\t}\\n#endif\";\n\nvar defaultnormal_vertex = \"vec3 transformedNormal = objectNormal;\\n#ifdef USE_INSTANCING\\n\\tmat3 m = mat3( instanceMatrix );\\n\\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\\n\\ttransformedNormal = m * transformedNormal;\\n#endif\\ntransformedNormal = normalMatrix * transformedNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n#ifdef USE_TANGENT\\n\\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#ifdef FLIP_SIDED\\n\\t\\ttransformedTangent = - transformedTangent;\\n\\t#endif\\n#endif\";\n\nvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\";\n\nvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\\n#endif\";\n\nvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\";\n\nvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\\tuniform sampler2D emissiveMap;\\n#endif\";\n\nvar colorspace_fragment = \"gl_FragColor = linearToOutputTexel( gl_FragColor );\";\n\nvar colorspace_pars_fragment = \"vec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\";\n\nvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvec3 cameraToFrag;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\";\n\nvar envmap_common_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float envMapIntensity;\\n\\tuniform float flipEnvMap;\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tuniform samplerCube envMap;\\n\\t#else\\n\\t\\tuniform sampler2D envMap;\\n\\t#endif\\n\\t\\n#endif\";\n\nvar envmap_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tuniform float reflectivity;\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t\\tuniform float refractionRatio;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t#endif\\n#endif\";\n\nvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\\n\\t\\t#define ENV_WORLDPOS\\n\\t#endif\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\t\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\";\n\nvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\\t#ifdef ENV_WORLDPOS\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex;\\n\\t\\tif ( isOrthographic ) {\\n\\t\\t\\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\\t\\t} else {\\n\\t\\t\\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\t}\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\n\nvar fog_vertex = \"#ifdef USE_FOG\\n\\tvFogDepth = - mvPosition.z;\\n#endif\";\n\nvar fog_pars_vertex = \"#ifdef USE_FOG\\n\\tvarying float vFogDepth;\\n#endif\";\n\nvar fog_fragment = \"#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\";\n\nvar fog_pars_fragment = \"#ifdef USE_FOG\\n\\tuniform vec3 fogColor;\\n\\tvarying float vFogDepth;\\n\\t#ifdef FOG_EXP2\\n\\t\\tuniform float fogDensity;\\n\\t#else\\n\\t\\tuniform float fogNear;\\n\\t\\tuniform float fogFar;\\n\\t#endif\\n#endif\";\n\nvar gradientmap_pars_fragment = \"#ifdef USE_GRADIENTMAP\\n\\tuniform sampler2D gradientMap;\\n#endif\\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\tfloat dotNL = dot( normal, lightDirection );\\n\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t#ifdef USE_GRADIENTMAP\\n\\t\\treturn vec3( texture2D( gradientMap, coord ).r );\\n\\t#else\\n\\t\\tvec2 fw = fwidth( coord ) * 0.5;\\n\\t\\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\\n\\t#endif\\n}\";\n\nvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\\n\\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\\n\\treflectedLight.indirectDiffuse += lightMapIrradiance;\\n#endif\";\n\nvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\\tuniform sampler2D lightMap;\\n\\tuniform float lightMapIntensity;\\n#endif\";\n\nvar lights_lambert_fragment = \"LambertMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularStrength = specularStrength;\";\n\nvar lights_lambert_pars_fragment = \"varying vec3 vViewPosition;\\nstruct LambertMaterial {\\n\\tvec3 diffuseColor;\\n\\tfloat specularStrength;\\n};\\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Lambert\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Lambert\";\n\nvar lights_pars_begin = \"uniform bool receiveShadow;\\nuniform vec3 ambientLightColor;\\nuniform vec3 lightProbe[ 9 ];\\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\n\\tfloat x = normal.x, y = normal.y, z = normal.z;\\n\\tvec3 result = shCoefficients[ 0 ] * 0.886227;\\n\\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\\n\\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\n\\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\n\\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\\n\\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\\n\\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\\n\\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\n\\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\n\\treturn result;\\n}\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\\n\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\\n\\treturn irradiance;\\n}\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\\tvec3 irradiance = ambientLightColor;\\n\\treturn irradiance;\\n}\\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\t#if defined ( LEGACY_LIGHTS )\\n\\t\\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\n\\t\\t\\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\\t\\t}\\n\\t\\treturn 1.0;\\n\\t#else\\n\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\tif ( cutoffDistance > 0.0 ) {\\n\\t\\t\\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\t}\\n\\t\\treturn distanceFalloff;\\n\\t#endif\\n}\\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\\n\\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\\tstruct DirectionalLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t};\\n\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\\n\\t\\tlight.color = directionalLight.color;\\n\\t\\tlight.direction = directionalLight.direction;\\n\\t\\tlight.visible = true;\\n\\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\\tstruct PointLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t};\\n\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\\n\\t\\tvec3 lVector = pointLight.position - geometry.position;\\n\\t\\tlight.direction = normalize( lVector );\\n\\t\\tfloat lightDistance = length( lVector );\\n\\t\\tlight.color = pointLight.color;\\n\\t\\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\\n\\t\\tlight.visible = ( light.color != vec3( 0.0 ) );\\n\\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\\tstruct SpotLight {\\n\\t\\tvec3 position;\\n\\t\\tvec3 direction;\\n\\t\\tvec3 color;\\n\\t\\tfloat distance;\\n\\t\\tfloat decay;\\n\\t\\tfloat coneCos;\\n\\t\\tfloat penumbraCos;\\n\\t};\\n\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\\n\\t\\tvec3 lVector = spotLight.position - geometry.position;\\n\\t\\tlight.direction = normalize( lVector );\\n\\t\\tfloat angleCos = dot( light.direction, spotLight.direction );\\n\\t\\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\\t\\tif ( spotAttenuation > 0.0 ) {\\n\\t\\t\\tfloat lightDistance = length( lVector );\\n\\t\\t\\tlight.color = spotLight.color * spotAttenuation;\\n\\t\\t\\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\\n\\t\\t\\tlight.visible = ( light.color != vec3( 0.0 ) );\\n\\t\\t} else {\\n\\t\\t\\tlight.color = vec3( 0.0 );\\n\\t\\t\\tlight.visible = false;\\n\\t\\t}\\n\\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tstruct RectAreaLight {\\n\\t\\tvec3 color;\\n\\t\\tvec3 position;\\n\\t\\tvec3 halfWidth;\\n\\t\\tvec3 halfHeight;\\n\\t};\\n\\tuniform sampler2D ltc_1;\\tuniform sampler2D ltc_2;\\n\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\\tstruct HemisphereLight {\\n\\t\\tvec3 direction;\\n\\t\\tvec3 skyColor;\\n\\t\\tvec3 groundColor;\\n\\t};\\n\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\\n\\t\\tfloat dotNL = dot( normal, hemiLight.direction );\\n\\t\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\t\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\\t\\treturn irradiance;\\n\\t}\\n#endif\";\n\nvar envmap_physical_pars_fragment = \"#ifdef USE_ENVMAP\\n\\tvec3 getIBLIrradiance( const in vec3 normal ) {\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\\n\\t\\t\\treturn PI * envMapColor.rgb * envMapIntensity;\\n\\t\\t#else\\n\\t\\t\\treturn vec3( 0.0 );\\n\\t\\t#endif\\n\\t}\\n\\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\\n\\t\\t#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t\\t\\tvec3 reflectVec = reflect( - viewDir, normal );\\n\\t\\t\\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\\n\\t\\t\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\\t\\t\\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\\n\\t\\t\\treturn envMapColor.rgb * envMapIntensity;\\n\\t\\t#else\\n\\t\\t\\treturn vec3( 0.0 );\\n\\t\\t#endif\\n\\t}\\n\\t#ifdef USE_ANISOTROPY\\n\\t\\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\\n\\t\\t\\t#ifdef ENVMAP_TYPE_CUBE_UV\\n\\t\\t\\t\\tvec3 bentNormal = cross( bitangent, viewDir );\\n\\t\\t\\t\\tbentNormal = normalize( cross( bentNormal, bitangent ) );\\n\\t\\t\\t\\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\\n\\t\\t\\t\\treturn getIBLRadiance( viewDir, bentNormal, roughness );\\n\\t\\t\\t#else\\n\\t\\t\\t\\treturn vec3( 0.0 );\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t#endif\\n#endif\";\n\nvar lights_toon_fragment = \"ToonMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\";\n\nvar lights_toon_pars_fragment = \"varying vec3 vViewPosition;\\nstruct ToonMaterial {\\n\\tvec3 diffuseColor;\\n};\\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Toon\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Toon\";\n\nvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\";\n\nvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\nstruct BlinnPhongMaterial {\\n\\tvec3 diffuseColor;\\n\\tvec3 specularColor;\\n\\tfloat specularShininess;\\n\\tfloat specularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\";\n\nvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\\nmaterial.roughness = min( material.roughness, 1.0 );\\n#ifdef IOR\\n\\tmaterial.ior = ior;\\n\\t#ifdef USE_SPECULAR\\n\\t\\tfloat specularIntensityFactor = specularIntensity;\\n\\t\\tvec3 specularColorFactor = specularColor;\\n\\t\\t#ifdef USE_SPECULAR_COLORMAP\\n\\t\\t\\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\\n\\t\\t#endif\\n\\t\\t#ifdef USE_SPECULAR_INTENSITYMAP\\n\\t\\t\\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\\n\\t\\t#endif\\n\\t\\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\\n\\t#else\\n\\t\\tfloat specularIntensityFactor = 1.0;\\n\\t\\tvec3 specularColorFactor = vec3( 1.0 );\\n\\t\\tmaterial.specularF90 = 1.0;\\n\\t#endif\\n\\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\\n#else\\n\\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\\n\\tmaterial.specularF90 = 1.0;\\n#endif\\n#ifdef USE_CLEARCOAT\\n\\tmaterial.clearcoat = clearcoat;\\n\\tmaterial.clearcoatRoughness = clearcoatRoughness;\\n\\tmaterial.clearcoatF0 = vec3( 0.04 );\\n\\tmaterial.clearcoatF90 = 1.0;\\n\\t#ifdef USE_CLEARCOATMAP\\n\\t\\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\t\\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\\n\\t#endif\\n\\tmaterial.clearcoat = saturate( material.clearcoat );\\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\\n\\tmaterial.clearcoatRoughness += geometryRoughness;\\n\\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\\n#endif\\n#ifdef USE_IRIDESCENCE\\n\\tmaterial.iridescence = iridescence;\\n\\tmaterial.iridescenceIOR = iridescenceIOR;\\n\\t#ifdef USE_IRIDESCENCEMAP\\n\\t\\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\\n\\t#endif\\n\\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\t\\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\\n\\t#else\\n\\t\\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\\n\\t#endif\\n#endif\\n#ifdef USE_SHEEN\\n\\tmaterial.sheenColor = sheenColor;\\n\\t#ifdef USE_SHEEN_COLORMAP\\n\\t\\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\\n\\t#endif\\n\\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\\n\\t#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\t\\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\\n\\t#endif\\n#endif\\n#ifdef USE_ANISOTROPY\\n\\t#ifdef USE_ANISOTROPYMAP\\n\\t\\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\\n\\t\\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\\n\\t\\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\\n\\t#else\\n\\t\\tvec2 anisotropyV = anisotropyVector;\\n\\t#endif\\n\\tmaterial.anisotropy = length( anisotropyV );\\n\\tanisotropyV /= material.anisotropy;\\n\\tmaterial.anisotropy = saturate( material.anisotropy );\\n\\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\\n\\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\\n\\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\\n#endif\";\n\nvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\\tvec3 diffuseColor;\\n\\tfloat roughness;\\n\\tvec3 specularColor;\\n\\tfloat specularF90;\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat clearcoat;\\n\\t\\tfloat clearcoatRoughness;\\n\\t\\tvec3 clearcoatF0;\\n\\t\\tfloat clearcoatF90;\\n\\t#endif\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\tfloat iridescence;\\n\\t\\tfloat iridescenceIOR;\\n\\t\\tfloat iridescenceThickness;\\n\\t\\tvec3 iridescenceFresnel;\\n\\t\\tvec3 iridescenceF0;\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\tvec3 sheenColor;\\n\\t\\tfloat sheenRoughness;\\n\\t#endif\\n\\t#ifdef IOR\\n\\t\\tfloat ior;\\n\\t#endif\\n\\t#ifdef USE_TRANSMISSION\\n\\t\\tfloat transmission;\\n\\t\\tfloat transmissionAlpha;\\n\\t\\tfloat thickness;\\n\\t\\tfloat attenuationDistance;\\n\\t\\tvec3 attenuationColor;\\n\\t#endif\\n\\t#ifdef USE_ANISOTROPY\\n\\t\\tfloat anisotropy;\\n\\t\\tfloat alphaT;\\n\\t\\tvec3 anisotropyT;\\n\\t\\tvec3 anisotropyB;\\n\\t#endif\\n};\\nvec3 clearcoatSpecular = vec3( 0.0 );\\nvec3 sheenSpecular = vec3( 0.0 );\\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\\n    float x2 = x * x;\\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\\n}\\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\n#ifdef USE_ANISOTROPY\\n\\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\\n\\t\\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\\n\\t\\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\\n\\t\\tfloat v = 0.5 / ( gv + gl );\\n\\t\\treturn saturate(v);\\n\\t}\\n\\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\\n\\t\\tfloat a2 = alphaT * alphaB;\\n\\t\\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\\n\\t\\thighp float v2 = dot( v, v );\\n\\t\\tfloat w2 = a2 / v2;\\n\\t\\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\\n\\t}\\n#endif\\n#ifdef USE_CLEARCOAT\\n\\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\\n\\t\\tvec3 f0 = material.clearcoatF0;\\n\\t\\tfloat f90 = material.clearcoatF90;\\n\\t\\tfloat roughness = material.clearcoatRoughness;\\n\\t\\tfloat alpha = pow2( roughness );\\n\\t\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\t\\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\\t\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\t\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\t\\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\\t\\tvec3 F = F_Schlick( f0, f90, dotVH );\\n\\t\\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\t\\tfloat D = D_GGX( alpha, dotNH );\\n\\t\\treturn F * ( V * D );\\n\\t}\\n#endif\\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\\n\\tvec3 f0 = material.specularColor;\\n\\tfloat f90 = material.specularF90;\\n\\tfloat roughness = material.roughness;\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\\n\\tvec3 F = F_Schlick( f0, f90, dotVH );\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\tF = mix( F, material.iridescenceFresnel, material.iridescence );\\n\\t#endif\\n\\t#ifdef USE_ANISOTROPY\\n\\t\\tfloat dotTL = dot( material.anisotropyT, lightDir );\\n\\t\\tfloat dotTV = dot( material.anisotropyT, viewDir );\\n\\t\\tfloat dotTH = dot( material.anisotropyT, halfDir );\\n\\t\\tfloat dotBL = dot( material.anisotropyB, lightDir );\\n\\t\\tfloat dotBV = dot( material.anisotropyB, viewDir );\\n\\t\\tfloat dotBH = dot( material.anisotropyB, halfDir );\\n\\t\\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\\n\\t\\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\\n\\t#else\\n\\t\\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\t\\tfloat D = D_GGX( alpha, dotNH );\\n\\t#endif\\n\\treturn F * ( V * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\\tfloat dotNV = saturate( dot( N, V ) );\\n\\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\\treturn vec3( result );\\n}\\n#if defined( USE_SHEEN )\\nfloat D_Charlie( float roughness, float dotNH ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tfloat invAlpha = 1.0 / alpha;\\n\\tfloat cos2h = dotNH * dotNH;\\n\\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\\n\\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\\n}\\nfloat V_Neubelt( float dotNV, float dotNL ) {\\n\\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\\n}\\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\\n\\tvec3 halfDir = normalize( lightDir + viewDir );\\n\\tfloat dotNL = saturate( dot( normal, lightDir ) );\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\\tfloat D = D_Charlie( sheenRoughness, dotNH );\\n\\tfloat V = V_Neubelt( dotNV, dotNL );\\n\\treturn sheenColor * ( D * V );\\n}\\n#endif\\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tfloat r2 = roughness * roughness;\\n\\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\\n\\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\\n\\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\\n\\treturn saturate( DG * RECIPROCAL_PI );\\n}\\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\\n\\treturn fab;\\n}\\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\\n\\tvec2 fab = DFGApprox( normal, viewDir, roughness );\\n\\treturn specularColor * fab.x + specularF90 * fab.y;\\n}\\n#ifdef USE_IRIDESCENCE\\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n#else\\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n#endif\\n\\tvec2 fab = DFGApprox( normal, viewDir, roughness );\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\\n\\t#else\\n\\t\\tvec3 Fr = specularColor;\\n\\t#endif\\n\\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\\n\\tfloat Ess = fab.x + fab.y;\\n\\tfloat Ems = 1.0 - Ess;\\n\\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\\tsingleScatter += FssEss;\\n\\tmultiScatter += Fms * Ems;\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.roughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tvec4 t1 = texture2D( ltc_1, uv );\\n\\t\\tvec4 t2 = texture2D( ltc_2, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3( t1.x, 0, t1.y ),\\n\\t\\t\\tvec3(    0, 1,    0 ),\\n\\t\\t\\tvec3( t1.z, 0, t1.w )\\n\\t\\t);\\n\\t\\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\\t\\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\\n\\t\\tvec3 ccIrradiance = dotNLcc * directLight.color;\\n\\t\\tclearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\\n\\t#endif\\n\\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\\n\\t#endif\\n\\t#ifdef USE_SHEEN\\n\\t\\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\\n\\t#endif\\n\\tvec3 singleScattering = vec3( 0.0 );\\n\\tvec3 multiScattering = vec3( 0.0 );\\n\\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\\t#ifdef USE_IRIDESCENCE\\n\\t\\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\\n\\t#else\\n\\t\\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\\n\\t#endif\\n\\tvec3 totalScattering = singleScattering + multiScattering;\\n\\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\\n\\treflectedLight.indirectSpecular += radiance * singleScattering;\\n\\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\\n\\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\";\n\nvar lights_fragment_begin = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\n#ifdef USE_CLEARCOAT\\n\\tgeometry.clearcoatNormal = clearcoatNormal;\\n#endif\\n#ifdef USE_IRIDESCENCE\\n\\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\\n\\tif ( material.iridescenceThickness == 0.0 ) {\\n\\t\\tmaterial.iridescence = 0.0;\\n\\t} else {\\n\\t\\tmaterial.iridescence = saturate( material.iridescence );\\n\\t}\\n\\tif ( material.iridescence > 0.0 ) {\\n\\t\\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\\n\\t\\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\\n\\t}\\n#endif\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tPointLight pointLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tgetPointLightInfo( pointLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\n\\t\\tpointLightShadow = pointLightShadows[ i ];\\n\\t\\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tSpotLight spotLight;\\n\\tvec4 spotColor;\\n\\tvec3 spotLightCoord;\\n\\tbool inSpotLightMap;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tgetSpotLightInfo( spotLight, geometry, directLight );\\n\\t\\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\\n\\t\\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\\n\\t\\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\\n\\t\\t#else\\n\\t\\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\\n\\t\\t#endif\\n\\t\\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\\n\\t\\t\\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\\n\\t\\t\\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\\n\\t\\t\\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\\n\\t\\t\\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\\n\\t\\t#endif\\n\\t\\t#undef SPOT_LIGHT_MAP_INDEX\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\tspotLightShadow = spotLightShadows[ i ];\\n\\t\\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\\tDirectionalLight directionalLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\tRectAreaLight rectAreaLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\\tvec3 iblIrradiance = vec3( 0.0 );\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearcoatRadiance = vec3( 0.0 );\\n#endif\";\n\nvar lights_fragment_maps = \"#if defined( RE_IndirectDiffuse )\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\\n\\t\\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\\n\\t\\tirradiance += lightMapIrradiance;\\n\\t#endif\\n\\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tiblIrradiance += getIBLIrradiance( geometry.normal );\\n\\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\\t#ifdef USE_ANISOTROPY\\n\\t\\tradiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );\\n\\t#else\\n\\t\\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\\n\\t#endif\\n#endif\";\n\nvar lights_fragment_end = \"#if defined( RE_IndirectDiffuse )\\n\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\\n#endif\";\n\nvar logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\";\n\nvar logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\\tuniform float logDepthBufFC;\\n\\tvarying float vFragDepth;\\n\\tvarying float vIsPerspective;\\n#endif\";\n\nvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvarying float vFragDepth;\\n\\t\\tvarying float vIsPerspective;\\n\\t#else\\n\\t\\tuniform float logDepthBufFC;\\n\\t#endif\\n#endif\";\n\nvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\\t#ifdef USE_LOGDEPTHBUF_EXT\\n\\t\\tvFragDepth = 1.0 + gl_Position.w;\\n\\t\\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\\n\\t#else\\n\\t\\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\\n\\t\\t\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\\t\\t\\tgl_Position.z *= gl_Position.w;\\n\\t\\t}\\n\\t#endif\\n#endif\";\n\nvar map_fragment = \"#ifdef USE_MAP\\n\\tdiffuseColor *= texture2D( map, vMapUv );\\n#endif\";\n\nvar map_pars_fragment = \"#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\";\n\nvar map_particle_fragment = \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\t#if defined( USE_POINTS_UV )\\n\\t\\tvec2 uv = vUv;\\n\\t#else\\n\\t\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n\\t#endif\\n#endif\\n#ifdef USE_MAP\\n\\tdiffuseColor *= texture2D( map, uv );\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\\n#endif\";\n\nvar map_particle_pars_fragment = \"#if defined( USE_POINTS_UV )\\n\\tvarying vec2 vUv;\\n#else\\n\\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\\t\\tuniform mat3 uvTransform;\\n\\t#endif\\n#endif\\n#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tuniform sampler2D alphaMap;\\n#endif\";\n\nvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\\n\\tmetalnessFactor *= texelMetalness.b;\\n#endif\";\n\nvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif\";\n\nvar morphcolor_vertex = \"#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\\n\\tvColor *= morphTargetBaseInfluence;\\n\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\t#if defined( USE_COLOR_ALPHA )\\n\\t\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\\n\\t\\t#elif defined( USE_COLOR )\\n\\t\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\\n\\t\\t#endif\\n\\t}\\n#endif\";\n\nvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\\tobjectNormal *= morphTargetBaseInfluence;\\n\\t#ifdef MORPHTARGETS_TEXTURE\\n\\t\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\\n\\t\\t}\\n\\t#else\\n\\t\\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\\n\\t\\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\\n\\t\\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\\n\\t\\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\\n\\t#endif\\n#endif\";\n\nvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\\tuniform float morphTargetBaseInfluence;\\n\\t#ifdef MORPHTARGETS_TEXTURE\\n\\t\\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\\n\\t\\tuniform sampler2DArray morphTargetsTexture;\\n\\t\\tuniform ivec2 morphTargetsTextureSize;\\n\\t\\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\\n\\t\\t\\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\\n\\t\\t\\tint y = texelIndex / morphTargetsTextureSize.x;\\n\\t\\t\\tint x = texelIndex - y * morphTargetsTextureSize.x;\\n\\t\\t\\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\\n\\t\\t\\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\\n\\t\\t}\\n\\t#else\\n\\t\\t#ifndef USE_MORPHNORMALS\\n\\t\\t\\tuniform float morphTargetInfluences[ 8 ];\\n\\t\\t#else\\n\\t\\t\\tuniform float morphTargetInfluences[ 4 ];\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\n\nvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\\ttransformed *= morphTargetBaseInfluence;\\n\\t#ifdef MORPHTARGETS_TEXTURE\\n\\t\\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\\n\\t\\t\\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\\n\\t\\t}\\n\\t#else\\n\\t\\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\\n\\t\\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\\n\\t\\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\\n\\t\\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\\n\\t\\t#ifndef USE_MORPHNORMALS\\n\\t\\t\\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\\n\\t\\t\\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\\n\\t\\t\\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\\n\\t\\t\\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\\n\\t\\t#endif\\n\\t#endif\\n#endif\";\n\nvar normal_fragment_begin = \"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\\n#ifdef FLAT_SHADED\\n\\tvec3 fdx = dFdx( vViewPosition );\\n\\tvec3 fdy = dFdy( vViewPosition );\\n\\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\\tvec3 normal = normalize( vNormal );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal *= faceDirection;\\n\\t#endif\\n#endif\\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\\n\\t#ifdef USE_TANGENT\\n\\t\\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\\n\\t#else\\n\\t\\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\\n\\t\\t#if defined( USE_NORMALMAP )\\n\\t\\t\\tvNormalMapUv\\n\\t\\t#elif defined( USE_CLEARCOAT_NORMALMAP )\\n\\t\\t\\tvClearcoatNormalMapUv\\n\\t\\t#else\\n\\t\\t\\tvUv\\n\\t\\t#endif\\n\\t\\t);\\n\\t#endif\\n\\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\\n\\t\\ttbn[0] *= faceDirection;\\n\\t\\ttbn[1] *= faceDirection;\\n\\t#endif\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\t#ifdef USE_TANGENT\\n\\t\\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\\n\\t#else\\n\\t\\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\\n\\t#endif\\n\\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\\n\\t\\ttbn2[0] *= faceDirection;\\n\\t\\ttbn2[1] *= faceDirection;\\n\\t#endif\\n#endif\\nvec3 geometryNormal = normal;\";\n\nvar normal_fragment_maps = \"#ifdef USE_NORMALMAP_OBJECTSPACE\\n\\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\\n\\t#ifdef FLIP_SIDED\\n\\t\\tnormal = - normal;\\n\\t#endif\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\tnormal = normal * faceDirection;\\n\\t#endif\\n\\tnormal = normalize( normalMatrix * normal );\\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\\n\\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\\n\\tmapN.xy *= normalScale;\\n\\tnormal = normalize( tbn * mapN );\\n#elif defined( USE_BUMPMAP )\\n\\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\\n#endif\";\n\nvar normal_pars_fragment = \"#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\";\n\nvar normal_pars_vertex = \"#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n\\t#ifdef USE_TANGENT\\n\\t\\tvarying vec3 vTangent;\\n\\t\\tvarying vec3 vBitangent;\\n\\t#endif\\n#endif\";\n\nvar normal_vertex = \"#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n\\t#ifdef USE_TANGENT\\n\\t\\tvTangent = normalize( transformedTangent );\\n\\t\\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\\t#endif\\n#endif\";\n\nvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\\tuniform sampler2D normalMap;\\n\\tuniform vec2 normalScale;\\n#endif\\n#ifdef USE_NORMALMAP_OBJECTSPACE\\n\\tuniform mat3 normalMatrix;\\n#endif\\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\\n\\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\\n\\t\\tvec3 q0 = dFdx( eye_pos.xyz );\\n\\t\\tvec3 q1 = dFdy( eye_pos.xyz );\\n\\t\\tvec2 st0 = dFdx( uv.st );\\n\\t\\tvec2 st1 = dFdy( uv.st );\\n\\t\\tvec3 N = surf_norm;\\n\\t\\tvec3 q1perp = cross( q1, N );\\n\\t\\tvec3 q0perp = cross( N, q0 );\\n\\t\\tvec3 T = q1perp * st0.x + q0perp * st1.x;\\n\\t\\tvec3 B = q1perp * st0.y + q0perp * st1.y;\\n\\t\\tfloat det = max( dot( T, T ), dot( B, B ) );\\n\\t\\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\\n\\t\\treturn mat3( T * scale, B * scale, N );\\n\\t}\\n#endif\";\n\nvar clearcoat_normal_fragment_begin = \"#ifdef USE_CLEARCOAT\\n\\tvec3 clearcoatNormal = geometryNormal;\\n#endif\";\n\nvar clearcoat_normal_fragment_maps = \"#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\\n\\tclearcoatMapN.xy *= clearcoatNormalScale;\\n\\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\\n#endif\";\n\nvar clearcoat_pars_fragment = \"#ifdef USE_CLEARCOATMAP\\n\\tuniform sampler2D clearcoatMap;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tuniform sampler2D clearcoatNormalMap;\\n\\tuniform vec2 clearcoatNormalScale;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tuniform sampler2D clearcoatRoughnessMap;\\n#endif\";\n\nvar iridescence_pars_fragment = \"#ifdef USE_IRIDESCENCEMAP\\n\\tuniform sampler2D iridescenceMap;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\tuniform sampler2D iridescenceThicknessMap;\\n#endif\";\n\nvar opaque_fragment = \"#ifdef OPAQUE\\ndiffuseColor.a = 1.0;\\n#endif\\n#ifdef USE_TRANSMISSION\\ndiffuseColor.a *= material.transmissionAlpha;\\n#endif\\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\";\n\nvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nvec2 packDepthToRG( in highp float v ) {\\n\\treturn packDepthToRGBA( v ).yx;\\n}\\nfloat unpackRGToDepth( const in highp vec2 v ) {\\n\\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\\n}\\nvec4 pack2HalfToRGBA( vec2 v ) {\\n\\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\\n\\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\\n}\\nvec2 unpackRGBATo2Half( vec4 v ) {\\n\\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\\n\\treturn depth * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * depth - far );\\n}\";\n\nvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\";\n\nvar project_vertex = \"vec4 mvPosition = vec4( transformed, 1.0 );\\n#ifdef USE_INSTANCING\\n\\tmvPosition = instanceMatrix * mvPosition;\\n#endif\\nmvPosition = modelViewMatrix * mvPosition;\\ngl_Position = projectionMatrix * mvPosition;\";\n\nvar dithering_fragment = \"#ifdef DITHERING\\n\\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\";\n\nvar dithering_pars_fragment = \"#ifdef DITHERING\\n\\tvec3 dithering( vec3 color ) {\\n\\t\\tfloat grid_position = rand( gl_FragCoord.xy );\\n\\t\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\\t\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\\t\\treturn color + dither_shift_RGB;\\n\\t}\\n#endif\";\n\nvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\";\n\nvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif\";\n\nvar shadowmap_pars_fragment = \"#if NUM_SPOT_LIGHT_COORDS > 0\\n\\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\\n#endif\\n#if NUM_SPOT_LIGHT_MAPS > 0\\n\\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\\n#endif\\n#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\\n\\t\\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\\n\\t}\\n\\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\\n\\t\\tfloat occlusion = 1.0;\\n\\t\\tvec2 distribution = texture2DDistribution( shadow, uv );\\n\\t\\tfloat hard_shadow = step( compare , distribution.x );\\n\\t\\tif (hard_shadow != 1.0 ) {\\n\\t\\t\\tfloat distance = compare - distribution.x ;\\n\\t\\t\\tfloat variance = max( 0.00000, distribution.y * distribution.y );\\n\\t\\t\\tfloat softness_probability = variance / (variance + distance * distance );\\t\\t\\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\\t\\t\\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\\n\\t\\t}\\n\\t\\treturn occlusion;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\\n\\t\\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx2 = dx0 / 2.0;\\n\\t\\t\\tfloat dy2 = dy0 / 2.0;\\n\\t\\t\\tfloat dx3 = dx1 / 2.0;\\n\\t\\t\\tfloat dy3 = dy1 / 2.0;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 17.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx = texelSize.x;\\n\\t\\t\\tfloat dy = texelSize.y;\\n\\t\\t\\tvec2 uv = shadowCoord.xy;\\n\\t\\t\\tvec2 f = fract( uv * shadowMapSize + 0.5 );\\n\\t\\t\\tuv -= f * texelSize;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.x ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t f.y ) +\\n\\t\\t\\t\\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  f.x ),\\n\\t\\t\\t\\t\\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\\n\\t\\t\\t\\t\\t\\t  f.x ),\\n\\t\\t\\t\\t\\t f.y )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\t\\tdp += shadowBias;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\";\n\nvar shadowmap_pars_vertex = \"#if NUM_SPOT_LIGHT_COORDS > 0\\n\\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\\n\\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\\n#endif\\n#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t\\tstruct DirectionalLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\t\\tstruct SpotLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t};\\n\\t\\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t\\tstruct PointLightShadow {\\n\\t\\t\\tfloat shadowBias;\\n\\t\\t\\tfloat shadowNormalBias;\\n\\t\\t\\tfloat shadowRadius;\\n\\t\\t\\tvec2 shadowMapSize;\\n\\t\\t\\tfloat shadowCameraNear;\\n\\t\\t\\tfloat shadowCameraFar;\\n\\t\\t};\\n\\t\\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\\t#endif\\n#endif\";\n\nvar shadowmap_vertex = \"#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\\n\\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\tvec4 shadowWorldPosition;\\n#endif\\n#if defined( USE_SHADOWMAP )\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\t\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\t\\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\\n\\t\\t\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\t#endif\\n#endif\\n#if NUM_SPOT_LIGHT_COORDS > 0\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\\n\\t\\tshadowWorldPosition = worldPosition;\\n\\t\\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\t\\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\\n\\t\\t#endif\\n\\t\\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\\n\\t}\\n\\t#pragma unroll_loop_end\\n#endif\";\n\nvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tspotLight = spotLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLight;\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\\t\\tpointLight = pointLightShadows[ i ];\\n\\t\\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\";\n\nvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\n\nvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\\tuniform mat4 bindMatrix;\\n\\tuniform mat4 bindMatrixInverse;\\n\\tuniform highp sampler2D boneTexture;\\n\\tuniform int boneTextureSize;\\n\\tmat4 getBoneMatrix( const in float i ) {\\n\\t\\tfloat j = i * 4.0;\\n\\t\\tfloat x = mod( j, float( boneTextureSize ) );\\n\\t\\tfloat y = floor( j / float( boneTextureSize ) );\\n\\t\\tfloat dx = 1.0 / float( boneTextureSize );\\n\\t\\tfloat dy = 1.0 / float( boneTextureSize );\\n\\t\\ty = dy * ( y + 0.5 );\\n\\t\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\\t\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\\t\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\\t\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\t\\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\\t\\treturn bone;\\n\\t}\\n#endif\";\n\nvar skinning_vertex = \"#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\";\n\nvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\\t#ifdef USE_TANGENT\\n\\t\\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\\t#endif\\n#endif\";\n\nvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\\n\\tspecularStrength = texelSpecular.r;\\n#else\\n\\tspecularStrength = 1.0;\\n#endif\";\n\nvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\\tuniform sampler2D specularMap;\\n#endif\";\n\nvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n\\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\";\n\nvar tonemapping_pars_fragment = \"#ifndef saturate\\n#define saturate( a ) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn saturate( toneMappingExposure * color );\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 RRTAndODTFit( vec3 v ) {\\n\\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\\n\\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\\n\\treturn a / b;\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\\tconst mat3 ACESInputMat = mat3(\\n\\t\\tvec3( 0.59719, 0.07600, 0.02840 ),\\t\\tvec3( 0.35458, 0.90834, 0.13383 ),\\n\\t\\tvec3( 0.04823, 0.01566, 0.83777 )\\n\\t);\\n\\tconst mat3 ACESOutputMat = mat3(\\n\\t\\tvec3(  1.60475, -0.10208, -0.00327 ),\\t\\tvec3( -0.53108,  1.10813, -0.07276 ),\\n\\t\\tvec3( -0.07367, -0.00605,  1.07602 )\\n\\t);\\n\\tcolor *= toneMappingExposure / 0.6;\\n\\tcolor = ACESInputMat * color;\\n\\tcolor = RRTAndODTFit( color );\\n\\tcolor = ACESOutputMat * color;\\n\\treturn saturate( color );\\n}\\nvec3 CustomToneMapping( vec3 color ) { return color; }\";\n\nvar transmission_fragment = \"#ifdef USE_TRANSMISSION\\n\\tmaterial.transmission = transmission;\\n\\tmaterial.transmissionAlpha = 1.0;\\n\\tmaterial.thickness = thickness;\\n\\tmaterial.attenuationDistance = attenuationDistance;\\n\\tmaterial.attenuationColor = attenuationColor;\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\\n\\t#endif\\n\\tvec3 pos = vWorldPosition;\\n\\tvec3 v = normalize( cameraPosition - pos );\\n\\tvec3 n = inverseTransformDirection( normal, viewMatrix );\\n\\tvec4 transmitted = getIBLVolumeRefraction(\\n\\t\\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\\n\\t\\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\\n\\t\\tmaterial.attenuationColor, material.attenuationDistance );\\n\\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\\n\\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\\n#endif\";\n\nvar transmission_pars_fragment = \"#ifdef USE_TRANSMISSION\\n\\tuniform float transmission;\\n\\tuniform float thickness;\\n\\tuniform float attenuationDistance;\\n\\tuniform vec3 attenuationColor;\\n\\t#ifdef USE_TRANSMISSIONMAP\\n\\t\\tuniform sampler2D transmissionMap;\\n\\t#endif\\n\\t#ifdef USE_THICKNESSMAP\\n\\t\\tuniform sampler2D thicknessMap;\\n\\t#endif\\n\\tuniform vec2 transmissionSamplerSize;\\n\\tuniform sampler2D transmissionSamplerMap;\\n\\tuniform mat4 modelMatrix;\\n\\tuniform mat4 projectionMatrix;\\n\\tvarying vec3 vWorldPosition;\\n\\tfloat w0( float a ) {\\n\\t\\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\\n\\t}\\n\\tfloat w1( float a ) {\\n\\t\\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\\n\\t}\\n\\tfloat w2( float a ){\\n\\t\\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\\n\\t}\\n\\tfloat w3( float a ) {\\n\\t\\treturn ( 1.0 / 6.0 ) * ( a * a * a );\\n\\t}\\n\\tfloat g0( float a ) {\\n\\t\\treturn w0( a ) + w1( a );\\n\\t}\\n\\tfloat g1( float a ) {\\n\\t\\treturn w2( a ) + w3( a );\\n\\t}\\n\\tfloat h0( float a ) {\\n\\t\\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\\n\\t}\\n\\tfloat h1( float a ) {\\n\\t\\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\\n\\t}\\n\\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\\n\\t\\tuv = uv * texelSize.zw + 0.5;\\n\\t\\tvec2 iuv = floor( uv );\\n\\t\\tvec2 fuv = fract( uv );\\n\\t\\tfloat g0x = g0( fuv.x );\\n\\t\\tfloat g1x = g1( fuv.x );\\n\\t\\tfloat h0x = h0( fuv.x );\\n\\t\\tfloat h1x = h1( fuv.x );\\n\\t\\tfloat h0y = h0( fuv.y );\\n\\t\\tfloat h1y = h1( fuv.y );\\n\\t\\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\\n\\t\\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\\n\\t\\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\\n\\t\\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\\n\\t\\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\\n\\t\\t\\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\\n\\t}\\n\\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\\n\\t\\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\\n\\t\\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\\n\\t\\tvec2 fLodSizeInv = 1.0 / fLodSize;\\n\\t\\tvec2 cLodSizeInv = 1.0 / cLodSize;\\n\\t\\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\\n\\t\\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\\n\\t\\treturn mix( fSample, cSample, fract( lod ) );\\n\\t}\\n\\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\\n\\t\\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\\n\\t\\tvec3 modelScale;\\n\\t\\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\\n\\t\\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\\n\\t\\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\\n\\t\\treturn normalize( refractionVector ) * thickness * modelScale;\\n\\t}\\n\\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\\n\\t\\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\\n\\t}\\n\\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\\n\\t\\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\\n\\t\\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\\n\\t}\\n\\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\\n\\t\\tif ( isinf( attenuationDistance ) ) {\\n\\t\\t\\treturn vec3( 1.0 );\\n\\t\\t} else {\\n\\t\\t\\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\\n\\t\\t\\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\\t\\t\\treturn transmittance;\\n\\t\\t}\\n\\t}\\n\\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\\n\\t\\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\\n\\t\\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\\n\\t\\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\\n\\t\\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\\n\\t\\tvec3 refractedRayExit = position + transmissionRay;\\n\\t\\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\\n\\t\\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\\n\\t\\trefractionCoords += 1.0;\\n\\t\\trefractionCoords /= 2.0;\\n\\t\\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\\n\\t\\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\\n\\t\\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\\n\\t\\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\\n\\t\\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\\n\\t\\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\\n\\t}\\n#endif\";\n\nvar uv_pars_fragment = \"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\\n\\tvarying vec2 vUv;\\n#endif\\n#ifdef USE_MAP\\n\\tvarying vec2 vMapUv;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tvarying vec2 vAlphaMapUv;\\n#endif\\n#ifdef USE_LIGHTMAP\\n\\tvarying vec2 vLightMapUv;\\n#endif\\n#ifdef USE_AOMAP\\n\\tvarying vec2 vAoMapUv;\\n#endif\\n#ifdef USE_BUMPMAP\\n\\tvarying vec2 vBumpMapUv;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tvarying vec2 vNormalMapUv;\\n#endif\\n#ifdef USE_EMISSIVEMAP\\n\\tvarying vec2 vEmissiveMapUv;\\n#endif\\n#ifdef USE_METALNESSMAP\\n\\tvarying vec2 vMetalnessMapUv;\\n#endif\\n#ifdef USE_ROUGHNESSMAP\\n\\tvarying vec2 vRoughnessMapUv;\\n#endif\\n#ifdef USE_ANISOTROPYMAP\\n\\tvarying vec2 vAnisotropyMapUv;\\n#endif\\n#ifdef USE_CLEARCOATMAP\\n\\tvarying vec2 vClearcoatMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvarying vec2 vClearcoatNormalMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tvarying vec2 vClearcoatRoughnessMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCEMAP\\n\\tvarying vec2 vIridescenceMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\tvarying vec2 vIridescenceThicknessMapUv;\\n#endif\\n#ifdef USE_SHEEN_COLORMAP\\n\\tvarying vec2 vSheenColorMapUv;\\n#endif\\n#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\tvarying vec2 vSheenRoughnessMapUv;\\n#endif\\n#ifdef USE_SPECULARMAP\\n\\tvarying vec2 vSpecularMapUv;\\n#endif\\n#ifdef USE_SPECULAR_COLORMAP\\n\\tvarying vec2 vSpecularColorMapUv;\\n#endif\\n#ifdef USE_SPECULAR_INTENSITYMAP\\n\\tvarying vec2 vSpecularIntensityMapUv;\\n#endif\\n#ifdef USE_TRANSMISSIONMAP\\n\\tuniform mat3 transmissionMapTransform;\\n\\tvarying vec2 vTransmissionMapUv;\\n#endif\\n#ifdef USE_THICKNESSMAP\\n\\tuniform mat3 thicknessMapTransform;\\n\\tvarying vec2 vThicknessMapUv;\\n#endif\";\n\nvar uv_pars_vertex = \"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\\n\\tvarying vec2 vUv;\\n#endif\\n#ifdef USE_MAP\\n\\tuniform mat3 mapTransform;\\n\\tvarying vec2 vMapUv;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tuniform mat3 alphaMapTransform;\\n\\tvarying vec2 vAlphaMapUv;\\n#endif\\n#ifdef USE_LIGHTMAP\\n\\tuniform mat3 lightMapTransform;\\n\\tvarying vec2 vLightMapUv;\\n#endif\\n#ifdef USE_AOMAP\\n\\tuniform mat3 aoMapTransform;\\n\\tvarying vec2 vAoMapUv;\\n#endif\\n#ifdef USE_BUMPMAP\\n\\tuniform mat3 bumpMapTransform;\\n\\tvarying vec2 vBumpMapUv;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tuniform mat3 normalMapTransform;\\n\\tvarying vec2 vNormalMapUv;\\n#endif\\n#ifdef USE_DISPLACEMENTMAP\\n\\tuniform mat3 displacementMapTransform;\\n\\tvarying vec2 vDisplacementMapUv;\\n#endif\\n#ifdef USE_EMISSIVEMAP\\n\\tuniform mat3 emissiveMapTransform;\\n\\tvarying vec2 vEmissiveMapUv;\\n#endif\\n#ifdef USE_METALNESSMAP\\n\\tuniform mat3 metalnessMapTransform;\\n\\tvarying vec2 vMetalnessMapUv;\\n#endif\\n#ifdef USE_ROUGHNESSMAP\\n\\tuniform mat3 roughnessMapTransform;\\n\\tvarying vec2 vRoughnessMapUv;\\n#endif\\n#ifdef USE_ANISOTROPYMAP\\n\\tuniform mat3 anisotropyMapTransform;\\n\\tvarying vec2 vAnisotropyMapUv;\\n#endif\\n#ifdef USE_CLEARCOATMAP\\n\\tuniform mat3 clearcoatMapTransform;\\n\\tvarying vec2 vClearcoatMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tuniform mat3 clearcoatNormalMapTransform;\\n\\tvarying vec2 vClearcoatNormalMapUv;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tuniform mat3 clearcoatRoughnessMapTransform;\\n\\tvarying vec2 vClearcoatRoughnessMapUv;\\n#endif\\n#ifdef USE_SHEEN_COLORMAP\\n\\tuniform mat3 sheenColorMapTransform;\\n\\tvarying vec2 vSheenColorMapUv;\\n#endif\\n#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\tuniform mat3 sheenRoughnessMapTransform;\\n\\tvarying vec2 vSheenRoughnessMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCEMAP\\n\\tuniform mat3 iridescenceMapTransform;\\n\\tvarying vec2 vIridescenceMapUv;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\tuniform mat3 iridescenceThicknessMapTransform;\\n\\tvarying vec2 vIridescenceThicknessMapUv;\\n#endif\\n#ifdef USE_SPECULARMAP\\n\\tuniform mat3 specularMapTransform;\\n\\tvarying vec2 vSpecularMapUv;\\n#endif\\n#ifdef USE_SPECULAR_COLORMAP\\n\\tuniform mat3 specularColorMapTransform;\\n\\tvarying vec2 vSpecularColorMapUv;\\n#endif\\n#ifdef USE_SPECULAR_INTENSITYMAP\\n\\tuniform mat3 specularIntensityMapTransform;\\n\\tvarying vec2 vSpecularIntensityMapUv;\\n#endif\\n#ifdef USE_TRANSMISSIONMAP\\n\\tuniform mat3 transmissionMapTransform;\\n\\tvarying vec2 vTransmissionMapUv;\\n#endif\\n#ifdef USE_THICKNESSMAP\\n\\tuniform mat3 thicknessMapTransform;\\n\\tvarying vec2 vThicknessMapUv;\\n#endif\";\n\nvar uv_vertex = \"#if defined( USE_UV ) || defined( USE_ANISOTROPY )\\n\\tvUv = vec3( uv, 1 ).xy;\\n#endif\\n#ifdef USE_MAP\\n\\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_LIGHTMAP\\n\\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_AOMAP\\n\\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_BUMPMAP\\n\\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_NORMALMAP\\n\\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_DISPLACEMENTMAP\\n\\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_EMISSIVEMAP\\n\\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_METALNESSMAP\\n\\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_ROUGHNESSMAP\\n\\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_ANISOTROPYMAP\\n\\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_CLEARCOATMAP\\n\\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_IRIDESCENCEMAP\\n\\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\\n\\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SHEEN_COLORMAP\\n\\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SPECULARMAP\\n\\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SPECULAR_COLORMAP\\n\\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_SPECULAR_INTENSITYMAP\\n\\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_TRANSMISSIONMAP\\n\\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\\n#endif\\n#ifdef USE_THICKNESSMAP\\n\\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\\n#endif\";\n\nvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\\n\\tvec4 worldPosition = vec4( transformed, 1.0 );\\n\\t#ifdef USE_INSTANCING\\n\\t\\tworldPosition = instanceMatrix * worldPosition;\\n\\t#endif\\n\\tworldPosition = modelMatrix * worldPosition;\\n#endif\";\n\nconst vertex$h = \"varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\";\n\nconst fragment$h = \"uniform sampler2D t2D;\\nuniform float backgroundIntensity;\\nvarying vec2 vUv;\\nvoid main() {\\n\\tvec4 texColor = texture2D( t2D, vUv );\\n\\ttexColor.rgb *= backgroundIntensity;\\n\\tgl_FragColor = texColor;\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n}\";\n\nconst vertex$g = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\";\n\nconst fragment$g = \"#ifdef ENVMAP_TYPE_CUBE\\n\\tuniform samplerCube envMap;\\n#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\tuniform sampler2D envMap;\\n#endif\\nuniform float flipEnvMap;\\nuniform float backgroundBlurriness;\\nuniform float backgroundIntensity;\\nvarying vec3 vWorldDirection;\\n#include <cube_uv_reflection_fragment>\\nvoid main() {\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\\t\\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\\n\\t#else\\n\\t\\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\t#endif\\n\\ttexColor.rgb *= backgroundIntensity;\\n\\tgl_FragColor = texColor;\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n}\";\n\nconst vertex$f = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n\\tgl_Position.z = gl_Position.w;\\n}\";\n\nconst fragment$f = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\nvoid main() {\\n\\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\\n\\tgl_FragColor = texColor;\\n\\tgl_FragColor.a *= opacity;\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n}\";\n\nconst vertex$e = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvHighPrecisionZW = gl_Position.zw;\\n}\";\n\nconst fragment$e = \"#if DEPTH_PACKING == 3200\\n\\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tdiffuseColor.a = opacity;\\n\\t#endif\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\\n\\t#if DEPTH_PACKING == 3200\\n\\t\\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\\n\\t#elif DEPTH_PACKING == 3201\\n\\t\\tgl_FragColor = packDepthToRGBA( fragCoordZ );\\n\\t#endif\\n}\";\n\nconst vertex$d = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition.xyz;\\n}\";\n\nconst fragment$d = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( 1.0 );\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\tfloat dist = length( vWorldPosition - referencePosition );\\n\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\\tdist = saturate( dist );\\n\\tgl_FragColor = packDepthToRGBA( dist );\\n}\";\n\nconst vertex$c = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvWorldDirection = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\";\n\nconst fragment$c = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldDirection );\\n\\tvec2 sampleUV = equirectUv( direction );\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n}\";\n\nconst vertex$b = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\tvLineDistance = scale * lineDistance;\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$b = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\n\nconst vertex$a = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinbase_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$a = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <specularmap_fragment>\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\t#ifdef USE_LIGHTMAP\\n\\t\\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\\n\\t\\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\\n\\t#else\\n\\t\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\\t#endif\\n\\t#include <aomap_fragment>\\n\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\t#include <envmap_fragment>\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$9 = \"#define LAMBERT\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$9 = \"#define LAMBERT\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_lambert_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_lambert_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$8 = \"#define MATCAP\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n}\";\n\nconst fragment$8 = \"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <normal_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tvec3 viewDir = normalize( vViewPosition );\\n\\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\\tvec3 y = cross( viewDir, x );\\n\\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\\t#ifdef USE_MATCAP\\n\\t\\tvec4 matcapColor = texture2D( matcap, uv );\\n\\t#else\\n\\t\\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\\n\\t#endif\\n\\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$7 = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\";\n\nconst fragment$7 = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <normal_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n\\t#ifdef OPAQUE\\n\\t\\tgl_FragColor.a = 1.0;\\n\\t#endif\\n}\";\n\nconst vertex$6 = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$6 = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$5 = \"#define STANDARD\\nvarying vec3 vViewPosition;\\n#ifdef USE_TRANSMISSION\\n\\tvarying vec3 vWorldPosition;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n#ifdef USE_TRANSMISSION\\n\\tvWorldPosition = worldPosition.xyz;\\n#endif\\n}\";\n\nconst fragment$5 = \"#define STANDARD\\n#ifdef PHYSICAL\\n\\t#define IOR\\n\\t#define USE_SPECULAR\\n#endif\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifdef IOR\\n\\tuniform float ior;\\n#endif\\n#ifdef USE_SPECULAR\\n\\tuniform float specularIntensity;\\n\\tuniform vec3 specularColor;\\n\\t#ifdef USE_SPECULAR_COLORMAP\\n\\t\\tuniform sampler2D specularColorMap;\\n\\t#endif\\n\\t#ifdef USE_SPECULAR_INTENSITYMAP\\n\\t\\tuniform sampler2D specularIntensityMap;\\n\\t#endif\\n#endif\\n#ifdef USE_CLEARCOAT\\n\\tuniform float clearcoat;\\n\\tuniform float clearcoatRoughness;\\n#endif\\n#ifdef USE_IRIDESCENCE\\n\\tuniform float iridescence;\\n\\tuniform float iridescenceIOR;\\n\\tuniform float iridescenceThicknessMinimum;\\n\\tuniform float iridescenceThicknessMaximum;\\n#endif\\n#ifdef USE_SHEEN\\n\\tuniform vec3 sheenColor;\\n\\tuniform float sheenRoughness;\\n\\t#ifdef USE_SHEEN_COLORMAP\\n\\t\\tuniform sampler2D sheenColorMap;\\n\\t#endif\\n\\t#ifdef USE_SHEEN_ROUGHNESSMAP\\n\\t\\tuniform sampler2D sheenRoughnessMap;\\n\\t#endif\\n#endif\\n#ifdef USE_ANISOTROPY\\n\\tuniform vec2 anisotropyVector;\\n\\t#ifdef USE_ANISOTROPYMAP\\n\\t\\tuniform sampler2D anisotropyMap;\\n\\t#endif\\n#endif\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <iridescence_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_physical_pars_fragment>\\n#include <transmission_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <clearcoat_pars_fragment>\\n#include <iridescence_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <clearcoat_normal_fragment_begin>\\n\\t#include <clearcoat_normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\\n\\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\\n\\t#include <transmission_fragment>\\n\\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\\n\\t#ifdef USE_SHEEN\\n\\t\\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\\n\\t\\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\\n\\t#endif\\n\\t#ifdef USE_CLEARCOAT\\n\\t\\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\\n\\t\\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\\n\\t\\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\\n\\t#endif\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$4 = \"#define TOON\\nvarying vec3 vViewPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <normal_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <color_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <normal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$4 = \"#define TOON\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <normal_pars_fragment>\\n#include <lights_toon_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\t#include <normal_fragment_begin>\\n\\t#include <normal_fragment_maps>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_toon_fragment>\\n\\t#include <lights_fragment_begin>\\n\\t#include <lights_fragment_maps>\\n\\t#include <lights_fragment_end>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\";\n\nconst vertex$3 = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\n#ifdef USE_POINTS_UV\\n\\tvarying vec2 vUv;\\n\\tuniform mat3 uvTransform;\\n#endif\\nvoid main() {\\n\\t#ifdef USE_POINTS_UV\\n\\t\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\\t#endif\\n\\t#include <color_vertex>\\n\\t#include <morphcolor_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <project_vertex>\\n\\tgl_PointSize = size;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$3 = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n}\";\n\nconst vertex$2 = \"#include <common>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$2 = \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <logdepthbuf_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\t#include <logdepthbuf_fragment>\\n\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nconst vertex$1 = \"uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec2 scale;\\n\\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\\t#ifndef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\\t\\tif ( isPerspective ) scale *= - mvPosition.z;\\n\\t#endif\\n\\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\\tvec2 rotatedPosition;\\n\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\\tmvPosition.xy += rotatedPosition;\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <fog_vertex>\\n}\";\n\nconst fragment$1 = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <alphatest_pars_fragment>\\n#include <alphahash_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <alphahash_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\t#include <opaque_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <colorspace_fragment>\\n\\t#include <fog_fragment>\\n}\";\n\nconst ShaderChunk = {\n\talphahash_fragment: alphahash_fragment,\n\talphahash_pars_fragment: alphahash_pars_fragment,\n\talphamap_fragment: alphamap_fragment,\n\talphamap_pars_fragment: alphamap_pars_fragment,\n\talphatest_fragment: alphatest_fragment,\n\talphatest_pars_fragment: alphatest_pars_fragment,\n\taomap_fragment: aomap_fragment,\n\taomap_pars_fragment: aomap_pars_fragment,\n\tbegin_vertex: begin_vertex,\n\tbeginnormal_vertex: beginnormal_vertex,\n\tbsdfs: bsdfs,\n\tiridescence_fragment: iridescence_fragment,\n\tbumpmap_pars_fragment: bumpmap_pars_fragment,\n\tclipping_planes_fragment: clipping_planes_fragment,\n\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\n\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\n\tclipping_planes_vertex: clipping_planes_vertex,\n\tcolor_fragment: color_fragment,\n\tcolor_pars_fragment: color_pars_fragment,\n\tcolor_pars_vertex: color_pars_vertex,\n\tcolor_vertex: color_vertex,\n\tcommon: common,\n\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\n\tdefaultnormal_vertex: defaultnormal_vertex,\n\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\n\tdisplacementmap_vertex: displacementmap_vertex,\n\temissivemap_fragment: emissivemap_fragment,\n\temissivemap_pars_fragment: emissivemap_pars_fragment,\n\tcolorspace_fragment: colorspace_fragment,\n\tcolorspace_pars_fragment: colorspace_pars_fragment,\n\tenvmap_fragment: envmap_fragment,\n\tenvmap_common_pars_fragment: envmap_common_pars_fragment,\n\tenvmap_pars_fragment: envmap_pars_fragment,\n\tenvmap_pars_vertex: envmap_pars_vertex,\n\tenvmap_physical_pars_fragment: envmap_physical_pars_fragment,\n\tenvmap_vertex: envmap_vertex,\n\tfog_vertex: fog_vertex,\n\tfog_pars_vertex: fog_pars_vertex,\n\tfog_fragment: fog_fragment,\n\tfog_pars_fragment: fog_pars_fragment,\n\tgradientmap_pars_fragment: gradientmap_pars_fragment,\n\tlightmap_fragment: lightmap_fragment,\n\tlightmap_pars_fragment: lightmap_pars_fragment,\n\tlights_lambert_fragment: lights_lambert_fragment,\n\tlights_lambert_pars_fragment: lights_lambert_pars_fragment,\n\tlights_pars_begin: lights_pars_begin,\n\tlights_toon_fragment: lights_toon_fragment,\n\tlights_toon_pars_fragment: lights_toon_pars_fragment,\n\tlights_phong_fragment: lights_phong_fragment,\n\tlights_phong_pars_fragment: lights_phong_pars_fragment,\n\tlights_physical_fragment: lights_physical_fragment,\n\tlights_physical_pars_fragment: lights_physical_pars_fragment,\n\tlights_fragment_begin: lights_fragment_begin,\n\tlights_fragment_maps: lights_fragment_maps,\n\tlights_fragment_end: lights_fragment_end,\n\tlogdepthbuf_fragment: logdepthbuf_fragment,\n\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\n\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\n\tlogdepthbuf_vertex: logdepthbuf_vertex,\n\tmap_fragment: map_fragment,\n\tmap_pars_fragment: map_pars_fragment,\n\tmap_particle_fragment: map_particle_fragment,\n\tmap_particle_pars_fragment: map_particle_pars_fragment,\n\tmetalnessmap_fragment: metalnessmap_fragment,\n\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\n\tmorphcolor_vertex: morphcolor_vertex,\n\tmorphnormal_vertex: morphnormal_vertex,\n\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\n\tmorphtarget_vertex: morphtarget_vertex,\n\tnormal_fragment_begin: normal_fragment_begin,\n\tnormal_fragment_maps: normal_fragment_maps,\n\tnormal_pars_fragment: normal_pars_fragment,\n\tnormal_pars_vertex: normal_pars_vertex,\n\tnormal_vertex: normal_vertex,\n\tnormalmap_pars_fragment: normalmap_pars_fragment,\n\tclearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,\n\tclearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,\n\tclearcoat_pars_fragment: clearcoat_pars_fragment,\n\tiridescence_pars_fragment: iridescence_pars_fragment,\n\topaque_fragment: opaque_fragment,\n\tpacking: packing,\n\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\n\tproject_vertex: project_vertex,\n\tdithering_fragment: dithering_fragment,\n\tdithering_pars_fragment: dithering_pars_fragment,\n\troughnessmap_fragment: roughnessmap_fragment,\n\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\n\tshadowmap_pars_fragment: shadowmap_pars_fragment,\n\tshadowmap_pars_vertex: shadowmap_pars_vertex,\n\tshadowmap_vertex: shadowmap_vertex,\n\tshadowmask_pars_fragment: shadowmask_pars_fragment,\n\tskinbase_vertex: skinbase_vertex,\n\tskinning_pars_vertex: skinning_pars_vertex,\n\tskinning_vertex: skinning_vertex,\n\tskinnormal_vertex: skinnormal_vertex,\n\tspecularmap_fragment: specularmap_fragment,\n\tspecularmap_pars_fragment: specularmap_pars_fragment,\n\ttonemapping_fragment: tonemapping_fragment,\n\ttonemapping_pars_fragment: tonemapping_pars_fragment,\n\ttransmission_fragment: transmission_fragment,\n\ttransmission_pars_fragment: transmission_pars_fragment,\n\tuv_pars_fragment: uv_pars_fragment,\n\tuv_pars_vertex: uv_pars_vertex,\n\tuv_vertex: uv_vertex,\n\tworldpos_vertex: worldpos_vertex,\n\n\tbackground_vert: vertex$h,\n\tbackground_frag: fragment$h,\n\tbackgroundCube_vert: vertex$g,\n\tbackgroundCube_frag: fragment$g,\n\tcube_vert: vertex$f,\n\tcube_frag: fragment$f,\n\tdepth_vert: vertex$e,\n\tdepth_frag: fragment$e,\n\tdistanceRGBA_vert: vertex$d,\n\tdistanceRGBA_frag: fragment$d,\n\tequirect_vert: vertex$c,\n\tequirect_frag: fragment$c,\n\tlinedashed_vert: vertex$b,\n\tlinedashed_frag: fragment$b,\n\tmeshbasic_vert: vertex$a,\n\tmeshbasic_frag: fragment$a,\n\tmeshlambert_vert: vertex$9,\n\tmeshlambert_frag: fragment$9,\n\tmeshmatcap_vert: vertex$8,\n\tmeshmatcap_frag: fragment$8,\n\tmeshnormal_vert: vertex$7,\n\tmeshnormal_frag: fragment$7,\n\tmeshphong_vert: vertex$6,\n\tmeshphong_frag: fragment$6,\n\tmeshphysical_vert: vertex$5,\n\tmeshphysical_frag: fragment$5,\n\tmeshtoon_vert: vertex$4,\n\tmeshtoon_frag: fragment$4,\n\tpoints_vert: vertex$3,\n\tpoints_frag: fragment$3,\n\tshadow_vert: vertex$2,\n\tshadow_frag: fragment$2,\n\tsprite_vert: vertex$1,\n\tsprite_frag: fragment$1\n};\n\n/**\n * Uniforms library for shared webgl shaders\n */\n\nconst UniformsLib = {\n\n\tcommon: {\n\n\t\tdiffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },\n\t\topacity: { value: 1.0 },\n\n\t\tmap: { value: null },\n\t\tmapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\n\t\talphaMap: { value: null },\n\t\talphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\n\t\talphaTest: { value: 0 }\n\n\t},\n\n\tspecularmap: {\n\n\t\tspecularMap: { value: null },\n\t\tspecularMapTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\tenvmap: {\n\n\t\tenvMap: { value: null },\n\t\tflipEnvMap: { value: - 1 },\n\t\treflectivity: { value: 1.0 }, // basic, lambert, phong\n\t\tior: { value: 1.5 }, // physical\n\t\trefractionRatio: { value: 0.98 }, // basic, lambert, phong\n\n\t},\n\n\taomap: {\n\n\t\taoMap: { value: null },\n\t\taoMapIntensity: { value: 1 },\n\t\taoMapTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\tlightmap: {\n\n\t\tlightMap: { value: null },\n\t\tlightMapIntensity: { value: 1 },\n\t\tlightMapTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\tbumpmap: {\n\n\t\tbumpMap: { value: null },\n\t\tbumpMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\tbumpScale: { value: 1 }\n\n\t},\n\n\tnormalmap: {\n\n\t\tnormalMap: { value: null },\n\t\tnormalMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\tnormalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) }\n\n\t},\n\n\tdisplacementmap: {\n\n\t\tdisplacementMap: { value: null },\n\t\tdisplacementMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\tdisplacementScale: { value: 1 },\n\t\tdisplacementBias: { value: 0 }\n\n\t},\n\n\temissivemap: {\n\n\t\temissiveMap: { value: null },\n\t\temissiveMapTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\tmetalnessmap: {\n\n\t\tmetalnessMap: { value: null },\n\t\tmetalnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\troughnessmap: {\n\n\t\troughnessMap: { value: null },\n\t\troughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\tgradientmap: {\n\n\t\tgradientMap: { value: null }\n\n\t},\n\n\tfog: {\n\n\t\tfogDensity: { value: 0.00025 },\n\t\tfogNear: { value: 1 },\n\t\tfogFar: { value: 2000 },\n\t\tfogColor: { value: /*@__PURE__*/ new Color( 0xffffff ) }\n\n\t},\n\n\tlights: {\n\n\t\tambientLightColor: { value: [] },\n\n\t\tlightProbe: { value: [] },\n\n\t\tdirectionalLights: { value: [], properties: {\n\t\t\tdirection: {},\n\t\t\tcolor: {}\n\t\t} },\n\n\t\tdirectionalLightShadows: { value: [], properties: {\n\t\t\tshadowBias: {},\n\t\t\tshadowNormalBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {}\n\t\t} },\n\n\t\tdirectionalShadowMap: { value: [] },\n\t\tdirectionalShadowMatrix: { value: [] },\n\n\t\tspotLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\tdirection: {},\n\t\t\tdistance: {},\n\t\t\tconeCos: {},\n\t\t\tpenumbraCos: {},\n\t\t\tdecay: {}\n\t\t} },\n\n\t\tspotLightShadows: { value: [], properties: {\n\t\t\tshadowBias: {},\n\t\t\tshadowNormalBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {}\n\t\t} },\n\n\t\tspotLightMap: { value: [] },\n\t\tspotShadowMap: { value: [] },\n\t\tspotLightMatrix: { value: [] },\n\n\t\tpointLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\tdecay: {},\n\t\t\tdistance: {}\n\t\t} },\n\n\t\tpointLightShadows: { value: [], properties: {\n\t\t\tshadowBias: {},\n\t\t\tshadowNormalBias: {},\n\t\t\tshadowRadius: {},\n\t\t\tshadowMapSize: {},\n\t\t\tshadowCameraNear: {},\n\t\t\tshadowCameraFar: {}\n\t\t} },\n\n\t\tpointShadowMap: { value: [] },\n\t\tpointShadowMatrix: { value: [] },\n\n\t\themisphereLights: { value: [], properties: {\n\t\t\tdirection: {},\n\t\t\tskyColor: {},\n\t\t\tgroundColor: {}\n\t\t} },\n\n\t\t// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\n\t\trectAreaLights: { value: [], properties: {\n\t\t\tcolor: {},\n\t\t\tposition: {},\n\t\t\twidth: {},\n\t\t\theight: {}\n\t\t} },\n\n\t\tltc_1: { value: null },\n\t\tltc_2: { value: null }\n\n\t},\n\n\tpoints: {\n\n\t\tdiffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },\n\t\topacity: { value: 1.0 },\n\t\tsize: { value: 1.0 },\n\t\tscale: { value: 1.0 },\n\t\tmap: { value: null },\n\t\talphaMap: { value: null },\n\t\talphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\talphaTest: { value: 0 },\n\t\tuvTransform: { value: /*@__PURE__*/ new Matrix3() }\n\n\t},\n\n\tsprite: {\n\n\t\tdiffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },\n\t\topacity: { value: 1.0 },\n\t\tcenter: { value: /*@__PURE__*/ new Vector2( 0.5, 0.5 ) },\n\t\trotation: { value: 0.0 },\n\t\tmap: { value: null },\n\t\tmapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\talphaMap: { value: null },\n\t\talphaMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\talphaTest: { value: 0 }\n\n\t}\n\n};\n\nconst ShaderLib = {\n\n\tbasic: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshbasic_vert,\n\t\tfragmentShader: ShaderChunk.meshbasic_frag\n\n\t},\n\n\tlambert: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshlambert_vert,\n\t\tfragmentShader: ShaderChunk.meshlambert_frag\n\n\t},\n\n\tphong: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.specularmap,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },\n\t\t\t\tspecular: { value: /*@__PURE__*/ new Color( 0x111111 ) },\n\t\t\t\tshininess: { value: 30 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphong_vert,\n\t\tfragmentShader: ShaderChunk.meshphong_frag\n\n\t},\n\n\tstandard: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.envmap,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.roughnessmap,\n\t\t\tUniformsLib.metalnessmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },\n\t\t\t\troughness: { value: 1.0 },\n\t\t\t\tmetalness: { value: 0.0 },\n\t\t\t\tenvMapIntensity: { value: 1 } // temporary\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshphysical_vert,\n\t\tfragmentShader: ShaderChunk.meshphysical_frag\n\n\t},\n\n\ttoon: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.aomap,\n\t\t\tUniformsLib.lightmap,\n\t\t\tUniformsLib.emissivemap,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.gradientmap,\n\t\t\tUniformsLib.fog,\n\t\t\tUniformsLib.lights,\n\t\t\t{\n\t\t\t\temissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshtoon_vert,\n\t\tfragmentShader: ShaderChunk.meshtoon_frag\n\n\t},\n\n\tmatcap: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tmatcap: { value: null }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshmatcap_vert,\n\t\tfragmentShader: ShaderChunk.meshmatcap_frag\n\n\t},\n\n\tpoints: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.points,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.points_vert,\n\t\tfragmentShader: ShaderChunk.points_frag\n\n\t},\n\n\tdashed: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tscale: { value: 1 },\n\t\t\t\tdashSize: { value: 1 },\n\t\t\t\ttotalSize: { value: 2 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.linedashed_vert,\n\t\tfragmentShader: ShaderChunk.linedashed_frag\n\n\t},\n\n\tdepth: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.displacementmap\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.depth_vert,\n\t\tfragmentShader: ShaderChunk.depth_frag\n\n\t},\n\n\tnormal: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.bumpmap,\n\t\t\tUniformsLib.normalmap,\n\t\t\tUniformsLib.displacementmap,\n\t\t\t{\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.meshnormal_vert,\n\t\tfragmentShader: ShaderChunk.meshnormal_frag\n\n\t},\n\n\tsprite: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.sprite,\n\t\t\tUniformsLib.fog\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.sprite_vert,\n\t\tfragmentShader: ShaderChunk.sprite_frag\n\n\t},\n\n\tbackground: {\n\n\t\tuniforms: {\n\t\t\tuvTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tt2D: { value: null },\n\t\t\tbackgroundIntensity: { value: 1 }\n\t\t},\n\n\t\tvertexShader: ShaderChunk.background_vert,\n\t\tfragmentShader: ShaderChunk.background_frag\n\n\t},\n\n\tbackgroundCube: {\n\n\t\tuniforms: {\n\t\t\tenvMap: { value: null },\n\t\t\tflipEnvMap: { value: - 1 },\n\t\t\tbackgroundBlurriness: { value: 0 },\n\t\t\tbackgroundIntensity: { value: 1 }\n\t\t},\n\n\t\tvertexShader: ShaderChunk.backgroundCube_vert,\n\t\tfragmentShader: ShaderChunk.backgroundCube_frag\n\n\t},\n\n\tcube: {\n\n\t\tuniforms: {\n\t\t\ttCube: { value: null },\n\t\t\ttFlip: { value: - 1 },\n\t\t\topacity: { value: 1.0 }\n\t\t},\n\n\t\tvertexShader: ShaderChunk.cube_vert,\n\t\tfragmentShader: ShaderChunk.cube_frag\n\n\t},\n\n\tequirect: {\n\n\t\tuniforms: {\n\t\t\ttEquirect: { value: null },\n\t\t},\n\n\t\tvertexShader: ShaderChunk.equirect_vert,\n\t\tfragmentShader: ShaderChunk.equirect_frag\n\n\t},\n\n\tdistanceRGBA: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.common,\n\t\t\tUniformsLib.displacementmap,\n\t\t\t{\n\t\t\t\treferencePosition: { value: /*@__PURE__*/ new Vector3() },\n\t\t\t\tnearDistance: { value: 1 },\n\t\t\t\tfarDistance: { value: 1000 }\n\t\t\t}\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.distanceRGBA_vert,\n\t\tfragmentShader: ShaderChunk.distanceRGBA_frag\n\n\t},\n\n\tshadow: {\n\n\t\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\t\tUniformsLib.lights,\n\t\t\tUniformsLib.fog,\n\t\t\t{\n\t\t\t\tcolor: { value: /*@__PURE__*/ new Color( 0x00000 ) },\n\t\t\t\topacity: { value: 1.0 }\n\t\t\t},\n\t\t] ),\n\n\t\tvertexShader: ShaderChunk.shadow_vert,\n\t\tfragmentShader: ShaderChunk.shadow_frag\n\n\t}\n\n};\n\nShaderLib.physical = {\n\n\tuniforms: /*@__PURE__*/ mergeUniforms( [\n\t\tShaderLib.standard.uniforms,\n\t\t{\n\t\t\tclearcoat: { value: 0 },\n\t\t\tclearcoatMap: { value: null },\n\t\t\tclearcoatMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tclearcoatNormalMap: { value: null },\n\t\t\tclearcoatNormalMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tclearcoatNormalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) },\n\t\t\tclearcoatRoughness: { value: 0 },\n\t\t\tclearcoatRoughnessMap: { value: null },\n\t\t\tclearcoatRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tiridescence: { value: 0 },\n\t\t\tiridescenceMap: { value: null },\n\t\t\tiridescenceMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tiridescenceIOR: { value: 1.3 },\n\t\t\tiridescenceThicknessMinimum: { value: 100 },\n\t\t\tiridescenceThicknessMaximum: { value: 400 },\n\t\t\tiridescenceThicknessMap: { value: null },\n\t\t\tiridescenceThicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tsheen: { value: 0 },\n\t\t\tsheenColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },\n\t\t\tsheenColorMap: { value: null },\n\t\t\tsheenColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tsheenRoughness: { value: 1 },\n\t\t\tsheenRoughnessMap: { value: null },\n\t\t\tsheenRoughnessMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\ttransmission: { value: 0 },\n\t\t\ttransmissionMap: { value: null },\n\t\t\ttransmissionMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\ttransmissionSamplerSize: { value: /*@__PURE__*/ new Vector2() },\n\t\t\ttransmissionSamplerMap: { value: null },\n\t\t\tthickness: { value: 0 },\n\t\t\tthicknessMap: { value: null },\n\t\t\tthicknessMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tattenuationDistance: { value: 0 },\n\t\t\tattenuationColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },\n\t\t\tspecularColor: { value: /*@__PURE__*/ new Color( 1, 1, 1 ) },\n\t\t\tspecularColorMap: { value: null },\n\t\t\tspecularColorMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tspecularIntensity: { value: 1 },\n\t\t\tspecularIntensityMap: { value: null },\n\t\t\tspecularIntensityMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t\tanisotropyVector: { value: /*@__PURE__*/ new Vector2() },\n\t\t\tanisotropyMap: { value: null },\n\t\t\tanisotropyMapTransform: { value: /*@__PURE__*/ new Matrix3() },\n\t\t}\n\t] ),\n\n\tvertexShader: ShaderChunk.meshphysical_vert,\n\tfragmentShader: ShaderChunk.meshphysical_frag\n\n};\n\nconst _rgb = { r: 0, b: 0, g: 0 };\n\nfunction WebGLBackground( renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha ) {\n\n\tconst clearColor = new Color( 0x000000 );\n\tlet clearAlpha = alpha === true ? 0 : 1;\n\n\tlet planeMesh;\n\tlet boxMesh;\n\n\tlet currentBackground = null;\n\tlet currentBackgroundVersion = 0;\n\tlet currentTonemapping = null;\n\n\tfunction render( renderList, scene ) {\n\n\t\tlet forceClear = false;\n\t\tlet background = scene.isScene === true ? scene.background : null;\n\n\t\tif ( background && background.isTexture ) {\n\n\t\t\tconst usePMREM = scene.backgroundBlurriness > 0; // use PMREM if the user wants to blur the background\n\t\t\tbackground = ( usePMREM ? cubeuvmaps : cubemaps ).get( background );\n\n\t\t}\n\n\t\tif ( background === null ) {\n\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t} else if ( background && background.isColor ) {\n\n\t\t\tsetClear( background, 1 );\n\t\t\tforceClear = true;\n\n\t\t}\n\n\t\tconst xr = renderer.xr;\n\t\tconst environmentBlendMode = xr.getEnvironmentBlendMode();\n\n\t\tswitch ( environmentBlendMode ) {\n\n\t\t\tcase 'opaque':\n\t\t\t\tforceClear = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'additive':\n\t\t\t\tstate.buffers.color.setClear( 0, 0, 0, 1, premultipliedAlpha );\n\t\t\t\tforceClear = true;\n\t\t\t\tbreak;\n\n\t\t\tcase 'alpha-blend':\n\t\t\t\tstate.buffers.color.setClear( 0, 0, 0, 0, premultipliedAlpha );\n\t\t\t\tforceClear = true;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( renderer.autoClear || forceClear ) {\n\n\t\t\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\n\t\t}\n\n\t\tif ( background && ( background.isCubeTexture || background.mapping === CubeUVReflectionMapping ) ) {\n\n\t\t\tif ( boxMesh === undefined ) {\n\n\t\t\t\tboxMesh = new Mesh(\n\t\t\t\t\tnew BoxGeometry( 1, 1, 1 ),\n\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\tname: 'BackgroundCubeMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.backgroundCube.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.backgroundCube.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.backgroundCube.fragmentShader,\n\t\t\t\t\t\tside: BackSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tboxMesh.geometry.deleteAttribute( 'normal' );\n\t\t\t\tboxMesh.geometry.deleteAttribute( 'uv' );\n\n\t\t\t\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\t\t\tthis.matrixWorld.copyPosition( camera.matrixWorld );\n\n\t\t\t\t};\n\n\t\t\t\t// add \"envMap\" material property so the renderer can evaluate it like for built-in materials\n\t\t\t\tObject.defineProperty( boxMesh.material, 'envMap', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.envMap.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( boxMesh );\n\n\t\t\t}\n\n\t\t\tboxMesh.material.uniforms.envMap.value = background;\n\t\t\tboxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background.isRenderTargetTexture === false ) ? - 1 : 1;\n\t\t\tboxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;\n\t\t\tboxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;\n\t\t\tboxMesh.material.toneMapped = ( background.colorSpace === SRGBColorSpace ) ? false : true;\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t\tcurrentBackgroundVersion !== background.version ||\n\t\t\t\tcurrentTonemapping !== renderer.toneMapping ) {\n\n\t\t\t\tboxMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\n\t\t\t}\n\n\t\t\tboxMesh.layers.enableAll();\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );\n\n\t\t} else if ( background && background.isTexture ) {\n\n\t\t\tif ( planeMesh === undefined ) {\n\n\t\t\t\tplaneMesh = new Mesh(\n\t\t\t\t\tnew PlaneGeometry( 2, 2 ),\n\t\t\t\t\tnew ShaderMaterial( {\n\t\t\t\t\t\tname: 'BackgroundMaterial',\n\t\t\t\t\t\tuniforms: cloneUniforms( ShaderLib.background.uniforms ),\n\t\t\t\t\t\tvertexShader: ShaderLib.background.vertexShader,\n\t\t\t\t\t\tfragmentShader: ShaderLib.background.fragmentShader,\n\t\t\t\t\t\tside: FrontSide,\n\t\t\t\t\t\tdepthTest: false,\n\t\t\t\t\t\tdepthWrite: false,\n\t\t\t\t\t\tfog: false\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tplaneMesh.geometry.deleteAttribute( 'normal' );\n\n\t\t\t\t// add \"map\" material property so the renderer can evaluate it like for built-in materials\n\t\t\t\tObject.defineProperty( planeMesh.material, 'map', {\n\n\t\t\t\t\tget: function () {\n\n\t\t\t\t\t\treturn this.uniforms.t2D.value;\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tobjects.update( planeMesh );\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.t2D.value = background;\n\t\t\tplaneMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;\n\t\t\tplaneMesh.material.toneMapped = ( background.colorSpace === SRGBColorSpace ) ? false : true;\n\n\t\t\tif ( background.matrixAutoUpdate === true ) {\n\n\t\t\t\tbackground.updateMatrix();\n\n\t\t\t}\n\n\t\t\tplaneMesh.material.uniforms.uvTransform.value.copy( background.matrix );\n\n\t\t\tif ( currentBackground !== background ||\n\t\t\t\tcurrentBackgroundVersion !== background.version ||\n\t\t\t\tcurrentTonemapping !== renderer.toneMapping ) {\n\n\t\t\t\tplaneMesh.material.needsUpdate = true;\n\n\t\t\t\tcurrentBackground = background;\n\t\t\t\tcurrentBackgroundVersion = background.version;\n\t\t\t\tcurrentTonemapping = renderer.toneMapping;\n\n\t\t\t}\n\n\t\t\tplaneMesh.layers.enableAll();\n\n\t\t\t// push to the pre-sorted opaque render list\n\t\t\trenderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );\n\n\t\t}\n\n\t}\n\n\tfunction setClear( color, alpha ) {\n\n\t\tcolor.getRGB( _rgb, getUnlitUniformColorSpace( renderer ) );\n\n\t\tstate.buffers.color.setClear( _rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha );\n\n\t}\n\n\treturn {\n\n\t\tgetClearColor: function () {\n\n\t\t\treturn clearColor;\n\n\t\t},\n\t\tsetClearColor: function ( color, alpha = 1 ) {\n\n\t\t\tclearColor.set( color );\n\t\t\tclearAlpha = alpha;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\tgetClearAlpha: function () {\n\n\t\t\treturn clearAlpha;\n\n\t\t},\n\t\tsetClearAlpha: function ( alpha ) {\n\n\t\t\tclearAlpha = alpha;\n\t\t\tsetClear( clearColor, clearAlpha );\n\n\t\t},\n\t\trender: render\n\n\t};\n\n}\n\nfunction WebGLBindingStates( gl, extensions, attributes, capabilities ) {\n\n\tconst maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\n\tconst extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );\n\tconst vaoAvailable = capabilities.isWebGL2 || extension !== null;\n\n\tconst bindingStates = {};\n\n\tconst defaultState = createBindingState( null );\n\tlet currentState = defaultState;\n\tlet forceUpdate = false;\n\n\tfunction setup( object, material, program, geometry, index ) {\n\n\t\tlet updateBuffers = false;\n\n\t\tif ( vaoAvailable ) {\n\n\t\t\tconst state = getBindingState( geometry, program, material );\n\n\t\t\tif ( currentState !== state ) {\n\n\t\t\t\tcurrentState = state;\n\t\t\t\tbindVertexArrayObject( currentState.object );\n\n\t\t\t}\n\n\t\t\tupdateBuffers = needsUpdate( object, geometry, program, index );\n\n\t\t\tif ( updateBuffers ) saveCache( object, geometry, program, index );\n\n\t\t} else {\n\n\t\t\tconst wireframe = ( material.wireframe === true );\n\n\t\t\tif ( currentState.geometry !== geometry.id ||\n\t\t\t\tcurrentState.program !== program.id ||\n\t\t\t\tcurrentState.wireframe !== wireframe ) {\n\n\t\t\t\tcurrentState.geometry = geometry.id;\n\t\t\t\tcurrentState.program = program.id;\n\t\t\t\tcurrentState.wireframe = wireframe;\n\n\t\t\t\tupdateBuffers = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( index !== null ) {\n\n\t\t\tattributes.update( index, gl.ELEMENT_ARRAY_BUFFER );\n\n\t\t}\n\n\t\tif ( updateBuffers || forceUpdate ) {\n\n\t\t\tforceUpdate = false;\n\n\t\t\tsetupVertexAttributes( object, material, program, geometry );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, attributes.get( index ).buffer );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction createVertexArrayObject() {\n\n\t\tif ( capabilities.isWebGL2 ) return gl.createVertexArray();\n\n\t\treturn extension.createVertexArrayOES();\n\n\t}\n\n\tfunction bindVertexArrayObject( vao ) {\n\n\t\tif ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );\n\n\t\treturn extension.bindVertexArrayOES( vao );\n\n\t}\n\n\tfunction deleteVertexArrayObject( vao ) {\n\n\t\tif ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );\n\n\t\treturn extension.deleteVertexArrayOES( vao );\n\n\t}\n\n\tfunction getBindingState( geometry, program, material ) {\n\n\t\tconst wireframe = ( material.wireframe === true );\n\n\t\tlet programMap = bindingStates[ geometry.id ];\n\n\t\tif ( programMap === undefined ) {\n\n\t\t\tprogramMap = {};\n\t\t\tbindingStates[ geometry.id ] = programMap;\n\n\t\t}\n\n\t\tlet stateMap = programMap[ program.id ];\n\n\t\tif ( stateMap === undefined ) {\n\n\t\t\tstateMap = {};\n\t\t\tprogramMap[ program.id ] = stateMap;\n\n\t\t}\n\n\t\tlet state = stateMap[ wireframe ];\n\n\t\tif ( state === undefined ) {\n\n\t\t\tstate = createBindingState( createVertexArrayObject() );\n\t\t\tstateMap[ wireframe ] = state;\n\n\t\t}\n\n\t\treturn state;\n\n\t}\n\n\tfunction createBindingState( vao ) {\n\n\t\tconst newAttributes = [];\n\t\tconst enabledAttributes = [];\n\t\tconst attributeDivisors = [];\n\n\t\tfor ( let i = 0; i < maxVertexAttributes; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\t\t\tenabledAttributes[ i ] = 0;\n\t\t\tattributeDivisors[ i ] = 0;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\t// for backward compatibility on non-VAO support browser\n\t\t\tgeometry: null,\n\t\t\tprogram: null,\n\t\t\twireframe: false,\n\n\t\t\tnewAttributes: newAttributes,\n\t\t\tenabledAttributes: enabledAttributes,\n\t\t\tattributeDivisors: attributeDivisors,\n\t\t\tobject: vao,\n\t\t\tattributes: {},\n\t\t\tindex: null\n\n\t\t};\n\n\t}\n\n\tfunction needsUpdate( object, geometry, program, index ) {\n\n\t\tconst cachedAttributes = currentState.attributes;\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\tlet attributesNum = 0;\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tfor ( const name in programAttributes ) {\n\n\t\t\tconst programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute.location >= 0 ) {\n\n\t\t\t\tconst cachedAttribute = cachedAttributes[ name ];\n\t\t\t\tlet geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute === undefined ) {\n\n\t\t\t\t\tif ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;\n\t\t\t\t\tif ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;\n\n\t\t\t\t}\n\n\t\t\t\tif ( cachedAttribute === undefined ) return true;\n\n\t\t\t\tif ( cachedAttribute.attribute !== geometryAttribute ) return true;\n\n\t\t\t\tif ( geometryAttribute && cachedAttribute.data !== geometryAttribute.data ) return true;\n\n\t\t\t\tattributesNum ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( currentState.attributesNum !== attributesNum ) return true;\n\n\t\tif ( currentState.index !== index ) return true;\n\n\t\treturn false;\n\n\t}\n\n\tfunction saveCache( object, geometry, program, index ) {\n\n\t\tconst cache = {};\n\t\tconst attributes = geometry.attributes;\n\t\tlet attributesNum = 0;\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tfor ( const name in programAttributes ) {\n\n\t\t\tconst programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute.location >= 0 ) {\n\n\t\t\t\tlet attribute = attributes[ name ];\n\n\t\t\t\tif ( attribute === undefined ) {\n\n\t\t\t\t\tif ( name === 'instanceMatrix' && object.instanceMatrix ) attribute = object.instanceMatrix;\n\t\t\t\t\tif ( name === 'instanceColor' && object.instanceColor ) attribute = object.instanceColor;\n\n\t\t\t\t}\n\n\t\t\t\tconst data = {};\n\t\t\t\tdata.attribute = attribute;\n\n\t\t\t\tif ( attribute && attribute.data ) {\n\n\t\t\t\t\tdata.data = attribute.data;\n\n\t\t\t\t}\n\n\t\t\t\tcache[ name ] = data;\n\n\t\t\t\tattributesNum ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcurrentState.attributes = cache;\n\t\tcurrentState.attributesNum = attributesNum;\n\n\t\tcurrentState.index = index;\n\n\t}\n\n\tfunction initAttributes() {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\n\t\tfor ( let i = 0, il = newAttributes.length; i < il; i ++ ) {\n\n\t\t\tnewAttributes[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\tfunction enableAttribute( attribute ) {\n\n\t\tenableAttributeAndDivisor( attribute, 0 );\n\n\t}\n\n\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute ) {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\t\tconst enabledAttributes = currentState.enabledAttributes;\n\t\tconst attributeDivisors = currentState.attributeDivisors;\n\n\t\tnewAttributes[ attribute ] = 1;\n\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\n\n\t\t\tgl.enableVertexAttribArray( attribute );\n\t\t\tenabledAttributes[ attribute ] = 1;\n\n\t\t}\n\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\n\n\t\t\tconst extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );\n\n\t\t\textension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\n\n\t\t}\n\n\t}\n\n\tfunction disableUnusedAttributes() {\n\n\t\tconst newAttributes = currentState.newAttributes;\n\t\tconst enabledAttributes = currentState.enabledAttributes;\n\n\t\tfor ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {\n\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\n\n\t\t\t\tgl.disableVertexAttribArray( i );\n\t\t\t\tenabledAttributes[ i ] = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction vertexAttribPointer( index, size, type, normalized, stride, offset, integer ) {\n\n\t\tif ( integer === true ) {\n\n\t\t\tgl.vertexAttribIPointer( index, size, type, stride, offset );\n\n\t\t} else {\n\n\t\t\tgl.vertexAttribPointer( index, size, type, normalized, stride, offset );\n\n\t\t}\n\n\t}\n\n\tfunction setupVertexAttributes( object, material, program, geometry ) {\n\n\t\tif ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {\n\n\t\t\tif ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;\n\n\t\t}\n\n\t\tinitAttributes();\n\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\tconst programAttributes = program.getAttributes();\n\n\t\tconst materialDefaultAttributeValues = material.defaultAttributeValues;\n\n\t\tfor ( const name in programAttributes ) {\n\n\t\t\tconst programAttribute = programAttributes[ name ];\n\n\t\t\tif ( programAttribute.location >= 0 ) {\n\n\t\t\t\tlet geometryAttribute = geometryAttributes[ name ];\n\n\t\t\t\tif ( geometryAttribute === undefined ) {\n\n\t\t\t\t\tif ( name === 'instanceMatrix' && object.instanceMatrix ) geometryAttribute = object.instanceMatrix;\n\t\t\t\t\tif ( name === 'instanceColor' && object.instanceColor ) geometryAttribute = object.instanceColor;\n\n\t\t\t\t}\n\n\t\t\t\tif ( geometryAttribute !== undefined ) {\n\n\t\t\t\t\tconst normalized = geometryAttribute.normalized;\n\t\t\t\t\tconst size = geometryAttribute.itemSize;\n\n\t\t\t\t\tconst attribute = attributes.get( geometryAttribute );\n\n\t\t\t\t\t// TODO Attribute may not be available on context restore\n\n\t\t\t\t\tif ( attribute === undefined ) continue;\n\n\t\t\t\t\tconst buffer = attribute.buffer;\n\t\t\t\t\tconst type = attribute.type;\n\t\t\t\t\tconst bytesPerElement = attribute.bytesPerElement;\n\n\t\t\t\t\t// check for integer attributes (WebGL 2 only)\n\n\t\t\t\t\tconst integer = ( capabilities.isWebGL2 === true && ( type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType ) );\n\n\t\t\t\t\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tconst data = geometryAttribute.data;\n\t\t\t\t\t\tconst stride = data.stride;\n\t\t\t\t\t\tconst offset = geometryAttribute.offset;\n\n\t\t\t\t\t\tif ( data.isInstancedInterleavedBuffer ) {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttributeAndDivisor( programAttribute.location + i, data.meshPerAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = data.meshPerAttribute * data.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttribute( programAttribute.location + i );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n\n\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\tvertexAttribPointer(\n\t\t\t\t\t\t\t\tprogramAttribute.location + i,\n\t\t\t\t\t\t\t\tsize / programAttribute.locationSize,\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\tnormalized,\n\t\t\t\t\t\t\t\tstride * bytesPerElement,\n\t\t\t\t\t\t\t\t( offset + ( size / programAttribute.locationSize ) * i ) * bytesPerElement,\n\t\t\t\t\t\t\t\tinteger\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( geometryAttribute.isInstancedBufferAttribute ) {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttributeAndDivisor( programAttribute.location + i, geometryAttribute.meshPerAttribute );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined ) {\n\n\t\t\t\t\t\t\t\tgeometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\t\tenableAttribute( programAttribute.location + i );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, buffer );\n\n\t\t\t\t\t\tfor ( let i = 0; i < programAttribute.locationSize; i ++ ) {\n\n\t\t\t\t\t\t\tvertexAttribPointer(\n\t\t\t\t\t\t\t\tprogramAttribute.location + i,\n\t\t\t\t\t\t\t\tsize / programAttribute.locationSize,\n\t\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\t\tnormalized,\n\t\t\t\t\t\t\t\tsize * bytesPerElement,\n\t\t\t\t\t\t\t\t( size / programAttribute.locationSize ) * i * bytesPerElement,\n\t\t\t\t\t\t\t\tinteger\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\n\n\t\t\t\t\tconst value = materialDefaultAttributeValues[ name ];\n\n\t\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\t\tswitch ( value.length ) {\n\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tgl.vertexAttrib2fv( programAttribute.location, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tgl.vertexAttrib3fv( programAttribute.location, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\tgl.vertexAttrib4fv( programAttribute.location, value );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tgl.vertexAttrib1fv( programAttribute.location, value );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tdisableUnusedAttributes();\n\n\t}\n\n\tfunction dispose() {\n\n\t\treset();\n\n\t\tfor ( const geometryId in bindingStates ) {\n\n\t\t\tconst programMap = bindingStates[ geometryId ];\n\n\t\t\tfor ( const programId in programMap ) {\n\n\t\t\t\tconst stateMap = programMap[ programId ];\n\n\t\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t\t}\n\n\t\t\t\tdelete programMap[ programId ];\n\n\t\t\t}\n\n\t\t\tdelete bindingStates[ geometryId ];\n\n\t\t}\n\n\t}\n\n\tfunction releaseStatesOfGeometry( geometry ) {\n\n\t\tif ( bindingStates[ geometry.id ] === undefined ) return;\n\n\t\tconst programMap = bindingStates[ geometry.id ];\n\n\t\tfor ( const programId in programMap ) {\n\n\t\t\tconst stateMap = programMap[ programId ];\n\n\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t}\n\n\t\t\tdelete programMap[ programId ];\n\n\t\t}\n\n\t\tdelete bindingStates[ geometry.id ];\n\n\t}\n\n\tfunction releaseStatesOfProgram( program ) {\n\n\t\tfor ( const geometryId in bindingStates ) {\n\n\t\t\tconst programMap = bindingStates[ geometryId ];\n\n\t\t\tif ( programMap[ program.id ] === undefined ) continue;\n\n\t\t\tconst stateMap = programMap[ program.id ];\n\n\t\t\tfor ( const wireframe in stateMap ) {\n\n\t\t\t\tdeleteVertexArrayObject( stateMap[ wireframe ].object );\n\n\t\t\t\tdelete stateMap[ wireframe ];\n\n\t\t\t}\n\n\t\t\tdelete programMap[ program.id ];\n\n\t\t}\n\n\t}\n\n\tfunction reset() {\n\n\t\tresetDefaultState();\n\t\tforceUpdate = true;\n\n\t\tif ( currentState === defaultState ) return;\n\n\t\tcurrentState = defaultState;\n\t\tbindVertexArrayObject( currentState.object );\n\n\t}\n\n\t// for backward-compatibility\n\n\tfunction resetDefaultState() {\n\n\t\tdefaultState.geometry = null;\n\t\tdefaultState.program = null;\n\t\tdefaultState.wireframe = false;\n\n\t}\n\n\treturn {\n\n\t\tsetup: setup,\n\t\treset: reset,\n\t\tresetDefaultState: resetDefaultState,\n\t\tdispose: dispose,\n\t\treleaseStatesOfGeometry: releaseStatesOfGeometry,\n\t\treleaseStatesOfProgram: releaseStatesOfProgram,\n\n\t\tinitAttributes: initAttributes,\n\t\tenableAttribute: enableAttribute,\n\t\tdisableUnusedAttributes: disableUnusedAttributes\n\n\t};\n\n}\n\nfunction WebGLBufferRenderer( gl, extensions, info, capabilities ) {\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\n\tlet mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\tgl.drawArrays( mode, start, count );\n\n\t\tinfo.update( count, mode, 1 );\n\n\t}\n\n\tfunction renderInstances( start, count, primcount ) {\n\n\t\tif ( primcount === 0 ) return;\n\n\t\tlet extension, methodName;\n\n\t\tif ( isWebGL2 ) {\n\n\t\t\textension = gl;\n\t\t\tmethodName = 'drawArraysInstanced';\n\n\t\t} else {\n\n\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\t\tmethodName = 'drawArraysInstancedANGLE';\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\textension[ methodName ]( mode, start, count, primcount );\n\n\t\tinfo.update( count, mode, primcount );\n\n\t}\n\n\t//\n\n\tthis.setMode = setMode;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n}\n\nfunction WebGLCapabilities( gl, extensions, parameters ) {\n\n\tlet maxAnisotropy;\n\n\tfunction getMaxAnisotropy() {\n\n\t\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\n\n\t\t} else {\n\n\t\t\tmaxAnisotropy = 0;\n\n\t\t}\n\n\t\treturn maxAnisotropy;\n\n\t}\n\n\tfunction getMaxPrecision( precision ) {\n\n\t\tif ( precision === 'highp' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\n\t\t\t\tgl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'highp';\n\n\t\t\t}\n\n\t\t\tprecision = 'mediump';\n\n\t\t}\n\n\t\tif ( precision === 'mediump' ) {\n\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\n\t\t\t\tgl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\n\n\t\t\t\treturn 'mediump';\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn 'lowp';\n\n\t}\n\n\tconst isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl.constructor.name === 'WebGL2RenderingContext';\n\n\tlet precision = parameters.precision !== undefined ? parameters.precision : 'highp';\n\tconst maxPrecision = getMaxPrecision( precision );\n\n\tif ( maxPrecision !== precision ) {\n\n\t\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\n\t\tprecision = maxPrecision;\n\n\t}\n\n\tconst drawBuffers = isWebGL2 || extensions.has( 'WEBGL_draw_buffers' );\n\n\tconst logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n\n\tconst maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\n\tconst maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\tconst maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\n\tconst maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\tconst maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\n\tconst maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\n\tconst maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\n\tconst maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\n\n\tconst vertexTextures = maxVertexTextures > 0;\n\tconst floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );\n\tconst floatVertexTextures = vertexTextures && floatFragmentTextures;\n\n\tconst maxSamples = isWebGL2 ? gl.getParameter( gl.MAX_SAMPLES ) : 0;\n\n\treturn {\n\n\t\tisWebGL2: isWebGL2,\n\n\t\tdrawBuffers: drawBuffers,\n\n\t\tgetMaxAnisotropy: getMaxAnisotropy,\n\t\tgetMaxPrecision: getMaxPrecision,\n\n\t\tprecision: precision,\n\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\n\t\tmaxTextures: maxTextures,\n\t\tmaxVertexTextures: maxVertexTextures,\n\t\tmaxTextureSize: maxTextureSize,\n\t\tmaxCubemapSize: maxCubemapSize,\n\n\t\tmaxAttributes: maxAttributes,\n\t\tmaxVertexUniforms: maxVertexUniforms,\n\t\tmaxVaryings: maxVaryings,\n\t\tmaxFragmentUniforms: maxFragmentUniforms,\n\n\t\tvertexTextures: vertexTextures,\n\t\tfloatFragmentTextures: floatFragmentTextures,\n\t\tfloatVertexTextures: floatVertexTextures,\n\n\t\tmaxSamples: maxSamples\n\n\t};\n\n}\n\nfunction WebGLClipping( properties ) {\n\n\tconst scope = this;\n\n\tlet globalState = null,\n\t\tnumGlobalPlanes = 0,\n\t\tlocalClippingEnabled = false,\n\t\trenderingShadows = false;\n\n\tconst plane = new Plane(),\n\t\tviewNormalMatrix = new Matrix3(),\n\n\t\tuniform = { value: null, needsUpdate: false };\n\n\tthis.uniform = uniform;\n\tthis.numPlanes = 0;\n\tthis.numIntersection = 0;\n\n\tthis.init = function ( planes, enableLocalClipping ) {\n\n\t\tconst enabled =\n\t\t\tplanes.length !== 0 ||\n\t\t\tenableLocalClipping ||\n\t\t\t// enable state of previous frame - the clipping code has to\n\t\t\t// run another frame in order to reset the state:\n\t\t\tnumGlobalPlanes !== 0 ||\n\t\t\tlocalClippingEnabled;\n\n\t\tlocalClippingEnabled = enableLocalClipping;\n\n\t\tnumGlobalPlanes = planes.length;\n\n\t\treturn enabled;\n\n\t};\n\n\tthis.beginShadows = function () {\n\n\t\trenderingShadows = true;\n\t\tprojectPlanes( null );\n\n\t};\n\n\tthis.endShadows = function () {\n\n\t\trenderingShadows = false;\n\n\t};\n\n\tthis.setGlobalState = function ( planes, camera ) {\n\n\t\tglobalState = projectPlanes( planes, camera, 0 );\n\n\t};\n\n\tthis.setState = function ( material, camera, useCache ) {\n\n\t\tconst planes = material.clippingPlanes,\n\t\t\tclipIntersection = material.clipIntersection,\n\t\t\tclipShadows = material.clipShadows;\n\n\t\tconst materialProperties = properties.get( material );\n\n\t\tif ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {\n\n\t\t\t// there's no local clipping\n\n\t\t\tif ( renderingShadows ) {\n\n\t\t\t\t// there's no global clipping\n\n\t\t\t\tprojectPlanes( null );\n\n\t\t\t} else {\n\n\t\t\t\tresetGlobalState();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst nGlobal = renderingShadows ? 0 : numGlobalPlanes,\n\t\t\t\tlGlobal = nGlobal * 4;\n\n\t\t\tlet dstArray = materialProperties.clippingState || null;\n\n\t\t\tuniform.value = dstArray; // ensure unique state\n\n\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, useCache );\n\n\t\t\tfor ( let i = 0; i !== lGlobal; ++ i ) {\n\n\t\t\t\tdstArray[ i ] = globalState[ i ];\n\n\t\t\t}\n\n\t\t\tmaterialProperties.clippingState = dstArray;\n\t\t\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\n\t\t\tthis.numPlanes += nGlobal;\n\n\t\t}\n\n\n\t};\n\n\tfunction resetGlobalState() {\n\n\t\tif ( uniform.value !== globalState ) {\n\n\t\t\tuniform.value = globalState;\n\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\n\n\t\t}\n\n\t\tscope.numPlanes = numGlobalPlanes;\n\t\tscope.numIntersection = 0;\n\n\t}\n\n\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\n\n\t\tconst nPlanes = planes !== null ? planes.length : 0;\n\t\tlet dstArray = null;\n\n\t\tif ( nPlanes !== 0 ) {\n\n\t\t\tdstArray = uniform.value;\n\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\n\n\t\t\t\tconst flatSize = dstOffset + nPlanes * 4,\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\n\n\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\n\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\n\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\n\n\t\t\t\t\tplane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );\n\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tuniform.value = dstArray;\n\t\t\tuniform.needsUpdate = true;\n\n\t\t}\n\n\t\tscope.numPlanes = nPlanes;\n\t\tscope.numIntersection = 0;\n\n\t\treturn dstArray;\n\n\t}\n\n}\n\nfunction WebGLCubeMaps( renderer ) {\n\n\tlet cubemaps = new WeakMap();\n\n\tfunction mapTextureMapping( texture, mapping ) {\n\n\t\tif ( mapping === EquirectangularReflectionMapping ) {\n\n\t\t\ttexture.mapping = CubeReflectionMapping;\n\n\t\t} else if ( mapping === EquirectangularRefractionMapping ) {\n\n\t\t\ttexture.mapping = CubeRefractionMapping;\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tfunction get( texture ) {\n\n\t\tif ( texture && texture.isTexture && texture.isRenderTargetTexture === false ) {\n\n\t\t\tconst mapping = texture.mapping;\n\n\t\t\tif ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {\n\n\t\t\t\tif ( cubemaps.has( texture ) ) {\n\n\t\t\t\t\tconst cubemap = cubemaps.get( texture ).texture;\n\t\t\t\t\treturn mapTextureMapping( cubemap, texture.mapping );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\tif ( image && image.height > 0 ) {\n\n\t\t\t\t\t\tconst renderTarget = new WebGLCubeRenderTarget( image.height / 2 );\n\t\t\t\t\t\trenderTarget.fromEquirectangularTexture( renderer, texture );\n\t\t\t\t\t\tcubemaps.set( texture, renderTarget );\n\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\treturn mapTextureMapping( renderTarget.texture, texture.mapping );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// image not yet ready. try the conversion next frame\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tfunction onTextureDispose( event ) {\n\n\t\tconst texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tconst cubemap = cubemaps.get( texture );\n\n\t\tif ( cubemap !== undefined ) {\n\n\t\t\tcubemaps.delete( texture );\n\t\t\tcubemap.dispose();\n\n\t\t}\n\n\t}\n\n\tfunction dispose() {\n\n\t\tcubemaps = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nclass OrthographicCamera extends Camera {\n\n\tconstructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {\n\n\t\tsuper();\n\n\t\tthis.isOrthographicCamera = true;\n\n\t\tthis.type = 'OrthographicCamera';\n\n\t\tthis.zoom = 1;\n\t\tthis.view = null;\n\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.top = top;\n\t\tthis.bottom = bottom;\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.left = source.left;\n\t\tthis.right = source.right;\n\t\tthis.top = source.top;\n\t\tthis.bottom = source.bottom;\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\n\t\tthis.zoom = source.zoom;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\treturn this;\n\n\t}\n\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tclearViewOffset() {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tupdateProjectionMatrix() {\n\n\t\tconst dx = ( this.right - this.left ) / ( 2 * this.zoom );\n\t\tconst dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\n\t\tconst cx = ( this.right + this.left ) / 2;\n\t\tconst cy = ( this.top + this.bottom ) / 2;\n\n\t\tlet left = cx - dx;\n\t\tlet right = cx + dx;\n\t\tlet top = cy + dy;\n\t\tlet bottom = cy - dy;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;\n\t\t\tconst scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;\n\n\t\t\tleft += scaleW * this.view.offsetX;\n\t\t\tright = left + scaleW * this.view.width;\n\t\t\ttop -= scaleH * this.view.offsetY;\n\t\t\tbottom = top - scaleH * this.view.height;\n\n\t\t}\n\n\t\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far, this.coordinateSystem );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.zoom = this.zoom;\n\t\tdata.object.left = this.left;\n\t\tdata.object.right = this.right;\n\t\tdata.object.top = this.top;\n\t\tdata.object.bottom = this.bottom;\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst LOD_MIN = 4;\n\n// The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\nconst EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];\n\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst _flatCamera = /*@__PURE__*/ new OrthographicCamera();\nconst _clearColor = /*@__PURE__*/ new Color();\nlet _oldTarget = null;\n\n// Golden Ratio\nconst PHI = ( 1 + Math.sqrt( 5 ) ) / 2;\nconst INV_PHI = 1 / PHI;\n\n// Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\nconst _axisDirections = [\n\t/*@__PURE__*/ new Vector3( 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, 1 ),\n\t/*@__PURE__*/ new Vector3( 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( - 1, 1, - 1 ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, INV_PHI ),\n\t/*@__PURE__*/ new Vector3( 0, PHI, - INV_PHI ),\n\t/*@__PURE__*/ new Vector3( INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( - INV_PHI, 0, PHI ),\n\t/*@__PURE__*/ new Vector3( PHI, INV_PHI, 0 ),\n\t/*@__PURE__*/ new Vector3( - PHI, INV_PHI, 0 ) ];\n\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nclass PMREMGenerator {\n\n\tconstructor( renderer ) {\n\n\t\tthis._renderer = renderer;\n\t\tthis._pingPongRenderTarget = null;\n\n\t\tthis._lodMax = 0;\n\t\tthis._cubeSize = 0;\n\t\tthis._lodPlanes = [];\n\t\tthis._sizeLods = [];\n\t\tthis._sigmas = [];\n\n\t\tthis._blurMaterial = null;\n\t\tthis._cubemapMaterial = null;\n\t\tthis._equirectMaterial = null;\n\n\t\tthis._compileMaterial( this._blurMaterial );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from a supplied Scene, which can be faster than using an\n\t * image if networking bandwidth is low. Optional sigma specifies a blur radius\n\t * in radians to be applied to the scene before PMREM generation. Optional near\n\t * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n\t * is placed at the origin).\n\t */\n\tfromScene( scene, sigma = 0, near = 0.1, far = 100 ) {\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\n\t\tthis._setSize( 256 );\n\n\t\tconst cubeUVRenderTarget = this._allocateTargets();\n\t\tcubeUVRenderTarget.depthBuffer = true;\n\n\t\tthis._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );\n\n\t\tif ( sigma > 0 ) {\n\n\t\t\tthis._blur( cubeUVRenderTarget, 0, 0, sigma );\n\n\t\t}\n\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an equirectangular texture, which can be either LDR\n\t * or HDR. The ideal input image size is 1k (1024 x 512),\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromEquirectangular( equirectangular, renderTarget = null ) {\n\n\t\treturn this._fromTexture( equirectangular, renderTarget );\n\n\t}\n\n\t/**\n\t * Generates a PMREM from an cubemap texture, which can be either LDR\n\t * or HDR. The ideal input cube size is 256 x 256,\n\t * as this matches best with the 256 x 256 cubemap output.\n\t */\n\tfromCubemap( cubemap, renderTarget = null ) {\n\n\t\treturn this._fromTexture( cubemap, renderTarget );\n\n\t}\n\n\t/**\n\t * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileCubemapShader() {\n\n\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\n\t\t\tthis._compileMaterial( this._cubemapMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n\t * your texture's network fetch for increased concurrency.\n\t */\n\tcompileEquirectangularShader() {\n\n\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\tthis._equirectMaterial = _getEquirectMaterial();\n\t\t\tthis._compileMaterial( this._equirectMaterial );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n\t * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n\t * one of them will cause any others to also become unusable.\n\t */\n\tdispose() {\n\n\t\tthis._dispose();\n\n\t\tif ( this._cubemapMaterial !== null ) this._cubemapMaterial.dispose();\n\t\tif ( this._equirectMaterial !== null ) this._equirectMaterial.dispose();\n\n\t}\n\n\t// private interface\n\n\t_setSize( cubeSize ) {\n\n\t\tthis._lodMax = Math.floor( Math.log2( cubeSize ) );\n\t\tthis._cubeSize = Math.pow( 2, this._lodMax );\n\n\t}\n\n\t_dispose() {\n\n\t\tif ( this._blurMaterial !== null ) this._blurMaterial.dispose();\n\n\t\tif ( this._pingPongRenderTarget !== null ) this._pingPongRenderTarget.dispose();\n\n\t\tfor ( let i = 0; i < this._lodPlanes.length; i ++ ) {\n\n\t\t\tthis._lodPlanes[ i ].dispose();\n\n\t\t}\n\n\t}\n\n\t_cleanup( outputTarget ) {\n\n\t\tthis._renderer.setRenderTarget( _oldTarget );\n\t\toutputTarget.scissorTest = false;\n\t\t_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );\n\n\t}\n\n\t_fromTexture( texture, renderTarget ) {\n\n\t\tif ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping ) {\n\n\t\t\tthis._setSize( texture.image.length === 0 ? 16 : ( texture.image[ 0 ].width || texture.image[ 0 ].image.width ) );\n\n\t\t} else { // Equirectangular\n\n\t\t\tthis._setSize( texture.image.width / 4 );\n\n\t\t}\n\n\t\t_oldTarget = this._renderer.getRenderTarget();\n\n\t\tconst cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\t\tthis._textureToCubeUV( texture, cubeUVRenderTarget );\n\t\tthis._applyPMREM( cubeUVRenderTarget );\n\t\tthis._cleanup( cubeUVRenderTarget );\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_allocateTargets() {\n\n\t\tconst width = 3 * Math.max( this._cubeSize, 16 * 7 );\n\t\tconst height = 4 * this._cubeSize;\n\n\t\tconst params = {\n\t\t\tmagFilter: LinearFilter,\n\t\t\tminFilter: LinearFilter,\n\t\t\tgenerateMipmaps: false,\n\t\t\ttype: HalfFloatType,\n\t\t\tformat: RGBAFormat,\n\t\t\tcolorSpace: LinearSRGBColorSpace,\n\t\t\tdepthBuffer: false\n\t\t};\n\n\t\tconst cubeUVRenderTarget = _createRenderTarget( width, height, params );\n\n\t\tif ( this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height ) {\n\n\t\t\tif ( this._pingPongRenderTarget !== null ) {\n\n\t\t\t\tthis._dispose();\n\n\t\t\t}\n\n\t\t\tthis._pingPongRenderTarget = _createRenderTarget( width, height, params );\n\n\t\t\tconst { _lodMax } = this;\n\t\t\t( { sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes( _lodMax ) );\n\n\t\t\tthis._blurMaterial = _getBlurShader( _lodMax, width, height );\n\n\t\t}\n\n\t\treturn cubeUVRenderTarget;\n\n\t}\n\n\t_compileMaterial( material ) {\n\n\t\tconst tmpMesh = new Mesh( this._lodPlanes[ 0 ], material );\n\t\tthis._renderer.compile( tmpMesh, _flatCamera );\n\n\t}\n\n\t_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {\n\n\t\tconst fov = 90;\n\t\tconst aspect = 1;\n\t\tconst cubeCamera = new PerspectiveCamera( fov, aspect, near, far );\n\t\tconst upSign = [ 1, - 1, 1, 1, 1, 1 ];\n\t\tconst forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];\n\t\tconst renderer = this._renderer;\n\n\t\tconst originalAutoClear = renderer.autoClear;\n\t\tconst toneMapping = renderer.toneMapping;\n\t\trenderer.getClearColor( _clearColor );\n\n\t\trenderer.toneMapping = NoToneMapping;\n\t\trenderer.autoClear = false;\n\n\t\tconst backgroundMaterial = new MeshBasicMaterial( {\n\t\t\tname: 'PMREM.Background',\n\t\t\tside: BackSide,\n\t\t\tdepthWrite: false,\n\t\t\tdepthTest: false,\n\t\t} );\n\n\t\tconst backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );\n\n\t\tlet useSolidColor = false;\n\t\tconst background = scene.background;\n\n\t\tif ( background ) {\n\n\t\t\tif ( background.isColor ) {\n\n\t\t\t\tbackgroundMaterial.color.copy( background );\n\t\t\t\tscene.background = null;\n\t\t\t\tuseSolidColor = true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tbackgroundMaterial.color.copy( _clearColor );\n\t\t\tuseSolidColor = true;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\tconst col = i % 3;\n\n\t\t\tif ( col === 0 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( forwardSign[ i ], 0, 0 );\n\n\t\t\t} else if ( col === 1 ) {\n\n\t\t\t\tcubeCamera.up.set( 0, 0, upSign[ i ] );\n\t\t\t\tcubeCamera.lookAt( 0, forwardSign[ i ], 0 );\n\n\t\t\t} else {\n\n\t\t\t\tcubeCamera.up.set( 0, upSign[ i ], 0 );\n\t\t\t\tcubeCamera.lookAt( 0, 0, forwardSign[ i ] );\n\n\t\t\t}\n\n\t\t\tconst size = this._cubeSize;\n\n\t\t\t_setViewport( cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size );\n\n\t\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\n\t\t\tif ( useSolidColor ) {\n\n\t\t\t\trenderer.render( backgroundBox, cubeCamera );\n\n\t\t\t}\n\n\t\t\trenderer.render( scene, cubeCamera );\n\n\t\t}\n\n\t\tbackgroundBox.geometry.dispose();\n\t\tbackgroundBox.material.dispose();\n\n\t\trenderer.toneMapping = toneMapping;\n\t\trenderer.autoClear = originalAutoClear;\n\t\tscene.background = background;\n\n\t}\n\n\t_textureToCubeUV( texture, cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\n\t\tconst isCubeTexture = ( texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping );\n\n\t\tif ( isCubeTexture ) {\n\n\t\t\tif ( this._cubemapMaterial === null ) {\n\n\t\t\t\tthis._cubemapMaterial = _getCubemapMaterial();\n\n\t\t\t}\n\n\t\t\tthis._cubemapMaterial.uniforms.flipEnvMap.value = ( texture.isRenderTargetTexture === false ) ? - 1 : 1;\n\n\t\t} else {\n\n\t\t\tif ( this._equirectMaterial === null ) {\n\n\t\t\t\tthis._equirectMaterial = _getEquirectMaterial();\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n\t\tconst mesh = new Mesh( this._lodPlanes[ 0 ], material );\n\n\t\tconst uniforms = material.uniforms;\n\n\t\tuniforms[ 'envMap' ].value = texture;\n\n\t\tconst size = this._cubeSize;\n\n\t\t_setViewport( cubeUVRenderTarget, 0, 0, 3 * size, 2 * size );\n\n\t\trenderer.setRenderTarget( cubeUVRenderTarget );\n\t\trenderer.render( mesh, _flatCamera );\n\n\t}\n\n\t_applyPMREM( cubeUVRenderTarget ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tfor ( let i = 1; i < this._lodPlanes.length; i ++ ) {\n\n\t\t\tconst sigma = Math.sqrt( this._sigmas[ i ] * this._sigmas[ i ] - this._sigmas[ i - 1 ] * this._sigmas[ i - 1 ] );\n\n\t\t\tconst poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];\n\n\t\t\tthis._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\n\t}\n\n\t/**\n\t * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n\t * vertically and horizontally, but this breaks down on a cube. Here we apply\n\t * the blur latitudinally (around the poles), and then longitudinally (towards\n\t * the poles) to approximate the orthogonally-separable blur. It is least\n\t * accurate at the poles, but still does a decent job.\n\t */\n\t_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {\n\n\t\tconst pingPongRenderTarget = this._pingPongRenderTarget;\n\n\t\tthis._halfBlur(\n\t\t\tcubeUVRenderTarget,\n\t\t\tpingPongRenderTarget,\n\t\t\tlodIn,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'latitudinal',\n\t\t\tpoleAxis );\n\n\t\tthis._halfBlur(\n\t\t\tpingPongRenderTarget,\n\t\t\tcubeUVRenderTarget,\n\t\t\tlodOut,\n\t\t\tlodOut,\n\t\t\tsigma,\n\t\t\t'longitudinal',\n\t\t\tpoleAxis );\n\n\t}\n\n\t_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {\n\n\t\tconst renderer = this._renderer;\n\t\tconst blurMaterial = this._blurMaterial;\n\n\t\tif ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {\n\n\t\t\tconsole.error(\n\t\t\t\t'blur direction must be either latitudinal or longitudinal!' );\n\n\t\t}\n\n\t\t// Number of standard deviations at which to cut off the discrete approximation.\n\t\tconst STANDARD_DEVIATIONS = 3;\n\n\t\tconst blurMesh = new Mesh( this._lodPlanes[ lodOut ], blurMaterial );\n\t\tconst blurUniforms = blurMaterial.uniforms;\n\n\t\tconst pixels = this._sizeLods[ lodIn ] - 1;\n\t\tconst radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );\n\t\tconst sigmaPixels = sigmaRadians / radiansPerPixel;\n\t\tconst samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;\n\n\t\tif ( samples > MAX_SAMPLES ) {\n\n\t\t\tconsole.warn( `sigmaRadians, ${\n\t\t\t\tsigmaRadians}, is too large and will clip, as it requested ${\n\t\t\t\tsamples} samples when the maximum is set to ${MAX_SAMPLES}` );\n\n\t\t}\n\n\t\tconst weights = [];\n\t\tlet sum = 0;\n\n\t\tfor ( let i = 0; i < MAX_SAMPLES; ++ i ) {\n\n\t\t\tconst x = i / sigmaPixels;\n\t\t\tconst weight = Math.exp( - x * x / 2 );\n\t\t\tweights.push( weight );\n\n\t\t\tif ( i === 0 ) {\n\n\t\t\t\tsum += weight;\n\n\t\t\t} else if ( i < samples ) {\n\n\t\t\t\tsum += 2 * weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < weights.length; i ++ ) {\n\n\t\t\tweights[ i ] = weights[ i ] / sum;\n\n\t\t}\n\n\t\tblurUniforms[ 'envMap' ].value = targetIn.texture;\n\t\tblurUniforms[ 'samples' ].value = samples;\n\t\tblurUniforms[ 'weights' ].value = weights;\n\t\tblurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';\n\n\t\tif ( poleAxis ) {\n\n\t\t\tblurUniforms[ 'poleAxis' ].value = poleAxis;\n\n\t\t}\n\n\t\tconst { _lodMax } = this;\n\t\tblurUniforms[ 'dTheta' ].value = radiansPerPixel;\n\t\tblurUniforms[ 'mipInt' ].value = _lodMax - lodIn;\n\n\t\tconst outputSize = this._sizeLods[ lodOut ];\n\t\tconst x = 3 * outputSize * ( lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0 );\n\t\tconst y = 4 * ( this._cubeSize - outputSize );\n\n\t\t_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );\n\t\trenderer.setRenderTarget( targetOut );\n\t\trenderer.render( blurMesh, _flatCamera );\n\n\t}\n\n}\n\n\n\nfunction _createPlanes( lodMax ) {\n\n\tconst lodPlanes = [];\n\tconst sizeLods = [];\n\tconst sigmas = [];\n\n\tlet lod = lodMax;\n\n\tconst totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n\tfor ( let i = 0; i < totalLods; i ++ ) {\n\n\t\tconst sizeLod = Math.pow( 2, lod );\n\t\tsizeLods.push( sizeLod );\n\t\tlet sigma = 1.0 / sizeLod;\n\n\t\tif ( i > lodMax - LOD_MIN ) {\n\n\t\t\tsigma = EXTRA_LOD_SIGMA[ i - lodMax + LOD_MIN - 1 ];\n\n\t\t} else if ( i === 0 ) {\n\n\t\t\tsigma = 0;\n\n\t\t}\n\n\t\tsigmas.push( sigma );\n\n\t\tconst texelSize = 1.0 / ( sizeLod - 2 );\n\t\tconst min = - texelSize;\n\t\tconst max = 1 + texelSize;\n\t\tconst uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];\n\n\t\tconst cubeFaces = 6;\n\t\tconst vertices = 6;\n\t\tconst positionSize = 3;\n\t\tconst uvSize = 2;\n\t\tconst faceIndexSize = 1;\n\n\t\tconst position = new Float32Array( positionSize * vertices * cubeFaces );\n\t\tconst uv = new Float32Array( uvSize * vertices * cubeFaces );\n\t\tconst faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );\n\n\t\tfor ( let face = 0; face < cubeFaces; face ++ ) {\n\n\t\t\tconst x = ( face % 3 ) * 2 / 3 - 1;\n\t\t\tconst y = face > 2 ? 0 : - 1;\n\t\t\tconst coordinates = [\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y, 0,\n\t\t\t\tx + 2 / 3, y + 1, 0,\n\t\t\t\tx, y + 1, 0\n\t\t\t];\n\t\t\tposition.set( coordinates, positionSize * vertices * face );\n\t\t\tuv.set( uv1, uvSize * vertices * face );\n\t\t\tconst fill = [ face, face, face, face, face, face ];\n\t\t\tfaceIndex.set( fill, faceIndexSize * vertices * face );\n\n\t\t}\n\n\t\tconst planes = new BufferGeometry();\n\t\tplanes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );\n\t\tplanes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );\n\t\tplanes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );\n\t\tlodPlanes.push( planes );\n\n\t\tif ( lod > LOD_MIN ) {\n\n\t\t\tlod --;\n\n\t\t}\n\n\t}\n\n\treturn { lodPlanes, sizeLods, sigmas };\n\n}\n\nfunction _createRenderTarget( width, height, params ) {\n\n\tconst cubeUVRenderTarget = new WebGLRenderTarget( width, height, params );\n\tcubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n\tcubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n\tcubeUVRenderTarget.scissorTest = true;\n\treturn cubeUVRenderTarget;\n\n}\n\nfunction _setViewport( target, x, y, width, height ) {\n\n\ttarget.viewport.set( x, y, width, height );\n\ttarget.scissor.set( x, y, width, height );\n\n}\n\nfunction _getBlurShader( lodMax, width, height ) {\n\n\tconst weights = new Float32Array( MAX_SAMPLES );\n\tconst poleAxis = new Vector3( 0, 1, 0 );\n\tconst shaderMaterial = new ShaderMaterial( {\n\n\t\tname: 'SphericalGaussianBlur',\n\n\t\tdefines: {\n\t\t\t'n': MAX_SAMPLES,\n\t\t\t'CUBEUV_TEXEL_WIDTH': 1.0 / width,\n\t\t\t'CUBEUV_TEXEL_HEIGHT': 1.0 / height,\n\t\t\t'CUBEUV_MAX_MIP': `${lodMax}.0`,\n\t\t},\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'samples': { value: 1 },\n\t\t\t'weights': { value: weights },\n\t\t\t'latitudinal': { value: false },\n\t\t\t'dTheta': { value: 0 },\n\t\t\t'mipInt': { value: 0 },\n\t\t\t'poleAxis': { value: poleAxis }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n\treturn shaderMaterial;\n\n}\n\nfunction _getEquirectMaterial() {\n\n\treturn new ShaderMaterial( {\n\n\t\tname: 'EquirectangularToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n}\n\nfunction _getCubemapMaterial() {\n\n\treturn new ShaderMaterial( {\n\n\t\tname: 'CubemapToCubeUV',\n\n\t\tuniforms: {\n\t\t\t'envMap': { value: null },\n\t\t\t'flipEnvMap': { value: - 1 }\n\t\t},\n\n\t\tvertexShader: _getCommonVertexShader(),\n\n\t\tfragmentShader: /* glsl */`\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t`,\n\n\t\tblending: NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t} );\n\n}\n\nfunction _getCommonVertexShader() {\n\n\treturn /* glsl */`\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`;\n\n}\n\nfunction WebGLCubeUVMaps( renderer ) {\n\n\tlet cubeUVmaps = new WeakMap();\n\n\tlet pmremGenerator = null;\n\n\tfunction get( texture ) {\n\n\t\tif ( texture && texture.isTexture ) {\n\n\t\t\tconst mapping = texture.mapping;\n\n\t\t\tconst isEquirectMap = ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping );\n\t\t\tconst isCubeMap = ( mapping === CubeReflectionMapping || mapping === CubeRefractionMapping );\n\n\t\t\t// equirect/cube map to cubeUV conversion\n\n\t\t\tif ( isEquirectMap || isCubeMap ) {\n\n\t\t\t\tif ( texture.isRenderTargetTexture && texture.needsPMREMUpdate === true ) {\n\n\t\t\t\t\ttexture.needsPMREMUpdate = false;\n\n\t\t\t\t\tlet renderTarget = cubeUVmaps.get( texture );\n\n\t\t\t\t\tif ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );\n\n\t\t\t\t\trenderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture, renderTarget ) : pmremGenerator.fromCubemap( texture, renderTarget );\n\t\t\t\t\tcubeUVmaps.set( texture, renderTarget );\n\n\t\t\t\t\treturn renderTarget.texture;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( cubeUVmaps.has( texture ) ) {\n\n\t\t\t\t\t\treturn cubeUVmaps.get( texture ).texture;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst image = texture.image;\n\n\t\t\t\t\t\tif ( ( isEquirectMap && image && image.height > 0 ) || ( isCubeMap && image && isCubeTextureComplete( image ) ) ) {\n\n\t\t\t\t\t\t\tif ( pmremGenerator === null ) pmremGenerator = new PMREMGenerator( renderer );\n\n\t\t\t\t\t\t\tconst renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular( texture ) : pmremGenerator.fromCubemap( texture );\n\t\t\t\t\t\t\tcubeUVmaps.set( texture, renderTarget );\n\n\t\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\t\t\treturn renderTarget.texture;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// image not yet ready. try the conversion next frame\n\n\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tfunction isCubeTextureComplete( image ) {\n\n\t\tlet count = 0;\n\t\tconst length = 6;\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tif ( image[ i ] !== undefined ) count ++;\n\n\t\t}\n\n\t\treturn count === length;\n\n\n\t}\n\n\tfunction onTextureDispose( event ) {\n\n\t\tconst texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tconst cubemapUV = cubeUVmaps.get( texture );\n\n\t\tif ( cubemapUV !== undefined ) {\n\n\t\t\tcubeUVmaps.delete( texture );\n\t\t\tcubemapUV.dispose();\n\n\t\t}\n\n\t}\n\n\tfunction dispose() {\n\n\t\tcubeUVmaps = new WeakMap();\n\n\t\tif ( pmremGenerator !== null ) {\n\n\t\t\tpmremGenerator.dispose();\n\t\t\tpmremGenerator = null;\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction WebGLExtensions( gl ) {\n\n\tconst extensions = {};\n\n\tfunction getExtension( name ) {\n\n\t\tif ( extensions[ name ] !== undefined ) {\n\n\t\t\treturn extensions[ name ];\n\n\t\t}\n\n\t\tlet extension;\n\n\t\tswitch ( name ) {\n\n\t\t\tcase 'WEBGL_depth_texture':\n\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'EXT_texture_filter_anisotropic':\n\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_s3tc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\t\t\t\tbreak;\n\n\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\textension = gl.getExtension( name );\n\n\t\t}\n\n\t\textensions[ name ] = extension;\n\n\t\treturn extension;\n\n\t}\n\n\treturn {\n\n\t\thas: function ( name ) {\n\n\t\t\treturn getExtension( name ) !== null;\n\n\t\t},\n\n\t\tinit: function ( capabilities ) {\n\n\t\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\t\tgetExtension( 'EXT_color_buffer_float' );\n\n\t\t\t} else {\n\n\t\t\t\tgetExtension( 'WEBGL_depth_texture' );\n\t\t\t\tgetExtension( 'OES_texture_float' );\n\t\t\t\tgetExtension( 'OES_texture_half_float' );\n\t\t\t\tgetExtension( 'OES_texture_half_float_linear' );\n\t\t\t\tgetExtension( 'OES_standard_derivatives' );\n\t\t\t\tgetExtension( 'OES_element_index_uint' );\n\t\t\t\tgetExtension( 'OES_vertex_array_object' );\n\t\t\t\tgetExtension( 'ANGLE_instanced_arrays' );\n\n\t\t\t}\n\n\t\t\tgetExtension( 'OES_texture_float_linear' );\n\t\t\tgetExtension( 'EXT_color_buffer_half_float' );\n\t\t\tgetExtension( 'WEBGL_multisampled_render_to_texture' );\n\n\t\t},\n\n\t\tget: function ( name ) {\n\n\t\t\tconst extension = getExtension( name );\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\n\n\t\t\t}\n\n\t\t\treturn extension;\n\n\t\t}\n\n\t};\n\n}\n\nfunction WebGLGeometries( gl, attributes, info, bindingStates ) {\n\n\tconst geometries = {};\n\tconst wireframeAttributes = new WeakMap();\n\n\tfunction onGeometryDispose( event ) {\n\n\t\tconst geometry = event.target;\n\n\t\tif ( geometry.index !== null ) {\n\n\t\t\tattributes.remove( geometry.index );\n\n\t\t}\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tattributes.remove( geometry.attributes[ name ] );\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tconst array = geometry.morphAttributes[ name ];\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tattributes.remove( array[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\tdelete geometries[ geometry.id ];\n\n\t\tconst attribute = wireframeAttributes.get( geometry );\n\n\t\tif ( attribute ) {\n\n\t\t\tattributes.remove( attribute );\n\t\t\twireframeAttributes.delete( geometry );\n\n\t\t}\n\n\t\tbindingStates.releaseStatesOfGeometry( geometry );\n\n\t\tif ( geometry.isInstancedBufferGeometry === true ) {\n\n\t\t\tdelete geometry._maxInstanceCount;\n\n\t\t}\n\n\t\t//\n\n\t\tinfo.memory.geometries --;\n\n\t}\n\n\tfunction get( object, geometry ) {\n\n\t\tif ( geometries[ geometry.id ] === true ) return geometry;\n\n\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\tgeometries[ geometry.id ] = true;\n\n\t\tinfo.memory.geometries ++;\n\n\t\treturn geometry;\n\n\t}\n\n\tfunction update( geometry ) {\n\n\t\tconst geometryAttributes = geometry.attributes;\n\n\t\t// Updating index buffer in VAO now. See WebGLBindingStates.\n\n\t\tfor ( const name in geometryAttributes ) {\n\n\t\t\tattributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = morphAttributes[ name ];\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\n\n\t\t\t\tattributes.update( array[ i ], gl.ARRAY_BUFFER );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction updateWireframeAttribute( geometry ) {\n\n\t\tconst indices = [];\n\n\t\tconst geometryIndex = geometry.index;\n\t\tconst geometryPosition = geometry.attributes.position;\n\t\tlet version = 0;\n\n\t\tif ( geometryIndex !== null ) {\n\n\t\t\tconst array = geometryIndex.array;\n\t\t\tversion = geometryIndex.version;\n\n\t\t\tfor ( let i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\t\tconst a = array[ i + 0 ];\n\t\t\t\tconst b = array[ i + 1 ];\n\t\t\t\tconst c = array[ i + 2 ];\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst array = geometryPosition.array;\n\t\t\tversion = geometryPosition.version;\n\n\t\t\tfor ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\n\n\t\t\t\tconst a = i + 0;\n\t\t\t\tconst b = i + 1;\n\t\t\t\tconst c = i + 2;\n\n\t\t\t\tindices.push( a, b, b, c, c, a );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst attribute = new ( arrayNeedsUint32( indices ) ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\n\t\tattribute.version = version;\n\n\t\t// Updating index buffer in VAO now. See WebGLBindingStates\n\n\t\t//\n\n\t\tconst previousAttribute = wireframeAttributes.get( geometry );\n\n\t\tif ( previousAttribute ) attributes.remove( previousAttribute );\n\n\t\t//\n\n\t\twireframeAttributes.set( geometry, attribute );\n\n\t}\n\n\tfunction getWireframeAttribute( geometry ) {\n\n\t\tconst currentAttribute = wireframeAttributes.get( geometry );\n\n\t\tif ( currentAttribute ) {\n\n\t\t\tconst geometryIndex = geometry.index;\n\n\t\t\tif ( geometryIndex !== null ) {\n\n\t\t\t\t// if the attribute is obsolete, create a new one\n\n\t\t\t\tif ( currentAttribute.version < geometryIndex.version ) {\n\n\t\t\t\t\tupdateWireframeAttribute( geometry );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tupdateWireframeAttribute( geometry );\n\n\t\t}\n\n\t\treturn wireframeAttributes.get( geometry );\n\n\t}\n\n\treturn {\n\n\t\tget: get,\n\t\tupdate: update,\n\n\t\tgetWireframeAttribute: getWireframeAttribute\n\n\t};\n\n}\n\nfunction WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\n\tlet mode;\n\n\tfunction setMode( value ) {\n\n\t\tmode = value;\n\n\t}\n\n\tlet type, bytesPerElement;\n\n\tfunction setIndex( value ) {\n\n\t\ttype = value.type;\n\t\tbytesPerElement = value.bytesPerElement;\n\n\t}\n\n\tfunction render( start, count ) {\n\n\t\tgl.drawElements( mode, count, type, start * bytesPerElement );\n\n\t\tinfo.update( count, mode, 1 );\n\n\t}\n\n\tfunction renderInstances( start, count, primcount ) {\n\n\t\tif ( primcount === 0 ) return;\n\n\t\tlet extension, methodName;\n\n\t\tif ( isWebGL2 ) {\n\n\t\t\textension = gl;\n\t\t\tmethodName = 'drawElementsInstanced';\n\n\t\t} else {\n\n\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\n\t\t\tmethodName = 'drawElementsInstancedANGLE';\n\n\t\t\tif ( extension === null ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\textension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );\n\n\t\tinfo.update( count, mode, primcount );\n\n\t}\n\n\t//\n\n\tthis.setMode = setMode;\n\tthis.setIndex = setIndex;\n\tthis.render = render;\n\tthis.renderInstances = renderInstances;\n\n}\n\nfunction WebGLInfo( gl ) {\n\n\tconst memory = {\n\t\tgeometries: 0,\n\t\ttextures: 0\n\t};\n\n\tconst render = {\n\t\tframe: 0,\n\t\tcalls: 0,\n\t\ttriangles: 0,\n\t\tpoints: 0,\n\t\tlines: 0\n\t};\n\n\tfunction update( count, mode, instanceCount ) {\n\n\t\trender.calls ++;\n\n\t\tswitch ( mode ) {\n\n\t\t\tcase gl.TRIANGLES:\n\t\t\t\trender.triangles += instanceCount * ( count / 3 );\n\t\t\t\tbreak;\n\n\t\t\tcase gl.LINES:\n\t\t\t\trender.lines += instanceCount * ( count / 2 );\n\t\t\t\tbreak;\n\n\t\t\tcase gl.LINE_STRIP:\n\t\t\t\trender.lines += instanceCount * ( count - 1 );\n\t\t\t\tbreak;\n\n\t\t\tcase gl.LINE_LOOP:\n\t\t\t\trender.lines += instanceCount * count;\n\t\t\t\tbreak;\n\n\t\t\tcase gl.POINTS:\n\t\t\t\trender.points += instanceCount * count;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tconsole.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction reset() {\n\n\t\trender.calls = 0;\n\t\trender.triangles = 0;\n\t\trender.points = 0;\n\t\trender.lines = 0;\n\n\t}\n\n\treturn {\n\t\tmemory: memory,\n\t\trender: render,\n\t\tprograms: null,\n\t\tautoReset: true,\n\t\treset: reset,\n\t\tupdate: update\n\t};\n\n}\n\nfunction numericalSort( a, b ) {\n\n\treturn a[ 0 ] - b[ 0 ];\n\n}\n\nfunction absNumericalSort( a, b ) {\n\n\treturn Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );\n\n}\n\nfunction WebGLMorphtargets( gl, capabilities, textures ) {\n\n\tconst influencesList = {};\n\tconst morphInfluences = new Float32Array( 8 );\n\tconst morphTextures = new WeakMap();\n\tconst morph = new Vector4();\n\n\tconst workInfluences = [];\n\n\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\tworkInfluences[ i ] = [ i, 0 ];\n\n\t}\n\n\tfunction update( object, geometry, program ) {\n\n\t\tconst objectInfluences = object.morphTargetInfluences;\n\n\t\tif ( capabilities.isWebGL2 === true ) {\n\n\t\t\t// instead of using attributes, the WebGL 2 code path encodes morph targets\n\t\t\t// into an array of data textures. Each layer represents a single morph target.\n\n\t\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\t\tlet entry = morphTextures.get( geometry );\n\n\t\t\tif ( entry === undefined || entry.count !== morphTargetsCount ) {\n\n\t\t\t\tif ( entry !== undefined ) entry.texture.dispose();\n\n\t\t\t\tconst hasMorphPosition = geometry.morphAttributes.position !== undefined;\n\t\t\t\tconst hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n\t\t\t\tconst hasMorphColors = geometry.morphAttributes.color !== undefined;\n\n\t\t\t\tconst morphTargets = geometry.morphAttributes.position || [];\n\t\t\t\tconst morphNormals = geometry.morphAttributes.normal || [];\n\t\t\t\tconst morphColors = geometry.morphAttributes.color || [];\n\n\t\t\t\tlet vertexDataCount = 0;\n\n\t\t\t\tif ( hasMorphPosition === true ) vertexDataCount = 1;\n\t\t\t\tif ( hasMorphNormals === true ) vertexDataCount = 2;\n\t\t\t\tif ( hasMorphColors === true ) vertexDataCount = 3;\n\n\t\t\t\tlet width = geometry.attributes.position.count * vertexDataCount;\n\t\t\t\tlet height = 1;\n\n\t\t\t\tif ( width > capabilities.maxTextureSize ) {\n\n\t\t\t\t\theight = Math.ceil( width / capabilities.maxTextureSize );\n\t\t\t\t\twidth = capabilities.maxTextureSize;\n\n\t\t\t\t}\n\n\t\t\t\tconst buffer = new Float32Array( width * height * 4 * morphTargetsCount );\n\n\t\t\t\tconst texture = new DataArrayTexture( buffer, width, height, morphTargetsCount );\n\t\t\t\ttexture.type = FloatType;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t// fill buffer\n\n\t\t\t\tconst vertexDataStride = vertexDataCount * 4;\n\n\t\t\t\tfor ( let i = 0; i < morphTargetsCount; i ++ ) {\n\n\t\t\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\t\t\tconst morphNormal = morphNormals[ i ];\n\t\t\t\t\tconst morphColor = morphColors[ i ];\n\n\t\t\t\t\tconst offset = width * height * 4 * i;\n\n\t\t\t\t\tfor ( let j = 0; j < morphTarget.count; j ++ ) {\n\n\t\t\t\t\t\tconst stride = j * vertexDataStride;\n\n\t\t\t\t\t\tif ( hasMorphPosition === true ) {\n\n\t\t\t\t\t\t\tmorph.fromBufferAttribute( morphTarget, j );\n\n\t\t\t\t\t\t\tbuffer[ offset + stride + 0 ] = morph.x;\n\t\t\t\t\t\t\tbuffer[ offset + stride + 1 ] = morph.y;\n\t\t\t\t\t\t\tbuffer[ offset + stride + 2 ] = morph.z;\n\t\t\t\t\t\t\tbuffer[ offset + stride + 3 ] = 0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasMorphNormals === true ) {\n\n\t\t\t\t\t\t\tmorph.fromBufferAttribute( morphNormal, j );\n\n\t\t\t\t\t\t\tbuffer[ offset + stride + 4 ] = morph.x;\n\t\t\t\t\t\t\tbuffer[ offset + stride + 5 ] = morph.y;\n\t\t\t\t\t\t\tbuffer[ offset + stride + 6 ] = morph.z;\n\t\t\t\t\t\t\tbuffer[ offset + stride + 7 ] = 0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasMorphColors === true ) {\n\n\t\t\t\t\t\t\tmorph.fromBufferAttribute( morphColor, j );\n\n\t\t\t\t\t\t\tbuffer[ offset + stride + 8 ] = morph.x;\n\t\t\t\t\t\t\tbuffer[ offset + stride + 9 ] = morph.y;\n\t\t\t\t\t\t\tbuffer[ offset + stride + 10 ] = morph.z;\n\t\t\t\t\t\t\tbuffer[ offset + stride + 11 ] = ( morphColor.itemSize === 4 ) ? morph.w : 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tentry = {\n\t\t\t\t\tcount: morphTargetsCount,\n\t\t\t\t\ttexture: texture,\n\t\t\t\t\tsize: new Vector2( width, height )\n\t\t\t\t};\n\n\t\t\t\tmorphTextures.set( geometry, entry );\n\n\t\t\t\tfunction disposeTexture() {\n\n\t\t\t\t\ttexture.dispose();\n\n\t\t\t\t\tmorphTextures.delete( geometry );\n\n\t\t\t\t\tgeometry.removeEventListener( 'dispose', disposeTexture );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addEventListener( 'dispose', disposeTexture );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet morphInfluencesSum = 0;\n\n\t\t\tfor ( let i = 0; i < objectInfluences.length; i ++ ) {\n\n\t\t\t\tmorphInfluencesSum += objectInfluences[ i ];\n\n\t\t\t}\n\n\t\t\tconst morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', objectInfluences );\n\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetsTexture', entry.texture, textures );\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetsTextureSize', entry.size );\n\n\n\t\t} else {\n\n\t\t\t// When object doesn't have morph target influences defined, we treat it as a 0-length array\n\t\t\t// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n\n\t\t\tconst length = objectInfluences === undefined ? 0 : objectInfluences.length;\n\n\t\t\tlet influences = influencesList[ geometry.id ];\n\n\t\t\tif ( influences === undefined || influences.length !== length ) {\n\n\t\t\t\t// initialise list\n\n\t\t\t\tinfluences = [];\n\n\t\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\t\tinfluences[ i ] = [ i, 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tinfluencesList[ geometry.id ] = influences;\n\n\t\t\t}\n\n\t\t\t// Collect influences\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tconst influence = influences[ i ];\n\n\t\t\t\tinfluence[ 0 ] = i;\n\t\t\t\tinfluence[ 1 ] = objectInfluences[ i ];\n\n\t\t\t}\n\n\t\t\tinfluences.sort( absNumericalSort );\n\n\t\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\t\tif ( i < length && influences[ i ][ 1 ] ) {\n\n\t\t\t\t\tworkInfluences[ i ][ 0 ] = influences[ i ][ 0 ];\n\t\t\t\t\tworkInfluences[ i ][ 1 ] = influences[ i ][ 1 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tworkInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;\n\t\t\t\t\tworkInfluences[ i ][ 1 ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tworkInfluences.sort( numericalSort );\n\n\t\t\tconst morphTargets = geometry.morphAttributes.position;\n\t\t\tconst morphNormals = geometry.morphAttributes.normal;\n\n\t\t\tlet morphInfluencesSum = 0;\n\n\t\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\t\tconst influence = workInfluences[ i ];\n\t\t\t\tconst index = influence[ 0 ];\n\t\t\t\tconst value = influence[ 1 ];\n\n\t\t\t\tif ( index !== Number.MAX_SAFE_INTEGER && value ) {\n\n\t\t\t\t\tif ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {\n\n\t\t\t\t\t\tgeometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {\n\n\t\t\t\t\t\tgeometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmorphInfluences[ i ] = value;\n\t\t\t\t\tmorphInfluencesSum += value;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {\n\n\t\t\t\t\t\tgeometry.deleteAttribute( 'morphTarget' + i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {\n\n\t\t\t\t\t\tgeometry.deleteAttribute( 'morphNormal' + i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmorphInfluences[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// GLSL shader uses formula baseinfluence * base + sum(target * influence)\n\t\t\t// This allows us to switch between absolute morphs and relative morphs without changing shader code\n\t\t\t// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n\t\t\tconst morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );\n\t\t\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\tupdate: update\n\n\t};\n\n}\n\nfunction WebGLObjects( gl, geometries, attributes, info ) {\n\n\tlet updateMap = new WeakMap();\n\n\tfunction update( object ) {\n\n\t\tconst frame = info.render.frame;\n\n\t\tconst geometry = object.geometry;\n\t\tconst buffergeometry = geometries.get( object, geometry );\n\n\t\t// Update once per frame\n\n\t\tif ( updateMap.get( buffergeometry ) !== frame ) {\n\n\t\t\tgeometries.update( buffergeometry );\n\n\t\t\tupdateMap.set( buffergeometry, frame );\n\n\t\t}\n\n\t\tif ( object.isInstancedMesh ) {\n\n\t\t\tif ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {\n\n\t\t\t\tobject.addEventListener( 'dispose', onInstancedMeshDispose );\n\n\t\t\t}\n\n\t\t\tif ( updateMap.get( object ) !== frame ) {\n\n\t\t\t\tattributes.update( object.instanceMatrix, gl.ARRAY_BUFFER );\n\n\t\t\t\tif ( object.instanceColor !== null ) {\n\n\t\t\t\t\tattributes.update( object.instanceColor, gl.ARRAY_BUFFER );\n\n\t\t\t\t}\n\n\t\t\t\tupdateMap.set( object, frame );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tconst skeleton = object.skeleton;\n\n\t\t\tif ( updateMap.get( skeleton ) !== frame ) {\n\n\t\t\t\tskeleton.update();\n\n\t\t\t\tupdateMap.set( skeleton, frame );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn buffergeometry;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tupdateMap = new WeakMap();\n\n\t}\n\n\tfunction onInstancedMeshDispose( event ) {\n\n\t\tconst instancedMesh = event.target;\n\n\t\tinstancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );\n\n\t\tattributes.remove( instancedMesh.instanceMatrix );\n\n\t\tif ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );\n\n\t}\n\n\treturn {\n\n\t\tupdate: update,\n\t\tdispose: dispose\n\n\t};\n\n}\n\n/**\n * Uniforms of a program.\n * Those form a tree structure with a special top-level container for the root,\n * which you get by calling 'new WebGLUniforms( gl, program )'.\n *\n *\n * Properties of inner nodes including the top-level container:\n *\n * .seq - array of nested uniforms\n * .map - nested uniforms by name\n *\n *\n * Methods of all nodes except the top-level container:\n *\n * .setValue( gl, value, [textures] )\n *\n * \t\tuploads a uniform value(s)\n *  \tthe 'textures' parameter is needed for sampler uniforms\n *\n *\n * Static methods of the top-level container (textures factorizations):\n *\n * .upload( gl, seq, values, textures )\n *\n * \t\tsets uniforms in 'seq' to 'values[id].value'\n *\n * .seqWithValue( seq, values ) : filteredSeq\n *\n * \t\tfilters 'seq' entries with corresponding entry in values\n *\n *\n * Methods of the top-level container (textures factorizations):\n *\n * .setValue( gl, name, value, textures )\n *\n * \t\tsets uniform with  name 'name' to 'value'\n *\n * .setOptional( gl, obj, prop )\n *\n * \t\tlike .set for an optional property of the object\n *\n */\n\n\nconst emptyTexture = /*@__PURE__*/ new Texture();\nconst emptyArrayTexture = /*@__PURE__*/ new DataArrayTexture();\nconst empty3dTexture = /*@__PURE__*/ new Data3DTexture();\nconst emptyCubeTexture = /*@__PURE__*/ new CubeTexture();\n\n// --- Utilities ---\n\n// Array Caches (provide typed arrays for temporary by size)\n\nconst arrayCacheF32 = [];\nconst arrayCacheI32 = [];\n\n// Float32Array caches used for uploading Matrix uniforms\n\nconst mat4array = new Float32Array( 16 );\nconst mat3array = new Float32Array( 9 );\nconst mat2array = new Float32Array( 4 );\n\n// Flattening for arrays of vectors and matrices\n\nfunction flatten( array, nBlocks, blockSize ) {\n\n\tconst firstElem = array[ 0 ];\n\n\tif ( firstElem <= 0 || firstElem > 0 ) return array;\n\t// unoptimized: ! isNaN( firstElem )\n\t// see http://jacksondunstan.com/articles/983\n\n\tconst n = nBlocks * blockSize;\n\tlet r = arrayCacheF32[ n ];\n\n\tif ( r === undefined ) {\n\n\t\tr = new Float32Array( n );\n\t\tarrayCacheF32[ n ] = r;\n\n\t}\n\n\tif ( nBlocks !== 0 ) {\n\n\t\tfirstElem.toArray( r, 0 );\n\n\t\tfor ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {\n\n\t\t\toffset += blockSize;\n\t\t\tarray[ i ].toArray( r, offset );\n\n\t\t}\n\n\t}\n\n\treturn r;\n\n}\n\nfunction arraysEqual( a, b ) {\n\n\tif ( a.length !== b.length ) return false;\n\n\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\tif ( a[ i ] !== b[ i ] ) return false;\n\n\t}\n\n\treturn true;\n\n}\n\nfunction copyArray( a, b ) {\n\n\tfor ( let i = 0, l = b.length; i < l; i ++ ) {\n\n\t\ta[ i ] = b[ i ];\n\n\t}\n\n}\n\n// Texture unit allocation\n\nfunction allocTexUnits( textures, n ) {\n\n\tlet r = arrayCacheI32[ n ];\n\n\tif ( r === undefined ) {\n\n\t\tr = new Int32Array( n );\n\t\tarrayCacheI32[ n ] = r;\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\tr[ i ] = textures.allocateTextureUnit();\n\n\t}\n\n\treturn r;\n\n}\n\n// --- Setters ---\n\n// Note: Defining these methods externally, because they come in a bunch\n// and this way their names minify.\n\n// Single scalar\n\nfunction setValueV1f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1f( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single float vector (from flat array or THREE.VectorN)\n\nfunction setValueV2f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {\n\n\t\t\tgl.uniform2f( this.addr, v.x, v.y );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform2fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV3f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {\n\n\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\n\t\t}\n\n\t} else if ( v.r !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {\n\n\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\n\n\t\t\tcache[ 0 ] = v.r;\n\t\t\tcache[ 1 ] = v.g;\n\t\t\tcache[ 2 ] = v.b;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform3fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV4f( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {\n\n\t\t\tgl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\t\t\tcache[ 3 ] = v.w;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform4fv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\n// Single matrix (from flat array or THREE.MatrixN)\n\nfunction setValueM2( gl, v ) {\n\n\tconst cache = this.cache;\n\tconst elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix2fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat2array.set( elements );\n\n\t\tgl.uniformMatrix2fv( this.addr, false, mat2array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\nfunction setValueM3( gl, v ) {\n\n\tconst cache = this.cache;\n\tconst elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix3fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat3array.set( elements );\n\n\t\tgl.uniformMatrix3fv( this.addr, false, mat3array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\nfunction setValueM4( gl, v ) {\n\n\tconst cache = this.cache;\n\tconst elements = v.elements;\n\n\tif ( elements === undefined ) {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniformMatrix4fv( this.addr, false, v );\n\n\t\tcopyArray( cache, v );\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, elements ) ) return;\n\n\t\tmat4array.set( elements );\n\n\t\tgl.uniformMatrix4fv( this.addr, false, mat4array );\n\n\t\tcopyArray( cache, elements );\n\n\t}\n\n}\n\n// Single integer / boolean\n\nfunction setValueV1i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1i( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single integer / boolean vector (from flat array or THREE.VectorN)\n\nfunction setValueV2i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {\n\n\t\t\tgl.uniform2i( this.addr, v.x, v.y );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform2iv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV3i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {\n\n\t\t\tgl.uniform3i( this.addr, v.x, v.y, v.z );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform3iv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV4i( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {\n\n\t\t\tgl.uniform4i( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\t\t\tcache[ 3 ] = v.w;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform4iv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\n// Single unsigned integer\n\nfunction setValueV1ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( cache[ 0 ] === v ) return;\n\n\tgl.uniform1ui( this.addr, v );\n\n\tcache[ 0 ] = v;\n\n}\n\n// Single unsigned integer vector (from flat array or THREE.VectorN)\n\nfunction setValueV2ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {\n\n\t\t\tgl.uniform2ui( this.addr, v.x, v.y );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform2uiv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV3ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {\n\n\t\t\tgl.uniform3ui( this.addr, v.x, v.y, v.z );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform3uiv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\nfunction setValueV4ui( gl, v ) {\n\n\tconst cache = this.cache;\n\n\tif ( v.x !== undefined ) {\n\n\t\tif ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {\n\n\t\t\tgl.uniform4ui( this.addr, v.x, v.y, v.z, v.w );\n\n\t\t\tcache[ 0 ] = v.x;\n\t\t\tcache[ 1 ] = v.y;\n\t\t\tcache[ 2 ] = v.z;\n\t\t\tcache[ 3 ] = v.w;\n\n\t\t}\n\n\t} else {\n\n\t\tif ( arraysEqual( cache, v ) ) return;\n\n\t\tgl.uniform4uiv( this.addr, v );\n\n\t\tcopyArray( cache, v );\n\n\t}\n\n}\n\n\n// Single texture (2D / Cube)\n\nfunction setValueT1( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.setTexture2D( v || emptyTexture, unit );\n\n}\n\nfunction setValueT3D1( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.setTexture3D( v || empty3dTexture, unit );\n\n}\n\nfunction setValueT6( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.setTextureCube( v || emptyCubeTexture, unit );\n\n}\n\nfunction setValueT2DArray1( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\tconst unit = textures.allocateTextureUnit();\n\n\tif ( cache[ 0 ] !== unit ) {\n\n\t\tgl.uniform1i( this.addr, unit );\n\t\tcache[ 0 ] = unit;\n\n\t}\n\n\ttextures.setTexture2DArray( v || emptyArrayTexture, unit );\n\n}\n\n// Helper to pick the right setter for the singular case\n\nfunction getSingularSetter( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase 0x1406: return setValueV1f; // FLOAT\n\t\tcase 0x8b50: return setValueV2f; // _VEC2\n\t\tcase 0x8b51: return setValueV3f; // _VEC3\n\t\tcase 0x8b52: return setValueV4f; // _VEC4\n\n\t\tcase 0x8b5a: return setValueM2; // _MAT2\n\t\tcase 0x8b5b: return setValueM3; // _MAT3\n\t\tcase 0x8b5c: return setValueM4; // _MAT4\n\n\t\tcase 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL\n\t\tcase 0x8b53: case 0x8b57: return setValueV2i; // _VEC2\n\t\tcase 0x8b54: case 0x8b58: return setValueV3i; // _VEC3\n\t\tcase 0x8b55: case 0x8b59: return setValueV4i; // _VEC4\n\n\t\tcase 0x1405: return setValueV1ui; // UINT\n\t\tcase 0x8dc6: return setValueV2ui; // _VEC2\n\t\tcase 0x8dc7: return setValueV3ui; // _VEC3\n\t\tcase 0x8dc8: return setValueV4ui; // _VEC4\n\n\t\tcase 0x8b5e: // SAMPLER_2D\n\t\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\n\t\tcase 0x8dca: // INT_SAMPLER_2D\n\t\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\t\tcase 0x8b62: // SAMPLER_2D_SHADOW\n\t\t\treturn setValueT1;\n\n\t\tcase 0x8b5f: // SAMPLER_3D\n\t\tcase 0x8dcb: // INT_SAMPLER_3D\n\t\tcase 0x8dd3: // UNSIGNED_INT_SAMPLER_3D\n\t\t\treturn setValueT3D1;\n\n\t\tcase 0x8b60: // SAMPLER_CUBE\n\t\tcase 0x8dcc: // INT_SAMPLER_CUBE\n\t\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\t\tcase 0x8dc5: // SAMPLER_CUBE_SHADOW\n\t\t\treturn setValueT6;\n\n\t\tcase 0x8dc1: // SAMPLER_2D_ARRAY\n\t\tcase 0x8dcf: // INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW\n\t\t\treturn setValueT2DArray1;\n\n\t}\n\n}\n\n\n// Array of scalars\n\nfunction setValueV1fArray( gl, v ) {\n\n\tgl.uniform1fv( this.addr, v );\n\n}\n\n// Array of vectors (from flat array or array of THREE.VectorN)\n\nfunction setValueV2fArray( gl, v ) {\n\n\tconst data = flatten( v, this.size, 2 );\n\n\tgl.uniform2fv( this.addr, data );\n\n}\n\nfunction setValueV3fArray( gl, v ) {\n\n\tconst data = flatten( v, this.size, 3 );\n\n\tgl.uniform3fv( this.addr, data );\n\n}\n\nfunction setValueV4fArray( gl, v ) {\n\n\tconst data = flatten( v, this.size, 4 );\n\n\tgl.uniform4fv( this.addr, data );\n\n}\n\n// Array of matrices (from flat array or array of THREE.MatrixN)\n\nfunction setValueM2Array( gl, v ) {\n\n\tconst data = flatten( v, this.size, 4 );\n\n\tgl.uniformMatrix2fv( this.addr, false, data );\n\n}\n\nfunction setValueM3Array( gl, v ) {\n\n\tconst data = flatten( v, this.size, 9 );\n\n\tgl.uniformMatrix3fv( this.addr, false, data );\n\n}\n\nfunction setValueM4Array( gl, v ) {\n\n\tconst data = flatten( v, this.size, 16 );\n\n\tgl.uniformMatrix4fv( this.addr, false, data );\n\n}\n\n// Array of integer / boolean\n\nfunction setValueV1iArray( gl, v ) {\n\n\tgl.uniform1iv( this.addr, v );\n\n}\n\n// Array of integer / boolean vectors (from flat array)\n\nfunction setValueV2iArray( gl, v ) {\n\n\tgl.uniform2iv( this.addr, v );\n\n}\n\nfunction setValueV3iArray( gl, v ) {\n\n\tgl.uniform3iv( this.addr, v );\n\n}\n\nfunction setValueV4iArray( gl, v ) {\n\n\tgl.uniform4iv( this.addr, v );\n\n}\n\n// Array of unsigned integer\n\nfunction setValueV1uiArray( gl, v ) {\n\n\tgl.uniform1uiv( this.addr, v );\n\n}\n\n// Array of unsigned integer vectors (from flat array)\n\nfunction setValueV2uiArray( gl, v ) {\n\n\tgl.uniform2uiv( this.addr, v );\n\n}\n\nfunction setValueV3uiArray( gl, v ) {\n\n\tgl.uniform3uiv( this.addr, v );\n\n}\n\nfunction setValueV4uiArray( gl, v ) {\n\n\tgl.uniform4uiv( this.addr, v );\n\n}\n\n\n// Array of textures (2D / 3D / Cube / 2DArray)\n\nfunction setValueT1Array( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tif ( ! arraysEqual( cache, units ) ) {\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tcopyArray( cache, units );\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\n\n\t}\n\n}\n\nfunction setValueT3DArray( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tif ( ! arraysEqual( cache, units ) ) {\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tcopyArray( cache, units );\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.setTexture3D( v[ i ] || empty3dTexture, units[ i ] );\n\n\t}\n\n}\n\nfunction setValueT6Array( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tif ( ! arraysEqual( cache, units ) ) {\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tcopyArray( cache, units );\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\n\n\t}\n\n}\n\nfunction setValueT2DArrayArray( gl, v, textures ) {\n\n\tconst cache = this.cache;\n\n\tconst n = v.length;\n\n\tconst units = allocTexUnits( textures, n );\n\n\tif ( ! arraysEqual( cache, units ) ) {\n\n\t\tgl.uniform1iv( this.addr, units );\n\n\t\tcopyArray( cache, units );\n\n\t}\n\n\tfor ( let i = 0; i !== n; ++ i ) {\n\n\t\ttextures.setTexture2DArray( v[ i ] || emptyArrayTexture, units[ i ] );\n\n\t}\n\n}\n\n\n// Helper to pick the right setter for a pure (bottom-level) array\n\nfunction getPureArraySetter( type ) {\n\n\tswitch ( type ) {\n\n\t\tcase 0x1406: return setValueV1fArray; // FLOAT\n\t\tcase 0x8b50: return setValueV2fArray; // _VEC2\n\t\tcase 0x8b51: return setValueV3fArray; // _VEC3\n\t\tcase 0x8b52: return setValueV4fArray; // _VEC4\n\n\t\tcase 0x8b5a: return setValueM2Array; // _MAT2\n\t\tcase 0x8b5b: return setValueM3Array; // _MAT3\n\t\tcase 0x8b5c: return setValueM4Array; // _MAT4\n\n\t\tcase 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL\n\t\tcase 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2\n\t\tcase 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3\n\t\tcase 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4\n\n\t\tcase 0x1405: return setValueV1uiArray; // UINT\n\t\tcase 0x8dc6: return setValueV2uiArray; // _VEC2\n\t\tcase 0x8dc7: return setValueV3uiArray; // _VEC3\n\t\tcase 0x8dc8: return setValueV4uiArray; // _VEC4\n\n\t\tcase 0x8b5e: // SAMPLER_2D\n\t\tcase 0x8d66: // SAMPLER_EXTERNAL_OES\n\t\tcase 0x8dca: // INT_SAMPLER_2D\n\t\tcase 0x8dd2: // UNSIGNED_INT_SAMPLER_2D\n\t\tcase 0x8b62: // SAMPLER_2D_SHADOW\n\t\t\treturn setValueT1Array;\n\n\t\tcase 0x8b5f: // SAMPLER_3D\n\t\tcase 0x8dcb: // INT_SAMPLER_3D\n\t\tcase 0x8dd3: // UNSIGNED_INT_SAMPLER_3D\n\t\t\treturn setValueT3DArray;\n\n\t\tcase 0x8b60: // SAMPLER_CUBE\n\t\tcase 0x8dcc: // INT_SAMPLER_CUBE\n\t\tcase 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE\n\t\tcase 0x8dc5: // SAMPLER_CUBE_SHADOW\n\t\t\treturn setValueT6Array;\n\n\t\tcase 0x8dc1: // SAMPLER_2D_ARRAY\n\t\tcase 0x8dcf: // INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY\n\t\tcase 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW\n\t\t\treturn setValueT2DArrayArray;\n\n\t}\n\n}\n\n// --- Uniform Classes ---\n\nclass SingleUniform {\n\n\tconstructor( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.cache = [];\n\t\tthis.setValue = getSingularSetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n}\n\nclass PureArrayUniform {\n\n\tconstructor( id, activeInfo, addr ) {\n\n\t\tthis.id = id;\n\t\tthis.addr = addr;\n\t\tthis.cache = [];\n\t\tthis.size = activeInfo.size;\n\t\tthis.setValue = getPureArraySetter( activeInfo.type );\n\n\t\t// this.path = activeInfo.name; // DEBUG\n\n\t}\n\n}\n\nclass StructuredUniform {\n\n\tconstructor( id ) {\n\n\t\tthis.id = id;\n\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\n\t}\n\n\tsetValue( gl, value, textures ) {\n\n\t\tconst seq = this.seq;\n\n\t\tfor ( let i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tconst u = seq[ i ];\n\t\t\tu.setValue( gl, value[ u.id ], textures );\n\n\t\t}\n\n\t}\n\n}\n\n// --- Top-level ---\n\n// Parser - builds up the property tree from the path strings\n\nconst RePathPart = /(\\w+)(\\])?(\\[|\\.)?/g;\n\n// extracts\n// \t- the identifier (member name or array index)\n//  - followed by an optional right bracket (found when array index)\n//  - followed by an optional left bracket or dot (type of subscript)\n//\n// Note: These portions can be read in a non-overlapping fashion and\n// allow straightforward parsing of the hierarchy that WebGL encodes\n// in the uniform names.\n\nfunction addUniform( container, uniformObject ) {\n\n\tcontainer.seq.push( uniformObject );\n\tcontainer.map[ uniformObject.id ] = uniformObject;\n\n}\n\nfunction parseUniform( activeInfo, addr, container ) {\n\n\tconst path = activeInfo.name,\n\t\tpathLength = path.length;\n\n\t// reset RegExp object, because of the early exit of a previous run\n\tRePathPart.lastIndex = 0;\n\n\twhile ( true ) {\n\n\t\tconst match = RePathPart.exec( path ),\n\t\t\tmatchEnd = RePathPart.lastIndex;\n\n\t\tlet id = match[ 1 ];\n\t\tconst idIsIndex = match[ 2 ] === ']',\n\t\t\tsubscript = match[ 3 ];\n\n\t\tif ( idIsIndex ) id = id | 0; // convert to integer\n\n\t\tif ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {\n\n\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\n\n\t\t\taddUniform( container, subscript === undefined ?\n\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\n\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\n\n\t\t\tbreak;\n\n\t\t} else {\n\n\t\t\t// step into inner node / create it in case it doesn't exist\n\n\t\t\tconst map = container.map;\n\t\t\tlet next = map[ id ];\n\n\t\t\tif ( next === undefined ) {\n\n\t\t\t\tnext = new StructuredUniform( id );\n\t\t\t\taddUniform( container, next );\n\n\t\t\t}\n\n\t\t\tcontainer = next;\n\n\t\t}\n\n\t}\n\n}\n\n// Root Container\n\nclass WebGLUniforms {\n\n\tconstructor( gl, program ) {\n\n\t\tthis.seq = [];\n\t\tthis.map = {};\n\n\t\tconst n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\n\n\t\tfor ( let i = 0; i < n; ++ i ) {\n\n\t\t\tconst info = gl.getActiveUniform( program, i ),\n\t\t\t\taddr = gl.getUniformLocation( program, info.name );\n\n\t\t\tparseUniform( info, addr, this );\n\n\t\t}\n\n\t}\n\n\tsetValue( gl, name, value, textures ) {\n\n\t\tconst u = this.map[ name ];\n\n\t\tif ( u !== undefined ) u.setValue( gl, value, textures );\n\n\t}\n\n\tsetOptional( gl, object, name ) {\n\n\t\tconst v = object[ name ];\n\n\t\tif ( v !== undefined ) this.setValue( gl, name, v );\n\n\t}\n\n\tstatic upload( gl, seq, values, textures ) {\n\n\t\tfor ( let i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tconst u = seq[ i ],\n\t\t\t\tv = values[ u.id ];\n\n\t\t\tif ( v.needsUpdate !== false ) {\n\n\t\t\t\t// note: always updating when .needsUpdate is undefined\n\t\t\t\tu.setValue( gl, v.value, textures );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic seqWithValue( seq, values ) {\n\n\t\tconst r = [];\n\n\t\tfor ( let i = 0, n = seq.length; i !== n; ++ i ) {\n\n\t\t\tconst u = seq[ i ];\n\t\t\tif ( u.id in values ) r.push( u );\n\n\t\t}\n\n\t\treturn r;\n\n\t}\n\n}\n\nfunction WebGLShader( gl, type, string ) {\n\n\tconst shader = gl.createShader( type );\n\n\tgl.shaderSource( shader, string );\n\tgl.compileShader( shader );\n\n\treturn shader;\n\n}\n\nlet programIdCount = 0;\n\nfunction handleSource( string, errorLine ) {\n\n\tconst lines = string.split( '\\n' );\n\tconst lines2 = [];\n\n\tconst from = Math.max( errorLine - 6, 0 );\n\tconst to = Math.min( errorLine + 6, lines.length );\n\n\tfor ( let i = from; i < to; i ++ ) {\n\n\t\tconst line = i + 1;\n\t\tlines2.push( `${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}` );\n\n\t}\n\n\treturn lines2.join( '\\n' );\n\n}\n\nfunction getEncodingComponents( colorSpace ) {\n\n\tswitch ( colorSpace ) {\n\n\t\tcase LinearSRGBColorSpace:\n\t\t\treturn [ 'Linear', '( value )' ];\n\t\tcase SRGBColorSpace:\n\t\t\treturn [ 'sRGB', '( value )' ];\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.WebGLProgram: Unsupported color space:', colorSpace );\n\t\t\treturn [ 'Linear', '( value )' ];\n\n\t}\n\n}\n\nfunction getShaderErrors( gl, shader, type ) {\n\n\tconst status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );\n\tconst errors = gl.getShaderInfoLog( shader ).trim();\n\n\tif ( status && errors === '' ) return '';\n\n\tconst errorMatches = /ERROR: 0:(\\d+)/.exec( errors );\n\tif ( errorMatches ) {\n\n\t\t// --enable-privileged-webgl-extension\n\t\t// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\n\n\t\tconst errorLine = parseInt( errorMatches[ 1 ] );\n\t\treturn type.toUpperCase() + '\\n\\n' + errors + '\\n\\n' + handleSource( gl.getShaderSource( shader ), errorLine );\n\n\t} else {\n\n\t\treturn errors;\n\n\t}\n\n}\n\nfunction getTexelEncodingFunction( functionName, colorSpace ) {\n\n\tconst components = getEncodingComponents( colorSpace );\n\treturn 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';\n\n}\n\nfunction getToneMappingFunction( functionName, toneMapping ) {\n\n\tlet toneMappingName;\n\n\tswitch ( toneMapping ) {\n\n\t\tcase LinearToneMapping:\n\t\t\ttoneMappingName = 'Linear';\n\t\t\tbreak;\n\n\t\tcase ReinhardToneMapping:\n\t\t\ttoneMappingName = 'Reinhard';\n\t\t\tbreak;\n\n\t\tcase CineonToneMapping:\n\t\t\ttoneMappingName = 'OptimizedCineon';\n\t\t\tbreak;\n\n\t\tcase ACESFilmicToneMapping:\n\t\t\ttoneMappingName = 'ACESFilmic';\n\t\t\tbreak;\n\n\t\tcase CustomToneMapping:\n\t\t\ttoneMappingName = 'Custom';\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );\n\t\t\ttoneMappingName = 'Linear';\n\n\t}\n\n\treturn 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\n\n}\n\nfunction generateExtensions( parameters ) {\n\n\tconst chunks = [\n\t\t( parameters.extensionDerivatives || !! parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.normalMapTangentSpace || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',\n\t\t( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',\n\t\t( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',\n\t\t( parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''\n\t];\n\n\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\n\n}\n\nfunction generateDefines( defines ) {\n\n\tconst chunks = [];\n\n\tfor ( const name in defines ) {\n\n\t\tconst value = defines[ name ];\n\n\t\tif ( value === false ) continue;\n\n\t\tchunks.push( '#define ' + name + ' ' + value );\n\n\t}\n\n\treturn chunks.join( '\\n' );\n\n}\n\nfunction fetchAttributeLocations( gl, program ) {\n\n\tconst attributes = {};\n\n\tconst n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\n\n\tfor ( let i = 0; i < n; i ++ ) {\n\n\t\tconst info = gl.getActiveAttrib( program, i );\n\t\tconst name = info.name;\n\n\t\tlet locationSize = 1;\n\t\tif ( info.type === gl.FLOAT_MAT2 ) locationSize = 2;\n\t\tif ( info.type === gl.FLOAT_MAT3 ) locationSize = 3;\n\t\tif ( info.type === gl.FLOAT_MAT4 ) locationSize = 4;\n\n\t\t// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\n\n\t\tattributes[ name ] = {\n\t\t\ttype: info.type,\n\t\t\tlocation: gl.getAttribLocation( program, name ),\n\t\t\tlocationSize: locationSize\n\t\t};\n\n\t}\n\n\treturn attributes;\n\n}\n\nfunction filterEmptyLine( string ) {\n\n\treturn string !== '';\n\n}\n\nfunction replaceLightNums( string, parameters ) {\n\n\tconst numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;\n\n\treturn string\n\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\n\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\n\t\t.replace( /NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps )\n\t\t.replace( /NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords )\n\t\t.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )\n\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\n\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )\n\t\t.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )\n\t\t.replace( /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps )\n\t\t.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )\n\t\t.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );\n\n}\n\nfunction replaceClippingPlaneNums( string, parameters ) {\n\n\treturn string\n\t\t.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )\n\t\t.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );\n\n}\n\n// Resolve Includes\n\nconst includePattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\nfunction resolveIncludes( string ) {\n\n\treturn string.replace( includePattern, includeReplacer );\n\n}\n\nconst shaderChunkMap = new Map( [\n\t[ 'encodings_fragment', 'colorspace_fragment' ], // @deprecated, r154\n\t[ 'encodings_pars_fragment', 'colorspace_pars_fragment' ], // @deprecated, r154\n\t[ 'output_fragment', 'opaque_fragment' ], // @deprecated, r154\n] );\n\nfunction includeReplacer( match, include ) {\n\n\tlet string = ShaderChunk[ include ];\n\n\tif ( string === undefined ) {\n\n\t\tconst newInclude = shaderChunkMap.get( include );\n\n\t\tif ( newInclude !== undefined ) {\n\n\t\t\tstring = ShaderChunk[ newInclude ];\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Shader chunk \"%s\" has been deprecated. Use \"%s\" instead.', include, newInclude );\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\n\n\t\t}\n\n\t}\n\n\treturn resolveIncludes( string );\n\n}\n\n// Unroll Loops\n\nconst unrollLoopPattern = /#pragma unroll_loop_start\\s+for\\s*\\(\\s*int\\s+i\\s*=\\s*(\\d+)\\s*;\\s*i\\s*<\\s*(\\d+)\\s*;\\s*i\\s*\\+\\+\\s*\\)\\s*{([\\s\\S]+?)}\\s+#pragma unroll_loop_end/g;\n\nfunction unrollLoops( string ) {\n\n\treturn string.replace( unrollLoopPattern, loopReplacer );\n\n}\n\nfunction loopReplacer( match, start, end, snippet ) {\n\n\tlet string = '';\n\n\tfor ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {\n\n\t\tstring += snippet\n\t\t\t.replace( /\\[\\s*i\\s*\\]/g, '[ ' + i + ' ]' )\n\t\t\t.replace( /UNROLLED_LOOP_INDEX/g, i );\n\n\t}\n\n\treturn string;\n\n}\n\n//\n\nfunction generatePrecision( parameters ) {\n\n\tlet precisionstring = 'precision ' + parameters.precision + ' float;\\nprecision ' + parameters.precision + ' int;';\n\n\tif ( parameters.precision === 'highp' ) {\n\n\t\tprecisionstring += '\\n#define HIGH_PRECISION';\n\n\t} else if ( parameters.precision === 'mediump' ) {\n\n\t\tprecisionstring += '\\n#define MEDIUM_PRECISION';\n\n\t} else if ( parameters.precision === 'lowp' ) {\n\n\t\tprecisionstring += '\\n#define LOW_PRECISION';\n\n\t}\n\n\treturn precisionstring;\n\n}\n\nfunction generateShadowMapTypeDefine( parameters ) {\n\n\tlet shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\n\n\tif ( parameters.shadowMapType === PCFShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\n\n\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\n\n\t} else if ( parameters.shadowMapType === VSMShadowMap ) {\n\n\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';\n\n\t}\n\n\treturn shadowMapTypeDefine;\n\n}\n\nfunction generateEnvMapTypeDefine( parameters ) {\n\n\tlet envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( parameters.envMapMode ) {\n\n\t\t\tcase CubeReflectionMapping:\n\t\t\tcase CubeRefractionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\n\t\t\t\tbreak;\n\n\t\t\tcase CubeUVReflectionMapping:\n\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn envMapTypeDefine;\n\n}\n\nfunction generateEnvMapModeDefine( parameters ) {\n\n\tlet envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( parameters.envMapMode ) {\n\n\t\t\tcase CubeRefractionMapping:\n\n\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn envMapModeDefine;\n\n}\n\nfunction generateEnvMapBlendingDefine( parameters ) {\n\n\tlet envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';\n\n\tif ( parameters.envMap ) {\n\n\t\tswitch ( parameters.combine ) {\n\n\t\t\tcase MultiplyOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\n\t\t\t\tbreak;\n\n\t\t\tcase MixOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\n\t\t\t\tbreak;\n\n\t\t\tcase AddOperation:\n\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn envMapBlendingDefine;\n\n}\n\nfunction generateCubeUVSize( parameters ) {\n\n\tconst imageHeight = parameters.envMapCubeUVHeight;\n\n\tif ( imageHeight === null ) return null;\n\n\tconst maxMip = Math.log2( imageHeight ) - 2;\n\n\tconst texelHeight = 1.0 / imageHeight;\n\n\tconst texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );\n\n\treturn { texelWidth, texelHeight, maxMip };\n\n}\n\nfunction WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {\n\n\t// TODO Send this event to Three.js DevTools\n\t// console.log( 'WebGLProgram', cacheKey );\n\n\tconst gl = renderer.getContext();\n\n\tconst defines = parameters.defines;\n\n\tlet vertexShader = parameters.vertexShader;\n\tlet fragmentShader = parameters.fragmentShader;\n\n\tconst shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );\n\tconst envMapTypeDefine = generateEnvMapTypeDefine( parameters );\n\tconst envMapModeDefine = generateEnvMapModeDefine( parameters );\n\tconst envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );\n\tconst envMapCubeUVSize = generateCubeUVSize( parameters );\n\n\tconst customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );\n\n\tconst customDefines = generateDefines( defines );\n\n\tconst program = gl.createProgram();\n\n\tlet prefixVertex, prefixFragment;\n\tlet versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\\n' : '';\n\n\tif ( parameters.isRawShaderMaterial ) {\n\n\t\tprefixVertex = [\n\n\t\t\t'#define SHADER_TYPE ' + parameters.shaderType,\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tif ( prefixVertex.length > 0 ) {\n\n\t\t\tprefixVertex += '\\n';\n\n\t\t}\n\n\t\tprefixFragment = [\n\n\t\t\tcustomExtensions,\n\n\t\t\t'#define SHADER_TYPE ' + parameters.shaderType,\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tif ( prefixFragment.length > 0 ) {\n\n\t\t\tprefixFragment += '\\n';\n\n\t\t}\n\n\t} else {\n\n\t\tprefixVertex = [\n\n\t\t\tgeneratePrecision( parameters ),\n\n\t\t\t'#define SHADER_TYPE ' + parameters.shaderType,\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines,\n\n\t\t\tparameters.instancing ? '#define USE_INSTANCING' : '',\n\t\t\tparameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',\n\n\t\t\tparameters.useFog && parameters.fog ? '#define USE_FOG' : '',\n\t\t\tparameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',\n\n\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\tparameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',\n\t\t\tparameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',\n\t\t\tparameters.displacementMap ? '#define USE_DISPLACEMENTMAP' : '',\n\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\n\t\t\tparameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',\n\n\t\t\tparameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',\n\t\t\tparameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',\n\t\t\tparameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',\n\n\t\t\tparameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',\n\t\t\tparameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',\n\n\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\tparameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',\n\t\t\tparameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',\n\n\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\tparameters.alphaHash ? '#define USE_ALPHAHASH' : '',\n\n\t\t\tparameters.transmission ? '#define USE_TRANSMISSION' : '',\n\t\t\tparameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',\n\t\t\tparameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',\n\n\t\t\tparameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',\n\t\t\tparameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',\n\n\t\t\t//\n\n\t\t\tparameters.mapUv ? '#define MAP_UV ' + parameters.mapUv : '',\n\t\t\tparameters.alphaMapUv ? '#define ALPHAMAP_UV ' + parameters.alphaMapUv : '',\n\t\t\tparameters.lightMapUv ? '#define LIGHTMAP_UV ' + parameters.lightMapUv : '',\n\t\t\tparameters.aoMapUv ? '#define AOMAP_UV ' + parameters.aoMapUv : '',\n\t\t\tparameters.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + parameters.emissiveMapUv : '',\n\t\t\tparameters.bumpMapUv ? '#define BUMPMAP_UV ' + parameters.bumpMapUv : '',\n\t\t\tparameters.normalMapUv ? '#define NORMALMAP_UV ' + parameters.normalMapUv : '',\n\t\t\tparameters.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + parameters.displacementMapUv : '',\n\n\t\t\tparameters.metalnessMapUv ? '#define METALNESSMAP_UV ' + parameters.metalnessMapUv : '',\n\t\t\tparameters.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + parameters.roughnessMapUv : '',\n\n\t\t\tparameters.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + parameters.anisotropyMapUv : '',\n\n\t\t\tparameters.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + parameters.clearcoatMapUv : '',\n\t\t\tparameters.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + parameters.clearcoatNormalMapUv : '',\n\t\t\tparameters.clearcoatRoughnessMapUv ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + parameters.clearcoatRoughnessMapUv : '',\n\n\t\t\tparameters.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + parameters.iridescenceMapUv : '',\n\t\t\tparameters.iridescenceThicknessMapUv ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + parameters.iridescenceThicknessMapUv : '',\n\n\t\t\tparameters.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + parameters.sheenColorMapUv : '',\n\t\t\tparameters.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + parameters.sheenRoughnessMapUv : '',\n\n\t\t\tparameters.specularMapUv ? '#define SPECULARMAP_UV ' + parameters.specularMapUv : '',\n\t\t\tparameters.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + parameters.specularColorMapUv : '',\n\t\t\tparameters.specularIntensityMapUv ? '#define SPECULAR_INTENSITYMAP_UV ' + parameters.specularIntensityMapUv : '',\n\n\t\t\tparameters.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + parameters.transmissionMapUv : '',\n\t\t\tparameters.thicknessMapUv ? '#define THICKNESSMAP_UV ' + parameters.thicknessMapUv : '',\n\n\t\t\t//\n\n\t\t\tparameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',\n\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\n\t\t\tparameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',\n\t\t\tparameters.vertexUv1s ? '#define USE_UV1' : '',\n\t\t\tparameters.vertexUv2s ? '#define USE_UV2' : '',\n\t\t\tparameters.vertexUv3s ? '#define USE_UV3' : '',\n\n\t\t\tparameters.pointsUvs ? '#define USE_POINTS_UV' : '',\n\n\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\n\n\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\n\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\n\t\t\t( parameters.morphColors && parameters.isWebGL2 ) ? '#define USE_MORPHCOLORS' : '',\n\t\t\t( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_TEXTURE' : '',\n\t\t\t( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',\n\t\t\t( parameters.morphTargetsCount > 0 && parameters.isWebGL2 ) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',\n\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\n\n\t\t\tparameters.useLegacyLights ? '#define LEGACY_LIGHTS' : '',\n\n\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t'uniform mat4 modelMatrix;',\n\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t'uniform mat3 normalMatrix;',\n\t\t\t'uniform vec3 cameraPosition;',\n\t\t\t'uniform bool isOrthographic;',\n\n\t\t\t'#ifdef USE_INSTANCING',\n\n\t\t\t'\tattribute mat4 instanceMatrix;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_INSTANCING_COLOR',\n\n\t\t\t'\tattribute vec3 instanceColor;',\n\n\t\t\t'#endif',\n\n\t\t\t'attribute vec3 position;',\n\t\t\t'attribute vec3 normal;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'#ifdef USE_UV1',\n\n\t\t\t'\tattribute vec2 uv1;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_UV2',\n\n\t\t\t'\tattribute vec2 uv2;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_UV3',\n\n\t\t\t'\tattribute vec2 uv3;',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_TANGENT',\n\n\t\t\t'\tattribute vec4 tangent;',\n\n\t\t\t'#endif',\n\n\t\t\t'#if defined( USE_COLOR_ALPHA )',\n\n\t\t\t'\tattribute vec4 color;',\n\n\t\t\t'#elif defined( USE_COLOR )',\n\n\t\t\t'\tattribute vec3 color;',\n\n\t\t\t'#endif',\n\n\t\t\t'#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',\n\n\t\t\t'\tattribute vec3 morphTarget0;',\n\t\t\t'\tattribute vec3 morphTarget1;',\n\t\t\t'\tattribute vec3 morphTarget2;',\n\t\t\t'\tattribute vec3 morphTarget3;',\n\n\t\t\t'\t#ifdef USE_MORPHNORMALS',\n\n\t\t\t'\t\tattribute vec3 morphNormal0;',\n\t\t\t'\t\tattribute vec3 morphNormal1;',\n\t\t\t'\t\tattribute vec3 morphNormal2;',\n\t\t\t'\t\tattribute vec3 morphNormal3;',\n\n\t\t\t'\t#else',\n\n\t\t\t'\t\tattribute vec3 morphTarget4;',\n\t\t\t'\t\tattribute vec3 morphTarget5;',\n\t\t\t'\t\tattribute vec3 morphTarget6;',\n\t\t\t'\t\tattribute vec3 morphTarget7;',\n\n\t\t\t'\t#endif',\n\n\t\t\t'#endif',\n\n\t\t\t'#ifdef USE_SKINNING',\n\n\t\t\t'\tattribute vec4 skinIndex;',\n\t\t\t'\tattribute vec4 skinWeight;',\n\n\t\t\t'#endif',\n\n\t\t\t'\\n'\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t\tprefixFragment = [\n\n\t\t\tcustomExtensions,\n\n\t\t\tgeneratePrecision( parameters ),\n\n\t\t\t'#define SHADER_TYPE ' + parameters.shaderType,\n\t\t\t'#define SHADER_NAME ' + parameters.shaderName,\n\n\t\t\tcustomDefines,\n\n\t\t\tparameters.useFog && parameters.fog ? '#define USE_FOG' : '',\n\t\t\tparameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',\n\n\t\t\tparameters.map ? '#define USE_MAP' : '',\n\t\t\tparameters.matcap ? '#define USE_MATCAP' : '',\n\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\n\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\n\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\n\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\n\t\t\tenvMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',\n\t\t\tenvMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',\n\t\t\tenvMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',\n\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\n\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\n\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\n\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\n\t\t\tparameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '',\n\t\t\tparameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '',\n\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\n\n\t\t\tparameters.anisotropy ? '#define USE_ANISOTROPY' : '',\n\t\t\tparameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '',\n\n\t\t\tparameters.clearcoat ? '#define USE_CLEARCOAT' : '',\n\t\t\tparameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',\n\t\t\tparameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',\n\t\t\tparameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',\n\n\t\t\tparameters.iridescence ? '#define USE_IRIDESCENCE' : '',\n\t\t\tparameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',\n\t\t\tparameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '',\n\n\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\n\t\t\tparameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '',\n\t\t\tparameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '',\n\n\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\n\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\n\n\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\n\t\t\tparameters.alphaTest ? '#define USE_ALPHATEST' : '',\n\t\t\tparameters.alphaHash ? '#define USE_ALPHAHASH' : '',\n\n\t\t\tparameters.sheen ? '#define USE_SHEEN' : '',\n\t\t\tparameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '',\n\t\t\tparameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '',\n\n\t\t\tparameters.transmission ? '#define USE_TRANSMISSION' : '',\n\t\t\tparameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',\n\t\t\tparameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',\n\n\t\t\tparameters.vertexTangents && parameters.flatShading === false ? '#define USE_TANGENT' : '',\n\t\t\tparameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',\n\t\t\tparameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',\n\t\t\tparameters.vertexUv1s ? '#define USE_UV1' : '',\n\t\t\tparameters.vertexUv2s ? '#define USE_UV2' : '',\n\t\t\tparameters.vertexUv3s ? '#define USE_UV3' : '',\n\n\t\t\tparameters.pointsUvs ? '#define USE_POINTS_UV' : '',\n\n\t\t\tparameters.gradientMap ? '#define USE_GRADIENTMAP' : '',\n\n\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\n\n\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\n\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\n\n\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\n\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\n\n\t\t\tparameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',\n\n\t\t\tparameters.useLegacyLights ? '#define LEGACY_LIGHTS' : '',\n\n\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\n\t\t\t( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\n\n\t\t\t'uniform mat4 viewMatrix;',\n\t\t\t'uniform vec3 cameraPosition;',\n\t\t\t'uniform bool isOrthographic;',\n\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below\n\t\t\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',\n\n\t\t\tparameters.dithering ? '#define DITHERING' : '',\n\t\t\tparameters.opaque ? '#define OPAQUE' : '',\n\n\t\t\tShaderChunk[ 'colorspace_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below\n\t\t\tgetTexelEncodingFunction( 'linearToOutputTexel', parameters.outputColorSpace ),\n\n\t\t\tparameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',\n\n\t\t\t'\\n'\n\n\t\t].filter( filterEmptyLine ).join( '\\n' );\n\n\t}\n\n\tvertexShader = resolveIncludes( vertexShader );\n\tvertexShader = replaceLightNums( vertexShader, parameters );\n\tvertexShader = replaceClippingPlaneNums( vertexShader, parameters );\n\n\tfragmentShader = resolveIncludes( fragmentShader );\n\tfragmentShader = replaceLightNums( fragmentShader, parameters );\n\tfragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );\n\n\tvertexShader = unrollLoops( vertexShader );\n\tfragmentShader = unrollLoops( fragmentShader );\n\n\tif ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {\n\n\t\t// GLSL 3.0 conversion for built-in materials and ShaderMaterial\n\n\t\tversionString = '#version 300 es\\n';\n\n\t\tprefixVertex = [\n\t\t\t'precision mediump sampler2DArray;',\n\t\t\t'#define attribute in',\n\t\t\t'#define varying out',\n\t\t\t'#define texture2D texture'\n\t\t].join( '\\n' ) + '\\n' + prefixVertex;\n\n\t\tprefixFragment = [\n\t\t\t'#define varying in',\n\t\t\t( parameters.glslVersion === GLSL3 ) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',\n\t\t\t( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',\n\t\t\t'#define gl_FragDepthEXT gl_FragDepth',\n\t\t\t'#define texture2D texture',\n\t\t\t'#define textureCube texture',\n\t\t\t'#define texture2DProj textureProj',\n\t\t\t'#define texture2DLodEXT textureLod',\n\t\t\t'#define texture2DProjLodEXT textureProjLod',\n\t\t\t'#define textureCubeLodEXT textureLod',\n\t\t\t'#define texture2DGradEXT textureGrad',\n\t\t\t'#define texture2DProjGradEXT textureProjGrad',\n\t\t\t'#define textureCubeGradEXT textureGrad'\n\t\t].join( '\\n' ) + '\\n' + prefixFragment;\n\n\t}\n\n\tconst vertexGlsl = versionString + prefixVertex + vertexShader;\n\tconst fragmentGlsl = versionString + prefixFragment + fragmentShader;\n\n\t// console.log( '*VERTEX*', vertexGlsl );\n\t// console.log( '*FRAGMENT*', fragmentGlsl );\n\n\tconst glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\n\tconst glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\n\n\tgl.attachShader( program, glVertexShader );\n\tgl.attachShader( program, glFragmentShader );\n\n\t// Force a particular attribute to index 0.\n\n\tif ( parameters.index0AttributeName !== undefined ) {\n\n\t\tgl.bindAttribLocation( program, 0, parameters.index0AttributeName );\n\n\t} else if ( parameters.morphTargets === true ) {\n\n\t\t// programs with morphTargets displace position out of attribute 0\n\t\tgl.bindAttribLocation( program, 0, 'position' );\n\n\t}\n\n\tgl.linkProgram( program );\n\n\t// check for link errors\n\tif ( renderer.debug.checkShaderErrors ) {\n\n\t\tconst programLog = gl.getProgramInfoLog( program ).trim();\n\t\tconst vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();\n\t\tconst fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();\n\n\t\tlet runnable = true;\n\t\tlet haveDiagnostics = true;\n\n\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\n\n\t\t\trunnable = false;\n\n\t\t\tif ( typeof renderer.debug.onShaderError === 'function' ) {\n\n\t\t\t\trenderer.debug.onShaderError( gl, program, glVertexShader, glFragmentShader );\n\n\t\t\t} else {\n\n\t\t\t\t// default error reporting\n\n\t\t\t\tconst vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );\n\t\t\t\tconst fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );\n\n\t\t\t\tconsole.error(\n\t\t\t\t\t'THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +\n\t\t\t\t\t'VALIDATE_STATUS ' + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + '\\n\\n' +\n\t\t\t\t\t'Program Info Log: ' + programLog + '\\n' +\n\t\t\t\t\tvertexErrors + '\\n' +\n\t\t\t\t\tfragmentErrors\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t} else if ( programLog !== '' ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLProgram: Program Info Log:', programLog );\n\n\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\n\n\t\t\thaveDiagnostics = false;\n\n\t\t}\n\n\t\tif ( haveDiagnostics ) {\n\n\t\t\tthis.diagnostics = {\n\n\t\t\t\trunnable: runnable,\n\n\t\t\t\tprogramLog: programLog,\n\n\t\t\t\tvertexShader: {\n\n\t\t\t\t\tlog: vertexLog,\n\t\t\t\t\tprefix: prefixVertex\n\n\t\t\t\t},\n\n\t\t\t\tfragmentShader: {\n\n\t\t\t\t\tlog: fragmentLog,\n\t\t\t\t\tprefix: prefixFragment\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\t// Clean up\n\n\t// Crashes in iOS9 and iOS10. #18402\n\t// gl.detachShader( program, glVertexShader );\n\t// gl.detachShader( program, glFragmentShader );\n\n\tgl.deleteShader( glVertexShader );\n\tgl.deleteShader( glFragmentShader );\n\n\t// set up caching for uniform locations\n\n\tlet cachedUniforms;\n\n\tthis.getUniforms = function () {\n\n\t\tif ( cachedUniforms === undefined ) {\n\n\t\t\tcachedUniforms = new WebGLUniforms( gl, program );\n\n\t\t}\n\n\t\treturn cachedUniforms;\n\n\t};\n\n\t// set up caching for attribute locations\n\n\tlet cachedAttributes;\n\n\tthis.getAttributes = function () {\n\n\t\tif ( cachedAttributes === undefined ) {\n\n\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\n\n\t\t}\n\n\t\treturn cachedAttributes;\n\n\t};\n\n\t// free resource\n\n\tthis.destroy = function () {\n\n\t\tbindingStates.releaseStatesOfProgram( this );\n\n\t\tgl.deleteProgram( program );\n\t\tthis.program = undefined;\n\n\t};\n\n\t//\n\n\tthis.type = parameters.shaderType;\n\tthis.name = parameters.shaderName;\n\tthis.id = programIdCount ++;\n\tthis.cacheKey = cacheKey;\n\tthis.usedTimes = 1;\n\tthis.program = program;\n\tthis.vertexShader = glVertexShader;\n\tthis.fragmentShader = glFragmentShader;\n\n\treturn this;\n\n}\n\nlet _id = 0;\n\nclass WebGLShaderCache {\n\n\tconstructor() {\n\n\t\tthis.shaderCache = new Map();\n\t\tthis.materialCache = new Map();\n\n\t}\n\n\tupdate( material ) {\n\n\t\tconst vertexShader = material.vertexShader;\n\t\tconst fragmentShader = material.fragmentShader;\n\n\t\tconst vertexShaderStage = this._getShaderStage( vertexShader );\n\t\tconst fragmentShaderStage = this._getShaderStage( fragmentShader );\n\n\t\tconst materialShaders = this._getShaderCacheForMaterial( material );\n\n\t\tif ( materialShaders.has( vertexShaderStage ) === false ) {\n\n\t\t\tmaterialShaders.add( vertexShaderStage );\n\t\t\tvertexShaderStage.usedTimes ++;\n\n\t\t}\n\n\t\tif ( materialShaders.has( fragmentShaderStage ) === false ) {\n\n\t\t\tmaterialShaders.add( fragmentShaderStage );\n\t\t\tfragmentShaderStage.usedTimes ++;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tremove( material ) {\n\n\t\tconst materialShaders = this.materialCache.get( material );\n\n\t\tfor ( const shaderStage of materialShaders ) {\n\n\t\t\tshaderStage.usedTimes --;\n\n\t\t\tif ( shaderStage.usedTimes === 0 ) this.shaderCache.delete( shaderStage.code );\n\n\t\t}\n\n\t\tthis.materialCache.delete( material );\n\n\t\treturn this;\n\n\t}\n\n\tgetVertexShaderID( material ) {\n\n\t\treturn this._getShaderStage( material.vertexShader ).id;\n\n\t}\n\n\tgetFragmentShaderID( material ) {\n\n\t\treturn this._getShaderStage( material.fragmentShader ).id;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shaderCache.clear();\n\t\tthis.materialCache.clear();\n\n\t}\n\n\t_getShaderCacheForMaterial( material ) {\n\n\t\tconst cache = this.materialCache;\n\t\tlet set = cache.get( material );\n\n\t\tif ( set === undefined ) {\n\n\t\t\tset = new Set();\n\t\t\tcache.set( material, set );\n\n\t\t}\n\n\t\treturn set;\n\n\t}\n\n\t_getShaderStage( code ) {\n\n\t\tconst cache = this.shaderCache;\n\t\tlet stage = cache.get( code );\n\n\t\tif ( stage === undefined ) {\n\n\t\t\tstage = new WebGLShaderStage( code );\n\t\t\tcache.set( code, stage );\n\n\t\t}\n\n\t\treturn stage;\n\n\t}\n\n}\n\nclass WebGLShaderStage {\n\n\tconstructor( code ) {\n\n\t\tthis.id = _id ++;\n\n\t\tthis.code = code;\n\t\tthis.usedTimes = 0;\n\n\t}\n\n}\n\nfunction WebGLPrograms( renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping ) {\n\n\tconst _programLayers = new Layers();\n\tconst _customShaders = new WebGLShaderCache();\n\tconst programs = [];\n\n\tconst IS_WEBGL2 = capabilities.isWebGL2;\n\tconst logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;\n\tconst SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;\n\n\tlet precision = capabilities.precision;\n\n\tconst shaderIDs = {\n\t\tMeshDepthMaterial: 'depth',\n\t\tMeshDistanceMaterial: 'distanceRGBA',\n\t\tMeshNormalMaterial: 'normal',\n\t\tMeshBasicMaterial: 'basic',\n\t\tMeshLambertMaterial: 'lambert',\n\t\tMeshPhongMaterial: 'phong',\n\t\tMeshToonMaterial: 'toon',\n\t\tMeshStandardMaterial: 'physical',\n\t\tMeshPhysicalMaterial: 'physical',\n\t\tMeshMatcapMaterial: 'matcap',\n\t\tLineBasicMaterial: 'basic',\n\t\tLineDashedMaterial: 'dashed',\n\t\tPointsMaterial: 'points',\n\t\tShadowMaterial: 'shadow',\n\t\tSpriteMaterial: 'sprite'\n\t};\n\n\tfunction getChannel( value ) {\n\n\t\tif ( value === 0 ) return 'uv';\n\n\t\treturn `uv${ value }`;\n\n\t}\n\n\tfunction getParameters( material, lights, shadows, scene, object ) {\n\n\t\tconst fog = scene.fog;\n\t\tconst geometry = object.geometry;\n\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\n\t\tconst envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );\n\t\tconst envMapCubeUVHeight = ( !! envMap ) && ( envMap.mapping === CubeUVReflectionMapping ) ? envMap.image.height : null;\n\n\t\tconst shaderID = shaderIDs[ material.type ];\n\n\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t// (not to blow over maxLights budget)\n\n\t\tif ( material.precision !== null ) {\n\n\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\n\n\t\t\tif ( precision !== material.precision ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\tlet morphTextureStride = 0;\n\n\t\tif ( geometry.morphAttributes.position !== undefined ) morphTextureStride = 1;\n\t\tif ( geometry.morphAttributes.normal !== undefined ) morphTextureStride = 2;\n\t\tif ( geometry.morphAttributes.color !== undefined ) morphTextureStride = 3;\n\n\t\t//\n\n\t\tlet vertexShader, fragmentShader;\n\t\tlet customVertexShaderID, customFragmentShaderID;\n\n\t\tif ( shaderID ) {\n\n\t\t\tconst shader = ShaderLib[ shaderID ];\n\n\t\t\tvertexShader = shader.vertexShader;\n\t\t\tfragmentShader = shader.fragmentShader;\n\n\t\t} else {\n\n\t\t\tvertexShader = material.vertexShader;\n\t\t\tfragmentShader = material.fragmentShader;\n\n\t\t\t_customShaders.update( material );\n\n\t\t\tcustomVertexShaderID = _customShaders.getVertexShaderID( material );\n\t\t\tcustomFragmentShaderID = _customShaders.getFragmentShaderID( material );\n\n\t\t}\n\n\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\tconst IS_INSTANCEDMESH = object.isInstancedMesh === true;\n\n\t\tconst HAS_MAP = !! material.map;\n\t\tconst HAS_MATCAP = !! material.matcap;\n\t\tconst HAS_ENVMAP = !! envMap;\n\t\tconst HAS_AOMAP = !! material.aoMap;\n\t\tconst HAS_LIGHTMAP = !! material.lightMap;\n\t\tconst HAS_BUMPMAP = !! material.bumpMap;\n\t\tconst HAS_NORMALMAP = !! material.normalMap;\n\t\tconst HAS_DISPLACEMENTMAP = !! material.displacementMap;\n\t\tconst HAS_EMISSIVEMAP = !! material.emissiveMap;\n\n\t\tconst HAS_METALNESSMAP = !! material.metalnessMap;\n\t\tconst HAS_ROUGHNESSMAP = !! material.roughnessMap;\n\n\t\tconst HAS_ANISOTROPY = material.anisotropy > 0;\n\t\tconst HAS_CLEARCOAT = material.clearcoat > 0;\n\t\tconst HAS_IRIDESCENCE = material.iridescence > 0;\n\t\tconst HAS_SHEEN = material.sheen > 0;\n\t\tconst HAS_TRANSMISSION = material.transmission > 0;\n\n\t\tconst HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !! material.anisotropyMap;\n\n\t\tconst HAS_CLEARCOATMAP = HAS_CLEARCOAT && !! material.clearcoatMap;\n\t\tconst HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !! material.clearcoatNormalMap;\n\t\tconst HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !! material.clearcoatRoughnessMap;\n\n\t\tconst HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !! material.iridescenceMap;\n\t\tconst HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !! material.iridescenceThicknessMap;\n\n\t\tconst HAS_SHEEN_COLORMAP = HAS_SHEEN && !! material.sheenColorMap;\n\t\tconst HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !! material.sheenRoughnessMap;\n\n\t\tconst HAS_SPECULARMAP = !! material.specularMap;\n\t\tconst HAS_SPECULAR_COLORMAP = !! material.specularColorMap;\n\t\tconst HAS_SPECULAR_INTENSITYMAP = !! material.specularIntensityMap;\n\n\t\tconst HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !! material.transmissionMap;\n\t\tconst HAS_THICKNESSMAP = HAS_TRANSMISSION && !! material.thicknessMap;\n\n\t\tconst HAS_GRADIENTMAP = !! material.gradientMap;\n\n\t\tconst HAS_ALPHAMAP = !! material.alphaMap;\n\n\t\tconst HAS_ALPHATEST = material.alphaTest > 0;\n\n\t\tconst HAS_ALPHAHASH = !! material.alphaHash;\n\n\t\tconst HAS_EXTENSIONS = !! material.extensions;\n\n\t\tconst HAS_ATTRIBUTE_UV1 = !! geometry.attributes.uv1;\n\t\tconst HAS_ATTRIBUTE_UV2 = !! geometry.attributes.uv2;\n\t\tconst HAS_ATTRIBUTE_UV3 = !! geometry.attributes.uv3;\n\n\t\tconst parameters = {\n\n\t\t\tisWebGL2: IS_WEBGL2,\n\n\t\t\tshaderID: shaderID,\n\t\t\tshaderType: material.type,\n\t\t\tshaderName: material.name,\n\n\t\t\tvertexShader: vertexShader,\n\t\t\tfragmentShader: fragmentShader,\n\t\t\tdefines: material.defines,\n\n\t\t\tcustomVertexShaderID: customVertexShaderID,\n\t\t\tcustomFragmentShaderID: customFragmentShaderID,\n\n\t\t\tisRawShaderMaterial: material.isRawShaderMaterial === true,\n\t\t\tglslVersion: material.glslVersion,\n\n\t\t\tprecision: precision,\n\n\t\t\tinstancing: IS_INSTANCEDMESH,\n\t\t\tinstancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,\n\n\t\t\tsupportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,\n\t\t\toutputColorSpace: ( currentRenderTarget === null ) ? renderer.outputColorSpace : ( currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace ),\n\n\t\t\tmap: HAS_MAP,\n\t\t\tmatcap: HAS_MATCAP,\n\t\t\tenvMap: HAS_ENVMAP,\n\t\t\tenvMapMode: HAS_ENVMAP && envMap.mapping,\n\t\t\tenvMapCubeUVHeight: envMapCubeUVHeight,\n\t\t\taoMap: HAS_AOMAP,\n\t\t\tlightMap: HAS_LIGHTMAP,\n\t\t\tbumpMap: HAS_BUMPMAP,\n\t\t\tnormalMap: HAS_NORMALMAP,\n\t\t\tdisplacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,\n\t\t\temissiveMap: HAS_EMISSIVEMAP,\n\n\t\t\tnormalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,\n\t\t\tnormalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,\n\n\t\t\tmetalnessMap: HAS_METALNESSMAP,\n\t\t\troughnessMap: HAS_ROUGHNESSMAP,\n\n\t\t\tanisotropy: HAS_ANISOTROPY,\n\t\t\tanisotropyMap: HAS_ANISOTROPYMAP,\n\n\t\t\tclearcoat: HAS_CLEARCOAT,\n\t\t\tclearcoatMap: HAS_CLEARCOATMAP,\n\t\t\tclearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,\n\t\t\tclearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,\n\n\t\t\tiridescence: HAS_IRIDESCENCE,\n\t\t\tiridescenceMap: HAS_IRIDESCENCEMAP,\n\t\t\tiridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,\n\n\t\t\tsheen: HAS_SHEEN,\n\t\t\tsheenColorMap: HAS_SHEEN_COLORMAP,\n\t\t\tsheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,\n\n\t\t\tspecularMap: HAS_SPECULARMAP,\n\t\t\tspecularColorMap: HAS_SPECULAR_COLORMAP,\n\t\t\tspecularIntensityMap: HAS_SPECULAR_INTENSITYMAP,\n\n\t\t\ttransmission: HAS_TRANSMISSION,\n\t\t\ttransmissionMap: HAS_TRANSMISSIONMAP,\n\t\t\tthicknessMap: HAS_THICKNESSMAP,\n\n\t\t\tgradientMap: HAS_GRADIENTMAP,\n\n\t\t\topaque: material.transparent === false && material.blending === NormalBlending,\n\n\t\t\talphaMap: HAS_ALPHAMAP,\n\t\t\talphaTest: HAS_ALPHATEST,\n\t\t\talphaHash: HAS_ALPHAHASH,\n\n\t\t\tcombine: material.combine,\n\n\t\t\t//\n\n\t\t\tmapUv: HAS_MAP && getChannel( material.map.channel ),\n\t\t\taoMapUv: HAS_AOMAP && getChannel( material.aoMap.channel ),\n\t\t\tlightMapUv: HAS_LIGHTMAP && getChannel( material.lightMap.channel ),\n\t\t\tbumpMapUv: HAS_BUMPMAP && getChannel( material.bumpMap.channel ),\n\t\t\tnormalMapUv: HAS_NORMALMAP && getChannel( material.normalMap.channel ),\n\t\t\tdisplacementMapUv: HAS_DISPLACEMENTMAP && getChannel( material.displacementMap.channel ),\n\t\t\temissiveMapUv: HAS_EMISSIVEMAP && getChannel( material.emissiveMap.channel ),\n\n\t\t\tmetalnessMapUv: HAS_METALNESSMAP && getChannel( material.metalnessMap.channel ),\n\t\t\troughnessMapUv: HAS_ROUGHNESSMAP && getChannel( material.roughnessMap.channel ),\n\n\t\t\tanisotropyMapUv: HAS_ANISOTROPYMAP && getChannel( material.anisotropyMap.channel ),\n\n\t\t\tclearcoatMapUv: HAS_CLEARCOATMAP && getChannel( material.clearcoatMap.channel ),\n\t\t\tclearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel( material.clearcoatNormalMap.channel ),\n\t\t\tclearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel( material.clearcoatRoughnessMap.channel ),\n\n\t\t\tiridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel( material.iridescenceMap.channel ),\n\t\t\tiridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel( material.iridescenceThicknessMap.channel ),\n\n\t\t\tsheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel( material.sheenColorMap.channel ),\n\t\t\tsheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel( material.sheenRoughnessMap.channel ),\n\n\t\t\tspecularMapUv: HAS_SPECULARMAP && getChannel( material.specularMap.channel ),\n\t\t\tspecularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel( material.specularColorMap.channel ),\n\t\t\tspecularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel( material.specularIntensityMap.channel ),\n\n\t\t\ttransmissionMapUv: HAS_TRANSMISSIONMAP && getChannel( material.transmissionMap.channel ),\n\t\t\tthicknessMapUv: HAS_THICKNESSMAP && getChannel( material.thicknessMap.channel ),\n\n\t\t\talphaMapUv: HAS_ALPHAMAP && getChannel( material.alphaMap.channel ),\n\n\t\t\t//\n\n\t\t\tvertexTangents: !! geometry.attributes.tangent && ( HAS_NORMALMAP || HAS_ANISOTROPY ),\n\t\t\tvertexColors: material.vertexColors,\n\t\t\tvertexAlphas: material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4,\n\t\t\tvertexUv1s: HAS_ATTRIBUTE_UV1,\n\t\t\tvertexUv2s: HAS_ATTRIBUTE_UV2,\n\t\t\tvertexUv3s: HAS_ATTRIBUTE_UV3,\n\n\t\t\tpointsUvs: object.isPoints === true && !! geometry.attributes.uv && ( HAS_MAP || HAS_ALPHAMAP ),\n\n\t\t\tfog: !! fog,\n\t\t\tuseFog: material.fog === true,\n\t\t\tfogExp2: ( fog && fog.isFogExp2 ),\n\n\t\t\tflatShading: material.flatShading === true,\n\n\t\t\tsizeAttenuation: material.sizeAttenuation === true,\n\t\t\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\n\n\t\t\tskinning: object.isSkinnedMesh === true,\n\n\t\t\tmorphTargets: geometry.morphAttributes.position !== undefined,\n\t\t\tmorphNormals: geometry.morphAttributes.normal !== undefined,\n\t\t\tmorphColors: geometry.morphAttributes.color !== undefined,\n\t\t\tmorphTargetsCount: morphTargetsCount,\n\t\t\tmorphTextureStride: morphTextureStride,\n\n\t\t\tnumDirLights: lights.directional.length,\n\t\t\tnumPointLights: lights.point.length,\n\t\t\tnumSpotLights: lights.spot.length,\n\t\t\tnumSpotLightMaps: lights.spotLightMap.length,\n\t\t\tnumRectAreaLights: lights.rectArea.length,\n\t\t\tnumHemiLights: lights.hemi.length,\n\n\t\t\tnumDirLightShadows: lights.directionalShadowMap.length,\n\t\t\tnumPointLightShadows: lights.pointShadowMap.length,\n\t\t\tnumSpotLightShadows: lights.spotShadowMap.length,\n\t\t\tnumSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,\n\n\t\t\tnumClippingPlanes: clipping.numPlanes,\n\t\t\tnumClipIntersection: clipping.numIntersection,\n\n\t\t\tdithering: material.dithering,\n\n\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,\n\t\t\tshadowMapType: renderer.shadowMap.type,\n\n\t\t\ttoneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,\n\t\t\tuseLegacyLights: renderer.useLegacyLights,\n\n\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\n\n\t\t\tdoubleSided: material.side === DoubleSide,\n\t\t\tflipSided: material.side === BackSide,\n\n\t\t\tuseDepthPacking: material.depthPacking >= 0,\n\t\t\tdepthPacking: material.depthPacking || 0,\n\n\t\t\tindex0AttributeName: material.index0AttributeName,\n\n\t\t\textensionDerivatives: HAS_EXTENSIONS && material.extensions.derivatives === true,\n\t\t\textensionFragDepth: HAS_EXTENSIONS && material.extensions.fragDepth === true,\n\t\t\textensionDrawBuffers: HAS_EXTENSIONS && material.extensions.drawBuffers === true,\n\t\t\textensionShaderTextureLOD: HAS_EXTENSIONS && material.extensions.shaderTextureLOD === true,\n\n\t\t\trendererExtensionFragDepth: IS_WEBGL2 || extensions.has( 'EXT_frag_depth' ),\n\t\t\trendererExtensionDrawBuffers: IS_WEBGL2 || extensions.has( 'WEBGL_draw_buffers' ),\n\t\t\trendererExtensionShaderTextureLod: IS_WEBGL2 || extensions.has( 'EXT_shader_texture_lod' ),\n\n\t\t\tcustomProgramCacheKey: material.customProgramCacheKey()\n\n\t\t};\n\n\t\treturn parameters;\n\n\t}\n\n\tfunction getProgramCacheKey( parameters ) {\n\n\t\tconst array = [];\n\n\t\tif ( parameters.shaderID ) {\n\n\t\t\tarray.push( parameters.shaderID );\n\n\t\t} else {\n\n\t\t\tarray.push( parameters.customVertexShaderID );\n\t\t\tarray.push( parameters.customFragmentShaderID );\n\n\t\t}\n\n\t\tif ( parameters.defines !== undefined ) {\n\n\t\t\tfor ( const name in parameters.defines ) {\n\n\t\t\t\tarray.push( name );\n\t\t\t\tarray.push( parameters.defines[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parameters.isRawShaderMaterial === false ) {\n\n\t\t\tgetProgramCacheKeyParameters( array, parameters );\n\t\t\tgetProgramCacheKeyBooleans( array, parameters );\n\t\t\tarray.push( renderer.outputColorSpace );\n\n\t\t}\n\n\t\tarray.push( parameters.customProgramCacheKey );\n\n\t\treturn array.join();\n\n\t}\n\n\tfunction getProgramCacheKeyParameters( array, parameters ) {\n\n\t\tarray.push( parameters.precision );\n\t\tarray.push( parameters.outputColorSpace );\n\t\tarray.push( parameters.envMapMode );\n\t\tarray.push( parameters.envMapCubeUVHeight );\n\t\tarray.push( parameters.mapUv );\n\t\tarray.push( parameters.alphaMapUv );\n\t\tarray.push( parameters.lightMapUv );\n\t\tarray.push( parameters.aoMapUv );\n\t\tarray.push( parameters.bumpMapUv );\n\t\tarray.push( parameters.normalMapUv );\n\t\tarray.push( parameters.displacementMapUv );\n\t\tarray.push( parameters.emissiveMapUv );\n\t\tarray.push( parameters.metalnessMapUv );\n\t\tarray.push( parameters.roughnessMapUv );\n\t\tarray.push( parameters.anisotropyMapUv );\n\t\tarray.push( parameters.clearcoatMapUv );\n\t\tarray.push( parameters.clearcoatNormalMapUv );\n\t\tarray.push( parameters.clearcoatRoughnessMapUv );\n\t\tarray.push( parameters.iridescenceMapUv );\n\t\tarray.push( parameters.iridescenceThicknessMapUv );\n\t\tarray.push( parameters.sheenColorMapUv );\n\t\tarray.push( parameters.sheenRoughnessMapUv );\n\t\tarray.push( parameters.specularMapUv );\n\t\tarray.push( parameters.specularColorMapUv );\n\t\tarray.push( parameters.specularIntensityMapUv );\n\t\tarray.push( parameters.transmissionMapUv );\n\t\tarray.push( parameters.thicknessMapUv );\n\t\tarray.push( parameters.combine );\n\t\tarray.push( parameters.fogExp2 );\n\t\tarray.push( parameters.sizeAttenuation );\n\t\tarray.push( parameters.morphTargetsCount );\n\t\tarray.push( parameters.morphAttributeCount );\n\t\tarray.push( parameters.numDirLights );\n\t\tarray.push( parameters.numPointLights );\n\t\tarray.push( parameters.numSpotLights );\n\t\tarray.push( parameters.numSpotLightMaps );\n\t\tarray.push( parameters.numHemiLights );\n\t\tarray.push( parameters.numRectAreaLights );\n\t\tarray.push( parameters.numDirLightShadows );\n\t\tarray.push( parameters.numPointLightShadows );\n\t\tarray.push( parameters.numSpotLightShadows );\n\t\tarray.push( parameters.numSpotLightShadowsWithMaps );\n\t\tarray.push( parameters.shadowMapType );\n\t\tarray.push( parameters.toneMapping );\n\t\tarray.push( parameters.numClippingPlanes );\n\t\tarray.push( parameters.numClipIntersection );\n\t\tarray.push( parameters.depthPacking );\n\n\t}\n\n\tfunction getProgramCacheKeyBooleans( array, parameters ) {\n\n\t\t_programLayers.disableAll();\n\n\t\tif ( parameters.isWebGL2 )\n\t\t\t_programLayers.enable( 0 );\n\t\tif ( parameters.supportsVertexTextures )\n\t\t\t_programLayers.enable( 1 );\n\t\tif ( parameters.instancing )\n\t\t\t_programLayers.enable( 2 );\n\t\tif ( parameters.instancingColor )\n\t\t\t_programLayers.enable( 3 );\n\t\tif ( parameters.matcap )\n\t\t\t_programLayers.enable( 4 );\n\t\tif ( parameters.envMap )\n\t\t\t_programLayers.enable( 5 );\n\t\tif ( parameters.normalMapObjectSpace )\n\t\t\t_programLayers.enable( 6 );\n\t\tif ( parameters.normalMapTangentSpace )\n\t\t\t_programLayers.enable( 7 );\n\t\tif ( parameters.clearcoat )\n\t\t\t_programLayers.enable( 8 );\n\t\tif ( parameters.iridescence )\n\t\t\t_programLayers.enable( 9 );\n\t\tif ( parameters.alphaTest )\n\t\t\t_programLayers.enable( 10 );\n\t\tif ( parameters.vertexColors )\n\t\t\t_programLayers.enable( 11 );\n\t\tif ( parameters.vertexAlphas )\n\t\t\t_programLayers.enable( 12 );\n\t\tif ( parameters.vertexUv1s )\n\t\t\t_programLayers.enable( 13 );\n\t\tif ( parameters.vertexUv2s )\n\t\t\t_programLayers.enable( 14 );\n\t\tif ( parameters.vertexUv3s )\n\t\t\t_programLayers.enable( 15 );\n\t\tif ( parameters.vertexTangents )\n\t\t\t_programLayers.enable( 16 );\n\t\tif ( parameters.anisotropy )\n\t\t\t_programLayers.enable( 17 );\n\n\t\tarray.push( _programLayers.mask );\n\t\t_programLayers.disableAll();\n\n\t\tif ( parameters.fog )\n\t\t\t_programLayers.enable( 0 );\n\t\tif ( parameters.useFog )\n\t\t\t_programLayers.enable( 1 );\n\t\tif ( parameters.flatShading )\n\t\t\t_programLayers.enable( 2 );\n\t\tif ( parameters.logarithmicDepthBuffer )\n\t\t\t_programLayers.enable( 3 );\n\t\tif ( parameters.skinning )\n\t\t\t_programLayers.enable( 4 );\n\t\tif ( parameters.morphTargets )\n\t\t\t_programLayers.enable( 5 );\n\t\tif ( parameters.morphNormals )\n\t\t\t_programLayers.enable( 6 );\n\t\tif ( parameters.morphColors )\n\t\t\t_programLayers.enable( 7 );\n\t\tif ( parameters.premultipliedAlpha )\n\t\t\t_programLayers.enable( 8 );\n\t\tif ( parameters.shadowMapEnabled )\n\t\t\t_programLayers.enable( 9 );\n\t\tif ( parameters.useLegacyLights )\n\t\t\t_programLayers.enable( 10 );\n\t\tif ( parameters.doubleSided )\n\t\t\t_programLayers.enable( 11 );\n\t\tif ( parameters.flipSided )\n\t\t\t_programLayers.enable( 12 );\n\t\tif ( parameters.useDepthPacking )\n\t\t\t_programLayers.enable( 13 );\n\t\tif ( parameters.dithering )\n\t\t\t_programLayers.enable( 14 );\n\t\tif ( parameters.transmission )\n\t\t\t_programLayers.enable( 15 );\n\t\tif ( parameters.sheen )\n\t\t\t_programLayers.enable( 16 );\n\t\tif ( parameters.opaque )\n\t\t\t_programLayers.enable( 17 );\n\t\tif ( parameters.pointsUvs )\n\t\t\t_programLayers.enable( 18 );\n\n\t\tarray.push( _programLayers.mask );\n\n\t}\n\n\tfunction getUniforms( material ) {\n\n\t\tconst shaderID = shaderIDs[ material.type ];\n\t\tlet uniforms;\n\n\t\tif ( shaderID ) {\n\n\t\t\tconst shader = ShaderLib[ shaderID ];\n\t\t\tuniforms = UniformsUtils.clone( shader.uniforms );\n\n\t\t} else {\n\n\t\t\tuniforms = material.uniforms;\n\n\t\t}\n\n\t\treturn uniforms;\n\n\t}\n\n\tfunction acquireProgram( parameters, cacheKey ) {\n\n\t\tlet program;\n\n\t\t// Check if code has been already compiled\n\t\tfor ( let p = 0, pl = programs.length; p < pl; p ++ ) {\n\n\t\t\tconst preexistingProgram = programs[ p ];\n\n\t\t\tif ( preexistingProgram.cacheKey === cacheKey ) {\n\n\t\t\t\tprogram = preexistingProgram;\n\t\t\t\t++ program.usedTimes;\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( program === undefined ) {\n\n\t\t\tprogram = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );\n\t\t\tprograms.push( program );\n\n\t\t}\n\n\t\treturn program;\n\n\t}\n\n\tfunction releaseProgram( program ) {\n\n\t\tif ( -- program.usedTimes === 0 ) {\n\n\t\t\t// Remove from unordered set\n\t\t\tconst i = programs.indexOf( program );\n\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\n\t\t\tprograms.pop();\n\n\t\t\t// Free WebGL resources\n\t\t\tprogram.destroy();\n\n\t\t}\n\n\t}\n\n\tfunction releaseShaderCache( material ) {\n\n\t\t_customShaders.remove( material );\n\n\t}\n\n\tfunction dispose() {\n\n\t\t_customShaders.dispose();\n\n\t}\n\n\treturn {\n\t\tgetParameters: getParameters,\n\t\tgetProgramCacheKey: getProgramCacheKey,\n\t\tgetUniforms: getUniforms,\n\t\tacquireProgram: acquireProgram,\n\t\treleaseProgram: releaseProgram,\n\t\treleaseShaderCache: releaseShaderCache,\n\t\t// Exposed for resource monitoring & error feedback via renderer.info:\n\t\tprograms: programs,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction WebGLProperties() {\n\n\tlet properties = new WeakMap();\n\n\tfunction get( object ) {\n\n\t\tlet map = properties.get( object );\n\n\t\tif ( map === undefined ) {\n\n\t\t\tmap = {};\n\t\t\tproperties.set( object, map );\n\n\t\t}\n\n\t\treturn map;\n\n\t}\n\n\tfunction remove( object ) {\n\n\t\tproperties.delete( object );\n\n\t}\n\n\tfunction update( object, key, value ) {\n\n\t\tproperties.get( object )[ key ] = value;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tproperties = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tremove: remove,\n\t\tupdate: update,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction painterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.material.id !== b.material.id ) {\n\n\t\treturn a.material.id - b.material.id;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn a.z - b.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\nfunction reversePainterSortStable( a, b ) {\n\n\tif ( a.groupOrder !== b.groupOrder ) {\n\n\t\treturn a.groupOrder - b.groupOrder;\n\n\t} else if ( a.renderOrder !== b.renderOrder ) {\n\n\t\treturn a.renderOrder - b.renderOrder;\n\n\t} else if ( a.z !== b.z ) {\n\n\t\treturn b.z - a.z;\n\n\t} else {\n\n\t\treturn a.id - b.id;\n\n\t}\n\n}\n\n\nfunction WebGLRenderList() {\n\n\tconst renderItems = [];\n\tlet renderItemsIndex = 0;\n\n\tconst opaque = [];\n\tconst transmissive = [];\n\tconst transparent = [];\n\n\tfunction init() {\n\n\t\trenderItemsIndex = 0;\n\n\t\topaque.length = 0;\n\t\ttransmissive.length = 0;\n\t\ttransparent.length = 0;\n\n\t}\n\n\tfunction getNextRenderItem( object, geometry, material, groupOrder, z, group ) {\n\n\t\tlet renderItem = renderItems[ renderItemsIndex ];\n\n\t\tif ( renderItem === undefined ) {\n\n\t\t\trenderItem = {\n\t\t\t\tid: object.id,\n\t\t\t\tobject: object,\n\t\t\t\tgeometry: geometry,\n\t\t\t\tmaterial: material,\n\t\t\t\tgroupOrder: groupOrder,\n\t\t\t\trenderOrder: object.renderOrder,\n\t\t\t\tz: z,\n\t\t\t\tgroup: group\n\t\t\t};\n\n\t\t\trenderItems[ renderItemsIndex ] = renderItem;\n\n\t\t} else {\n\n\t\t\trenderItem.id = object.id;\n\t\t\trenderItem.object = object;\n\t\t\trenderItem.geometry = geometry;\n\t\t\trenderItem.material = material;\n\t\t\trenderItem.groupOrder = groupOrder;\n\t\t\trenderItem.renderOrder = object.renderOrder;\n\t\t\trenderItem.z = z;\n\t\t\trenderItem.group = group;\n\n\t\t}\n\n\t\trenderItemsIndex ++;\n\n\t\treturn renderItem;\n\n\t}\n\n\tfunction push( object, geometry, material, groupOrder, z, group ) {\n\n\t\tconst renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );\n\n\t\tif ( material.transmission > 0.0 ) {\n\n\t\t\ttransmissive.push( renderItem );\n\n\t\t} else if ( material.transparent === true ) {\n\n\t\t\ttransparent.push( renderItem );\n\n\t\t} else {\n\n\t\t\topaque.push( renderItem );\n\n\t\t}\n\n\t}\n\n\tfunction unshift( object, geometry, material, groupOrder, z, group ) {\n\n\t\tconst renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );\n\n\t\tif ( material.transmission > 0.0 ) {\n\n\t\t\ttransmissive.unshift( renderItem );\n\n\t\t} else if ( material.transparent === true ) {\n\n\t\t\ttransparent.unshift( renderItem );\n\n\t\t} else {\n\n\t\t\topaque.unshift( renderItem );\n\n\t\t}\n\n\t}\n\n\tfunction sort( customOpaqueSort, customTransparentSort ) {\n\n\t\tif ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );\n\t\tif ( transmissive.length > 1 ) transmissive.sort( customTransparentSort || reversePainterSortStable );\n\t\tif ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );\n\n\t}\n\n\tfunction finish() {\n\n\t\t// Clear references from inactive renderItems in the list\n\n\t\tfor ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {\n\n\t\t\tconst renderItem = renderItems[ i ];\n\n\t\t\tif ( renderItem.id === null ) break;\n\n\t\t\trenderItem.id = null;\n\t\t\trenderItem.object = null;\n\t\t\trenderItem.geometry = null;\n\t\t\trenderItem.material = null;\n\t\t\trenderItem.group = null;\n\n\t\t}\n\n\t}\n\n\treturn {\n\n\t\topaque: opaque,\n\t\ttransmissive: transmissive,\n\t\ttransparent: transparent,\n\n\t\tinit: init,\n\t\tpush: push,\n\t\tunshift: unshift,\n\t\tfinish: finish,\n\n\t\tsort: sort\n\t};\n\n}\n\nfunction WebGLRenderLists() {\n\n\tlet lists = new WeakMap();\n\n\tfunction get( scene, renderCallDepth ) {\n\n\t\tconst listArray = lists.get( scene );\n\t\tlet list;\n\n\t\tif ( listArray === undefined ) {\n\n\t\t\tlist = new WebGLRenderList();\n\t\t\tlists.set( scene, [ list ] );\n\n\t\t} else {\n\n\t\t\tif ( renderCallDepth >= listArray.length ) {\n\n\t\t\t\tlist = new WebGLRenderList();\n\t\t\t\tlistArray.push( list );\n\n\t\t\t} else {\n\n\t\t\t\tlist = listArray[ renderCallDepth ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn list;\n\n\t}\n\n\tfunction dispose() {\n\n\t\tlists = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nfunction UniformsCache() {\n\n\tconst lights = {};\n\n\treturn {\n\n\t\tget: function ( light ) {\n\n\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\treturn lights[ light.id ];\n\n\t\t\t}\n\n\t\t\tlet uniforms;\n\n\t\t\tswitch ( light.type ) {\n\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tcolor: new Color()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tconeCos: 0,\n\t\t\t\t\t\tpenumbraCos: 0,\n\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tdistance: 0,\n\t\t\t\t\t\tdecay: 0\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tdirection: new Vector3(),\n\t\t\t\t\t\tskyColor: new Color(),\n\t\t\t\t\t\tgroundColor: new Color()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'RectAreaLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tcolor: new Color(),\n\t\t\t\t\t\tposition: new Vector3(),\n\t\t\t\t\t\thalfWidth: new Vector3(),\n\t\t\t\t\t\thalfHeight: new Vector3()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\treturn uniforms;\n\n\t\t}\n\n\t};\n\n}\n\nfunction ShadowUniformsCache() {\n\n\tconst lights = {};\n\n\treturn {\n\n\t\tget: function ( light ) {\n\n\t\t\tif ( lights[ light.id ] !== undefined ) {\n\n\t\t\t\treturn lights[ light.id ];\n\n\t\t\t}\n\n\t\t\tlet uniforms;\n\n\t\t\tswitch ( light.type ) {\n\n\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2()\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\t\t\t\t\tuniforms = {\n\t\t\t\t\t\tshadowBias: 0,\n\t\t\t\t\t\tshadowNormalBias: 0,\n\t\t\t\t\t\tshadowRadius: 1,\n\t\t\t\t\t\tshadowMapSize: new Vector2(),\n\t\t\t\t\t\tshadowCameraNear: 1,\n\t\t\t\t\t\tshadowCameraFar: 1000\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t\t// TODO (abelnation): set RectAreaLight shadow uniforms\n\n\t\t\t}\n\n\t\t\tlights[ light.id ] = uniforms;\n\n\t\t\treturn uniforms;\n\n\t\t}\n\n\t};\n\n}\n\n\n\nlet nextVersion = 0;\n\nfunction shadowCastingAndTexturingLightsFirst( lightA, lightB ) {\n\n\treturn ( lightB.castShadow ? 2 : 0 ) - ( lightA.castShadow ? 2 : 0 ) + ( lightB.map ? 1 : 0 ) - ( lightA.map ? 1 : 0 );\n\n}\n\nfunction WebGLLights( extensions, capabilities ) {\n\n\tconst cache = new UniformsCache();\n\n\tconst shadowCache = ShadowUniformsCache();\n\n\tconst state = {\n\n\t\tversion: 0,\n\n\t\thash: {\n\t\t\tdirectionalLength: - 1,\n\t\t\tpointLength: - 1,\n\t\t\tspotLength: - 1,\n\t\t\trectAreaLength: - 1,\n\t\t\themiLength: - 1,\n\n\t\t\tnumDirectionalShadows: - 1,\n\t\t\tnumPointShadows: - 1,\n\t\t\tnumSpotShadows: - 1,\n\t\t\tnumSpotMaps: - 1\n\t\t},\n\n\t\tambient: [ 0, 0, 0 ],\n\t\tprobe: [],\n\t\tdirectional: [],\n\t\tdirectionalShadow: [],\n\t\tdirectionalShadowMap: [],\n\t\tdirectionalShadowMatrix: [],\n\t\tspot: [],\n\t\tspotLightMap: [],\n\t\tspotShadow: [],\n\t\tspotShadowMap: [],\n\t\tspotLightMatrix: [],\n\t\trectArea: [],\n\t\trectAreaLTC1: null,\n\t\trectAreaLTC2: null,\n\t\tpoint: [],\n\t\tpointShadow: [],\n\t\tpointShadowMap: [],\n\t\tpointShadowMatrix: [],\n\t\themi: [],\n\t\tnumSpotLightShadowsWithMaps: 0\n\n\t};\n\n\tfor ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );\n\n\tconst vector3 = new Vector3();\n\tconst matrix4 = new Matrix4();\n\tconst matrix42 = new Matrix4();\n\n\tfunction setup( lights, useLegacyLights ) {\n\n\t\tlet r = 0, g = 0, b = 0;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );\n\n\t\tlet directionalLength = 0;\n\t\tlet pointLength = 0;\n\t\tlet spotLength = 0;\n\t\tlet rectAreaLength = 0;\n\t\tlet hemiLength = 0;\n\n\t\tlet numDirectionalShadows = 0;\n\t\tlet numPointShadows = 0;\n\t\tlet numSpotShadows = 0;\n\t\tlet numSpotMaps = 0;\n\t\tlet numSpotShadowsWithMaps = 0;\n\n\t\t// ordering : [shadow casting + map texturing, map texturing, shadow casting, none ]\n\t\tlights.sort( shadowCastingAndTexturingLightsFirst );\n\n\t\t// artist-friendly light intensity scaling factor\n\t\tconst scaleFactor = ( useLegacyLights === true ) ? Math.PI : 1;\n\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\n\t\t\tconst color = light.color;\n\t\t\tconst intensity = light.intensity;\n\t\t\tconst distance = light.distance;\n\n\t\t\tconst shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\n\n\t\t\tif ( light.isAmbientLight ) {\n\n\t\t\t\tr += color.r * intensity * scaleFactor;\n\t\t\t\tg += color.g * intensity * scaleFactor;\n\t\t\t\tb += color.b * intensity * scaleFactor;\n\n\t\t\t} else if ( light.isLightProbe ) {\n\n\t\t\t\tfor ( let j = 0; j < 9; j ++ ) {\n\n\t\t\t\t\tstate.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );\n\n\t\t\t\t}\n\n\t\t\t} else if ( light.isDirectionalLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t\tstate.directionalShadow[ directionalLength ] = shadowUniforms;\n\t\t\t\t\tstate.directionalShadowMap[ directionalLength ] = shadowMap;\n\t\t\t\t\tstate.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\n\n\t\t\t\t\tnumDirectionalShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.directional[ directionalLength ] = uniforms;\n\n\t\t\t\tdirectionalLength ++;\n\n\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity * scaleFactor );\n\t\t\t\tuniforms.distance = distance;\n\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\n\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\tstate.spot[ spotLength ] = uniforms;\n\n\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\tif ( light.map ) {\n\n\t\t\t\t\tstate.spotLightMap[ numSpotMaps ] = light.map;\n\t\t\t\t\tnumSpotMaps ++;\n\n\t\t\t\t\t// make sure the lightMatrix is up to date\n\t\t\t\t\t// TODO : do it if required only\n\t\t\t\t\tshadow.updateMatrices( light );\n\n\t\t\t\t\tif ( light.castShadow ) numSpotShadowsWithMaps ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.spotLightMatrix[ spotLength ] = shadow.matrix;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\n\t\t\t\t\tstate.spotShadow[ spotLength ] = shadowUniforms;\n\t\t\t\t\tstate.spotShadowMap[ spotLength ] = shadowMap;\n\n\t\t\t\t\tnumSpotShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tspotLength ++;\n\n\t\t\t} else if ( light.isRectAreaLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\n\n\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\n\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\t\t\tstate.rectArea[ rectAreaLength ] = uniforms;\n\n\t\t\t\trectAreaLength ++;\n\n\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity * scaleFactor );\n\t\t\t\tuniforms.distance = light.distance;\n\t\t\t\tuniforms.decay = light.decay;\n\n\t\t\t\tif ( light.castShadow ) {\n\n\t\t\t\t\tconst shadow = light.shadow;\n\n\t\t\t\t\tconst shadowUniforms = shadowCache.get( light );\n\n\t\t\t\t\tshadowUniforms.shadowBias = shadow.bias;\n\t\t\t\t\tshadowUniforms.shadowNormalBias = shadow.normalBias;\n\t\t\t\t\tshadowUniforms.shadowRadius = shadow.radius;\n\t\t\t\t\tshadowUniforms.shadowMapSize = shadow.mapSize;\n\t\t\t\t\tshadowUniforms.shadowCameraNear = shadow.camera.near;\n\t\t\t\t\tshadowUniforms.shadowCameraFar = shadow.camera.far;\n\n\t\t\t\t\tstate.pointShadow[ pointLength ] = shadowUniforms;\n\t\t\t\t\tstate.pointShadowMap[ pointLength ] = shadowMap;\n\t\t\t\t\tstate.pointShadowMatrix[ pointLength ] = light.shadow.matrix;\n\n\t\t\t\t\tnumPointShadows ++;\n\n\t\t\t\t}\n\n\t\t\t\tstate.point[ pointLength ] = uniforms;\n\n\t\t\t\tpointLength ++;\n\n\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\tconst uniforms = cache.get( light );\n\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity * scaleFactor );\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity * scaleFactor );\n\n\t\t\t\tstate.hemi[ hemiLength ] = uniforms;\n\n\t\t\t\themiLength ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( rectAreaLength > 0 ) {\n\n\t\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\t\t// WebGL 2\n\n\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n\n\t\t\t} else {\n\n\t\t\t\t// WebGL 1\n\n\t\t\t\tif ( extensions.has( 'OES_texture_float_linear' ) === true ) {\n\n\t\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n\t\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n\n\t\t\t\t} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {\n\n\t\t\t\t\tstate.rectAreaLTC1 = UniformsLib.LTC_HALF_1;\n\t\t\t\t\tstate.rectAreaLTC2 = UniformsLib.LTC_HALF_2;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.ambient[ 0 ] = r;\n\t\tstate.ambient[ 1 ] = g;\n\t\tstate.ambient[ 2 ] = b;\n\n\t\tconst hash = state.hash;\n\n\t\tif ( hash.directionalLength !== directionalLength ||\n\t\t\thash.pointLength !== pointLength ||\n\t\t\thash.spotLength !== spotLength ||\n\t\t\thash.rectAreaLength !== rectAreaLength ||\n\t\t\thash.hemiLength !== hemiLength ||\n\t\t\thash.numDirectionalShadows !== numDirectionalShadows ||\n\t\t\thash.numPointShadows !== numPointShadows ||\n\t\t\thash.numSpotShadows !== numSpotShadows ||\n\t\t\thash.numSpotMaps !== numSpotMaps ) {\n\n\t\t\tstate.directional.length = directionalLength;\n\t\t\tstate.spot.length = spotLength;\n\t\t\tstate.rectArea.length = rectAreaLength;\n\t\t\tstate.point.length = pointLength;\n\t\t\tstate.hemi.length = hemiLength;\n\n\t\t\tstate.directionalShadow.length = numDirectionalShadows;\n\t\t\tstate.directionalShadowMap.length = numDirectionalShadows;\n\t\t\tstate.pointShadow.length = numPointShadows;\n\t\t\tstate.pointShadowMap.length = numPointShadows;\n\t\t\tstate.spotShadow.length = numSpotShadows;\n\t\t\tstate.spotShadowMap.length = numSpotShadows;\n\t\t\tstate.directionalShadowMatrix.length = numDirectionalShadows;\n\t\t\tstate.pointShadowMatrix.length = numPointShadows;\n\t\t\tstate.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;\n\t\t\tstate.spotLightMap.length = numSpotMaps;\n\t\t\tstate.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;\n\n\t\t\thash.directionalLength = directionalLength;\n\t\t\thash.pointLength = pointLength;\n\t\t\thash.spotLength = spotLength;\n\t\t\thash.rectAreaLength = rectAreaLength;\n\t\t\thash.hemiLength = hemiLength;\n\n\t\t\thash.numDirectionalShadows = numDirectionalShadows;\n\t\t\thash.numPointShadows = numPointShadows;\n\t\t\thash.numSpotShadows = numSpotShadows;\n\t\t\thash.numSpotMaps = numSpotMaps;\n\n\t\t\tstate.version = nextVersion ++;\n\n\t\t}\n\n\t}\n\n\tfunction setupView( lights, camera ) {\n\n\t\tlet directionalLength = 0;\n\t\tlet pointLength = 0;\n\t\tlet spotLength = 0;\n\t\tlet rectAreaLength = 0;\n\t\tlet hemiLength = 0;\n\n\t\tconst viewMatrix = camera.matrixWorldInverse;\n\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\n\t\t\tif ( light.isDirectionalLight ) {\n\n\t\t\t\tconst uniforms = state.directional[ directionalLength ];\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tdirectionalLength ++;\n\n\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\tconst uniforms = state.spot[ spotLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tvector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\tuniforms.direction.sub( vector3 );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\tspotLength ++;\n\n\t\t\t} else if ( light.isRectAreaLight ) {\n\n\t\t\t\tconst uniforms = state.rectArea[ rectAreaLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\t// extract local rotation of light to derive width/height half vectors\n\t\t\t\tmatrix42.identity();\n\t\t\t\tmatrix4.copy( light.matrixWorld );\n\t\t\t\tmatrix4.premultiply( viewMatrix );\n\t\t\t\tmatrix42.extractRotation( matrix4 );\n\n\t\t\t\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\n\t\t\t\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\n\n\t\t\t\tuniforms.halfWidth.applyMatrix4( matrix42 );\n\t\t\t\tuniforms.halfHeight.applyMatrix4( matrix42 );\n\n\t\t\t\trectAreaLength ++;\n\n\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\tconst uniforms = state.point[ pointLength ];\n\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\n\n\t\t\t\tpointLength ++;\n\n\t\t\t} else if ( light.isHemisphereLight ) {\n\n\t\t\t\tconst uniforms = state.hemi[ hemiLength ];\n\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\n\n\t\t\t\themiLength ++;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn {\n\t\tsetup: setup,\n\t\tsetupView: setupView,\n\t\tstate: state\n\t};\n\n}\n\nfunction WebGLRenderState( extensions, capabilities ) {\n\n\tconst lights = new WebGLLights( extensions, capabilities );\n\n\tconst lightsArray = [];\n\tconst shadowsArray = [];\n\n\tfunction init() {\n\n\t\tlightsArray.length = 0;\n\t\tshadowsArray.length = 0;\n\n\t}\n\n\tfunction pushLight( light ) {\n\n\t\tlightsArray.push( light );\n\n\t}\n\n\tfunction pushShadow( shadowLight ) {\n\n\t\tshadowsArray.push( shadowLight );\n\n\t}\n\n\tfunction setupLights( useLegacyLights ) {\n\n\t\tlights.setup( lightsArray, useLegacyLights );\n\n\t}\n\n\tfunction setupLightsView( camera ) {\n\n\t\tlights.setupView( lightsArray, camera );\n\n\t}\n\n\tconst state = {\n\t\tlightsArray: lightsArray,\n\t\tshadowsArray: shadowsArray,\n\n\t\tlights: lights\n\t};\n\n\treturn {\n\t\tinit: init,\n\t\tstate: state,\n\t\tsetupLights: setupLights,\n\t\tsetupLightsView: setupLightsView,\n\n\t\tpushLight: pushLight,\n\t\tpushShadow: pushShadow\n\t};\n\n}\n\nfunction WebGLRenderStates( extensions, capabilities ) {\n\n\tlet renderStates = new WeakMap();\n\n\tfunction get( scene, renderCallDepth = 0 ) {\n\n\t\tconst renderStateArray = renderStates.get( scene );\n\t\tlet renderState;\n\n\t\tif ( renderStateArray === undefined ) {\n\n\t\t\trenderState = new WebGLRenderState( extensions, capabilities );\n\t\t\trenderStates.set( scene, [ renderState ] );\n\n\t\t} else {\n\n\t\t\tif ( renderCallDepth >= renderStateArray.length ) {\n\n\t\t\t\trenderState = new WebGLRenderState( extensions, capabilities );\n\t\t\t\trenderStateArray.push( renderState );\n\n\t\t\t} else {\n\n\t\t\t\trenderState = renderStateArray[ renderCallDepth ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn renderState;\n\n\t}\n\n\tfunction dispose() {\n\n\t\trenderStates = new WeakMap();\n\n\t}\n\n\treturn {\n\t\tget: get,\n\t\tdispose: dispose\n\t};\n\n}\n\nclass MeshDepthMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshDepthMaterial = true;\n\n\t\tthis.type = 'MeshDepthMaterial';\n\n\t\tthis.depthPacking = BasicDepthPacking;\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.depthPacking = source.depthPacking;\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshDistanceMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshDistanceMaterial = true;\n\n\t\tthis.type = 'MeshDistanceMaterial';\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst vertex = \"void main() {\\n\\tgl_Position = vec4( position, 1.0 );\\n}\";\n\nconst fragment = \"uniform sampler2D shadow_pass;\\nuniform vec2 resolution;\\nuniform float radius;\\n#include <packing>\\nvoid main() {\\n\\tconst float samples = float( VSM_SAMPLES );\\n\\tfloat mean = 0.0;\\n\\tfloat squared_mean = 0.0;\\n\\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\\n\\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\\n\\tfor ( float i = 0.0; i < samples; i ++ ) {\\n\\t\\tfloat uvOffset = uvStart + i * uvStride;\\n\\t\\t#ifdef HORIZONTAL_PASS\\n\\t\\t\\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\\n\\t\\t\\tmean += distribution.x;\\n\\t\\t\\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\\n\\t\\t#else\\n\\t\\t\\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\\n\\t\\t\\tmean += depth;\\n\\t\\t\\tsquared_mean += depth * depth;\\n\\t\\t#endif\\n\\t}\\n\\tmean = mean / samples;\\n\\tsquared_mean = squared_mean / samples;\\n\\tfloat std_dev = sqrt( squared_mean - mean * mean );\\n\\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\\n}\";\n\nfunction WebGLShadowMap( _renderer, _objects, _capabilities ) {\n\n\tlet _frustum = new Frustum();\n\n\tconst _shadowMapSize = new Vector2(),\n\t\t_viewportSize = new Vector2(),\n\n\t\t_viewport = new Vector4(),\n\n\t\t_depthMaterial = new MeshDepthMaterial( { depthPacking: RGBADepthPacking } ),\n\t\t_distanceMaterial = new MeshDistanceMaterial(),\n\n\t\t_materialCache = {},\n\n\t\t_maxTextureSize = _capabilities.maxTextureSize;\n\n\tconst shadowSide = { [ FrontSide ]: BackSide, [ BackSide ]: FrontSide, [ DoubleSide ]: DoubleSide };\n\n\tconst shadowMaterialVertical = new ShaderMaterial( {\n\t\tdefines: {\n\t\t\tVSM_SAMPLES: 8\n\t\t},\n\t\tuniforms: {\n\t\t\tshadow_pass: { value: null },\n\t\t\tresolution: { value: new Vector2() },\n\t\t\tradius: { value: 4.0 }\n\t\t},\n\n\t\tvertexShader: vertex,\n\t\tfragmentShader: fragment\n\n\t} );\n\n\tconst shadowMaterialHorizontal = shadowMaterialVertical.clone();\n\tshadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\n\n\tconst fullScreenTri = new BufferGeometry();\n\tfullScreenTri.setAttribute(\n\t\t'position',\n\t\tnew BufferAttribute(\n\t\t\tnew Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),\n\t\t\t3\n\t\t)\n\t);\n\n\tconst fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );\n\n\tconst scope = this;\n\n\tthis.enabled = false;\n\n\tthis.autoUpdate = true;\n\tthis.needsUpdate = false;\n\n\tthis.type = PCFShadowMap;\n\tlet _previousType = this.type;\n\n\tthis.render = function ( lights, scene, camera ) {\n\n\t\tif ( scope.enabled === false ) return;\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\n\n\t\tif ( lights.length === 0 ) return;\n\n\t\tconst currentRenderTarget = _renderer.getRenderTarget();\n\t\tconst activeCubeFace = _renderer.getActiveCubeFace();\n\t\tconst activeMipmapLevel = _renderer.getActiveMipmapLevel();\n\n\t\tconst _state = _renderer.state;\n\n\t\t// Set GL state for depth map.\n\t\t_state.setBlending( NoBlending );\n\t\t_state.buffers.color.setClear( 1, 1, 1, 1 );\n\t\t_state.buffers.depth.setTest( true );\n\t\t_state.setScissorTest( false );\n\n\t\t// check for shadow map type changes\n\n\t\tconst toVSM = ( _previousType !== VSMShadowMap && this.type === VSMShadowMap );\n\t\tconst fromVSM = ( _previousType === VSMShadowMap && this.type !== VSMShadowMap );\n\n\t\t// render depth map\n\n\t\tfor ( let i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\tconst light = lights[ i ];\n\t\t\tconst shadow = light.shadow;\n\n\t\t\tif ( shadow === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;\n\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\n\n\t\t\tconst shadowFrameExtents = shadow.getFrameExtents();\n\n\t\t\t_shadowMapSize.multiply( shadowFrameExtents );\n\n\t\t\t_viewportSize.copy( shadow.mapSize );\n\n\t\t\tif ( _shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize ) {\n\n\t\t\t\tif ( _shadowMapSize.x > _maxTextureSize ) {\n\n\t\t\t\t\t_viewportSize.x = Math.floor( _maxTextureSize / shadowFrameExtents.x );\n\t\t\t\t\t_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n\t\t\t\t\tshadow.mapSize.x = _viewportSize.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( _shadowMapSize.y > _maxTextureSize ) {\n\n\t\t\t\t\t_viewportSize.y = Math.floor( _maxTextureSize / shadowFrameExtents.y );\n\t\t\t\t\t_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n\t\t\t\t\tshadow.mapSize.y = _viewportSize.y;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( shadow.map === null || toVSM === true || fromVSM === true ) {\n\n\t\t\t\tconst pars = ( this.type !== VSMShadowMap ) ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};\n\n\t\t\t\tif ( shadow.map !== null ) {\n\n\t\t\t\t\tshadow.map.dispose();\n\n\t\t\t\t}\n\n\t\t\t\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\n\t\t\t\tshadow.map.texture.name = light.name + '.shadowMap';\n\n\t\t\t\tshadow.camera.updateProjectionMatrix();\n\n\t\t\t}\n\n\t\t\t_renderer.setRenderTarget( shadow.map );\n\t\t\t_renderer.clear();\n\n\t\t\tconst viewportCount = shadow.getViewportCount();\n\n\t\t\tfor ( let vp = 0; vp < viewportCount; vp ++ ) {\n\n\t\t\t\tconst viewport = shadow.getViewport( vp );\n\n\t\t\t\t_viewport.set(\n\t\t\t\t\t_viewportSize.x * viewport.x,\n\t\t\t\t\t_viewportSize.y * viewport.y,\n\t\t\t\t\t_viewportSize.x * viewport.z,\n\t\t\t\t\t_viewportSize.y * viewport.w\n\t\t\t\t);\n\n\t\t\t\t_state.viewport( _viewport );\n\n\t\t\t\tshadow.updateMatrices( light, vp );\n\n\t\t\t\t_frustum = shadow.getFrustum();\n\n\t\t\t\trenderObject( scene, camera, shadow.camera, light, this.type );\n\n\t\t\t}\n\n\t\t\t// do blur pass for VSM\n\n\t\t\tif ( shadow.isPointLightShadow !== true && this.type === VSMShadowMap ) {\n\n\t\t\t\tVSMPass( shadow, camera );\n\n\t\t\t}\n\n\t\t\tshadow.needsUpdate = false;\n\n\t\t}\n\n\t\t_previousType = this.type;\n\n\t\tscope.needsUpdate = false;\n\n\t\t_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );\n\n\t};\n\n\tfunction VSMPass( shadow, camera ) {\n\n\t\tconst geometry = _objects.update( fullScreenMesh );\n\n\t\tif ( shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples ) {\n\n\t\t\tshadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;\n\t\t\tshadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;\n\n\t\t\tshadowMaterialVertical.needsUpdate = true;\n\t\t\tshadowMaterialHorizontal.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( shadow.mapPass === null ) {\n\n\t\t\tshadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y );\n\n\t\t}\n\n\t\t// vertical pass\n\n\t\tshadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n\t\tshadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n\t\tshadowMaterialVertical.uniforms.radius.value = shadow.radius;\n\t\t_renderer.setRenderTarget( shadow.mapPass );\n\t\t_renderer.clear();\n\t\t_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );\n\n\t\t// horizontal pass\n\n\t\tshadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;\n\t\tshadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;\n\t\tshadowMaterialHorizontal.uniforms.radius.value = shadow.radius;\n\t\t_renderer.setRenderTarget( shadow.map );\n\t\t_renderer.clear();\n\t\t_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );\n\n\t}\n\n\tfunction getDepthMaterial( object, material, light, type ) {\n\n\t\tlet result = null;\n\n\t\tconst customMaterial = ( light.isPointLight === true ) ? object.customDistanceMaterial : object.customDepthMaterial;\n\n\t\tif ( customMaterial !== undefined ) {\n\n\t\t\tresult = customMaterial;\n\n\t\t} else {\n\n\t\t\tresult = ( light.isPointLight === true ) ? _distanceMaterial : _depthMaterial;\n\n\t\t\tif ( ( _renderer.localClippingEnabled && material.clipShadows === true && Array.isArray( material.clippingPlanes ) && material.clippingPlanes.length !== 0 ) ||\n\t\t\t\t( material.displacementMap && material.displacementScale !== 0 ) ||\n\t\t\t\t( material.alphaMap && material.alphaTest > 0 ) ||\n\t\t\t\t( material.map && material.alphaTest > 0 ) ) {\n\n\t\t\t\t// in this case we need a unique material instance reflecting the\n\t\t\t\t// appropriate state\n\n\t\t\t\tconst keyA = result.uuid, keyB = material.uuid;\n\n\t\t\t\tlet materialsForVariant = _materialCache[ keyA ];\n\n\t\t\t\tif ( materialsForVariant === undefined ) {\n\n\t\t\t\t\tmaterialsForVariant = {};\n\t\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\n\n\t\t\t\t}\n\n\t\t\t\tlet cachedMaterial = materialsForVariant[ keyB ];\n\n\t\t\t\tif ( cachedMaterial === undefined ) {\n\n\t\t\t\t\tcachedMaterial = result.clone();\n\t\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\n\n\t\t\t\t}\n\n\t\t\t\tresult = cachedMaterial;\n\n\t\t\t}\n\n\t\t}\n\n\t\tresult.visible = material.visible;\n\t\tresult.wireframe = material.wireframe;\n\n\t\tif ( type === VSMShadowMap ) {\n\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;\n\n\t\t} else {\n\n\t\t\tresult.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];\n\n\t\t}\n\n\t\tresult.alphaMap = material.alphaMap;\n\t\tresult.alphaTest = material.alphaTest;\n\t\tresult.map = material.map;\n\n\t\tresult.clipShadows = material.clipShadows;\n\t\tresult.clippingPlanes = material.clippingPlanes;\n\t\tresult.clipIntersection = material.clipIntersection;\n\n\t\tresult.displacementMap = material.displacementMap;\n\t\tresult.displacementScale = material.displacementScale;\n\t\tresult.displacementBias = material.displacementBias;\n\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\n\t\tresult.linewidth = material.linewidth;\n\n\t\tif ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {\n\n\t\t\tconst materialProperties = _renderer.properties.get( result );\n\t\t\tmaterialProperties.light = light;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction renderObject( object, camera, shadowCamera, light, type ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tconst visible = object.layers.test( camera.layers );\n\n\t\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\n\n\t\t\tif ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\n\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\tconst geometry = _objects.update( object );\n\t\t\t\tconst material = object.material;\n\n\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\tfor ( let k = 0, kl = groups.length; k < kl; k ++ ) {\n\n\t\t\t\t\t\tconst group = groups[ k ];\n\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, groupMaterial, light, type );\n\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\tconst depthMaterial = getDepthMaterial( object, material, light, type );\n\n\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\trenderObject( children[ i ], camera, shadowCamera, light, type );\n\n\t\t}\n\n\t}\n\n}\n\nfunction WebGLState( gl, extensions, capabilities ) {\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\n\tfunction ColorBuffer() {\n\n\t\tlet locked = false;\n\n\t\tconst color = new Vector4();\n\t\tlet currentColorMask = null;\n\t\tconst currentColorClear = new Vector4( 0, 0, 0, 0 );\n\n\t\treturn {\n\n\t\t\tsetMask: function ( colorMask ) {\n\n\t\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\n\n\t\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\n\t\t\t\t\tcurrentColorMask = colorMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( r, g, b, a, premultipliedAlpha ) {\n\n\t\t\t\tif ( premultipliedAlpha === true ) {\n\n\t\t\t\t\tr *= a; g *= a; b *= a;\n\n\t\t\t\t}\n\n\t\t\t\tcolor.set( r, g, b, a );\n\n\t\t\t\tif ( currentColorClear.equals( color ) === false ) {\n\n\t\t\t\t\tgl.clearColor( r, g, b, a );\n\t\t\t\t\tcurrentColorClear.copy( color );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentColorMask = null;\n\t\t\t\tcurrentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfunction DepthBuffer() {\n\n\t\tlet locked = false;\n\n\t\tlet currentDepthMask = null;\n\t\tlet currentDepthFunc = null;\n\t\tlet currentDepthClear = null;\n\n\t\treturn {\n\n\t\t\tsetTest: function ( depthTest ) {\n\n\t\t\t\tif ( depthTest ) {\n\n\t\t\t\t\tenable( gl.DEPTH_TEST );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdisable( gl.DEPTH_TEST );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetMask: function ( depthMask ) {\n\n\t\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\n\n\t\t\t\t\tgl.depthMask( depthMask );\n\t\t\t\t\tcurrentDepthMask = depthMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetFunc: function ( depthFunc ) {\n\n\t\t\t\tif ( currentDepthFunc !== depthFunc ) {\n\n\t\t\t\t\tswitch ( depthFunc ) {\n\n\t\t\t\t\t\tcase NeverDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AlwaysDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase LessDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase LessEqualDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EqualDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase GreaterEqualDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase GreaterDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase NotEqualDepth:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentDepthFunc = depthFunc;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( depth ) {\n\n\t\t\t\tif ( currentDepthClear !== depth ) {\n\n\t\t\t\t\tgl.clearDepth( depth );\n\t\t\t\t\tcurrentDepthClear = depth;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentDepthMask = null;\n\t\t\t\tcurrentDepthFunc = null;\n\t\t\t\tcurrentDepthClear = null;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfunction StencilBuffer() {\n\n\t\tlet locked = false;\n\n\t\tlet currentStencilMask = null;\n\t\tlet currentStencilFunc = null;\n\t\tlet currentStencilRef = null;\n\t\tlet currentStencilFuncMask = null;\n\t\tlet currentStencilFail = null;\n\t\tlet currentStencilZFail = null;\n\t\tlet currentStencilZPass = null;\n\t\tlet currentStencilClear = null;\n\n\t\treturn {\n\n\t\t\tsetTest: function ( stencilTest ) {\n\n\t\t\t\tif ( ! locked ) {\n\n\t\t\t\t\tif ( stencilTest ) {\n\n\t\t\t\t\t\tenable( gl.STENCIL_TEST );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tdisable( gl.STENCIL_TEST );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetMask: function ( stencilMask ) {\n\n\t\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\n\n\t\t\t\t\tgl.stencilMask( stencilMask );\n\t\t\t\t\tcurrentStencilMask = stencilMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\n\n\t\t\t\tif ( currentStencilFunc !== stencilFunc ||\n\t\t\t\t     currentStencilRef !== stencilRef ||\n\t\t\t\t     currentStencilFuncMask !== stencilMask ) {\n\n\t\t\t\t\tgl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n\n\t\t\t\t\tcurrentStencilFunc = stencilFunc;\n\t\t\t\t\tcurrentStencilRef = stencilRef;\n\t\t\t\t\tcurrentStencilFuncMask = stencilMask;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\n\n\t\t\t\tif ( currentStencilFail !== stencilFail ||\n\t\t\t\t     currentStencilZFail !== stencilZFail ||\n\t\t\t\t     currentStencilZPass !== stencilZPass ) {\n\n\t\t\t\t\tgl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n\n\t\t\t\t\tcurrentStencilFail = stencilFail;\n\t\t\t\t\tcurrentStencilZFail = stencilZFail;\n\t\t\t\t\tcurrentStencilZPass = stencilZPass;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetLocked: function ( lock ) {\n\n\t\t\t\tlocked = lock;\n\n\t\t\t},\n\n\t\t\tsetClear: function ( stencil ) {\n\n\t\t\t\tif ( currentStencilClear !== stencil ) {\n\n\t\t\t\t\tgl.clearStencil( stencil );\n\t\t\t\t\tcurrentStencilClear = stencil;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\treset: function () {\n\n\t\t\t\tlocked = false;\n\n\t\t\t\tcurrentStencilMask = null;\n\t\t\t\tcurrentStencilFunc = null;\n\t\t\t\tcurrentStencilRef = null;\n\t\t\t\tcurrentStencilFuncMask = null;\n\t\t\t\tcurrentStencilFail = null;\n\t\t\t\tcurrentStencilZFail = null;\n\t\t\t\tcurrentStencilZPass = null;\n\t\t\t\tcurrentStencilClear = null;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t//\n\n\tconst colorBuffer = new ColorBuffer();\n\tconst depthBuffer = new DepthBuffer();\n\tconst stencilBuffer = new StencilBuffer();\n\n\tconst uboBindings = new WeakMap();\n\tconst uboProgramMap = new WeakMap();\n\n\tlet enabledCapabilities = {};\n\n\tlet currentBoundFramebuffers = {};\n\tlet currentDrawbuffers = new WeakMap();\n\tlet defaultDrawbuffers = [];\n\n\tlet currentProgram = null;\n\n\tlet currentBlendingEnabled = false;\n\tlet currentBlending = null;\n\tlet currentBlendEquation = null;\n\tlet currentBlendSrc = null;\n\tlet currentBlendDst = null;\n\tlet currentBlendEquationAlpha = null;\n\tlet currentBlendSrcAlpha = null;\n\tlet currentBlendDstAlpha = null;\n\tlet currentPremultipledAlpha = false;\n\n\tlet currentFlipSided = null;\n\tlet currentCullFace = null;\n\n\tlet currentLineWidth = null;\n\n\tlet currentPolygonOffsetFactor = null;\n\tlet currentPolygonOffsetUnits = null;\n\n\tconst maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );\n\n\tlet lineWidthAvailable = false;\n\tlet version = 0;\n\tconst glVersion = gl.getParameter( gl.VERSION );\n\n\tif ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {\n\n\t\tversion = parseFloat( /^WebGL (\\d)/.exec( glVersion )[ 1 ] );\n\t\tlineWidthAvailable = ( version >= 1.0 );\n\n\t} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {\n\n\t\tversion = parseFloat( /^OpenGL ES (\\d)/.exec( glVersion )[ 1 ] );\n\t\tlineWidthAvailable = ( version >= 2.0 );\n\n\t}\n\n\tlet currentTextureSlot = null;\n\tlet currentBoundTextures = {};\n\n\tconst scissorParam = gl.getParameter( gl.SCISSOR_BOX );\n\tconst viewportParam = gl.getParameter( gl.VIEWPORT );\n\n\tconst currentScissor = new Vector4().fromArray( scissorParam );\n\tconst currentViewport = new Vector4().fromArray( viewportParam );\n\n\tfunction createTexture( type, target, count, dimensions ) {\n\n\t\tconst data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\n\t\tconst texture = gl.createTexture();\n\n\t\tgl.bindTexture( type, texture );\n\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\n\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tif ( isWebGL2 && ( type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY ) ) {\n\n\t\t\t\tgl.texImage3D( target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t\t} else {\n\n\t\t\t\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n\tconst emptyTextures = {};\n\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\n\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\n\n\tif ( isWebGL2 ) {\n\n\t\temptyTextures[ gl.TEXTURE_2D_ARRAY ] = createTexture( gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1 );\n\t\temptyTextures[ gl.TEXTURE_3D ] = createTexture( gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1 );\n\n\t}\n\n\t// init\n\n\tcolorBuffer.setClear( 0, 0, 0, 1 );\n\tdepthBuffer.setClear( 1 );\n\tstencilBuffer.setClear( 0 );\n\n\tenable( gl.DEPTH_TEST );\n\tdepthBuffer.setFunc( LessEqualDepth );\n\n\tsetFlipSided( false );\n\tsetCullFace( CullFaceBack );\n\tenable( gl.CULL_FACE );\n\n\tsetBlending( NoBlending );\n\n\t//\n\n\tfunction enable( id ) {\n\n\t\tif ( enabledCapabilities[ id ] !== true ) {\n\n\t\t\tgl.enable( id );\n\t\t\tenabledCapabilities[ id ] = true;\n\n\t\t}\n\n\t}\n\n\tfunction disable( id ) {\n\n\t\tif ( enabledCapabilities[ id ] !== false ) {\n\n\t\t\tgl.disable( id );\n\t\t\tenabledCapabilities[ id ] = false;\n\n\t\t}\n\n\t}\n\n\tfunction bindFramebuffer( target, framebuffer ) {\n\n\t\tif ( currentBoundFramebuffers[ target ] !== framebuffer ) {\n\n\t\t\tgl.bindFramebuffer( target, framebuffer );\n\n\t\t\tcurrentBoundFramebuffers[ target ] = framebuffer;\n\n\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\t// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER\n\n\t\t\t\tif ( target === gl.DRAW_FRAMEBUFFER ) {\n\n\t\t\t\t\tcurrentBoundFramebuffers[ gl.FRAMEBUFFER ] = framebuffer;\n\n\t\t\t\t}\n\n\t\t\t\tif ( target === gl.FRAMEBUFFER ) {\n\n\t\t\t\t\tcurrentBoundFramebuffers[ gl.DRAW_FRAMEBUFFER ] = framebuffer;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tfunction drawBuffers( renderTarget, framebuffer ) {\n\n\t\tlet drawBuffers = defaultDrawbuffers;\n\n\t\tlet needsUpdate = false;\n\n\t\tif ( renderTarget ) {\n\n\t\t\tdrawBuffers = currentDrawbuffers.get( framebuffer );\n\n\t\t\tif ( drawBuffers === undefined ) {\n\n\t\t\t\tdrawBuffers = [];\n\t\t\t\tcurrentDrawbuffers.set( framebuffer, drawBuffers );\n\n\t\t\t}\n\n\t\t\tif ( renderTarget.isWebGLMultipleRenderTargets ) {\n\n\t\t\t\tconst textures = renderTarget.texture;\n\n\t\t\t\tif ( drawBuffers.length !== textures.length || drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {\n\n\t\t\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tdrawBuffers[ i ] = gl.COLOR_ATTACHMENT0 + i;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdrawBuffers.length = textures.length;\n\n\t\t\t\t\tneedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( drawBuffers[ 0 ] !== gl.COLOR_ATTACHMENT0 ) {\n\n\t\t\t\t\tdrawBuffers[ 0 ] = gl.COLOR_ATTACHMENT0;\n\n\t\t\t\t\tneedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( drawBuffers[ 0 ] !== gl.BACK ) {\n\n\t\t\t\tdrawBuffers[ 0 ] = gl.BACK;\n\n\t\t\t\tneedsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\t\tgl.drawBuffers( drawBuffers );\n\n\t\t\t} else {\n\n\t\t\t\textensions.get( 'WEBGL_draw_buffers' ).drawBuffersWEBGL( drawBuffers );\n\n\t\t\t}\n\n\t\t}\n\n\n\t}\n\n\tfunction useProgram( program ) {\n\n\t\tif ( currentProgram !== program ) {\n\n\t\t\tgl.useProgram( program );\n\n\t\t\tcurrentProgram = program;\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tconst equationToGL = {\n\t\t[ AddEquation ]: gl.FUNC_ADD,\n\t\t[ SubtractEquation ]: gl.FUNC_SUBTRACT,\n\t\t[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT\n\t};\n\n\tif ( isWebGL2 ) {\n\n\t\tequationToGL[ MinEquation ] = gl.MIN;\n\t\tequationToGL[ MaxEquation ] = gl.MAX;\n\n\t} else {\n\n\t\tconst extension = extensions.get( 'EXT_blend_minmax' );\n\n\t\tif ( extension !== null ) {\n\n\t\t\tequationToGL[ MinEquation ] = extension.MIN_EXT;\n\t\t\tequationToGL[ MaxEquation ] = extension.MAX_EXT;\n\n\t\t}\n\n\t}\n\n\tconst factorToGL = {\n\t\t[ ZeroFactor ]: gl.ZERO,\n\t\t[ OneFactor ]: gl.ONE,\n\t\t[ SrcColorFactor ]: gl.SRC_COLOR,\n\t\t[ SrcAlphaFactor ]: gl.SRC_ALPHA,\n\t\t[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,\n\t\t[ DstColorFactor ]: gl.DST_COLOR,\n\t\t[ DstAlphaFactor ]: gl.DST_ALPHA,\n\t\t[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,\n\t\t[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,\n\t\t[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,\n\t\t[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA\n\t};\n\n\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\n\n\t\tif ( blending === NoBlending ) {\n\n\t\t\tif ( currentBlendingEnabled === true ) {\n\n\t\t\t\tdisable( gl.BLEND );\n\t\t\t\tcurrentBlendingEnabled = false;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( currentBlendingEnabled === false ) {\n\n\t\t\tenable( gl.BLEND );\n\t\t\tcurrentBlendingEnabled = true;\n\n\t\t}\n\n\t\tif ( blending !== CustomBlending ) {\n\n\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\n\n\t\t\t\tif ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {\n\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\n\n\t\t\t\t\tcurrentBlendEquation = AddEquation;\n\t\t\t\t\tcurrentBlendEquationAlpha = AddEquation;\n\n\t\t\t\t}\n\n\t\t\t\tif ( premultipliedAlpha ) {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.ONE, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tswitch ( blending ) {\n\n\t\t\t\t\t\tcase NormalBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase AdditiveBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase SubtractiveBlending:\n\t\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase MultiplyBlending:\n\t\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error( 'THREE.WebGLState: Invalid blending: ', blending );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tcurrentBlendSrc = null;\n\t\t\t\tcurrentBlendDst = null;\n\t\t\t\tcurrentBlendSrcAlpha = null;\n\t\t\t\tcurrentBlendDstAlpha = null;\n\n\t\t\t\tcurrentBlending = blending;\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\n\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// custom blending\n\n\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\n\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\n\t\tblendDstAlpha = blendDstAlpha || blendDst;\n\n\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\n\n\t\t\tgl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );\n\n\t\t\tcurrentBlendEquation = blendEquation;\n\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\n\n\t\t}\n\n\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\n\n\t\t\tgl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );\n\n\t\t\tcurrentBlendSrc = blendSrc;\n\t\t\tcurrentBlendDst = blendDst;\n\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\n\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\n\n\t\t}\n\n\t\tcurrentBlending = blending;\n\t\tcurrentPremultipledAlpha = false;\n\n\t}\n\n\tfunction setMaterial( material, frontFaceCW ) {\n\n\t\tmaterial.side === DoubleSide\n\t\t\t? disable( gl.CULL_FACE )\n\t\t\t: enable( gl.CULL_FACE );\n\n\t\tlet flipSided = ( material.side === BackSide );\n\t\tif ( frontFaceCW ) flipSided = ! flipSided;\n\n\t\tsetFlipSided( flipSided );\n\n\t\t( material.blending === NormalBlending && material.transparent === false )\n\t\t\t? setBlending( NoBlending )\n\t\t\t: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\n\n\t\tdepthBuffer.setFunc( material.depthFunc );\n\t\tdepthBuffer.setTest( material.depthTest );\n\t\tdepthBuffer.setMask( material.depthWrite );\n\t\tcolorBuffer.setMask( material.colorWrite );\n\n\t\tconst stencilWrite = material.stencilWrite;\n\t\tstencilBuffer.setTest( stencilWrite );\n\t\tif ( stencilWrite ) {\n\n\t\t\tstencilBuffer.setMask( material.stencilWriteMask );\n\t\t\tstencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );\n\t\t\tstencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );\n\n\t\t}\n\n\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\tmaterial.alphaToCoverage === true\n\t\t\t? enable( gl.SAMPLE_ALPHA_TO_COVERAGE )\n\t\t\t: disable( gl.SAMPLE_ALPHA_TO_COVERAGE );\n\n\t}\n\n\t//\n\n\tfunction setFlipSided( flipSided ) {\n\n\t\tif ( currentFlipSided !== flipSided ) {\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\tgl.frontFace( gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\tgl.frontFace( gl.CCW );\n\n\t\t\t}\n\n\t\t\tcurrentFlipSided = flipSided;\n\n\t\t}\n\n\t}\n\n\tfunction setCullFace( cullFace ) {\n\n\t\tif ( cullFace !== CullFaceNone ) {\n\n\t\t\tenable( gl.CULL_FACE );\n\n\t\t\tif ( cullFace !== currentCullFace ) {\n\n\t\t\t\tif ( cullFace === CullFaceBack ) {\n\n\t\t\t\t\tgl.cullFace( gl.BACK );\n\n\t\t\t\t} else if ( cullFace === CullFaceFront ) {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdisable( gl.CULL_FACE );\n\n\t\t}\n\n\t\tcurrentCullFace = cullFace;\n\n\t}\n\n\tfunction setLineWidth( width ) {\n\n\t\tif ( width !== currentLineWidth ) {\n\n\t\t\tif ( lineWidthAvailable ) gl.lineWidth( width );\n\n\t\t\tcurrentLineWidth = width;\n\n\t\t}\n\n\t}\n\n\tfunction setPolygonOffset( polygonOffset, factor, units ) {\n\n\t\tif ( polygonOffset ) {\n\n\t\t\tenable( gl.POLYGON_OFFSET_FILL );\n\n\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\n\n\t\t\t\tgl.polygonOffset( factor, units );\n\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\n\t\t\t\tcurrentPolygonOffsetUnits = units;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdisable( gl.POLYGON_OFFSET_FILL );\n\n\t\t}\n\n\t}\n\n\tfunction setScissorTest( scissorTest ) {\n\n\t\tif ( scissorTest ) {\n\n\t\t\tenable( gl.SCISSOR_TEST );\n\n\t\t} else {\n\n\t\t\tdisable( gl.SCISSOR_TEST );\n\n\t\t}\n\n\t}\n\n\t// texture\n\n\tfunction activeTexture( webglSlot ) {\n\n\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\tgl.activeTexture( webglSlot );\n\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t}\n\n\t}\n\n\tfunction bindTexture( webglType, webglTexture, webglSlot ) {\n\n\t\tif ( webglSlot === undefined ) {\n\n\t\t\tif ( currentTextureSlot === null ) {\n\n\t\t\t\twebglSlot = gl.TEXTURE0 + maxTextures - 1;\n\n\t\t\t} else {\n\n\t\t\t\twebglSlot = currentTextureSlot;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet boundTexture = currentBoundTextures[ webglSlot ];\n\n\t\tif ( boundTexture === undefined ) {\n\n\t\t\tboundTexture = { type: undefined, texture: undefined };\n\t\t\tcurrentBoundTextures[ webglSlot ] = boundTexture;\n\n\t\t}\n\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\n\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\n\n\t\t\t\tgl.activeTexture( webglSlot );\n\t\t\t\tcurrentTextureSlot = webglSlot;\n\n\t\t\t}\n\n\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\n\n\t\t\tboundTexture.type = webglType;\n\t\t\tboundTexture.texture = webglTexture;\n\n\t\t}\n\n\t}\n\n\tfunction unbindTexture() {\n\n\t\tconst boundTexture = currentBoundTextures[ currentTextureSlot ];\n\n\t\tif ( boundTexture !== undefined && boundTexture.type !== undefined ) {\n\n\t\t\tgl.bindTexture( boundTexture.type, null );\n\n\t\t\tboundTexture.type = undefined;\n\t\t\tboundTexture.texture = undefined;\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texSubImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.texSubImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texSubImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.texSubImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexSubImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexSubImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction compressedTexSubImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.compressedTexSubImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texStorage2D() {\n\n\t\ttry {\n\n\t\t\tgl.texStorage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texStorage3D() {\n\n\t\ttry {\n\n\t\t\tgl.texStorage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texImage2D() {\n\n\t\ttry {\n\n\t\t\tgl.texImage2D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\tfunction texImage3D() {\n\n\t\ttry {\n\n\t\t\tgl.texImage3D.apply( gl, arguments );\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLState:', error );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction scissor( scissor ) {\n\n\t\tif ( currentScissor.equals( scissor ) === false ) {\n\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\n\t\t\tcurrentScissor.copy( scissor );\n\n\t\t}\n\n\t}\n\n\tfunction viewport( viewport ) {\n\n\t\tif ( currentViewport.equals( viewport ) === false ) {\n\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\n\t\t\tcurrentViewport.copy( viewport );\n\n\t\t}\n\n\t}\n\n\tfunction updateUBOMapping( uniformsGroup, program ) {\n\n\t\tlet mapping = uboProgramMap.get( program );\n\n\t\tif ( mapping === undefined ) {\n\n\t\t\tmapping = new WeakMap();\n\n\t\t\tuboProgramMap.set( program, mapping );\n\n\t\t}\n\n\t\tlet blockIndex = mapping.get( uniformsGroup );\n\n\t\tif ( blockIndex === undefined ) {\n\n\t\t\tblockIndex = gl.getUniformBlockIndex( program, uniformsGroup.name );\n\n\t\t\tmapping.set( uniformsGroup, blockIndex );\n\n\t\t}\n\n\t}\n\n\tfunction uniformBlockBinding( uniformsGroup, program ) {\n\n\t\tconst mapping = uboProgramMap.get( program );\n\t\tconst blockIndex = mapping.get( uniformsGroup );\n\n\t\tif ( uboBindings.get( program ) !== blockIndex ) {\n\n\t\t\t// bind shader specific block index to global block point\n\t\t\tgl.uniformBlockBinding( program, blockIndex, uniformsGroup.__bindingPointIndex );\n\n\t\t\tuboBindings.set( program, blockIndex );\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction reset() {\n\n\t\t// reset state\n\n\t\tgl.disable( gl.BLEND );\n\t\tgl.disable( gl.CULL_FACE );\n\t\tgl.disable( gl.DEPTH_TEST );\n\t\tgl.disable( gl.POLYGON_OFFSET_FILL );\n\t\tgl.disable( gl.SCISSOR_TEST );\n\t\tgl.disable( gl.STENCIL_TEST );\n\t\tgl.disable( gl.SAMPLE_ALPHA_TO_COVERAGE );\n\n\t\tgl.blendEquation( gl.FUNC_ADD );\n\t\tgl.blendFunc( gl.ONE, gl.ZERO );\n\t\tgl.blendFuncSeparate( gl.ONE, gl.ZERO, gl.ONE, gl.ZERO );\n\n\t\tgl.colorMask( true, true, true, true );\n\t\tgl.clearColor( 0, 0, 0, 0 );\n\n\t\tgl.depthMask( true );\n\t\tgl.depthFunc( gl.LESS );\n\t\tgl.clearDepth( 1 );\n\n\t\tgl.stencilMask( 0xffffffff );\n\t\tgl.stencilFunc( gl.ALWAYS, 0, 0xffffffff );\n\t\tgl.stencilOp( gl.KEEP, gl.KEEP, gl.KEEP );\n\t\tgl.clearStencil( 0 );\n\n\t\tgl.cullFace( gl.BACK );\n\t\tgl.frontFace( gl.CCW );\n\n\t\tgl.polygonOffset( 0, 0 );\n\n\t\tgl.activeTexture( gl.TEXTURE0 );\n\n\t\tgl.bindFramebuffer( gl.FRAMEBUFFER, null );\n\n\t\tif ( isWebGL2 === true ) {\n\n\t\t\tgl.bindFramebuffer( gl.DRAW_FRAMEBUFFER, null );\n\t\t\tgl.bindFramebuffer( gl.READ_FRAMEBUFFER, null );\n\n\t\t}\n\n\t\tgl.useProgram( null );\n\n\t\tgl.lineWidth( 1 );\n\n\t\tgl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );\n\t\tgl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );\n\n\t\t// reset internals\n\n\t\tenabledCapabilities = {};\n\n\t\tcurrentTextureSlot = null;\n\t\tcurrentBoundTextures = {};\n\n\t\tcurrentBoundFramebuffers = {};\n\t\tcurrentDrawbuffers = new WeakMap();\n\t\tdefaultDrawbuffers = [];\n\n\t\tcurrentProgram = null;\n\n\t\tcurrentBlendingEnabled = false;\n\t\tcurrentBlending = null;\n\t\tcurrentBlendEquation = null;\n\t\tcurrentBlendSrc = null;\n\t\tcurrentBlendDst = null;\n\t\tcurrentBlendEquationAlpha = null;\n\t\tcurrentBlendSrcAlpha = null;\n\t\tcurrentBlendDstAlpha = null;\n\t\tcurrentPremultipledAlpha = false;\n\n\t\tcurrentFlipSided = null;\n\t\tcurrentCullFace = null;\n\n\t\tcurrentLineWidth = null;\n\n\t\tcurrentPolygonOffsetFactor = null;\n\t\tcurrentPolygonOffsetUnits = null;\n\n\t\tcurrentScissor.set( 0, 0, gl.canvas.width, gl.canvas.height );\n\t\tcurrentViewport.set( 0, 0, gl.canvas.width, gl.canvas.height );\n\n\t\tcolorBuffer.reset();\n\t\tdepthBuffer.reset();\n\t\tstencilBuffer.reset();\n\n\t}\n\n\treturn {\n\n\t\tbuffers: {\n\t\t\tcolor: colorBuffer,\n\t\t\tdepth: depthBuffer,\n\t\t\tstencil: stencilBuffer\n\t\t},\n\n\t\tenable: enable,\n\t\tdisable: disable,\n\n\t\tbindFramebuffer: bindFramebuffer,\n\t\tdrawBuffers: drawBuffers,\n\n\t\tuseProgram: useProgram,\n\n\t\tsetBlending: setBlending,\n\t\tsetMaterial: setMaterial,\n\n\t\tsetFlipSided: setFlipSided,\n\t\tsetCullFace: setCullFace,\n\n\t\tsetLineWidth: setLineWidth,\n\t\tsetPolygonOffset: setPolygonOffset,\n\n\t\tsetScissorTest: setScissorTest,\n\n\t\tactiveTexture: activeTexture,\n\t\tbindTexture: bindTexture,\n\t\tunbindTexture: unbindTexture,\n\t\tcompressedTexImage2D: compressedTexImage2D,\n\t\tcompressedTexImage3D: compressedTexImage3D,\n\t\ttexImage2D: texImage2D,\n\t\ttexImage3D: texImage3D,\n\n\t\tupdateUBOMapping: updateUBOMapping,\n\t\tuniformBlockBinding: uniformBlockBinding,\n\n\t\ttexStorage2D: texStorage2D,\n\t\ttexStorage3D: texStorage3D,\n\t\ttexSubImage2D: texSubImage2D,\n\t\ttexSubImage3D: texSubImage3D,\n\t\tcompressedTexSubImage2D: compressedTexSubImage2D,\n\t\tcompressedTexSubImage3D: compressedTexSubImage3D,\n\n\t\tscissor: scissor,\n\t\tviewport: viewport,\n\n\t\treset: reset\n\n\t};\n\n}\n\nfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\tconst maxTextures = capabilities.maxTextures;\n\tconst maxCubemapSize = capabilities.maxCubemapSize;\n\tconst maxTextureSize = capabilities.maxTextureSize;\n\tconst maxSamples = capabilities.maxSamples;\n\tconst multisampledRTTExt = extensions.has( 'WEBGL_multisampled_render_to_texture' ) ? extensions.get( 'WEBGL_multisampled_render_to_texture' ) : null;\n\tconst supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? false : /OculusBrowser/g.test( navigator.userAgent );\n\n\tconst _videoTextures = new WeakMap();\n\tlet _canvas;\n\n\tconst _sources = new WeakMap(); // maps WebglTexture objects to instances of Source\n\n\t// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,\n\t// also OffscreenCanvas.getContext(\"webgl\"), but not OffscreenCanvas.getContext(\"2d\")!\n\t// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).\n\n\tlet useOffscreenCanvas = false;\n\n\ttry {\n\n\t\tuseOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'\n\t\t\t// eslint-disable-next-line compat/compat\n\t\t\t&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;\n\n\t} catch ( err ) {\n\n\t\t// Ignore any errors\n\n\t}\n\n\tfunction createCanvas( width, height ) {\n\n\t\t// Use OffscreenCanvas when available. Specially needed in web workers\n\n\t\treturn useOffscreenCanvas ?\n\t\t\t// eslint-disable-next-line compat/compat\n\t\t\tnew OffscreenCanvas( width, height ) : createElementNS( 'canvas' );\n\n\t}\n\n\tfunction resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {\n\n\t\tlet scale = 1;\n\n\t\t// handle case if texture exceeds max size\n\n\t\tif ( image.width > maxSize || image.height > maxSize ) {\n\n\t\t\tscale = maxSize / Math.max( image.width, image.height );\n\n\t\t}\n\n\t\t// only perform resize if necessary\n\n\t\tif ( scale < 1 || needsPowerOfTwo === true ) {\n\n\t\t\t// only perform resize for certain image types\n\n\t\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t\t\tconst floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;\n\n\t\t\t\tconst width = floor( scale * image.width );\n\t\t\t\tconst height = floor( scale * image.height );\n\n\t\t\t\tif ( _canvas === undefined ) _canvas = createCanvas( width, height );\n\n\t\t\t\t// cube textures can't reuse the same canvas\n\n\t\t\t\tconst canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;\n\n\t\t\t\tcanvas.width = width;\n\t\t\t\tcanvas.height = height;\n\n\t\t\t\tconst context = canvas.getContext( '2d' );\n\t\t\t\tcontext.drawImage( image, 0, 0, width, height );\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );\n\n\t\t\t\treturn canvas;\n\n\t\t\t} else {\n\n\t\t\t\tif ( 'data' in image ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );\n\n\t\t\t\t}\n\n\t\t\t\treturn image;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\tfunction isPowerOfTwo$1( image ) {\n\n\t\treturn isPowerOfTwo( image.width ) && isPowerOfTwo( image.height );\n\n\t}\n\n\tfunction textureNeedsPowerOfTwo( texture ) {\n\n\t\tif ( isWebGL2 ) return false;\n\n\t\treturn ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||\n\t\t\t( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );\n\n\t}\n\n\tfunction textureNeedsGenerateMipmaps( texture, supportsMips ) {\n\n\t\treturn texture.generateMipmaps && supportsMips &&\n\t\t\ttexture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n\n\t}\n\n\tfunction generateMipmap( target ) {\n\n\t\t_gl.generateMipmap( target );\n\n\t}\n\n\tfunction getInternalFormat( internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false ) {\n\n\t\tif ( isWebGL2 === false ) return glFormat;\n\n\t\tif ( internalFormatName !== null ) {\n\n\t\t\tif ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\'' + internalFormatName + '\\'' );\n\n\t\t}\n\n\t\tlet internalFormat = glFormat;\n\n\t\tif ( glFormat === _gl.RED ) {\n\n\t\t\tif ( glType === _gl.FLOAT ) internalFormat = _gl.R32F;\n\t\t\tif ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.R16F;\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8;\n\n\t\t}\n\n\t\tif ( glFormat === _gl.RG ) {\n\n\t\t\tif ( glType === _gl.FLOAT ) internalFormat = _gl.RG32F;\n\t\t\tif ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RG16F;\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RG8;\n\n\t\t}\n\n\t\tif ( glFormat === _gl.RGBA ) {\n\n\t\t\tif ( glType === _gl.FLOAT ) internalFormat = _gl.RGBA32F;\n\t\t\tif ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RGBA16F;\n\t\t\tif ( glType === _gl.UNSIGNED_BYTE ) internalFormat = ( colorSpace === SRGBColorSpace && forceLinearTransfer === false ) ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;\n\t\t\tif ( glType === _gl.UNSIGNED_SHORT_4_4_4_4 ) internalFormat = _gl.RGBA4;\n\t\t\tif ( glType === _gl.UNSIGNED_SHORT_5_5_5_1 ) internalFormat = _gl.RGB5_A1;\n\n\t\t}\n\n\t\tif ( internalFormat === _gl.R16F || internalFormat === _gl.R32F ||\n\t\t\tinternalFormat === _gl.RG16F || internalFormat === _gl.RG32F ||\n\t\t\tinternalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F ) {\n\n\t\t\textensions.get( 'EXT_color_buffer_float' );\n\n\t\t}\n\n\t\treturn internalFormat;\n\n\t}\n\n\tfunction getMipLevels( texture, image, supportsMips ) {\n\n\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) === true || ( texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) ) {\n\n\t\t\treturn Math.log2( Math.max( image.width, image.height ) ) + 1;\n\n\t\t} else if ( texture.mipmaps !== undefined && texture.mipmaps.length > 0 ) {\n\n\t\t\t// user-defined mipmaps\n\n\t\t\treturn texture.mipmaps.length;\n\n\t\t} else if ( texture.isCompressedTexture && Array.isArray( texture.image ) ) {\n\n\t\t\treturn image.mipmaps.length;\n\n\t\t} else {\n\n\t\t\t// texture without mipmaps (only base level)\n\n\t\t\treturn 1;\n\n\t\t}\n\n\t}\n\n\t// Fallback filters for non-power-of-2 textures\n\n\tfunction filterFallback( f ) {\n\n\t\tif ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {\n\n\t\t\treturn _gl.NEAREST;\n\n\t\t}\n\n\t\treturn _gl.LINEAR;\n\n\t}\n\n\t//\n\n\tfunction onTextureDispose( event ) {\n\n\t\tconst texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tdeallocateTexture( texture );\n\n\t\tif ( texture.isVideoTexture ) {\n\n\t\t\t_videoTextures.delete( texture );\n\n\t\t}\n\n\t}\n\n\tfunction onRenderTargetDispose( event ) {\n\n\t\tconst renderTarget = event.target;\n\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tdeallocateRenderTarget( renderTarget );\n\n\t}\n\n\t//\n\n\tfunction deallocateTexture( texture ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( textureProperties.__webglInit === undefined ) return;\n\n\t\t// check if it's necessary to remove the WebGLTexture object\n\n\t\tconst source = texture.source;\n\t\tconst webglTextures = _sources.get( source );\n\n\t\tif ( webglTextures ) {\n\n\t\t\tconst webglTexture = webglTextures[ textureProperties.__cacheKey ];\n\t\t\twebglTexture.usedTimes --;\n\n\t\t\t// the WebGLTexture object is not used anymore, remove it\n\n\t\t\tif ( webglTexture.usedTimes === 0 ) {\n\n\t\t\t\tdeleteTexture( texture );\n\n\t\t\t}\n\n\t\t\t// remove the weak map entry if no WebGLTexture uses the source anymore\n\n\t\t\tif ( Object.keys( webglTextures ).length === 0 ) {\n\n\t\t\t\t_sources.delete( source );\n\n\t\t\t}\n\n\t\t}\n\n\t\tproperties.remove( texture );\n\n\t}\n\n\tfunction deleteTexture( texture ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\tconst source = texture.source;\n\t\tconst webglTextures = _sources.get( source );\n\t\tdelete webglTextures[ textureProperties.__cacheKey ];\n\n\t\tinfo.memory.textures --;\n\n\t}\n\n\tfunction deallocateRenderTarget( renderTarget ) {\n\n\t\tconst texture = renderTarget.texture;\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( textureProperties.__webglTexture !== undefined ) {\n\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\n\n\t\t\tinfo.memory.textures --;\n\n\t\t}\n\n\t\tif ( renderTarget.depthTexture ) {\n\n\t\t\trenderTarget.depthTexture.dispose();\n\n\t\t}\n\n\t\tif ( renderTarget.isWebGLCubeRenderTarget ) {\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\n\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\n\t\t\tif ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );\n\n\t\t\tif ( renderTargetProperties.__webglColorRenderbuffer ) {\n\n\t\t\t\tfor ( let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i ++ ) {\n\n\t\t\t\t\tif ( renderTargetProperties.__webglColorRenderbuffer[ i ] ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );\n\n\t\t}\n\n\t\tif ( renderTarget.isWebGLMultipleRenderTargets ) {\n\n\t\t\tfor ( let i = 0, il = texture.length; i < il; i ++ ) {\n\n\t\t\t\tconst attachmentProperties = properties.get( texture[ i ] );\n\n\t\t\t\tif ( attachmentProperties.__webglTexture ) {\n\n\t\t\t\t\t_gl.deleteTexture( attachmentProperties.__webglTexture );\n\n\t\t\t\t\tinfo.memory.textures --;\n\n\t\t\t\t}\n\n\t\t\t\tproperties.remove( texture[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tproperties.remove( texture );\n\t\tproperties.remove( renderTarget );\n\n\t}\n\n\t//\n\n\tlet textureUnits = 0;\n\n\tfunction resetTextureUnits() {\n\n\t\ttextureUnits = 0;\n\n\t}\n\n\tfunction allocateTextureUnit() {\n\n\t\tconst textureUnit = textureUnits;\n\n\t\tif ( textureUnit >= maxTextures ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );\n\n\t\t}\n\n\t\ttextureUnits += 1;\n\n\t\treturn textureUnit;\n\n\t}\n\n\tfunction getTextureCacheKey( texture ) {\n\n\t\tconst array = [];\n\n\t\tarray.push( texture.wrapS );\n\t\tarray.push( texture.wrapT );\n\t\tarray.push( texture.wrapR || 0 );\n\t\tarray.push( texture.magFilter );\n\t\tarray.push( texture.minFilter );\n\t\tarray.push( texture.anisotropy );\n\t\tarray.push( texture.internalFormat );\n\t\tarray.push( texture.format );\n\t\tarray.push( texture.type );\n\t\tarray.push( texture.generateMipmaps );\n\t\tarray.push( texture.premultiplyAlpha );\n\t\tarray.push( texture.flipY );\n\t\tarray.push( texture.unpackAlignment );\n\t\tarray.push( texture.colorSpace );\n\n\t\treturn array.join();\n\n\t}\n\n\t//\n\n\tfunction setTexture2D( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.isVideoTexture ) updateVideoTexture( texture );\n\n\t\tif ( texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tconst image = texture.image;\n\n\t\t\tif ( image === null ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but no image data found.' );\n\n\t\t\t} else if ( image.complete === false ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );\n\n\t\t\t} else {\n\n\t\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t}\n\n\tfunction setTexture2DArray( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.bindTexture( _gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t}\n\n\tfunction setTexture3D( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.bindTexture( _gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t}\n\n\tfunction setTextureCube( texture, slot ) {\n\n\t\tconst textureProperties = properties.get( texture );\n\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\n\n\t\t\tuploadCubeTexture( textureProperties, texture, slot );\n\t\t\treturn;\n\n\t\t}\n\n\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t}\n\n\tconst wrappingToGL = {\n\t\t[ RepeatWrapping ]: _gl.REPEAT,\n\t\t[ ClampToEdgeWrapping ]: _gl.CLAMP_TO_EDGE,\n\t\t[ MirroredRepeatWrapping ]: _gl.MIRRORED_REPEAT\n\t};\n\n\tconst filterToGL = {\n\t\t[ NearestFilter ]: _gl.NEAREST,\n\t\t[ NearestMipmapNearestFilter ]: _gl.NEAREST_MIPMAP_NEAREST,\n\t\t[ NearestMipmapLinearFilter ]: _gl.NEAREST_MIPMAP_LINEAR,\n\n\t\t[ LinearFilter ]: _gl.LINEAR,\n\t\t[ LinearMipmapNearestFilter ]: _gl.LINEAR_MIPMAP_NEAREST,\n\t\t[ LinearMipmapLinearFilter ]: _gl.LINEAR_MIPMAP_LINEAR\n\t};\n\n\tconst compareToGL = {\n\t\t[ NeverCompare ]: _gl.NEVER,\n\t\t[ AlwaysCompare ]: _gl.ALWAYS,\n\t\t[ LessCompare ]: _gl.LESS,\n\t\t[ LessEqualCompare ]: _gl.LEQUAL,\n\t\t[ EqualCompare ]: _gl.EQUAL,\n\t\t[ GreaterEqualCompare ]: _gl.GEQUAL,\n\t\t[ GreaterCompare ]: _gl.GREATER,\n\t\t[ NotEqualCompare ]: _gl.NOTEQUAL\n\t};\n\n\tfunction setTextureParameters( textureType, texture, supportsMips ) {\n\n\t\tif ( supportsMips ) {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );\n\n\t\t\tif ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );\n\n\t\t\t}\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[ texture.minFilter ] );\n\n\t\t} else {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\n\t\t\tif ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {\n\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE );\n\n\t\t\t}\n\n\t\t\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );\n\n\t\t\t}\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\n\t\t\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( texture.compareFunction ) {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[ texture.compareFunction ] );\n\n\t\t}\n\n\t\tif ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {\n\n\t\t\tconst extension = extensions.get( 'EXT_texture_filter_anisotropic' );\n\n\t\t\tif ( texture.magFilter === NearestFilter ) return;\n\t\t\tif ( texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter ) return;\n\t\t\tif ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2\n\t\t\tif ( isWebGL2 === false && ( texture.type === HalfFloatType && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) return; // verify extension for WebGL 1 only\n\n\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\n\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\n\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction initTexture( textureProperties, texture ) {\n\n\t\tlet forceUpload = false;\n\n\t\tif ( textureProperties.__webglInit === undefined ) {\n\n\t\t\ttextureProperties.__webglInit = true;\n\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t}\n\n\t\t// create Source <-> WebGLTextures mapping if necessary\n\n\t\tconst source = texture.source;\n\t\tlet webglTextures = _sources.get( source );\n\n\t\tif ( webglTextures === undefined ) {\n\n\t\t\twebglTextures = {};\n\t\t\t_sources.set( source, webglTextures );\n\n\t\t}\n\n\t\t// check if there is already a WebGLTexture object for the given texture parameters\n\n\t\tconst textureCacheKey = getTextureCacheKey( texture );\n\n\t\tif ( textureCacheKey !== textureProperties.__cacheKey ) {\n\n\t\t\t// if not, create a new instance of WebGLTexture\n\n\t\t\tif ( webglTextures[ textureCacheKey ] === undefined ) {\n\n\t\t\t\t// create new entry\n\n\t\t\t\twebglTextures[ textureCacheKey ] = {\n\t\t\t\t\ttexture: _gl.createTexture(),\n\t\t\t\t\tusedTimes: 0\n\t\t\t\t};\n\n\t\t\t\tinfo.memory.textures ++;\n\n\t\t\t\t// when a new instance of WebGLTexture was created, a texture upload is required\n\t\t\t\t// even if the image contents are identical\n\n\t\t\t\tforceUpload = true;\n\n\t\t\t}\n\n\t\t\twebglTextures[ textureCacheKey ].usedTimes ++;\n\n\t\t\t// every time the texture cache key changes, it's necessary to check if an instance of\n\t\t\t// WebGLTexture can be deleted in order to avoid a memory leak.\n\n\t\t\tconst webglTexture = webglTextures[ textureProperties.__cacheKey ];\n\n\t\t\tif ( webglTexture !== undefined ) {\n\n\t\t\t\twebglTextures[ textureProperties.__cacheKey ].usedTimes --;\n\n\t\t\t\tif ( webglTexture.usedTimes === 0 ) {\n\n\t\t\t\t\tdeleteTexture( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// store references to cache key and WebGLTexture object\n\n\t\t\ttextureProperties.__cacheKey = textureCacheKey;\n\t\t\ttextureProperties.__webglTexture = webglTextures[ textureCacheKey ].texture;\n\n\t\t}\n\n\t\treturn forceUpload;\n\n\t}\n\n\tfunction uploadTexture( textureProperties, texture, slot ) {\n\n\t\tlet textureType = _gl.TEXTURE_2D;\n\n\t\tif ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) textureType = _gl.TEXTURE_2D_ARRAY;\n\t\tif ( texture.isData3DTexture ) textureType = _gl.TEXTURE_3D;\n\n\t\tconst forceUpload = initTexture( textureProperties, texture );\n\t\tconst source = texture.source;\n\n\t\tstate.bindTexture( textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t\tconst sourceProperties = properties.get( source );\n\n\t\tif ( source.version !== sourceProperties.__version || forceUpload === true ) {\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE );\n\n\t\t\tconst needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo$1( texture.image ) === false;\n\t\t\tlet image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );\n\t\t\timage = verifyColorSpace( texture, image );\n\n\t\t\tconst supportsMips = isPowerOfTwo$1( image ) || isWebGL2,\n\t\t\t\tglFormat = utils.convert( texture.format, texture.colorSpace );\n\n\t\t\tlet glType = utils.convert( texture.type ),\n\t\t\t\tglInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );\n\n\t\t\tsetTextureParameters( textureType, texture, supportsMips );\n\n\t\t\tlet mipmap;\n\t\t\tconst mipmaps = texture.mipmaps;\n\n\t\t\tconst useTexStorage = ( isWebGL2 && texture.isVideoTexture !== true );\n\t\t\tconst allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );\n\t\t\tconst levels = getMipLevels( texture, image, supportsMips );\n\n\t\t\tif ( texture.isDepthTexture ) {\n\n\t\t\t\t// populate depth texture with dummy data\n\n\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT;\n\n\t\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\t\tif ( texture.type === FloatType ) {\n\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT32F;\n\n\t\t\t\t\t} else if ( texture.type === UnsignedIntType ) {\n\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT24;\n\n\t\t\t\t\t} else if ( texture.type === UnsignedInt248Type ) {\n\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH24_STENCIL8;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( texture.type === FloatType ) {\n\n\t\t\t\t\t\tconsole.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// validation checks for WebGL 1\n\n\t\t\t\tif ( texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT ) {\n\n\t\t\t\t\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t\t// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\n\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\t\tif ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );\n\n\t\t\t\t\t\ttexture.type = UnsignedIntType;\n\t\t\t\t\t\tglType = utils.convert( texture.type );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT ) {\n\n\t\t\t\t\t// Depth stencil textures need the DEPTH_STENCIL internal format\n\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\t\tglInternalFormat = _gl.DEPTH_STENCIL;\n\n\t\t\t\t\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n\t\t\t\t\t// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\n\t\t\t\t\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\t\t\t\t\tif ( texture.type !== UnsignedInt248Type ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );\n\n\t\t\t\t\t\ttexture.type = UnsignedInt248Type;\n\t\t\t\t\t\tglType = utils.convert( texture.type );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isDataTexture ) {\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && supportsMips ) {\n\n\t\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isCompressedTexture ) {\n\n\t\t\t\tif ( texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height, image.depth );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\t\tif ( texture.format !== RGBAFormat ) {\n\n\t\t\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0 );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tstate.texSubImage3D( _gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage3D( _gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\t\tif ( texture.format !== RGBAFormat ) {\n\n\t\t\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isDataArrayTexture ) {\n\n\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage3D( _gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.texSubImage3D( _gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage3D( _gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage3D( _gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tstate.texSubImage3D( _gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstate.texImage3D( _gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture.isFramebufferTexture ) {\n\n\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tlet width = image.width, height = image.height;\n\n\t\t\t\t\t\tfor ( let i = 0; i < levels; i ++ ) {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null );\n\n\t\t\t\t\t\t\twidth >>= 1;\n\t\t\t\t\t\t\theight >>= 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// regular Texture (image, video, canvas)\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && supportsMips ) {\n\n\t\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[ 0 ].width, mipmaps[ 0 ].height );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\n\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\tif ( allocateMemory ) {\n\n\t\t\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\t\tgenerateMipmap( textureType );\n\n\t\t\t}\n\n\t\t\tsourceProperties.__version = source.version;\n\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t}\n\n\t\ttextureProperties.__version = texture.version;\n\n\t}\n\n\tfunction uploadCubeTexture( textureProperties, texture, slot ) {\n\n\t\tif ( texture.image.length !== 6 ) return;\n\n\t\tconst forceUpload = initTexture( textureProperties, texture );\n\t\tconst source = texture.source;\n\n\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot );\n\n\t\tconst sourceProperties = properties.get( source );\n\n\t\tif ( source.version !== sourceProperties.__version || forceUpload === true ) {\n\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE );\n\n\t\t\tconst isCompressed = ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture );\n\t\t\tconst isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );\n\n\t\t\tconst cubeImage = [];\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tif ( ! isCompressed && ! isDataTexture ) {\n\n\t\t\t\t\tcubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tcubeImage[ i ] = verifyColorSpace( texture, cubeImage[ i ] );\n\n\t\t\t}\n\n\t\t\tconst image = cubeImage[ 0 ],\n\t\t\t\tsupportsMips = isPowerOfTwo$1( image ) || isWebGL2,\n\t\t\t\tglFormat = utils.convert( texture.format, texture.colorSpace ),\n\t\t\t\tglType = utils.convert( texture.type ),\n\t\t\t\tglInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );\n\n\t\t\tconst useTexStorage = ( isWebGL2 && texture.isVideoTexture !== true );\n\t\t\tconst allocateMemory = ( sourceProperties.__version === undefined ) || ( forceUpload === true );\n\t\t\tlet levels = getMipLevels( texture, image, supportsMips );\n\n\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, supportsMips );\n\n\t\t\tlet mipmaps;\n\n\t\t\tif ( isCompressed ) {\n\n\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tmipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\t\t\tconst mipmap = mipmaps[ j ];\n\n\t\t\t\t\t\tif ( texture.format !== RGBAFormat ) {\n\n\t\t\t\t\t\t\tif ( glFormat !== null ) {\n\n\t\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tmipmaps = texture.mipmaps;\n\n\t\t\t\tif ( useTexStorage && allocateMemory ) {\n\n\t\t\t\t\t// TODO: Uniformly handle mipmap definitions\n\t\t\t\t\t// Normal textures and compressed cube textures define base level + mips with their mipmap array\n\t\t\t\t\t// Uncompressed cube textures use their mipmap array only for mips (no base level)\n\n\t\t\t\t\tif ( mipmaps.length > 0 ) levels ++;\n\n\t\t\t\t\tstate.texStorage2D( _gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, cubeImage[ 0 ].width, cubeImage[ 0 ].height );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( isDataTexture ) {\n\n\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[ i ].width, cubeImage[ i ].height, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\t\t\t\tconst mipmap = mipmaps[ j ];\n\t\t\t\t\t\t\tconst mipmapImage = mipmap.image[ i ].image;\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor ( let j = 0; j < mipmaps.length; j ++ ) {\n\n\t\t\t\t\t\t\tconst mipmap = mipmaps[ j ];\n\n\t\t\t\t\t\t\tif ( useTexStorage ) {\n\n\t\t\t\t\t\t\t\tstate.texSubImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[ i ] );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\t\t// We assume images for cube map have the same size.\n\t\t\t\tgenerateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t}\n\n\t\t\tsourceProperties.__version = source.version;\n\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\n\n\t\t}\n\n\t\ttextureProperties.__version = texture.version;\n\n\t}\n\n\t// Render targets\n\n\t// Setup storage for target texture and bind it to correct framebuffer\n\tfunction setupFrameBufferTexture( framebuffer, renderTarget, texture, attachment, textureTarget ) {\n\n\t\tconst glFormat = utils.convert( texture.format, texture.colorSpace );\n\t\tconst glType = utils.convert( texture.type );\n\t\tconst glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\tif ( ! renderTargetProperties.__hasExternalTextures ) {\n\n\t\t\tif ( textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY ) {\n\n\t\t\t\tstate.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );\n\n\t\t\t} else {\n\n\t\t\t\tstate.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\tif ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( texture ).__webglTexture, 0, getRenderTargetSamples( renderTarget ) );\n\n\t\t} else if ( textureTarget === _gl.TEXTURE_2D || ( textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z ) ) { // see #24753\n\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );\n\n\t\t}\n\n\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\tfunction setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\tlet glInternalFormat = _gl.DEPTH_COMPONENT16;\n\n\t\t\tif ( isMultisample || useMultisampledRTT( renderTarget ) ) {\n\n\t\t\t\tconst depthTexture = renderTarget.depthTexture;\n\n\t\t\t\tif ( depthTexture && depthTexture.isDepthTexture ) {\n\n\t\t\t\t\tif ( depthTexture.type === FloatType ) {\n\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT32F;\n\n\t\t\t\t\t} else if ( depthTexture.type === UnsignedIntType ) {\n\n\t\t\t\t\t\tglInternalFormat = _gl.DEPTH_COMPONENT24;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\n\t\t\t\tif ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\t\t\tmultisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\n\t\t\tif ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\t\t_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height );\n\n\t\t\t} else if ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\t\tmultisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\n\t\t\t}\n\n\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else {\n\n\t\t\tconst textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tconst texture = textures[ i ];\n\n\t\t\t\tconst glFormat = utils.convert( texture.format, texture.colorSpace );\n\t\t\t\tconst glType = utils.convert( texture.type );\n\t\t\t\tconst glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace );\n\t\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\n\t\t\t\tif ( isMultisample && useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\t\t\t_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t} else if ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\t\t\tmultisampledRTTExt.renderbufferStorageMultisampleEXT( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t}\n\n\t// Setup resources for a Depth Texture for a FBO (needs an extension)\n\tfunction setupDepthTexture( framebuffer, renderTarget ) {\n\n\t\tconst isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );\n\t\tif ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );\n\n\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\tif ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {\n\n\t\t\tthrow new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );\n\n\t\t}\n\n\t\t// upload an empty depth texture with framebuffer size\n\t\tif ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||\n\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\n\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\n\n\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\n\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\n\t\t\trenderTarget.depthTexture.needsUpdate = true;\n\n\t\t}\n\n\t\tsetTexture2D( renderTarget.depthTexture, 0 );\n\n\t\tconst webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\n\t\tconst samples = getRenderTargetSamples( renderTarget );\n\n\t\tif ( renderTarget.depthTexture.format === DepthFormat ) {\n\n\t\t\tif ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t}\n\n\t\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\n\n\t\t\tif ( useMultisampledRTT( renderTarget ) ) {\n\n\t\t\t\tmultisampledRTTExt.framebufferTexture2DMultisampleEXT( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'Unknown depthTexture format' );\n\n\t\t}\n\n\t}\n\n\t// Setup GL resources for a non-texture depth buffer\n\tfunction setupDepthRenderbuffer( renderTarget ) {\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\tconst isCube = ( renderTarget.isWebGLCubeRenderTarget === true );\n\n\t\tif ( renderTarget.depthTexture && ! renderTargetProperties.__autoAllocateDepthBuffer ) {\n\n\t\t\tif ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );\n\n\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\n\n\t\t} else {\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\n\n\t\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t}\n\n\t// rebind framebuffer with external textures\n\tfunction rebindTextures( renderTarget, colorTexture, depthTexture ) {\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\tif ( colorTexture !== undefined ) {\n\n\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\n\n\t\t}\n\n\t\tif ( depthTexture !== undefined ) {\n\n\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t}\n\n\t}\n\n\t// Set up GL resources for the render target\n\tfunction setupRenderTarget( renderTarget ) {\n\n\t\tconst texture = renderTarget.texture;\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\tconst textureProperties = properties.get( texture );\n\n\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tif ( renderTarget.isWebGLMultipleRenderTargets !== true ) {\n\n\t\t\tif ( textureProperties.__webglTexture === undefined ) {\n\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t}\n\n\t\t\ttextureProperties.__version = texture.version;\n\t\t\tinfo.memory.textures ++;\n\n\t\t}\n\n\t\tconst isCube = ( renderTarget.isWebGLCubeRenderTarget === true );\n\t\tconst isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );\n\t\tconst supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;\n\n\t\t// Setup framebuffer\n\n\t\tif ( isCube ) {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = [];\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\tif ( isMultipleRenderTargets ) {\n\n\t\t\t\tif ( capabilities.drawBuffers ) {\n\n\t\t\t\t\tconst textures = renderTarget.texture;\n\n\t\t\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst attachmentProperties = properties.get( textures[ i ] );\n\n\t\t\t\t\t\tif ( attachmentProperties.__webglTexture === undefined ) {\n\n\t\t\t\t\t\t\tattachmentProperties.__webglTexture = _gl.createTexture();\n\n\t\t\t\t\t\t\tinfo.memory.textures ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ( isWebGL2 && renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\t\tconst textures = isMultipleRenderTargets ? texture : [ texture ];\n\n\t\t\t\trenderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();\n\t\t\t\trenderTargetProperties.__webglColorRenderbuffer = [];\n\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\tconst texture = textures[ i ];\n\t\t\t\t\trenderTargetProperties.__webglColorRenderbuffer[ i ] = _gl.createRenderbuffer();\n\n\t\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t\tconst glFormat = utils.convert( texture.format, texture.colorSpace );\n\t\t\t\t\tconst glType = utils.convert( texture.type );\n\t\t\t\t\tconst glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType, texture.colorSpace, renderTarget.isXRRenderTarget === true );\n\t\t\t\t\tconst samples = getRenderTargetSamples( renderTarget );\n\t\t\t\t\t_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );\n\n\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\n\t\t\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\t\t\trenderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );\n\n\t\t\t\t}\n\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Setup color buffer\n\n\t\tif ( isCube ) {\n\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, supportsMips );\n\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\n\t\t\t}\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\t\tgenerateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t}\n\n\t\t\tstate.unbindTexture();\n\n\t\t} else if ( isMultipleRenderTargets ) {\n\n\t\t\tconst textures = renderTarget.texture;\n\n\t\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\t\tconst attachment = textures[ i ];\n\t\t\t\tconst attachmentProperties = properties.get( attachment );\n\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, attachmentProperties.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, attachment, supportsMips );\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D );\n\n\t\t\t\tif ( textureNeedsGenerateMipmaps( attachment, supportsMips ) ) {\n\n\t\t\t\t\tgenerateMipmap( _gl.TEXTURE_2D );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.unbindTexture();\n\n\t\t} else {\n\n\t\t\tlet glTextureType = _gl.TEXTURE_2D;\n\n\t\t\tif ( renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget ) {\n\n\t\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\t\tglTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.bindTexture( glTextureType, textureProperties.__webglTexture );\n\t\t\tsetTextureParameters( glTextureType, texture, supportsMips );\n\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType );\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\t\tgenerateMipmap( glTextureType );\n\n\t\t\t}\n\n\t\t\tstate.unbindTexture();\n\n\t\t}\n\n\t\t// Setup depth and stencil buffers\n\n\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\tsetupDepthRenderbuffer( renderTarget );\n\n\t\t}\n\n\t}\n\n\tfunction updateRenderTargetMipmap( renderTarget ) {\n\n\t\tconst supportsMips = isPowerOfTwo$1( renderTarget ) || isWebGL2;\n\n\t\tconst textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [ renderTarget.texture ];\n\n\t\tfor ( let i = 0, il = textures.length; i < il; i ++ ) {\n\n\t\t\tconst texture = textures[ i ];\n\n\t\t\tif ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {\n\n\t\t\t\tconst target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\t\t\t\tconst webglTexture = properties.get( texture ).__webglTexture;\n\n\t\t\t\tstate.bindTexture( target, webglTexture );\n\t\t\t\tgenerateMipmap( target );\n\t\t\t\tstate.unbindTexture();\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction updateMultisampleRenderTarget( renderTarget ) {\n\n\t\tif ( ( isWebGL2 && renderTarget.samples > 0 ) && useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\tconst textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [ renderTarget.texture ];\n\t\t\tconst width = renderTarget.width;\n\t\t\tconst height = renderTarget.height;\n\t\t\tlet mask = _gl.COLOR_BUFFER_BIT;\n\t\t\tconst invalidationArray = [];\n\t\t\tconst depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;\n\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\t\tconst isMultipleRenderTargets = ( renderTarget.isWebGLMultipleRenderTargets === true );\n\n\t\t\t// If MRT we need to remove FBO attachments\n\t\t\tif ( isMultipleRenderTargets ) {\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null );\n\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\t_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.bindFramebuffer( _gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\n\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\tinvalidationArray.push( _gl.COLOR_ATTACHMENT0 + i );\n\n\t\t\t\tif ( renderTarget.depthBuffer ) {\n\n\t\t\t\t\tinvalidationArray.push( depthStyle );\n\n\t\t\t\t}\n\n\t\t\t\tconst ignoreDepthValues = ( renderTargetProperties.__ignoreDepthValues !== undefined ) ? renderTargetProperties.__ignoreDepthValues : false;\n\n\t\t\t\tif ( ignoreDepthValues === false ) {\n\n\t\t\t\t\tif ( renderTarget.depthBuffer ) mask |= _gl.DEPTH_BUFFER_BIT;\n\t\t\t\t\tif ( renderTarget.stencilBuffer ) mask |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t\t\t}\n\n\t\t\t\tif ( isMultipleRenderTargets ) {\n\n\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ignoreDepthValues === true ) {\n\n\t\t\t\t\t_gl.invalidateFramebuffer( _gl.READ_FRAMEBUFFER, [ depthStyle ] );\n\t\t\t\t\t_gl.invalidateFramebuffer( _gl.DRAW_FRAMEBUFFER, [ depthStyle ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( isMultipleRenderTargets ) {\n\n\t\t\t\t\tconst webglTexture = properties.get( textures[ i ] ).__webglTexture;\n\t\t\t\t\t_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0 );\n\n\t\t\t\t}\n\n\t\t\t\t_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST );\n\n\t\t\t\tif ( supportsInvalidateFramebuffer ) {\n\n\t\t\t\t\t_gl.invalidateFramebuffer( _gl.READ_FRAMEBUFFER, invalidationArray );\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t\tstate.bindFramebuffer( _gl.READ_FRAMEBUFFER, null );\n\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, null );\n\n\t\t\t// If MRT since pre-blit we removed the FBO we need to reconstruct the attachments\n\t\t\tif ( isMultipleRenderTargets ) {\n\n\t\t\t\tfor ( let i = 0; i < textures.length; i ++ ) {\n\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[ i ] );\n\n\t\t\t\t\tconst webglTexture = properties.get( textures[ i ] ).__webglTexture;\n\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\n\t\t\t\t\t_gl.framebufferTexture2D( _gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tstate.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );\n\n\t\t}\n\n\t}\n\n\tfunction getRenderTargetSamples( renderTarget ) {\n\n\t\treturn Math.min( maxSamples, renderTarget.samples );\n\n\t}\n\n\tfunction useMultisampledRTT( renderTarget ) {\n\n\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\treturn isWebGL2 && renderTarget.samples > 0 && extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true && renderTargetProperties.__useRenderToTexture !== false;\n\n\t}\n\n\tfunction updateVideoTexture( texture ) {\n\n\t\tconst frame = info.render.frame;\n\n\t\t// Check the last frame we updated the VideoTexture\n\n\t\tif ( _videoTextures.get( texture ) !== frame ) {\n\n\t\t\t_videoTextures.set( texture, frame );\n\t\t\ttexture.update();\n\n\t\t}\n\n\t}\n\n\tfunction verifyColorSpace( texture, image ) {\n\n\t\tconst colorSpace = texture.colorSpace;\n\t\tconst format = texture.format;\n\t\tconst type = texture.type;\n\n\t\tif ( texture.isCompressedTexture === true || texture.format === _SRGBAFormat ) return image;\n\n\t\tif ( colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace ) {\n\n\t\t\t// sRGB\n\n\t\t\tif ( colorSpace === SRGBColorSpace ) {\n\n\t\t\t\tif ( isWebGL2 === false ) {\n\n\t\t\t\t\t// in WebGL 1, try to use EXT_sRGB extension and unsized formats\n\n\t\t\t\t\tif ( extensions.has( 'EXT_sRGB' ) === true && format === RGBAFormat ) {\n\n\t\t\t\t\t\ttexture.format = _SRGBAFormat;\n\n\t\t\t\t\t\t// it's not possible to generate mips in WebGL 1 with this extension\n\n\t\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// slow fallback (CPU decode)\n\n\t\t\t\t\t\timage = ImageUtils.sRGBToLinear( image );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format\n\n\t\t\t\t\tif ( format !== RGBAFormat || type !== UnsignedByteType ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.WebGLTextures: Unsupported texture color space:', colorSpace );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn image;\n\n\t}\n\n\t//\n\n\tthis.allocateTextureUnit = allocateTextureUnit;\n\tthis.resetTextureUnits = resetTextureUnits;\n\n\tthis.setTexture2D = setTexture2D;\n\tthis.setTexture2DArray = setTexture2DArray;\n\tthis.setTexture3D = setTexture3D;\n\tthis.setTextureCube = setTextureCube;\n\tthis.rebindTextures = rebindTextures;\n\tthis.setupRenderTarget = setupRenderTarget;\n\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\n\tthis.updateMultisampleRenderTarget = updateMultisampleRenderTarget;\n\tthis.setupDepthRenderbuffer = setupDepthRenderbuffer;\n\tthis.setupFrameBufferTexture = setupFrameBufferTexture;\n\tthis.useMultisampledRTT = useMultisampledRTT;\n\n}\n\nfunction WebGLUtils( gl, extensions, capabilities ) {\n\n\tconst isWebGL2 = capabilities.isWebGL2;\n\n\tfunction convert( p, colorSpace = NoColorSpace ) {\n\n\t\tlet extension;\n\n\t\tif ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;\n\t\tif ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;\n\t\tif ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;\n\n\t\tif ( p === ByteType ) return gl.BYTE;\n\t\tif ( p === ShortType ) return gl.SHORT;\n\t\tif ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;\n\t\tif ( p === IntType ) return gl.INT;\n\t\tif ( p === UnsignedIntType ) return gl.UNSIGNED_INT;\n\t\tif ( p === FloatType ) return gl.FLOAT;\n\n\t\tif ( p === HalfFloatType ) {\n\n\t\t\tif ( isWebGL2 ) return gl.HALF_FLOAT;\n\n\t\t\textension = extensions.get( 'OES_texture_half_float' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\treturn extension.HALF_FLOAT_OES;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( p === AlphaFormat ) return gl.ALPHA;\n\t\tif ( p === RGBAFormat ) return gl.RGBA;\n\t\tif ( p === LuminanceFormat ) return gl.LUMINANCE;\n\t\tif ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;\n\t\tif ( p === DepthFormat ) return gl.DEPTH_COMPONENT;\n\t\tif ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;\n\n\t\t// WebGL 1 sRGB fallback\n\n\t\tif ( p === _SRGBAFormat ) {\n\n\t\t\textension = extensions.get( 'EXT_sRGB' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\treturn extension.SRGB_ALPHA_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// WebGL2 formats.\n\n\t\tif ( p === RedFormat ) return gl.RED;\n\t\tif ( p === RedIntegerFormat ) return gl.RED_INTEGER;\n\t\tif ( p === RGFormat ) return gl.RG;\n\t\tif ( p === RGIntegerFormat ) return gl.RG_INTEGER;\n\t\tif ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;\n\n\t\t// S3TC\n\n\t\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\n\n\t\t\tif ( colorSpace === SRGBColorSpace ) {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc_srgb' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\n\n\t\t\t\tif ( extension !== null ) {\n\n\t\t\t\t\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\t\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// PVRTC\n\n\t\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ETC1\n\n\t\tif ( p === RGB_ETC1_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\treturn extension.COMPRESSED_RGB_ETC1_WEBGL;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ETC2\n\n\t\tif ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGB_ETC2_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;\n\t\t\t\tif ( p === RGBA_ETC2_EAC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// ASTC\n\n\t\tif ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||\n\t\t\tp === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||\n\t\t\tp === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||\n\t\t\tp === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||\n\t\t\tp === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {\n\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_astc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_ASTC_4x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_5x4_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_5x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_6x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_6x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_8x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x5_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x6_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x8_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_10x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_12x10_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;\n\t\t\t\tif ( p === RGBA_ASTC_12x12_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// BPTC\n\n\t\tif ( p === RGBA_BPTC_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_bptc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_BPTC_Format ) return ( colorSpace === SRGBColorSpace ) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// RGTC\n\n\t\tif ( p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format ) {\n\n\t\t\textension = extensions.get( 'EXT_texture_compression_rgtc' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\tif ( p === RGBA_BPTC_Format ) return extension.COMPRESSED_RED_RGTC1_EXT;\n\t\t\t\tif ( p === SIGNED_RED_RGTC1_Format ) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;\n\t\t\t\tif ( p === RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;\n\t\t\t\tif ( p === SIGNED_RED_GREEN_RGTC2_Format ) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tif ( p === UnsignedInt248Type ) {\n\n\t\t\tif ( isWebGL2 ) return gl.UNSIGNED_INT_24_8;\n\n\t\t\textension = extensions.get( 'WEBGL_depth_texture' );\n\n\t\t\tif ( extension !== null ) {\n\n\t\t\t\treturn extension.UNSIGNED_INT_24_8_WEBGL;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// if \"p\" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)\n\n\t\treturn ( gl[ p ] !== undefined ) ? gl[ p ] : null;\n\n\t}\n\n\treturn { convert: convert };\n\n}\n\nclass ArrayCamera extends PerspectiveCamera {\n\n\tconstructor( array = [] ) {\n\n\t\tsuper();\n\n\t\tthis.isArrayCamera = true;\n\n\t\tthis.cameras = array;\n\n\t}\n\n}\n\nclass Group extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isGroup = true;\n\n\t\tthis.type = 'Group';\n\n\t}\n\n}\n\nconst _moveEvent = { type: 'move' };\n\nclass WebXRController {\n\n\tconstructor() {\n\n\t\tthis._targetRay = null;\n\t\tthis._grip = null;\n\t\tthis._hand = null;\n\n\t}\n\n\tgetHandSpace() {\n\n\t\tif ( this._hand === null ) {\n\n\t\t\tthis._hand = new Group();\n\t\t\tthis._hand.matrixAutoUpdate = false;\n\t\t\tthis._hand.visible = false;\n\n\t\t\tthis._hand.joints = {};\n\t\t\tthis._hand.inputState = { pinching: false };\n\n\t\t}\n\n\t\treturn this._hand;\n\n\t}\n\n\tgetTargetRaySpace() {\n\n\t\tif ( this._targetRay === null ) {\n\n\t\t\tthis._targetRay = new Group();\n\t\t\tthis._targetRay.matrixAutoUpdate = false;\n\t\t\tthis._targetRay.visible = false;\n\t\t\tthis._targetRay.hasLinearVelocity = false;\n\t\t\tthis._targetRay.linearVelocity = new Vector3();\n\t\t\tthis._targetRay.hasAngularVelocity = false;\n\t\t\tthis._targetRay.angularVelocity = new Vector3();\n\n\t\t}\n\n\t\treturn this._targetRay;\n\n\t}\n\n\tgetGripSpace() {\n\n\t\tif ( this._grip === null ) {\n\n\t\t\tthis._grip = new Group();\n\t\t\tthis._grip.matrixAutoUpdate = false;\n\t\t\tthis._grip.visible = false;\n\t\t\tthis._grip.hasLinearVelocity = false;\n\t\t\tthis._grip.linearVelocity = new Vector3();\n\t\t\tthis._grip.hasAngularVelocity = false;\n\t\t\tthis._grip.angularVelocity = new Vector3();\n\n\t\t}\n\n\t\treturn this._grip;\n\n\t}\n\n\tdispatchEvent( event ) {\n\n\t\tif ( this._targetRay !== null ) {\n\n\t\t\tthis._targetRay.dispatchEvent( event );\n\n\t\t}\n\n\t\tif ( this._grip !== null ) {\n\n\t\t\tthis._grip.dispatchEvent( event );\n\n\t\t}\n\n\t\tif ( this._hand !== null ) {\n\n\t\t\tthis._hand.dispatchEvent( event );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tconnect( inputSource ) {\n\n\t\tif ( inputSource && inputSource.hand ) {\n\n\t\t\tconst hand = this._hand;\n\n\t\t\tif ( hand ) {\n\n\t\t\t\tfor ( const inputjoint of inputSource.hand.values() ) {\n\n\t\t\t\t\t// Initialize hand with joints when connected\n\t\t\t\t\tthis._getHandJoint( hand, inputjoint );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.dispatchEvent( { type: 'connected', data: inputSource } );\n\n\t\treturn this;\n\n\t}\n\n\tdisconnect( inputSource ) {\n\n\t\tthis.dispatchEvent( { type: 'disconnected', data: inputSource } );\n\n\t\tif ( this._targetRay !== null ) {\n\n\t\t\tthis._targetRay.visible = false;\n\n\t\t}\n\n\t\tif ( this._grip !== null ) {\n\n\t\t\tthis._grip.visible = false;\n\n\t\t}\n\n\t\tif ( this._hand !== null ) {\n\n\t\t\tthis._hand.visible = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tupdate( inputSource, frame, referenceSpace ) {\n\n\t\tlet inputPose = null;\n\t\tlet gripPose = null;\n\t\tlet handPose = null;\n\n\t\tconst targetRay = this._targetRay;\n\t\tconst grip = this._grip;\n\t\tconst hand = this._hand;\n\n\t\tif ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {\n\n\t\t\tif ( hand && inputSource.hand ) {\n\n\t\t\t\thandPose = true;\n\n\t\t\t\tfor ( const inputjoint of inputSource.hand.values() ) {\n\n\t\t\t\t\t// Update the joints groups with the XRJoint poses\n\t\t\t\t\tconst jointPose = frame.getJointPose( inputjoint, referenceSpace );\n\n\t\t\t\t\t// The transform of this joint will be updated with the joint pose on each frame\n\t\t\t\t\tconst joint = this._getHandJoint( hand, inputjoint );\n\n\t\t\t\t\tif ( jointPose !== null ) {\n\n\t\t\t\t\t\tjoint.matrix.fromArray( jointPose.transform.matrix );\n\t\t\t\t\t\tjoint.matrix.decompose( joint.position, joint.rotation, joint.scale );\n\t\t\t\t\t\tjoint.matrixWorldNeedsUpdate = true;\n\t\t\t\t\t\tjoint.jointRadius = jointPose.radius;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tjoint.visible = jointPose !== null;\n\n\t\t\t\t}\n\n\t\t\t\t// Custom events\n\n\t\t\t\t// Check pinchz\n\t\t\t\tconst indexTip = hand.joints[ 'index-finger-tip' ];\n\t\t\t\tconst thumbTip = hand.joints[ 'thumb-tip' ];\n\t\t\t\tconst distance = indexTip.position.distanceTo( thumbTip.position );\n\n\t\t\t\tconst distanceToPinch = 0.02;\n\t\t\t\tconst threshold = 0.005;\n\n\t\t\t\tif ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {\n\n\t\t\t\t\thand.inputState.pinching = false;\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'pinchend',\n\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\ttarget: this\n\t\t\t\t\t} );\n\n\t\t\t\t} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {\n\n\t\t\t\t\thand.inputState.pinching = true;\n\t\t\t\t\tthis.dispatchEvent( {\n\t\t\t\t\t\ttype: 'pinchstart',\n\t\t\t\t\t\thandedness: inputSource.handedness,\n\t\t\t\t\t\ttarget: this\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( grip !== null && inputSource.gripSpace ) {\n\n\t\t\t\t\tgripPose = frame.getPose( inputSource.gripSpace, referenceSpace );\n\n\t\t\t\t\tif ( gripPose !== null ) {\n\n\t\t\t\t\t\tgrip.matrix.fromArray( gripPose.transform.matrix );\n\t\t\t\t\t\tgrip.matrix.decompose( grip.position, grip.rotation, grip.scale );\n\t\t\t\t\t\tgrip.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t\t\tif ( gripPose.linearVelocity ) {\n\n\t\t\t\t\t\t\tgrip.hasLinearVelocity = true;\n\t\t\t\t\t\t\tgrip.linearVelocity.copy( gripPose.linearVelocity );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgrip.hasLinearVelocity = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( gripPose.angularVelocity ) {\n\n\t\t\t\t\t\t\tgrip.hasAngularVelocity = true;\n\t\t\t\t\t\t\tgrip.angularVelocity.copy( gripPose.angularVelocity );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tgrip.hasAngularVelocity = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( targetRay !== null ) {\n\n\t\t\t\tinputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );\n\n\t\t\t\t// Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it\n\t\t\t\tif ( inputPose === null && gripPose !== null ) {\n\n\t\t\t\t\tinputPose = gripPose;\n\n\t\t\t\t}\n\n\t\t\t\tif ( inputPose !== null ) {\n\n\t\t\t\t\ttargetRay.matrix.fromArray( inputPose.transform.matrix );\n\t\t\t\t\ttargetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );\n\t\t\t\t\ttargetRay.matrixWorldNeedsUpdate = true;\n\n\t\t\t\t\tif ( inputPose.linearVelocity ) {\n\n\t\t\t\t\t\ttargetRay.hasLinearVelocity = true;\n\t\t\t\t\t\ttargetRay.linearVelocity.copy( inputPose.linearVelocity );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetRay.hasLinearVelocity = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( inputPose.angularVelocity ) {\n\n\t\t\t\t\t\ttargetRay.hasAngularVelocity = true;\n\t\t\t\t\t\ttargetRay.angularVelocity.copy( inputPose.angularVelocity );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttargetRay.hasAngularVelocity = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.dispatchEvent( _moveEvent );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t\tif ( targetRay !== null ) {\n\n\t\t\ttargetRay.visible = ( inputPose !== null );\n\n\t\t}\n\n\t\tif ( grip !== null ) {\n\n\t\t\tgrip.visible = ( gripPose !== null );\n\n\t\t}\n\n\t\tif ( hand !== null ) {\n\n\t\t\thand.visible = ( handPose !== null );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// private method\n\n\t_getHandJoint( hand, inputjoint ) {\n\n\t\tif ( hand.joints[ inputjoint.jointName ] === undefined ) {\n\n\t\t\tconst joint = new Group();\n\t\t\tjoint.matrixAutoUpdate = false;\n\t\t\tjoint.visible = false;\n\t\t\thand.joints[ inputjoint.jointName ] = joint;\n\n\t\t\thand.add( joint );\n\n\t\t}\n\n\t\treturn hand.joints[ inputjoint.jointName ];\n\n\t}\n\n}\n\nclass DepthTexture extends Texture {\n\n\tconstructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\n\n\t\tformat = format !== undefined ? format : DepthFormat;\n\n\t\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\n\n\t\t\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );\n\n\t\t}\n\n\t\tif ( type === undefined && format === DepthFormat ) type = UnsignedIntType;\n\t\tif ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.isDepthTexture = true;\n\n\t\tthis.image = { width: width, height: height };\n\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\n\n\t\tthis.flipY = false;\n\t\tthis.generateMipmaps = false;\n\n\t\tthis.compareFunction = null;\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.compareFunction = source.compareFunction;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.compareFunction !== null ) data.compareFunction = this.compareFunction;\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass WebXRManager extends EventDispatcher {\n\n\tconstructor( renderer, gl ) {\n\n\t\tsuper();\n\n\t\tconst scope = this;\n\n\t\tlet session = null;\n\n\t\tlet framebufferScaleFactor = 1.0;\n\n\t\tlet referenceSpace = null;\n\t\tlet referenceSpaceType = 'local-floor';\n\t\t// Set default foveation to maximum.\n\t\tlet foveation = 1.0;\n\t\tlet customReferenceSpace = null;\n\n\t\tlet pose = null;\n\t\tlet glBinding = null;\n\t\tlet glProjLayer = null;\n\t\tlet glBaseLayer = null;\n\t\tlet xrFrame = null;\n\t\tconst attributes = gl.getContextAttributes();\n\t\tlet initialRenderTarget = null;\n\t\tlet newRenderTarget = null;\n\n\t\tconst controllers = [];\n\t\tconst controllerInputSources = [];\n\n\t\t//\n\n\t\tconst cameraL = new PerspectiveCamera();\n\t\tcameraL.layers.enable( 1 );\n\t\tcameraL.viewport = new Vector4();\n\n\t\tconst cameraR = new PerspectiveCamera();\n\t\tcameraR.layers.enable( 2 );\n\t\tcameraR.viewport = new Vector4();\n\n\t\tconst cameras = [ cameraL, cameraR ];\n\n\t\tconst cameraXR = new ArrayCamera();\n\t\tcameraXR.layers.enable( 1 );\n\t\tcameraXR.layers.enable( 2 );\n\n\t\tlet _currentDepthNear = null;\n\t\tlet _currentDepthFar = null;\n\n\t\t//\n\n\t\tthis.cameraAutoUpdate = true;\n\t\tthis.enabled = false;\n\n\t\tthis.isPresenting = false;\n\n\t\tthis.getController = function ( index ) {\n\n\t\t\tlet controller = controllers[ index ];\n\n\t\t\tif ( controller === undefined ) {\n\n\t\t\t\tcontroller = new WebXRController();\n\t\t\t\tcontrollers[ index ] = controller;\n\n\t\t\t}\n\n\t\t\treturn controller.getTargetRaySpace();\n\n\t\t};\n\n\t\tthis.getControllerGrip = function ( index ) {\n\n\t\t\tlet controller = controllers[ index ];\n\n\t\t\tif ( controller === undefined ) {\n\n\t\t\t\tcontroller = new WebXRController();\n\t\t\t\tcontrollers[ index ] = controller;\n\n\t\t\t}\n\n\t\t\treturn controller.getGripSpace();\n\n\t\t};\n\n\t\tthis.getHand = function ( index ) {\n\n\t\t\tlet controller = controllers[ index ];\n\n\t\t\tif ( controller === undefined ) {\n\n\t\t\t\tcontroller = new WebXRController();\n\t\t\t\tcontrollers[ index ] = controller;\n\n\t\t\t}\n\n\t\t\treturn controller.getHandSpace();\n\n\t\t};\n\n\t\t//\n\n\t\tfunction onSessionEvent( event ) {\n\n\t\t\tconst controllerIndex = controllerInputSources.indexOf( event.inputSource );\n\n\t\t\tif ( controllerIndex === - 1 ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst controller = controllers[ controllerIndex ];\n\n\t\t\tif ( controller !== undefined ) {\n\n\t\t\t\tcontroller.update( event.inputSource, event.frame, customReferenceSpace || referenceSpace );\n\t\t\t\tcontroller.dispatchEvent( { type: event.type, data: event.inputSource } );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction onSessionEnd() {\n\n\t\t\tsession.removeEventListener( 'select', onSessionEvent );\n\t\t\tsession.removeEventListener( 'selectstart', onSessionEvent );\n\t\t\tsession.removeEventListener( 'selectend', onSessionEvent );\n\t\t\tsession.removeEventListener( 'squeeze', onSessionEvent );\n\t\t\tsession.removeEventListener( 'squeezestart', onSessionEvent );\n\t\t\tsession.removeEventListener( 'squeezeend', onSessionEvent );\n\t\t\tsession.removeEventListener( 'end', onSessionEnd );\n\t\t\tsession.removeEventListener( 'inputsourceschange', onInputSourcesChange );\n\n\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\tconst inputSource = controllerInputSources[ i ];\n\n\t\t\t\tif ( inputSource === null ) continue;\n\n\t\t\t\tcontrollerInputSources[ i ] = null;\n\n\t\t\t\tcontrollers[ i ].disconnect( inputSource );\n\n\t\t\t}\n\n\t\t\t_currentDepthNear = null;\n\t\t\t_currentDepthFar = null;\n\n\t\t\t// restore framebuffer/rendering state\n\n\t\t\trenderer.setRenderTarget( initialRenderTarget );\n\n\t\t\tglBaseLayer = null;\n\t\t\tglProjLayer = null;\n\t\t\tglBinding = null;\n\t\t\tsession = null;\n\t\t\tnewRenderTarget = null;\n\n\t\t\t//\n\n\t\t\tanimation.stop();\n\n\t\t\tscope.isPresenting = false;\n\n\t\t\tscope.dispatchEvent( { type: 'sessionend' } );\n\n\t\t}\n\n\t\tthis.setFramebufferScaleFactor = function ( value ) {\n\n\t\t\tframebufferScaleFactor = value;\n\n\t\t\tif ( scope.isPresenting === true ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.setReferenceSpaceType = function ( value ) {\n\n\t\t\treferenceSpaceType = value;\n\n\t\t\tif ( scope.isPresenting === true ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.getReferenceSpace = function () {\n\n\t\t\treturn customReferenceSpace || referenceSpace;\n\n\t\t};\n\n\t\tthis.setReferenceSpace = function ( space ) {\n\n\t\t\tcustomReferenceSpace = space;\n\n\t\t};\n\n\t\tthis.getBaseLayer = function () {\n\n\t\t\treturn glProjLayer !== null ? glProjLayer : glBaseLayer;\n\n\t\t};\n\n\t\tthis.getBinding = function () {\n\n\t\t\treturn glBinding;\n\n\t\t};\n\n\t\tthis.getFrame = function () {\n\n\t\t\treturn xrFrame;\n\n\t\t};\n\n\t\tthis.getSession = function () {\n\n\t\t\treturn session;\n\n\t\t};\n\n\t\tthis.setSession = async function ( value ) {\n\n\t\t\tsession = value;\n\n\t\t\tif ( session !== null ) {\n\n\t\t\t\tinitialRenderTarget = renderer.getRenderTarget();\n\n\t\t\t\tsession.addEventListener( 'select', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'selectstart', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'selectend', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'squeeze', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'squeezestart', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'squeezeend', onSessionEvent );\n\t\t\t\tsession.addEventListener( 'end', onSessionEnd );\n\t\t\t\tsession.addEventListener( 'inputsourceschange', onInputSourcesChange );\n\n\t\t\t\tif ( attributes.xrCompatible !== true ) {\n\n\t\t\t\t\tawait gl.makeXRCompatible();\n\n\t\t\t\t}\n\n\t\t\t\tif ( ( session.renderState.layers === undefined ) || ( renderer.capabilities.isWebGL2 === false ) ) {\n\n\t\t\t\t\tconst layerInit = {\n\t\t\t\t\t\tantialias: ( session.renderState.layers === undefined ) ? attributes.antialias : true,\n\t\t\t\t\t\talpha: true,\n\t\t\t\t\t\tdepth: attributes.depth,\n\t\t\t\t\t\tstencil: attributes.stencil,\n\t\t\t\t\t\tframebufferScaleFactor: framebufferScaleFactor\n\t\t\t\t\t};\n\n\t\t\t\t\tglBaseLayer = new XRWebGLLayer( session, gl, layerInit );\n\n\t\t\t\t\tsession.updateRenderState( { baseLayer: glBaseLayer } );\n\n\t\t\t\t\tnewRenderTarget = new WebGLRenderTarget(\n\t\t\t\t\t\tglBaseLayer.framebufferWidth,\n\t\t\t\t\t\tglBaseLayer.framebufferHeight,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tformat: RGBAFormat,\n\t\t\t\t\t\t\ttype: UnsignedByteType,\n\t\t\t\t\t\t\tcolorSpace: renderer.outputColorSpace,\n\t\t\t\t\t\t\tstencilBuffer: attributes.stencil\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlet depthFormat = null;\n\t\t\t\t\tlet depthType = null;\n\t\t\t\t\tlet glDepthFormat = null;\n\n\t\t\t\t\tif ( attributes.depth ) {\n\n\t\t\t\t\t\tglDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;\n\t\t\t\t\t\tdepthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;\n\t\t\t\t\t\tdepthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst projectionlayerInit = {\n\t\t\t\t\t\tcolorFormat: gl.RGBA8,\n\t\t\t\t\t\tdepthFormat: glDepthFormat,\n\t\t\t\t\t\tscaleFactor: framebufferScaleFactor\n\t\t\t\t\t};\n\n\t\t\t\t\tglBinding = new XRWebGLBinding( session, gl );\n\n\t\t\t\t\tglProjLayer = glBinding.createProjectionLayer( projectionlayerInit );\n\n\t\t\t\t\tsession.updateRenderState( { layers: [ glProjLayer ] } );\n\n\t\t\t\t\tnewRenderTarget = new WebGLRenderTarget(\n\t\t\t\t\t\tglProjLayer.textureWidth,\n\t\t\t\t\t\tglProjLayer.textureHeight,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tformat: RGBAFormat,\n\t\t\t\t\t\t\ttype: UnsignedByteType,\n\t\t\t\t\t\t\tdepthTexture: new DepthTexture( glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat ),\n\t\t\t\t\t\t\tstencilBuffer: attributes.stencil,\n\t\t\t\t\t\t\tcolorSpace: renderer.outputColorSpace,\n\t\t\t\t\t\t\tsamples: attributes.antialias ? 4 : 0\n\t\t\t\t\t\t} );\n\n\t\t\t\t\tconst renderTargetProperties = renderer.properties.get( newRenderTarget );\n\t\t\t\t\trenderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;\n\n\t\t\t\t}\n\n\t\t\t\tnewRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278\n\n\t\t\t\tthis.setFoveation( foveation );\n\n\t\t\t\tcustomReferenceSpace = null;\n\t\t\t\treferenceSpace = await session.requestReferenceSpace( referenceSpaceType );\n\n\t\t\t\tanimation.setContext( session );\n\t\t\t\tanimation.start();\n\n\t\t\t\tscope.isPresenting = true;\n\n\t\t\t\tscope.dispatchEvent( { type: 'sessionstart' } );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.getEnvironmentBlendMode = function () {\n\n\t\t\tif ( session !== null ) {\n\n\t\t\t\treturn session.environmentBlendMode;\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction onInputSourcesChange( event ) {\n\n\t\t\t// Notify disconnected\n\n\t\t\tfor ( let i = 0; i < event.removed.length; i ++ ) {\n\n\t\t\t\tconst inputSource = event.removed[ i ];\n\t\t\t\tconst index = controllerInputSources.indexOf( inputSource );\n\n\t\t\t\tif ( index >= 0 ) {\n\n\t\t\t\t\tcontrollerInputSources[ index ] = null;\n\t\t\t\t\tcontrollers[ index ].disconnect( inputSource );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Notify connected\n\n\t\t\tfor ( let i = 0; i < event.added.length; i ++ ) {\n\n\t\t\t\tconst inputSource = event.added[ i ];\n\n\t\t\t\tlet controllerIndex = controllerInputSources.indexOf( inputSource );\n\n\t\t\t\tif ( controllerIndex === - 1 ) {\n\n\t\t\t\t\t// Assign input source a controller that currently has no input source\n\n\t\t\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\t\t\tif ( i >= controllerInputSources.length ) {\n\n\t\t\t\t\t\t\tcontrollerInputSources.push( inputSource );\n\t\t\t\t\t\t\tcontrollerIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t} else if ( controllerInputSources[ i ] === null ) {\n\n\t\t\t\t\t\t\tcontrollerInputSources[ i ] = inputSource;\n\t\t\t\t\t\t\tcontrollerIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// If all controllers do currently receive input we ignore new ones\n\n\t\t\t\t\tif ( controllerIndex === - 1 ) break;\n\n\t\t\t\t}\n\n\t\t\t\tconst controller = controllers[ controllerIndex ];\n\n\t\t\t\tif ( controller ) {\n\n\t\t\t\t\tcontroller.connect( inputSource );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst cameraLPos = new Vector3();\n\t\tconst cameraRPos = new Vector3();\n\n\t\t/**\n\t\t * Assumes 2 cameras that are parallel and share an X-axis, and that\n\t\t * the cameras' projection and world matrices have already been set.\n\t\t * And that near and far planes are identical for both cameras.\n\t\t * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n\t\t */\n\t\tfunction setProjectionFromUnion( camera, cameraL, cameraR ) {\n\n\t\t\tcameraLPos.setFromMatrixPosition( cameraL.matrixWorld );\n\t\t\tcameraRPos.setFromMatrixPosition( cameraR.matrixWorld );\n\n\t\t\tconst ipd = cameraLPos.distanceTo( cameraRPos );\n\n\t\t\tconst projL = cameraL.projectionMatrix.elements;\n\t\t\tconst projR = cameraR.projectionMatrix.elements;\n\n\t\t\t// VR systems will have identical far and near planes, and\n\t\t\t// most likely identical top and bottom frustum extents.\n\t\t\t// Use the left camera for these values.\n\t\t\tconst near = projL[ 14 ] / ( projL[ 10 ] - 1 );\n\t\t\tconst far = projL[ 14 ] / ( projL[ 10 ] + 1 );\n\t\t\tconst topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];\n\t\t\tconst bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];\n\n\t\t\tconst leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];\n\t\t\tconst rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];\n\t\t\tconst left = near * leftFov;\n\t\t\tconst right = near * rightFov;\n\n\t\t\t// Calculate the new camera's position offset from the\n\t\t\t// left camera. xOffset should be roughly half `ipd`.\n\t\t\tconst zOffset = ipd / ( - leftFov + rightFov );\n\t\t\tconst xOffset = zOffset * - leftFov;\n\n\t\t\t// TODO: Better way to apply this offset?\n\t\t\tcameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );\n\t\t\tcamera.translateX( xOffset );\n\t\t\tcamera.translateZ( zOffset );\n\t\t\tcamera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );\n\t\t\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\n\n\t\t\t// Find the union of the frustum values of the cameras and scale\n\t\t\t// the values so that the near plane's position does not change in world space,\n\t\t\t// although must now be relative to the new union camera.\n\t\t\tconst near2 = near + zOffset;\n\t\t\tconst far2 = far + zOffset;\n\t\t\tconst left2 = left - xOffset;\n\t\t\tconst right2 = right + ( ipd - xOffset );\n\t\t\tconst top2 = topFov * far / far2 * near2;\n\t\t\tconst bottom2 = bottomFov * far / far2 * near2;\n\n\t\t\tcamera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );\n\t\t\tcamera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();\n\n\t\t}\n\n\t\tfunction updateCamera( camera, parent ) {\n\n\t\t\tif ( parent === null ) {\n\n\t\t\t\tcamera.matrixWorld.copy( camera.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tcamera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );\n\n\t\t\t}\n\n\t\t\tcamera.matrixWorldInverse.copy( camera.matrixWorld ).invert();\n\n\t\t}\n\n\t\tthis.updateCamera = function ( camera ) {\n\n\t\t\tif ( session === null ) return;\n\n\t\t\tcameraXR.near = cameraR.near = cameraL.near = camera.near;\n\t\t\tcameraXR.far = cameraR.far = cameraL.far = camera.far;\n\n\t\t\tif ( _currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far ) {\n\n\t\t\t\t// Note that the new renderState won't apply until the next frame. See #18320\n\n\t\t\t\tsession.updateRenderState( {\n\t\t\t\t\tdepthNear: cameraXR.near,\n\t\t\t\t\tdepthFar: cameraXR.far\n\t\t\t\t} );\n\n\t\t\t\t_currentDepthNear = cameraXR.near;\n\t\t\t\t_currentDepthFar = cameraXR.far;\n\n\t\t\t}\n\n\t\t\tconst parent = camera.parent;\n\t\t\tconst cameras = cameraXR.cameras;\n\n\t\t\tupdateCamera( cameraXR, parent );\n\n\t\t\tfor ( let i = 0; i < cameras.length; i ++ ) {\n\n\t\t\t\tupdateCamera( cameras[ i ], parent );\n\n\t\t\t}\n\n\t\t\t// update projection matrix for proper view frustum culling\n\n\t\t\tif ( cameras.length === 2 ) {\n\n\t\t\t\tsetProjectionFromUnion( cameraXR, cameraL, cameraR );\n\n\t\t\t} else {\n\n\t\t\t\t// assume single camera setup (AR)\n\n\t\t\t\tcameraXR.projectionMatrix.copy( cameraL.projectionMatrix );\n\n\t\t\t}\n\n\t\t\t// update user camera and its children\n\n\t\t\tupdateUserCamera( camera, cameraXR, parent );\n\n\t\t};\n\n\t\tfunction updateUserCamera( camera, cameraXR, parent ) {\n\n\t\t\tif ( parent === null ) {\n\n\t\t\t\tcamera.matrix.copy( cameraXR.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tcamera.matrix.copy( parent.matrixWorld );\n\t\t\t\tcamera.matrix.invert();\n\t\t\t\tcamera.matrix.multiply( cameraXR.matrixWorld );\n\n\t\t\t}\n\n\t\t\tcamera.matrix.decompose( camera.position, camera.quaternion, camera.scale );\n\t\t\tcamera.updateMatrixWorld( true );\n\n\t\t\tconst children = camera.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tchildren[ i ].updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t\tcamera.projectionMatrix.copy( cameraXR.projectionMatrix );\n\t\t\tcamera.projectionMatrixInverse.copy( cameraXR.projectionMatrixInverse );\n\n\t\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\t\tcamera.fov = RAD2DEG * 2 * Math.atan( 1 / camera.projectionMatrix.elements[ 5 ] );\n\t\t\t\tcamera.zoom = 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.getCamera = function () {\n\n\t\t\treturn cameraXR;\n\n\t\t};\n\n\t\tthis.getFoveation = function () {\n\n\t\t\tif ( glProjLayer === null && glBaseLayer === null ) {\n\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\treturn foveation;\n\n\t\t};\n\n\t\tthis.setFoveation = function ( value ) {\n\n\t\t\t// 0 = no foveation = full resolution\n\t\t\t// 1 = maximum foveation = the edges render at lower resolution\n\n\t\t\tfoveation = value;\n\n\t\t\tif ( glProjLayer !== null ) {\n\n\t\t\t\tglProjLayer.fixedFoveation = value;\n\n\t\t\t}\n\n\t\t\tif ( glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined ) {\n\n\t\t\t\tglBaseLayer.fixedFoveation = value;\n\n\t\t\t}\n\n\t\t};\n\n\t\t// Animation Loop\n\n\t\tlet onAnimationFrameCallback = null;\n\n\t\tfunction onAnimationFrame( time, frame ) {\n\n\t\t\tpose = frame.getViewerPose( customReferenceSpace || referenceSpace );\n\t\t\txrFrame = frame;\n\n\t\t\tif ( pose !== null ) {\n\n\t\t\t\tconst views = pose.views;\n\n\t\t\t\tif ( glBaseLayer !== null ) {\n\n\t\t\t\t\trenderer.setRenderTargetFramebuffer( newRenderTarget, glBaseLayer.framebuffer );\n\t\t\t\t\trenderer.setRenderTarget( newRenderTarget );\n\n\t\t\t\t}\n\n\t\t\t\tlet cameraXRNeedsUpdate = false;\n\n\t\t\t\t// check if it's necessary to rebuild cameraXR's camera list\n\n\t\t\t\tif ( views.length !== cameraXR.cameras.length ) {\n\n\t\t\t\t\tcameraXR.cameras.length = 0;\n\t\t\t\t\tcameraXRNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0; i < views.length; i ++ ) {\n\n\t\t\t\t\tconst view = views[ i ];\n\n\t\t\t\t\tlet viewport = null;\n\n\t\t\t\t\tif ( glBaseLayer !== null ) {\n\n\t\t\t\t\t\tviewport = glBaseLayer.getViewport( view );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst glSubImage = glBinding.getViewSubImage( glProjLayer, view );\n\t\t\t\t\t\tviewport = glSubImage.viewport;\n\n\t\t\t\t\t\t// For side-by-side projection, we only produce a single texture for both eyes.\n\t\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\t\trenderer.setRenderTargetTextures(\n\t\t\t\t\t\t\t\tnewRenderTarget,\n\t\t\t\t\t\t\t\tglSubImage.colorTexture,\n\t\t\t\t\t\t\t\tglProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture );\n\n\t\t\t\t\t\t\trenderer.setRenderTarget( newRenderTarget );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet camera = cameras[ i ];\n\n\t\t\t\t\tif ( camera === undefined ) {\n\n\t\t\t\t\t\tcamera = new PerspectiveCamera();\n\t\t\t\t\t\tcamera.layers.enable( i );\n\t\t\t\t\t\tcamera.viewport = new Vector4();\n\t\t\t\t\t\tcameras[ i ] = camera;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcamera.matrix.fromArray( view.transform.matrix );\n\t\t\t\t\tcamera.matrix.decompose( camera.position, camera.quaternion, camera.scale );\n\t\t\t\t\tcamera.projectionMatrix.fromArray( view.projectionMatrix );\n\t\t\t\t\tcamera.projectionMatrixInverse.copy( camera.projectionMatrix ).invert();\n\t\t\t\t\tcamera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );\n\n\t\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\t\tcameraXR.matrix.copy( camera.matrix );\n\t\t\t\t\t\tcameraXR.matrix.decompose( cameraXR.position, cameraXR.quaternion, cameraXR.scale );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( cameraXRNeedsUpdate === true ) {\n\n\t\t\t\t\t\tcameraXR.cameras.push( camera );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tfor ( let i = 0; i < controllers.length; i ++ ) {\n\n\t\t\t\tconst inputSource = controllerInputSources[ i ];\n\t\t\t\tconst controller = controllers[ i ];\n\n\t\t\t\tif ( inputSource !== null && controller !== undefined ) {\n\n\t\t\t\t\tcontroller.update( inputSource, frame, customReferenceSpace || referenceSpace );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );\n\n\t\t\tif ( frame.detectedPlanes ) {\n\n\t\t\t\tscope.dispatchEvent( { type: 'planesdetected', data: frame } );\n\n\t\t\t}\n\n\t\t\txrFrame = null;\n\n\t\t}\n\n\t\tconst animation = new WebGLAnimation();\n\n\t\tanimation.setAnimationLoop( onAnimationFrame );\n\n\t\tthis.setAnimationLoop = function ( callback ) {\n\n\t\t\tonAnimationFrameCallback = callback;\n\n\t\t};\n\n\t\tthis.dispose = function () {};\n\n\t}\n\n}\n\nfunction WebGLMaterials( renderer, properties ) {\n\n\tfunction refreshTransformUniform( map, uniform ) {\n\n\t\tif ( map.matrixAutoUpdate === true ) {\n\n\t\t\tmap.updateMatrix();\n\n\t\t}\n\n\t\tuniform.value.copy( map.matrix );\n\n\t}\n\n\tfunction refreshFogUniforms( uniforms, fog ) {\n\n\t\tfog.color.getRGB( uniforms.fogColor.value, getUnlitUniformColorSpace( renderer ) );\n\n\t\tif ( fog.isFog ) {\n\n\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t} else if ( fog.isFogExp2 ) {\n\n\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t}\n\n\t}\n\n\tfunction refreshMaterialUniforms( uniforms, material, pixelRatio, height, transmissionRenderTarget ) {\n\n\t\tif ( material.isMeshBasicMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t} else if ( material.isMeshLambertMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t} else if ( material.isMeshToonMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsToon( uniforms, material );\n\n\t\t} else if ( material.isMeshPhongMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsPhong( uniforms, material );\n\n\t\t} else if ( material.isMeshStandardMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsStandard( uniforms, material );\n\n\t\t\tif ( material.isMeshPhysicalMaterial ) {\n\n\t\t\t\trefreshUniformsPhysical( uniforms, material, transmissionRenderTarget );\n\n\t\t\t}\n\n\t\t} else if ( material.isMeshMatcapMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsMatcap( uniforms, material );\n\n\t\t} else if ( material.isMeshDepthMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t} else if ( material.isMeshDistanceMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\t\t\trefreshUniformsDistance( uniforms, material );\n\n\t\t} else if ( material.isMeshNormalMaterial ) {\n\n\t\t\trefreshUniformsCommon( uniforms, material );\n\n\t\t} else if ( material.isLineBasicMaterial ) {\n\n\t\t\trefreshUniformsLine( uniforms, material );\n\n\t\t\tif ( material.isLineDashedMaterial ) {\n\n\t\t\t\trefreshUniformsDash( uniforms, material );\n\n\t\t\t}\n\n\t\t} else if ( material.isPointsMaterial ) {\n\n\t\t\trefreshUniformsPoints( uniforms, material, pixelRatio, height );\n\n\t\t} else if ( material.isSpriteMaterial ) {\n\n\t\t\trefreshUniformsSprites( uniforms, material );\n\n\t\t} else if ( material.isShadowMaterial ) {\n\n\t\t\tuniforms.color.value.copy( material.color );\n\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t} else if ( material.isShaderMaterial ) {\n\n\t\t\tmaterial.uniformsNeedUpdate = false; // #15581\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsCommon( uniforms, material ) {\n\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tif ( material.color ) {\n\n\t\t\tuniforms.diffuse.value.copy( material.color );\n\n\t\t}\n\n\t\tif ( material.emissive ) {\n\n\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t}\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\trefreshTransformUniform( material.map, uniforms.mapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\trefreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );\n\n\t\t}\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\n\t\t\trefreshTransformUniform( material.bumpMap, uniforms.bumpMapTransform );\n\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\tuniforms.bumpScale.value *= - 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\n\t\t\trefreshTransformUniform( material.normalMap, uniforms.normalMapTransform );\n\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\tuniforms.normalScale.value.negate();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.displacementMap ) {\n\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\n\t\t\trefreshTransformUniform( material.displacementMap, uniforms.displacementMapTransform );\n\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t}\n\n\t\tif ( material.emissiveMap ) {\n\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\n\t\t\trefreshTransformUniform( material.emissiveMap, uniforms.emissiveMapTransform );\n\n\t\t}\n\n\t\tif ( material.specularMap ) {\n\n\t\t\tuniforms.specularMap.value = material.specularMap;\n\n\t\t\trefreshTransformUniform( material.specularMap, uniforms.specularMapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaTest > 0 ) {\n\n\t\t\tuniforms.alphaTest.value = material.alphaTest;\n\n\t\t}\n\n\t\tconst envMap = properties.get( material ).envMap;\n\n\t\tif ( envMap ) {\n\n\t\t\tuniforms.envMap.value = envMap;\n\n\t\t\tuniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;\n\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\t\t\tuniforms.ior.value = material.ior;\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t}\n\n\t\tif ( material.lightMap ) {\n\n\t\t\tuniforms.lightMap.value = material.lightMap;\n\n\t\t\t// artist-friendly light intensity scaling factor\n\t\t\tconst scaleFactor = ( renderer.useLegacyLights === true ) ? Math.PI : 1;\n\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;\n\n\t\t\trefreshTransformUniform( material.lightMap, uniforms.lightMapTransform );\n\n\t\t}\n\n\t\tif ( material.aoMap ) {\n\n\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t\trefreshTransformUniform( material.aoMap, uniforms.aoMapTransform );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsLine( uniforms, material ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\trefreshTransformUniform( material.map, uniforms.mapTransform );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsDash( uniforms, material ) {\n\n\t\tuniforms.dashSize.value = material.dashSize;\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\tuniforms.scale.value = material.scale;\n\n\t}\n\n\tfunction refreshUniformsPoints( uniforms, material, pixelRatio, height ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.size.value = material.size * pixelRatio;\n\t\tuniforms.scale.value = height * 0.5;\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\trefreshTransformUniform( material.map, uniforms.uvTransform );\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\trefreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaTest > 0 ) {\n\n\t\t\tuniforms.alphaTest.value = material.alphaTest;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsSprites( uniforms, material ) {\n\n\t\tuniforms.diffuse.value.copy( material.color );\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.rotation.value = material.rotation;\n\n\t\tif ( material.map ) {\n\n\t\t\tuniforms.map.value = material.map;\n\n\t\t\trefreshTransformUniform( material.map, uniforms.mapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaMap ) {\n\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\trefreshTransformUniform( material.alphaMap, uniforms.alphaMapTransform );\n\n\t\t}\n\n\t\tif ( material.alphaTest > 0 ) {\n\n\t\t\tuniforms.alphaTest.value = material.alphaTest;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhong( uniforms, material ) {\n\n\t\tuniforms.specular.value.copy( material.specular );\n\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\n\n\t}\n\n\tfunction refreshUniformsToon( uniforms, material ) {\n\n\t\tif ( material.gradientMap ) {\n\n\t\t\tuniforms.gradientMap.value = material.gradientMap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsStandard( uniforms, material ) {\n\n\t\tuniforms.metalness.value = material.metalness;\n\n\t\tif ( material.metalnessMap ) {\n\n\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\n\n\t\t\trefreshTransformUniform( material.metalnessMap, uniforms.metalnessMapTransform );\n\n\t\t}\n\n\t\tuniforms.roughness.value = material.roughness;\n\n\t\tif ( material.roughnessMap ) {\n\n\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t\trefreshTransformUniform( material.roughnessMap, uniforms.roughnessMapTransform );\n\n\t\t}\n\n\t\tconst envMap = properties.get( material ).envMap;\n\n\t\tif ( envMap ) {\n\n\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\n\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsPhysical( uniforms, material, transmissionRenderTarget ) {\n\n\t\tuniforms.ior.value = material.ior; // also part of uniforms common\n\n\t\tif ( material.sheen > 0 ) {\n\n\t\t\tuniforms.sheenColor.value.copy( material.sheenColor ).multiplyScalar( material.sheen );\n\n\t\t\tuniforms.sheenRoughness.value = material.sheenRoughness;\n\n\t\t\tif ( material.sheenColorMap ) {\n\n\t\t\t\tuniforms.sheenColorMap.value = material.sheenColorMap;\n\n\t\t\t\trefreshTransformUniform( material.sheenColorMap, uniforms.sheenColorMapTransform );\n\n\t\t\t}\n\n\t\t\tif ( material.sheenRoughnessMap ) {\n\n\t\t\t\tuniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;\n\n\t\t\t\trefreshTransformUniform( material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.clearcoat > 0 ) {\n\n\t\t\tuniforms.clearcoat.value = material.clearcoat;\n\t\t\tuniforms.clearcoatRoughness.value = material.clearcoatRoughness;\n\n\t\t\tif ( material.clearcoatMap ) {\n\n\t\t\t\tuniforms.clearcoatMap.value = material.clearcoatMap;\n\n\t\t\t\trefreshTransformUniform( material.clearcoatMap, uniforms.clearcoatMapTransform );\n\n\t\t\t}\n\n\t\t\tif ( material.clearcoatRoughnessMap ) {\n\n\t\t\t\tuniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;\n\n\t\t\t\trefreshTransformUniform( material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform );\n\n\t\t\t}\n\n\t\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\t\tuniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;\n\n\t\t\t\trefreshTransformUniform( material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform );\n\n\t\t\t\tuniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );\n\n\t\t\t\tif ( material.side === BackSide ) {\n\n\t\t\t\t\tuniforms.clearcoatNormalScale.value.negate();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.iridescence > 0 ) {\n\n\t\t\tuniforms.iridescence.value = material.iridescence;\n\t\t\tuniforms.iridescenceIOR.value = material.iridescenceIOR;\n\t\t\tuniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[ 0 ];\n\t\t\tuniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[ 1 ];\n\n\t\t\tif ( material.iridescenceMap ) {\n\n\t\t\t\tuniforms.iridescenceMap.value = material.iridescenceMap;\n\n\t\t\t\trefreshTransformUniform( material.iridescenceMap, uniforms.iridescenceMapTransform );\n\n\t\t\t}\n\n\t\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\t\tuniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;\n\n\t\t\t\trefreshTransformUniform( material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.transmission > 0 ) {\n\n\t\t\tuniforms.transmission.value = material.transmission;\n\t\t\tuniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;\n\t\t\tuniforms.transmissionSamplerSize.value.set( transmissionRenderTarget.width, transmissionRenderTarget.height );\n\n\t\t\tif ( material.transmissionMap ) {\n\n\t\t\t\tuniforms.transmissionMap.value = material.transmissionMap;\n\n\t\t\t\trefreshTransformUniform( material.transmissionMap, uniforms.transmissionMapTransform );\n\n\t\t\t}\n\n\t\t\tuniforms.thickness.value = material.thickness;\n\n\t\t\tif ( material.thicknessMap ) {\n\n\t\t\t\tuniforms.thicknessMap.value = material.thicknessMap;\n\n\t\t\t\trefreshTransformUniform( material.thicknessMap, uniforms.thicknessMapTransform );\n\n\t\t\t}\n\n\t\t\tuniforms.attenuationDistance.value = material.attenuationDistance;\n\t\t\tuniforms.attenuationColor.value.copy( material.attenuationColor );\n\n\t\t}\n\n\t\tif ( material.anisotropy > 0 ) {\n\n\t\t\tuniforms.anisotropyVector.value.set( material.anisotropy * Math.cos( material.anisotropyRotation ), material.anisotropy * Math.sin( material.anisotropyRotation ) );\n\n\t\t\tif ( material.anisotropyMap ) {\n\n\t\t\t\tuniforms.anisotropyMap.value = material.anisotropyMap;\n\n\t\t\t\trefreshTransformUniform( material.anisotropyMap, uniforms.anisotropyMapTransform );\n\n\t\t\t}\n\n\t\t}\n\n\t\tuniforms.specularIntensity.value = material.specularIntensity;\n\t\tuniforms.specularColor.value.copy( material.specularColor );\n\n\t\tif ( material.specularColorMap ) {\n\n\t\t\tuniforms.specularColorMap.value = material.specularColorMap;\n\n\t\t\trefreshTransformUniform( material.specularColorMap, uniforms.specularColorMapTransform );\n\n\t\t}\n\n\t\tif ( material.specularIntensityMap ) {\n\n\t\t\tuniforms.specularIntensityMap.value = material.specularIntensityMap;\n\n\t\t\trefreshTransformUniform( material.specularIntensityMap, uniforms.specularIntensityMapTransform );\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsMatcap( uniforms, material ) {\n\n\t\tif ( material.matcap ) {\n\n\t\t\tuniforms.matcap.value = material.matcap;\n\n\t\t}\n\n\t}\n\n\tfunction refreshUniformsDistance( uniforms, material ) {\n\n\t\tconst light = properties.get( material ).light;\n\n\t\tuniforms.referencePosition.value.setFromMatrixPosition( light.matrixWorld );\n\t\tuniforms.nearDistance.value = light.shadow.camera.near;\n\t\tuniforms.farDistance.value = light.shadow.camera.far;\n\n\t}\n\n\treturn {\n\t\trefreshFogUniforms: refreshFogUniforms,\n\t\trefreshMaterialUniforms: refreshMaterialUniforms\n\t};\n\n}\n\nfunction WebGLUniformsGroups( gl, info, capabilities, state ) {\n\n\tlet buffers = {};\n\tlet updateList = {};\n\tlet allocatedBindingPoints = [];\n\n\tconst maxBindingPoints = ( capabilities.isWebGL2 ) ? gl.getParameter( gl.MAX_UNIFORM_BUFFER_BINDINGS ) : 0; // binding points are global whereas block indices are per shader program\n\n\tfunction bind( uniformsGroup, program ) {\n\n\t\tconst webglProgram = program.program;\n\t\tstate.uniformBlockBinding( uniformsGroup, webglProgram );\n\n\t}\n\n\tfunction update( uniformsGroup, program ) {\n\n\t\tlet buffer = buffers[ uniformsGroup.id ];\n\n\t\tif ( buffer === undefined ) {\n\n\t\t\tprepareUniformsGroup( uniformsGroup );\n\n\t\t\tbuffer = createBuffer( uniformsGroup );\n\t\t\tbuffers[ uniformsGroup.id ] = buffer;\n\n\t\t\tuniformsGroup.addEventListener( 'dispose', onUniformsGroupsDispose );\n\n\t\t}\n\n\t\t// ensure to update the binding points/block indices mapping for this program\n\n\t\tconst webglProgram = program.program;\n\t\tstate.updateUBOMapping( uniformsGroup, webglProgram );\n\n\t\t// update UBO once per frame\n\n\t\tconst frame = info.render.frame;\n\n\t\tif ( updateList[ uniformsGroup.id ] !== frame ) {\n\n\t\t\tupdateBufferData( uniformsGroup );\n\n\t\t\tupdateList[ uniformsGroup.id ] = frame;\n\n\t\t}\n\n\t}\n\n\tfunction createBuffer( uniformsGroup ) {\n\n\t\t// the setup of an UBO is independent of a particular shader program but global\n\n\t\tconst bindingPointIndex = allocateBindingPointIndex();\n\t\tuniformsGroup.__bindingPointIndex = bindingPointIndex;\n\n\t\tconst buffer = gl.createBuffer();\n\t\tconst size = uniformsGroup.__size;\n\t\tconst usage = uniformsGroup.usage;\n\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, buffer );\n\t\tgl.bufferData( gl.UNIFORM_BUFFER, size, usage );\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, null );\n\t\tgl.bindBufferBase( gl.UNIFORM_BUFFER, bindingPointIndex, buffer );\n\n\t\treturn buffer;\n\n\t}\n\n\tfunction allocateBindingPointIndex() {\n\n\t\tfor ( let i = 0; i < maxBindingPoints; i ++ ) {\n\n\t\t\tif ( allocatedBindingPoints.indexOf( i ) === - 1 ) {\n\n\t\t\t\tallocatedBindingPoints.push( i );\n\t\t\t\treturn i;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconsole.error( 'THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.' );\n\n\t\treturn 0;\n\n\t}\n\n\tfunction updateBufferData( uniformsGroup ) {\n\n\t\tconst buffer = buffers[ uniformsGroup.id ];\n\t\tconst uniforms = uniformsGroup.uniforms;\n\t\tconst cache = uniformsGroup.__cache;\n\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, buffer );\n\n\t\tfor ( let i = 0, il = uniforms.length; i < il; i ++ ) {\n\n\t\t\tconst uniform = uniforms[ i ];\n\n\t\t\t// partly update the buffer if necessary\n\n\t\t\tif ( hasUniformChanged( uniform, i, cache ) === true ) {\n\n\t\t\t\tconst offset = uniform.__offset;\n\n\t\t\t\tconst values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];\n\n\t\t\t\tlet arrayOffset = 0;\n\n\t\t\t\tfor ( let i = 0; i < values.length; i ++ ) {\n\n\t\t\t\t\tconst value = values[ i ];\n\n\t\t\t\t\tconst info = getUniformSize( value );\n\n\t\t\t\t\tif ( typeof value === 'number' ) {\n\n\t\t\t\t\t\tuniform.__data[ 0 ] = value;\n\t\t\t\t\t\tgl.bufferSubData( gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data );\n\n\t\t\t\t\t} else if ( value.isMatrix3 ) {\n\n\t\t\t\t\t\t// manually converting 3x3 to 3x4\n\n\t\t\t\t\t\tuniform.__data[ 0 ] = value.elements[ 0 ];\n\t\t\t\t\t\tuniform.__data[ 1 ] = value.elements[ 1 ];\n\t\t\t\t\t\tuniform.__data[ 2 ] = value.elements[ 2 ];\n\t\t\t\t\t\tuniform.__data[ 3 ] = value.elements[ 0 ];\n\t\t\t\t\t\tuniform.__data[ 4 ] = value.elements[ 3 ];\n\t\t\t\t\t\tuniform.__data[ 5 ] = value.elements[ 4 ];\n\t\t\t\t\t\tuniform.__data[ 6 ] = value.elements[ 5 ];\n\t\t\t\t\t\tuniform.__data[ 7 ] = value.elements[ 0 ];\n\t\t\t\t\t\tuniform.__data[ 8 ] = value.elements[ 6 ];\n\t\t\t\t\t\tuniform.__data[ 9 ] = value.elements[ 7 ];\n\t\t\t\t\t\tuniform.__data[ 10 ] = value.elements[ 8 ];\n\t\t\t\t\t\tuniform.__data[ 11 ] = value.elements[ 0 ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvalue.toArray( uniform.__data, arrayOffset );\n\n\t\t\t\t\t\tarrayOffset += info.storage / Float32Array.BYTES_PER_ELEMENT;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgl.bufferSubData( gl.UNIFORM_BUFFER, offset, uniform.__data );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgl.bindBuffer( gl.UNIFORM_BUFFER, null );\n\n\t}\n\n\tfunction hasUniformChanged( uniform, index, cache ) {\n\n\t\tconst value = uniform.value;\n\n\t\tif ( cache[ index ] === undefined ) {\n\n\t\t\t// cache entry does not exist so far\n\n\t\t\tif ( typeof value === 'number' ) {\n\n\t\t\t\tcache[ index ] = value;\n\n\t\t\t} else {\n\n\t\t\t\tconst values = Array.isArray( value ) ? value : [ value ];\n\n\t\t\t\tconst tempValues = [];\n\n\t\t\t\tfor ( let i = 0; i < values.length; i ++ ) {\n\n\t\t\t\t\ttempValues.push( values[ i ].clone() );\n\n\t\t\t\t}\n\n\t\t\t\tcache[ index ] = tempValues;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\t// compare current value with cached entry\n\n\t\t\tif ( typeof value === 'number' ) {\n\n\t\t\t\tif ( cache[ index ] !== value ) {\n\n\t\t\t\t\tcache[ index ] = value;\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst cachedObjects = Array.isArray( cache[ index ] ) ? cache[ index ] : [ cache[ index ] ];\n\t\t\t\tconst values = Array.isArray( value ) ? value : [ value ];\n\n\t\t\t\tfor ( let i = 0; i < cachedObjects.length; i ++ ) {\n\n\t\t\t\t\tconst cachedObject = cachedObjects[ i ];\n\n\t\t\t\t\tif ( cachedObject.equals( values[ i ] ) === false ) {\n\n\t\t\t\t\t\tcachedObject.copy( values[ i ] );\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tfunction prepareUniformsGroup( uniformsGroup ) {\n\n\t\t// determine total buffer size according to the STD140 layout\n\t\t// Hint: STD140 is the only supported layout in WebGL 2\n\n\t\tconst uniforms = uniformsGroup.uniforms;\n\n\t\tlet offset = 0; // global buffer offset in bytes\n\t\tconst chunkSize = 16; // size of a chunk in bytes\n\t\tlet chunkOffset = 0; // offset within a single chunk in bytes\n\n\t\tfor ( let i = 0, l = uniforms.length; i < l; i ++ ) {\n\n\t\t\tconst uniform = uniforms[ i ];\n\n\t\t\tconst infos = {\n\t\t\t\tboundary: 0, // bytes\n\t\t\t\tstorage: 0 // bytes\n\t\t\t};\n\n\t\t\tconst values = Array.isArray( uniform.value ) ? uniform.value : [ uniform.value ];\n\n\t\t\tfor ( let j = 0, jl = values.length; j < jl; j ++ ) {\n\n\t\t\t\tconst value = values[ j ];\n\n\t\t\t\tconst info = getUniformSize( value );\n\n\t\t\t\tinfos.boundary += info.boundary;\n\t\t\t\tinfos.storage += info.storage;\n\n\t\t\t}\n\n\t\t\t// the following two properties will be used for partial buffer updates\n\n\t\t\tuniform.__data = new Float32Array( infos.storage / Float32Array.BYTES_PER_ELEMENT );\n\t\t\tuniform.__offset = offset;\n\n\t\t\t//\n\n\t\t\tif ( i > 0 ) {\n\n\t\t\t\tchunkOffset = offset % chunkSize;\n\n\t\t\t\tconst remainingSizeInChunk = chunkSize - chunkOffset;\n\n\t\t\t\t// check for chunk overflow\n\n\t\t\t\tif ( chunkOffset !== 0 && ( remainingSizeInChunk - infos.boundary ) < 0 ) {\n\n\t\t\t\t\t// add padding and adjust offset\n\n\t\t\t\t\toffset += ( chunkSize - chunkOffset );\n\t\t\t\t\tuniform.__offset = offset;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\toffset += infos.storage;\n\n\t\t}\n\n\t\t// ensure correct final padding\n\n\t\tchunkOffset = offset % chunkSize;\n\n\t\tif ( chunkOffset > 0 ) offset += ( chunkSize - chunkOffset );\n\n\t\t//\n\n\t\tuniformsGroup.__size = offset;\n\t\tuniformsGroup.__cache = {};\n\n\t\treturn this;\n\n\t}\n\n\tfunction getUniformSize( value ) {\n\n\t\tconst info = {\n\t\t\tboundary: 0, // bytes\n\t\t\tstorage: 0 // bytes\n\t\t};\n\n\t\t// determine sizes according to STD140\n\n\t\tif ( typeof value === 'number' ) {\n\n\t\t\t// float/int\n\n\t\t\tinfo.boundary = 4;\n\t\t\tinfo.storage = 4;\n\n\t\t} else if ( value.isVector2 ) {\n\n\t\t\t// vec2\n\n\t\t\tinfo.boundary = 8;\n\t\t\tinfo.storage = 8;\n\n\t\t} else if ( value.isVector3 || value.isColor ) {\n\n\t\t\t// vec3\n\n\t\t\tinfo.boundary = 16;\n\t\t\tinfo.storage = 12; // evil: vec3 must start on a 16-byte boundary but it only consumes 12 bytes\n\n\t\t} else if ( value.isVector4 ) {\n\n\t\t\t// vec4\n\n\t\t\tinfo.boundary = 16;\n\t\t\tinfo.storage = 16;\n\n\t\t} else if ( value.isMatrix3 ) {\n\n\t\t\t// mat3 (in STD140 a 3x3 matrix is represented as 3x4)\n\n\t\t\tinfo.boundary = 48;\n\t\t\tinfo.storage = 48;\n\n\t\t} else if ( value.isMatrix4 ) {\n\n\t\t\t// mat4\n\n\t\t\tinfo.boundary = 64;\n\t\t\tinfo.storage = 64;\n\n\t\t} else if ( value.isTexture ) {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.' );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Unsupported uniform value type.', value );\n\n\t\t}\n\n\t\treturn info;\n\n\t}\n\n\tfunction onUniformsGroupsDispose( event ) {\n\n\t\tconst uniformsGroup = event.target;\n\n\t\tuniformsGroup.removeEventListener( 'dispose', onUniformsGroupsDispose );\n\n\t\tconst index = allocatedBindingPoints.indexOf( uniformsGroup.__bindingPointIndex );\n\t\tallocatedBindingPoints.splice( index, 1 );\n\n\t\tgl.deleteBuffer( buffers[ uniformsGroup.id ] );\n\n\t\tdelete buffers[ uniformsGroup.id ];\n\t\tdelete updateList[ uniformsGroup.id ];\n\n\t}\n\n\tfunction dispose() {\n\n\t\tfor ( const id in buffers ) {\n\n\t\t\tgl.deleteBuffer( buffers[ id ] );\n\n\t\t}\n\n\t\tallocatedBindingPoints = [];\n\t\tbuffers = {};\n\t\tupdateList = {};\n\n\t}\n\n\treturn {\n\n\t\tbind: bind,\n\t\tupdate: update,\n\n\t\tdispose: dispose\n\n\t};\n\n}\n\nfunction createCanvasElement() {\n\n\tconst canvas = createElementNS( 'canvas' );\n\tcanvas.style.display = 'block';\n\treturn canvas;\n\n}\n\nclass WebGLRenderer {\n\n\tconstructor( parameters = {} ) {\n\n\t\tconst {\n\t\t\tcanvas = createCanvasElement(),\n\t\t\tcontext = null,\n\t\t\tdepth = true,\n\t\t\tstencil = true,\n\t\t\talpha = false,\n\t\t\tantialias = false,\n\t\t\tpremultipliedAlpha = true,\n\t\t\tpreserveDrawingBuffer = false,\n\t\t\tpowerPreference = 'default',\n\t\t\tfailIfMajorPerformanceCaveat = false,\n\t\t} = parameters;\n\n\t\tthis.isWebGLRenderer = true;\n\n\t\tlet _alpha;\n\n\t\tif ( context !== null ) {\n\n\t\t\t_alpha = context.getContextAttributes().alpha;\n\n\t\t} else {\n\n\t\t\t_alpha = alpha;\n\n\t\t}\n\n\t\tconst uintClearColor = new Uint32Array( 4 );\n\t\tconst intClearColor = new Int32Array( 4 );\n\n\t\tlet currentRenderList = null;\n\t\tlet currentRenderState = null;\n\n\t\t// render() can be called from within a callback triggered by another render.\n\t\t// We track this so that the nested render call gets its list and state isolated from the parent render call.\n\n\t\tconst renderListStack = [];\n\t\tconst renderStateStack = [];\n\n\t\t// public properties\n\n\t\tthis.domElement = canvas;\n\n\t\t// Debug configuration container\n\t\tthis.debug = {\n\n\t\t\t/**\n\t\t\t * Enables error checking and reporting when shader programs are being compiled\n\t\t\t * @type {boolean}\n\t\t\t */\n\t\t\tcheckShaderErrors: true,\n\t\t\t/**\n\t\t\t * Callback for custom error reporting.\n\t\t\t * @type {?Function}\n\t\t\t */\n\t\t\tonShaderError: null\n\t\t};\n\n\t\t// clearing\n\n\t\tthis.autoClear = true;\n\t\tthis.autoClearColor = true;\n\t\tthis.autoClearDepth = true;\n\t\tthis.autoClearStencil = true;\n\n\t\t// scene graph\n\n\t\tthis.sortObjects = true;\n\n\t\t// user-defined clipping\n\n\t\tthis.clippingPlanes = [];\n\t\tthis.localClippingEnabled = false;\n\n\t\t// physically based shading\n\n\t\tthis.outputColorSpace = SRGBColorSpace;\n\n\t\t// physical lights\n\n\t\tthis.useLegacyLights = true;\n\n\t\t// tone mapping\n\n\t\tthis.toneMapping = NoToneMapping;\n\t\tthis.toneMappingExposure = 1.0;\n\n\t\t// internal properties\n\n\t\tconst _this = this;\n\n\t\tlet _isContextLost = false;\n\n\t\t// internal state cache\n\n\t\tlet _currentActiveCubeFace = 0;\n\t\tlet _currentActiveMipmapLevel = 0;\n\t\tlet _currentRenderTarget = null;\n\t\tlet _currentMaterialId = - 1;\n\n\t\tlet _currentCamera = null;\n\n\t\tconst _currentViewport = new Vector4();\n\t\tconst _currentScissor = new Vector4();\n\t\tlet _currentScissorTest = null;\n\n\t\tconst _currentClearColor = new Color( 0x000000 );\n\t\tlet _currentClearAlpha = 0;\n\n\t\t//\n\n\t\tlet _width = canvas.width;\n\t\tlet _height = canvas.height;\n\n\t\tlet _pixelRatio = 1;\n\t\tlet _opaqueSort = null;\n\t\tlet _transparentSort = null;\n\n\t\tconst _viewport = new Vector4( 0, 0, _width, _height );\n\t\tconst _scissor = new Vector4( 0, 0, _width, _height );\n\t\tlet _scissorTest = false;\n\n\t\t// frustum\n\n\t\tconst _frustum = new Frustum();\n\n\t\t// clipping\n\n\t\tlet _clippingEnabled = false;\n\t\tlet _localClippingEnabled = false;\n\n\t\t// transmission\n\n\t\tlet _transmissionRenderTarget = null;\n\n\t\t// camera matrices cache\n\n\t\tconst _projScreenMatrix = new Matrix4();\n\n\t\tconst _vector2 = new Vector2();\n\t\tconst _vector3 = new Vector3();\n\n\t\tconst _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };\n\n\t\tfunction getTargetPixelRatio() {\n\n\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\n\n\t\t}\n\n\t\t// initialize\n\n\t\tlet _gl = context;\n\n\t\tfunction getContext( contextNames, contextAttributes ) {\n\n\t\t\tfor ( let i = 0; i < contextNames.length; i ++ ) {\n\n\t\t\t\tconst contextName = contextNames[ i ];\n\t\t\t\tconst context = canvas.getContext( contextName, contextAttributes );\n\t\t\t\tif ( context !== null ) return context;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\ttry {\n\n\t\t\tconst contextAttributes = {\n\t\t\t\talpha: true,\n\t\t\t\tdepth,\n\t\t\t\tstencil,\n\t\t\t\tantialias,\n\t\t\t\tpremultipliedAlpha,\n\t\t\t\tpreserveDrawingBuffer,\n\t\t\t\tpowerPreference,\n\t\t\t\tfailIfMajorPerformanceCaveat,\n\t\t\t};\n\n\t\t\t// OffscreenCanvas does not have setAttribute, see #22811\n\t\t\tif ( 'setAttribute' in canvas ) canvas.setAttribute( 'data-engine', `three.js r${REVISION}` );\n\n\t\t\t// event listeners must be registered before WebGL context is created, see #12753\n\t\t\tcanvas.addEventListener( 'webglcontextlost', onContextLost, false );\n\t\t\tcanvas.addEventListener( 'webglcontextrestored', onContextRestore, false );\n\t\t\tcanvas.addEventListener( 'webglcontextcreationerror', onContextCreationError, false );\n\n\t\t\tif ( _gl === null ) {\n\n\t\t\t\tconst contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];\n\n\t\t\t\tif ( _this.isWebGL1Renderer === true ) {\n\n\t\t\t\t\tcontextNames.shift();\n\n\t\t\t\t}\n\n\t\t\t\t_gl = getContext( contextNames, contextAttributes );\n\n\t\t\t\tif ( _gl === null ) {\n\n\t\t\t\t\tif ( getContext( contextNames ) ) {\n\n\t\t\t\t\t\tthrow new Error( 'Error creating WebGL context with your selected attributes.' );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( 'Error creating WebGL context.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( typeof WebGLRenderingContext !== 'undefined' && _gl instanceof WebGLRenderingContext ) { // @deprecated, r153\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163.' );\n\n\t\t\t}\n\n\t\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\n\n\t\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t\t_gl.getShaderPrecisionFormat = function () {\n\n\t\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error.message );\n\t\t\tthrow error;\n\n\t\t}\n\n\t\tlet extensions, capabilities, state, info;\n\t\tlet properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;\n\t\tlet programCache, materials, renderLists, renderStates, clipping, shadowMap;\n\n\t\tlet background, morphtargets, bufferRenderer, indexedBufferRenderer;\n\n\t\tlet utils, bindingStates, uniformsGroups;\n\n\t\tfunction initGLContext() {\n\n\t\t\textensions = new WebGLExtensions( _gl );\n\n\t\t\tcapabilities = new WebGLCapabilities( _gl, extensions, parameters );\n\n\t\t\textensions.init( capabilities );\n\n\t\t\tutils = new WebGLUtils( _gl, extensions, capabilities );\n\n\t\t\tstate = new WebGLState( _gl, extensions, capabilities );\n\n\t\t\tinfo = new WebGLInfo( _gl );\n\t\t\tproperties = new WebGLProperties();\n\t\t\ttextures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );\n\t\t\tcubemaps = new WebGLCubeMaps( _this );\n\t\t\tcubeuvmaps = new WebGLCubeUVMaps( _this );\n\t\t\tattributes = new WebGLAttributes( _gl, capabilities );\n\t\t\tbindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );\n\t\t\tgeometries = new WebGLGeometries( _gl, attributes, info, bindingStates );\n\t\t\tobjects = new WebGLObjects( _gl, geometries, attributes, info );\n\t\t\tmorphtargets = new WebGLMorphtargets( _gl, capabilities, textures );\n\t\t\tclipping = new WebGLClipping( properties );\n\t\t\tprogramCache = new WebGLPrograms( _this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping );\n\t\t\tmaterials = new WebGLMaterials( _this, properties );\n\t\t\trenderLists = new WebGLRenderLists();\n\t\t\trenderStates = new WebGLRenderStates( extensions, capabilities );\n\t\t\tbackground = new WebGLBackground( _this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha );\n\t\t\tshadowMap = new WebGLShadowMap( _this, objects, capabilities );\n\t\t\tuniformsGroups = new WebGLUniformsGroups( _gl, info, capabilities, state );\n\n\t\t\tbufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );\n\t\t\tindexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );\n\n\t\t\tinfo.programs = programCache.programs;\n\n\t\t\t_this.capabilities = capabilities;\n\t\t\t_this.extensions = extensions;\n\t\t\t_this.properties = properties;\n\t\t\t_this.renderLists = renderLists;\n\t\t\t_this.shadowMap = shadowMap;\n\t\t\t_this.state = state;\n\t\t\t_this.info = info;\n\n\t\t}\n\n\t\tinitGLContext();\n\n\t\t// xr\n\n\t\tconst xr = new WebXRManager( _this, _gl );\n\n\t\tthis.xr = xr;\n\n\t\t// API\n\n\t\tthis.getContext = function () {\n\n\t\t\treturn _gl;\n\n\t\t};\n\n\t\tthis.getContextAttributes = function () {\n\n\t\t\treturn _gl.getContextAttributes();\n\n\t\t};\n\n\t\tthis.forceContextLoss = function () {\n\n\t\t\tconst extension = extensions.get( 'WEBGL_lose_context' );\n\t\t\tif ( extension ) extension.loseContext();\n\n\t\t};\n\n\t\tthis.forceContextRestore = function () {\n\n\t\t\tconst extension = extensions.get( 'WEBGL_lose_context' );\n\t\t\tif ( extension ) extension.restoreContext();\n\n\t\t};\n\n\t\tthis.getPixelRatio = function () {\n\n\t\t\treturn _pixelRatio;\n\n\t\t};\n\n\t\tthis.setPixelRatio = function ( value ) {\n\n\t\t\tif ( value === undefined ) return;\n\n\t\t\t_pixelRatio = value;\n\n\t\t\tthis.setSize( _width, _height, false );\n\n\t\t};\n\n\t\tthis.getSize = function ( target ) {\n\n\t\t\treturn target.set( _width, _height );\n\n\t\t};\n\n\t\tthis.setSize = function ( width, height, updateStyle = true ) {\n\n\t\t\tif ( xr.isPresenting ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Can\\'t change size while VR device is presenting.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\n\t\t\tcanvas.width = Math.floor( width * _pixelRatio );\n\t\t\tcanvas.height = Math.floor( height * _pixelRatio );\n\n\t\t\tif ( updateStyle === true ) {\n\n\t\t\t\tcanvas.style.width = width + 'px';\n\t\t\t\tcanvas.style.height = height + 'px';\n\n\t\t\t}\n\n\t\t\tthis.setViewport( 0, 0, width, height );\n\n\t\t};\n\n\t\tthis.getDrawingBufferSize = function ( target ) {\n\n\t\t\treturn target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();\n\n\t\t};\n\n\t\tthis.setDrawingBufferSize = function ( width, height, pixelRatio ) {\n\n\t\t\t_width = width;\n\t\t\t_height = height;\n\n\t\t\t_pixelRatio = pixelRatio;\n\n\t\t\tcanvas.width = Math.floor( width * pixelRatio );\n\t\t\tcanvas.height = Math.floor( height * pixelRatio );\n\n\t\t\tthis.setViewport( 0, 0, width, height );\n\n\t\t};\n\n\t\tthis.getCurrentViewport = function ( target ) {\n\n\t\t\treturn target.copy( _currentViewport );\n\n\t\t};\n\n\t\tthis.getViewport = function ( target ) {\n\n\t\t\treturn target.copy( _viewport );\n\n\t\t};\n\n\t\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t\tif ( x.isVector4 ) {\n\n\t\t\t\t_viewport.set( x.x, x.y, x.z, x.w );\n\n\t\t\t} else {\n\n\t\t\t\t_viewport.set( x, y, width, height );\n\n\t\t\t}\n\n\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );\n\n\t\t};\n\n\t\tthis.getScissor = function ( target ) {\n\n\t\t\treturn target.copy( _scissor );\n\n\t\t};\n\n\t\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\t\tif ( x.isVector4 ) {\n\n\t\t\t\t_scissor.set( x.x, x.y, x.z, x.w );\n\n\t\t\t} else {\n\n\t\t\t\t_scissor.set( x, y, width, height );\n\n\t\t\t}\n\n\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );\n\n\t\t};\n\n\t\tthis.getScissorTest = function () {\n\n\t\t\treturn _scissorTest;\n\n\t\t};\n\n\t\tthis.setScissorTest = function ( boolean ) {\n\n\t\t\tstate.setScissorTest( _scissorTest = boolean );\n\n\t\t};\n\n\t\tthis.setOpaqueSort = function ( method ) {\n\n\t\t\t_opaqueSort = method;\n\n\t\t};\n\n\t\tthis.setTransparentSort = function ( method ) {\n\n\t\t\t_transparentSort = method;\n\n\t\t};\n\n\t\t// Clearing\n\n\t\tthis.getClearColor = function ( target ) {\n\n\t\t\treturn target.copy( background.getClearColor() );\n\n\t\t};\n\n\t\tthis.setClearColor = function () {\n\n\t\t\tbackground.setClearColor.apply( background, arguments );\n\n\t\t};\n\n\t\tthis.getClearAlpha = function () {\n\n\t\t\treturn background.getClearAlpha();\n\n\t\t};\n\n\t\tthis.setClearAlpha = function () {\n\n\t\t\tbackground.setClearAlpha.apply( background, arguments );\n\n\t\t};\n\n\t\tthis.clear = function ( color = true, depth = true, stencil = true ) {\n\n\t\t\tlet bits = 0;\n\n\t\t\tif ( color ) {\n\n\t\t\t\t// check if we're trying to clear an integer target\n\t\t\t\tlet isIntegerFormat = false;\n\t\t\t\tif ( _currentRenderTarget !== null ) {\n\n\t\t\t\t\tconst targetFormat = _currentRenderTarget.texture.format;\n\t\t\t\t\tisIntegerFormat = targetFormat === RGBAIntegerFormat ||\n\t\t\t\t\t\ttargetFormat === RGIntegerFormat ||\n\t\t\t\t\t\ttargetFormat === RedIntegerFormat;\n\n\t\t\t\t}\n\n\t\t\t\t// use the appropriate clear functions to clear the target if it's a signed\n\t\t\t\t// or unsigned integer target\n\t\t\t\tif ( isIntegerFormat ) {\n\n\t\t\t\t\tconst targetType = _currentRenderTarget.texture.type;\n\t\t\t\t\tconst isUnsignedType = targetType === UnsignedByteType ||\n\t\t\t\t\t\ttargetType === UnsignedIntType ||\n\t\t\t\t\t\ttargetType === UnsignedShortType ||\n\t\t\t\t\t\ttargetType === UnsignedInt248Type ||\n\t\t\t\t\t\ttargetType === UnsignedShort4444Type ||\n\t\t\t\t\t\ttargetType === UnsignedShort5551Type;\n\n\t\t\t\t\tconst clearColor = background.getClearColor();\n\t\t\t\t\tconst a = background.getClearAlpha();\n\t\t\t\t\tconst r = clearColor.r;\n\t\t\t\t\tconst g = clearColor.g;\n\t\t\t\t\tconst b = clearColor.b;\n\n\t\t\t\t\tif ( isUnsignedType ) {\n\n\t\t\t\t\t\tuintClearColor[ 0 ] = r;\n\t\t\t\t\t\tuintClearColor[ 1 ] = g;\n\t\t\t\t\t\tuintClearColor[ 2 ] = b;\n\t\t\t\t\t\tuintClearColor[ 3 ] = a;\n\t\t\t\t\t\t_gl.clearBufferuiv( _gl.COLOR, 0, uintClearColor );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tintClearColor[ 0 ] = r;\n\t\t\t\t\t\tintClearColor[ 1 ] = g;\n\t\t\t\t\t\tintClearColor[ 2 ] = b;\n\t\t\t\t\t\tintClearColor[ 3 ] = a;\n\t\t\t\t\t\t_gl.clearBufferiv( _gl.COLOR, 0, intClearColor );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbits |= _gl.COLOR_BUFFER_BIT;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\t\tif ( stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t\t_gl.clear( bits );\n\n\t\t};\n\n\t\tthis.clearColor = function () {\n\n\t\t\tthis.clear( true, false, false );\n\n\t\t};\n\n\t\tthis.clearDepth = function () {\n\n\t\t\tthis.clear( false, true, false );\n\n\t\t};\n\n\t\tthis.clearStencil = function () {\n\n\t\t\tthis.clear( false, false, true );\n\n\t\t};\n\n\t\t//\n\n\t\tthis.dispose = function () {\n\n\t\t\tcanvas.removeEventListener( 'webglcontextlost', onContextLost, false );\n\t\t\tcanvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );\n\t\t\tcanvas.removeEventListener( 'webglcontextcreationerror', onContextCreationError, false );\n\n\t\t\trenderLists.dispose();\n\t\t\trenderStates.dispose();\n\t\t\tproperties.dispose();\n\t\t\tcubemaps.dispose();\n\t\t\tcubeuvmaps.dispose();\n\t\t\tobjects.dispose();\n\t\t\tbindingStates.dispose();\n\t\t\tuniformsGroups.dispose();\n\t\t\tprogramCache.dispose();\n\n\t\t\txr.dispose();\n\n\t\t\txr.removeEventListener( 'sessionstart', onXRSessionStart );\n\t\t\txr.removeEventListener( 'sessionend', onXRSessionEnd );\n\n\t\t\tif ( _transmissionRenderTarget ) {\n\n\t\t\t\t_transmissionRenderTarget.dispose();\n\t\t\t\t_transmissionRenderTarget = null;\n\n\t\t\t}\n\n\t\t\tanimation.stop();\n\n\t\t};\n\n\t\t// Events\n\n\t\tfunction onContextLost( event ) {\n\n\t\t\tevent.preventDefault();\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Context Lost.' );\n\n\t\t\t_isContextLost = true;\n\n\t\t}\n\n\t\tfunction onContextRestore( /* event */ ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Context Restored.' );\n\n\t\t\t_isContextLost = false;\n\n\t\t\tconst infoAutoReset = info.autoReset;\n\t\t\tconst shadowMapEnabled = shadowMap.enabled;\n\t\t\tconst shadowMapAutoUpdate = shadowMap.autoUpdate;\n\t\t\tconst shadowMapNeedsUpdate = shadowMap.needsUpdate;\n\t\t\tconst shadowMapType = shadowMap.type;\n\n\t\t\tinitGLContext();\n\n\t\t\tinfo.autoReset = infoAutoReset;\n\t\t\tshadowMap.enabled = shadowMapEnabled;\n\t\t\tshadowMap.autoUpdate = shadowMapAutoUpdate;\n\t\t\tshadowMap.needsUpdate = shadowMapNeedsUpdate;\n\t\t\tshadowMap.type = shadowMapType;\n\n\t\t}\n\n\t\tfunction onContextCreationError( event ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage );\n\n\t\t}\n\n\t\tfunction onMaterialDispose( event ) {\n\n\t\t\tconst material = event.target;\n\n\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\t\tdeallocateMaterial( material );\n\n\t\t}\n\n\t\t// Buffer deallocation\n\n\t\tfunction deallocateMaterial( material ) {\n\n\t\t\treleaseMaterialProgramReferences( material );\n\n\t\t\tproperties.remove( material );\n\n\t\t}\n\n\n\t\tfunction releaseMaterialProgramReferences( material ) {\n\n\t\t\tconst programs = properties.get( material ).programs;\n\n\t\t\tif ( programs !== undefined ) {\n\n\t\t\t\tprograms.forEach( function ( program ) {\n\n\t\t\t\t\tprogramCache.releaseProgram( program );\n\n\t\t\t\t} );\n\n\t\t\t\tif ( material.isShaderMaterial ) {\n\n\t\t\t\t\tprogramCache.releaseShaderCache( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Buffer rendering\n\n\t\tthis.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {\n\n\t\t\tif ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)\n\n\t\t\tconst frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\n\n\t\t\tconst program = setProgram( camera, scene, geometry, material, object );\n\n\t\t\tstate.setMaterial( material, frontFaceCW );\n\n\t\t\t//\n\n\t\t\tlet index = geometry.index;\n\t\t\tlet rangeFactor = 1;\n\n\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\tindex = geometries.getWireframeAttribute( geometry );\n\t\t\t\trangeFactor = 2;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst drawRange = geometry.drawRange;\n\t\t\tconst position = geometry.attributes.position;\n\n\t\t\tlet drawStart = drawRange.start * rangeFactor;\n\t\t\tlet drawEnd = ( drawRange.start + drawRange.count ) * rangeFactor;\n\n\t\t\tif ( group !== null ) {\n\n\t\t\t\tdrawStart = Math.max( drawStart, group.start * rangeFactor );\n\t\t\t\tdrawEnd = Math.min( drawEnd, ( group.start + group.count ) * rangeFactor );\n\n\t\t\t}\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tdrawStart = Math.max( drawStart, 0 );\n\t\t\t\tdrawEnd = Math.min( drawEnd, index.count );\n\n\t\t\t} else if ( position !== undefined && position !== null ) {\n\n\t\t\t\tdrawStart = Math.max( drawStart, 0 );\n\t\t\t\tdrawEnd = Math.min( drawEnd, position.count );\n\n\t\t\t}\n\n\t\t\tconst drawCount = drawEnd - drawStart;\n\n\t\t\tif ( drawCount < 0 || drawCount === Infinity ) return;\n\n\t\t\t//\n\n\t\t\tbindingStates.setup( object, material, program, geometry, index );\n\n\t\t\tlet attribute;\n\t\t\tlet renderer = bufferRenderer;\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\tattribute = attributes.get( index );\n\n\t\t\t\trenderer = indexedBufferRenderer;\n\t\t\t\trenderer.setIndex( attribute );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tif ( material.wireframe === true ) {\n\n\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isLine ) {\n\n\t\t\t\tlet lineWidth = material.linewidth;\n\n\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\n\n\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\n\n\t\t\t\tif ( object.isLineSegments ) {\n\n\t\t\t\t\trenderer.setMode( _gl.LINES );\n\n\t\t\t\t} else if ( object.isLineLoop ) {\n\n\t\t\t\t\trenderer.setMode( _gl.LINE_LOOP );\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object.isPoints ) {\n\n\t\t\t\trenderer.setMode( _gl.POINTS );\n\n\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\trenderer.setMode( _gl.TRIANGLES );\n\n\t\t\t}\n\n\t\t\tif ( object.isInstancedMesh ) {\n\n\t\t\t\trenderer.renderInstances( drawStart, drawCount, object.count );\n\n\t\t\t} else if ( geometry.isInstancedBufferGeometry ) {\n\n\t\t\t\tconst maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;\n\t\t\t\tconst instanceCount = Math.min( geometry.instanceCount, maxInstanceCount );\n\n\t\t\t\trenderer.renderInstances( drawStart, drawCount, instanceCount );\n\n\t\t\t} else {\n\n\t\t\t\trenderer.render( drawStart, drawCount );\n\n\t\t\t}\n\n\t\t};\n\n\t\t// Compile\n\n\t\tthis.compile = function ( scene, camera ) {\n\n\t\t\tfunction prepare( material, scene, object ) {\n\n\t\t\t\tif ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {\n\n\t\t\t\t\tmaterial.side = BackSide;\n\t\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t\t\tmaterial.side = FrontSide;\n\t\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t\t\tmaterial.side = DoubleSide;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tgetProgram( material, scene, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcurrentRenderState = renderStates.get( scene );\n\t\t\tcurrentRenderState.init();\n\n\t\t\trenderStateStack.push( currentRenderState );\n\n\t\t\tscene.traverseVisible( function ( object ) {\n\n\t\t\t\tif ( object.isLight && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tcurrentRenderState.setupLights( _this.useLegacyLights );\n\n\t\t\tscene.traverse( function ( object ) {\n\n\t\t\t\tconst material = object.material;\n\n\t\t\t\tif ( material ) {\n\n\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\tfor ( let i = 0; i < material.length; i ++ ) {\n\n\t\t\t\t\t\t\tconst material2 = material[ i ];\n\n\t\t\t\t\t\t\tprepare( material2, scene, object );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tprepare( material, scene, object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\trenderStateStack.pop();\n\t\t\tcurrentRenderState = null;\n\n\t\t};\n\n\t\t// Animation Loop\n\n\t\tlet onAnimationFrameCallback = null;\n\n\t\tfunction onAnimationFrame( time ) {\n\n\t\t\tif ( onAnimationFrameCallback ) onAnimationFrameCallback( time );\n\n\t\t}\n\n\t\tfunction onXRSessionStart() {\n\n\t\t\tanimation.stop();\n\n\t\t}\n\n\t\tfunction onXRSessionEnd() {\n\n\t\t\tanimation.start();\n\n\t\t}\n\n\t\tconst animation = new WebGLAnimation();\n\t\tanimation.setAnimationLoop( onAnimationFrame );\n\n\t\tif ( typeof self !== 'undefined' ) animation.setContext( self );\n\n\t\tthis.setAnimationLoop = function ( callback ) {\n\n\t\t\tonAnimationFrameCallback = callback;\n\t\t\txr.setAnimationLoop( callback );\n\n\t\t\t( callback === null ) ? animation.stop() : animation.start();\n\n\t\t};\n\n\t\txr.addEventListener( 'sessionstart', onXRSessionStart );\n\t\txr.addEventListener( 'sessionend', onXRSessionEnd );\n\n\t\t// Rendering\n\n\t\tthis.render = function ( scene, camera ) {\n\n\t\t\tif ( camera !== undefined && camera.isCamera !== true ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( _isContextLost === true ) return;\n\n\t\t\t// update scene graph\n\n\t\t\tif ( scene.matrixWorldAutoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t\t// update camera matrices and frustum\n\n\t\t\tif ( camera.parent === null && camera.matrixWorldAutoUpdate === true ) camera.updateMatrixWorld();\n\n\t\t\tif ( xr.enabled === true && xr.isPresenting === true ) {\n\n\t\t\t\tif ( xr.cameraAutoUpdate === true ) xr.updateCamera( camera );\n\n\t\t\t\tcamera = xr.getCamera(); // use XR camera for rendering\n\n\t\t\t}\n\n\t\t\t//\n\t\t\tif ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, _currentRenderTarget );\n\n\t\t\tcurrentRenderState = renderStates.get( scene, renderStateStack.length );\n\t\t\tcurrentRenderState.init();\n\n\t\t\trenderStateStack.push( currentRenderState );\n\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t\t_frustum.setFromProjectionMatrix( _projScreenMatrix );\n\n\t\t\t_localClippingEnabled = this.localClippingEnabled;\n\t\t\t_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled );\n\n\t\t\tcurrentRenderList = renderLists.get( scene, renderListStack.length );\n\t\t\tcurrentRenderList.init();\n\n\t\t\trenderListStack.push( currentRenderList );\n\n\t\t\tprojectObject( scene, camera, 0, _this.sortObjects );\n\n\t\t\tcurrentRenderList.finish();\n\n\t\t\tif ( _this.sortObjects === true ) {\n\n\t\t\t\tcurrentRenderList.sort( _opaqueSort, _transparentSort );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tthis.info.render.frame ++;\n\n\t\t\tif ( _clippingEnabled === true ) clipping.beginShadows();\n\n\t\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\t\tshadowMap.render( shadowsArray, scene, camera );\n\n\t\t\tif ( _clippingEnabled === true ) clipping.endShadows();\n\n\t\t\t//\n\n\t\t\tif ( this.info.autoReset === true ) this.info.reset();\n\n\n\t\t\t//\n\n\t\t\tbackground.render( currentRenderList, scene );\n\n\t\t\t// render scene\n\n\t\t\tcurrentRenderState.setupLights( _this.useLegacyLights );\n\n\t\t\tif ( camera.isArrayCamera ) {\n\n\t\t\t\tconst cameras = camera.cameras;\n\n\t\t\t\tfor ( let i = 0, l = cameras.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst camera2 = cameras[ i ];\n\n\t\t\t\t\trenderScene( currentRenderList, scene, camera2, camera2.viewport );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\trenderScene( currentRenderList, scene, camera );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( _currentRenderTarget !== null ) {\n\n\t\t\t\t// resolve multisample renderbuffers to a single-sample texture if necessary\n\n\t\t\t\ttextures.updateMultisampleRenderTarget( _currentRenderTarget );\n\n\t\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\t\t\ttextures.updateRenderTargetMipmap( _currentRenderTarget );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );\n\n\t\t\t// _gl.finish();\n\n\t\t\tbindingStates.resetDefaultState();\n\t\t\t_currentMaterialId = - 1;\n\t\t\t_currentCamera = null;\n\n\t\t\trenderStateStack.pop();\n\n\t\t\tif ( renderStateStack.length > 0 ) {\n\n\t\t\t\tcurrentRenderState = renderStateStack[ renderStateStack.length - 1 ];\n\n\t\t\t} else {\n\n\t\t\t\tcurrentRenderState = null;\n\n\t\t\t}\n\n\t\t\trenderListStack.pop();\n\n\t\t\tif ( renderListStack.length > 0 ) {\n\n\t\t\t\tcurrentRenderList = renderListStack[ renderListStack.length - 1 ];\n\n\t\t\t} else {\n\n\t\t\t\tcurrentRenderList = null;\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction projectObject( object, camera, groupOrder, sortObjects ) {\n\n\t\t\tif ( object.visible === false ) return;\n\n\t\t\tconst visible = object.layers.test( camera.layers );\n\n\t\t\tif ( visible ) {\n\n\t\t\t\tif ( object.isGroup ) {\n\n\t\t\t\t\tgroupOrder = object.renderOrder;\n\n\t\t\t\t} else if ( object.isLOD ) {\n\n\t\t\t\t\tif ( object.autoUpdate === true ) object.update( camera );\n\n\t\t\t\t} else if ( object.isLight ) {\n\n\t\t\t\t\tcurrentRenderState.pushLight( object );\n\n\t\t\t\t\tif ( object.castShadow ) {\n\n\t\t\t\t\t\tcurrentRenderState.pushShadow( object );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isSprite ) {\n\n\t\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\n\n\t\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld )\n\t\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\t\tif ( material.visible ) {\n\n\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\t\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\t\tconst geometry = objects.update( object );\n\t\t\t\t\t\tconst material = object.material;\n\n\t\t\t\t\t\tif ( sortObjects ) {\n\n\t\t\t\t\t\t\tif ( object.boundingSphere !== undefined ) {\n\n\t\t\t\t\t\t\t\tif ( object.boundingSphere === null ) object.computeBoundingSphere();\n\t\t\t\t\t\t\t\t_vector3.copy( object.boundingSphere.center );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\t\t\t\t\t\t\t\t_vector3.copy( geometry.boundingSphere.center );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_vector3\n\t\t\t\t\t\t\t\t.applyMatrix4( object.matrixWorld )\n\t\t\t\t\t\t\t\t.applyMatrix4( _projScreenMatrix );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( Array.isArray( material ) ) {\n\n\t\t\t\t\t\t\tconst groups = geometry.groups;\n\n\t\t\t\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tconst group = groups[ i ];\n\t\t\t\t\t\t\t\tconst groupMaterial = material[ group.materialIndex ];\n\n\t\t\t\t\t\t\t\tif ( groupMaterial && groupMaterial.visible ) {\n\n\t\t\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( material.visible ) {\n\n\t\t\t\t\t\t\tcurrentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst children = object.children;\n\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tprojectObject( children[ i ], camera, groupOrder, sortObjects );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderScene( currentRenderList, scene, camera, viewport ) {\n\n\t\t\tconst opaqueObjects = currentRenderList.opaque;\n\t\t\tconst transmissiveObjects = currentRenderList.transmissive;\n\t\t\tconst transparentObjects = currentRenderList.transparent;\n\n\t\t\tcurrentRenderState.setupLightsView( camera );\n\n\t\t\tif ( _clippingEnabled === true ) clipping.setGlobalState( _this.clippingPlanes, camera );\n\n\t\t\tif ( transmissiveObjects.length > 0 ) renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera );\n\n\t\t\tif ( viewport ) state.viewport( _currentViewport.copy( viewport ) );\n\n\t\t\tif ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );\n\t\t\tif ( transmissiveObjects.length > 0 ) renderObjects( transmissiveObjects, scene, camera );\n\t\t\tif ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );\n\n\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\t\tstate.buffers.depth.setTest( true );\n\t\t\tstate.buffers.depth.setMask( true );\n\t\t\tstate.buffers.color.setMask( true );\n\n\t\t\tstate.setPolygonOffset( false );\n\n\t\t}\n\n\t\tfunction renderTransmissionPass( opaqueObjects, transmissiveObjects, scene, camera ) {\n\n\t\t\tconst isWebGL2 = capabilities.isWebGL2;\n\n\t\t\tif ( _transmissionRenderTarget === null ) {\n\n\t\t\t\t_transmissionRenderTarget = new WebGLRenderTarget( 1, 1, {\n\t\t\t\t\tgenerateMipmaps: true,\n\t\t\t\t\ttype: extensions.has( 'EXT_color_buffer_half_float' ) ? HalfFloatType : UnsignedByteType,\n\t\t\t\t\tminFilter: LinearMipmapLinearFilter,\n\t\t\t\t\tsamples: ( isWebGL2 ) ? 4 : 0\n\t\t\t\t} );\n\n\t\t\t\t// debug\n\n\t\t\t\t/*\n\t\t\t\tconst geometry = new PlaneGeometry();\n\t\t\t\tconst material = new MeshBasicMaterial( { map: _transmissionRenderTarget.texture } );\n\n\t\t\t\tconst mesh = new Mesh( geometry, material );\n\t\t\t\tscene.add( mesh );\n\t\t\t\t*/\n\n\t\t\t}\n\n\t\t\t_this.getDrawingBufferSize( _vector2 );\n\n\t\t\tif ( isWebGL2 ) {\n\n\t\t\t\t_transmissionRenderTarget.setSize( _vector2.x, _vector2.y );\n\n\t\t\t} else {\n\n\t\t\t\t_transmissionRenderTarget.setSize( floorPowerOfTwo( _vector2.x ), floorPowerOfTwo( _vector2.y ) );\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tconst currentRenderTarget = _this.getRenderTarget();\n\t\t\t_this.setRenderTarget( _transmissionRenderTarget );\n\n\t\t\t_this.getClearColor( _currentClearColor );\n\t\t\t_currentClearAlpha = _this.getClearAlpha();\n\t\t\tif ( _currentClearAlpha < 1 ) _this.setClearColor( 0xffffff, 0.5 );\n\n\t\t\t_this.clear();\n\n\t\t\t// Turn off the features which can affect the frag color for opaque objects pass.\n\t\t\t// Otherwise they are applied twice in opaque objects pass and transmission objects pass.\n\t\t\tconst currentToneMapping = _this.toneMapping;\n\t\t\t_this.toneMapping = NoToneMapping;\n\n\t\t\trenderObjects( opaqueObjects, scene, camera );\n\n\t\t\ttextures.updateMultisampleRenderTarget( _transmissionRenderTarget );\n\t\t\ttextures.updateRenderTargetMipmap( _transmissionRenderTarget );\n\n\t\t\tlet renderTargetNeedsUpdate = false;\n\n\t\t\tfor ( let i = 0, l = transmissiveObjects.length; i < l; i ++ ) {\n\n\t\t\t\tconst renderItem = transmissiveObjects[ i ];\n\n\t\t\t\tconst object = renderItem.object;\n\t\t\t\tconst geometry = renderItem.geometry;\n\t\t\t\tconst material = renderItem.material;\n\t\t\t\tconst group = renderItem.group;\n\n\t\t\t\tif ( material.side === DoubleSide && object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\tconst currentSide = material.side;\n\n\t\t\t\t\tmaterial.side = BackSide;\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t\trenderObject( object, scene, camera, geometry, material, group );\n\n\t\t\t\t\tmaterial.side = currentSide;\n\t\t\t\t\tmaterial.needsUpdate = true;\n\n\t\t\t\t\trenderTargetNeedsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( renderTargetNeedsUpdate === true ) {\n\n\t\t\t\ttextures.updateMultisampleRenderTarget( _transmissionRenderTarget );\n\t\t\t\ttextures.updateRenderTargetMipmap( _transmissionRenderTarget );\n\n\t\t\t}\n\n\t\t\t_this.setRenderTarget( currentRenderTarget );\n\n\t\t\t_this.setClearColor( _currentClearColor, _currentClearAlpha );\n\n\t\t\t_this.toneMapping = currentToneMapping;\n\n\t\t}\n\n\t\tfunction renderObjects( renderList, scene, camera ) {\n\n\t\t\tconst overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n\n\t\t\tfor ( let i = 0, l = renderList.length; i < l; i ++ ) {\n\n\t\t\t\tconst renderItem = renderList[ i ];\n\n\t\t\t\tconst object = renderItem.object;\n\t\t\t\tconst geometry = renderItem.geometry;\n\t\t\t\tconst material = overrideMaterial === null ? renderItem.material : overrideMaterial;\n\t\t\t\tconst group = renderItem.group;\n\n\t\t\t\tif ( object.layers.test( camera.layers ) ) {\n\n\t\t\t\t\trenderObject( object, scene, camera, geometry, material, group );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction renderObject( object, scene, camera, geometry, material, group ) {\n\n\t\t\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\n\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\n\n\t\t\tmaterial.onBeforeRender( _this, scene, camera, geometry, object, group );\n\n\t\t\tif ( material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false ) {\n\n\t\t\t\tmaterial.side = BackSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\t\tmaterial.side = FrontSide;\n\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\t\tmaterial.side = DoubleSide;\n\n\t\t\t} else {\n\n\t\t\t\t_this.renderBufferDirect( camera, scene, geometry, material, object, group );\n\n\t\t\t}\n\n\t\t\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\n\n\t\t}\n\n\t\tfunction getProgram( material, scene, object ) {\n\n\t\t\tif ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\t\tconst materialProperties = properties.get( material );\n\n\t\t\tconst lights = currentRenderState.state.lights;\n\t\t\tconst shadowsArray = currentRenderState.state.shadowsArray;\n\n\t\t\tconst lightsStateVersion = lights.state.version;\n\n\t\t\tconst parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );\n\t\t\tconst programCacheKey = programCache.getProgramCacheKey( parameters );\n\n\t\t\tlet programs = materialProperties.programs;\n\n\t\t\t// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change\n\n\t\t\tmaterialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\t\tmaterialProperties.fog = scene.fog;\n\t\t\tmaterialProperties.envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || materialProperties.environment );\n\n\t\t\tif ( programs === undefined ) {\n\n\t\t\t\t// new material\n\n\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\t\t\tprograms = new Map();\n\t\t\t\tmaterialProperties.programs = programs;\n\n\t\t\t}\n\n\t\t\tlet program = programs.get( programCacheKey );\n\n\t\t\tif ( program !== undefined ) {\n\n\t\t\t\t// early out if program and light state is identical\n\n\t\t\t\tif ( materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion ) {\n\n\t\t\t\t\tupdateCommonMaterialProperties( material, parameters );\n\n\t\t\t\t\treturn program;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tparameters.uniforms = programCache.getUniforms( material );\n\n\t\t\t\tmaterial.onBuild( object, parameters, _this );\n\n\t\t\t\tmaterial.onBeforeCompile( parameters, _this );\n\n\t\t\t\tprogram = programCache.acquireProgram( parameters, programCacheKey );\n\t\t\t\tprograms.set( programCacheKey, program );\n\n\t\t\t\tmaterialProperties.uniforms = parameters.uniforms;\n\n\t\t\t}\n\n\t\t\tconst uniforms = materialProperties.uniforms;\n\n\t\t\tif ( ( ! material.isShaderMaterial && ! material.isRawShaderMaterial ) || material.clipping === true ) {\n\n\t\t\t\tuniforms.clippingPlanes = clipping.uniform;\n\n\t\t\t}\n\n\t\t\tupdateCommonMaterialProperties( material, parameters );\n\n\t\t\t// store the light setup it was created for\n\n\t\t\tmaterialProperties.needsLights = materialNeedsLights( material );\n\t\t\tmaterialProperties.lightsStateVersion = lightsStateVersion;\n\n\t\t\tif ( materialProperties.needsLights ) {\n\n\t\t\t\t// wire up the material to this renderer's lighting state\n\n\t\t\t\tuniforms.ambientLightColor.value = lights.state.ambient;\n\t\t\t\tuniforms.lightProbe.value = lights.state.probe;\n\t\t\t\tuniforms.directionalLights.value = lights.state.directional;\n\t\t\t\tuniforms.directionalLightShadows.value = lights.state.directionalShadow;\n\t\t\t\tuniforms.spotLights.value = lights.state.spot;\n\t\t\t\tuniforms.spotLightShadows.value = lights.state.spotShadow;\n\t\t\t\tuniforms.rectAreaLights.value = lights.state.rectArea;\n\t\t\t\tuniforms.ltc_1.value = lights.state.rectAreaLTC1;\n\t\t\t\tuniforms.ltc_2.value = lights.state.rectAreaLTC2;\n\t\t\t\tuniforms.pointLights.value = lights.state.point;\n\t\t\t\tuniforms.pointLightShadows.value = lights.state.pointShadow;\n\t\t\t\tuniforms.hemisphereLights.value = lights.state.hemi;\n\n\t\t\t\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n\t\t\t\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n\t\t\t\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\n\t\t\t\tuniforms.spotLightMatrix.value = lights.state.spotLightMatrix;\n\t\t\t\tuniforms.spotLightMap.value = lights.state.spotLightMap;\n\t\t\t\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\n\t\t\t\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\n\t\t\t\t// TODO (abelnation): add area lights shadow info to uniforms\n\n\t\t\t}\n\n\t\t\tconst progUniforms = program.getUniforms();\n\t\t\tconst uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\n\n\t\t\tmaterialProperties.currentProgram = program;\n\t\t\tmaterialProperties.uniformsList = uniformsList;\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\tfunction updateCommonMaterialProperties( material, parameters ) {\n\n\t\t\tconst materialProperties = properties.get( material );\n\n\t\t\tmaterialProperties.outputColorSpace = parameters.outputColorSpace;\n\t\t\tmaterialProperties.instancing = parameters.instancing;\n\t\t\tmaterialProperties.skinning = parameters.skinning;\n\t\t\tmaterialProperties.morphTargets = parameters.morphTargets;\n\t\t\tmaterialProperties.morphNormals = parameters.morphNormals;\n\t\t\tmaterialProperties.morphColors = parameters.morphColors;\n\t\t\tmaterialProperties.morphTargetsCount = parameters.morphTargetsCount;\n\t\t\tmaterialProperties.numClippingPlanes = parameters.numClippingPlanes;\n\t\t\tmaterialProperties.numIntersection = parameters.numClipIntersection;\n\t\t\tmaterialProperties.vertexAlphas = parameters.vertexAlphas;\n\t\t\tmaterialProperties.vertexTangents = parameters.vertexTangents;\n\t\t\tmaterialProperties.toneMapping = parameters.toneMapping;\n\n\t\t}\n\n\t\tfunction setProgram( camera, scene, geometry, material, object ) {\n\n\t\t\tif ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...\n\n\t\t\ttextures.resetTextureUnits();\n\n\t\t\tconst fog = scene.fog;\n\t\t\tconst environment = material.isMeshStandardMaterial ? scene.environment : null;\n\t\t\tconst colorSpace = ( _currentRenderTarget === null ) ? _this.outputColorSpace : ( _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace );\n\t\t\tconst envMap = ( material.isMeshStandardMaterial ? cubeuvmaps : cubemaps ).get( material.envMap || environment );\n\t\t\tconst vertexAlphas = material.vertexColors === true && !! geometry.attributes.color && geometry.attributes.color.itemSize === 4;\n\t\t\tconst vertexTangents = !! geometry.attributes.tangent && ( !! material.normalMap || material.anisotropy > 0 );\n\t\t\tconst morphTargets = !! geometry.morphAttributes.position;\n\t\t\tconst morphNormals = !! geometry.morphAttributes.normal;\n\t\t\tconst morphColors = !! geometry.morphAttributes.color;\n\t\t\tconst toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;\n\n\t\t\tconst morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n\t\t\tconst morphTargetsCount = ( morphAttribute !== undefined ) ? morphAttribute.length : 0;\n\n\t\t\tconst materialProperties = properties.get( material );\n\t\t\tconst lights = currentRenderState.state.lights;\n\n\t\t\tif ( _clippingEnabled === true ) {\n\n\t\t\t\tif ( _localClippingEnabled === true || camera !== _currentCamera ) {\n\n\t\t\t\t\tconst useCache =\n\t\t\t\t\t\tcamera === _currentCamera &&\n\t\t\t\t\t\tmaterial.id === _currentMaterialId;\n\n\t\t\t\t\t// we might want to call this function with some ClippingGroup\n\t\t\t\t\t// object instead of the material, once it becomes feasible\n\t\t\t\t\t// (#8465, #8379)\n\t\t\t\t\tclipping.setState( material, camera, useCache );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet needsProgramChange = false;\n\n\t\t\tif ( material.version === materialProperties.__version ) {\n\n\t\t\t\tif ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.outputColorSpace !== colorSpace ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isInstancedMesh && materialProperties.instancing === false ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( ! object.isInstancedMesh && materialProperties.instancing === true ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( object.isSkinnedMesh && materialProperties.skinning === false ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( ! object.isSkinnedMesh && materialProperties.skinning === true ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.envMap !== envMap ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( material.fog === true && materialProperties.fog !== fog ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.numClippingPlanes !== undefined &&\n\t\t\t\t\t( materialProperties.numClippingPlanes !== clipping.numPlanes ||\n\t\t\t\t\tmaterialProperties.numIntersection !== clipping.numIntersection ) ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.vertexAlphas !== vertexAlphas ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.vertexTangents !== vertexTangents ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.morphTargets !== morphTargets ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.morphNormals !== morphNormals ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.morphColors !== morphColors ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( materialProperties.toneMapping !== toneMapping ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t} else if ( capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount ) {\n\n\t\t\t\t\tneedsProgramChange = true;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tneedsProgramChange = true;\n\t\t\t\tmaterialProperties.__version = material.version;\n\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tlet program = materialProperties.currentProgram;\n\n\t\t\tif ( needsProgramChange === true ) {\n\n\t\t\t\tprogram = getProgram( material, scene, object );\n\n\t\t\t}\n\n\t\t\tlet refreshProgram = false;\n\t\t\tlet refreshMaterial = false;\n\t\t\tlet refreshLights = false;\n\n\t\t\tconst p_uniforms = program.getUniforms(),\n\t\t\t\tm_uniforms = materialProperties.uniforms;\n\n\t\t\tif ( state.useProgram( program.program ) ) {\n\n\t\t\t\trefreshProgram = true;\n\t\t\t\trefreshMaterial = true;\n\t\t\t\trefreshLights = true;\n\n\t\t\t}\n\n\t\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t\t_currentMaterialId = material.id;\n\n\t\t\t\trefreshMaterial = true;\n\n\t\t\t}\n\n\t\t\tif ( refreshProgram || _currentCamera !== camera ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );\n\n\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\n\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( _currentCamera !== camera ) {\n\n\t\t\t\t\t_currentCamera = camera;\n\n\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\n\t\t\t\t\t// now, in case this material supports lights - or later, when\n\t\t\t\t\t// the next material that does gets activated:\n\n\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\n\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\n\n\t\t\t\t}\n\n\t\t\t\t// load material specific uniforms\n\t\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\t\tif ( material.isShaderMaterial ||\n\t\t\t\t\tmaterial.isMeshPhongMaterial ||\n\t\t\t\t\tmaterial.isMeshToonMaterial ||\n\t\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\t\tmaterial.envMap ) {\n\n\t\t\t\t\tconst uCamPos = p_uniforms.map.cameraPosition;\n\n\t\t\t\t\tif ( uCamPos !== undefined ) {\n\n\t\t\t\t\t\tuCamPos.setValue( _gl,\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\t\tmaterial.isMeshToonMaterial ||\n\t\t\t\t\tmaterial.isMeshLambertMaterial ||\n\t\t\t\t\tmaterial.isMeshBasicMaterial ||\n\t\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\t\tmaterial.isShaderMaterial ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );\n\n\t\t\t\t}\n\n\t\t\t\tif ( material.isMeshPhongMaterial ||\n\t\t\t\t\tmaterial.isMeshToonMaterial ||\n\t\t\t\t\tmaterial.isMeshLambertMaterial ||\n\t\t\t\t\tmaterial.isMeshBasicMaterial ||\n\t\t\t\t\tmaterial.isMeshStandardMaterial ||\n\t\t\t\t\tmaterial.isShaderMaterial ||\n\t\t\t\t\tmaterial.isShadowMaterial ||\n\t\t\t\t\tobject.isSkinnedMesh ) {\n\n\t\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// skinning and morph target uniforms must be set even if material didn't change\n\t\t\t// auto-setting of texture unit for bone and morph texture must go before other textures\n\t\t\t// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures\n\n\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\n\n\t\t\t\tconst skeleton = object.skeleton;\n\n\t\t\t\tif ( skeleton ) {\n\n\t\t\t\t\tif ( capabilities.floatVertexTextures ) {\n\n\t\t\t\t\t\tif ( skeleton.boneTexture === null ) skeleton.computeBoneTexture();\n\n\t\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );\n\t\t\t\t\t\tp_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst morphAttributes = geometry.morphAttributes;\n\n\t\t\tif ( morphAttributes.position !== undefined || morphAttributes.normal !== undefined || ( morphAttributes.color !== undefined && capabilities.isWebGL2 === true ) ) {\n\n\t\t\t\tmorphtargets.update( object, geometry, program );\n\n\t\t\t}\n\n\t\t\tif ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {\n\n\t\t\t\tmaterialProperties.receiveShadow = object.receiveShadow;\n\t\t\t\tp_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );\n\n\t\t\t}\n\n\t\t\t// https://github.com/mrdoob/three.js/pull/24467#issuecomment-1209031512\n\n\t\t\tif ( material.isMeshGouraudMaterial && material.envMap !== null ) {\n\n\t\t\t\tm_uniforms.envMap.value = envMap;\n\n\t\t\t\tm_uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap.isRenderTargetTexture === false ) ? - 1 : 1;\n\n\t\t\t}\n\n\t\t\tif ( refreshMaterial ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );\n\n\t\t\t\tif ( materialProperties.needsLights ) {\n\n\t\t\t\t\t// the current material requires lighting info\n\n\t\t\t\t\t// note: all lighting uniforms are always set correctly\n\t\t\t\t\t// they simply reference the renderer's state for their\n\t\t\t\t\t// values\n\t\t\t\t\t//\n\t\t\t\t\t// use the current material's .needsUpdate flags to set\n\t\t\t\t\t// the GL state when required\n\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\n\n\t\t\t\t}\n\n\t\t\t\t// refresh uniforms common to several materials\n\n\t\t\t\tif ( fog && material.fog === true ) {\n\n\t\t\t\t\tmaterials.refreshFogUniforms( m_uniforms, fog );\n\n\t\t\t\t}\n\n\t\t\t\tmaterials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget );\n\n\t\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );\n\n\t\t\t}\n\n\t\t\tif ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {\n\n\t\t\t\tWebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );\n\t\t\t\tmaterial.uniformsNeedUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( material.isSpriteMaterial ) {\n\n\t\t\t\tp_uniforms.setValue( _gl, 'center', object.center );\n\n\t\t\t}\n\n\t\t\t// common matrices\n\n\t\t\tp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );\n\t\t\tp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );\n\t\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\n\n\t\t\t// UBOs\n\n\t\t\tif ( material.isShaderMaterial || material.isRawShaderMaterial ) {\n\n\t\t\t\tconst groups = material.uniformsGroups;\n\n\t\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\t\tif ( capabilities.isWebGL2 ) {\n\n\t\t\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\t\t\tuniformsGroups.update( group, program );\n\t\t\t\t\t\tuniformsGroups.bind( group, program );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn program;\n\n\t\t}\n\n\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\n\n\t\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\n\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\n\t\t\tuniforms.lightProbe.needsUpdate = value;\n\n\t\t\tuniforms.directionalLights.needsUpdate = value;\n\t\t\tuniforms.directionalLightShadows.needsUpdate = value;\n\t\t\tuniforms.pointLights.needsUpdate = value;\n\t\t\tuniforms.pointLightShadows.needsUpdate = value;\n\t\t\tuniforms.spotLights.needsUpdate = value;\n\t\t\tuniforms.spotLightShadows.needsUpdate = value;\n\t\t\tuniforms.rectAreaLights.needsUpdate = value;\n\t\t\tuniforms.hemisphereLights.needsUpdate = value;\n\n\t\t}\n\n\t\tfunction materialNeedsLights( material ) {\n\n\t\t\treturn material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||\n\t\t\t\tmaterial.isMeshStandardMaterial || material.isShadowMaterial ||\n\t\t\t\t( material.isShaderMaterial && material.lights === true );\n\n\t\t}\n\n\t\tthis.getActiveCubeFace = function () {\n\n\t\t\treturn _currentActiveCubeFace;\n\n\t\t};\n\n\t\tthis.getActiveMipmapLevel = function () {\n\n\t\t\treturn _currentActiveMipmapLevel;\n\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn _currentRenderTarget;\n\n\t\t};\n\n\t\tthis.setRenderTargetTextures = function ( renderTarget, colorTexture, depthTexture ) {\n\n\t\t\tproperties.get( renderTarget.texture ).__webglTexture = colorTexture;\n\t\t\tproperties.get( renderTarget.depthTexture ).__webglTexture = depthTexture;\n\n\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\t\trenderTargetProperties.__hasExternalTextures = true;\n\n\t\t\tif ( renderTargetProperties.__hasExternalTextures ) {\n\n\t\t\t\trenderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;\n\n\t\t\t\tif ( ! renderTargetProperties.__autoAllocateDepthBuffer ) {\n\n\t\t\t\t\t// The multisample_render_to_texture extension doesn't work properly if there\n\t\t\t\t\t// are midframe flushes and an external depth buffer. Disable use of the extension.\n\t\t\t\t\tif ( extensions.has( 'WEBGL_multisampled_render_to_texture' ) === true ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided' );\n\t\t\t\t\t\trenderTargetProperties.__useRenderToTexture = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.setRenderTargetFramebuffer = function ( renderTarget, defaultFramebuffer ) {\n\n\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\t\t\trenderTargetProperties.__webglFramebuffer = defaultFramebuffer;\n\t\t\trenderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;\n\n\t\t};\n\n\t\tthis.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {\n\n\t\t\t_currentRenderTarget = renderTarget;\n\t\t\t_currentActiveCubeFace = activeCubeFace;\n\t\t\t_currentActiveMipmapLevel = activeMipmapLevel;\n\n\t\t\tlet useDefaultFramebuffer = true;\n\t\t\tlet framebuffer = null;\n\t\t\tlet isCube = false;\n\t\t\tlet isRenderTarget3D = false;\n\n\t\t\tif ( renderTarget ) {\n\n\t\t\t\tconst renderTargetProperties = properties.get( renderTarget );\n\n\t\t\t\tif ( renderTargetProperties.__useDefaultFramebuffer !== undefined ) {\n\n\t\t\t\t\t// We need to make sure to rebind the framebuffer.\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\t\t\t\t\tuseDefaultFramebuffer = false;\n\n\t\t\t\t} else if ( renderTargetProperties.__webglFramebuffer === undefined ) {\n\n\t\t\t\t\ttextures.setupRenderTarget( renderTarget );\n\n\t\t\t\t} else if ( renderTargetProperties.__hasExternalTextures ) {\n\n\t\t\t\t\t// Color and depth texture must be rebound in order for the swapchain to update.\n\t\t\t\t\ttextures.rebindTextures( renderTarget, properties.get( renderTarget.texture ).__webglTexture, properties.get( renderTarget.depthTexture ).__webglTexture );\n\n\t\t\t\t}\n\n\t\t\t\tconst texture = renderTarget.texture;\n\n\t\t\t\tif ( texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\t\t\tisRenderTarget3D = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\t\tif ( renderTarget.isWebGLCubeRenderTarget ) {\n\n\t\t\t\t\tframebuffer = __webglFramebuffer[ activeCubeFace ];\n\t\t\t\t\tisCube = true;\n\n\t\t\t\t} else if ( ( capabilities.isWebGL2 && renderTarget.samples > 0 ) && textures.useMultisampledRTT( renderTarget ) === false ) {\n\n\t\t\t\t\tframebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tframebuffer = __webglFramebuffer;\n\n\t\t\t\t}\n\n\t\t\t\t_currentViewport.copy( renderTarget.viewport );\n\t\t\t\t_currentScissor.copy( renderTarget.scissor );\n\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\n\n\t\t\t} else {\n\n\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();\n\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();\n\t\t\t\t_currentScissorTest = _scissorTest;\n\n\t\t\t}\n\n\t\t\tconst framebufferBound = state.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\tif ( framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer ) {\n\n\t\t\t\tstate.drawBuffers( renderTarget, framebuffer );\n\n\t\t\t}\n\n\t\t\tstate.viewport( _currentViewport );\n\t\t\tstate.scissor( _currentScissor );\n\t\t\tstate.setScissorTest( _currentScissorTest );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tconst textureProperties = properties.get( renderTarget.texture );\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );\n\n\t\t\t} else if ( isRenderTarget3D ) {\n\n\t\t\t\tconst textureProperties = properties.get( renderTarget.texture );\n\t\t\t\tconst layer = activeCubeFace || 0;\n\t\t\t\t_gl.framebufferTextureLayer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );\n\n\t\t\t}\n\n\t\t\t_currentMaterialId = - 1; // reset current material to ensure correct uniform bindings\n\n\t\t};\n\n\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {\n\n\t\t\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\n\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet framebuffer = properties.get( renderTarget ).__webglFramebuffer;\n\n\t\t\tif ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {\n\n\t\t\t\tframebuffer = framebuffer[ activeCubeFaceIndex ];\n\n\t\t\t}\n\n\t\t\tif ( framebuffer ) {\n\n\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\ttry {\n\n\t\t\t\t\tconst texture = renderTarget.texture;\n\t\t\t\t\tconst textureFormat = texture.format;\n\t\t\t\t\tconst textureType = texture.type;\n\n\t\t\t\t\tif ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );\n\n\t\t\t\t\tif ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // Edge and Chrome Mac < 52 (#9513)\n\t\t\t\t\t\t! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\n\t\t\t\t\t\t! halfFloatSupportedByExt ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\n\n\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\n\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t} finally {\n\n\t\t\t\t\t// restore framebuffer of current render target if necessary\n\n\t\t\t\t\tconst framebuffer = ( _currentRenderTarget !== null ) ? properties.get( _currentRenderTarget ).__webglFramebuffer : null;\n\t\t\t\t\tstate.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.copyFramebufferToTexture = function ( position, texture, level = 0 ) {\n\n\t\t\tconst levelScale = Math.pow( 2, - level );\n\t\t\tconst width = Math.floor( texture.image.width * levelScale );\n\t\t\tconst height = Math.floor( texture.image.height * levelScale );\n\n\t\t\ttextures.setTexture2D( texture, 0 );\n\n\t\t\t_gl.copyTexSubImage2D( _gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height );\n\n\t\t\tstate.unbindTexture();\n\n\t\t};\n\n\t\tthis.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {\n\n\t\t\tconst width = srcTexture.image.width;\n\t\t\tconst height = srcTexture.image.height;\n\t\t\tconst glFormat = utils.convert( dstTexture.format );\n\t\t\tconst glType = utils.convert( dstTexture.type );\n\n\t\t\ttextures.setTexture2D( dstTexture, 0 );\n\n\t\t\t// As another texture upload may have changed pixelStorei\n\t\t\t// parameters, make sure they are correct for the dstTexture\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\n\n\t\t\tif ( srcTexture.isDataTexture ) {\n\n\t\t\t\t_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );\n\n\t\t\t} else {\n\n\t\t\t\tif ( srcTexture.isCompressedTexture ) {\n\n\t\t\t\t\t_gl.compressedTexSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Generate mipmaps only when copying level 0\n\t\t\tif ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\t\tstate.unbindTexture();\n\n\t\t};\n\n\t\tthis.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {\n\n\t\t\tif ( _this.isWebGL1Renderer ) {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst width = sourceBox.max.x - sourceBox.min.x + 1;\n\t\t\tconst height = sourceBox.max.y - sourceBox.min.y + 1;\n\t\t\tconst depth = sourceBox.max.z - sourceBox.min.z + 1;\n\t\t\tconst glFormat = utils.convert( dstTexture.format );\n\t\t\tconst glType = utils.convert( dstTexture.type );\n\t\t\tlet glTarget;\n\n\t\t\tif ( dstTexture.isData3DTexture ) {\n\n\t\t\t\ttextures.setTexture3D( dstTexture, 0 );\n\t\t\t\tglTarget = _gl.TEXTURE_3D;\n\n\t\t\t} else if ( dstTexture.isDataArrayTexture ) {\n\n\t\t\t\ttextures.setTexture2DArray( dstTexture, 0 );\n\t\t\t\tglTarget = _gl.TEXTURE_2D_ARRAY;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );\n\n\t\t\tconst unpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );\n\t\t\tconst unpackImageHeight = _gl.getParameter( _gl.UNPACK_IMAGE_HEIGHT );\n\t\t\tconst unpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );\n\t\t\tconst unpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );\n\t\t\tconst unpackSkipImages = _gl.getParameter( _gl.UNPACK_SKIP_IMAGES );\n\n\t\t\tconst image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[ 0 ] : srcTexture.image;\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, image.width );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, image.height );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, sourceBox.min.x );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, sourceBox.min.y );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, sourceBox.min.z );\n\n\t\t\tif ( srcTexture.isDataTexture || srcTexture.isData3DTexture ) {\n\n\t\t\t\t_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data );\n\n\t\t\t} else {\n\n\t\t\t\tif ( srcTexture.isCompressedArrayTexture ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.' );\n\t\t\t\t\t_gl.compressedTexSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.texSubImage3D( glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, unpackRowLen );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, unpackSkipPixels );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, unpackSkipRows );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, unpackSkipImages );\n\n\t\t\t// Generate mipmaps only when copying level 0\n\t\t\tif ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );\n\n\t\t\tstate.unbindTexture();\n\n\t\t};\n\n\t\tthis.initTexture = function ( texture ) {\n\n\t\t\tif ( texture.isCubeTexture ) {\n\n\t\t\t\ttextures.setTextureCube( texture, 0 );\n\n\t\t\t} else if ( texture.isData3DTexture ) {\n\n\t\t\t\ttextures.setTexture3D( texture, 0 );\n\n\t\t\t} else if ( texture.isDataArrayTexture || texture.isCompressedArrayTexture ) {\n\n\t\t\t\ttextures.setTexture2DArray( texture, 0 );\n\n\t\t\t} else {\n\n\t\t\t\ttextures.setTexture2D( texture, 0 );\n\n\t\t\t}\n\n\t\t\tstate.unbindTexture();\n\n\t\t};\n\n\t\tthis.resetState = function () {\n\n\t\t\t_currentActiveCubeFace = 0;\n\t\t\t_currentActiveMipmapLevel = 0;\n\t\t\t_currentRenderTarget = null;\n\n\t\t\tstate.reset();\n\t\t\tbindingStates.reset();\n\n\t\t};\n\n\t\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );\n\n\t\t}\n\n\t}\n\n\tget coordinateSystem() {\n\n\t\treturn WebGLCoordinateSystem;\n\n\t}\n\n\tget physicallyCorrectLights() { // @deprecated, r150\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.' );\n\t\treturn ! this.useLegacyLights;\n\n\t}\n\n\tset physicallyCorrectLights( value ) { // @deprecated, r150\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.' );\n\t\tthis.useLegacyLights = ! value;\n\n\t}\n\n\tget outputEncoding() { // @deprecated, r152\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.' );\n\t\treturn this.outputColorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n\n\t}\n\n\tset outputEncoding( encoding ) { // @deprecated, r152\n\n\t\tconsole.warn( 'THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.' );\n\t\tthis.outputColorSpace = encoding === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n\n\t}\n\n}\n\nclass WebGL1Renderer extends WebGLRenderer {}\n\nWebGL1Renderer.prototype.isWebGL1Renderer = true;\n\nclass FogExp2 {\n\n\tconstructor( color, density = 0.00025 ) {\n\n\t\tthis.isFogExp2 = true;\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\t\tthis.density = density;\n\n\t}\n\n\tclone() {\n\n\t\treturn new FogExp2( this.color, this.density );\n\n\t}\n\n\ttoJSON( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'FogExp2',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tdensity: this.density\n\t\t};\n\n\t}\n\n}\n\nclass Fog {\n\n\tconstructor( color, near = 1, far = 1000 ) {\n\n\t\tthis.isFog = true;\n\n\t\tthis.name = '';\n\n\t\tthis.color = new Color( color );\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Fog( this.color, this.near, this.far );\n\n\t}\n\n\ttoJSON( /* meta */ ) {\n\n\t\treturn {\n\t\t\ttype: 'Fog',\n\t\t\tcolor: this.color.getHex(),\n\t\t\tnear: this.near,\n\t\t\tfar: this.far\n\t\t};\n\n\t}\n\n}\n\nclass Scene extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isScene = true;\n\n\t\tthis.type = 'Scene';\n\n\t\tthis.background = null;\n\t\tthis.environment = null;\n\t\tthis.fog = null;\n\n\t\tthis.backgroundBlurriness = 0;\n\t\tthis.backgroundIntensity = 1;\n\n\t\tthis.overrideMaterial = null;\n\n\t\tif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t\t\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.background !== null ) this.background = source.background.clone();\n\t\tif ( source.environment !== null ) this.environment = source.environment.clone();\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\n\n\t\tthis.backgroundBlurriness = source.backgroundBlurriness;\n\t\tthis.backgroundIntensity = source.backgroundIntensity;\n\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\n\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\n\t\tif ( this.backgroundBlurriness > 0 ) data.object.backgroundBlurriness = this.backgroundBlurriness;\n\t\tif ( this.backgroundIntensity !== 1 ) data.object.backgroundIntensity = this.backgroundIntensity;\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass InterleavedBuffer {\n\n\tconstructor( array, stride ) {\n\n\t\tthis.isInterleavedBuffer = true;\n\n\t\tthis.array = array;\n\t\tthis.stride = stride;\n\t\tthis.count = array !== undefined ? array.length / stride : 0;\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis.updateRange = { offset: 0, count: - 1 };\n\n\t\tthis.version = 0;\n\n\t\tthis.uuid = generateUUID();\n\n\t}\n\n\tonUploadCallback() {}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.array = new source.array.constructor( source.array );\n\t\tthis.count = source.count;\n\t\tthis.stride = source.stride;\n\t\tthis.usage = source.usage;\n\n\t\treturn this;\n\n\t}\n\n\tcopyAt( index1, attribute, index2 ) {\n\n\t\tindex1 *= this.stride;\n\t\tindex2 *= attribute.stride;\n\n\t\tfor ( let i = 0, l = this.stride; i < l; i ++ ) {\n\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tset( value, offset = 0 ) {\n\n\t\tthis.array.set( value, offset );\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tif ( data.arrayBuffers === undefined ) {\n\n\t\t\tdata.arrayBuffers = {};\n\n\t\t}\n\n\t\tif ( this.array.buffer._uuid === undefined ) {\n\n\t\t\tthis.array.buffer._uuid = generateUUID();\n\n\t\t}\n\n\t\tif ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {\n\n\t\t\tdata.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;\n\n\t\t}\n\n\t\tconst array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );\n\n\t\tconst ib = new this.constructor( array, this.stride );\n\t\tib.setUsage( this.usage );\n\n\t\treturn ib;\n\n\t}\n\n\tonUpload( callback ) {\n\n\t\tthis.onUploadCallback = callback;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tif ( data.arrayBuffers === undefined ) {\n\n\t\t\tdata.arrayBuffers = {};\n\n\t\t}\n\n\t\t// generate UUID for array buffer if necessary\n\n\t\tif ( this.array.buffer._uuid === undefined ) {\n\n\t\t\tthis.array.buffer._uuid = generateUUID();\n\n\t\t}\n\n\t\tif ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {\n\n\t\t\tdata.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );\n\n\t\t}\n\n\t\t//\n\n\t\treturn {\n\t\t\tuuid: this.uuid,\n\t\t\tbuffer: this.array.buffer._uuid,\n\t\t\ttype: this.array.constructor.name,\n\t\t\tstride: this.stride\n\t\t};\n\n\t}\n\n}\n\nconst _vector$5 = /*@__PURE__*/ new Vector3();\n\nclass InterleavedBufferAttribute {\n\n\tconstructor( interleavedBuffer, itemSize, offset, normalized = false ) {\n\n\t\tthis.isInterleavedBufferAttribute = true;\n\n\t\tthis.name = '';\n\n\t\tthis.data = interleavedBuffer;\n\t\tthis.itemSize = itemSize;\n\t\tthis.offset = offset;\n\n\t\tthis.normalized = normalized;\n\n\t}\n\n\tget count() {\n\n\t\treturn this.data.count;\n\n\t}\n\n\tget array() {\n\n\t\treturn this.data.array;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tthis.data.needsUpdate = value;\n\n\t}\n\n\tapplyMatrix4( m ) {\n\n\t\tfor ( let i = 0, l = this.data.count; i < l; i ++ ) {\n\n\t\t\t_vector$5.fromBufferAttribute( this, i );\n\n\t\t\t_vector$5.applyMatrix4( m );\n\n\t\t\tthis.setXYZ( i, _vector$5.x, _vector$5.y, _vector$5.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyNormalMatrix( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$5.fromBufferAttribute( this, i );\n\n\t\t\t_vector$5.applyNormalMatrix( m );\n\n\t\t\tthis.setXYZ( i, _vector$5.x, _vector$5.y, _vector$5.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttransformDirection( m ) {\n\n\t\tfor ( let i = 0, l = this.count; i < l; i ++ ) {\n\n\t\t\t_vector$5.fromBufferAttribute( this, i );\n\n\t\t\t_vector$5.transformDirection( m );\n\n\t\t\tthis.setXYZ( i, _vector$5.x, _vector$5.y, _vector$5.z );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetX( index, x ) {\n\n\t\tif ( this.normalized ) x = normalize( x, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\n\n\t\treturn this;\n\n\t}\n\n\tsetY( index, y ) {\n\n\t\tif ( this.normalized ) y = normalize( y, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetZ( index, z ) {\n\n\t\tif ( this.normalized ) z = normalize( z, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetW( index, w ) {\n\n\t\tif ( this.normalized ) w = normalize( w, this.array );\n\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tgetX( index ) {\n\n\t\tlet x = this.data.array[ index * this.data.stride + this.offset ];\n\n\t\tif ( this.normalized ) x = denormalize( x, this.array );\n\n\t\treturn x;\n\n\t}\n\n\tgetY( index ) {\n\n\t\tlet y = this.data.array[ index * this.data.stride + this.offset + 1 ];\n\n\t\tif ( this.normalized ) y = denormalize( y, this.array );\n\n\t\treturn y;\n\n\t}\n\n\tgetZ( index ) {\n\n\t\tlet z = this.data.array[ index * this.data.stride + this.offset + 2 ];\n\n\t\tif ( this.normalized ) z = denormalize( z, this.array );\n\n\t\treturn z;\n\n\t}\n\n\tgetW( index ) {\n\n\t\tlet w = this.data.array[ index * this.data.stride + this.offset + 3 ];\n\n\t\tif ( this.normalized ) w = denormalize( w, this.array );\n\n\t\treturn w;\n\n\t}\n\n\tsetXY( index, x, y ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZ( index, x, y, z ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\n\t\treturn this;\n\n\t}\n\n\tsetXYZW( index, x, y, z, w ) {\n\n\t\tindex = index * this.data.stride + this.offset;\n\n\t\tif ( this.normalized ) {\n\n\t\t\tx = normalize( x, this.array );\n\t\t\ty = normalize( y, this.array );\n\t\t\tz = normalize( z, this.array );\n\t\t\tw = normalize( w, this.array );\n\n\t\t}\n\n\t\tthis.data.array[ index + 0 ] = x;\n\t\tthis.data.array[ index + 1 ] = y;\n\t\tthis.data.array[ index + 2 ] = z;\n\t\tthis.data.array[ index + 3 ] = w;\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconsole.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.' );\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0; i < this.count; i ++ ) {\n\n\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\tfor ( let j = 0; j < this.itemSize; j ++ ) {\n\n\t\t\t\t\tarray.push( this.data.array[ index + j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );\n\n\t\t} else {\n\n\t\t\tif ( data.interleavedBuffers === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers = {};\n\n\t\t\t}\n\n\t\t\tif ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );\n\n\t\t\t}\n\n\t\t\treturn new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );\n\n\t\t}\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tif ( data === undefined ) {\n\n\t\t\tconsole.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.' );\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0; i < this.count; i ++ ) {\n\n\t\t\t\tconst index = i * this.data.stride + this.offset;\n\n\t\t\t\tfor ( let j = 0; j < this.itemSize; j ++ ) {\n\n\t\t\t\t\tarray.push( this.data.array[ index + j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// de-interleave data and save it as an ordinary buffer attribute for now\n\n\t\t\treturn {\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\ttype: this.array.constructor.name,\n\t\t\t\tarray: array,\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\n\t\t} else {\n\n\t\t\t// save as true interleaved attribute\n\n\t\t\tif ( data.interleavedBuffers === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers = {};\n\n\t\t\t}\n\n\t\t\tif ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {\n\n\t\t\t\tdata.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );\n\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tisInterleavedBufferAttribute: true,\n\t\t\t\titemSize: this.itemSize,\n\t\t\t\tdata: this.data.uuid,\n\t\t\t\toffset: this.offset,\n\t\t\t\tnormalized: this.normalized\n\t\t\t};\n\n\t\t}\n\n\t}\n\n}\n\nclass SpriteMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isSpriteMaterial = true;\n\n\t\tthis.type = 'SpriteMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.rotation = 0;\n\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.transparent = true;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.rotation = source.rotation;\n\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nlet _geometry;\n\nconst _intersectPoint = /*@__PURE__*/ new Vector3();\nconst _worldScale = /*@__PURE__*/ new Vector3();\nconst _mvPosition = /*@__PURE__*/ new Vector3();\n\nconst _alignedPosition = /*@__PURE__*/ new Vector2();\nconst _rotatedPosition = /*@__PURE__*/ new Vector2();\nconst _viewWorldMatrix = /*@__PURE__*/ new Matrix4();\n\nconst _vA = /*@__PURE__*/ new Vector3();\nconst _vB = /*@__PURE__*/ new Vector3();\nconst _vC = /*@__PURE__*/ new Vector3();\n\nconst _uvA = /*@__PURE__*/ new Vector2();\nconst _uvB = /*@__PURE__*/ new Vector2();\nconst _uvC = /*@__PURE__*/ new Vector2();\n\nclass Sprite extends Object3D {\n\n\tconstructor( material ) {\n\n\t\tsuper();\n\n\t\tthis.isSprite = true;\n\n\t\tthis.type = 'Sprite';\n\n\t\tif ( _geometry === undefined ) {\n\n\t\t\t_geometry = new BufferGeometry();\n\n\t\t\tconst float32Array = new Float32Array( [\n\t\t\t\t- 0.5, - 0.5, 0, 0, 0,\n\t\t\t\t0.5, - 0.5, 0, 1, 0,\n\t\t\t\t0.5, 0.5, 0, 1, 1,\n\t\t\t\t- 0.5, 0.5, 0, 0, 1\n\t\t\t] );\n\n\t\t\tconst interleavedBuffer = new InterleavedBuffer( float32Array, 5 );\n\n\t\t\t_geometry.setIndex( [ 0, 1, 2,\t0, 2, 3 ] );\n\t\t\t_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\n\t\t\t_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\n\n\t\t}\n\n\t\tthis.geometry = _geometry;\n\t\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\n\n\t\tthis.center = new Vector2( 0.5, 0.5 );\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tif ( raycaster.camera === null ) {\n\n\t\t\tconsole.error( 'THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.' );\n\n\t\t}\n\n\t\t_worldScale.setFromMatrixScale( this.matrixWorld );\n\n\t\t_viewWorldMatrix.copy( raycaster.camera.matrixWorld );\n\t\tthis.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );\n\n\t\t_mvPosition.setFromMatrixPosition( this.modelViewMatrix );\n\n\t\tif ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {\n\n\t\t\t_worldScale.multiplyScalar( - _mvPosition.z );\n\n\t\t}\n\n\t\tconst rotation = this.material.rotation;\n\t\tlet sin, cos;\n\n\t\tif ( rotation !== 0 ) {\n\n\t\t\tcos = Math.cos( rotation );\n\t\t\tsin = Math.sin( rotation );\n\n\t\t}\n\n\t\tconst center = this.center;\n\n\t\ttransformVertex( _vA.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\ttransformVertex( _vB.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\ttransformVertex( _vC.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\n\t\t_uvA.set( 0, 0 );\n\t\t_uvB.set( 1, 0 );\n\t\t_uvC.set( 1, 1 );\n\n\t\t// check first triangle\n\t\tlet intersect = raycaster.ray.intersectTriangle( _vA, _vB, _vC, false, _intersectPoint );\n\n\t\tif ( intersect === null ) {\n\n\t\t\t// check second triangle\n\t\t\ttransformVertex( _vB.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );\n\t\t\t_uvB.set( 0, 1 );\n\n\t\t\tintersect = raycaster.ray.intersectTriangle( _vA, _vC, _vB, false, _intersectPoint );\n\t\t\tif ( intersect === null ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst distance = raycaster.ray.origin.distanceTo( _intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tpoint: _intersectPoint.clone(),\n\t\t\tuv: Triangle.getInterpolation( _intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() ),\n\t\t\tface: null,\n\t\t\tobject: this\n\n\t\t} );\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tif ( source.center !== undefined ) this.center.copy( source.center );\n\n\t\tthis.material = source.material;\n\n\t\treturn this;\n\n\t}\n\n}\n\nfunction transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {\n\n\t// compute position in camera space\n\t_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );\n\n\t// to check if rotation is not zero\n\tif ( sin !== undefined ) {\n\n\t\t_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );\n\t\t_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );\n\n\t} else {\n\n\t\t_rotatedPosition.copy( _alignedPosition );\n\n\t}\n\n\n\tvertexPosition.copy( mvPosition );\n\tvertexPosition.x += _rotatedPosition.x;\n\tvertexPosition.y += _rotatedPosition.y;\n\n\t// transform to world space\n\tvertexPosition.applyMatrix4( _viewWorldMatrix );\n\n}\n\nconst _v1$2 = /*@__PURE__*/ new Vector3();\nconst _v2$1 = /*@__PURE__*/ new Vector3();\n\nclass LOD extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis._currentLevel = 0;\n\n\t\tthis.type = 'LOD';\n\n\t\tObject.defineProperties( this, {\n\t\t\tlevels: {\n\t\t\t\tenumerable: true,\n\t\t\t\tvalue: []\n\t\t\t},\n\t\t\tisLOD: {\n\t\t\t\tvalue: true,\n\t\t\t}\n\t\t} );\n\n\t\tthis.autoUpdate = true;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source, false );\n\n\t\tconst levels = source.levels;\n\n\t\tfor ( let i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tconst level = levels[ i ];\n\n\t\t\tthis.addLevel( level.object.clone(), level.distance, level.hysteresis );\n\n\t\t}\n\n\t\tthis.autoUpdate = source.autoUpdate;\n\n\t\treturn this;\n\n\t}\n\n\taddLevel( object, distance = 0, hysteresis = 0 ) {\n\n\t\tdistance = Math.abs( distance );\n\n\t\tconst levels = this.levels;\n\n\t\tlet l;\n\n\t\tfor ( l = 0; l < levels.length; l ++ ) {\n\n\t\t\tif ( distance < levels[ l ].distance ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlevels.splice( l, 0, { distance: distance, hysteresis: hysteresis, object: object } );\n\n\t\tthis.add( object );\n\n\t\treturn this;\n\n\t}\n\n\tgetCurrentLevel() {\n\n\t\treturn this._currentLevel;\n\n\t}\n\n\n\n\tgetObjectForDistance( distance ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 0 ) {\n\n\t\t\tlet i, l;\n\n\t\t\tfor ( i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tlet levelDistance = levels[ i ].distance;\n\n\t\t\t\tif ( levels[ i ].object.visible ) {\n\n\t\t\t\t\tlevelDistance -= levelDistance * levels[ i ].hysteresis;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distance < levelDistance ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn levels[ i - 1 ].object;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 0 ) {\n\n\t\t\t_v1$2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tconst distance = raycaster.ray.origin.distanceTo( _v1$2 );\n\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\n\n\t\t}\n\n\t}\n\n\tupdate( camera ) {\n\n\t\tconst levels = this.levels;\n\n\t\tif ( levels.length > 1 ) {\n\n\t\t\t_v1$2.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t_v2$1.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tconst distance = _v1$2.distanceTo( _v2$1 ) / camera.zoom;\n\n\t\t\tlevels[ 0 ].object.visible = true;\n\n\t\t\tlet i, l;\n\n\t\t\tfor ( i = 1, l = levels.length; i < l; i ++ ) {\n\n\t\t\t\tlet levelDistance = levels[ i ].distance;\n\n\t\t\t\tif ( levels[ i ].object.visible ) {\n\n\t\t\t\t\tlevelDistance -= levelDistance * levels[ i ].hysteresis;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distance >= levelDistance ) {\n\n\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\n\t\t\t\t\tlevels[ i ].object.visible = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._currentLevel = i - 1;\n\n\t\t\tfor ( ; i < l; i ++ ) {\n\n\t\t\t\tlevels[ i ].object.visible = false;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tif ( this.autoUpdate === false ) data.object.autoUpdate = false;\n\n\t\tdata.object.levels = [];\n\n\t\tconst levels = this.levels;\n\n\t\tfor ( let i = 0, l = levels.length; i < l; i ++ ) {\n\n\t\t\tconst level = levels[ i ];\n\n\t\t\tdata.object.levels.push( {\n\t\t\t\tobject: level.object.uuid,\n\t\t\t\tdistance: level.distance,\n\t\t\t\thysteresis: level.hysteresis\n\t\t\t} );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst _basePosition = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\n\nconst _vector3 = /*@__PURE__*/ new Vector3();\nconst _matrix4 = /*@__PURE__*/ new Matrix4();\nconst _vertex = /*@__PURE__*/ new Vector3();\n\nconst _sphere$3 = /*@__PURE__*/ new Sphere();\nconst _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();\nconst _ray$2 = /*@__PURE__*/ new Ray();\n\nclass SkinnedMesh extends Mesh {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isSkinnedMesh = true;\n\n\t\tthis.type = 'SkinnedMesh';\n\n\t\tthis.bindMode = 'attached';\n\t\tthis.bindMatrix = new Matrix4();\n\t\tthis.bindMatrixInverse = new Matrix4();\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.makeEmpty();\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\t_vertex.fromBufferAttribute( positionAttribute, i );\n\t\t\tthis.applyBoneTransform( i, _vertex );\n\t\t\tthis.boundingBox.expandByPoint( _vertex );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.makeEmpty();\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i ++ ) {\n\n\t\t\t_vertex.fromBufferAttribute( positionAttribute, i );\n\t\t\tthis.applyBoneTransform( i, _vertex );\n\t\t\tthis.boundingSphere.expandByPoint( _vertex );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.bindMode = source.bindMode;\n\t\tthis.bindMatrix.copy( source.bindMatrix );\n\t\tthis.bindMatrixInverse.copy( source.bindMatrixInverse );\n\n\t\tthis.skeleton = source.skeleton;\n\n\t\tif ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();\n\t\tif ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst material = this.material;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\tif ( material === undefined ) return;\n\n\t\t// test with bounding sphere in world space\n\n\t\tif ( this.boundingSphere === null ) this.computeBoundingSphere();\n\n\t\t_sphere$3.copy( this.boundingSphere );\n\t\t_sphere$3.applyMatrix4( matrixWorld );\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;\n\n\t\t// convert ray to local space of skinned mesh\n\n\t\t_inverseMatrix$2.copy( matrixWorld ).invert();\n\t\t_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );\n\n\t\t// test with bounding box in local space\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tif ( _ray$2.intersectsBox( this.boundingBox ) === false ) return;\n\n\t\t}\n\n\t\t// test for intersections with geometry\n\n\t\tthis._computeIntersections( raycaster, intersects, _ray$2 );\n\n\t}\n\n\tgetVertexPosition( index, target ) {\n\n\t\tsuper.getVertexPosition( index, target );\n\n\t\tthis.applyBoneTransform( index, target );\n\n\t\treturn target;\n\n\t}\n\n\tbind( skeleton, bindMatrix ) {\n\n\t\tthis.skeleton = skeleton;\n\n\t\tif ( bindMatrix === undefined ) {\n\n\t\t\tthis.updateMatrixWorld( true );\n\n\t\t\tthis.skeleton.calculateInverses();\n\n\t\t\tbindMatrix = this.matrixWorld;\n\n\t\t}\n\n\t\tthis.bindMatrix.copy( bindMatrix );\n\t\tthis.bindMatrixInverse.copy( bindMatrix ).invert();\n\n\t}\n\n\tpose() {\n\n\t\tthis.skeleton.pose();\n\n\t}\n\n\tnormalizeSkinWeights() {\n\n\t\tconst vector = new Vector4();\n\n\t\tconst skinWeight = this.geometry.attributes.skinWeight;\n\n\t\tfor ( let i = 0, l = skinWeight.count; i < l; i ++ ) {\n\n\t\t\tvector.fromBufferAttribute( skinWeight, i );\n\n\t\t\tconst scale = 1.0 / vector.manhattanLength();\n\n\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\tvector.multiplyScalar( scale );\n\n\t\t\t} else {\n\n\t\t\t\tvector.set( 1, 0, 0, 0 ); // do something reasonable\n\n\t\t\t}\n\n\t\t\tskinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.bindMode === 'attached' ) {\n\n\t\t\tthis.bindMatrixInverse.copy( this.matrixWorld ).invert();\n\n\t\t} else if ( this.bindMode === 'detached' ) {\n\n\t\t\tthis.bindMatrixInverse.copy( this.bindMatrix ).invert();\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\n\n\t\t}\n\n\t}\n\n\tapplyBoneTransform( index, vector ) {\n\n\t\tconst skeleton = this.skeleton;\n\t\tconst geometry = this.geometry;\n\n\t\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t\t_basePosition.copy( vector ).applyMatrix4( this.bindMatrix );\n\n\t\tvector.set( 0, 0, 0 );\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\t\tif ( weight !== 0 ) {\n\n\t\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\n\t\t\t\t_matrix4.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );\n\n\t\t\t\tvector.addScaledVector( _vector3.copy( _basePosition ).applyMatrix4( _matrix4 ), weight );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn vector.applyMatrix4( this.bindMatrixInverse );\n\n\t}\n\n\tboneTransform( index, vector ) { // @deprecated, r151\n\n\t\tconsole.warn( 'THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151.' );\n\t\treturn this.applyBoneTransform( index, vector );\n\n\t}\n\n\n}\n\nclass Bone extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isBone = true;\n\n\t\tthis.type = 'Bone';\n\n\t}\n\n}\n\nclass DataTexture extends Texture {\n\n\tconstructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace ) {\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\tthis.isDataTexture = true;\n\n\t\tthis.image = { data: data, width: width, height: height };\n\n\t\tthis.generateMipmaps = false;\n\t\tthis.flipY = false;\n\t\tthis.unpackAlignment = 1;\n\n\t}\n\n}\n\nconst _offsetMatrix = /*@__PURE__*/ new Matrix4();\nconst _identityMatrix = /*@__PURE__*/ new Matrix4();\n\nclass Skeleton {\n\n\tconstructor( bones = [], boneInverses = [] ) {\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.bones = bones.slice( 0 );\n\t\tthis.boneInverses = boneInverses;\n\t\tthis.boneMatrices = null;\n\n\t\tthis.boneTexture = null;\n\t\tthis.boneTextureSize = 0;\n\n\t\tthis.init();\n\n\t}\n\n\tinit() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tthis.boneMatrices = new Float32Array( bones.length * 16 );\n\n\t\t// calculate inverse bone matrices if necessary\n\n\t\tif ( boneInverses.length === 0 ) {\n\n\t\t\tthis.calculateInverses();\n\n\t\t} else {\n\n\t\t\t// handle special case\n\n\t\t\tif ( bones.length !== boneInverses.length ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );\n\n\t\t\t\tthis.boneInverses = [];\n\n\t\t\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\t\t\tthis.boneInverses.push( new Matrix4() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcalculateInverses() {\n\n\t\tthis.boneInverses.length = 0;\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst inverse = new Matrix4();\n\n\t\t\tif ( this.bones[ i ] ) {\n\n\t\t\t\tinverse.copy( this.bones[ i ].matrixWorld ).invert();\n\n\t\t\t}\n\n\t\t\tthis.boneInverses.push( inverse );\n\n\t\t}\n\n\t}\n\n\tpose() {\n\n\t\t// recover the bind-time world matrices\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tbone.matrixWorld.copy( this.boneInverses[ i ] ).invert();\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compute the local matrices, positions, rotations and scales\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone ) {\n\n\t\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\t\tconst boneMatrices = this.boneMatrices;\n\t\tconst boneTexture = this.boneTexture;\n\n\t\t// flatten bone matrices to array\n\n\t\tfor ( let i = 0, il = bones.length; i < il; i ++ ) {\n\n\t\t\t// compute the offset between the current and the original transform\n\n\t\t\tconst matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;\n\n\t\t\t_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\n\t\t\t_offsetMatrix.toArray( boneMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( boneTexture !== null ) {\n\n\t\t\tboneTexture.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new Skeleton( this.bones, this.boneInverses );\n\n\t}\n\n\tcomputeBoneTexture() {\n\n\t\t// layout (1 matrix = 4 pixels)\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\n\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\n\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\n\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\n\n\t\tlet size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\n\t\tsize = ceilPowerOfTwo( size );\n\t\tsize = Math.max( size, 4 );\n\n\t\tconst boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\n\t\tboneMatrices.set( this.boneMatrices ); // copy current values\n\n\t\tconst boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\n\t\tboneTexture.needsUpdate = true;\n\n\t\tthis.boneMatrices = boneMatrices;\n\t\tthis.boneTexture = boneTexture;\n\t\tthis.boneTextureSize = size;\n\n\t\treturn this;\n\n\t}\n\n\tgetBoneByName( name ) {\n\n\t\tfor ( let i = 0, il = this.bones.length; i < il; i ++ ) {\n\n\t\t\tconst bone = this.bones[ i ];\n\n\t\t\tif ( bone.name === name ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t}\n\n\tdispose( ) {\n\n\t\tif ( this.boneTexture !== null ) {\n\n\t\t\tthis.boneTexture.dispose();\n\n\t\t\tthis.boneTexture = null;\n\n\t\t}\n\n\t}\n\n\tfromJSON( json, bones ) {\n\n\t\tthis.uuid = json.uuid;\n\n\t\tfor ( let i = 0, l = json.bones.length; i < l; i ++ ) {\n\n\t\t\tconst uuid = json.bones[ i ];\n\t\t\tlet bone = bones[ uuid ];\n\n\t\t\tif ( bone === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );\n\t\t\t\tbone = new Bone();\n\n\t\t\t}\n\n\t\t\tthis.bones.push( bone );\n\t\t\tthis.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );\n\n\t\t}\n\n\t\tthis.init();\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Skeleton',\n\t\t\t\tgenerator: 'Skeleton.toJSON'\n\t\t\t},\n\t\t\tbones: [],\n\t\t\tboneInverses: []\n\t\t};\n\n\t\tdata.uuid = this.uuid;\n\n\t\tconst bones = this.bones;\n\t\tconst boneInverses = this.boneInverses;\n\n\t\tfor ( let i = 0, l = bones.length; i < l; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\t\t\tdata.bones.push( bone.uuid );\n\n\t\t\tconst boneInverse = boneInverses[ i ];\n\t\t\tdata.boneInverses.push( boneInverse.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass InstancedBufferAttribute extends BufferAttribute {\n\n\tconstructor( array, itemSize, normalized, meshPerAttribute = 1 ) {\n\n\t\tsuper( array, itemSize, normalized );\n\n\t\tthis.isInstancedBufferAttribute = true;\n\n\t\tthis.meshPerAttribute = meshPerAttribute;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.meshPerAttribute = this.meshPerAttribute;\n\n\t\tdata.isInstancedBufferAttribute = true;\n\n\t\treturn data;\n\n\t}\n\n}\n\nconst _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();\nconst _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();\n\nconst _instanceIntersects = [];\n\nconst _box3 = /*@__PURE__*/ new Box3();\nconst _identity = /*@__PURE__*/ new Matrix4();\nconst _mesh = /*@__PURE__*/ new Mesh();\nconst _sphere$2 = /*@__PURE__*/ new Sphere();\n\nclass InstancedMesh extends Mesh {\n\n\tconstructor( geometry, material, count ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isInstancedMesh = true;\n\n\t\tthis.instanceMatrix = new InstancedBufferAttribute( new Float32Array( count * 16 ), 16 );\n\t\tthis.instanceColor = null;\n\n\t\tthis.count = count;\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.setMatrixAt( i, _identity );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst count = this.count;\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tthis.boundingBox.makeEmpty();\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.getMatrixAt( i, _instanceLocalMatrix );\n\n\t\t\t_box3.copy( geometry.boundingBox ).applyMatrix4( _instanceLocalMatrix );\n\n\t\t\tthis.boundingBox.union( _box3 );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst count = this.count;\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.makeEmpty();\n\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tthis.getMatrixAt( i, _instanceLocalMatrix );\n\n\t\t\t_sphere$2.copy( geometry.boundingSphere ).applyMatrix4( _instanceLocalMatrix );\n\n\t\t\tthis.boundingSphere.union( _sphere$2 );\n\n\t\t}\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.instanceMatrix.copy( source.instanceMatrix );\n\n\t\tif ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();\n\n\t\tthis.count = source.count;\n\n\t\tif ( source.boundingBox !== null ) this.boundingBox = source.boundingBox.clone();\n\t\tif ( source.boundingSphere !== null ) this.boundingSphere = source.boundingSphere.clone();\n\n\t\treturn this;\n\n\t}\n\n\tgetColorAt( index, color ) {\n\n\t\tcolor.fromArray( this.instanceColor.array, index * 3 );\n\n\t}\n\n\tgetMatrixAt( index, matrix ) {\n\n\t\tmatrix.fromArray( this.instanceMatrix.array, index * 16 );\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst raycastTimes = this.count;\n\n\t\t_mesh.geometry = this.geometry;\n\t\t_mesh.material = this.material;\n\n\t\tif ( _mesh.material === undefined ) return;\n\n\t\t// test with bounding sphere first\n\n\t\tif ( this.boundingSphere === null ) this.computeBoundingSphere();\n\n\t\t_sphere$2.copy( this.boundingSphere );\n\t\t_sphere$2.applyMatrix4( matrixWorld );\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$2 ) === false ) return;\n\n\t\t// now test each instance\n\n\t\tfor ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {\n\n\t\t\t// calculate the world matrix for each instance\n\n\t\t\tthis.getMatrixAt( instanceId, _instanceLocalMatrix );\n\n\t\t\t_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );\n\n\t\t\t// the mesh represents this single instance\n\n\t\t\t_mesh.matrixWorld = _instanceWorldMatrix;\n\n\t\t\t_mesh.raycast( raycaster, _instanceIntersects );\n\n\t\t\t// process the result of raycast\n\n\t\t\tfor ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {\n\n\t\t\t\tconst intersect = _instanceIntersects[ i ];\n\t\t\t\tintersect.instanceId = instanceId;\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_instanceIntersects.length = 0;\n\n\t\t}\n\n\t}\n\n\tsetColorAt( index, color ) {\n\n\t\tif ( this.instanceColor === null ) {\n\n\t\t\tthis.instanceColor = new InstancedBufferAttribute( new Float32Array( this.instanceMatrix.count * 3 ), 3 );\n\n\t\t}\n\n\t\tcolor.toArray( this.instanceColor.array, index * 3 );\n\n\t}\n\n\tsetMatrixAt( index, matrix ) {\n\n\t\tmatrix.toArray( this.instanceMatrix.array, index * 16 );\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nclass LineBasicMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isLineBasicMaterial = true;\n\n\t\tthis.type = 'LineBasicMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.linewidth = 1;\n\t\tthis.linecap = 'round';\n\t\tthis.linejoin = 'round';\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.linewidth = source.linewidth;\n\t\tthis.linecap = source.linecap;\n\t\tthis.linejoin = source.linejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _start$1 = /*@__PURE__*/ new Vector3();\nconst _end$1 = /*@__PURE__*/ new Vector3();\nconst _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();\nconst _ray$1 = /*@__PURE__*/ new Ray();\nconst _sphere$1 = /*@__PURE__*/ new Sphere();\n\nclass Line extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isLine = true;\n\n\t\tthis.type = 'Line';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.material = source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\t// we assume non-indexed geometry\n\n\t\tif ( geometry.index === null ) {\n\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst lineDistances = [ 0 ];\n\n\t\t\tfor ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {\n\n\t\t\t\t_start$1.fromBufferAttribute( positionAttribute, i - 1 );\n\t\t\t\t_end$1.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\tlineDistances[ i ] = lineDistances[ i - 1 ];\n\t\t\t\tlineDistances[ i ] += _start$1.distanceTo( _end$1 );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Line.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere$1.copy( geometry.boundingSphere );\n\t\t_sphere$1.applyMatrix4( matrixWorld );\n\t\t_sphere$1.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix$1.copy( matrixWorld ).invert();\n\t\t_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tconst vStart = new Vector3();\n\t\tconst vEnd = new Vector3();\n\t\tconst interSegment = new Vector3();\n\t\tconst interRay = new Vector3();\n\t\tconst step = this.isLineSegments ? 2 : 1;\n\n\t\tconst index = geometry.index;\n\t\tconst attributes = geometry.attributes;\n\t\tconst positionAttribute = attributes.position;\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\tconst a = index.getX( i );\n\t\t\t\tconst b = index.getX( i + 1 );\n\n\t\t\t\tvStart.fromBufferAttribute( positionAttribute, a );\n\t\t\t\tvEnd.fromBufferAttribute( positionAttribute, b );\n\n\t\t\t\tconst distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\tif ( distSq > localThresholdSq ) continue;\n\n\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\tconst distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\tintersects.push( {\n\n\t\t\t\t\tdistance: distance,\n\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\tindex: i,\n\t\t\t\t\tface: null,\n\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\tobject: this\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end - 1; i < l; i += step ) {\n\n\t\t\t\tvStart.fromBufferAttribute( positionAttribute, i );\n\t\t\t\tvEnd.fromBufferAttribute( positionAttribute, i + 1 );\n\n\t\t\t\tconst distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\n\n\t\t\t\tif ( distSq > localThresholdSq ) continue;\n\n\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\n\n\t\t\t\tconst distance = raycaster.ray.origin.distanceTo( interRay );\n\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\tintersects.push( {\n\n\t\t\t\t\tdistance: distance,\n\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\n\t\t\t\t\tindex: i,\n\t\t\t\t\tface: null,\n\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\tobject: this\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nconst _start = /*@__PURE__*/ new Vector3();\nconst _end = /*@__PURE__*/ new Vector3();\n\nclass LineSegments extends Line {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineSegments = true;\n\n\t\tthis.type = 'LineSegments';\n\n\t}\n\n\tcomputeLineDistances() {\n\n\t\tconst geometry = this.geometry;\n\n\t\t// we assume non-indexed geometry\n\n\t\tif ( geometry.index === null ) {\n\n\t\t\tconst positionAttribute = geometry.attributes.position;\n\t\t\tconst lineDistances = [];\n\n\t\t\tfor ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {\n\n\t\t\t\t_start.fromBufferAttribute( positionAttribute, i );\n\t\t\t\t_end.fromBufferAttribute( positionAttribute, i + 1 );\n\n\t\t\t\tlineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];\n\t\t\t\tlineDistances[ i + 1 ] = lineDistances[ i ] + _start.distanceTo( _end );\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineLoop extends Line {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isLineLoop = true;\n\n\t\tthis.type = 'LineLoop';\n\n\t}\n\n}\n\nclass PointsMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isPointsMaterial = true;\n\n\t\tthis.type = 'PointsMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.size = 1;\n\t\tthis.sizeAttenuation = true;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.size = source.size;\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _inverseMatrix = /*@__PURE__*/ new Matrix4();\nconst _ray = /*@__PURE__*/ new Ray();\nconst _sphere = /*@__PURE__*/ new Sphere();\nconst _position$2 = /*@__PURE__*/ new Vector3();\n\nclass Points extends Object3D {\n\n\tconstructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {\n\n\t\tsuper();\n\n\t\tthis.isPoints = true;\n\n\t\tthis.type = 'Points';\n\n\t\tthis.geometry = geometry;\n\t\tthis.material = material;\n\n\t\tthis.updateMorphTargets();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.material = source.material;\n\t\tthis.geometry = source.geometry;\n\n\t\treturn this;\n\n\t}\n\n\traycast( raycaster, intersects ) {\n\n\t\tconst geometry = this.geometry;\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst threshold = raycaster.params.Points.threshold;\n\t\tconst drawRange = geometry.drawRange;\n\n\t\t// Checking boundingSphere distance to ray\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere );\n\t\t_sphere.applyMatrix4( matrixWorld );\n\t\t_sphere.radius += threshold;\n\n\t\tif ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;\n\n\t\t//\n\n\t\t_inverseMatrix.copy( matrixWorld ).invert();\n\t\t_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );\n\n\t\tconst localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\n\t\tconst localThresholdSq = localThreshold * localThreshold;\n\n\t\tconst index = geometry.index;\n\t\tconst attributes = geometry.attributes;\n\t\tconst positionAttribute = attributes.position;\n\n\t\tif ( index !== null ) {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, il = end; i < il; i ++ ) {\n\n\t\t\t\tconst a = index.getX( i );\n\n\t\t\t\t_position$2.fromBufferAttribute( positionAttribute, a );\n\n\t\t\t\ttestPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst start = Math.max( 0, drawRange.start );\n\t\t\tconst end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( let i = start, l = end; i < l; i ++ ) {\n\n\t\t\t\t_position$2.fromBufferAttribute( positionAttribute, i );\n\n\t\t\t\ttestPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tupdateMorphTargets() {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst morphAttributes = geometry.morphAttributes;\n\t\tconst keys = Object.keys( morphAttributes );\n\n\t\tif ( keys.length > 0 ) {\n\n\t\t\tconst morphAttribute = morphAttributes[ keys[ 0 ] ];\n\n\t\t\tif ( morphAttribute !== undefined ) {\n\n\t\t\t\tthis.morphTargetInfluences = [];\n\t\t\t\tthis.morphTargetDictionary = {};\n\n\t\t\t\tfor ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\n\n\t\t\t\t\tconst name = morphAttribute[ m ].name || String( m );\n\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\t\t\tthis.morphTargetDictionary[ name ] = m;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\nfunction testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {\n\n\tconst rayPointDistanceSq = _ray.distanceSqToPoint( point );\n\n\tif ( rayPointDistanceSq < localThresholdSq ) {\n\n\t\tconst intersectPoint = new Vector3();\n\n\t\t_ray.closestPointToPoint( point, intersectPoint );\n\t\tintersectPoint.applyMatrix4( matrixWorld );\n\n\t\tconst distance = raycaster.ray.origin.distanceTo( intersectPoint );\n\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\n\n\t\tintersects.push( {\n\n\t\t\tdistance: distance,\n\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\n\t\t\tpoint: intersectPoint,\n\t\t\tindex: index,\n\t\t\tface: null,\n\t\t\tobject: object\n\n\t\t} );\n\n\t}\n\n}\n\nclass VideoTexture extends Texture {\n\n\tconstructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tsuper( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.isVideoTexture = true;\n\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\n\t\tthis.generateMipmaps = false;\n\n\t\tconst scope = this;\n\n\t\tfunction updateVideo() {\n\n\t\t\tscope.needsUpdate = true;\n\t\t\tvideo.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t\tif ( 'requestVideoFrameCallback' in video ) {\n\n\t\t\tvideo.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.image ).copy( this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst video = this.image;\n\t\tconst hasVideoFrameCallback = 'requestVideoFrameCallback' in video;\n\n\t\tif ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass FramebufferTexture extends Texture {\n\n\tconstructor( width, height ) {\n\n\t\tsuper( { width, height } );\n\n\t\tthis.isFramebufferTexture = true;\n\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.minFilter = NearestFilter;\n\n\t\tthis.generateMipmaps = false;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nclass CompressedTexture extends Texture {\n\n\tconstructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace ) {\n\n\t\tsuper( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace );\n\n\t\tthis.isCompressedTexture = true;\n\n\t\tthis.image = { width: width, height: height };\n\t\tthis.mipmaps = mipmaps;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\tthis.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\tthis.generateMipmaps = false;\n\n\t}\n\n}\n\nclass CompressedArrayTexture extends CompressedTexture {\n\n\tconstructor( mipmaps, width, height, depth, format, type ) {\n\n\t\tsuper( mipmaps, width, height, format, type );\n\n\t\tthis.isCompressedArrayTexture = true;\n\t\tthis.image.depth = depth;\n\t\tthis.wrapR = ClampToEdgeWrapping;\n\n\t}\n\n}\n\nclass CanvasTexture extends Texture {\n\n\tconstructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\t\tsuper( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\tthis.isCanvasTexture = true;\n\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\n/**\n * Extensible curve object.\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\nclass Curve {\n\n\tconstructor() {\n\n\t\tthis.type = 'Curve';\n\n\t\tthis.arcLengthDivisions = 200;\n\n\t}\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint( /* t, optionalTarget */ ) {\n\n\t\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\n\t\treturn null;\n\n\t}\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t, optionalTarget );\n\n\t}\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t// Get total curve arc length\n\n\tgetLength() {\n\n\t\tconst lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t}\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths( divisions = this.arcLengthDivisions ) {\n\n\t\tif ( this.cacheArcLengths &&\n\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\n\t\t\t! this.needsUpdate ) {\n\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tconst cache = [];\n\t\tlet current, last = this.getPoint( 0 );\n\t\tlet sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( let p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\n\t}\n\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t}\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping( u, distance ) {\n\n\t\tconst arcLengths = this.getLengths();\n\n\t\tlet i = 0;\n\t\tconst il = arcLengths.length;\n\n\t\tlet targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tlet low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\treturn i / ( il - 1 );\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tconst lengthBefore = arcLengths[ i ];\n\t\tconst lengthAfter = arcLengths[ i + 1 ];\n\n\t\tconst segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tconst segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tconst t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t}\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent( t, optionalTarget ) {\n\n\t\tconst delta = 0.0001;\n\t\tlet t1 = t - delta;\n\t\tlet t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tconst pt1 = this.getPoint( t1 );\n\t\tconst pt2 = this.getPoint( t2 );\n\n\t\tconst tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );\n\n\t\ttangent.copy( pt2 ).sub( pt1 ).normalize();\n\n\t\treturn tangent;\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t, optionalTarget );\n\n\t}\n\n\tcomputeFrenetFrames( segments, closed ) {\n\n\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\tconst normal = new Vector3();\n\n\t\tconst tangents = [];\n\t\tconst normals = [];\n\t\tconst binormals = [];\n\n\t\tconst vec = new Vector3();\n\t\tconst mat = new Matrix4();\n\n\t\t// compute the tangent vectors for each segment on the curve\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst u = i / segments;\n\n\t\t\ttangents[ i ] = this.getTangentAt( u, new Vector3() );\n\n\t\t}\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the minimum tangent xyz component\n\n\t\tnormals[ 0 ] = new Vector3();\n\t\tbinormals[ 0 ] = new Vector3();\n\t\tlet min = Number.MAX_VALUE;\n\t\tconst tx = Math.abs( tangents[ 0 ].x );\n\t\tconst ty = Math.abs( tangents[ 0 ].y );\n\t\tconst tz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= min ) {\n\n\t\t\tmin = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= min ) {\n\n\t\t\tmin = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= min ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\tvec.normalize();\n\n\t\t\t\tconst theta = Math.acos( clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t}\n\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\tif ( closed === true ) {\n\n\t\t\tlet theta = Math.acos( clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\ttheta /= segments;\n\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\ttheta = - theta;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t// twist a little...\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\ttangents: tangents,\n\t\t\tnormals: normals,\n\t\t\tbinormals: binormals\n\t\t};\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.6,\n\t\t\t\ttype: 'Curve',\n\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t}\n\t\t};\n\n\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\tdata.type = this.type;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass EllipseCurve extends Curve {\n\n\tconstructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.isEllipseCurve = true;\n\n\t\tthis.type = 'EllipseCurve';\n\n\t\tthis.aX = aX;\n\t\tthis.aY = aY;\n\n\t\tthis.xRadius = xRadius;\n\t\tthis.yRadius = yRadius;\n\n\t\tthis.aStartAngle = aStartAngle;\n\t\tthis.aEndAngle = aEndAngle;\n\n\t\tthis.aClockwise = aClockwise;\n\n\t\tthis.aRotation = aRotation;\n\n\t}\n\n\tgetPoint( t, optionalTarget ) {\n\n\t\tconst point = optionalTarget || new Vector2();\n\n\t\tconst twoPi = Math.PI * 2;\n\t\tlet deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\tconst samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n\t\tif ( deltaAngle < Number.EPSILON ) {\n\n\t\t\tif ( samePoints ) {\n\n\t\t\t\tdeltaAngle = 0;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.aClockwise === true && ! samePoints ) {\n\n\t\t\tif ( deltaAngle === twoPi ) {\n\n\t\t\t\tdeltaAngle = - twoPi;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst angle = this.aStartAngle + t * deltaAngle;\n\t\tlet x = this.aX + this.xRadius * Math.cos( angle );\n\t\tlet y = this.aY + this.yRadius * Math.sin( angle );\n\n\t\tif ( this.aRotation !== 0 ) {\n\n\t\t\tconst cos = Math.cos( this.aRotation );\n\t\t\tconst sin = Math.sin( this.aRotation );\n\n\t\t\tconst tx = x - this.aX;\n\t\t\tconst ty = y - this.aY;\n\n\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\ty = tx * sin + ty * cos + this.aY;\n\n\t\t}\n\n\t\treturn point.set( x, y );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.aX = source.aX;\n\t\tthis.aY = source.aY;\n\n\t\tthis.xRadius = source.xRadius;\n\t\tthis.yRadius = source.yRadius;\n\n\t\tthis.aStartAngle = source.aStartAngle;\n\t\tthis.aEndAngle = source.aEndAngle;\n\n\t\tthis.aClockwise = source.aClockwise;\n\n\t\tthis.aRotation = source.aRotation;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.aX = this.aX;\n\t\tdata.aY = this.aY;\n\n\t\tdata.xRadius = this.xRadius;\n\t\tdata.yRadius = this.yRadius;\n\n\t\tdata.aStartAngle = this.aStartAngle;\n\t\tdata.aEndAngle = this.aEndAngle;\n\n\t\tdata.aClockwise = this.aClockwise;\n\n\t\tdata.aRotation = this.aRotation;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.aX = json.aX;\n\t\tthis.aY = json.aY;\n\n\t\tthis.xRadius = json.xRadius;\n\t\tthis.yRadius = json.yRadius;\n\n\t\tthis.aStartAngle = json.aStartAngle;\n\t\tthis.aEndAngle = json.aEndAngle;\n\n\t\tthis.aClockwise = json.aClockwise;\n\n\t\tthis.aRotation = json.aRotation;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass ArcCurve extends EllipseCurve {\n\n\tconstructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tsuper( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\tthis.isArcCurve = true;\n\n\t\tthis.type = 'ArcCurve';\n\n\t}\n\n}\n\n/**\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\n\n/*\nBased on an optimized c++ solution in\n - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n - http://ideone.com/NoEbVM\n\nThis CubicPoly class could be used for reusing some variables and calculations,\nbut for three.js curve use, it could be possible inlined and flatten into a single function call\nwhich can be placed in CurveUtils.\n*/\n\nfunction CubicPoly() {\n\n\tlet c0 = 0, c1 = 0, c2 = 0, c3 = 0;\n\n\t/*\n\t * Compute coefficients for a cubic polynomial\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t * such that\n\t *   p(0) = x0, p(1) = x1\n\t *  and\n\t *   p'(0) = t0, p'(1) = t1.\n\t */\n\tfunction init( x0, x1, t0, t1 ) {\n\n\t\tc0 = x0;\n\t\tc1 = t0;\n\t\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t}\n\n\treturn {\n\n\t\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\n\n\t\t\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t\t},\n\n\t\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\tlet t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\tlet t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\tt1 *= dt1;\n\t\t\tt2 *= dt1;\n\n\t\t\tinit( x1, x2, t1, t2 );\n\n\t\t},\n\n\t\tcalc: function ( t ) {\n\n\t\t\tconst t2 = t * t;\n\t\t\tconst t3 = t2 * t;\n\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\n\n\t\t}\n\n\t};\n\n}\n\n//\n\nconst tmp = /*@__PURE__*/ new Vector3();\nconst px = /*@__PURE__*/ new CubicPoly();\nconst py = /*@__PURE__*/ new CubicPoly();\nconst pz = /*@__PURE__*/ new CubicPoly();\n\nclass CatmullRomCurve3 extends Curve {\n\n\tconstructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {\n\n\t\tsuper();\n\n\t\tthis.isCatmullRomCurve3 = true;\n\n\t\tthis.type = 'CatmullRomCurve3';\n\n\t\tthis.points = points;\n\t\tthis.closed = closed;\n\t\tthis.curveType = curveType;\n\t\tthis.tension = tension;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst points = this.points;\n\t\tconst l = points.length;\n\n\t\tconst p = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\tlet intPoint = Math.floor( p );\n\t\tlet weight = p - intPoint;\n\n\t\tif ( this.closed ) {\n\n\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;\n\n\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\tintPoint = l - 2;\n\t\t\tweight = 1;\n\n\t\t}\n\n\t\tlet p0, p3; // 4 points (p1 & p2 defined below)\n\n\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate first point\n\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\tp0 = tmp;\n\n\t\t}\n\n\t\tconst p1 = points[ intPoint % l ];\n\t\tconst p2 = points[ ( intPoint + 1 ) % l ];\n\n\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate last point\n\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\tp3 = tmp;\n\n\t\t}\n\n\t\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\n\n\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\tconst pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n\t\t\tlet dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\tlet dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\tlet dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t// safety check for repeated points\n\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t} else if ( this.curveType === 'catmullrom' ) {\n\n\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\n\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\n\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\n\n\t\t}\n\n\t\tpoint.set(\n\t\t\tpx.calc( weight ),\n\t\t\tpy.calc( weight ),\n\t\t\tpz.calc( weight )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\tthis.closed = source.closed;\n\t\tthis.curveType = source.curveType;\n\t\tthis.tension = source.tension;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.points = [];\n\n\t\tfor ( let i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\tdata.closed = this.closed;\n\t\tdata.curveType = this.curveType;\n\t\tdata.tension = this.tension;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = json.points[ i ];\n\t\t\tthis.points.push( new Vector3().fromArray( point ) );\n\n\t\t}\n\n\t\tthis.closed = json.closed;\n\t\tthis.curveType = json.curveType;\n\t\tthis.tension = json.tension;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * Bezier Curves formulas obtained from\n * https://en.wikipedia.org/wiki/B%C3%A9zier_curve\n */\n\nfunction CatmullRom( t, p0, p1, p2, p3 ) {\n\n\tconst v0 = ( p2 - p0 ) * 0.5;\n\tconst v1 = ( p3 - p1 ) * 0.5;\n\tconst t2 = t * t;\n\tconst t3 = t * t2;\n\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n}\n\n//\n\nfunction QuadraticBezierP0( t, p ) {\n\n\tconst k = 1 - t;\n\treturn k * k * p;\n\n}\n\nfunction QuadraticBezierP1( t, p ) {\n\n\treturn 2 * ( 1 - t ) * t * p;\n\n}\n\nfunction QuadraticBezierP2( t, p ) {\n\n\treturn t * t * p;\n\n}\n\nfunction QuadraticBezier( t, p0, p1, p2 ) {\n\n\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\n\t\tQuadraticBezierP2( t, p2 );\n\n}\n\n//\n\nfunction CubicBezierP0( t, p ) {\n\n\tconst k = 1 - t;\n\treturn k * k * k * p;\n\n}\n\nfunction CubicBezierP1( t, p ) {\n\n\tconst k = 1 - t;\n\treturn 3 * k * k * t * p;\n\n}\n\nfunction CubicBezierP2( t, p ) {\n\n\treturn 3 * ( 1 - t ) * t * t * p;\n\n}\n\nfunction CubicBezierP3( t, p ) {\n\n\treturn t * t * t * p;\n\n}\n\nfunction CubicBezier( t, p0, p1, p2, p3 ) {\n\n\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\n\t\tCubicBezierP3( t, p3 );\n\n}\n\nclass CubicBezierCurve extends Curve {\n\n\tconstructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.isCubicBezierCurve = true;\n\n\t\tthis.type = 'CubicBezierCurve';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass CubicBezierCurve3 extends Curve {\n\n\tconstructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.isCubicBezierCurve3 = true;\n\n\t\tthis.type = 'CubicBezierCurve3';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\n\t\t\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineCurve extends Curve {\n\n\tconstructor( v1 = new Vector2(), v2 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.isLineCurve = true;\n\n\t\tthis.type = 'LineCurve';\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t}\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\tgetPointAt( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t}\n\n\tgetTangent( t, optionalTarget = new Vector2() ) {\n\n\t\treturn optionalTarget.subVectors( this.v2, this.v1 ).normalize();\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\treturn this.getTangent( u, optionalTarget );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineCurve3 extends Curve {\n\n\tconstructor( v1 = new Vector3(), v2 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.isLineCurve3 = true;\n\n\t\tthis.type = 'LineCurve3';\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t}\n\t// Line curve is linear, so we can overwrite default getPointAt\n\tgetPointAt( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t}\n\n\tgetTangent( t, optionalTarget = new Vector3() ) {\n\n\t\treturn optionalTarget.subVectors( this.v2, this.v1 ).normalize();\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\treturn this.getTangent( u, optionalTarget );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass QuadraticBezierCurve extends Curve {\n\n\tconstructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.isQuadraticBezierCurve = true;\n\n\t\tthis.type = 'QuadraticBezierCurve';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass QuadraticBezierCurve3 extends Curve {\n\n\tconstructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.isQuadraticBezierCurve3 = true;\n\n\t\tthis.type = 'QuadraticBezierCurve3';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\n\t\t\tQuadraticBezier( t, v0.z, v1.z, v2.z )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass SplineCurve extends Curve {\n\n\tconstructor( points = [] ) {\n\n\t\tsuper();\n\n\t\tthis.isSplineCurve = true;\n\n\t\tthis.type = 'SplineCurve';\n\n\t\tthis.points = points;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst points = this.points;\n\t\tconst p = ( points.length - 1 ) * t;\n\n\t\tconst intPoint = Math.floor( p );\n\t\tconst weight = p - intPoint;\n\n\t\tconst p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\tconst p1 = points[ intPoint ];\n\t\tconst p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tconst p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tpoint.set(\n\t\t\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\n\t\t\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.points = [];\n\n\t\tfor ( let i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = json.points[ i ];\n\t\t\tthis.points.push( new Vector2().fromArray( point ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nvar Curves = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tArcCurve: ArcCurve,\n\tCatmullRomCurve3: CatmullRomCurve3,\n\tCubicBezierCurve: CubicBezierCurve,\n\tCubicBezierCurve3: CubicBezierCurve3,\n\tEllipseCurve: EllipseCurve,\n\tLineCurve: LineCurve,\n\tLineCurve3: LineCurve3,\n\tQuadraticBezierCurve: QuadraticBezierCurve,\n\tQuadraticBezierCurve3: QuadraticBezierCurve3,\n\tSplineCurve: SplineCurve\n});\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nclass CurvePath extends Curve {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'CurvePath';\n\n\t\tthis.curves = [];\n\t\tthis.autoClose = false; // Automatically closes the path\n\n\t}\n\n\tadd( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t}\n\n\tclosePath() {\n\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tconst startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tconst endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\n\n\t\t}\n\n\t}\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint( t, optionalTarget ) {\n\n\t\tconst d = t * this.getLength();\n\t\tconst curveLengths = this.getCurveLengths();\n\t\tlet i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tconst diff = curveLengths[ i ] - d;\n\t\t\t\tconst curve = this.curves[ i ];\n\n\t\t\t\tconst segmentLength = curve.getLength();\n\t\t\t\tconst u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\treturn curve.getPointAt( u, optionalTarget );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t}\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength() {\n\n\t\tconst lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t}\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getCurveLengths();\n\n\t}\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths() {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tconst lengths = [];\n\t\tlet sums = 0;\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t}\n\n\tgetSpacedPoints( divisions = 40 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let i = 0; i <= divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tgetPoints( divisions = 12 ) {\n\n\t\tconst points = [];\n\t\tlet last;\n\n\t\tfor ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\tconst curve = curves[ i ];\n\t\t\tconst resolution = curve.isEllipseCurve ? divisions * 2\n\t\t\t\t: ( curve.isLineCurve || curve.isLineCurve3 ) ? 1\n\t\t\t\t\t: curve.isSplineCurve ? divisions * curve.points.length\n\t\t\t\t\t\t: divisions;\n\n\t\t\tconst pts = curve.getPoints( resolution );\n\n\t\t\tfor ( let j = 0; j < pts.length; j ++ ) {\n\n\t\t\t\tconst point = pts[ j ];\n\n\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\tpoints.push( point );\n\t\t\t\tlast = point;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = source.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = source.curves[ i ];\n\n\t\t\tthis.curves.push( curve.clone() );\n\n\t\t}\n\n\t\tthis.autoClose = source.autoClose;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.autoClose = this.autoClose;\n\t\tdata.curves = [];\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = this.curves[ i ];\n\t\t\tdata.curves.push( curve.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.autoClose = json.autoClose;\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = json.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = json.curves[ i ];\n\t\t\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Path extends CurvePath {\n\n\tconstructor( points ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Path';\n\n\t\tthis.currentPoint = new Vector2();\n\n\t\tif ( points ) {\n\n\t\t\tthis.setFromPoints( points );\n\n\t\t}\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\n\n\t\tfor ( let i = 1, l = points.length; i < l; i ++ ) {\n\n\t\t\tthis.lineTo( points[ i ].x, points[ i ].y );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t\treturn this;\n\n\t}\n\n\tlineTo( x, y ) {\n\n\t\tconst curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tconst curve = new QuadraticBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tconst curve = new CubicBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tsplineThru( pts /*Array of Vector*/ ) {\n\n\t\tconst npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\tconst curve = new SplineCurve( npts );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t\treturn this;\n\n\t}\n\n\tarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\tabsarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\tellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\treturn this;\n\n\t}\n\n\tabsellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t// if a previous curve is present, attempt to join\n\t\t\tconst firstPoint = curve.getPoint( 0 );\n\n\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.curves.push( curve );\n\n\t\tconst lastPoint = curve.getPoint( 1 );\n\t\tthis.currentPoint.copy( lastPoint );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.currentPoint.copy( source.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.currentPoint = this.currentPoint.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.currentPoint.fromArray( json.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LatheGeometry extends BufferGeometry {\n\n\tconstructor( points = [ new Vector2( 0, - 0.5 ), new Vector2( 0.5, 0 ), new Vector2( 0, 0.5 ) ], segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LatheGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tsegments = Math.floor( segments );\n\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\n\t\tphiLength = clamp( phiLength, 0, Math.PI * 2 );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst uvs = [];\n\t\tconst initNormals = [];\n\t\tconst normals = [];\n\n\t\t// helper variables\n\n\t\tconst inverseSegments = 1.0 / segments;\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tconst normal = new Vector3();\n\t\tconst curNormal = new Vector3();\n\t\tconst prevNormal = new Vector3();\n\t\tlet dx = 0;\n\t\tlet dy = 0;\n\n\t\t// pre-compute normals for initial \"meridian\"\n\n\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\tswitch ( j ) {\n\n\t\t\t\tcase 0:\t\t\t\t// special handling for 1st vertex on path\n\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\n\n\t\t\t\t\tnormal.x = dy * 1.0;\n\t\t\t\t\tnormal.y = - dx;\n\t\t\t\t\tnormal.z = dy * 0.0;\n\n\t\t\t\t\tprevNormal.copy( normal );\n\n\t\t\t\t\tnormal.normalize();\n\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ( points.length - 1 ):\t// special handling for last Vertex on path\n\n\t\t\t\t\tinitNormals.push( prevNormal.x, prevNormal.y, prevNormal.z );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\t\t\t// default handling for all vertices in between\n\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\n\n\t\t\t\t\tnormal.x = dy * 1.0;\n\t\t\t\t\tnormal.y = - dx;\n\t\t\t\t\tnormal.z = dy * 0.0;\n\n\t\t\t\t\tcurNormal.copy( normal );\n\n\t\t\t\t\tnormal.x += prevNormal.x;\n\t\t\t\t\tnormal.y += prevNormal.y;\n\t\t\t\t\tnormal.z += prevNormal.z;\n\n\t\t\t\t\tnormal.normalize();\n\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\tprevNormal.copy( curNormal );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate vertices, uvs and normals\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst phi = phiStart + i * inverseSegments * phiLength;\n\n\t\t\tconst sin = Math.sin( phi );\n\t\t\tconst cos = Math.cos( phi );\n\n\t\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// normal\n\n\t\t\t\tconst x = initNormals[ 3 * j + 0 ] * sin;\n\t\t\t\tconst y = initNormals[ 3 * j + 1 ];\n\t\t\t\tconst z = initNormals[ 3 * j + 0 ] * cos;\n\n\t\t\t\tnormals.push( x, y, z );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 0; i < segments; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\t\tconst base = j + i * points.length;\n\n\t\t\t\tconst a = base;\n\t\t\t\tconst b = base + points.length;\n\t\t\t\tconst c = base + points.length + 1;\n\t\t\t\tconst d = base + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( c, d, b );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new LatheGeometry( data.points, data.segments, data.phiStart, data.phiLength );\n\n\t}\n\n}\n\nclass CapsuleGeometry extends LatheGeometry {\n\n\tconstructor( radius = 1, length = 1, capSegments = 4, radialSegments = 8 ) {\n\n\t\tconst path = new Path();\n\t\tpath.absarc( 0, - length / 2, radius, Math.PI * 1.5, 0 );\n\t\tpath.absarc( 0, length / 2, radius, 0, Math.PI * 0.5 );\n\n\t\tsuper( path.getPoints( capSegments ), radialSegments );\n\n\t\tthis.type = 'CapsuleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: length,\n\t\t\tcapSegments: capSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CapsuleGeometry( data.radius, data.length, data.capSegments, data.radialSegments );\n\n\t}\n\n}\n\nclass CircleGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CircleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tsegments: segments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tsegments = Math.max( 3, segments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// center point\n\n\t\tvertices.push( 0, 0, 0 );\n\t\tnormals.push( 0, 0, 1 );\n\t\tuvs.push( 0.5, 0.5 );\n\n\t\tfor ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {\n\n\t\t\tconst segment = thetaStart + s / segments * thetaLength;\n\n\t\t\t// vertex\n\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t// normal\n\n\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t// uvs\n\n\t\t\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\n\t\t\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\n\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tindices.push( i, i + 1, 0 );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CircleGeometry( data.radius, data.segments, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass CylinderGeometry extends BufferGeometry {\n\n\tconstructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CylinderGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradiusTop: radiusTop,\n\t\t\tradiusBottom: radiusBottom,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tconst scope = this;\n\n\t\tradialSegments = Math.floor( radialSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet index = 0;\n\t\tconst indexArray = [];\n\t\tconst halfHeight = height / 2;\n\t\tlet groupStart = 0;\n\n\t\t// generate geometry\n\n\t\tgenerateTorso();\n\n\t\tif ( openEnded === false ) {\n\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction generateTorso() {\n\n\t\t\tconst normal = new Vector3();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\t// this will be used to calculate the normal\n\t\t\tconst slope = ( radiusBottom - radiusTop ) / height;\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let y = 0; y <= heightSegments; y ++ ) {\n\n\t\t\t\tconst indexRow = [];\n\n\t\t\t\tconst v = y / heightSegments;\n\n\t\t\t\t// calculate the radius of the current row\n\n\t\t\t\tconst radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\t\tconst u = x / radialSegments;\n\n\t\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\t\tconst sinTheta = Math.sin( theta );\n\t\t\t\t\tconst cosTheta = Math.cos( theta );\n\n\t\t\t\t\t// vertex\n\n\t\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\n\t\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t\t// normal\n\n\t\t\t\t\tnormal.set( sinTheta, slope, cosTheta ).normalize();\n\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\t// uv\n\n\t\t\t\t\tuvs.push( u, 1 - v );\n\n\t\t\t\t\t// save index of vertex in respective row\n\n\t\t\t\t\tindexRow.push( index ++ );\n\n\t\t\t\t}\n\n\t\t\t\t// now save vertices of the row in our index array\n\n\t\t\t\tindexArray.push( indexRow );\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tfor ( let y = 0; y < heightSegments; y ++ ) {\n\n\t\t\t\t\t// we use the index array to access the correct indices\n\n\t\t\t\t\tconst a = indexArray[ y ][ x ];\n\t\t\t\t\tconst b = indexArray[ y + 1 ][ x ];\n\t\t\t\t\tconst c = indexArray[ y + 1 ][ x + 1 ];\n\t\t\t\t\tconst d = indexArray[ y ][ x + 1 ];\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// update group counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t\tfunction generateCap( top ) {\n\n\t\t\t// save the index of the first center vertex\n\t\t\tconst centerIndexStart = index;\n\n\t\t\tconst uv = new Vector2();\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst radius = ( top === true ) ? radiusTop : radiusBottom;\n\t\t\tconst sign = ( top === true ) ? 1 : - 1;\n\n\t\t\t// first we generate the center vertex data of the cap.\n\t\t\t// because the geometry needs one set of uvs per face,\n\t\t\t// we must generate a center vertex per face/segment\n\n\t\t\tfor ( let x = 1; x <= radialSegments; x ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertices.push( 0, halfHeight * sign, 0 );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( 0.5, 0.5 );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// save the index of the last center vertex\n\t\t\tconst centerIndexEnd = index;\n\n\t\t\t// now we generate the surrounding vertices, normals and uvs\n\n\t\t\tfor ( let x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\t\tconst u = x / radialSegments;\n\t\t\t\tconst theta = u * thetaLength + thetaStart;\n\n\t\t\t\tconst cosTheta = Math.cos( theta );\n\t\t\t\tconst sinTheta = Math.sin( theta );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * sinTheta;\n\t\t\t\tvertex.y = halfHeight * sign;\n\t\t\t\tvertex.z = radius * cosTheta;\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, sign, 0 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// increase index\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\t// generate indices\n\n\t\t\tfor ( let x = 0; x < radialSegments; x ++ ) {\n\n\t\t\t\tconst c = centerIndexStart + x;\n\t\t\t\tconst i = centerIndexEnd + x;\n\n\t\t\t\tif ( top === true ) {\n\n\t\t\t\t\t// face top\n\n\t\t\t\t\tindices.push( i, i + 1, c );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// face bottom\n\n\t\t\t\t\tindices.push( i + 1, i, c );\n\n\t\t\t\t}\n\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass ConeGeometry extends CylinderGeometry {\n\n\tconstructor( radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\n\n\t\tthis.type = 'ConeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: height,\n\t\t\tradialSegments: radialSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\topenEnded: openEnded,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new ConeGeometry( data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass PolyhedronGeometry extends BufferGeometry {\n\n\tconstructor( vertices = [], indices = [], radius = 1, detail = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PolyhedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tvertices: vertices,\n\t\t\tindices: indices,\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t\t// default buffer data\n\n\t\tconst vertexBuffer = [];\n\t\tconst uvBuffer = [];\n\n\t\t// the subdivision creates the vertex buffer data\n\n\t\tsubdivide( detail );\n\n\t\t// all vertices should lie on a conceptual sphere with a given radius\n\n\t\tapplyRadius( radius );\n\n\t\t// finally, create the uv data\n\n\t\tgenerateUVs();\n\n\t\t// build non-indexed geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\n\n\t\tif ( detail === 0 ) {\n\n\t\t\tthis.computeVertexNormals(); // flat normals\n\n\t\t} else {\n\n\t\t\tthis.normalizeNormals(); // smooth normals\n\n\t\t}\n\n\t\t// helper functions\n\n\t\tfunction subdivide( detail ) {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\t// iterate over all faces and apply a subdivision with the given detail value\n\n\t\t\tfor ( let i = 0; i < indices.length; i += 3 ) {\n\n\t\t\t\t// get the vertices of the face\n\n\t\t\t\tgetVertexByIndex( indices[ i + 0 ], a );\n\t\t\t\tgetVertexByIndex( indices[ i + 1 ], b );\n\t\t\t\tgetVertexByIndex( indices[ i + 2 ], c );\n\n\t\t\t\t// perform subdivision\n\n\t\t\t\tsubdivideFace( a, b, c, detail );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction subdivideFace( a, b, c, detail ) {\n\n\t\t\tconst cols = detail + 1;\n\n\t\t\t// we use this multidimensional array as a data structure for creating the subdivision\n\n\t\t\tconst v = [];\n\n\t\t\t// construct all of the vertices for this subdivision\n\n\t\t\tfor ( let i = 0; i <= cols; i ++ ) {\n\n\t\t\t\tv[ i ] = [];\n\n\t\t\t\tconst aj = a.clone().lerp( c, i / cols );\n\t\t\t\tconst bj = b.clone().lerp( c, i / cols );\n\n\t\t\t\tconst rows = cols - i;\n\n\t\t\t\tfor ( let j = 0; j <= rows; j ++ ) {\n\n\t\t\t\t\tif ( j === 0 && i === cols ) {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// construct all of the faces\n\n\t\t\tfor ( let i = 0; i < cols; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\n\n\t\t\t\t\tconst k = Math.floor( j / 2 );\n\n\t\t\t\t\tif ( j % 2 === 0 ) {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\t\t\t\t\t\tpushVertex( v[ i ][ k ] );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpushVertex( v[ i ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k + 1 ] );\n\t\t\t\t\t\tpushVertex( v[ i + 1 ][ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction applyRadius( radius ) {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\t// iterate over the entire buffer and apply the radius to each vertex\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tvertex.normalize().multiplyScalar( radius );\n\n\t\t\t\tvertexBuffer[ i + 0 ] = vertex.x;\n\t\t\t\tvertexBuffer[ i + 1 ] = vertex.y;\n\t\t\t\tvertexBuffer[ i + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tconst vertex = new Vector3();\n\n\t\t\tfor ( let i = 0; i < vertexBuffer.length; i += 3 ) {\n\n\t\t\t\tvertex.x = vertexBuffer[ i + 0 ];\n\t\t\t\tvertex.y = vertexBuffer[ i + 1 ];\n\t\t\t\tvertex.z = vertexBuffer[ i + 2 ];\n\n\t\t\t\tconst u = azimuth( vertex ) / 2 / Math.PI + 0.5;\n\t\t\t\tconst v = inclination( vertex ) / Math.PI + 0.5;\n\t\t\t\tuvBuffer.push( u, 1 - v );\n\n\t\t\t}\n\n\t\t\tcorrectUVs();\n\n\t\t\tcorrectSeam();\n\n\t\t}\n\n\t\tfunction correctSeam() {\n\n\t\t\t// handle case when face straddles the seam, see #3269\n\n\t\t\tfor ( let i = 0; i < uvBuffer.length; i += 6 ) {\n\n\t\t\t\t// uv data of a single face\n\n\t\t\t\tconst x0 = uvBuffer[ i + 0 ];\n\t\t\t\tconst x1 = uvBuffer[ i + 2 ];\n\t\t\t\tconst x2 = uvBuffer[ i + 4 ];\n\n\t\t\t\tconst max = Math.max( x0, x1, x2 );\n\t\t\t\tconst min = Math.min( x0, x1, x2 );\n\n\t\t\t\t// 0.9 is somewhat arbitrary\n\n\t\t\t\tif ( max > 0.9 && min < 0.1 ) {\n\n\t\t\t\t\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\n\t\t\t\t\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\n\t\t\t\t\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction pushVertex( vertex ) {\n\n\t\t\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tfunction getVertexByIndex( index, vertex ) {\n\n\t\t\tconst stride = index * 3;\n\n\t\t\tvertex.x = vertices[ stride + 0 ];\n\t\t\tvertex.y = vertices[ stride + 1 ];\n\t\t\tvertex.z = vertices[ stride + 2 ];\n\n\t\t}\n\n\t\tfunction correctUVs() {\n\n\t\t\tconst a = new Vector3();\n\t\t\tconst b = new Vector3();\n\t\t\tconst c = new Vector3();\n\n\t\t\tconst centroid = new Vector3();\n\n\t\t\tconst uvA = new Vector2();\n\t\t\tconst uvB = new Vector2();\n\t\t\tconst uvC = new Vector2();\n\n\t\t\tfor ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\n\n\t\t\t\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\n\t\t\t\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\n\t\t\t\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\n\n\t\t\t\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\n\t\t\t\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\n\t\t\t\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\n\n\t\t\t\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\n\n\t\t\t\tconst azi = azimuth( centroid );\n\n\t\t\t\tcorrectUV( uvA, j + 0, a, azi );\n\t\t\t\tcorrectUV( uvB, j + 2, b, azi );\n\t\t\t\tcorrectUV( uvC, j + 4, c, azi );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction correctUV( uv, stride, vector, azimuth ) {\n\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = uv.x - 1;\n\n\t\t\t}\n\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\n\n\t\t\t\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\t\tfunction azimuth( vector ) {\n\n\t\t\treturn Math.atan2( vector.z, - vector.x );\n\n\t\t}\n\n\n\t\t// Angle above the XZ plane.\n\n\t\tfunction inclination( vector ) {\n\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );\n\n\t}\n\n}\n\nclass DodecahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\t\tconst r = 1 / t;\n\n\t\tconst vertices = [\n\n\t\t\t// (1, 1, 1)\n\t\t\t- 1, - 1, - 1,\t- 1, - 1, 1,\n\t\t\t- 1, 1, - 1, - 1, 1, 1,\n\t\t\t1, - 1, - 1, 1, - 1, 1,\n\t\t\t1, 1, - 1, 1, 1, 1,\n\n\t\t\t// (0, 1/, )\n\t\t\t0, - r, - t, 0, - r, t,\n\t\t\t0, r, - t, 0, r, t,\n\n\t\t\t// (1/, , 0)\n\t\t\t- r, - t, 0, - r, t, 0,\n\t\t\tr, - t, 0, r, t, 0,\n\n\t\t\t// (, 0, 1/)\n\t\t\t- t, 0, - r, t, 0, - r,\n\t\t\t- t, 0, r, t, 0, r\n\t\t];\n\n\t\tconst indices = [\n\t\t\t3, 11, 7, \t3, 7, 15, \t3, 15, 13,\n\t\t\t7, 19, 17, \t7, 17, 6, \t7, 6, 15,\n\t\t\t17, 4, 8, \t17, 8, 10, \t17, 10, 6,\n\t\t\t8, 0, 16, \t8, 16, 2, \t8, 2, 10,\n\t\t\t0, 12, 1, \t0, 1, 18, \t0, 18, 16,\n\t\t\t6, 10, 2, \t6, 2, 13, \t6, 13, 15,\n\t\t\t2, 16, 18, \t2, 18, 3, \t2, 3, 13,\n\t\t\t18, 1, 9, \t18, 9, 11, \t18, 11, 3,\n\t\t\t4, 14, 12, \t4, 12, 0, \t4, 0, 8,\n\t\t\t11, 9, 5, \t11, 5, 19, \t11, 19, 7,\n\t\t\t19, 5, 14, \t19, 14, 4, \t19, 4, 17,\n\t\t\t1, 12, 14, \t1, 14, 5, \t1, 5, 9\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'DodecahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new DodecahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nconst _v0 = /*@__PURE__*/ new Vector3();\nconst _v1$1 = /*@__PURE__*/ new Vector3();\nconst _normal = /*@__PURE__*/ new Vector3();\nconst _triangle = /*@__PURE__*/ new Triangle();\n\nclass EdgesGeometry extends BufferGeometry {\n\n\tconstructor( geometry = null, thresholdAngle = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'EdgesGeometry';\n\n\t\tthis.parameters = {\n\t\t\tgeometry: geometry,\n\t\t\tthresholdAngle: thresholdAngle\n\t\t};\n\n\t\tif ( geometry !== null ) {\n\n\t\t\tconst precisionPoints = 4;\n\t\t\tconst precision = Math.pow( 10, precisionPoints );\n\t\t\tconst thresholdDot = Math.cos( DEG2RAD * thresholdAngle );\n\n\t\t\tconst indexAttr = geometry.getIndex();\n\t\t\tconst positionAttr = geometry.getAttribute( 'position' );\n\t\t\tconst indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n\n\t\t\tconst indexArr = [ 0, 0, 0 ];\n\t\t\tconst vertKeys = [ 'a', 'b', 'c' ];\n\t\t\tconst hashes = new Array( 3 );\n\n\t\t\tconst edgeData = {};\n\t\t\tconst vertices = [];\n\t\t\tfor ( let i = 0; i < indexCount; i += 3 ) {\n\n\t\t\t\tif ( indexAttr ) {\n\n\t\t\t\t\tindexArr[ 0 ] = indexAttr.getX( i );\n\t\t\t\t\tindexArr[ 1 ] = indexAttr.getX( i + 1 );\n\t\t\t\t\tindexArr[ 2 ] = indexAttr.getX( i + 2 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindexArr[ 0 ] = i;\n\t\t\t\t\tindexArr[ 1 ] = i + 1;\n\t\t\t\t\tindexArr[ 2 ] = i + 2;\n\n\t\t\t\t}\n\n\t\t\t\tconst { a, b, c } = _triangle;\n\t\t\t\ta.fromBufferAttribute( positionAttr, indexArr[ 0 ] );\n\t\t\t\tb.fromBufferAttribute( positionAttr, indexArr[ 1 ] );\n\t\t\t\tc.fromBufferAttribute( positionAttr, indexArr[ 2 ] );\n\t\t\t\t_triangle.getNormal( _normal );\n\n\t\t\t\t// create hashes for the edge from the vertices\n\t\t\t\thashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;\n\t\t\t\thashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;\n\t\t\t\thashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;\n\n\t\t\t\t// skip degenerate triangles\n\t\t\t\tif ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over every edge\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t// get the first and next vertex making up the edge\n\t\t\t\t\tconst jNext = ( j + 1 ) % 3;\n\t\t\t\t\tconst vecHash0 = hashes[ j ];\n\t\t\t\t\tconst vecHash1 = hashes[ jNext ];\n\t\t\t\t\tconst v0 = _triangle[ vertKeys[ j ] ];\n\t\t\t\t\tconst v1 = _triangle[ vertKeys[ jNext ] ];\n\n\t\t\t\t\tconst hash = `${ vecHash0 }_${ vecHash1 }`;\n\t\t\t\t\tconst reverseHash = `${ vecHash1 }_${ vecHash0 }`;\n\n\t\t\t\t\tif ( reverseHash in edgeData && edgeData[ reverseHash ] ) {\n\n\t\t\t\t\t\t// if we found a sibling edge add it into the vertex array if\n\t\t\t\t\t\t// it meets the angle threshold and delete the edge from the map.\n\t\t\t\t\t\tif ( _normal.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {\n\n\t\t\t\t\t\t\tvertices.push( v0.x, v0.y, v0.z );\n\t\t\t\t\t\t\tvertices.push( v1.x, v1.y, v1.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tedgeData[ reverseHash ] = null;\n\n\t\t\t\t\t} else if ( ! ( hash in edgeData ) ) {\n\n\t\t\t\t\t\t// if we've already got an edge here then skip adding a new one\n\t\t\t\t\t\tedgeData[ hash ] = {\n\n\t\t\t\t\t\t\tindex0: indexArr[ j ],\n\t\t\t\t\t\t\tindex1: indexArr[ jNext ],\n\t\t\t\t\t\t\tnormal: _normal.clone(),\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// iterate over all remaining, unmatched edges and add them to the vertex array\n\t\t\tfor ( const key in edgeData ) {\n\n\t\t\t\tif ( edgeData[ key ] ) {\n\n\t\t\t\t\tconst { index0, index1 } = edgeData[ key ];\n\t\t\t\t\t_v0.fromBufferAttribute( positionAttr, index0 );\n\t\t\t\t\t_v1$1.fromBufferAttribute( positionAttr, index1 );\n\n\t\t\t\t\tvertices.push( _v0.x, _v0.y, _v0.z );\n\t\t\t\t\tvertices.push( _v1$1.x, _v1$1.y, _v1$1.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Shape extends Path {\n\n\tconstructor( points ) {\n\n\t\tsuper( points );\n\n\t\tthis.uuid = generateUUID();\n\n\t\tthis.type = 'Shape';\n\n\t\tthis.holes = [];\n\n\t}\n\n\tgetPointsHoles( divisions ) {\n\n\t\tconst holesPts = [];\n\n\t\tfor ( let i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\n\n\t\t}\n\n\t\treturn holesPts;\n\n\t}\n\n\t// get points of shape and holes (keypoints based on segments parameter)\n\n\textractPoints( divisions ) {\n\n\t\treturn {\n\n\t\t\tshape: this.getPoints( divisions ),\n\t\t\tholes: this.getPointsHoles( divisions )\n\n\t\t};\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.holes = [];\n\n\t\tfor ( let i = 0, l = source.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = source.holes[ i ];\n\n\t\t\tthis.holes.push( hole.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.holes = [];\n\n\t\tfor ( let i = 0, l = this.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = this.holes[ i ];\n\t\t\tdata.holes.push( hole.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.uuid = json.uuid;\n\t\tthis.holes = [];\n\n\t\tfor ( let i = 0, l = json.holes.length; i < l; i ++ ) {\n\n\t\t\tconst hole = json.holes[ i ];\n\t\t\tthis.holes.push( new Path().fromJSON( hole ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * Port from https://github.com/mapbox/earcut (v2.2.4)\n */\n\nconst Earcut = {\n\n\ttriangulate: function ( data, holeIndices, dim = 2 ) {\n\n\t\tconst hasHoles = holeIndices && holeIndices.length;\n\t\tconst outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;\n\t\tlet outerNode = linkedList( data, 0, outerLen, dim, true );\n\t\tconst triangles = [];\n\n\t\tif ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;\n\n\t\tlet minX, minY, maxX, maxY, x, y, invSize;\n\n\t\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\n\n\t\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n\t\tif ( data.length > 80 * dim ) {\n\n\t\t\tminX = maxX = data[ 0 ];\n\t\t\tminY = maxY = data[ 1 ];\n\n\t\t\tfor ( let i = dim; i < outerLen; i += dim ) {\n\n\t\t\t\tx = data[ i ];\n\t\t\t\ty = data[ i + 1 ];\n\t\t\t\tif ( x < minX ) minX = x;\n\t\t\t\tif ( y < minY ) minY = y;\n\t\t\t\tif ( x > maxX ) maxX = x;\n\t\t\t\tif ( y > maxY ) maxY = y;\n\n\t\t\t}\n\n\t\t\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\n\t\t\tinvSize = Math.max( maxX - minX, maxY - minY );\n\t\t\tinvSize = invSize !== 0 ? 32767 / invSize : 0;\n\n\t\t}\n\n\t\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize, 0 );\n\n\t\treturn triangles;\n\n\t}\n\n};\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList( data, start, end, dim, clockwise ) {\n\n\tlet i, last;\n\n\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\n\n\t\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t} else {\n\n\t\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\n\n\t}\n\n\tif ( last && equals( last, last.next ) ) {\n\n\t\tremoveNode( last );\n\t\tlast = last.next;\n\n\t}\n\n\treturn last;\n\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints( start, end ) {\n\n\tif ( ! start ) return start;\n\tif ( ! end ) end = start;\n\n\tlet p = start,\n\t\tagain;\n\tdo {\n\n\t\tagain = false;\n\n\t\tif ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {\n\n\t\t\tremoveNode( p );\n\t\t\tp = end = p.prev;\n\t\t\tif ( p === p.next ) break;\n\t\t\tagain = true;\n\n\t\t} else {\n\n\t\t\tp = p.next;\n\n\t\t}\n\n\t} while ( again || p !== end );\n\n\treturn end;\n\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\n\n\tif ( ! ear ) return;\n\n\t// interlink polygon nodes in z-order\n\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\n\n\tlet stop = ear,\n\t\tprev, next;\n\n\t// iterate through ears, slicing them one by one\n\twhile ( ear.prev !== ear.next ) {\n\n\t\tprev = ear.prev;\n\t\tnext = ear.next;\n\n\t\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\n\n\t\t\t// cut off the triangle\n\t\t\ttriangles.push( prev.i / dim | 0 );\n\t\t\ttriangles.push( ear.i / dim | 0 );\n\t\t\ttriangles.push( next.i / dim | 0 );\n\n\t\t\tremoveNode( ear );\n\n\t\t\t// skipping the next vertex leads to less sliver triangles\n\t\t\tear = next.next;\n\t\t\tstop = next.next;\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tear = next;\n\n\t\t// if we looped through the whole remaining polygon and can't find any more ears\n\t\tif ( ear === stop ) {\n\n\t\t\t// try filtering points and slicing again\n\t\t\tif ( ! pass ) {\n\n\t\t\t\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\n\n\t\t\t\t// if this didn't work, try curing all small self-intersections locally\n\n\t\t\t} else if ( pass === 1 ) {\n\n\t\t\t\tear = cureLocalIntersections( filterPoints( ear ), triangles, dim );\n\t\t\t\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\n\n\t\t\t\t// as a last resort, try splitting the remaining polygon into two\n\n\t\t\t} else if ( pass === 2 ) {\n\n\t\t\t\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar( ear ) {\n\n\tconst a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\t// now make sure we don't have other points inside the potential ear\n\tconst ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n\t// triangle bbox; min & max are calculated like this for speed\n\tconst x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),\n\t\ty0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),\n\t\tx1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),\n\t\ty1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );\n\n\tlet p = c.next;\n\twhile ( p !== a ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) &&\n\t\t\tarea( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.next;\n\n\t}\n\n\treturn true;\n\n}\n\nfunction isEarHashed( ear, minX, minY, invSize ) {\n\n\tconst a = ear.prev,\n\t\tb = ear,\n\t\tc = ear.next;\n\n\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\n\n\tconst ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n\t// triangle bbox; min & max are calculated like this for speed\n\tconst x0 = ax < bx ? ( ax < cx ? ax : cx ) : ( bx < cx ? bx : cx ),\n\t\ty0 = ay < by ? ( ay < cy ? ay : cy ) : ( by < cy ? by : cy ),\n\t\tx1 = ax > bx ? ( ax > cx ? ax : cx ) : ( bx > cx ? bx : cx ),\n\t\ty1 = ay > by ? ( ay > cy ? ay : cy ) : ( by > cy ? by : cy );\n\n\t// z-order range for the current triangle bbox;\n\tconst minZ = zOrder( x0, y0, minX, minY, invSize ),\n\t\tmaxZ = zOrder( x1, y1, minX, minY, invSize );\n\n\tlet p = ear.prevZ,\n\t\tn = ear.nextZ;\n\n\t// look for points inside the triangle in both directions\n\twhile ( p && p.z >= minZ && n && n.z <= maxZ ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t\tif ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\t// look for remaining points in decreasing z-order\n\twhile ( p && p.z >= minZ ) {\n\n\t\tif ( p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) return false;\n\t\tp = p.prevZ;\n\n\t}\n\n\t// look for remaining points in increasing z-order\n\twhile ( n && n.z <= maxZ ) {\n\n\t\tif ( n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n\t\t\tpointInTriangle( ax, ay, bx, by, cx, cy, n.x, n.y ) && area( n.prev, n, n.next ) >= 0 ) return false;\n\t\tn = n.nextZ;\n\n\t}\n\n\treturn true;\n\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections( start, triangles, dim ) {\n\n\tlet p = start;\n\tdo {\n\n\t\tconst a = p.prev,\n\t\t\tb = p.next.next;\n\n\t\tif ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\n\n\t\t\ttriangles.push( a.i / dim | 0 );\n\t\t\ttriangles.push( p.i / dim | 0 );\n\t\t\ttriangles.push( b.i / dim | 0 );\n\n\t\t\t// remove two nodes involved\n\t\t\tremoveNode( p );\n\t\t\tremoveNode( p.next );\n\n\t\t\tp = start = b;\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn filterPoints( p );\n\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\n\n\t// look for a valid diagonal that divides the polygon into two\n\tlet a = start;\n\tdo {\n\n\t\tlet b = a.next.next;\n\t\twhile ( b !== a.prev ) {\n\n\t\t\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\n\n\t\t\t\t// split the polygon in two by the diagonal\n\t\t\t\tlet c = splitPolygon( a, b );\n\n\t\t\t\t// filter colinear points around the cuts\n\t\t\t\ta = filterPoints( a, a.next );\n\t\t\t\tc = filterPoints( c, c.next );\n\n\t\t\t\t// run earcut on each half\n\t\t\t\tearcutLinked( a, triangles, dim, minX, minY, invSize, 0 );\n\t\t\t\tearcutLinked( c, triangles, dim, minX, minY, invSize, 0 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tb = b.next;\n\n\t\t}\n\n\t\ta = a.next;\n\n\t} while ( a !== start );\n\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\n\n\tconst queue = [];\n\tlet i, len, start, end, list;\n\n\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\n\n\t\tstart = holeIndices[ i ] * dim;\n\t\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\n\t\tlist = linkedList( data, start, end, dim, false );\n\t\tif ( list === list.next ) list.steiner = true;\n\t\tqueue.push( getLeftmost( list ) );\n\n\t}\n\n\tqueue.sort( compareX );\n\n\t// process holes from left to right\n\tfor ( i = 0; i < queue.length; i ++ ) {\n\n\t\touterNode = eliminateHole( queue[ i ], outerNode );\n\n\t}\n\n\treturn outerNode;\n\n}\n\nfunction compareX( a, b ) {\n\n\treturn a.x - b.x;\n\n}\n\n// find a bridge between vertices that connects hole with an outer ring and link it\nfunction eliminateHole( hole, outerNode ) {\n\n\tconst bridge = findHoleBridge( hole, outerNode );\n\tif ( ! bridge ) {\n\n\t\treturn outerNode;\n\n\t}\n\n\tconst bridgeReverse = splitPolygon( bridge, hole );\n\n\t// filter collinear points around the cuts\n\tfilterPoints( bridgeReverse, bridgeReverse.next );\n\treturn filterPoints( bridge, bridge.next );\n\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge( hole, outerNode ) {\n\n\tlet p = outerNode,\n\t\tqx = - Infinity,\n\t\tm;\n\n\tconst hx = hole.x, hy = hole.y;\n\n\t// find a segment intersected by a ray from the hole's leftmost point to the left;\n\t// segment's endpoint with lesser x will be potential connection point\n\tdo {\n\n\t\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\n\n\t\t\tconst x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\n\t\t\tif ( x <= hx && x > qx ) {\n\n\t\t\t\tqx = x;\n\t\t\t\tm = p.x < p.next.x ? p : p.next;\n\t\t\t\tif ( x === hx ) return m; // hole touches outer segment; pick leftmost endpoint\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== outerNode );\n\n\tif ( ! m ) return null;\n\n\t// look for points inside the triangle of hole point, segment intersection and endpoint;\n\t// if there are no points found, we have a valid connection;\n\t// otherwise choose the point of the minimum angle with the ray as connection point\n\n\tconst stop = m,\n\t\tmx = m.x,\n\t\tmy = m.y;\n\tlet tanMin = Infinity, tan;\n\n\tp = m;\n\n\tdo {\n\n\t\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\n\t\t\t\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\n\n\t\t\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\n\n\t\t\tif ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {\n\n\t\t\t\tm = p;\n\t\t\t\ttanMin = tan;\n\n\t\t\t}\n\n\t\t}\n\n\t\tp = p.next;\n\n\t} while ( p !== stop );\n\n\treturn m;\n\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector( m, p ) {\n\n\treturn area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;\n\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve( start, minX, minY, invSize ) {\n\n\tlet p = start;\n\tdo {\n\n\t\tif ( p.z === 0 ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\n\t\tp.prevZ = p.prev;\n\t\tp.nextZ = p.next;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\tp.prevZ.nextZ = null;\n\tp.prevZ = null;\n\n\tsortLinked( p );\n\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked( list ) {\n\n\tlet i, p, q, e, tail, numMerges, pSize, qSize,\n\t\tinSize = 1;\n\n\tdo {\n\n\t\tp = list;\n\t\tlist = null;\n\t\ttail = null;\n\t\tnumMerges = 0;\n\n\t\twhile ( p ) {\n\n\t\t\tnumMerges ++;\n\t\t\tq = p;\n\t\t\tpSize = 0;\n\t\t\tfor ( i = 0; i < inSize; i ++ ) {\n\n\t\t\t\tpSize ++;\n\t\t\t\tq = q.nextZ;\n\t\t\t\tif ( ! q ) break;\n\n\t\t\t}\n\n\t\t\tqSize = inSize;\n\n\t\t\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\n\n\t\t\t\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\n\n\t\t\t\t\te = p;\n\t\t\t\t\tp = p.nextZ;\n\t\t\t\t\tpSize --;\n\n\t\t\t\t} else {\n\n\t\t\t\t\te = q;\n\t\t\t\t\tq = q.nextZ;\n\t\t\t\t\tqSize --;\n\n\t\t\t\t}\n\n\t\t\t\tif ( tail ) tail.nextZ = e;\n\t\t\t\telse list = e;\n\n\t\t\t\te.prevZ = tail;\n\t\t\t\ttail = e;\n\n\t\t\t}\n\n\t\t\tp = q;\n\n\t\t}\n\n\t\ttail.nextZ = null;\n\t\tinSize *= 2;\n\n\t} while ( numMerges > 1 );\n\n\treturn list;\n\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder( x, y, minX, minY, invSize ) {\n\n\t// coords are transformed into non-negative 15-bit integer range\n\tx = ( x - minX ) * invSize | 0;\n\ty = ( y - minY ) * invSize | 0;\n\n\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\n\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\n\tx = ( x | ( x << 2 ) ) & 0x33333333;\n\tx = ( x | ( x << 1 ) ) & 0x55555555;\n\n\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\n\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\n\ty = ( y | ( y << 2 ) ) & 0x33333333;\n\ty = ( y | ( y << 1 ) ) & 0x55555555;\n\n\treturn x | ( y << 1 );\n\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost( start ) {\n\n\tlet p = start,\n\t\tleftmost = start;\n\tdo {\n\n\t\tif ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;\n\t\tp = p.next;\n\n\t} while ( p !== start );\n\n\treturn leftmost;\n\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\n\n\treturn ( cx - px ) * ( ay - py ) >= ( ax - px ) * ( cy - py ) &&\n           ( ax - px ) * ( by - py ) >= ( bx - px ) * ( ay - py ) &&\n           ( bx - px ) * ( cy - py ) >= ( cx - px ) * ( by - py );\n\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal( a, b ) {\n\n\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges\n           ( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible\n            ( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors\n            equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case\n\n}\n\n// signed area of a triangle\nfunction area( p, q, r ) {\n\n\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\n\n}\n\n// check if two points are equal\nfunction equals( p1, p2 ) {\n\n\treturn p1.x === p2.x && p1.y === p2.y;\n\n}\n\n// check if two segments intersect\nfunction intersects( p1, q1, p2, q2 ) {\n\n\tconst o1 = sign( area( p1, q1, p2 ) );\n\tconst o2 = sign( area( p1, q1, q2 ) );\n\tconst o3 = sign( area( p2, q2, p1 ) );\n\tconst o4 = sign( area( p2, q2, q1 ) );\n\n\tif ( o1 !== o2 && o3 !== o4 ) return true; // general case\n\n\tif ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n\tif ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n\tif ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n\tif ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n\treturn false;\n\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment( p, q, r ) {\n\n\treturn q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );\n\n}\n\nfunction sign( num ) {\n\n\treturn num > 0 ? 1 : num < 0 ? - 1 : 0;\n\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon( a, b ) {\n\n\tlet p = a;\n\tdo {\n\n\t\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n\t\t\tintersects( p, p.next, a, b ) ) return true;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn false;\n\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside( a, b ) {\n\n\treturn area( a.prev, a, a.next ) < 0 ?\n\t\tarea( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :\n\t\tarea( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;\n\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside( a, b ) {\n\n\tlet p = a,\n\t\tinside = false;\n\tconst px = ( a.x + b.x ) / 2,\n\t\tpy = ( a.y + b.y ) / 2;\n\tdo {\n\n\t\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\n\t\t\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )\n\t\t\tinside = ! inside;\n\t\tp = p.next;\n\n\t} while ( p !== a );\n\n\treturn inside;\n\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon( a, b ) {\n\n\tconst a2 = new Node( a.i, a.x, a.y ),\n\t\tb2 = new Node( b.i, b.x, b.y ),\n\t\tan = a.next,\n\t\tbp = b.prev;\n\n\ta.next = b;\n\tb.prev = a;\n\n\ta2.next = an;\n\tan.prev = a2;\n\n\tb2.next = a2;\n\ta2.prev = b2;\n\n\tbp.next = b2;\n\tb2.prev = bp;\n\n\treturn b2;\n\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode( i, x, y, last ) {\n\n\tconst p = new Node( i, x, y );\n\n\tif ( ! last ) {\n\n\t\tp.prev = p;\n\t\tp.next = p;\n\n\t} else {\n\n\t\tp.next = last.next;\n\t\tp.prev = last;\n\t\tlast.next.prev = p;\n\t\tlast.next = p;\n\n\t}\n\n\treturn p;\n\n}\n\nfunction removeNode( p ) {\n\n\tp.next.prev = p.prev;\n\tp.prev.next = p.next;\n\n\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\n\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\n\n}\n\nfunction Node( i, x, y ) {\n\n\t// vertex index in coordinates array\n\tthis.i = i;\n\n\t// vertex coordinates\n\tthis.x = x;\n\tthis.y = y;\n\n\t// previous and next vertex nodes in a polygon ring\n\tthis.prev = null;\n\tthis.next = null;\n\n\t// z-order curve value\n\tthis.z = 0;\n\n\t// previous and next nodes in z-order\n\tthis.prevZ = null;\n\tthis.nextZ = null;\n\n\t// indicates whether this is a steiner point\n\tthis.steiner = false;\n\n}\n\nfunction signedArea( data, start, end, dim ) {\n\n\tlet sum = 0;\n\tfor ( let i = start, j = end - dim; i < end; i += dim ) {\n\n\t\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\n\t\tj = i;\n\n\t}\n\n\treturn sum;\n\n}\n\nclass ShapeUtils {\n\n\t// calculate area of the contour polygon\n\n\tstatic area( contour ) {\n\n\t\tconst n = contour.length;\n\t\tlet a = 0.0;\n\n\t\tfor ( let p = n - 1, q = 0; q < n; p = q ++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t}\n\n\tstatic isClockWise( pts ) {\n\n\t\treturn ShapeUtils.area( pts ) < 0;\n\n\t}\n\n\tstatic triangulateShape( contour, holes ) {\n\n\t\tconst vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\n\t\tconst holeIndices = []; // array of hole indices\n\t\tconst faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\n\n\t\tremoveDupEndPts( contour );\n\t\taddContour( vertices, contour );\n\n\t\t//\n\n\t\tlet holeIndex = contour.length;\n\n\t\tholes.forEach( removeDupEndPts );\n\n\t\tfor ( let i = 0; i < holes.length; i ++ ) {\n\n\t\t\tholeIndices.push( holeIndex );\n\t\t\tholeIndex += holes[ i ].length;\n\t\t\taddContour( vertices, holes[ i ] );\n\n\t\t}\n\n\t\t//\n\n\t\tconst triangles = Earcut.triangulate( vertices, holeIndices );\n\n\t\t//\n\n\t\tfor ( let i = 0; i < triangles.length; i += 3 ) {\n\n\t\t\tfaces.push( triangles.slice( i, i + 3 ) );\n\n\t\t}\n\n\t\treturn faces;\n\n\t}\n\n}\n\nfunction removeDupEndPts( points ) {\n\n\tconst l = points.length;\n\n\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\n\n\t\tpoints.pop();\n\n\t}\n\n}\n\nfunction addContour( vertices, contour ) {\n\n\tfor ( let i = 0; i < contour.length; i ++ ) {\n\n\t\tvertices.push( contour[ i ].x );\n\t\tvertices.push( contour[ i ].y );\n\n\t}\n\n}\n\n/**\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\n *  depth: <float>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel\n *  bevelOffset: <float>, // how far from shape outline does bevel start\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.Curve> // curve to extrude shape along\n *\n *  UVGenerator: <Object> // object that provides UV generator functions\n *\n * }\n */\n\n\nclass ExtrudeGeometry extends BufferGeometry {\n\n\tconstructor( shapes = new Shape( [ new Vector2( 0.5, 0.5 ), new Vector2( - 0.5, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), options = {} ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ExtrudeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\toptions: options\n\t\t};\n\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\n\n\t\tconst scope = this;\n\n\t\tconst verticesArray = [];\n\t\tconst uvArray = [];\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\t\t\taddShape( shape );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\n\n\t\tthis.computeVertexNormals();\n\n\t\t// functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst placeholder = [];\n\n\t\t\t// options\n\n\t\t\tconst curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\t\t\tconst steps = options.steps !== undefined ? options.steps : 1;\n\t\t\tconst depth = options.depth !== undefined ? options.depth : 1;\n\n\t\t\tlet bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;\n\t\t\tlet bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;\n\t\t\tlet bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;\n\t\t\tlet bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;\n\t\t\tlet bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\t\t\tconst extrudePath = options.extrudePath;\n\n\t\t\tconst uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;\n\n\t\t\t//\n\n\t\t\tlet extrudePts, extrudeByPath = false;\n\t\t\tlet splineTube, binormal, normal, position2;\n\n\t\t\tif ( extrudePath ) {\n\n\t\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\t\t\textrudeByPath = true;\n\t\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t\t\t// SETUP TNB variables\n\n\t\t\t\t// TODO1 - have a .isClosed in spline?\n\n\t\t\t\tsplineTube = extrudePath.computeFrenetFrames( steps, false );\n\n\t\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\t\t\tbinormal = new Vector3();\n\t\t\t\tnormal = new Vector3();\n\t\t\t\tposition2 = new Vector3();\n\n\t\t\t}\n\n\t\t\t// Safeguards if bevels are not enabled\n\n\t\t\tif ( ! bevelEnabled ) {\n\n\t\t\t\tbevelSegments = 0;\n\t\t\t\tbevelThickness = 0;\n\t\t\t\tbevelSize = 0;\n\t\t\t\tbevelOffset = 0;\n\n\t\t\t}\n\n\t\t\t// Variables initialization\n\n\t\t\tconst shapePoints = shape.extractPoints( curveSegments );\n\n\t\t\tlet vertices = shapePoints.shape;\n\t\t\tconst holes = shapePoints.holes;\n\n\t\t\tconst reverse = ! ShapeUtils.isClockWise( vertices );\n\n\t\t\tif ( reverse ) {\n\n\t\t\t\tvertices = vertices.reverse();\n\n\t\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\t\tif ( ShapeUtils.isClockWise( ahole ) ) {\n\n\t\t\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( vertices, holes );\n\n\t\t\t/* Vertices */\n\n\t\t\tconst contour = vertices; // vertices has all points but contour has only points of circumference\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\tvertices = vertices.concat( ahole );\n\n\t\t\t}\n\n\n\t\t\tfunction scalePt2( pt, vec, size ) {\n\n\t\t\t\tif ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );\n\n\t\t\t\treturn pt.clone().addScaledVector( vec, size );\n\n\t\t\t}\n\n\t\t\tconst vlen = vertices.length, flen = faces.length;\n\n\n\t\t\t// Find directions for point movement\n\n\n\t\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\n\n\t\t\t\t// computes for inPt the corresponding point inPt' on a new contour\n\t\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\n\t\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\n\t\t\t\t//\n\t\t\t\t// inPt' is the intersection of the two lines parallel to the two\n\t\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\n\n\t\t\t\tlet v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\n\n\t\t\t\t// good reading for geometry algorithms (here: line-line intersection)\n\t\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\n\n\t\t\t\tconst v_prev_x = inPt.x - inPrev.x,\n\t\t\t\t\tv_prev_y = inPt.y - inPrev.y;\n\t\t\t\tconst v_next_x = inNext.x - inPt.x,\n\t\t\t\t\tv_next_y = inNext.y - inPt.y;\n\n\t\t\t\tconst v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\n\n\t\t\t\t// check for collinear edges\n\t\t\t\tconst collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not collinear\n\n\t\t\t\t\t// length of vectors for normalizing\n\n\t\t\t\t\tconst v_prev_len = Math.sqrt( v_prev_lensq );\n\t\t\t\t\tconst v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\n\n\t\t\t\t\t// shift adjacent points by unit vectors to the left\n\n\t\t\t\t\tconst ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\n\t\t\t\t\tconst ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\n\n\t\t\t\t\tconst ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\n\t\t\t\t\tconst ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\n\n\t\t\t\t\t// scaling factor for v_prev to intersection point\n\n\t\t\t\t\tconst sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\n\t\t\t\t\t\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\n\n\t\t\t\t\t// vector from inPt to intersection point\n\n\t\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\n\t\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\n\n\t\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\n\t\t\t\t\t//  but prevent crazy spikes\n\t\t\t\t\tconst v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\n\t\t\t\t\tif ( v_trans_lensq <= 2 ) {\n\n\t\t\t\t\t\treturn new Vector2( v_trans_x, v_trans_y );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// handle special case of collinear edges\n\n\t\t\t\t\tlet direction_eq = false; // assumes: opposite\n\n\t\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\n\n\t\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\n\n\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\n\n\t\t\t\t\t\t\t\tdirection_eq = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( direction_eq ) {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\n\t\t\t\t\t\tv_trans_x = - v_prev_y;\n\t\t\t\t\t\tv_trans_y = v_prev_x;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\n\t\t\t\t\t\tv_trans_x = v_prev_x;\n\t\t\t\t\t\tv_trans_y = v_prev_y;\n\t\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\n\n\t\t\t}\n\n\n\t\t\tconst contourMovements = [];\n\n\t\t\tfor ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t// console.log('i,j,k', i, j , k)\n\n\t\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t\t\t}\n\n\t\t\tconst holesMovements = [];\n\t\t\tlet oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\tconst ahole = holes[ h ];\n\n\t\t\t\toneHoleMovements = [];\n\n\t\t\t\tfor ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\t\t\tif ( j === il ) j = 0;\n\t\t\t\t\tif ( k === il ) k = 0;\n\n\t\t\t\t\t//  (j)---(i)---(k)\n\t\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t\t\t}\n\n\t\t\t\tholesMovements.push( oneHoleMovements );\n\t\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t\t\t}\n\n\n\t\t\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\t\t\tfor ( let b = 0; b < bevelSegments; b ++ ) {\n\n\t\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\n\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tv( vert.x, vert.y, - z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst bs = bevelSize + bevelOffset;\n\n\t\t\t// Back facing vertices\n\n\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\n\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Add stepped vertices...\n\t\t\t// Including front facing vertices\n\n\t\t\tfor ( let s = 1; s <= steps; s ++ ) {\n\n\t\t\t\tfor ( let i = 0; i < vlen; i ++ ) {\n\n\t\t\t\t\tconst vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\tv( vert.x, vert.y, depth / steps * s );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\n\t\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\n\n\t\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\n\n\t\t\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// Add bevel segments planes\n\n\t\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\t\t\tfor ( let b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\t\t\tconst t = b / bevelSegments;\n\t\t\t\tconst z = bevelThickness * Math.cos( t * Math.PI / 2 );\n\t\t\t\tconst bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;\n\n\t\t\t\t// contract shape\n\n\t\t\t\tfor ( let i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t}\n\n\t\t\t\t// expand holes\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\t\t\tfor ( let i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tconst vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\t\t\tif ( ! extrudeByPath ) {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y, depth + z );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Faces */\n\n\t\t\t// Top and bottom faces\n\n\t\t\tbuildLidFaces();\n\n\t\t\t// Sides faces\n\n\t\t\tbuildSideFaces();\n\n\n\t\t\t/////  Internal functions\n\n\t\t\tfunction buildLidFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\n\t\t\t\tif ( bevelEnabled ) {\n\n\t\t\t\t\tlet layer = 0; // steps + 1\n\t\t\t\t\tlet offset = vlen * layer;\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\t\t\toffset = vlen * layer;\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Bottom faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Top faces\n\n\t\t\t\t\tfor ( let i = 0; i < flen; i ++ ) {\n\n\t\t\t\t\t\tconst face = faces[ i ];\n\t\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 0 );\n\n\t\t\t}\n\n\t\t\t// Create faces for the z-sides of the shape\n\n\t\t\tfunction buildSideFaces() {\n\n\t\t\t\tconst start = verticesArray.length / 3;\n\t\t\t\tlet layeroffset = 0;\n\t\t\t\tsidewalls( contour, layeroffset );\n\t\t\t\tlayeroffset += contour.length;\n\n\t\t\t\tfor ( let h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\t\t\tconst ahole = holes[ h ];\n\t\t\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t\t\t//, true\n\t\t\t\t\tlayeroffset += ahole.length;\n\n\t\t\t\t}\n\n\n\t\t\t\tscope.addGroup( start, verticesArray.length / 3 - start, 1 );\n\n\n\t\t\t}\n\n\t\t\tfunction sidewalls( contour, layeroffset ) {\n\n\t\t\t\tlet i = contour.length;\n\n\t\t\t\twhile ( -- i >= 0 ) {\n\n\t\t\t\t\tconst j = i;\n\t\t\t\t\tlet k = i - 1;\n\t\t\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\t\t\tfor ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {\n\n\t\t\t\t\t\tconst slen1 = vlen * s;\n\t\t\t\t\t\tconst slen2 = vlen * ( s + 1 );\n\n\t\t\t\t\t\tconst a = layeroffset + j + slen1,\n\t\t\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\t\t\tf4( a, b, c, d );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction v( x, y, z ) {\n\n\t\t\t\tplaceholder.push( x );\n\t\t\t\tplaceholder.push( y );\n\t\t\t\tplaceholder.push( z );\n\n\t\t\t}\n\n\n\t\t\tfunction f3( a, b, c ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\n\t\t\t}\n\n\t\t\tfunction f4( a, b, c, d ) {\n\n\t\t\t\taddVertex( a );\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( d );\n\n\t\t\t\taddVertex( b );\n\t\t\t\taddVertex( c );\n\t\t\t\taddVertex( d );\n\n\n\t\t\t\tconst nextIndex = verticesArray.length / 3;\n\t\t\t\tconst uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\n\n\t\t\t\taddUV( uvs[ 0 ] );\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t\taddUV( uvs[ 1 ] );\n\t\t\t\taddUV( uvs[ 2 ] );\n\t\t\t\taddUV( uvs[ 3 ] );\n\n\t\t\t}\n\n\t\t\tfunction addVertex( index ) {\n\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 0 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 1 ] );\n\t\t\t\tverticesArray.push( placeholder[ index * 3 + 2 ] );\n\n\t\t\t}\n\n\n\t\t\tfunction addUV( vector2 ) {\n\n\t\t\t\tuvArray.push( vector2.x );\n\t\t\t\tuvArray.push( vector2.y );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tconst shapes = this.parameters.shapes;\n\t\tconst options = this.parameters.options;\n\n\t\treturn toJSON$1( shapes, options, data );\n\n\t}\n\n\tstatic fromJSON( data, shapes ) {\n\n\t\tconst geometryShapes = [];\n\n\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\tconst shape = shapes[ data.shapes[ j ] ];\n\n\t\t\tgeometryShapes.push( shape );\n\n\t\t}\n\n\t\tconst extrudePath = data.options.extrudePath;\n\n\t\tif ( extrudePath !== undefined ) {\n\n\t\t\tdata.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );\n\n\t\t}\n\n\t\treturn new ExtrudeGeometry( geometryShapes, data.options );\n\n\t}\n\n}\n\nconst WorldUVGenerator = {\n\n\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\n\t\treturn [\n\t\t\tnew Vector2( a_x, a_y ),\n\t\t\tnew Vector2( b_x, b_y ),\n\t\t\tnew Vector2( c_x, c_y )\n\t\t];\n\n\t},\n\n\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\n\n\t\tconst a_x = vertices[ indexA * 3 ];\n\t\tconst a_y = vertices[ indexA * 3 + 1 ];\n\t\tconst a_z = vertices[ indexA * 3 + 2 ];\n\t\tconst b_x = vertices[ indexB * 3 ];\n\t\tconst b_y = vertices[ indexB * 3 + 1 ];\n\t\tconst b_z = vertices[ indexB * 3 + 2 ];\n\t\tconst c_x = vertices[ indexC * 3 ];\n\t\tconst c_y = vertices[ indexC * 3 + 1 ];\n\t\tconst c_z = vertices[ indexC * 3 + 2 ];\n\t\tconst d_x = vertices[ indexD * 3 ];\n\t\tconst d_y = vertices[ indexD * 3 + 1 ];\n\t\tconst d_z = vertices[ indexD * 3 + 2 ];\n\n\t\tif ( Math.abs( a_y - b_y ) < Math.abs( a_x - b_x ) ) {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_x, 1 - a_z ),\n\t\t\t\tnew Vector2( b_x, 1 - b_z ),\n\t\t\t\tnew Vector2( c_x, 1 - c_z ),\n\t\t\t\tnew Vector2( d_x, 1 - d_z )\n\t\t\t];\n\n\t\t} else {\n\n\t\t\treturn [\n\t\t\t\tnew Vector2( a_y, 1 - a_z ),\n\t\t\t\tnew Vector2( b_y, 1 - b_z ),\n\t\t\t\tnew Vector2( c_y, 1 - c_z ),\n\t\t\t\tnew Vector2( d_y, 1 - d_z )\n\t\t\t];\n\n\t\t}\n\n\t}\n\n};\n\nfunction toJSON$1( shapes, options, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\tdata.options = Object.assign( {}, options );\n\n\tif ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();\n\n\treturn data;\n\n}\n\nclass IcosahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\t\tconst vertices = [\n\t\t\t- 1, t, 0, \t1, t, 0, \t- 1, - t, 0, \t1, - t, 0,\n\t\t\t0, - 1, t, \t0, 1, t,\t0, - 1, - t, \t0, 1, - t,\n\t\t\tt, 0, - 1, \tt, 0, 1, \t- t, 0, - 1, \t- t, 0, 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t0, 11, 5, \t0, 5, 1, \t0, 1, 7, \t0, 7, 10, \t0, 10, 11,\n\t\t\t1, 5, 9, \t5, 11, 4,\t11, 10, 2,\t10, 7, 6,\t7, 1, 8,\n\t\t\t3, 9, 4, \t3, 4, 2,\t3, 2, 6,\t3, 6, 8,\t3, 8, 9,\n\t\t\t4, 9, 5, \t2, 4, 11,\t6, 2, 10,\t8, 6, 7,\t9, 8, 1\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'IcosahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new IcosahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nclass OctahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst vertices = [\n\t\t\t1, 0, 0, \t- 1, 0, 0,\t0, 1, 0,\n\t\t\t0, - 1, 0, \t0, 0, 1,\t0, 0, - 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t0, 2, 4,\t0, 4, 3,\t0, 3, 5,\n\t\t\t0, 5, 2,\t1, 2, 5,\t1, 5, 3,\n\t\t\t1, 3, 4,\t1, 4, 2\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'OctahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new OctahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nclass RingGeometry extends BufferGeometry {\n\n\tconstructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'RingGeometry';\n\n\t\tthis.parameters = {\n\t\t\tinnerRadius: innerRadius,\n\t\t\touterRadius: outerRadius,\n\t\t\tthetaSegments: thetaSegments,\n\t\t\tphiSegments: phiSegments,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\tthetaSegments = Math.max( 3, thetaSegments );\n\t\tphiSegments = Math.max( 1, phiSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// some helper variables\n\n\t\tlet radius = innerRadius;\n\t\tconst radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let j = 0; j <= phiSegments; j ++ ) {\n\n\t\t\tfor ( let i = 0; i <= thetaSegments; i ++ ) {\n\n\t\t\t\t// values are generate from the inside of the ring to the outside\n\n\t\t\t\tconst segment = thetaStart + i / thetaSegments * thetaLength;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormals.push( 0, 0, 1 );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t}\n\n\t\t\t// increase the radius for next row of vertices\n\n\t\t\tradius += radiusStep;\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let j = 0; j < phiSegments; j ++ ) {\n\n\t\t\tconst thetaSegmentLevel = j * ( thetaSegments + 1 );\n\n\t\t\tfor ( let i = 0; i < thetaSegments; i ++ ) {\n\n\t\t\t\tconst segment = i + thetaSegmentLevel;\n\n\t\t\t\tconst a = segment;\n\t\t\t\tconst b = segment + thetaSegments + 1;\n\t\t\t\tconst c = segment + thetaSegments + 2;\n\t\t\t\tconst d = segment + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new RingGeometry( data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass ShapeGeometry extends BufferGeometry {\n\n\tconstructor( shapes = new Shape( [ new Vector2( 0, 0.5 ), new Vector2( - 0.5, - 0.5 ), new Vector2( 0.5, - 0.5 ) ] ), curveSegments = 12 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ShapeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tshapes: shapes,\n\t\t\tcurveSegments: curveSegments\n\t\t};\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet groupStart = 0;\n\t\tlet groupCount = 0;\n\n\t\t// allow single and array values for \"shapes\" parameter\n\n\t\tif ( Array.isArray( shapes ) === false ) {\n\n\t\t\taddShape( shapes );\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < shapes.length; i ++ ) {\n\n\t\t\t\taddShape( shapes[ i ] );\n\n\t\t\t\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\n\n\t\t\t\tgroupStart += groupCount;\n\t\t\t\tgroupCount = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\n\t\t// helper functions\n\n\t\tfunction addShape( shape ) {\n\n\t\t\tconst indexOffset = vertices.length / 3;\n\t\t\tconst points = shape.extractPoints( curveSegments );\n\n\t\t\tlet shapeVertices = points.shape;\n\t\t\tconst shapeHoles = points.holes;\n\n\t\t\t// check direction of vertices\n\n\t\t\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\n\n\t\t\t\tshapeVertices = shapeVertices.reverse();\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\n\t\t\t\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\n\n\t\t\t\t\tshapeHoles[ i ] = shapeHole.reverse();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\n\n\t\t\t// join vertices of inner and outer paths to a single array\n\n\t\t\tfor ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {\n\n\t\t\t\tconst shapeHole = shapeHoles[ i ];\n\t\t\t\tshapeVertices = shapeVertices.concat( shapeHole );\n\n\t\t\t}\n\n\t\t\t// vertices, normals, uvs\n\n\t\t\tfor ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {\n\n\t\t\t\tconst vertex = shapeVertices[ i ];\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, 0 );\n\t\t\t\tnormals.push( 0, 0, 1 );\n\t\t\t\tuvs.push( vertex.x, vertex.y ); // world uvs\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\tconst face = faces[ i ];\n\n\t\t\t\tconst a = face[ 0 ] + indexOffset;\n\t\t\t\tconst b = face[ 1 ] + indexOffset;\n\t\t\t\tconst c = face[ 2 ] + indexOffset;\n\n\t\t\t\tindices.push( a, b, c );\n\t\t\t\tgroupCount += 3;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tconst shapes = this.parameters.shapes;\n\n\t\treturn toJSON( shapes, data );\n\n\t}\n\n\tstatic fromJSON( data, shapes ) {\n\n\t\tconst geometryShapes = [];\n\n\t\tfor ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {\n\n\t\t\tconst shape = shapes[ data.shapes[ j ] ];\n\n\t\t\tgeometryShapes.push( shape );\n\n\t\t}\n\n\t\treturn new ShapeGeometry( geometryShapes, data.curveSegments );\n\n\t}\n\n}\n\nfunction toJSON( shapes, data ) {\n\n\tdata.shapes = [];\n\n\tif ( Array.isArray( shapes ) ) {\n\n\t\tfor ( let i = 0, l = shapes.length; i < l; i ++ ) {\n\n\t\t\tconst shape = shapes[ i ];\n\n\t\t\tdata.shapes.push( shape.uuid );\n\n\t\t}\n\n\t} else {\n\n\t\tdata.shapes.push( shapes.uuid );\n\n\t}\n\n\treturn data;\n\n}\n\nclass SphereGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'SphereGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) );\n\n\t\tconst thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );\n\n\t\tlet index = 0;\n\t\tconst grid = [];\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let iy = 0; iy <= heightSegments; iy ++ ) {\n\n\t\t\tconst verticesRow = [];\n\n\t\t\tconst v = iy / heightSegments;\n\n\t\t\t// special case for the poles\n\n\t\t\tlet uOffset = 0;\n\n\t\t\tif ( iy === 0 && thetaStart === 0 ) {\n\n\t\t\t\tuOffset = 0.5 / widthSegments;\n\n\t\t\t} else if ( iy === heightSegments && thetaEnd === Math.PI ) {\n\n\t\t\t\tuOffset = - 0.5 / widthSegments;\n\n\t\t\t}\n\n\t\t\tfor ( let ix = 0; ix <= widthSegments; ix ++ ) {\n\n\t\t\t\tconst u = ix / widthSegments;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.copy( vertex ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u + uOffset, 1 - v );\n\n\t\t\t\tverticesRow.push( index ++ );\n\n\t\t\t}\n\n\t\t\tgrid.push( verticesRow );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let iy = 0; iy < heightSegments; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < widthSegments; ix ++ ) {\n\n\t\t\t\tconst a = grid[ iy ][ ix + 1 ];\n\t\t\t\tconst b = grid[ iy ][ ix ];\n\t\t\t\tconst c = grid[ iy + 1 ][ ix ];\n\t\t\t\tconst d = grid[ iy + 1 ][ ix + 1 ];\n\n\t\t\t\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\n\t\t\t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nclass TetrahedronGeometry extends PolyhedronGeometry {\n\n\tconstructor( radius = 1, detail = 0 ) {\n\n\t\tconst vertices = [\n\t\t\t1, 1, 1, \t- 1, - 1, 1, \t- 1, 1, - 1, \t1, - 1, - 1\n\t\t];\n\n\t\tconst indices = [\n\t\t\t2, 1, 0, \t0, 3, 2,\t1, 3, 0,\t2, 3, 1\n\t\t];\n\n\t\tsuper( vertices, indices, radius, detail );\n\n\t\tthis.type = 'TetrahedronGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\tdetail: detail\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TetrahedronGeometry( data.radius, data.detail );\n\n\t}\n\n}\n\nclass TorusGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TorusGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\tradialSegments: radialSegments,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tarc: arc\n\t\t};\n\n\t\tradialSegments = Math.floor( radialSegments );\n\t\ttubularSegments = Math.floor( tubularSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst center = new Vector3();\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tconst u = i / tubularSegments * arc;\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\t\tvertex.z = tube * Math.sin( v );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tcenter.x = radius * Math.cos( u );\n\t\t\t\tcenter.y = radius * Math.sin( u );\n\t\t\t\tnormal.subVectors( vertex, center ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let j = 1; j <= radialSegments; j ++ ) {\n\n\t\t\tfor ( let i = 1; i <= tubularSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tconst a = ( tubularSegments + 1 ) * j + i - 1;\n\t\t\t\tconst b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\t\tconst c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\t\tconst d = ( tubularSegments + 1 ) * j + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TorusGeometry( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc );\n\n\t}\n\n}\n\nclass TorusKnotGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TorusKnotGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\ttube: tube,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t\tp: p,\n\t\t\tq: q\n\t\t};\n\n\t\ttubularSegments = Math.floor( tubularSegments );\n\t\tradialSegments = Math.floor( radialSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\tconst P1 = new Vector3();\n\t\tconst P2 = new Vector3();\n\n\t\tconst B = new Vector3();\n\t\tconst T = new Vector3();\n\t\tconst N = new Vector3();\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let i = 0; i <= tubularSegments; ++ i ) {\n\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segment\n\n\t\t\tconst u = i / tubularSegments * p * Math.PI * 2;\n\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\n\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\n\n\t\t\t// calculate orthonormal basis\n\n\t\t\tT.subVectors( P2, P1 );\n\t\t\tN.addVectors( P2, P1 );\n\t\t\tB.crossVectors( T, N );\n\t\t\tN.crossVectors( B, T );\n\n\t\t\t// normalize B, N. T can be ignored, we don't use it\n\n\t\t\tB.normalize();\n\t\t\tN.normalize();\n\n\t\t\tfor ( let j = 0; j <= radialSegments; ++ j ) {\n\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\t\t\t\tconst cx = - tube * Math.cos( v );\n\t\t\t\tconst cy = tube * Math.sin( v );\n\n\t\t\t\t// now calculate the final vertex position.\n\t\t\t\t// first we orient the extrusion with our basis vectors, then we add it to the current position on the curve\n\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\n\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( i / tubularSegments );\n\t\t\t\tuvs.push( j / radialSegments );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate indices\n\n\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t// indices\n\n\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// this function calculates the current position on the torus curve\n\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\n\n\t\t\tconst cu = Math.cos( u );\n\t\t\tconst su = Math.sin( u );\n\t\t\tconst quOverP = q / p * u;\n\t\t\tconst cs = Math.cos( quOverP );\n\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new TorusKnotGeometry( data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q );\n\n\t}\n\n}\n\nclass TubeGeometry extends BufferGeometry {\n\n\tconstructor( path = new QuadraticBezierCurve3( new Vector3( - 1, - 1, 0 ), new Vector3( - 1, 1, 0 ), new Vector3( 1, 1, 0 ) ), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'TubeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpath: path,\n\t\t\ttubularSegments: tubularSegments,\n\t\t\tradius: radius,\n\t\t\tradialSegments: radialSegments,\n\t\t\tclosed: closed\n\t\t};\n\n\t\tconst frames = path.computeFrenetFrames( tubularSegments, closed );\n\n\t\t// expose internals\n\n\t\tthis.tangents = frames.tangents;\n\t\tthis.normals = frames.normals;\n\t\tthis.binormals = frames.binormals;\n\n\t\t// helper variables\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tlet P = new Vector3();\n\n\t\t// buffer\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\t\tconst indices = [];\n\n\t\t// create buffer data\n\n\t\tgenerateBufferData();\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\t// functions\n\n\t\tfunction generateBufferData() {\n\n\t\t\tfor ( let i = 0; i < tubularSegments; i ++ ) {\n\n\t\t\t\tgenerateSegment( i );\n\n\t\t\t}\n\n\t\t\t// if the geometry is not closed, generate the last row of vertices and normals\n\t\t\t// at the regular position on the given path\n\t\t\t//\n\t\t\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n\n\t\t\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\n\n\t\t\t// uvs are generated in a separate function.\n\t\t\t// this makes it easy compute correct values for closed geometries\n\n\t\t\tgenerateUVs();\n\n\t\t\t// finally create faces\n\n\t\t\tgenerateIndices();\n\n\t\t}\n\n\t\tfunction generateSegment( i ) {\n\n\t\t\t// we use getPointAt to sample evenly distributed points from the given path\n\n\t\t\tP = path.getPointAt( i / tubularSegments, P );\n\n\t\t\t// retrieve corresponding normal and binormal\n\n\t\t\tconst N = frames.normals[ i ];\n\t\t\tconst B = frames.binormals[ i ];\n\n\t\t\t// generate normals and vertices for the current segment\n\n\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\tconst v = j / radialSegments * Math.PI * 2;\n\n\t\t\t\tconst sin = Math.sin( v );\n\t\t\t\tconst cos = - Math.cos( v );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.x = ( cos * N.x + sin * B.x );\n\t\t\t\tnormal.y = ( cos * N.y + sin * B.y );\n\t\t\t\tnormal.z = ( cos * N.z + sin * B.z );\n\t\t\t\tnormal.normalize();\n\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = P.x + radius * normal.x;\n\t\t\t\tvertex.y = P.y + radius * normal.y;\n\t\t\t\tvertex.z = P.z + radius * normal.z;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateIndices() {\n\n\t\t\tfor ( let j = 1; j <= tubularSegments; j ++ ) {\n\n\t\t\t\tfor ( let i = 1; i <= radialSegments; i ++ ) {\n\n\t\t\t\t\tconst a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\n\t\t\t\t\tconst b = ( radialSegments + 1 ) * j + ( i - 1 );\n\t\t\t\t\tconst c = ( radialSegments + 1 ) * j + i;\n\t\t\t\t\tconst d = ( radialSegments + 1 ) * ( j - 1 ) + i;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction generateUVs() {\n\n\t\t\tfor ( let i = 0; i <= tubularSegments; i ++ ) {\n\n\t\t\t\tfor ( let j = 0; j <= radialSegments; j ++ ) {\n\n\t\t\t\t\tuv.x = i / tubularSegments;\n\t\t\t\t\tuv.y = j / radialSegments;\n\n\t\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.path = this.parameters.path.toJSON();\n\n\t\treturn data;\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\t// This only works for built-in curves (e.g. CatmullRomCurve3).\n\t\t// User defined curves or instances of CurvePath will not be deserialized.\n\t\treturn new TubeGeometry(\n\t\t\tnew Curves[ data.path.type ]().fromJSON( data.path ),\n\t\t\tdata.tubularSegments,\n\t\t\tdata.radius,\n\t\t\tdata.radialSegments,\n\t\t\tdata.closed\n\t\t);\n\n\t}\n\n}\n\nclass WireframeGeometry extends BufferGeometry {\n\n\tconstructor( geometry = null ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'WireframeGeometry';\n\n\t\tthis.parameters = {\n\t\t\tgeometry: geometry\n\t\t};\n\n\t\tif ( geometry !== null ) {\n\n\t\t\t// buffer\n\n\t\t\tconst vertices = [];\n\t\t\tconst edges = new Set();\n\n\t\t\t// helper variables\n\n\t\t\tconst start = new Vector3();\n\t\t\tconst end = new Vector3();\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t// indexed BufferGeometry\n\n\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\tconst indices = geometry.index;\n\t\t\t\tlet groups = geometry.groups;\n\n\t\t\t\tif ( groups.length === 0 ) {\n\n\t\t\t\t\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\n\n\t\t\t\t}\n\n\t\t\t\t// create a data structure that contains all edges without duplicates\n\n\t\t\t\tfor ( let o = 0, ol = groups.length; o < ol; ++ o ) {\n\n\t\t\t\t\tconst group = groups[ o ];\n\n\t\t\t\t\tconst groupStart = group.start;\n\t\t\t\t\tconst groupCount = group.count;\n\n\t\t\t\t\tfor ( let i = groupStart, l = ( groupStart + groupCount ); i < l; i += 3 ) {\n\n\t\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\tconst index1 = indices.getX( i + j );\n\t\t\t\t\t\t\tconst index2 = indices.getX( i + ( j + 1 ) % 3 );\n\n\t\t\t\t\t\t\tstart.fromBufferAttribute( position, index1 );\n\t\t\t\t\t\t\tend.fromBufferAttribute( position, index2 );\n\n\t\t\t\t\t\t\tif ( isUniqueEdge( start, end, edges ) === true ) {\n\n\t\t\t\t\t\t\t\tvertices.push( start.x, start.y, start.z );\n\t\t\t\t\t\t\t\tvertices.push( end.x, end.y, end.z );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed BufferGeometry\n\n\t\t\t\tconst position = geometry.attributes.position;\n\n\t\t\t\tfor ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\n\n\t\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t// three edges per triangle, an edge is represented as (index1, index2)\n\t\t\t\t\t\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\n\n\t\t\t\t\t\tconst index1 = 3 * i + j;\n\t\t\t\t\t\tconst index2 = 3 * i + ( ( j + 1 ) % 3 );\n\n\t\t\t\t\t\tstart.fromBufferAttribute( position, index1 );\n\t\t\t\t\t\tend.fromBufferAttribute( position, index2 );\n\n\t\t\t\t\t\tif ( isUniqueEdge( start, end, edges ) === true ) {\n\n\t\t\t\t\t\t\tvertices.push( start.x, start.y, start.z );\n\t\t\t\t\t\t\tvertices.push( end.x, end.y, end.z );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n}\n\nfunction isUniqueEdge( start, end, edges ) {\n\n\tconst hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;\n\tconst hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge\n\n\tif ( edges.has( hash1 ) === true || edges.has( hash2 ) === true ) {\n\n\t\treturn false;\n\n\t} else {\n\n\t\tedges.add( hash1 );\n\t\tedges.add( hash2 );\n\t\treturn true;\n\n\t}\n\n}\n\nvar Geometries = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tBoxGeometry: BoxGeometry,\n\tCapsuleGeometry: CapsuleGeometry,\n\tCircleGeometry: CircleGeometry,\n\tConeGeometry: ConeGeometry,\n\tCylinderGeometry: CylinderGeometry,\n\tDodecahedronGeometry: DodecahedronGeometry,\n\tEdgesGeometry: EdgesGeometry,\n\tExtrudeGeometry: ExtrudeGeometry,\n\tIcosahedronGeometry: IcosahedronGeometry,\n\tLatheGeometry: LatheGeometry,\n\tOctahedronGeometry: OctahedronGeometry,\n\tPlaneGeometry: PlaneGeometry,\n\tPolyhedronGeometry: PolyhedronGeometry,\n\tRingGeometry: RingGeometry,\n\tShapeGeometry: ShapeGeometry,\n\tSphereGeometry: SphereGeometry,\n\tTetrahedronGeometry: TetrahedronGeometry,\n\tTorusGeometry: TorusGeometry,\n\tTorusKnotGeometry: TorusKnotGeometry,\n\tTubeGeometry: TubeGeometry,\n\tWireframeGeometry: WireframeGeometry\n});\n\nclass ShadowMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isShadowMaterial = true;\n\n\t\tthis.type = 'ShadowMaterial';\n\n\t\tthis.color = new Color( 0x000000 );\n\t\tthis.transparent = true;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass RawShaderMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( parameters );\n\n\t\tthis.isRawShaderMaterial = true;\n\n\t\tthis.type = 'RawShaderMaterial';\n\n\t}\n\n}\n\nclass MeshStandardMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshStandardMaterial = true;\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.type = 'MeshStandardMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.roughness = 1.0;\n\t\tthis.metalness = 0.0;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.roughnessMap = null;\n\n\t\tthis.metalnessMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.envMapIntensity = 1.0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = { 'STANDARD': '' };\n\n\t\tthis.color.copy( source.color );\n\t\tthis.roughness = source.roughness;\n\t\tthis.metalness = source.metalness;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.roughnessMap = source.roughnessMap;\n\n\t\tthis.metalnessMap = source.metalnessMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.envMapIntensity = source.envMapIntensity;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshPhysicalMaterial extends MeshStandardMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshPhysicalMaterial = true;\n\n\t\tthis.defines = {\n\n\t\t\t'STANDARD': '',\n\t\t\t'PHYSICAL': ''\n\n\t\t};\n\n\t\tthis.type = 'MeshPhysicalMaterial';\n\n\t\tthis.anisotropyRotation = 0;\n\t\tthis.anisotropyMap = null;\n\n\t\tthis.clearcoatMap = null;\n\t\tthis.clearcoatRoughness = 0.0;\n\t\tthis.clearcoatRoughnessMap = null;\n\t\tthis.clearcoatNormalScale = new Vector2( 1, 1 );\n\t\tthis.clearcoatNormalMap = null;\n\n\t\tthis.ior = 1.5;\n\n\t\tObject.defineProperty( this, 'reflectivity', {\n\t\t\tget: function () {\n\n\t\t\t\treturn ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );\n\n\t\t\t},\n\t\t\tset: function ( reflectivity ) {\n\n\t\t\t\tthis.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );\n\n\t\t\t}\n\t\t} );\n\n\t\tthis.iridescenceMap = null;\n\t\tthis.iridescenceIOR = 1.3;\n\t\tthis.iridescenceThicknessRange = [ 100, 400 ];\n\t\tthis.iridescenceThicknessMap = null;\n\n\t\tthis.sheenColor = new Color( 0x000000 );\n\t\tthis.sheenColorMap = null;\n\t\tthis.sheenRoughness = 1.0;\n\t\tthis.sheenRoughnessMap = null;\n\n\t\tthis.transmissionMap = null;\n\n\t\tthis.thickness = 0;\n\t\tthis.thicknessMap = null;\n\t\tthis.attenuationDistance = Infinity;\n\t\tthis.attenuationColor = new Color( 1, 1, 1 );\n\n\t\tthis.specularIntensity = 1.0;\n\t\tthis.specularIntensityMap = null;\n\t\tthis.specularColor = new Color( 1, 1, 1 );\n\t\tthis.specularColorMap = null;\n\n\t\tthis._anisotropy = 0;\n\t\tthis._clearcoat = 0;\n\t\tthis._iridescence = 0;\n\t\tthis._sheen = 0.0;\n\t\tthis._transmission = 0;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tget anisotropy() {\n\n\t\treturn this._anisotropy;\n\n\t}\n\n\tset anisotropy( value ) {\n\n\t\tif ( this._anisotropy > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._anisotropy = value;\n\n\t}\n\n\tget clearcoat() {\n\n\t\treturn this._clearcoat;\n\n\t}\n\n\tset clearcoat( value ) {\n\n\t\tif ( this._clearcoat > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._clearcoat = value;\n\n\t}\n\n\tget iridescence() {\n\n\t\treturn this._iridescence;\n\n\t}\n\n\tset iridescence( value ) {\n\n\t\tif ( this._iridescence > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._iridescence = value;\n\n\t}\n\n\tget sheen() {\n\n\t\treturn this._sheen;\n\n\t}\n\n\tset sheen( value ) {\n\n\t\tif ( this._sheen > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._sheen = value;\n\n\t}\n\n\tget transmission() {\n\n\t\treturn this._transmission;\n\n\t}\n\n\tset transmission( value ) {\n\n\t\tif ( this._transmission > 0 !== value > 0 ) {\n\n\t\t\tthis.version ++;\n\n\t\t}\n\n\t\tthis._transmission = value;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = {\n\n\t\t\t'STANDARD': '',\n\t\t\t'PHYSICAL': ''\n\n\t\t};\n\n\t\tthis.anisotropy = source.anisotropy;\n\t\tthis.anisotropyRotation = source.anisotropyRotation;\n\t\tthis.anisotropyMap = source.anisotropyMap;\n\n\t\tthis.clearcoat = source.clearcoat;\n\t\tthis.clearcoatMap = source.clearcoatMap;\n\t\tthis.clearcoatRoughness = source.clearcoatRoughness;\n\t\tthis.clearcoatRoughnessMap = source.clearcoatRoughnessMap;\n\t\tthis.clearcoatNormalMap = source.clearcoatNormalMap;\n\t\tthis.clearcoatNormalScale.copy( source.clearcoatNormalScale );\n\n\t\tthis.ior = source.ior;\n\n\t\tthis.iridescence = source.iridescence;\n\t\tthis.iridescenceMap = source.iridescenceMap;\n\t\tthis.iridescenceIOR = source.iridescenceIOR;\n\t\tthis.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];\n\t\tthis.iridescenceThicknessMap = source.iridescenceThicknessMap;\n\n\t\tthis.sheen = source.sheen;\n\t\tthis.sheenColor.copy( source.sheenColor );\n\t\tthis.sheenColorMap = source.sheenColorMap;\n\t\tthis.sheenRoughness = source.sheenRoughness;\n\t\tthis.sheenRoughnessMap = source.sheenRoughnessMap;\n\n\t\tthis.transmission = source.transmission;\n\t\tthis.transmissionMap = source.transmissionMap;\n\n\t\tthis.thickness = source.thickness;\n\t\tthis.thicknessMap = source.thicknessMap;\n\t\tthis.attenuationDistance = source.attenuationDistance;\n\t\tthis.attenuationColor.copy( source.attenuationColor );\n\n\t\tthis.specularIntensity = source.specularIntensity;\n\t\tthis.specularIntensityMap = source.specularIntensityMap;\n\t\tthis.specularColor.copy( source.specularColor );\n\t\tthis.specularColorMap = source.specularColorMap;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshPhongMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshPhongMaterial = true;\n\n\t\tthis.type = 'MeshPhongMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\t\tthis.specular = new Color( 0x111111 );\n\t\tthis.shininess = 30;\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.specular.copy( source.specular );\n\t\tthis.shininess = source.shininess;\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshToonMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshToonMaterial = true;\n\n\t\tthis.defines = { 'TOON': '' };\n\n\t\tthis.type = 'MeshToonMaterial';\n\n\t\tthis.color = new Color( 0xffffff );\n\n\t\tthis.map = null;\n\t\tthis.gradientMap = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\t\tthis.gradientMap = source.gradientMap;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshNormalMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshNormalMaterial = true;\n\n\t\tthis.type = 'MeshNormalMaterial';\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\n\t\tthis.flatShading = false;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshLambertMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshLambertMaterial = true;\n\n\t\tthis.type = 'MeshLambertMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.map = null;\n\n\t\tthis.lightMap = null;\n\t\tthis.lightMapIntensity = 1.0;\n\n\t\tthis.aoMap = null;\n\t\tthis.aoMapIntensity = 1.0;\n\n\t\tthis.emissive = new Color( 0x000000 );\n\t\tthis.emissiveIntensity = 1.0;\n\t\tthis.emissiveMap = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.specularMap = null;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.envMap = null;\n\t\tthis.combine = MultiplyOperation;\n\t\tthis.reflectivity = 1;\n\t\tthis.refractionRatio = 0.98;\n\n\t\tthis.wireframe = false;\n\t\tthis.wireframeLinewidth = 1;\n\t\tthis.wireframeLinecap = 'round';\n\t\tthis.wireframeLinejoin = 'round';\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.map = source.map;\n\n\t\tthis.lightMap = source.lightMap;\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\t\tthis.aoMap = source.aoMap;\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\t\tthis.emissive.copy( source.emissive );\n\t\tthis.emissiveMap = source.emissiveMap;\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.specularMap = source.specularMap;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.envMap = source.envMap;\n\t\tthis.combine = source.combine;\n\t\tthis.reflectivity = source.reflectivity;\n\t\tthis.refractionRatio = source.refractionRatio;\n\n\t\tthis.wireframe = source.wireframe;\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass MeshMatcapMaterial extends Material {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isMeshMatcapMaterial = true;\n\n\t\tthis.defines = { 'MATCAP': '' };\n\n\t\tthis.type = 'MeshMatcapMaterial';\n\n\t\tthis.color = new Color( 0xffffff ); // diffuse\n\n\t\tthis.matcap = null;\n\n\t\tthis.map = null;\n\n\t\tthis.bumpMap = null;\n\t\tthis.bumpScale = 1;\n\n\t\tthis.normalMap = null;\n\t\tthis.normalMapType = TangentSpaceNormalMap;\n\t\tthis.normalScale = new Vector2( 1, 1 );\n\n\t\tthis.displacementMap = null;\n\t\tthis.displacementScale = 1;\n\t\tthis.displacementBias = 0;\n\n\t\tthis.alphaMap = null;\n\n\t\tthis.flatShading = false;\n\n\t\tthis.fog = true;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.defines = { 'MATCAP': '' };\n\n\t\tthis.color.copy( source.color );\n\n\t\tthis.matcap = source.matcap;\n\n\t\tthis.map = source.map;\n\n\t\tthis.bumpMap = source.bumpMap;\n\t\tthis.bumpScale = source.bumpScale;\n\n\t\tthis.normalMap = source.normalMap;\n\t\tthis.normalMapType = source.normalMapType;\n\t\tthis.normalScale.copy( source.normalScale );\n\n\t\tthis.displacementMap = source.displacementMap;\n\t\tthis.displacementScale = source.displacementScale;\n\t\tthis.displacementBias = source.displacementBias;\n\n\t\tthis.alphaMap = source.alphaMap;\n\n\t\tthis.flatShading = source.flatShading;\n\n\t\tthis.fog = source.fog;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass LineDashedMaterial extends LineBasicMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper();\n\n\t\tthis.isLineDashedMaterial = true;\n\n\t\tthis.type = 'LineDashedMaterial';\n\n\t\tthis.scale = 1;\n\t\tthis.dashSize = 3;\n\t\tthis.gapSize = 1;\n\n\t\tthis.setValues( parameters );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.scale = source.scale;\n\t\tthis.dashSize = source.dashSize;\n\t\tthis.gapSize = source.gapSize;\n\n\t\treturn this;\n\n\t}\n\n}\n\n// same as Array.prototype.slice, but also works on typed arrays\nfunction arraySlice( array, from, to ) {\n\n\tif ( isTypedArray( array ) ) {\n\n\t\t// in ios9 array.subarray(from, undefined) will return empty array\n\t\t// but array.subarray(from) or array.subarray(from, len) is correct\n\t\treturn new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );\n\n\t}\n\n\treturn array.slice( from, to );\n\n}\n\n// converts an array to a specific type\nfunction convertArray( array, type, forceClone ) {\n\n\tif ( ! array || // let 'undefined' and 'null' pass\n\t\t! forceClone && array.constructor === type ) return array;\n\n\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\n\n\t\treturn new type( array ); // create typed array\n\n\t}\n\n\treturn Array.prototype.slice.call( array ); // create Array\n\n}\n\nfunction isTypedArray( object ) {\n\n\treturn ArrayBuffer.isView( object ) &&\n\t\t! ( object instanceof DataView );\n\n}\n\n// returns an array by which times and values can be sorted\nfunction getKeyframeOrder( times ) {\n\n\tfunction compareTime( i, j ) {\n\n\t\treturn times[ i ] - times[ j ];\n\n\t}\n\n\tconst n = times.length;\n\tconst result = new Array( n );\n\tfor ( let i = 0; i !== n; ++ i ) result[ i ] = i;\n\n\tresult.sort( compareTime );\n\n\treturn result;\n\n}\n\n// uses the array previously returned by 'getKeyframeOrder' to sort data\nfunction sortedArray( values, stride, order ) {\n\n\tconst nValues = values.length;\n\tconst result = new values.constructor( nValues );\n\n\tfor ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\n\n\t\tconst srcOffset = order[ i ] * stride;\n\n\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n// function for parsing AOS keyframe formats\nfunction flattenJSON( jsonKeys, times, values, valuePropertyName ) {\n\n\tlet i = 1, key = jsonKeys[ 0 ];\n\n\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\n\n\t\tkey = jsonKeys[ i ++ ];\n\n\t}\n\n\tif ( key === undefined ) return; // no data\n\n\tlet value = key[ valuePropertyName ];\n\tif ( value === undefined ) return; // no data\n\n\tif ( Array.isArray( value ) ) {\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push.apply( values, value ); // push all elements\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else if ( value.toArray !== undefined ) {\n\n\t\t// ...assume THREE.Math-ish\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalue.toArray( values, values.length );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t} else {\n\n\t\t// otherwise push as-is\n\n\t\tdo {\n\n\t\t\tvalue = key[ valuePropertyName ];\n\n\t\t\tif ( value !== undefined ) {\n\n\t\t\t\ttimes.push( key.time );\n\t\t\t\tvalues.push( value );\n\n\t\t\t}\n\n\t\t\tkey = jsonKeys[ i ++ ];\n\n\t\t} while ( key !== undefined );\n\n\t}\n\n}\n\nfunction subclip( sourceClip, name, startFrame, endFrame, fps = 30 ) {\n\n\tconst clip = sourceClip.clone();\n\n\tclip.name = name;\n\n\tconst tracks = [];\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tconst track = clip.tracks[ i ];\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = [];\n\t\tconst values = [];\n\n\t\tfor ( let j = 0; j < track.times.length; ++ j ) {\n\n\t\t\tconst frame = track.times[ j ] * fps;\n\n\t\t\tif ( frame < startFrame || frame >= endFrame ) continue;\n\n\t\t\ttimes.push( track.times[ j ] );\n\n\t\t\tfor ( let k = 0; k < valueSize; ++ k ) {\n\n\t\t\t\tvalues.push( track.values[ j * valueSize + k ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( times.length === 0 ) continue;\n\n\t\ttrack.times = convertArray( times, track.times.constructor );\n\t\ttrack.values = convertArray( values, track.values.constructor );\n\n\t\ttracks.push( track );\n\n\t}\n\n\tclip.tracks = tracks;\n\n\t// find minimum .times value across all tracks in the trimmed clip\n\n\tlet minStartTime = Infinity;\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tif ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {\n\n\t\t\tminStartTime = clip.tracks[ i ].times[ 0 ];\n\n\t\t}\n\n\t}\n\n\t// shift all tracks such that clip begins at t=0\n\n\tfor ( let i = 0; i < clip.tracks.length; ++ i ) {\n\n\t\tclip.tracks[ i ].shift( - 1 * minStartTime );\n\n\t}\n\n\tclip.resetDuration();\n\n\treturn clip;\n\n}\n\nfunction makeClipAdditive( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {\n\n\tif ( fps <= 0 ) fps = 30;\n\n\tconst numTracks = referenceClip.tracks.length;\n\tconst referenceTime = referenceFrame / fps;\n\n\t// Make each track's values relative to the values at the reference frame\n\tfor ( let i = 0; i < numTracks; ++ i ) {\n\n\t\tconst referenceTrack = referenceClip.tracks[ i ];\n\t\tconst referenceTrackType = referenceTrack.ValueTypeName;\n\n\t\t// Skip this track if it's non-numeric\n\t\tif ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;\n\n\t\t// Find the track in the target clip whose name and type matches the reference track\n\t\tconst targetTrack = targetClip.tracks.find( function ( track ) {\n\n\t\t\treturn track.name === referenceTrack.name\n\t\t\t\t&& track.ValueTypeName === referenceTrackType;\n\n\t\t} );\n\n\t\tif ( targetTrack === undefined ) continue;\n\n\t\tlet referenceOffset = 0;\n\t\tconst referenceValueSize = referenceTrack.getValueSize();\n\n\t\tif ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\treferenceOffset = referenceValueSize / 3;\n\n\t\t}\n\n\t\tlet targetOffset = 0;\n\t\tconst targetValueSize = targetTrack.getValueSize();\n\n\t\tif ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\ttargetOffset = targetValueSize / 3;\n\n\t\t}\n\n\t\tconst lastIndex = referenceTrack.times.length - 1;\n\t\tlet referenceValue;\n\n\t\t// Find the value to subtract out of the track\n\t\tif ( referenceTime <= referenceTrack.times[ 0 ] ) {\n\n\t\t\t// Reference frame is earlier than the first keyframe, so just use the first keyframe\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\treferenceValue = arraySlice( referenceTrack.values, startIndex, endIndex );\n\n\t\t} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {\n\n\t\t\t// Reference frame is after the last keyframe, so just use the last keyframe\n\t\t\tconst startIndex = lastIndex * referenceValueSize + referenceOffset;\n\t\t\tconst endIndex = startIndex + referenceValueSize - referenceOffset;\n\t\t\treferenceValue = arraySlice( referenceTrack.values, startIndex, endIndex );\n\n\t\t} else {\n\n\t\t\t// Interpolate to the reference value\n\t\t\tconst interpolant = referenceTrack.createInterpolant();\n\t\t\tconst startIndex = referenceOffset;\n\t\t\tconst endIndex = referenceValueSize - referenceOffset;\n\t\t\tinterpolant.evaluate( referenceTime );\n\t\t\treferenceValue = arraySlice( interpolant.resultBuffer, startIndex, endIndex );\n\n\t\t}\n\n\t\t// Conjugate the quaternion\n\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\tconst referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();\n\t\t\treferenceQuat.toArray( referenceValue );\n\n\t\t}\n\n\t\t// Subtract the reference value from all of the track values\n\n\t\tconst numTimes = targetTrack.times.length;\n\t\tfor ( let j = 0; j < numTimes; ++ j ) {\n\n\t\t\tconst valueStart = j * targetValueSize + targetOffset;\n\n\t\t\tif ( referenceTrackType === 'quaternion' ) {\n\n\t\t\t\t// Multiply the conjugate for quaternion track types\n\t\t\t\tQuaternion.multiplyQuaternionsFlat(\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart,\n\t\t\t\t\treferenceValue,\n\t\t\t\t\t0,\n\t\t\t\t\ttargetTrack.values,\n\t\t\t\t\tvalueStart\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tconst valueEnd = targetValueSize - targetOffset * 2;\n\n\t\t\t\t// Subtract each value for all other numeric track types\n\t\t\t\tfor ( let k = 0; k < valueEnd; ++ k ) {\n\n\t\t\t\t\ttargetTrack.values[ valueStart + k ] -= referenceValue[ k ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttargetClip.blendMode = AdditiveAnimationBlendMode;\n\n\treturn targetClip;\n\n}\n\nconst AnimationUtils = {\n\tarraySlice: arraySlice,\n\tconvertArray: convertArray,\n\tisTypedArray: isTypedArray,\n\tgetKeyframeOrder: getKeyframeOrder,\n\tsortedArray: sortedArray,\n\tflattenJSON: flattenJSON,\n\tsubclip: subclip,\n\tmakeClipAdditive: makeClipAdditive\n};\n\n/**\n * Abstract base class of interpolants over parametric samples.\n *\n * The parameter domain is one dimensional, typically the time or a path\n * along a curve defined by the data.\n *\n * The sample values can have any dimensionality and derived classes may\n * apply special interpretations to the data.\n *\n * This class provides the interval seek in a Template Method, deferring\n * the actual interpolation to derived classes.\n *\n * Time complexity is O(1) for linear access crossing at most two points\n * and O(log N) for random access, where N is the number of positions.\n *\n * References:\n *\n * \t\thttp://www.oodesign.com/template-method-pattern.html\n *\n */\n\nclass Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tthis.parameterPositions = parameterPositions;\n\t\tthis._cachedIndex = 0;\n\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\n\t\tthis.sampleValues = sampleValues;\n\t\tthis.valueSize = sampleSize;\n\n\t\tthis.settings = null;\n\t\tthis.DefaultSettings_ = {};\n\n\t}\n\n\tevaluate( t ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet i1 = this._cachedIndex,\n\t\t\tt1 = pp[ i1 ],\n\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\tvalidate_interval: {\n\n\t\t\tseek: {\n\n\t\t\t\tlet right;\n\n\t\t\t\tlinear_scan: {\n\n\t\t\t\t\t//- See http://jsperf.com/comparison-to-undefined/3\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\n\t\t\t\t\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 + 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\n\n\t\t\t\t\t\t\t\t// after end\n\n\t\t\t\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt0 = t1;\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\n\n\t\t\t\t\t\t\tif ( t < t1 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the right side of the index\n\t\t\t\t\t\tright = pp.length;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//- slower code:\n\t\t\t\t\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\n\n\t\t\t\t\t\t// looping?\n\n\t\t\t\t\t\tconst t1global = pp[ 1 ];\n\n\t\t\t\t\t\tif ( t < t1global ) {\n\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\n\t\t\t\t\t\t\tt0 = t1global;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// linear reverse scan\n\n\t\t\t\t\t\tfor ( let giveUpAt = i1 - 2; ; ) {\n\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\t\t\t\t// before start\n\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\t\t\t\treturn this.copySampleValue_( 0 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\n\n\t\t\t\t\t\t\tt1 = t0;\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\n\n\t\t\t\t\t\t\tif ( t >= t0 ) {\n\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\n\t\t\t\t\t\t\t\tbreak seek;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// prepare binary search on the left side of the index\n\t\t\t\t\t\tright = i1;\n\t\t\t\t\t\ti1 = 0;\n\t\t\t\t\t\tbreak linear_scan;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// the interval is valid\n\n\t\t\t\t\tbreak validate_interval;\n\n\t\t\t\t} // linear scan\n\n\t\t\t\t// binary search\n\n\t\t\t\twhile ( i1 < right ) {\n\n\t\t\t\t\tconst mid = ( i1 + right ) >>> 1;\n\n\t\t\t\t\tif ( t < pp[ mid ] ) {\n\n\t\t\t\t\t\tright = mid;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ti1 = mid + 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tt1 = pp[ i1 ];\n\t\t\t\tt0 = pp[ i1 - 1 ];\n\n\t\t\t\t// check boundary cases, again\n\n\t\t\t\tif ( t0 === undefined ) {\n\n\t\t\t\t\tthis._cachedIndex = 0;\n\t\t\t\t\treturn this.copySampleValue_( 0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( t1 === undefined ) {\n\n\t\t\t\t\ti1 = pp.length;\n\t\t\t\t\tthis._cachedIndex = i1;\n\t\t\t\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t\t\t\t}\n\n\t\t\t} // seek\n\n\t\t\tthis._cachedIndex = i1;\n\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\n\n\t\t} // validate_interval\n\n\t\treturn this.interpolate_( i1, t0, t, t1 );\n\n\t}\n\n\tgetSettings_() {\n\n\t\treturn this.settings || this.DefaultSettings_;\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// copies a sample value to the result buffer\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = index * stride;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\t// Template methods for derived classes:\n\n\tinterpolate_( /* i1, t0, t, t1 */ ) {\n\n\t\tthrow new Error( 'call to abstract method' );\n\t\t// implementations shall return this.resultBuffer\n\n\t}\n\n\tintervalChanged_( /* i1, t0, t1 */ ) {\n\n\t\t// empty\n\n\t}\n\n}\n\n/**\n * Fast and simple cubic spline interpolant.\n *\n * It was derived from a Hermitian construction setting the first derivative\n * at each sample position to the linear slope between neighboring positions\n * over their parameter interval.\n */\n\nclass CubicInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t\tthis._weightPrev = - 0;\n\t\tthis._offsetPrev = - 0;\n\t\tthis._weightNext = - 0;\n\t\tthis._offsetNext = - 0;\n\n\t\tthis.DefaultSettings_ = {\n\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\n\t\t};\n\n\t}\n\n\tintervalChanged_( i1, t0, t1 ) {\n\n\t\tconst pp = this.parameterPositions;\n\t\tlet iPrev = i1 - 2,\n\t\t\tiNext = i1 + 1,\n\n\t\t\ttPrev = pp[ iPrev ],\n\t\t\ttNext = pp[ iNext ];\n\n\t\tif ( tPrev === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingStart ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(t0) = 0\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = 2 * t0 - t1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiPrev = pp.length - 2;\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\n\t\t\t\t\tiPrev = i1;\n\t\t\t\t\ttPrev = t1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tNext === undefined ) {\n\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\n\n\t\t\t\tcase ZeroSlopeEnding:\n\n\t\t\t\t\t// f'(tN) = 0\n\t\t\t\t\tiNext = i1;\n\t\t\t\t\ttNext = 2 * t1 - t0;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase WrapAroundEnding:\n\n\t\t\t\t\t// use the other end of the curve\n\t\t\t\t\tiNext = 1;\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault: // ZeroCurvatureEnding\n\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\n\t\t\t\t\tiNext = i1 - 1;\n\t\t\t\t\ttNext = t0;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst halfDt = ( t1 - t0 ) * 0.5,\n\t\t\tstride = this.valueSize;\n\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\n\t\tthis._offsetPrev = iPrev * stride;\n\t\tthis._offsetNext = iNext * stride;\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\n\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tpp = p * p,\n\t\t\tppp = pp * p;\n\n\t\t// evaluate polynomials\n\n\t\tconst sP = - wP * ppp + 2 * wP * pp - wP * p;\n\t\tconst s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\n\t\tconst s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\n\t\tconst sN = wN * ppp - wN * pp;\n\n\t\t// combine data linearly\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tsP * values[ oP + i ] +\n\t\t\t\t\ts0 * values[ o0 + i ] +\n\t\t\t\t\ts1 * values[ o1 + i ] +\n\t\t\t\t\tsN * values[ oN + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nclass LinearInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\toffset1 = i1 * stride,\n\t\t\toffset0 = offset1 - stride,\n\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\n\t\t\tweight0 = 1 - weight1;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tresult[ i ] =\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\n/**\n *\n * Interpolant that evaluates to the sample value at the position preceding\n * the parameter.\n */\n\nclass DiscreteInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1 /*, t0, t, t1 */ ) {\n\n\t\treturn this.copySampleValue_( i1 - 1 );\n\n\t}\n\n}\n\nclass KeyframeTrack {\n\n\tconstructor( name, times, values, interpolation ) {\n\n\t\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\n\t\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\n\n\t\tthis.name = name;\n\n\t\tthis.times = convertArray( times, this.TimeBufferType );\n\t\tthis.values = convertArray( values, this.ValueBufferType );\n\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\n\n\t}\n\n\t// Serialization (in static context, because of constructor invocation\n\t// and automatic invocation of .toJSON):\n\n\tstatic toJSON( track ) {\n\n\t\tconst trackType = track.constructor;\n\n\t\tlet json;\n\n\t\t// derived classes can define a static toJSON method\n\t\tif ( trackType.toJSON !== this.toJSON ) {\n\n\t\t\tjson = trackType.toJSON( track );\n\n\t\t} else {\n\n\t\t\t// by default, we assume the data can be serialized as-is\n\t\t\tjson = {\n\n\t\t\t\t'name': track.name,\n\t\t\t\t'times': convertArray( track.times, Array ),\n\t\t\t\t'values': convertArray( track.values, Array )\n\n\t\t\t};\n\n\t\t\tconst interpolation = track.getInterpolation();\n\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\n\n\t\t\t\tjson.interpolation = interpolation;\n\n\t\t\t}\n\n\t\t}\n\n\t\tjson.type = track.ValueTypeName; // mandatory\n\n\t\treturn json;\n\n\t}\n\n\tInterpolantFactoryMethodDiscrete( result ) {\n\n\t\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tInterpolantFactoryMethodSmooth( result ) {\n\n\t\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n\tsetInterpolation( interpolation ) {\n\n\t\tlet factoryMethod;\n\n\t\tswitch ( interpolation ) {\n\n\t\t\tcase InterpolateDiscrete:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateLinear:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\n\n\t\t\t\tbreak;\n\n\t\t\tcase InterpolateSmooth:\n\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( factoryMethod === undefined ) {\n\n\t\t\tconst message = 'unsupported interpolation for ' +\n\t\t\t\tthis.ValueTypeName + ' keyframe track named ' + this.name;\n\n\t\t\tif ( this.createInterpolant === undefined ) {\n\n\t\t\t\t// fall back to default, unless the default itself is messed up\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\n\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.KeyframeTrack:', message );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.createInterpolant = factoryMethod;\n\n\t\treturn this;\n\n\t}\n\n\tgetInterpolation() {\n\n\t\tswitch ( this.createInterpolant ) {\n\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\n\n\t\t\t\treturn InterpolateDiscrete;\n\n\t\t\tcase this.InterpolantFactoryMethodLinear:\n\n\t\t\t\treturn InterpolateLinear;\n\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\n\n\t\t\t\treturn InterpolateSmooth;\n\n\t\t}\n\n\t}\n\n\tgetValueSize() {\n\n\t\treturn this.values.length / this.times.length;\n\n\t}\n\n\t// move all keyframes either forwards or backwards in time\n\tshift( timeOffset ) {\n\n\t\tif ( timeOffset !== 0.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] += timeOffset;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\n\tscale( timeScale ) {\n\n\t\tif ( timeScale !== 1.0 ) {\n\n\t\t\tconst times = this.times;\n\n\t\t\tfor ( let i = 0, n = times.length; i !== n; ++ i ) {\n\n\t\t\t\ttimes[ i ] *= timeScale;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\n\ttrim( startTime, endTime ) {\n\n\t\tconst times = this.times,\n\t\t\tnKeys = times.length;\n\n\t\tlet from = 0,\n\t\t\tto = nKeys - 1;\n\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) {\n\n\t\t\t++ from;\n\n\t\t}\n\n\t\twhile ( to !== - 1 && times[ to ] > endTime ) {\n\n\t\t\t-- to;\n\n\t\t}\n\n\t\t++ to; // inclusive -> exclusive bound\n\n\t\tif ( from !== 0 || to !== nKeys ) {\n\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\n\t\t\tif ( from >= to ) {\n\n\t\t\t\tto = Math.max( to, 1 );\n\t\t\t\tfrom = to - 1;\n\n\t\t\t}\n\n\t\t\tconst stride = this.getValueSize();\n\t\t\tthis.times = arraySlice( times, from, to );\n\t\t\tthis.values = arraySlice( this.values, from * stride, to * stride );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tconst valueSize = this.getValueSize();\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tconst times = this.times,\n\t\t\tvalues = this.values,\n\n\t\t\tnKeys = times.length;\n\n\t\tif ( nKeys === 0 ) {\n\n\t\t\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\n\t\t\tvalid = false;\n\n\t\t}\n\n\t\tlet prevTime = null;\n\n\t\tfor ( let i = 0; i !== nKeys; i ++ ) {\n\n\t\t\tconst currTime = times[ i ];\n\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( prevTime !== null && prevTime > currTime ) {\n\n\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\n\t\t\t\tvalid = false;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t\tif ( values !== undefined ) {\n\n\t\t\tif ( isTypedArray( values ) ) {\n\n\t\t\t\tfor ( let i = 0, n = values.length; i !== n; ++ i ) {\n\n\t\t\t\t\tconst value = values[ i ];\n\n\t\t\t\t\tif ( isNaN( value ) ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\t// removes equivalent sequential keys as common in morph target sequences\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\n\toptimize() {\n\n\t\t// times or values may be shared with other tracks, so overwriting is unsafe\n\t\tconst times = arraySlice( this.times ),\n\t\t\tvalues = arraySlice( this.values ),\n\t\t\tstride = this.getValueSize(),\n\n\t\t\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\n\n\t\t\tlastIndex = times.length - 1;\n\n\t\tlet writeIndex = 1;\n\n\t\tfor ( let i = 1; i < lastIndex; ++ i ) {\n\n\t\t\tlet keep = false;\n\n\t\t\tconst time = times[ i ];\n\t\t\tconst timeNext = times[ i + 1 ];\n\n\t\t\t// remove adjacent keyframes scheduled at the same time\n\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {\n\n\t\t\t\tif ( ! smoothInterpolation ) {\n\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\n\n\t\t\t\t\tconst offset = i * stride,\n\t\t\t\t\t\toffsetP = offset - stride,\n\t\t\t\t\t\toffsetN = offset + stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tconst value = values[ offset + j ];\n\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\n\n\t\t\t\t\t\t\tkeep = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tkeep = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// in-place compaction\n\n\t\t\tif ( keep ) {\n\n\t\t\t\tif ( i !== writeIndex ) {\n\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\n\n\t\t\t\t\tconst readOffset = i * stride,\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\n\n\t\t\t\t\tfor ( let j = 0; j !== stride; ++ j ) {\n\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t++ writeIndex;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// flush last keyframe (compaction looks ahead)\n\n\t\tif ( lastIndex > 0 ) {\n\n\t\t\ttimes[ writeIndex ] = times[ lastIndex ];\n\n\t\t\tfor ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\n\n\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\n\n\t\t\t}\n\n\t\t\t++ writeIndex;\n\n\t\t}\n\n\t\tif ( writeIndex !== times.length ) {\n\n\t\t\tthis.times = arraySlice( times, 0, writeIndex );\n\t\t\tthis.values = arraySlice( values, 0, writeIndex * stride );\n\n\t\t} else {\n\n\t\t\tthis.times = times;\n\t\t\tthis.values = values;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst times = arraySlice( this.times, 0 );\n\t\tconst values = arraySlice( this.values, 0 );\n\n\t\tconst TypedKeyframeTrack = this.constructor;\n\t\tconst track = new TypedKeyframeTrack( this.name, times, values );\n\n\t\t// Interpolant argument to constructor is not saved, so copy the factory method directly.\n\t\ttrack.createInterpolant = this.createInterpolant;\n\n\t\treturn track;\n\n\t}\n\n}\n\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\n\n/**\n * A Track of Boolean keyframe values.\n */\nclass BooleanKeyframeTrack extends KeyframeTrack {}\n\nBooleanKeyframeTrack.prototype.ValueTypeName = 'bool';\nBooleanKeyframeTrack.prototype.ValueBufferType = Array;\nBooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of keyframe values that represent color.\n */\nclass ColorKeyframeTrack extends KeyframeTrack {}\n\nColorKeyframeTrack.prototype.ValueTypeName = 'color';\n\n/**\n * A Track of numeric keyframe values.\n */\nclass NumberKeyframeTrack extends KeyframeTrack {}\n\nNumberKeyframeTrack.prototype.ValueTypeName = 'number';\n\n/**\n * Spherical linear unit quaternion interpolant.\n */\n\nclass QuaternionLinearInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tstride = this.valueSize,\n\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\n\n\t\tlet offset = i1 * stride;\n\n\t\tfor ( let end = offset + stride; offset !== end; offset += 4 ) {\n\n\t\t\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\n/**\n * A Track of quaternion keyframe values.\n */\nclass QuaternionKeyframeTrack extends KeyframeTrack {\n\n\tInterpolantFactoryMethodLinear( result ) {\n\n\t\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\n\n\t}\n\n}\n\nQuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';\n// ValueBufferType is inherited\nQuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\nQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track that interpolates Strings\n */\nclass StringKeyframeTrack extends KeyframeTrack {}\n\nStringKeyframeTrack.prototype.ValueTypeName = 'string';\nStringKeyframeTrack.prototype.ValueBufferType = Array;\nStringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;\n\n/**\n * A Track of vectored keyframe values.\n */\nclass VectorKeyframeTrack extends KeyframeTrack {}\n\nVectorKeyframeTrack.prototype.ValueTypeName = 'vector';\n\nclass AnimationClip {\n\n\tconstructor( name, duration = - 1, tracks, blendMode = NormalAnimationBlendMode ) {\n\n\t\tthis.name = name;\n\t\tthis.tracks = tracks;\n\t\tthis.duration = duration;\n\t\tthis.blendMode = blendMode;\n\n\t\tthis.uuid = generateUUID();\n\n\t\t// this means it should figure out its duration by scanning the tracks\n\t\tif ( this.duration < 0 ) {\n\n\t\t\tthis.resetDuration();\n\n\t\t}\n\n\t}\n\n\n\tstatic parse( json ) {\n\n\t\tconst tracks = [],\n\t\t\tjsonTracks = json.tracks,\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\n\n\t\tfor ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );\n\n\t\t}\n\n\t\tconst clip = new this( json.name, json.duration, tracks, json.blendMode );\n\t\tclip.uuid = json.uuid;\n\n\t\treturn clip;\n\n\t}\n\n\tstatic toJSON( clip ) {\n\n\t\tconst tracks = [],\n\t\t\tclipTracks = clip.tracks;\n\n\t\tconst json = {\n\n\t\t\t'name': clip.name,\n\t\t\t'duration': clip.duration,\n\t\t\t'tracks': tracks,\n\t\t\t'uuid': clip.uuid,\n\t\t\t'blendMode': clip.blendMode\n\n\t\t};\n\n\t\tfor ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {\n\n\t\t\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\n\n\t\t}\n\n\t\treturn json;\n\n\t}\n\n\tstatic CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {\n\n\t\tconst numMorphTargets = morphTargetSequence.length;\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; i ++ ) {\n\n\t\t\tlet times = [];\n\t\t\tlet values = [];\n\n\t\t\ttimes.push(\n\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\n\t\t\t\ti,\n\t\t\t\t( i + 1 ) % numMorphTargets );\n\n\t\t\tvalues.push( 0, 1, 0 );\n\n\t\t\tconst order = getKeyframeOrder( times );\n\t\t\ttimes = sortedArray( times, 1, order );\n\t\t\tvalues = sortedArray( values, 1, order );\n\n\t\t\t// if there is a key at the first frame, duplicate it as the\n\t\t\t// last frame as well for perfect loop.\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\n\n\t\t\t\ttimes.push( numMorphTargets );\n\t\t\t\tvalues.push( values[ 0 ] );\n\n\t\t\t}\n\n\t\t\ttracks.push(\n\t\t\t\tnew NumberKeyframeTrack(\n\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\n\t\t\t\t\ttimes, values\n\t\t\t\t).scale( 1.0 / fps ) );\n\n\t\t}\n\n\t\treturn new this( name, - 1, tracks );\n\n\t}\n\n\tstatic findByName( objectOrClipArray, name ) {\n\n\t\tlet clipArray = objectOrClipArray;\n\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\n\n\t\t\tconst o = objectOrClipArray;\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\n\n\t\t}\n\n\t\tfor ( let i = 0; i < clipArray.length; i ++ ) {\n\n\t\t\tif ( clipArray[ i ].name === name ) {\n\n\t\t\t\treturn clipArray[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tstatic CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {\n\n\t\tconst animationToMorphTargets = {};\n\n\t\t// tested with https://regex101.com/ on trick sequences\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\n\t\tconst pattern = /^([\\w-]*?)([\\d]+)$/;\n\n\t\t// sort morph target names into animation groups based\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\n\t\tfor ( let i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tconst morphTarget = morphTargets[ i ];\n\t\t\tconst parts = morphTarget.name.match( pattern );\n\n\t\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\t\tconst name = parts[ 1 ];\n\n\t\t\t\tlet animationMorphTargets = animationToMorphTargets[ name ];\n\n\t\t\t\tif ( ! animationMorphTargets ) {\n\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\n\n\t\t\t\t}\n\n\t\t\t\tanimationMorphTargets.push( morphTarget );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst clips = [];\n\n\t\tfor ( const name in animationToMorphTargets ) {\n\n\t\t\tclips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\n\n\t\t}\n\n\t\treturn clips;\n\n\t}\n\n\t// parse the animation.hierarchy format\n\tstatic parseAnimation( animation, bones ) {\n\n\t\tif ( ! animation ) {\n\n\t\t\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\n\n\t\t\t// only return track if there are actually keys.\n\t\t\tif ( animationKeys.length !== 0 ) {\n\n\t\t\t\tconst times = [];\n\t\t\t\tconst values = [];\n\n\t\t\t\tflattenJSON( animationKeys, times, values, propertyName );\n\n\t\t\t\t// empty keys are filtered out, so check again\n\t\t\t\tif ( times.length !== 0 ) {\n\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tconst tracks = [];\n\n\t\tconst clipName = animation.name || 'default';\n\t\tconst fps = animation.fps || 30;\n\t\tconst blendMode = animation.blendMode;\n\n\t\t// automatic length determination in AnimationClip.\n\t\tlet duration = animation.length || - 1;\n\n\t\tconst hierarchyTracks = animation.hierarchy || [];\n\n\t\tfor ( let h = 0; h < hierarchyTracks.length; h ++ ) {\n\n\t\t\tconst animationKeys = hierarchyTracks[ h ].keys;\n\n\t\t\t// skip empty tracks\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\n\n\t\t\t// process morph targets\n\t\t\tif ( animationKeys[ 0 ].morphTargets ) {\n\n\t\t\t\t// figure out all morph targets used in this track\n\t\t\t\tconst morphTargetNames = {};\n\n\t\t\t\tlet k;\n\n\t\t\t\tfor ( k = 0; k < animationKeys.length; k ++ ) {\n\n\t\t\t\t\tif ( animationKeys[ k ].morphTargets ) {\n\n\t\t\t\t\t\tfor ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// create a track for each morph target with all zero\n\t\t\t\t// morphTargetInfluences except for the keys in which\n\t\t\t\t// the morphTarget is named.\n\t\t\t\tfor ( const morphTargetName in morphTargetNames ) {\n\n\t\t\t\t\tconst times = [];\n\t\t\t\t\tconst values = [];\n\n\t\t\t\t\tfor ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\n\n\t\t\t\t\t\tconst animationKey = animationKeys[ k ];\n\n\t\t\t\t\t\ttimes.push( animationKey.time );\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\n\n\t\t\t\t}\n\n\t\t\t\tduration = morphTargetNames.length * fps;\n\n\t\t\t} else {\n\n\t\t\t\t// ...assume skeletal animation\n\n\t\t\t\tconst boneName = '.bones[' + bones[ h ].name + ']';\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.position',\n\t\t\t\t\tanimationKeys, 'pos', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tQuaternionKeyframeTrack, boneName + '.quaternion',\n\t\t\t\t\tanimationKeys, 'rot', tracks );\n\n\t\t\t\taddNonemptyTrack(\n\t\t\t\t\tVectorKeyframeTrack, boneName + '.scale',\n\t\t\t\t\tanimationKeys, 'scl', tracks );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( tracks.length === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst clip = new this( clipName, duration, tracks, blendMode );\n\n\t\treturn clip;\n\n\t}\n\n\tresetDuration() {\n\n\t\tconst tracks = this.tracks;\n\t\tlet duration = 0;\n\n\t\tfor ( let i = 0, n = tracks.length; i !== n; ++ i ) {\n\n\t\t\tconst track = this.tracks[ i ];\n\n\t\t\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\n\n\t\t}\n\n\t\tthis.duration = duration;\n\n\t\treturn this;\n\n\t}\n\n\ttrim() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tvalidate() {\n\n\t\tlet valid = true;\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tvalid = valid && this.tracks[ i ].validate();\n\n\t\t}\n\n\t\treturn valid;\n\n\t}\n\n\toptimize() {\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\tthis.tracks[ i ].optimize();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\tconst tracks = [];\n\n\t\tfor ( let i = 0; i < this.tracks.length; i ++ ) {\n\n\t\t\ttracks.push( this.tracks[ i ].clone() );\n\n\t\t}\n\n\t\treturn new this.constructor( this.name, this.duration, tracks, this.blendMode );\n\n\t}\n\n\ttoJSON() {\n\n\t\treturn this.constructor.toJSON( this );\n\n\t}\n\n}\n\nfunction getTrackTypeForValueTypeName( typeName ) {\n\n\tswitch ( typeName.toLowerCase() ) {\n\n\t\tcase 'scalar':\n\t\tcase 'double':\n\t\tcase 'float':\n\t\tcase 'number':\n\t\tcase 'integer':\n\n\t\t\treturn NumberKeyframeTrack;\n\n\t\tcase 'vector':\n\t\tcase 'vector2':\n\t\tcase 'vector3':\n\t\tcase 'vector4':\n\n\t\t\treturn VectorKeyframeTrack;\n\n\t\tcase 'color':\n\n\t\t\treturn ColorKeyframeTrack;\n\n\t\tcase 'quaternion':\n\n\t\t\treturn QuaternionKeyframeTrack;\n\n\t\tcase 'bool':\n\t\tcase 'boolean':\n\n\t\t\treturn BooleanKeyframeTrack;\n\n\t\tcase 'string':\n\n\t\t\treturn StringKeyframeTrack;\n\n\t}\n\n\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\n\n}\n\nfunction parseKeyframeTrack( json ) {\n\n\tif ( json.type === undefined ) {\n\n\t\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\n\n\t}\n\n\tconst trackType = getTrackTypeForValueTypeName( json.type );\n\n\tif ( json.times === undefined ) {\n\n\t\tconst times = [], values = [];\n\n\t\tflattenJSON( json.keys, times, values, 'value' );\n\n\t\tjson.times = times;\n\t\tjson.values = values;\n\n\t}\n\n\t// derived classes can define a static parse method\n\tif ( trackType.parse !== undefined ) {\n\n\t\treturn trackType.parse( json );\n\n\t} else {\n\n\t\t// by default, we assume a constructor compatible with the base\n\t\treturn new trackType( json.name, json.times, json.values, json.interpolation );\n\n\t}\n\n}\n\nconst Cache = {\n\n\tenabled: false,\n\n\tfiles: {},\n\n\tadd: function ( key, file ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\tthis.files[ key ] = file;\n\n\t},\n\n\tget: function ( key ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\treturn this.files[ key ];\n\n\t},\n\n\tremove: function ( key ) {\n\n\t\tdelete this.files[ key ];\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.files = {};\n\n\t}\n\n};\n\nclass LoadingManager {\n\n\tconstructor( onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet isLoading = false;\n\t\tlet itemsLoaded = 0;\n\t\tlet itemsTotal = 0;\n\t\tlet urlModifier = undefined;\n\t\tconst handlers = [];\n\n\t\t// Refer to #5689 for the reason why we don't set .onStart\n\t\t// in the constructor\n\n\t\tthis.onStart = undefined;\n\t\tthis.onLoad = onLoad;\n\t\tthis.onProgress = onProgress;\n\t\tthis.onError = onError;\n\n\t\tthis.itemStart = function ( url ) {\n\n\t\t\titemsTotal ++;\n\n\t\t\tif ( isLoading === false ) {\n\n\t\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tisLoading = true;\n\n\t\t};\n\n\t\tthis.itemEnd = function ( url ) {\n\n\t\t\titemsLoaded ++;\n\n\t\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\t\tisLoading = false;\n\n\t\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\t\tscope.onLoad();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.itemError = function ( url ) {\n\n\t\t\tif ( scope.onError !== undefined ) {\n\n\t\t\t\tscope.onError( url );\n\n\t\t\t}\n\n\t\t};\n\n\t\tthis.resolveURL = function ( url ) {\n\n\t\t\tif ( urlModifier ) {\n\n\t\t\t\treturn urlModifier( url );\n\n\t\t\t}\n\n\t\t\treturn url;\n\n\t\t};\n\n\t\tthis.setURLModifier = function ( transform ) {\n\n\t\t\turlModifier = transform;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.addHandler = function ( regex, loader ) {\n\n\t\t\thandlers.push( regex, loader );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.removeHandler = function ( regex ) {\n\n\t\t\tconst index = handlers.indexOf( regex );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\thandlers.splice( index, 2 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.getHandler = function ( file ) {\n\n\t\t\tfor ( let i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\t\tconst regex = handlers[ i ];\n\t\t\t\tconst loader = handlers[ i + 1 ];\n\n\t\t\t\tif ( regex.global ) regex.lastIndex = 0; // see #17920\n\n\t\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\t\treturn loader;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t};\n\n\t}\n\n}\n\nconst DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();\n\nclass Loader {\n\n\tconstructor( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\t\tthis.crossOrigin = 'anonymous';\n\t\tthis.withCredentials = false;\n\t\tthis.path = '';\n\t\tthis.resourcePath = '';\n\t\tthis.requestHeader = {};\n\n\t}\n\n\tload( /* url, onLoad, onProgress, onError */ ) {}\n\n\tloadAsync( url, onProgress ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.load( url, resolve, onProgress, reject );\n\n\t\t} );\n\n\t}\n\n\tparse( /* data */ ) {}\n\n\tsetCrossOrigin( crossOrigin ) {\n\n\t\tthis.crossOrigin = crossOrigin;\n\t\treturn this;\n\n\t}\n\n\tsetWithCredentials( value ) {\n\n\t\tthis.withCredentials = value;\n\t\treturn this;\n\n\t}\n\n\tsetPath( path ) {\n\n\t\tthis.path = path;\n\t\treturn this;\n\n\t}\n\n\tsetResourcePath( resourcePath ) {\n\n\t\tthis.resourcePath = resourcePath;\n\t\treturn this;\n\n\t}\n\n\tsetRequestHeader( requestHeader ) {\n\n\t\tthis.requestHeader = requestHeader;\n\t\treturn this;\n\n\t}\n\n}\n\nLoader.DEFAULT_MATERIAL_NAME = '__DEFAULT';\n\nconst loading = {};\n\nclass HttpError extends Error {\n\n\tconstructor( message, response ) {\n\n\t\tsuper( message );\n\t\tthis.response = response;\n\n\t}\n\n}\n\nclass FileLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tthis.manager.itemStart( url );\n\n\t\t\tsetTimeout( () => {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tthis.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\t// Check if request is duplicate\n\n\t\tif ( loading[ url ] !== undefined ) {\n\n\t\t\tloading[ url ].push( {\n\n\t\t\t\tonLoad: onLoad,\n\t\t\t\tonProgress: onProgress,\n\t\t\t\tonError: onError\n\n\t\t\t} );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// Initialise array for duplicate requests\n\t\tloading[ url ] = [];\n\n\t\tloading[ url ].push( {\n\t\t\tonLoad: onLoad,\n\t\t\tonProgress: onProgress,\n\t\t\tonError: onError,\n\t\t} );\n\n\t\t// create request\n\t\tconst req = new Request( url, {\n\t\t\theaders: new Headers( this.requestHeader ),\n\t\t\tcredentials: this.withCredentials ? 'include' : 'same-origin',\n\t\t\t// An abort controller could be added within a future PR\n\t\t} );\n\n\t\t// record states ( avoid data race )\n\t\tconst mimeType = this.mimeType;\n\t\tconst responseType = this.responseType;\n\n\t\t// start the fetch\n\t\tfetch( req )\n\t\t\t.then( response => {\n\n\t\t\t\tif ( response.status === 200 || response.status === 0 ) {\n\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\n\n\t\t\t\t\tif ( response.status === 0 ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Workaround: Checking if response.body === undefined for Alipay browser #23548\n\n\t\t\t\t\tif ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {\n\n\t\t\t\t\t\treturn response;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst callbacks = loading[ url ];\n\t\t\t\t\tconst reader = response.body.getReader();\n\n\t\t\t\t\t// Nginx needs X-File-Size check\n\t\t\t\t\t// https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content\n\t\t\t\t\tconst contentLength = response.headers.get( 'Content-Length' ) || response.headers.get( 'X-File-Size' );\n\t\t\t\t\tconst total = contentLength ? parseInt( contentLength ) : 0;\n\t\t\t\t\tconst lengthComputable = total !== 0;\n\t\t\t\t\tlet loaded = 0;\n\n\t\t\t\t\t// periodically read data into the new stream tracking while download progress\n\t\t\t\t\tconst stream = new ReadableStream( {\n\t\t\t\t\t\tstart( controller ) {\n\n\t\t\t\t\t\t\treadData();\n\n\t\t\t\t\t\t\tfunction readData() {\n\n\t\t\t\t\t\t\t\treader.read().then( ( { done, value } ) => {\n\n\t\t\t\t\t\t\t\t\tif ( done ) {\n\n\t\t\t\t\t\t\t\t\t\tcontroller.close();\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tloaded += value.byteLength;\n\n\t\t\t\t\t\t\t\t\t\tconst event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );\n\t\t\t\t\t\t\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\t\t\t\t\t\t\tif ( callback.onProgress ) callback.onProgress( event );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tcontroller.enqueue( value );\n\t\t\t\t\t\t\t\t\t\treadData();\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn new Response( stream );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new HttpError( `fetch for \"${response.url}\" responded with ${response.status}: ${response.statusText}`, response );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( response => {\n\n\t\t\t\tswitch ( responseType ) {\n\n\t\t\t\t\tcase 'arraybuffer':\n\n\t\t\t\t\t\treturn response.arrayBuffer();\n\n\t\t\t\t\tcase 'blob':\n\n\t\t\t\t\t\treturn response.blob();\n\n\t\t\t\t\tcase 'document':\n\n\t\t\t\t\t\treturn response.text()\n\t\t\t\t\t\t\t.then( text => {\n\n\t\t\t\t\t\t\t\tconst parser = new DOMParser();\n\t\t\t\t\t\t\t\treturn parser.parseFromString( text, mimeType );\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\tcase 'json':\n\n\t\t\t\t\t\treturn response.json();\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( mimeType === undefined ) {\n\n\t\t\t\t\t\t\treturn response.text();\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// sniff encoding\n\t\t\t\t\t\t\tconst re = /charset=\"?([^;\"\\s]*)\"?/i;\n\t\t\t\t\t\t\tconst exec = re.exec( mimeType );\n\t\t\t\t\t\t\tconst label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;\n\t\t\t\t\t\t\tconst decoder = new TextDecoder( label );\n\t\t\t\t\t\t\treturn response.arrayBuffer().then( ab => decoder.decode( ab ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.then( data => {\n\n\t\t\t\t// Add to cache only on HTTP success, so that we do not cache\n\t\t\t\t// error response bodies as proper responses to requests.\n\t\t\t\tCache.add( url, data );\n\n\t\t\t\tconst callbacks = loading[ url ];\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onLoad ) callback.onLoad( data );\n\n\t\t\t\t}\n\n\t\t\t} )\n\t\t\t.catch( err => {\n\n\t\t\t\t// Abort errors and other errors are handled the same\n\n\t\t\t\tconst callbacks = loading[ url ];\n\n\t\t\t\tif ( callbacks === undefined ) {\n\n\t\t\t\t\t// When onLoad was called and url was deleted in `loading`\n\t\t\t\t\tthis.manager.itemError( url );\n\t\t\t\t\tthrow err;\n\n\t\t\t\t}\n\n\t\t\t\tdelete loading[ url ];\n\n\t\t\t\tfor ( let i = 0, il = callbacks.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst callback = callbacks[ i ];\n\t\t\t\t\tif ( callback.onError ) callback.onError( err );\n\n\t\t\t\t}\n\n\t\t\t\tthis.manager.itemError( url );\n\n\t\t\t} )\n\t\t\t.finally( () => {\n\n\t\t\t\tthis.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\tthis.manager.itemStart( url );\n\n\t}\n\n\tsetResponseType( value ) {\n\n\t\tthis.responseType = value;\n\t\treturn this;\n\n\t}\n\n\tsetMimeType( value ) {\n\n\t\tthis.mimeType = value;\n\t\treturn this;\n\n\t}\n\n}\n\nclass AnimationLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst animations = [];\n\n\t\tfor ( let i = 0; i < json.length; i ++ ) {\n\n\t\t\tconst clip = AnimationClip.parse( json[ i ] );\n\n\t\t\tanimations.push( clip );\n\n\t\t}\n\n\t\treturn animations;\n\n\t}\n\n}\n\n/**\n * Abstract Base class to block based textures loader (dds, pvr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nclass CompressedTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst images = [];\n\n\t\tconst texture = new CompressedTexture();\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( url[ i ], function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\timages[ i ] = {\n\t\t\t\t\twidth: texDatas.width,\n\t\t\t\t\theight: texDatas.height,\n\t\t\t\t\tformat: texDatas.format,\n\t\t\t\t\tmipmaps: texDatas.mipmaps\n\t\t\t\t};\n\n\t\t\t\tloaded += 1;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;\n\n\t\t\t\t\ttexture.image = images;\n\t\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\tif ( Array.isArray( url ) ) {\n\n\t\t\tfor ( let i = 0, il = url.length; i < il; ++ i ) {\n\n\t\t\t\tloadTexture( i );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t\tloader.load( url, function ( buffer ) {\n\n\t\t\t\tconst texDatas = scope.parse( buffer, true );\n\n\t\t\t\tif ( texDatas.isCubemap ) {\n\n\t\t\t\t\tconst faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n\n\t\t\t\t\tfor ( let f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps: [] };\n\n\t\t\t\t\t\tfor ( let i = 0; i < texDatas.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.image = images;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture.image.width = texDatas.width;\n\t\t\t\t\ttexture.image.height = texDatas.height;\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\n\n\t\t\t\t}\n\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\n\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t\t}\n\n\t\t\t\ttexture.format = texDatas.format;\n\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}, onProgress, onError );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass ImageLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tconst image = createElementNS( 'img' );\n\n\t\tfunction onImageLoad() {\n\n\t\t\tremoveEventListeners();\n\n\t\t\tCache.add( url, this );\n\n\t\t\tif ( onLoad ) onLoad( this );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction onImageError( event ) {\n\n\t\t\tremoveEventListeners();\n\n\t\t\tif ( onError ) onError( event );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction removeEventListeners() {\n\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\n\t\t\timage.removeEventListener( 'error', onImageError, false );\n\n\t\t}\n\n\t\timage.addEventListener( 'load', onImageLoad, false );\n\t\timage.addEventListener( 'error', onImageError, false );\n\n\t\tif ( url.slice( 0, 5 ) !== 'data:' ) {\n\n\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\n\n\t\t}\n\n\t\tscope.manager.itemStart( url );\n\n\t\timage.src = url;\n\n\t\treturn image;\n\n\t}\n\n}\n\nclass CubeTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( urls, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new CubeTexture();\n\t\ttexture.colorSpace = SRGBColorSpace;\n\n\t\tconst loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tlet loaded = 0;\n\n\t\tfunction loadTexture( i ) {\n\n\t\t\tloader.load( urls[ i ], function ( image ) {\n\n\t\t\t\ttexture.images[ i ] = image;\n\n\t\t\t\tloaded ++;\n\n\t\t\t\tif ( loaded === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}, undefined, onError );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < urls.length; ++ i ) {\n\n\t\t\tloadTexture( i );\n\n\t\t}\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\n *\n * Sub classes have to implement the parse() method which will be used in load().\n */\n\nclass DataTextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst texture = new DataTexture();\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setPath( this.path );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\tconst texData = scope.parse( buffer );\n\n\t\t\tif ( ! texData ) return;\n\n\t\t\tif ( texData.image !== undefined ) {\n\n\t\t\t\ttexture.image = texData.image;\n\n\t\t\t} else if ( texData.data !== undefined ) {\n\n\t\t\t\ttexture.image.width = texData.width;\n\t\t\t\ttexture.image.height = texData.height;\n\t\t\t\ttexture.image.data = texData.data;\n\n\t\t\t}\n\n\t\t\ttexture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;\n\t\t\ttexture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;\n\n\t\t\ttexture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;\n\t\t\ttexture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;\n\n\t\t\ttexture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;\n\n\t\t\tif ( texData.colorSpace !== undefined ) {\n\n\t\t\t\ttexture.colorSpace = texData.colorSpace;\n\n\t\t\t} else if ( texData.encoding !== undefined ) { // @deprecated, r152\n\n\t\t\t\ttexture.encoding = texData.encoding;\n\n\t\t\t}\n\n\t\t\tif ( texData.flipY !== undefined ) {\n\n\t\t\t\ttexture.flipY = texData.flipY;\n\n\t\t\t}\n\n\t\t\tif ( texData.format !== undefined ) {\n\n\t\t\t\ttexture.format = texData.format;\n\n\t\t\t}\n\n\t\t\tif ( texData.type !== undefined ) {\n\n\t\t\t\ttexture.type = texData.type;\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmaps !== undefined ) {\n\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\n\t\t\t\ttexture.minFilter = LinearMipmapLinearFilter; // presumably...\n\n\t\t\t}\n\n\t\t\tif ( texData.mipmapCount === 1 ) {\n\n\t\t\t\ttexture.minFilter = LinearFilter;\n\n\t\t\t}\n\n\t\t\tif ( texData.generateMipmaps !== undefined ) {\n\n\t\t\t\ttexture.generateMipmaps = texData.generateMipmaps;\n\n\t\t\t}\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}, onProgress, onError );\n\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass TextureLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst texture = new Texture();\n\n\t\tconst loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t}\n\n}\n\nclass Light extends Object3D {\n\n\tconstructor( color, intensity = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.isLight = true;\n\n\t\tthis.type = 'Light';\n\n\t\tthis.color = new Color( color );\n\t\tthis.intensity = intensity;\n\n\t}\n\n\tdispose() {\n\n\t\t// Empty here in base class; some subclasses override.\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.color.copy( source.color );\n\t\tthis.intensity = source.intensity;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.color = this.color.getHex();\n\t\tdata.object.intensity = this.intensity;\n\n\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\n\n\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\n\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\n\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\n\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\n\n\t\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass HemisphereLight extends Light {\n\n\tconstructor( skyColor, groundColor, intensity ) {\n\n\t\tsuper( skyColor, intensity );\n\n\t\tthis.isHemisphereLight = true;\n\n\t\tthis.type = 'HemisphereLight';\n\n\t\tthis.position.copy( Object3D.DEFAULT_UP );\n\t\tthis.updateMatrix();\n\n\t\tthis.groundColor = new Color( groundColor );\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.groundColor.copy( source.groundColor );\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();\nconst _lookTarget$1 = /*@__PURE__*/ new Vector3();\n\nclass LightShadow {\n\n\tconstructor( camera ) {\n\n\t\tthis.camera = camera;\n\n\t\tthis.bias = 0;\n\t\tthis.normalBias = 0;\n\t\tthis.radius = 1;\n\t\tthis.blurSamples = 8;\n\n\t\tthis.mapSize = new Vector2( 512, 512 );\n\n\t\tthis.map = null;\n\t\tthis.mapPass = null;\n\t\tthis.matrix = new Matrix4();\n\n\t\tthis.autoUpdate = true;\n\t\tthis.needsUpdate = false;\n\n\t\tthis._frustum = new Frustum();\n\t\tthis._frameExtents = new Vector2( 1, 1 );\n\n\t\tthis._viewportCount = 1;\n\n\t\tthis._viewports = [\n\n\t\t\tnew Vector4( 0, 0, 1, 1 )\n\n\t\t];\n\n\t}\n\n\tgetViewportCount() {\n\n\t\treturn this._viewportCount;\n\n\t}\n\n\tgetFrustum() {\n\n\t\treturn this._frustum;\n\n\t}\n\n\tupdateMatrices( light ) {\n\n\t\tconst shadowCamera = this.camera;\n\t\tconst shadowMatrix = this.matrix;\n\n\t\t_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );\n\t\tshadowCamera.position.copy( _lightPositionWorld$1 );\n\n\t\t_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );\n\t\tshadowCamera.lookAt( _lookTarget$1 );\n\t\tshadowCamera.updateMatrixWorld();\n\n\t\t_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\tthis._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );\n\n\t\tshadowMatrix.set(\n\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\n\t\tshadowMatrix.multiply( _projScreenMatrix$1 );\n\n\t}\n\n\tgetViewport( viewportIndex ) {\n\n\t\treturn this._viewports[ viewportIndex ];\n\n\t}\n\n\tgetFrameExtents() {\n\n\t\treturn this._frameExtents;\n\n\t}\n\n\tdispose() {\n\n\t\tif ( this.map ) {\n\n\t\t\tthis.map.dispose();\n\n\t\t}\n\n\t\tif ( this.mapPass ) {\n\n\t\t\tthis.mapPass.dispose();\n\n\t\t}\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.camera = source.camera.clone();\n\n\t\tthis.bias = source.bias;\n\t\tthis.radius = source.radius;\n\n\t\tthis.mapSize.copy( source.mapSize );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst object = {};\n\n\t\tif ( this.bias !== 0 ) object.bias = this.bias;\n\t\tif ( this.normalBias !== 0 ) object.normalBias = this.normalBias;\n\t\tif ( this.radius !== 1 ) object.radius = this.radius;\n\t\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\n\n\t\tobject.camera = this.camera.toJSON( false ).object;\n\t\tdelete object.camera.matrix;\n\n\t\treturn object;\n\n\t}\n\n}\n\nclass SpotLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new PerspectiveCamera( 50, 1, 0.5, 500 ) );\n\n\t\tthis.isSpotLightShadow = true;\n\n\t\tthis.focus = 1;\n\n\t}\n\n\tupdateMatrices( light ) {\n\n\t\tconst camera = this.camera;\n\n\t\tconst fov = RAD2DEG * 2 * light.angle * this.focus;\n\t\tconst aspect = this.mapSize.width / this.mapSize.height;\n\t\tconst far = light.distance || camera.far;\n\n\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\n\n\t\t\tcamera.fov = fov;\n\t\t\tcamera.aspect = aspect;\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\tsuper.updateMatrices( light );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.focus = source.focus;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass SpotLight extends Light {\n\n\tconstructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isSpotLight = true;\n\n\t\tthis.type = 'SpotLight';\n\n\t\tthis.position.copy( Object3D.DEFAULT_UP );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.distance = distance;\n\t\tthis.angle = angle;\n\t\tthis.penumbra = penumbra;\n\t\tthis.decay = decay;\n\n\t\tthis.map = null;\n\n\t\tthis.shadow = new SpotLightShadow();\n\n\t}\n\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in candela)\n\t\t// by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)\n\t\treturn this.intensity * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in candela) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / Math.PI;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.distance = source.distance;\n\t\tthis.angle = source.angle;\n\t\tthis.penumbra = source.penumbra;\n\t\tthis.decay = source.decay;\n\n\t\tthis.target = source.target.clone();\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _projScreenMatrix = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld = /*@__PURE__*/ new Vector3();\nconst _lookTarget = /*@__PURE__*/ new Vector3();\n\nclass PointLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n\t\tthis.isPointLightShadow = true;\n\n\t\tthis._frameExtents = new Vector2( 4, 2 );\n\n\t\tthis._viewportCount = 6;\n\n\t\tthis._viewports = [\n\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t// following orientation:\n\t\t\t//\n\t\t\t//  xzXZ\n\t\t\t//   y Y\n\t\t\t//\n\t\t\t// X - Positive x direction\n\t\t\t// x - Negative x direction\n\t\t\t// Y - Positive y direction\n\t\t\t// y - Negative y direction\n\t\t\t// Z - Positive z direction\n\t\t\t// z - Negative z direction\n\n\t\t\t// positive X\n\t\t\tnew Vector4( 2, 1, 1, 1 ),\n\t\t\t// negative X\n\t\t\tnew Vector4( 0, 1, 1, 1 ),\n\t\t\t// positive Z\n\t\t\tnew Vector4( 3, 1, 1, 1 ),\n\t\t\t// negative Z\n\t\t\tnew Vector4( 1, 1, 1, 1 ),\n\t\t\t// positive Y\n\t\t\tnew Vector4( 3, 0, 1, 1 ),\n\t\t\t// negative Y\n\t\t\tnew Vector4( 1, 0, 1, 1 )\n\t\t];\n\n\t\tthis._cubeDirections = [\n\t\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t\t];\n\n\t\tthis._cubeUps = [\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t\t];\n\n\t}\n\n\tupdateMatrices( light, viewportIndex = 0 ) {\n\n\t\tconst camera = this.camera;\n\t\tconst shadowMatrix = this.matrix;\n\n\t\tconst far = light.distance || camera.far;\n\n\t\tif ( far !== camera.far ) {\n\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\tcamera.position.copy( _lightPositionWorld );\n\n\t\t_lookTarget.copy( camera.position );\n\t\t_lookTarget.add( this._cubeDirections[ viewportIndex ] );\n\t\tcamera.up.copy( this._cubeUps[ viewportIndex ] );\n\t\tcamera.lookAt( _lookTarget );\n\t\tcamera.updateMatrixWorld();\n\n\t\tshadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\tthis._frustum.setFromProjectionMatrix( _projScreenMatrix );\n\n\t}\n\n}\n\nclass PointLight extends Light {\n\n\tconstructor( color, intensity, distance = 0, decay = 2 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isPointLight = true;\n\n\t\tthis.type = 'PointLight';\n\n\t\tthis.distance = distance;\n\t\tthis.decay = decay;\n\n\t\tthis.shadow = new PointLightShadow();\n\n\t}\n\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in candela)\n\t\t// for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)\n\t\treturn this.intensity * 4 * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in candela) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / ( 4 * Math.PI );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.distance = source.distance;\n\t\tthis.decay = source.decay;\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass DirectionalLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\n\n\t\tthis.isDirectionalLightShadow = true;\n\n\t}\n\n}\n\nclass DirectionalLight extends Light {\n\n\tconstructor( color, intensity ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isDirectionalLight = true;\n\n\t\tthis.type = 'DirectionalLight';\n\n\t\tthis.position.copy( Object3D.DEFAULT_UP );\n\t\tthis.updateMatrix();\n\n\t\tthis.target = new Object3D();\n\n\t\tthis.shadow = new DirectionalLightShadow();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.target = source.target.clone();\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass AmbientLight extends Light {\n\n\tconstructor( color, intensity ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isAmbientLight = true;\n\n\t\tthis.type = 'AmbientLight';\n\n\t}\n\n}\n\nclass RectAreaLight extends Light {\n\n\tconstructor( color, intensity, width = 10, height = 10 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.isRectAreaLight = true;\n\n\t\tthis.type = 'RectAreaLight';\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t}\n\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in nits)\n\t\treturn this.intensity * this.width * this.height * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in nits) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / ( this.width * this.height * Math.PI );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.width = source.width;\n\t\tthis.height = source.height;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.width = this.width;\n\t\tdata.object.height = this.height;\n\n\t\treturn data;\n\n\t}\n\n}\n\n/**\n * Primary reference:\n *   https://graphics.stanford.edu/papers/envmap/envmap.pdf\n *\n * Secondary reference:\n *   https://www.ppsloan.org/publications/StupidSH36.pdf\n */\n\n// 3-band SH defined by 9 coefficients\n\nclass SphericalHarmonics3 {\n\n\tconstructor() {\n\n\t\tthis.isSphericalHarmonics3 = true;\n\n\t\tthis.coefficients = [];\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients.push( new Vector3() );\n\n\t\t}\n\n\t}\n\n\tset( coefficients ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].copy( coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tzero() {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].set( 0, 0, 0 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// get the radiance in the direction of the normal\n\t// target is a Vector3\n\tgetAt( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\tconst coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );\n\n\t\t// band 1\n\t\ttarget.addScaledVector( coeff[ 1 ], 0.488603 * y );\n\t\ttarget.addScaledVector( coeff[ 2 ], 0.488603 * z );\n\t\ttarget.addScaledVector( coeff[ 3 ], 0.488603 * x );\n\n\t\t// band 2\n\t\ttarget.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );\n\t\ttarget.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );\n\t\ttarget.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );\n\t\ttarget.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );\n\t\ttarget.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );\n\n\t\treturn target;\n\n\t}\n\n\t// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal\n\t// target is a Vector3\n\t// https://graphics.stanford.edu/papers/envmap/envmap.pdf\n\tgetIrradianceAt( normal, target ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\tconst coeff = this.coefficients;\n\n\t\t// band 0\n\t\ttarget.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); //  * 0.282095\n\n\t\t// band 1\n\t\ttarget.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 *  / 3 ) * 0.488603\n\t\ttarget.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );\n\t\ttarget.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );\n\n\t\t// band 2\n\t\ttarget.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // (  / 4 ) * 1.092548\n\t\ttarget.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );\n\t\ttarget.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // (  / 4 ) * 0.315392 * 3\n\t\ttarget.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );\n\t\ttarget.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // (  / 4 ) * 0.546274\n\n\t\treturn target;\n\n\t}\n\n\tadd( sh ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].add( sh.coefficients[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\taddScaledSH( sh, s ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tscale( s ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].multiplyScalar( s );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tlerp( sh, alpha ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tthis.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tequals( sh ) {\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tif ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tcopy( sh ) {\n\n\t\treturn this.set( sh.coefficients );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tfromArray( array, offset = 0 ) {\n\n\t\tconst coefficients = this.coefficients;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].fromArray( array, offset + ( i * 3 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoArray( array = [], offset = 0 ) {\n\n\t\tconst coefficients = this.coefficients;\n\n\t\tfor ( let i = 0; i < 9; i ++ ) {\n\n\t\t\tcoefficients[ i ].toArray( array, offset + ( i * 3 ) );\n\n\t\t}\n\n\t\treturn array;\n\n\t}\n\n\t// evaluate the basis functions\n\t// shBasis is an Array[ 9 ]\n\tstatic getBasisAt( normal, shBasis ) {\n\n\t\t// normal is assumed to be unit length\n\n\t\tconst x = normal.x, y = normal.y, z = normal.z;\n\n\t\t// band 0\n\t\tshBasis[ 0 ] = 0.282095;\n\n\t\t// band 1\n\t\tshBasis[ 1 ] = 0.488603 * y;\n\t\tshBasis[ 2 ] = 0.488603 * z;\n\t\tshBasis[ 3 ] = 0.488603 * x;\n\n\t\t// band 2\n\t\tshBasis[ 4 ] = 1.092548 * x * y;\n\t\tshBasis[ 5 ] = 1.092548 * y * z;\n\t\tshBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );\n\t\tshBasis[ 7 ] = 1.092548 * x * z;\n\t\tshBasis[ 8 ] = 0.546274 * ( x * x - y * y );\n\n\t}\n\n}\n\nclass LightProbe extends Light {\n\n\tconstructor( sh = new SphericalHarmonics3(), intensity = 1 ) {\n\n\t\tsuper( undefined, intensity );\n\n\t\tthis.isLightProbe = true;\n\n\t\tthis.sh = sh;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.sh.copy( source.sh );\n\n\t\treturn this;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tthis.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();\n\t\tthis.sh.fromArray( json.sh );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.sh = this.sh.toArray();\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass MaterialLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\t\tthis.textures = {};\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst textures = this.textures;\n\n\t\tfunction getTexture( name ) {\n\n\t\t\tif ( textures[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\n\n\t\t\t}\n\n\t\t\treturn textures[ name ];\n\n\t\t}\n\n\t\tconst material = MaterialLoader.createMaterialFromType( json.type );\n\n\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\n\t\tif ( json.name !== undefined ) material.name = json.name;\n\t\tif ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\n\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\n\t\tif ( json.sheen !== undefined ) material.sheen = json.sheen;\n\t\tif ( json.sheenColor !== undefined ) material.sheenColor = new Color().setHex( json.sheenColor );\n\t\tif ( json.sheenRoughness !== undefined ) material.sheenRoughness = json.sheenRoughness;\n\t\tif ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );\n\t\tif ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );\n\t\tif ( json.specularIntensity !== undefined ) material.specularIntensity = json.specularIntensity;\n\t\tif ( json.specularColor !== undefined && material.specularColor !== undefined ) material.specularColor.setHex( json.specularColor );\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\n\t\tif ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;\n\t\tif ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;\n\t\tif ( json.iridescence !== undefined ) material.iridescence = json.iridescence;\n\t\tif ( json.iridescenceIOR !== undefined ) material.iridescenceIOR = json.iridescenceIOR;\n\t\tif ( json.iridescenceThicknessRange !== undefined ) material.iridescenceThicknessRange = json.iridescenceThicknessRange;\n\t\tif ( json.transmission !== undefined ) material.transmission = json.transmission;\n\t\tif ( json.thickness !== undefined ) material.thickness = json.thickness;\n\t\tif ( json.attenuationDistance !== undefined ) material.attenuationDistance = json.attenuationDistance;\n\t\tif ( json.attenuationColor !== undefined && material.attenuationColor !== undefined ) material.attenuationColor.setHex( json.attenuationColor );\n\t\tif ( json.anisotropy !== undefined ) material.anisotropy = json.anisotropy;\n\t\tif ( json.anisotropyRotation !== undefined ) material.anisotropyRotation = json.anisotropyRotation;\n\t\tif ( json.fog !== undefined ) material.fog = json.fog;\n\t\tif ( json.flatShading !== undefined ) material.flatShading = json.flatShading;\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\n\t\tif ( json.combine !== undefined ) material.combine = json.combine;\n\t\tif ( json.side !== undefined ) material.side = json.side;\n\t\tif ( json.shadowSide !== undefined ) material.shadowSide = json.shadowSide;\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\n\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\n\t\tif ( json.alphaHash !== undefined ) material.alphaHash = json.alphaHash;\n\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\n\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\n\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\n\n\t\tif ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;\n\t\tif ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;\n\t\tif ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;\n\t\tif ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;\n\t\tif ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;\n\t\tif ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;\n\t\tif ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;\n\t\tif ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;\n\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\n\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\n\t\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\n\t\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\n\n\t\tif ( json.rotation !== undefined ) material.rotation = json.rotation;\n\n\t\tif ( json.linewidth !== 1 ) material.linewidth = json.linewidth;\n\t\tif ( json.dashSize !== undefined ) material.dashSize = json.dashSize;\n\t\tif ( json.gapSize !== undefined ) material.gapSize = json.gapSize;\n\t\tif ( json.scale !== undefined ) material.scale = json.scale;\n\n\t\tif ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;\n\t\tif ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;\n\t\tif ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;\n\n\t\tif ( json.dithering !== undefined ) material.dithering = json.dithering;\n\n\t\tif ( json.alphaToCoverage !== undefined ) material.alphaToCoverage = json.alphaToCoverage;\n\t\tif ( json.premultipliedAlpha !== undefined ) material.premultipliedAlpha = json.premultipliedAlpha;\n\t\tif ( json.forceSinglePass !== undefined ) material.forceSinglePass = json.forceSinglePass;\n\n\t\tif ( json.visible !== undefined ) material.visible = json.visible;\n\n\t\tif ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;\n\n\t\tif ( json.userData !== undefined ) material.userData = json.userData;\n\n\t\tif ( json.vertexColors !== undefined ) {\n\n\t\t\tif ( typeof json.vertexColors === 'number' ) {\n\n\t\t\t\tmaterial.vertexColors = ( json.vertexColors > 0 ) ? true : false;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.vertexColors = json.vertexColors;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Shader Material\n\n\t\tif ( json.uniforms !== undefined ) {\n\n\t\t\tfor ( const name in json.uniforms ) {\n\n\t\t\t\tconst uniform = json.uniforms[ name ];\n\n\t\t\t\tmaterial.uniforms[ name ] = {};\n\n\t\t\t\tswitch ( uniform.type ) {\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = getTexture( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Color().setHex( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v2':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector2().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector3().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Vector4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm3':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm4':\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmaterial.uniforms[ name ].value = uniform.value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.defines !== undefined ) material.defines = json.defines;\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\n\t\tif ( json.glslVersion !== undefined ) material.glslVersion = json.glslVersion;\n\n\t\tif ( json.extensions !== undefined ) {\n\n\t\t\tfor ( const key in json.extensions ) {\n\n\t\t\t\tmaterial.extensions[ key ] = json.extensions[ key ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json.lights !== undefined ) material.lights = json.lights;\n\t\tif ( json.clipping !== undefined ) material.clipping = json.clipping;\n\n\t\t// for PointsMaterial\n\n\t\tif ( json.size !== undefined ) material.size = json.size;\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\n\n\t\t// maps\n\n\t\tif ( json.map !== undefined ) material.map = getTexture( json.map );\n\t\tif ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );\n\n\t\tif ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );\n\n\t\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\n\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\n\n\t\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\n\t\tif ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;\n\t\tif ( json.normalScale !== undefined ) {\n\n\t\t\tlet normalScale = json.normalScale;\n\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\n\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\n\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\n\n\t\t\t}\n\n\t\t\tmaterial.normalScale = new Vector2().fromArray( normalScale );\n\n\t\t}\n\n\t\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\n\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\n\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\n\n\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\n\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\n\n\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\n\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\n\n\t\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\n\t\tif ( json.specularIntensityMap !== undefined ) material.specularIntensityMap = getTexture( json.specularIntensityMap );\n\t\tif ( json.specularColorMap !== undefined ) material.specularColorMap = getTexture( json.specularColorMap );\n\n\t\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\n\t\tif ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;\n\n\t\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\n\t\tif ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;\n\n\t\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\n\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\n\n\t\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\n\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\n\n\t\tif ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );\n\n\t\tif ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );\n\t\tif ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );\n\t\tif ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );\n\t\tif ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );\n\n\t\tif ( json.iridescenceMap !== undefined ) material.iridescenceMap = getTexture( json.iridescenceMap );\n\t\tif ( json.iridescenceThicknessMap !== undefined ) material.iridescenceThicknessMap = getTexture( json.iridescenceThicknessMap );\n\n\t\tif ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );\n\t\tif ( json.thicknessMap !== undefined ) material.thicknessMap = getTexture( json.thicknessMap );\n\n\t\tif ( json.anisotropyMap !== undefined ) material.anisotropyMap = getTexture( json.anisotropyMap );\n\n\t\tif ( json.sheenColorMap !== undefined ) material.sheenColorMap = getTexture( json.sheenColorMap );\n\t\tif ( json.sheenRoughnessMap !== undefined ) material.sheenRoughnessMap = getTexture( json.sheenRoughnessMap );\n\n\t\treturn material;\n\n\t}\n\n\tsetTextures( value ) {\n\n\t\tthis.textures = value;\n\t\treturn this;\n\n\t}\n\n\tstatic createMaterialFromType( type ) {\n\n\t\tconst materialLib = {\n\t\t\tShadowMaterial,\n\t\t\tSpriteMaterial,\n\t\t\tRawShaderMaterial,\n\t\t\tShaderMaterial,\n\t\t\tPointsMaterial,\n\t\t\tMeshPhysicalMaterial,\n\t\t\tMeshStandardMaterial,\n\t\t\tMeshPhongMaterial,\n\t\t\tMeshToonMaterial,\n\t\t\tMeshNormalMaterial,\n\t\t\tMeshLambertMaterial,\n\t\t\tMeshDepthMaterial,\n\t\t\tMeshDistanceMaterial,\n\t\t\tMeshBasicMaterial,\n\t\t\tMeshMatcapMaterial,\n\t\t\tLineDashedMaterial,\n\t\t\tLineBasicMaterial,\n\t\t\tMaterial\n\t\t};\n\n\t\treturn new materialLib[ type ]();\n\n\t}\n\n}\n\nclass LoaderUtils {\n\n\tstatic decodeText( array ) {\n\n\t\tif ( typeof TextDecoder !== 'undefined' ) {\n\n\t\t\treturn new TextDecoder().decode( array );\n\n\t\t}\n\n\t\t// Avoid the String.fromCharCode.apply(null, array) shortcut, which\n\t\t// throws a \"maximum call stack size exceeded\" error for large arrays.\n\n\t\tlet s = '';\n\n\t\tfor ( let i = 0, il = array.length; i < il; i ++ ) {\n\n\t\t\t// Implicitly assumes little-endian.\n\t\t\ts += String.fromCharCode( array[ i ] );\n\n\t\t}\n\n\t\ttry {\n\n\t\t\t// merges multi-byte utf-8 characters.\n\n\t\t\treturn decodeURIComponent( escape( s ) );\n\n\t\t} catch ( e ) { // see #16358\n\n\t\t\treturn s;\n\n\t\t}\n\n\t}\n\n\tstatic extractUrlBase( url ) {\n\n\t\tconst index = url.lastIndexOf( '/' );\n\n\t\tif ( index === - 1 ) return './';\n\n\t\treturn url.slice( 0, index + 1 );\n\n\t}\n\n\tstatic resolveURL( url, path ) {\n\n\t\t// Invalid URL\n\t\tif ( typeof url !== 'string' || url === '' ) return '';\n\n\t\t// Host Relative URL\n\t\tif ( /^https?:\\/\\//i.test( path ) && /^\\//.test( url ) ) {\n\n\t\t\tpath = path.replace( /(^https?:\\/\\/[^\\/]+).*/i, '$1' );\n\n\t\t}\n\n\t\t// Absolute URL http://,https://,//\n\t\tif ( /^(https?:)?\\/\\//i.test( url ) ) return url;\n\n\t\t// Data URI\n\t\tif ( /^data:.*,.*$/i.test( url ) ) return url;\n\n\t\t// Blob URL\n\t\tif ( /^blob:.*$/i.test( url ) ) return url;\n\n\t\t// Relative URL\n\t\treturn path + url;\n\n\t}\n\n}\n\nclass InstancedBufferGeometry extends BufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isInstancedBufferGeometry = true;\n\n\t\tthis.type = 'InstancedBufferGeometry';\n\t\tthis.instanceCount = Infinity;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.instanceCount = source.instanceCount;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.instanceCount = this.instanceCount;\n\n\t\tdata.isInstancedBufferGeometry = true;\n\n\t\treturn data;\n\n\t}\n\n}\n\nclass BufferGeometryLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( json ) {\n\n\t\tconst interleavedBufferMap = {};\n\t\tconst arrayBufferMap = {};\n\n\t\tfunction getInterleavedBuffer( json, uuid ) {\n\n\t\t\tif ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];\n\n\t\t\tconst interleavedBuffers = json.interleavedBuffers;\n\t\t\tconst interleavedBuffer = interleavedBuffers[ uuid ];\n\n\t\t\tconst buffer = getArrayBuffer( json, interleavedBuffer.buffer );\n\n\t\t\tconst array = getTypedArray( interleavedBuffer.type, buffer );\n\t\t\tconst ib = new InterleavedBuffer( array, interleavedBuffer.stride );\n\t\t\tib.uuid = interleavedBuffer.uuid;\n\n\t\t\tinterleavedBufferMap[ uuid ] = ib;\n\n\t\t\treturn ib;\n\n\t\t}\n\n\t\tfunction getArrayBuffer( json, uuid ) {\n\n\t\t\tif ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];\n\n\t\t\tconst arrayBuffers = json.arrayBuffers;\n\t\t\tconst arrayBuffer = arrayBuffers[ uuid ];\n\n\t\t\tconst ab = new Uint32Array( arrayBuffer ).buffer;\n\n\t\t\tarrayBufferMap[ uuid ] = ab;\n\n\t\t\treturn ab;\n\n\t\t}\n\n\t\tconst geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\n\n\t\tconst index = json.data.index;\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst typedArray = getTypedArray( index.type, index.array );\n\t\t\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\n\n\t\t}\n\n\t\tconst attributes = json.data.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\t\t\tlet bufferAttribute;\n\n\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t} else {\n\n\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\tconst bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\n\t\t\t\tbufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t}\n\n\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\tif ( attribute.usage !== undefined ) bufferAttribute.setUsage( attribute.usage );\n\n\t\t\tif ( attribute.updateRange !== undefined ) {\n\n\t\t\t\tbufferAttribute.updateRange.offset = attribute.updateRange.offset;\n\t\t\t\tbufferAttribute.updateRange.count = attribute.updateRange.count;\n\n\t\t\t}\n\n\t\t\tgeometry.setAttribute( key, bufferAttribute );\n\n\t\t}\n\n\t\tconst morphAttributes = json.data.morphAttributes;\n\n\t\tif ( morphAttributes ) {\n\n\t\t\tfor ( const key in morphAttributes ) {\n\n\t\t\t\tconst attributeArray = morphAttributes[ key ];\n\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst attribute = attributeArray[ i ];\n\t\t\t\t\tlet bufferAttribute;\n\n\t\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\t\tconst interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );\n\t\t\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst typedArray = getTypedArray( attribute.type, attribute.array );\n\t\t\t\t\t\tbufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;\n\t\t\t\t\tarray.push( bufferAttribute );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.morphAttributes[ key ] = array;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst morphTargetsRelative = json.data.morphTargetsRelative;\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\tgeometry.morphTargetsRelative = true;\n\n\t\t}\n\n\t\tconst groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n\n\t\tif ( groups !== undefined ) {\n\n\t\t\tfor ( let i = 0, n = groups.length; i !== n; ++ i ) {\n\n\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst boundingSphere = json.data.boundingSphere;\n\n\t\tif ( boundingSphere !== undefined ) {\n\n\t\t\tconst center = new Vector3();\n\n\t\t\tif ( boundingSphere.center !== undefined ) {\n\n\t\t\t\tcenter.fromArray( boundingSphere.center );\n\n\t\t\t}\n\n\t\t\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\n\n\t\t}\n\n\t\tif ( json.name ) geometry.name = json.name;\n\t\tif ( json.userData ) geometry.userData = json.userData;\n\n\t\treturn geometry;\n\n\t}\n\n}\n\nclass ObjectLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\t\tthis.resourcePath = this.resourcePath || path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tlet json = null;\n\n\t\t\ttry {\n\n\t\t\t\tjson = JSON.parse( text );\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tif ( onError !== undefined ) onError( error );\n\n\t\t\t\tconsole.error( 'THREE:ObjectLoader: Can\\'t parse ' + url + '.', error.message );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tconst metadata = json.metadata;\n\n\t\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\t\tif ( onError !== undefined ) onError( new Error( 'THREE.ObjectLoader: Can\\'t load ' + url ) );\n\n\t\t\t\tconsole.error( 'THREE.ObjectLoader: Can\\'t load ' + url );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tscope.parse( json, onLoad );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tasync loadAsync( url, onProgress ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;\n\t\tthis.resourcePath = this.resourcePath || path;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tconst text = await loader.loadAsync( url, onProgress );\n\n\t\tconst json = JSON.parse( text );\n\n\t\tconst metadata = json.metadata;\n\n\t\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\n\n\t\t\tthrow new Error( 'THREE.ObjectLoader: Can\\'t load ' + url );\n\n\t\t}\n\n\t\treturn await scope.parseAsync( json );\n\n\t}\n\n\tparse( json, onLoad ) {\n\n\t\tconst animations = this.parseAnimations( json.animations );\n\t\tconst shapes = this.parseShapes( json.shapes );\n\t\tconst geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\tconst images = this.parseImages( json.images, function () {\n\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\n\n\t\t} );\n\n\t\tconst textures = this.parseTextures( json.textures, images );\n\t\tconst materials = this.parseMaterials( json.materials, textures );\n\n\t\tconst object = this.parseObject( json.object, geometries, materials, textures, animations );\n\t\tconst skeletons = this.parseSkeletons( json.skeletons, object );\n\n\t\tthis.bindSkeletons( object, skeletons );\n\n\t\t//\n\n\t\tif ( onLoad !== undefined ) {\n\n\t\t\tlet hasImages = false;\n\n\t\t\tfor ( const uuid in images ) {\n\n\t\t\t\tif ( images[ uuid ].data instanceof HTMLImageElement ) {\n\n\t\t\t\t\thasImages = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasImages === false ) onLoad( object );\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n\tasync parseAsync( json ) {\n\n\t\tconst animations = this.parseAnimations( json.animations );\n\t\tconst shapes = this.parseShapes( json.shapes );\n\t\tconst geometries = this.parseGeometries( json.geometries, shapes );\n\n\t\tconst images = await this.parseImagesAsync( json.images );\n\n\t\tconst textures = this.parseTextures( json.textures, images );\n\t\tconst materials = this.parseMaterials( json.materials, textures );\n\n\t\tconst object = this.parseObject( json.object, geometries, materials, textures, animations );\n\t\tconst skeletons = this.parseSkeletons( json.skeletons, object );\n\n\t\tthis.bindSkeletons( object, skeletons );\n\n\t\treturn object;\n\n\t}\n\n\tparseShapes( json ) {\n\n\t\tconst shapes = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst shape = new Shape().fromJSON( json[ i ] );\n\n\t\t\t\tshapes[ shape.uuid ] = shape;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n\tparseSkeletons( json, object ) {\n\n\t\tconst skeletons = {};\n\t\tconst bones = {};\n\n\t\t// generate bone lookup table\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isBone ) bones[ child.uuid ] = child;\n\n\t\t} );\n\n\t\t// create skeletons\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst skeleton = new Skeleton().fromJSON( json[ i ], bones );\n\n\t\t\t\tskeletons[ skeleton.uuid ] = skeleton;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn skeletons;\n\n\t}\n\n\tparseGeometries( json, shapes ) {\n\n\t\tconst geometries = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst bufferGeometryLoader = new BufferGeometryLoader();\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tlet geometry;\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'BufferGeometry':\n\t\t\t\t\tcase 'InstancedBufferGeometry':\n\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( data.type in Geometries ) {\n\n\t\t\t\t\t\t\tgeometry = Geometries[ data.type ].fromJSON( data, shapes );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( `THREE.ObjectLoader: Unsupported geometry type \"${ data.type }\"` );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\t\t\t\tif ( data.userData !== undefined ) geometry.userData = data.userData;\n\n\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometries;\n\n\t}\n\n\tparseMaterials( json, textures ) {\n\n\t\tconst cache = {}; // MultiMaterial\n\t\tconst materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tconst loader = new MaterialLoader();\n\t\t\tloader.setTextures( textures );\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tif ( cache[ data.uuid ] === undefined ) {\n\n\t\t\t\t\tcache[ data.uuid ] = loader.parse( data );\n\n\t\t\t\t}\n\n\t\t\t\tmaterials[ data.uuid ] = cache[ data.uuid ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t}\n\n\tparseAnimations( json ) {\n\n\t\tconst animations = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0; i < json.length; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tconst clip = AnimationClip.parse( data );\n\n\t\t\t\tanimations[ clip.uuid ] = clip;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn animations;\n\n\t}\n\n\tparseImages( json, onLoad ) {\n\n\t\tconst scope = this;\n\t\tconst images = {};\n\n\t\tlet loader;\n\n\t\tfunction loadImage( url ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\treturn loader.load( url, function () {\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, undefined, function () {\n\n\t\t\t\tscope.manager.itemError( url );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction deserializeImage( image ) {\n\n\t\t\tif ( typeof image === 'string' ) {\n\n\t\t\t\tconst url = image;\n\n\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( url ) ? url : scope.resourcePath + url;\n\n\t\t\t\treturn loadImage( path );\n\n\t\t\t} else {\n\n\t\t\t\tif ( image.data ) {\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: getTypedArray( image.type, image.data ),\n\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\theight: image.height\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tconst manager = new LoadingManager( onLoad );\n\n\t\t\tloader = new ImageLoader( manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( let i = 0, il = json.length; i < il; i ++ ) {\n\n\t\t\t\tconst image = json[ i ];\n\t\t\t\tconst url = image.url;\n\n\t\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\t\t// load array of images e.g CubeTexture\n\n\t\t\t\t\tconst imageArray = [];\n\n\t\t\t\t\tfor ( let j = 0, jl = url.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tconst currentUrl = url[ j ];\n\n\t\t\t\t\t\tconst deserializedImage = deserializeImage( currentUrl );\n\n\t\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\t\tif ( deserializedImage instanceof HTMLImageElement ) {\n\n\t\t\t\t\t\t\t\timageArray.push( deserializedImage );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\n\t\t\t\t\t\t\t\timageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\timages[ image.uuid ] = new Source( imageArray );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// load single image\n\n\t\t\t\t\tconst deserializedImage = deserializeImage( image.url );\n\t\t\t\t\timages[ image.uuid ] = new Source( deserializedImage );\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\tasync parseImagesAsync( json ) {\n\n\t\tconst scope = this;\n\t\tconst images = {};\n\n\t\tlet loader;\n\n\t\tasync function deserializeImage( image ) {\n\n\t\t\tif ( typeof image === 'string' ) {\n\n\t\t\t\tconst url = image;\n\n\t\t\t\tconst path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( url ) ? url : scope.resourcePath + url;\n\n\t\t\t\treturn await loader.loadAsync( path );\n\n\t\t\t} else {\n\n\t\t\t\tif ( image.data ) {\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdata: getTypedArray( image.type, image.data ),\n\t\t\t\t\t\twidth: image.width,\n\t\t\t\t\t\theight: image.height\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( json !== undefined && json.length > 0 ) {\n\n\t\t\tloader = new ImageLoader( this.manager );\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\n\n\t\t\tfor ( let i = 0, il = json.length; i < il; i ++ ) {\n\n\t\t\t\tconst image = json[ i ];\n\t\t\t\tconst url = image.url;\n\n\t\t\t\tif ( Array.isArray( url ) ) {\n\n\t\t\t\t\t// load array of images e.g CubeTexture\n\n\t\t\t\t\tconst imageArray = [];\n\n\t\t\t\t\tfor ( let j = 0, jl = url.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tconst currentUrl = url[ j ];\n\n\t\t\t\t\t\tconst deserializedImage = await deserializeImage( currentUrl );\n\n\t\t\t\t\t\tif ( deserializedImage !== null ) {\n\n\t\t\t\t\t\t\tif ( deserializedImage instanceof HTMLImageElement ) {\n\n\t\t\t\t\t\t\t\timageArray.push( deserializedImage );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// special case: handle array of data textures for cube textures\n\n\t\t\t\t\t\t\t\timageArray.push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\timages[ image.uuid ] = new Source( imageArray );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// load single image\n\n\t\t\t\t\tconst deserializedImage = await deserializeImage( image.url );\n\t\t\t\t\timages[ image.uuid ] = new Source( deserializedImage );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn images;\n\n\t}\n\n\tparseTextures( json, images ) {\n\n\t\tfunction parseConstant( value, type ) {\n\n\t\t\tif ( typeof value === 'number' ) return value;\n\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\n\n\t\t\treturn type[ value ];\n\n\t\t}\n\n\t\tconst textures = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tfor ( let i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tconst data = json[ i ];\n\n\t\t\t\tif ( data.image === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\n\n\t\t\t\t}\n\n\t\t\t\tif ( images[ data.image ] === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\n\n\t\t\t\t}\n\n\t\t\t\tconst source = images[ data.image ];\n\t\t\t\tconst image = source.data;\n\n\t\t\t\tlet texture;\n\n\t\t\t\tif ( Array.isArray( image ) ) {\n\n\t\t\t\t\ttexture = new CubeTexture();\n\n\t\t\t\t\tif ( image.length === 6 ) texture.needsUpdate = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( image && image.data ) {\n\n\t\t\t\t\t\ttexture = new DataTexture();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture = new Texture();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( image ) texture.needsUpdate = true; // textures can have undefined image data\n\n\t\t\t\t}\n\n\t\t\t\ttexture.source = source;\n\n\t\t\t\ttexture.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\n\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );\n\t\t\t\tif ( data.channel !== undefined ) texture.channel = data.channel;\n\n\t\t\t\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\n\t\t\t\tif ( data.center !== undefined ) texture.center.fromArray( data.center );\n\t\t\t\tif ( data.rotation !== undefined ) texture.rotation = data.rotation;\n\n\t\t\t\tif ( data.wrap !== undefined ) {\n\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.format !== undefined ) texture.format = data.format;\n\t\t\t\tif ( data.internalFormat !== undefined ) texture.internalFormat = data.internalFormat;\n\t\t\t\tif ( data.type !== undefined ) texture.type = data.type;\n\t\t\t\tif ( data.colorSpace !== undefined ) texture.colorSpace = data.colorSpace;\n\t\t\t\tif ( data.encoding !== undefined ) texture.encoding = data.encoding; // @deprecated, r152\n\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\n\n\t\t\t\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\n\n\t\t\t\tif ( data.generateMipmaps !== undefined ) texture.generateMipmaps = data.generateMipmaps;\n\t\t\t\tif ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;\n\t\t\t\tif ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;\n\t\t\t\tif ( data.compareFunction !== undefined ) texture.compareFunction = data.compareFunction;\n\n\t\t\t\tif ( data.userData !== undefined ) texture.userData = data.userData;\n\n\t\t\t\ttextures[ data.uuid ] = texture;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn textures;\n\n\t}\n\n\tparseObject( data, geometries, materials, textures, animations ) {\n\n\t\tlet object;\n\n\t\tfunction getGeometry( name ) {\n\n\t\t\tif ( geometries[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\n\n\t\t\t}\n\n\t\t\treturn geometries[ name ];\n\n\t\t}\n\n\t\tfunction getMaterial( name ) {\n\n\t\t\tif ( name === undefined ) return undefined;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\n\t\t\t\tconst array = [];\n\n\t\t\t\tfor ( let i = 0, l = name.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst uuid = name[ i ];\n\n\t\t\t\t\tif ( materials[ uuid ] === undefined ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', uuid );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tarray.push( materials[ uuid ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tif ( materials[ name ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\n\n\t\t\t}\n\n\t\t\treturn materials[ name ];\n\n\t\t}\n\n\t\tfunction getTexture( uuid ) {\n\n\t\t\tif ( textures[ uuid ] === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined texture', uuid );\n\n\t\t\t}\n\n\t\t\treturn textures[ uuid ];\n\n\t\t}\n\n\t\tlet geometry, material;\n\n\t\tswitch ( data.type ) {\n\n\t\t\tcase 'Scene':\n\n\t\t\t\tobject = new Scene();\n\n\t\t\t\tif ( data.background !== undefined ) {\n\n\t\t\t\t\tif ( Number.isInteger( data.background ) ) {\n\n\t\t\t\t\t\tobject.background = new Color( data.background );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tobject.background = getTexture( data.background );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.environment !== undefined ) {\n\n\t\t\t\t\tobject.environment = getTexture( data.environment );\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.fog !== undefined ) {\n\n\t\t\t\t\tif ( data.fog.type === 'Fog' ) {\n\n\t\t\t\t\t\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\n\n\t\t\t\t\t} else if ( data.fog.type === 'FogExp2' ) {\n\n\t\t\t\t\t\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( data.backgroundBlurriness !== undefined ) object.backgroundBlurriness = data.backgroundBlurriness;\n\t\t\t\tif ( data.backgroundIntensity !== undefined ) object.backgroundIntensity = data.backgroundIntensity;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\n\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\n\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'AmbientLight':\n\n\t\t\t\tobject = new AmbientLight( data.color, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'DirectionalLight':\n\n\t\t\t\tobject = new DirectionalLight( data.color, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointLight':\n\n\t\t\t\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'RectAreaLight':\n\n\t\t\t\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SpotLight':\n\n\t\t\t\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'HemisphereLight':\n\n\t\t\t\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LightProbe':\n\n\t\t\t\tobject = new LightProbe().fromJSON( data );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'SkinnedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t \tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new SkinnedMesh( geometry, material );\n\n\t\t\t\tif ( data.bindMode !== undefined ) object.bindMode = data.bindMode;\n\t\t\t\tif ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );\n\t\t\t\tif ( data.skeleton !== undefined ) object.skeleton = data.skeleton;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Mesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\n\t\t\t\tobject = new Mesh( geometry, material );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'InstancedMesh':\n\n\t\t\t\tgeometry = getGeometry( data.geometry );\n\t\t\t\tmaterial = getMaterial( data.material );\n\t\t\t\tconst count = data.count;\n\t\t\t\tconst instanceMatrix = data.instanceMatrix;\n\t\t\t\tconst instanceColor = data.instanceColor;\n\n\t\t\t\tobject = new InstancedMesh( geometry, material, count );\n\t\t\t\tobject.instanceMatrix = new InstancedBufferAttribute( new Float32Array( instanceMatrix.array ), 16 );\n\t\t\t\tif ( instanceColor !== undefined ) object.instanceColor = new InstancedBufferAttribute( new Float32Array( instanceColor.array ), instanceColor.itemSize );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LOD':\n\n\t\t\t\tobject = new LOD();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Line':\n\n\t\t\t\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineLoop':\n\n\t\t\t\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'LineSegments':\n\n\t\t\t\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'PointCloud':\n\t\t\tcase 'Points':\n\n\t\t\t\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Sprite':\n\n\t\t\t\tobject = new Sprite( getMaterial( data.material ) );\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Group':\n\n\t\t\t\tobject = new Group();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'Bone':\n\n\t\t\t\tobject = new Bone();\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tobject = new Object3D();\n\n\t\t}\n\n\t\tobject.uuid = data.uuid;\n\n\t\tif ( data.name !== undefined ) object.name = data.name;\n\n\t\tif ( data.matrix !== undefined ) {\n\n\t\t\tobject.matrix.fromArray( data.matrix );\n\n\t\t\tif ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;\n\t\t\tif ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t} else {\n\n\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\n\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t}\n\n\t\tif ( data.up !== undefined ) object.up.fromArray( data.up );\n\n\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\n\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\n\n\t\tif ( data.shadow ) {\n\n\t\t\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\n\t\t\tif ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;\n\t\t\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\n\t\t\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\n\t\t\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\n\n\t\t}\n\n\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\tif ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;\n\t\tif ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;\n\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\t\tif ( data.layers !== undefined ) object.layers.mask = data.layers;\n\n\t\tif ( data.children !== undefined ) {\n\n\t\t\tconst children = data.children;\n\n\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tobject.add( this.parseObject( children[ i ], geometries, materials, textures, animations ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.animations !== undefined ) {\n\n\t\t\tconst objectAnimations = data.animations;\n\n\t\t\tfor ( let i = 0; i < objectAnimations.length; i ++ ) {\n\n\t\t\t\tconst uuid = objectAnimations[ i ];\n\n\t\t\t\tobject.animations.push( animations[ uuid ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( data.type === 'LOD' ) {\n\n\t\t\tif ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;\n\n\t\t\tconst levels = data.levels;\n\n\t\t\tfor ( let l = 0; l < levels.length; l ++ ) {\n\n\t\t\t\tconst level = levels[ l ];\n\t\t\t\tconst child = object.getObjectByProperty( 'uuid', level.object );\n\n\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\tobject.addLevel( child, level.distance, level.hysteresis );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n\tbindSkeletons( object, skeletons ) {\n\n\t\tif ( Object.keys( skeletons ).length === 0 ) return;\n\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {\n\n\t\t\t\tconst skeleton = skeletons[ child.skeleton ];\n\n\t\t\t\tif ( skeleton === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tchild.bind( skeleton, child.bindMatrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n}\n\nconst TEXTURE_MAPPING = {\n\tUVMapping: UVMapping,\n\tCubeReflectionMapping: CubeReflectionMapping,\n\tCubeRefractionMapping: CubeRefractionMapping,\n\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\n\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\n\tCubeUVReflectionMapping: CubeUVReflectionMapping\n};\n\nconst TEXTURE_WRAPPING = {\n\tRepeatWrapping: RepeatWrapping,\n\tClampToEdgeWrapping: ClampToEdgeWrapping,\n\tMirroredRepeatWrapping: MirroredRepeatWrapping\n};\n\nconst TEXTURE_FILTER = {\n\tNearestFilter: NearestFilter,\n\tNearestMipmapNearestFilter: NearestMipmapNearestFilter,\n\tNearestMipmapLinearFilter: NearestMipmapLinearFilter,\n\tLinearFilter: LinearFilter,\n\tLinearMipmapNearestFilter: LinearMipmapNearestFilter,\n\tLinearMipmapLinearFilter: LinearMipmapLinearFilter\n};\n\nclass ImageBitmapLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.isImageBitmapLoader = true;\n\n\t\tif ( typeof createImageBitmap === 'undefined' ) {\n\n\t\t\tconsole.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );\n\n\t\t}\n\n\t\tif ( typeof fetch === 'undefined' ) {\n\n\t\t\tconsole.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );\n\n\t\t}\n\n\t\tthis.options = { premultiplyAlpha: 'none' };\n\n\t}\n\n\tsetOptions( options ) {\n\n\t\tthis.options = options;\n\n\t\treturn this;\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tif ( url === undefined ) url = '';\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tconst scope = this;\n\n\t\tconst cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tconst fetchOptions = {};\n\t\tfetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';\n\t\tfetchOptions.headers = this.requestHeader;\n\n\t\tfetch( url, fetchOptions ).then( function ( res ) {\n\n\t\t\treturn res.blob();\n\n\t\t} ).then( function ( blob ) {\n\n\t\t\treturn createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );\n\n\t\t} ).then( function ( imageBitmap ) {\n\n\t\t\tCache.add( url, imageBitmap );\n\n\t\t\tif ( onLoad ) onLoad( imageBitmap );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t} ).catch( function ( e ) {\n\n\t\t\tif ( onError ) onError( e );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t} );\n\n\t\tscope.manager.itemStart( url );\n\n\t}\n\n}\n\nlet _context;\n\nclass AudioContext {\n\n\tstatic getContext() {\n\n\t\tif ( _context === undefined ) {\n\n\t\t\t_context = new ( window.AudioContext || window.webkitAudioContext )();\n\n\t\t}\n\n\t\treturn _context;\n\n\t}\n\n\tstatic setContext( value ) {\n\n\t\t_context = value;\n\n\t}\n\n}\n\nclass AudioLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( buffer ) {\n\n\t\t\ttry {\n\n\t\t\t\t// Create a copy of the buffer. The `decodeAudioData` method\n\t\t\t\t// detaches the buffer when complete, preventing reuse.\n\t\t\t\tconst bufferCopy = buffer.slice( 0 );\n\n\t\t\t\tconst context = AudioContext.getContext();\n\t\t\t\tcontext.decodeAudioData( bufferCopy, function ( audioBuffer ) {\n\n\t\t\t\t\tonLoad( audioBuffer );\n\n\t\t\t\t}, handleError );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\thandleError( e );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\tfunction handleError( e ) {\n\n\t\t\tif ( onError ) {\n\n\t\t\t\tonError( e );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemError( url );\n\n\t\t}\n\n\t}\n\n}\n\nclass HemisphereLightProbe extends LightProbe {\n\n\tconstructor( skyColor, groundColor, intensity = 1 ) {\n\n\t\tsuper( undefined, intensity );\n\n\t\tthis.isHemisphereLightProbe = true;\n\n\t\tconst color1 = new Color().set( skyColor );\n\t\tconst color2 = new Color().set( groundColor );\n\n\t\tconst sky = new Vector3( color1.r, color1.g, color1.b );\n\t\tconst ground = new Vector3( color2.r, color2.g, color2.b );\n\n\t\t// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );\n\t\tconst c0 = Math.sqrt( Math.PI );\n\t\tconst c1 = c0 * Math.sqrt( 0.75 );\n\n\t\tthis.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );\n\t\tthis.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );\n\n\t}\n\n}\n\nclass AmbientLightProbe extends LightProbe {\n\n\tconstructor( color, intensity = 1 ) {\n\n\t\tsuper( undefined, intensity );\n\n\t\tthis.isAmbientLightProbe = true;\n\n\t\tconst color1 = new Color().set( color );\n\n\t\t// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );\n\t\tthis.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );\n\n\t}\n\n}\n\nconst _eyeRight = /*@__PURE__*/ new Matrix4();\nconst _eyeLeft = /*@__PURE__*/ new Matrix4();\nconst _projectionMatrix = /*@__PURE__*/ new Matrix4();\n\nclass StereoCamera {\n\n\tconstructor() {\n\n\t\tthis.type = 'StereoCamera';\n\n\t\tthis.aspect = 1;\n\n\t\tthis.eyeSep = 0.064;\n\n\t\tthis.cameraL = new PerspectiveCamera();\n\t\tthis.cameraL.layers.enable( 1 );\n\t\tthis.cameraL.matrixAutoUpdate = false;\n\n\t\tthis.cameraR = new PerspectiveCamera();\n\t\tthis.cameraR.layers.enable( 2 );\n\t\tthis.cameraR.matrixAutoUpdate = false;\n\n\t\tthis._cache = {\n\t\t\tfocus: null,\n\t\t\tfov: null,\n\t\t\taspect: null,\n\t\t\tnear: null,\n\t\t\tfar: null,\n\t\t\tzoom: null,\n\t\t\teyeSep: null\n\t\t};\n\n\t}\n\n\tupdate( camera ) {\n\n\t\tconst cache = this._cache;\n\n\t\tconst needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||\n\t\t\tcache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||\n\t\t\tcache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;\n\n\t\tif ( needsUpdate ) {\n\n\t\t\tcache.focus = camera.focus;\n\t\t\tcache.fov = camera.fov;\n\t\t\tcache.aspect = camera.aspect * this.aspect;\n\t\t\tcache.near = camera.near;\n\t\t\tcache.far = camera.far;\n\t\t\tcache.zoom = camera.zoom;\n\t\t\tcache.eyeSep = this.eyeSep;\n\n\t\t\t// Off-axis stereoscopic effect based on\n\t\t\t// http://paulbourke.net/stereographics/stereorender/\n\n\t\t\t_projectionMatrix.copy( camera.projectionMatrix );\n\t\t\tconst eyeSepHalf = cache.eyeSep / 2;\n\t\t\tconst eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;\n\t\t\tconst ymax = ( cache.near * Math.tan( DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;\n\t\t\tlet xmin, xmax;\n\n\t\t\t// translate xOffset\n\n\t\t\t_eyeLeft.elements[ 12 ] = - eyeSepHalf;\n\t\t\t_eyeRight.elements[ 12 ] = eyeSepHalf;\n\n\t\t\t// for left eye\n\n\t\t\txmin = - ymax * cache.aspect + eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect + eyeSepOnProjection;\n\n\t\t\t_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\t_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\tthis.cameraL.projectionMatrix.copy( _projectionMatrix );\n\n\t\t\t// for right eye\n\n\t\t\txmin = - ymax * cache.aspect - eyeSepOnProjection;\n\t\t\txmax = ymax * cache.aspect - eyeSepOnProjection;\n\n\t\t\t_projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );\n\t\t\t_projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\tthis.cameraR.projectionMatrix.copy( _projectionMatrix );\n\n\t\t}\n\n\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );\n\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );\n\n\t}\n\n}\n\nclass Clock {\n\n\tconstructor( autoStart = true ) {\n\n\t\tthis.autoStart = autoStart;\n\n\t\tthis.startTime = 0;\n\t\tthis.oldTime = 0;\n\t\tthis.elapsedTime = 0;\n\n\t\tthis.running = false;\n\n\t}\n\n\tstart() {\n\n\t\tthis.startTime = now();\n\n\t\tthis.oldTime = this.startTime;\n\t\tthis.elapsedTime = 0;\n\t\tthis.running = true;\n\n\t}\n\n\tstop() {\n\n\t\tthis.getElapsedTime();\n\t\tthis.running = false;\n\t\tthis.autoStart = false;\n\n\t}\n\n\tgetElapsedTime() {\n\n\t\tthis.getDelta();\n\t\treturn this.elapsedTime;\n\n\t}\n\n\tgetDelta() {\n\n\t\tlet diff = 0;\n\n\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\tthis.start();\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tif ( this.running ) {\n\n\t\t\tconst newTime = now();\n\n\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\n\t\t\tthis.oldTime = newTime;\n\n\t\t\tthis.elapsedTime += diff;\n\n\t\t}\n\n\t\treturn diff;\n\n\t}\n\n}\n\nfunction now() {\n\n\treturn ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732\n\n}\n\nconst _position$1 = /*@__PURE__*/ new Vector3();\nconst _quaternion$1 = /*@__PURE__*/ new Quaternion();\nconst _scale$1 = /*@__PURE__*/ new Vector3();\nconst _orientation$1 = /*@__PURE__*/ new Vector3();\n\nclass AudioListener extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'AudioListener';\n\n\t\tthis.context = AudioContext.getContext();\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( this.context.destination );\n\n\t\tthis.filter = null;\n\n\t\tthis.timeDelta = 0;\n\n\t\t// private\n\n\t\tthis._clock = new Clock();\n\n\t}\n\n\tgetInput() {\n\n\t\treturn this.gain;\n\n\t}\n\n\tremoveFilter() {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\t\t\tthis.gain.connect( this.context.destination );\n\t\t\tthis.filter = null;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetFilter() {\n\n\t\treturn this.filter;\n\n\t}\n\n\tsetFilter( value ) {\n\n\t\tif ( this.filter !== null ) {\n\n\t\t\tthis.gain.disconnect( this.filter );\n\t\t\tthis.filter.disconnect( this.context.destination );\n\n\t\t} else {\n\n\t\t\tthis.gain.disconnect( this.context.destination );\n\n\t\t}\n\n\t\tthis.filter = value;\n\t\tthis.gain.connect( this.filter );\n\t\tthis.filter.connect( this.context.destination );\n\n\t\treturn this;\n\n\t}\n\n\tgetMasterVolume() {\n\n\t\treturn this.gain.gain.value;\n\n\t}\n\n\tsetMasterVolume( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tconst listener = this.context.listener;\n\t\tconst up = this.up;\n\n\t\tthis.timeDelta = this._clock.getDelta();\n\n\t\tthis.matrixWorld.decompose( _position$1, _quaternion$1, _scale$1 );\n\n\t\t_orientation$1.set( 0, 0, - 1 ).applyQuaternion( _quaternion$1 );\n\n\t\tif ( listener.positionX ) {\n\n\t\t\t// code path for Chrome (see #14393)\n\n\t\t\tconst endTime = this.context.currentTime + this.timeDelta;\n\n\t\t\tlistener.positionX.linearRampToValueAtTime( _position$1.x, endTime );\n\t\t\tlistener.positionY.linearRampToValueAtTime( _position$1.y, endTime );\n\t\t\tlistener.positionZ.linearRampToValueAtTime( _position$1.z, endTime );\n\t\t\tlistener.forwardX.linearRampToValueAtTime( _orientation$1.x, endTime );\n\t\t\tlistener.forwardY.linearRampToValueAtTime( _orientation$1.y, endTime );\n\t\t\tlistener.forwardZ.linearRampToValueAtTime( _orientation$1.z, endTime );\n\t\t\tlistener.upX.linearRampToValueAtTime( up.x, endTime );\n\t\t\tlistener.upY.linearRampToValueAtTime( up.y, endTime );\n\t\t\tlistener.upZ.linearRampToValueAtTime( up.z, endTime );\n\n\t\t} else {\n\n\t\t\tlistener.setPosition( _position$1.x, _position$1.y, _position$1.z );\n\t\t\tlistener.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z );\n\n\t\t}\n\n\t}\n\n}\n\nclass Audio extends Object3D {\n\n\tconstructor( listener ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'Audio';\n\n\t\tthis.listener = listener;\n\t\tthis.context = listener.context;\n\n\t\tthis.gain = this.context.createGain();\n\t\tthis.gain.connect( listener.getInput() );\n\n\t\tthis.autoplay = false;\n\n\t\tthis.buffer = null;\n\t\tthis.detune = 0;\n\t\tthis.loop = false;\n\t\tthis.loopStart = 0;\n\t\tthis.loopEnd = 0;\n\t\tthis.offset = 0;\n\t\tthis.duration = undefined;\n\t\tthis.playbackRate = 1;\n\t\tthis.isPlaying = false;\n\t\tthis.hasPlaybackControl = true;\n\t\tthis.source = null;\n\t\tthis.sourceType = 'empty';\n\n\t\tthis._startedAt = 0;\n\t\tthis._progress = 0;\n\t\tthis._connected = false;\n\n\t\tthis.filters = [];\n\n\t}\n\n\tgetOutput() {\n\n\t\treturn this.gain;\n\n\t}\n\n\tsetNodeSource( audioNode ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'audioNode';\n\t\tthis.source = audioNode;\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetMediaElementSource( mediaElement ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'mediaNode';\n\t\tthis.source = this.context.createMediaElementSource( mediaElement );\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetMediaStreamSource( mediaStream ) {\n\n\t\tthis.hasPlaybackControl = false;\n\t\tthis.sourceType = 'mediaStreamNode';\n\t\tthis.source = this.context.createMediaStreamSource( mediaStream );\n\t\tthis.connect();\n\n\t\treturn this;\n\n\t}\n\n\tsetBuffer( audioBuffer ) {\n\n\t\tthis.buffer = audioBuffer;\n\t\tthis.sourceType = 'buffer';\n\n\t\tif ( this.autoplay ) this.play();\n\n\t\treturn this;\n\n\t}\n\n\tplay( delay = 0 ) {\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._startedAt = this.context.currentTime + delay;\n\n\t\tconst source = this.context.createBufferSource();\n\t\tsource.buffer = this.buffer;\n\t\tsource.loop = this.loop;\n\t\tsource.loopStart = this.loopStart;\n\t\tsource.loopEnd = this.loopEnd;\n\t\tsource.onended = this.onEnded.bind( this );\n\t\tsource.start( this._startedAt, this._progress + this.offset, this.duration );\n\n\t\tthis.isPlaying = true;\n\n\t\tthis.source = source;\n\n\t\tthis.setDetune( this.detune );\n\t\tthis.setPlaybackRate( this.playbackRate );\n\n\t\treturn this.connect();\n\n\t}\n\n\tpause() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\t// update current progress\n\n\t\t\tthis._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;\n\n\t\t\tif ( this.loop === true ) {\n\n\t\t\t\t// ensure _progress does not exceed duration with looped audios\n\n\t\t\t\tthis._progress = this._progress % ( this.duration || this.buffer.duration );\n\n\t\t\t}\n\n\t\t\tthis.source.stop();\n\t\t\tthis.source.onended = null;\n\n\t\t\tthis.isPlaying = false;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tstop() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis._progress = 0;\n\n\t\tif ( this.source !== null ) {\n\n\t\t\tthis.source.stop();\n\t\t\tthis.source.onended = null;\n\n\t\t}\n\n\t\tthis.isPlaying = false;\n\n\t\treturn this;\n\n\t}\n\n\tconnect() {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.connect( this.filters[ 0 ] );\n\n\t\t\tfor ( let i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.connect( this.getOutput() );\n\n\t\t}\n\n\t\tthis._connected = true;\n\n\t\treturn this;\n\n\t}\n\n\tdisconnect() {\n\n\t\tif ( this.filters.length > 0 ) {\n\n\t\t\tthis.source.disconnect( this.filters[ 0 ] );\n\n\t\t\tfor ( let i = 1, l = this.filters.length; i < l; i ++ ) {\n\n\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\n\n\t\t} else {\n\n\t\t\tthis.source.disconnect( this.getOutput() );\n\n\t\t}\n\n\t\tthis._connected = false;\n\n\t\treturn this;\n\n\t}\n\n\tgetFilters() {\n\n\t\treturn this.filters;\n\n\t}\n\n\tsetFilters( value ) {\n\n\t\tif ( ! value ) value = [];\n\n\t\tif ( this._connected === true ) {\n\n\t\t\tthis.disconnect();\n\t\t\tthis.filters = value.slice();\n\t\t\tthis.connect();\n\n\t\t} else {\n\n\t\t\tthis.filters = value.slice();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetDetune( value ) {\n\n\t\tthis.detune = value;\n\n\t\tif ( this.source.detune === undefined ) return; // only set detune when available\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetDetune() {\n\n\t\treturn this.detune;\n\n\t}\n\n\tgetFilter() {\n\n\t\treturn this.getFilters()[ 0 ];\n\n\t}\n\n\tsetFilter( filter ) {\n\n\t\treturn this.setFilters( filter ? [ filter ] : [] );\n\n\t}\n\n\tsetPlaybackRate( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.playbackRate = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetPlaybackRate() {\n\n\t\treturn this.playbackRate;\n\n\t}\n\n\tonEnded() {\n\n\t\tthis.isPlaying = false;\n\n\t}\n\n\tgetLoop() {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn this.loop;\n\n\t}\n\n\tsetLoop( value ) {\n\n\t\tif ( this.hasPlaybackControl === false ) {\n\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.loop = value;\n\n\t\tif ( this.isPlaying === true ) {\n\n\t\t\tthis.source.loop = this.loop;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetLoopStart( value ) {\n\n\t\tthis.loopStart = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetLoopEnd( value ) {\n\n\t\tthis.loopEnd = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetVolume() {\n\n\t\treturn this.gain.gain.value;\n\n\t}\n\n\tsetVolume( value ) {\n\n\t\tthis.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _position = /*@__PURE__*/ new Vector3();\nconst _quaternion = /*@__PURE__*/ new Quaternion();\nconst _scale = /*@__PURE__*/ new Vector3();\nconst _orientation = /*@__PURE__*/ new Vector3();\n\nclass PositionalAudio extends Audio {\n\n\tconstructor( listener ) {\n\n\t\tsuper( listener );\n\n\t\tthis.panner = this.context.createPanner();\n\t\tthis.panner.panningModel = 'HRTF';\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tconnect() {\n\n\t\tsuper.connect();\n\n\t\tthis.panner.connect( this.gain );\n\n\t}\n\n\tdisconnect() {\n\n\t\tsuper.disconnect();\n\n\t\tthis.panner.disconnect( this.gain );\n\n\t}\n\n\tgetOutput() {\n\n\t\treturn this.panner;\n\n\t}\n\n\tgetRefDistance() {\n\n\t\treturn this.panner.refDistance;\n\n\t}\n\n\tsetRefDistance( value ) {\n\n\t\tthis.panner.refDistance = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetRolloffFactor() {\n\n\t\treturn this.panner.rolloffFactor;\n\n\t}\n\n\tsetRolloffFactor( value ) {\n\n\t\tthis.panner.rolloffFactor = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetDistanceModel() {\n\n\t\treturn this.panner.distanceModel;\n\n\t}\n\n\tsetDistanceModel( value ) {\n\n\t\tthis.panner.distanceModel = value;\n\n\t\treturn this;\n\n\t}\n\n\tgetMaxDistance() {\n\n\t\treturn this.panner.maxDistance;\n\n\t}\n\n\tsetMaxDistance( value ) {\n\n\t\tthis.panner.maxDistance = value;\n\n\t\treturn this;\n\n\t}\n\n\tsetDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {\n\n\t\tthis.panner.coneInnerAngle = coneInnerAngle;\n\t\tthis.panner.coneOuterAngle = coneOuterAngle;\n\t\tthis.panner.coneOuterGain = coneOuterGain;\n\n\t\treturn this;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tif ( this.hasPlaybackControl === true && this.isPlaying === false ) return;\n\n\t\tthis.matrixWorld.decompose( _position, _quaternion, _scale );\n\n\t\t_orientation.set( 0, 0, 1 ).applyQuaternion( _quaternion );\n\n\t\tconst panner = this.panner;\n\n\t\tif ( panner.positionX ) {\n\n\t\t\t// code path for Chrome and Firefox (see #14393)\n\n\t\t\tconst endTime = this.context.currentTime + this.listener.timeDelta;\n\n\t\t\tpanner.positionX.linearRampToValueAtTime( _position.x, endTime );\n\t\t\tpanner.positionY.linearRampToValueAtTime( _position.y, endTime );\n\t\t\tpanner.positionZ.linearRampToValueAtTime( _position.z, endTime );\n\t\t\tpanner.orientationX.linearRampToValueAtTime( _orientation.x, endTime );\n\t\t\tpanner.orientationY.linearRampToValueAtTime( _orientation.y, endTime );\n\t\t\tpanner.orientationZ.linearRampToValueAtTime( _orientation.z, endTime );\n\n\t\t} else {\n\n\t\t\tpanner.setPosition( _position.x, _position.y, _position.z );\n\t\t\tpanner.setOrientation( _orientation.x, _orientation.y, _orientation.z );\n\n\t\t}\n\n\t}\n\n}\n\nclass AudioAnalyser {\n\n\tconstructor( audio, fftSize = 2048 ) {\n\n\t\tthis.analyser = audio.context.createAnalyser();\n\t\tthis.analyser.fftSize = fftSize;\n\n\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\n\n\t\taudio.getOutput().connect( this.analyser );\n\n\t}\n\n\n\tgetFrequencyData() {\n\n\t\tthis.analyser.getByteFrequencyData( this.data );\n\n\t\treturn this.data;\n\n\t}\n\n\tgetAverageFrequency() {\n\n\t\tlet value = 0;\n\t\tconst data = this.getFrequencyData();\n\n\t\tfor ( let i = 0; i < data.length; i ++ ) {\n\n\t\t\tvalue += data[ i ];\n\n\t\t}\n\n\t\treturn value / data.length;\n\n\t}\n\n}\n\nclass PropertyMixer {\n\n\tconstructor( binding, typeName, valueSize ) {\n\n\t\tthis.binding = binding;\n\t\tthis.valueSize = valueSize;\n\n\t\tlet mixFunction,\n\t\t\tmixFunctionAdditive,\n\t\t\tsetIdentity;\n\n\t\t// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]\n\t\t//\n\t\t// interpolators can use .buffer as their .result\n\t\t// the data then goes to 'incoming'\n\t\t//\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\n\t\t// the cumulative result and are compared to detect\n\t\t// changes\n\t\t//\n\t\t// 'orig' stores the original state of the property\n\t\t//\n\t\t// 'add' is used for additive cumulative results\n\t\t//\n\t\t// 'work' is optional and is only present for quaternion types. It is used\n\t\t// to store intermediate quaternion multiplication results\n\n\t\tswitch ( typeName ) {\n\n\t\t\tcase 'quaternion':\n\t\t\t\tmixFunction = this._slerp;\n\t\t\t\tmixFunctionAdditive = this._slerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityQuaternion;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 6 );\n\t\t\t\tthis._workIndex = 5;\n\t\t\t\tbreak;\n\n\t\t\tcase 'string':\n\t\t\tcase 'bool':\n\t\t\t\tmixFunction = this._select;\n\n\t\t\t\t// Use the regular mix function and for additive on these types,\n\t\t\t\t// additive is not relevant for non-numeric types\n\t\t\t\tmixFunctionAdditive = this._select;\n\n\t\t\t\tsetIdentity = this._setAdditiveIdentityOther;\n\n\t\t\t\tthis.buffer = new Array( valueSize * 5 );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tmixFunction = this._lerp;\n\t\t\t\tmixFunctionAdditive = this._lerpAdditive;\n\t\t\t\tsetIdentity = this._setAdditiveIdentityNumeric;\n\n\t\t\t\tthis.buffer = new Float64Array( valueSize * 5 );\n\n\t\t}\n\n\t\tthis._mixBufferRegion = mixFunction;\n\t\tthis._mixBufferRegionAdditive = mixFunctionAdditive;\n\t\tthis._setIdentity = setIdentity;\n\t\tthis._origIndex = 3;\n\t\tthis._addIndex = 4;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tthis.useCount = 0;\n\t\tthis.referenceCount = 0;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'accu<i>'\n\taccumulate( accuIndex, weight ) {\n\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\n\t\t// the weight and shouldn't have made the call in the first place\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = accuIndex * stride + stride;\n\n\t\tlet currentWeight = this.cumulativeWeight;\n\n\t\tif ( currentWeight === 0 ) {\n\n\t\t\t// accuN := incoming * weight\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\n\n\t\t\t}\n\n\t\t\tcurrentWeight = weight;\n\n\t\t} else {\n\n\t\t\t// accuN := accuN + incoming * weight\n\n\t\t\tcurrentWeight += weight;\n\t\t\tconst mix = weight / currentWeight;\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\n\n\t\t}\n\n\t\tthis.cumulativeWeight = currentWeight;\n\n\t}\n\n\t// accumulate data in the 'incoming' region into 'add'\n\taccumulateAdditive( weight ) {\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\t\t\toffset = stride * this._addIndex;\n\n\t\tif ( this.cumulativeWeightAdditive === 0 ) {\n\n\t\t\t// add = identity\n\n\t\t\tthis._setIdentity();\n\n\t\t}\n\n\t\t// add := add + incoming * weight\n\n\t\tthis._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );\n\t\tthis.cumulativeWeightAdditive += weight;\n\n\t}\n\n\t// apply the state of 'accu<i>' to the binding when accus differ\n\tapply( accuIndex ) {\n\n\t\tconst stride = this.valueSize,\n\t\t\tbuffer = this.buffer,\n\t\t\toffset = accuIndex * stride + stride,\n\n\t\t\tweight = this.cumulativeWeight,\n\t\t\tweightAdditive = this.cumulativeWeightAdditive,\n\n\t\t\tbinding = this.binding;\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t\tif ( weight < 1 ) {\n\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\n\n\t\t\tconst originalValueOffset = stride * this._origIndex;\n\n\t\t\tthis._mixBufferRegion(\n\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\n\n\t\t}\n\n\t\tif ( weightAdditive > 0 ) {\n\n\t\t\t// accuN := accuN + additive accuN\n\n\t\t\tthis._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );\n\n\t\t}\n\n\t\tfor ( let i = stride, e = stride + stride; i !== e; ++ i ) {\n\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\n\n\t\t\t\t// value has changed -> update scene graph\n\n\t\t\t\tbinding.setValue( buffer, offset );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remember the state of the bound property and copy it to both accus\n\tsaveOriginalState() {\n\n\t\tconst binding = this.binding;\n\n\t\tconst buffer = this.buffer,\n\t\t\tstride = this.valueSize,\n\n\t\t\toriginalValueOffset = stride * this._origIndex;\n\n\t\tbinding.getValue( buffer, originalValueOffset );\n\n\t\t// accu[0..1] := orig -- initially detect changes against the original\n\t\tfor ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {\n\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\n\n\t\t}\n\n\t\t// Add to identity for additive\n\t\tthis._setIdentity();\n\n\t\tthis.cumulativeWeight = 0;\n\t\tthis.cumulativeWeightAdditive = 0;\n\n\t}\n\n\t// apply the state previously taken via 'saveOriginalState' to the binding\n\trestoreOriginalState() {\n\n\t\tconst originalValueOffset = this.valueSize * 3;\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\n\n\t}\n\n\t_setAdditiveIdentityNumeric() {\n\n\t\tconst startIndex = this._addIndex * this.valueSize;\n\t\tconst endIndex = startIndex + this.valueSize;\n\n\t\tfor ( let i = startIndex; i < endIndex; i ++ ) {\n\n\t\t\tthis.buffer[ i ] = 0;\n\n\t\t}\n\n\t}\n\n\t_setAdditiveIdentityQuaternion() {\n\n\t\tthis._setAdditiveIdentityNumeric();\n\t\tthis.buffer[ this._addIndex * this.valueSize + 3 ] = 1;\n\n\t}\n\n\t_setAdditiveIdentityOther() {\n\n\t\tconst startIndex = this._origIndex * this.valueSize;\n\t\tconst targetIndex = this._addIndex * this.valueSize;\n\n\t\tfor ( let i = 0; i < this.valueSize; i ++ ) {\n\n\t\t\tthis.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];\n\n\t\t}\n\n\t}\n\n\n\t// mix functions\n\n\t_select( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tif ( t >= 0.5 ) {\n\n\t\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_slerp( buffer, dstOffset, srcOffset, t ) {\n\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\n\n\t}\n\n\t_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst workOffset = this._workIndex * stride;\n\n\t\t// Store result in intermediate buffer offset\n\t\tQuaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );\n\n\t\t// Slerp to the intermediate result\n\t\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );\n\n\t}\n\n\t_lerp( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tconst s = 1 - t;\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n\t_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {\n\n\t\tfor ( let i = 0; i !== stride; ++ i ) {\n\n\t\t\tconst j = dstOffset + i;\n\n\t\t\tbuffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;\n\n\t\t}\n\n\t}\n\n}\n\n// Characters [].:/ are reserved for track binding syntax.\nconst _RESERVED_CHARS_RE = '\\\\[\\\\]\\\\.:\\\\/';\nconst _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );\n\n// Attempts to allow node names from any language. ES5's `\\w` regexp matches\n// only latin characters, and the unicode \\p{L} is not yet supported. So\n// instead, we exclude reserved characters and match everything else.\nconst _wordChar = '[^' + _RESERVED_CHARS_RE + ']';\nconst _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\\\.', '' ) + ']';\n\n// Parent directories, delimited by '/' or ':'. Currently unused, but must\n// be matched to parse the rest of the track name.\nconst _directoryRe = /*@__PURE__*/ /((?:WC+[\\/:])*)/.source.replace( 'WC', _wordChar );\n\n// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\nconst _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );\n\n// Object on target node, and accessor. May not contain reserved\n// characters. Accessor may contain any character except closing bracket.\nconst _objectRe = /*@__PURE__*/ /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace( 'WC', _wordChar );\n\n// Property and accessor. May not contain reserved characters. Accessor may\n// contain any non-bracket characters.\nconst _propertyRe = /*@__PURE__*/ /\\.(WC+)(?:\\[(.+)\\])?/.source.replace( 'WC', _wordChar );\n\nconst _trackRe = new RegExp( ''\n\t+ '^'\n\t+ _directoryRe\n\t+ _nodeRe\n\t+ _objectRe\n\t+ _propertyRe\n\t+ '$'\n);\n\nconst _supportedObjectNames = [ 'material', 'materials', 'bones', 'map' ];\n\nclass Composite {\n\n\tconstructor( targetGroup, path, optionalParsedPath ) {\n\n\t\tconst parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis._targetGroup = targetGroup;\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\n\n\t}\n\n\tgetValue( array, offset ) {\n\n\t\tthis.bind(); // bind all binding\n\n\t\tconst firstValidIndex = this._targetGroup.nCachedObjects_,\n\t\t\tbinding = this._bindings[ firstValidIndex ];\n\n\t\t// and only call .getValue on the first\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\n\n\t}\n\n\tsetValue( array, offset ) {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].setValue( array, offset );\n\n\t\t}\n\n\t}\n\n\tbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].bind();\n\n\t\t}\n\n\t}\n\n\tunbind() {\n\n\t\tconst bindings = this._bindings;\n\n\t\tfor ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tbindings[ i ].unbind();\n\n\t\t}\n\n\t}\n\n}\n\n// Note: This class uses a State pattern on a per-method basis:\n// 'bind' sets 'this.getValue' / 'setValue' and shadows the\n// prototype version of these methods with one that represents\n// the bound state. When the property is not found, the methods\n// become no-ops.\nclass PropertyBinding {\n\n\tconstructor( rootNode, path, parsedPath ) {\n\n\t\tthis.path = path;\n\t\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\n\n\t\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName );\n\n\t\tthis.rootNode = rootNode;\n\n\t\t// initial state of these methods that calls 'bind'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n\n\tstatic create( root, path, parsedPath ) {\n\n\t\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\n\n\t\t\treturn new PropertyBinding( root, path, parsedPath );\n\n\t\t} else {\n\n\t\t\treturn new PropertyBinding.Composite( root, path, parsedPath );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Replaces spaces with underscores and removes unsupported characters from\n\t * node names, to ensure compatibility with parseTrackName().\n\t *\n\t * @param {string} name Node name to be sanitized.\n\t * @return {string}\n\t */\n\tstatic sanitizeNodeName( name ) {\n\n\t\treturn name.replace( /\\s/g, '_' ).replace( _reservedRe, '' );\n\n\t}\n\n\tstatic parseTrackName( trackName ) {\n\n\t\tconst matches = _trackRe.exec( trackName );\n\n\t\tif ( matches === null ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\n\n\t\t}\n\n\t\tconst results = {\n\t\t\t// directoryName: matches[ 1 ], // (tschw) currently unused\n\t\t\tnodeName: matches[ 2 ],\n\t\t\tobjectName: matches[ 3 ],\n\t\t\tobjectIndex: matches[ 4 ],\n\t\t\tpropertyName: matches[ 5 ], // required\n\t\t\tpropertyIndex: matches[ 6 ]\n\t\t};\n\n\t\tconst lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\n\n\t\tif ( lastDot !== undefined && lastDot !== - 1 ) {\n\n\t\t\tconst objectName = results.nodeName.substring( lastDot + 1 );\n\n\t\t\t// Object names must be checked against an allowlist. Otherwise, there\n\t\t\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\n\t\t\t// 'bar' could be the objectName, or part of a nodeName (which can\n\t\t\t// include '.' characters).\n\t\t\tif ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {\n\n\t\t\t\tresults.nodeName = results.nodeName.substring( 0, lastDot );\n\t\t\t\tresults.objectName = objectName;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\n\n\t\t\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\n\n\t\t}\n\n\t\treturn results;\n\n\t}\n\n\tstatic findNode( root, nodeName ) {\n\n\t\tif ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\n\n\t\t\treturn root;\n\n\t\t}\n\n\t\t// search into skeleton bones.\n\t\tif ( root.skeleton ) {\n\n\t\t\tconst bone = root.skeleton.getBoneByName( nodeName );\n\n\t\t\tif ( bone !== undefined ) {\n\n\t\t\t\treturn bone;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// search into node subtree.\n\t\tif ( root.children ) {\n\n\t\t\tconst searchNodeSubtree = function ( children ) {\n\n\t\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\t\tconst childNode = children[ i ];\n\n\t\t\t\t\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\n\n\t\t\t\t\t\treturn childNode;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = searchNodeSubtree( childNode.children );\n\n\t\t\t\t\tif ( result ) return result;\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t};\n\n\t\t\tconst subTreeNode = searchNodeSubtree( root.children );\n\n\t\t\tif ( subTreeNode ) {\n\n\t\t\t\treturn subTreeNode;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// these are used to \"bind\" a nonexistent property\n\t_getValue_unavailable() {}\n\t_setValue_unavailable() {}\n\n\t// Getters\n\n\t_getValue_direct( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.targetObject[ this.propertyName ];\n\n\t}\n\n\t_getValue_array( buffer, offset ) {\n\n\t\tconst source = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = source.length; i !== n; ++ i ) {\n\n\t\t\tbuffer[ offset ++ ] = source[ i ];\n\n\t\t}\n\n\t}\n\n\t_getValue_arrayElement( buffer, offset ) {\n\n\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\n\n\t}\n\n\t_getValue_toArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.toArray( buffer, offset );\n\n\t}\n\n\t// Direct\n\n\t_setValue_direct( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_direct_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// EntireArray\n\n\t_setValue_array( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t}\n\n\t_setValue_array_setNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tconst dest = this.resolvedProperty;\n\n\t\tfor ( let i = 0, n = dest.length; i !== n; ++ i ) {\n\n\t\t\tdest[ i ] = buffer[ offset ++ ];\n\n\t\t}\n\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// ArrayElement\n\n\t_setValue_arrayElement( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\n\t}\n\n\t_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t// HasToFromArray\n\n\t_setValue_fromArray( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\n\t}\n\n\t_setValue_fromArray_setNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.needsUpdate = true;\n\n\t}\n\n\t_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\n\n\t\tthis.resolvedProperty.fromArray( buffer, offset );\n\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\n\n\t}\n\n\t_getValue_unbound( targetArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.getValue( targetArray, offset );\n\n\t}\n\n\t_setValue_unbound( sourceArray, offset ) {\n\n\t\tthis.bind();\n\t\tthis.setValue( sourceArray, offset );\n\n\t}\n\n\t// create getter / setter pair for a property in the scene graph\n\tbind() {\n\n\t\tlet targetObject = this.node;\n\t\tconst parsedPath = this.parsedPath;\n\n\t\tconst objectName = parsedPath.objectName;\n\t\tconst propertyName = parsedPath.propertyName;\n\t\tlet propertyIndex = parsedPath.propertyIndex;\n\n\t\tif ( ! targetObject ) {\n\n\t\t\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName );\n\n\t\t\tthis.node = targetObject;\n\n\t\t}\n\n\t\t// set fail state so we can just 'return' on error\n\t\tthis.getValue = this._getValue_unavailable;\n\t\tthis.setValue = this._setValue_unavailable;\n\n\t\t// ensure there is a value node\n\t\tif ( ! targetObject ) {\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\'t found.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( objectName ) {\n\n\t\t\tlet objectIndex = parsedPath.objectIndex;\n\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\n\t\t\tswitch ( objectName ) {\n\n\t\t\t\tcase 'materials':\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.materials ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.materials;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bones':\n\n\t\t\t\t\tif ( ! targetObject.skeleton ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\n\t\t\t\t\t// and convert the integer string to a true integer.\n\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\n\n\t\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\t\tfor ( let i = 0; i < targetObject.length; i ++ ) {\n\n\t\t\t\t\t\tif ( targetObject[ i ].name === objectIndex ) {\n\n\t\t\t\t\t\t\tobjectIndex = i;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map':\n\n\t\t\t\t\tif ( 'map' in targetObject ) {\n\n\t\t\t\t\t\ttargetObject = targetObject.map;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! targetObject.material.map ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject.material.map;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\n\n\t\t\t}\n\n\n\t\t\tif ( objectIndex !== undefined ) {\n\n\t\t\t\tif ( targetObject[ objectIndex ] === undefined ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// resolve property\n\t\tconst nodeProperty = targetObject[ propertyName ];\n\n\t\tif ( nodeProperty === undefined ) {\n\n\t\t\tconst nodeName = parsedPath.nodeName;\n\n\t\t\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\n\t\t\t\t'.' + propertyName + ' but it wasn\\'t found.', targetObject );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// determine versioning scheme\n\t\tlet versioning = this.Versioning.None;\n\n\t\tthis.targetObject = targetObject;\n\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\n\n\t\t\tversioning = this.Versioning.NeedsUpdate;\n\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\n\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\n\n\t\t}\n\n\t\t// determine how the property gets bound\n\t\tlet bindingType = this.BindingType.Direct;\n\n\t\tif ( propertyIndex !== undefined ) {\n\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\n\n\t\t\tif ( propertyName === 'morphTargetInfluences' ) {\n\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\n\n\t\t\t\t// support resolving morphTarget names into indices.\n\t\t\t\tif ( ! targetObject.geometry ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! targetObject.geometry.morphAttributes ) {\n\n\t\t\t\t\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {\n\n\t\t\t\t\tpropertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbindingType = this.BindingType.ArrayElement;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\t\t\tthis.propertyIndex = propertyIndex;\n\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\n\n\t\t\t// must use copy for Object3D.Euler/Quaternion\n\n\t\t\tbindingType = this.BindingType.HasFromToArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else if ( Array.isArray( nodeProperty ) ) {\n\n\t\t\tbindingType = this.BindingType.EntireArray;\n\n\t\t\tthis.resolvedProperty = nodeProperty;\n\n\t\t} else {\n\n\t\t\tthis.propertyName = propertyName;\n\n\t\t}\n\n\t\t// select getter / setter\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\n\n\t}\n\n\tunbind() {\n\n\t\tthis.node = null;\n\n\t\t// back to the prototype version of getValue / setValue\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\n\t\tthis.getValue = this._getValue_unbound;\n\t\tthis.setValue = this._setValue_unbound;\n\n\t}\n\n}\n\nPropertyBinding.Composite = Composite;\n\nPropertyBinding.prototype.BindingType = {\n\tDirect: 0,\n\tEntireArray: 1,\n\tArrayElement: 2,\n\tHasFromToArray: 3\n};\n\nPropertyBinding.prototype.Versioning = {\n\tNone: 0,\n\tNeedsUpdate: 1,\n\tMatrixWorldNeedsUpdate: 2\n};\n\nPropertyBinding.prototype.GetterByBindingType = [\n\n\tPropertyBinding.prototype._getValue_direct,\n\tPropertyBinding.prototype._getValue_array,\n\tPropertyBinding.prototype._getValue_arrayElement,\n\tPropertyBinding.prototype._getValue_toArray,\n\n];\n\nPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [\n\n\t[\n\t\t// Direct\n\t\tPropertyBinding.prototype._setValue_direct,\n\t\tPropertyBinding.prototype._setValue_direct_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// EntireArray\n\n\t\tPropertyBinding.prototype._setValue_array,\n\t\tPropertyBinding.prototype._setValue_array_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// ArrayElement\n\t\tPropertyBinding.prototype._setValue_arrayElement,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,\n\n\t], [\n\n\t\t// HasToFromArray\n\t\tPropertyBinding.prototype._setValue_fromArray,\n\t\tPropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,\n\t\tPropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,\n\n\t]\n\n];\n\n/**\n *\n * A group of objects that receives a shared animation state.\n *\n * Usage:\n *\n *  - Add objects you would otherwise pass as 'root' to the\n *    constructor or the .clipAction method of AnimationMixer.\n *\n *  - Instead pass this object as 'root'.\n *\n *  - You can also add and remove objects later when the mixer\n *    is running.\n *\n * Note:\n *\n *    Objects of this class appear as one object to the mixer,\n *    so cache control of the individual objects must be done\n *    on the group.\n *\n * Limitation:\n *\n *  - The animated properties must be compatible among the\n *    all objects in the group.\n *\n *  - A single property can either be controlled through a\n *    target group or directly, but not both.\n */\n\nclass AnimationObjectGroup {\n\n\tconstructor() {\n\n\t\tthis.isAnimationObjectGroup = true;\n\n\t\tthis.uuid = generateUUID();\n\n\t\t// cached objects followed by the active ones\n\t\tthis._objects = Array.prototype.slice.call( arguments );\n\n\t\tthis.nCachedObjects_ = 0; // threshold\n\t\t// note: read by PropertyBinding.Composite\n\n\t\tconst indices = {};\n\t\tthis._indicesByUUID = indices; // for bookkeeping\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tindices[ arguments[ i ].uuid ] = i;\n\n\t\t}\n\n\t\tthis._paths = []; // inside: string\n\t\tthis._parsedPaths = []; // inside: { we don't care, here }\n\t\tthis._bindings = []; // inside: Array< PropertyBinding >\n\t\tthis._bindingsIndicesByPath = {}; // inside: indices in these arrays\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tobjects: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._objects.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn this.total - scope.nCachedObjects_;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tget bindingsPerObject() {\n\n\t\t\t\treturn scope._bindings.length;\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tadd() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tpaths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet knownObject = undefined,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid;\n\t\t\tlet index = indicesByUUID[ uuid ];\n\n\t\t\tif ( index === undefined ) {\n\n\t\t\t\t// unknown object -> add it to the ACTIVE region\n\n\t\t\t\tindex = nObjects ++;\n\t\t\t\tindicesByUUID[ uuid ] = index;\n\t\t\t\tobjects.push( object );\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\n\n\t\t\t\t}\n\n\t\t\t} else if ( index < nCachedObjects ) {\n\n\t\t\t\tknownObject = objects[ index ];\n\n\t\t\t\t// move existing object to the ACTIVE region\n\n\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\n\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\n\t\t\t\tobjects[ firstActiveIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ];\n\n\t\t\t\t\tlet binding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\n\t\t\t\t\tif ( binding === undefined ) {\n\n\t\t\t\t\t\t// since we do not bother to create new bindings\n\t\t\t\t\t\t// for objects that are cached, the binding may\n\t\t\t\t\t\t// or may not exist\n\n\t\t\t\t\t\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t} else if ( objects[ index ] !== knownObject ) {\n\n\t\t\t\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\n\t\t\t\t\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\n\n\t\t\t} // else the object is already where we want it to be\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\tremove() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\n\n\t\t\t\t// move existing object into the CACHED region\n\n\t\t\t\tconst lastCachedIndex = nCachedObjects ++,\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\n\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\n\t\t\t\tobjects[ index ] = firstActiveObject;\n\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\n\t\t\t\tobjects[ lastCachedIndex ] = object;\n\n\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\n\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t// remove & forget\n\tuncache() {\n\n\t\tconst objects = this._objects,\n\t\t\tindicesByUUID = this._indicesByUUID,\n\t\t\tbindings = this._bindings,\n\t\t\tnBindings = bindings.length;\n\n\t\tlet nCachedObjects = this.nCachedObjects_,\n\t\t\tnObjects = objects.length;\n\n\t\tfor ( let i = 0, n = arguments.length; i !== n; ++ i ) {\n\n\t\t\tconst object = arguments[ i ],\n\t\t\t\tuuid = object.uuid,\n\t\t\t\tindex = indicesByUUID[ uuid ];\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tdelete indicesByUUID[ uuid ];\n\n\t\t\t\tif ( index < nCachedObjects ) {\n\n\t\t\t\t\t// object is cached, shrink the CACHED region\n\n\t\t\t\t\tconst firstActiveIndex = -- nCachedObjects,\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\n\t\t\t\t\t\tlastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\t// last cached object takes this object's place\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\n\n\t\t\t\t\t// last object goes to the activated slot and pop\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ],\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// object is active, just swap with the last and pop\n\n\t\t\t\t\tconst lastIndex = -- nObjects,\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\n\n\t\t\t\t\tif ( lastIndex > 0 ) {\n\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects[ index ] = lastObject;\n\t\t\t\t\tobjects.pop();\n\n\t\t\t\t\t// accounting is done, now do the same for all bindings\n\n\t\t\t\t\tfor ( let j = 0, m = nBindings; j !== m; ++ j ) {\n\n\t\t\t\t\t\tconst bindingsForPath = bindings[ j ];\n\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\n\t\t\t\t\t\tbindingsForPath.pop();\n\n\t\t\t\t\t}\n\n\t\t\t\t} // cached or active\n\n\t\t\t} // if object is known\n\n\t\t} // for arguments\n\n\t\tthis.nCachedObjects_ = nCachedObjects;\n\n\t}\n\n\t// Internal interface used by befriended PropertyBinding.Composite:\n\n\tsubscribe_( path, parsedPath ) {\n\n\t\t// returns an array of bindings for the given path that is changed\n\t\t// according to the contained objects in the group\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath;\n\t\tlet index = indicesByPath[ path ];\n\t\tconst bindings = this._bindings;\n\n\t\tif ( index !== undefined ) return bindings[ index ];\n\n\t\tconst paths = this._paths,\n\t\t\tparsedPaths = this._parsedPaths,\n\t\t\tobjects = this._objects,\n\t\t\tnObjects = objects.length,\n\t\t\tnCachedObjects = this.nCachedObjects_,\n\t\t\tbindingsForPath = new Array( nObjects );\n\n\t\tindex = bindings.length;\n\n\t\tindicesByPath[ path ] = index;\n\n\t\tpaths.push( path );\n\t\tparsedPaths.push( parsedPath );\n\t\tbindings.push( bindingsForPath );\n\n\t\tfor ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\n\n\t\t\tconst object = objects[ i ];\n\t\t\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\n\n\t\t}\n\n\t\treturn bindingsForPath;\n\n\t}\n\n\tunsubscribe_( path ) {\n\n\t\t// tells the group to forget about a property path and no longer\n\t\t// update the array previously obtained with 'subscribe_'\n\n\t\tconst indicesByPath = this._bindingsIndicesByPath,\n\t\t\tindex = indicesByPath[ path ];\n\n\t\tif ( index !== undefined ) {\n\n\t\t\tconst paths = this._paths,\n\t\t\t\tparsedPaths = this._parsedPaths,\n\t\t\t\tbindings = this._bindings,\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\n\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\n\n\t\t\tbindings[ index ] = lastBindings;\n\t\t\tbindings.pop();\n\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\n\t\t\tparsedPaths.pop();\n\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\n\t\t\tpaths.pop();\n\n\t\t}\n\n\t}\n\n}\n\nclass AnimationAction {\n\n\tconstructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {\n\n\t\tthis._mixer = mixer;\n\t\tthis._clip = clip;\n\t\tthis._localRoot = localRoot;\n\t\tthis.blendMode = blendMode;\n\n\t\tconst tracks = clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tinterpolants = new Array( nTracks );\n\n\t\tconst interpolantSettings = {\n\t\t\tendingStart: ZeroCurvatureEnding,\n\t\t\tendingEnd: ZeroCurvatureEnding\n\t\t};\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst interpolant = tracks[ i ].createInterpolant( null );\n\t\t\tinterpolants[ i ] = interpolant;\n\t\t\tinterpolant.settings = interpolantSettings;\n\n\t\t}\n\n\t\tthis._interpolantSettings = interpolantSettings;\n\n\t\tthis._interpolants = interpolants; // bound by the mixer\n\n\t\t// inside: PropertyMixer (managed by the mixer)\n\t\tthis._propertyBindings = new Array( nTracks );\n\n\t\tthis._cacheIndex = null; // for the memory manager\n\t\tthis._byClipCacheIndex = null; // for the memory manager\n\n\t\tthis._timeScaleInterpolant = null;\n\t\tthis._weightInterpolant = null;\n\n\t\tthis.loop = LoopRepeat;\n\t\tthis._loopCount = - 1;\n\n\t\t// global mixer time when the action is to be started\n\t\t// it's set back to 'null' upon start of the action\n\t\tthis._startTime = null;\n\n\t\t// scaled local time of the action\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\n\t\tthis.time = 0;\n\n\t\tthis.timeScale = 1;\n\t\tthis._effectiveTimeScale = 1;\n\n\t\tthis.weight = 1;\n\t\tthis._effectiveWeight = 1;\n\n\t\tthis.repetitions = Infinity; // no. of repetitions when looping\n\n\t\tthis.paused = false; // true -> zero effective time scale\n\t\tthis.enabled = true; // false -> zero effective weight\n\n\t\tthis.clampWhenFinished = false;// keep feeding the last frame?\n\n\t\tthis.zeroSlopeAtStart = true;// for smooth interpolation w/o separate\n\t\tthis.zeroSlopeAtEnd = true;// clips for start, loop and end\n\n\t}\n\n\t// State & Scheduling\n\n\tplay() {\n\n\t\tthis._mixer._activateAction( this );\n\n\t\treturn this;\n\n\t}\n\n\tstop() {\n\n\t\tthis._mixer._deactivateAction( this );\n\n\t\treturn this.reset();\n\n\t}\n\n\treset() {\n\n\t\tthis.paused = false;\n\t\tthis.enabled = true;\n\n\t\tthis.time = 0; // restart clip\n\t\tthis._loopCount = - 1;// forget previous loops\n\t\tthis._startTime = null;// forget scheduling\n\n\t\treturn this.stopFading().stopWarping();\n\n\t}\n\n\tisRunning() {\n\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\n\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\n\n\t}\n\n\t// return true when play has been called\n\tisScheduled() {\n\n\t\treturn this._mixer._isActiveAction( this );\n\n\t}\n\n\tstartAt( time ) {\n\n\t\tthis._startTime = time;\n\n\t\treturn this;\n\n\t}\n\n\tsetLoop( mode, repetitions ) {\n\n\t\tthis.loop = mode;\n\t\tthis.repetitions = repetitions;\n\n\t\treturn this;\n\n\t}\n\n\t// Weight\n\n\t// set the weight stopping any scheduled fading\n\t// although .enabled = false yields an effective weight of zero, this\n\t// method does *not* change .enabled, because it would be confusing\n\tsetEffectiveWeight( weight ) {\n\n\t\tthis.weight = weight;\n\n\t\t// note: same logic as when updated at runtime\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\n\n\t\treturn this.stopFading();\n\n\t}\n\n\t// return the weight considering fading and .enabled\n\tgetEffectiveWeight() {\n\n\t\treturn this._effectiveWeight;\n\n\t}\n\n\tfadeIn( duration ) {\n\n\t\treturn this._scheduleFading( duration, 0, 1 );\n\n\t}\n\n\tfadeOut( duration ) {\n\n\t\treturn this._scheduleFading( duration, 1, 0 );\n\n\t}\n\n\tcrossFadeFrom( fadeOutAction, duration, warp ) {\n\n\t\tfadeOutAction.fadeOut( duration );\n\t\tthis.fadeIn( duration );\n\n\t\tif ( warp ) {\n\n\t\t\tconst fadeInDuration = this._clip.duration,\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\n\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\n\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcrossFadeTo( fadeInAction, duration, warp ) {\n\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\n\n\t}\n\n\tstopFading() {\n\n\t\tconst weightInterpolant = this._weightInterpolant;\n\n\t\tif ( weightInterpolant !== null ) {\n\n\t\t\tthis._weightInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Time Scale Control\n\n\t// set the time scale stopping any scheduled warping\n\t// although .paused = true yields an effective time scale of zero, this\n\t// method does *not* change .paused, because it would be confusing\n\tsetEffectiveTimeScale( timeScale ) {\n\n\t\tthis.timeScale = timeScale;\n\t\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\t// return the time scale considering warping and .paused\n\tgetEffectiveTimeScale() {\n\n\t\treturn this._effectiveTimeScale;\n\n\t}\n\n\tsetDuration( duration ) {\n\n\t\tthis.timeScale = this._clip.duration / duration;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\tsyncWith( action ) {\n\n\t\tthis.time = action.time;\n\t\tthis.timeScale = action.timeScale;\n\n\t\treturn this.stopWarping();\n\n\t}\n\n\thalt( duration ) {\n\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\n\n\t}\n\n\twarp( startTimeScale, endTimeScale, duration ) {\n\n\t\tconst mixer = this._mixer,\n\t\t\tnow = mixer.time,\n\t\t\ttimeScale = this.timeScale;\n\n\t\tlet interpolant = this._timeScaleInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._timeScaleInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\ttimes[ 1 ] = now + duration;\n\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\n\n\t\treturn this;\n\n\t}\n\n\tstopWarping() {\n\n\t\tconst timeScaleInterpolant = this._timeScaleInterpolant;\n\n\t\tif ( timeScaleInterpolant !== null ) {\n\n\t\t\tthis._timeScaleInterpolant = null;\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Object Accessors\n\n\tgetMixer() {\n\n\t\treturn this._mixer;\n\n\t}\n\n\tgetClip() {\n\n\t\treturn this._clip;\n\n\t}\n\n\tgetRoot() {\n\n\t\treturn this._localRoot || this._mixer._root;\n\n\t}\n\n\t// Interna\n\n\t_update( time, deltaTime, timeDirection, accuIndex ) {\n\n\t\t// called by the mixer\n\n\t\tif ( ! this.enabled ) {\n\n\t\t\t// call ._updateWeight() to update ._effectiveWeight\n\n\t\t\tthis._updateWeight( time );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst startTime = this._startTime;\n\n\t\tif ( startTime !== null ) {\n\n\t\t\t// check for scheduled start of action\n\n\t\t\tconst timeRunning = ( time - startTime ) * timeDirection;\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\n\n\t\t\t\tdeltaTime = 0;\n\n\t\t\t} else {\n\n\n\t\t\t\tthis._startTime = null; // unschedule\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// apply time scale and advance time\n\n\t\tdeltaTime *= this._updateTimeScale( time );\n\t\tconst clipTime = this._updateTime( deltaTime );\n\n\t\t// note: _updateTime may disable the action resulting in\n\t\t// an effective weight of 0\n\n\t\tconst weight = this._updateWeight( time );\n\n\t\tif ( weight > 0 ) {\n\n\t\t\tconst interpolants = this._interpolants;\n\t\t\tconst propertyMixers = this._propertyBindings;\n\n\t\t\tswitch ( this.blendMode ) {\n\n\t\t\t\tcase AdditiveAnimationBlendMode:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulateAdditive( weight );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase NormalAnimationBlendMode:\n\t\t\t\tdefault:\n\n\t\t\t\t\tfor ( let j = 0, m = interpolants.length; j !== m; ++ j ) {\n\n\t\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\n\t\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\n\n\t\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_updateWeight( time ) {\n\n\t\tlet weight = 0;\n\n\t\tif ( this.enabled ) {\n\n\t\t\tweight = this.weight;\n\t\t\tconst interpolant = this._weightInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\tweight *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopFading();\n\n\t\t\t\t\tif ( interpolantValue === 0 ) {\n\n\t\t\t\t\t\t// faded out, disable\n\t\t\t\t\t\tthis.enabled = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveWeight = weight;\n\t\treturn weight;\n\n\t}\n\n\t_updateTimeScale( time ) {\n\n\t\tlet timeScale = 0;\n\n\t\tif ( ! this.paused ) {\n\n\t\t\ttimeScale = this.timeScale;\n\n\t\t\tconst interpolant = this._timeScaleInterpolant;\n\n\t\t\tif ( interpolant !== null ) {\n\n\t\t\t\tconst interpolantValue = interpolant.evaluate( time )[ 0 ];\n\n\t\t\t\ttimeScale *= interpolantValue;\n\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\n\n\t\t\t\t\tthis.stopWarping();\n\n\t\t\t\t\tif ( timeScale === 0 ) {\n\n\t\t\t\t\t\t// motion has halted, pause\n\t\t\t\t\t\tthis.paused = true;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// warp done - apply final time scale\n\t\t\t\t\t\tthis.timeScale = timeScale;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis._effectiveTimeScale = timeScale;\n\t\treturn timeScale;\n\n\t}\n\n\t_updateTime( deltaTime ) {\n\n\t\tconst duration = this._clip.duration;\n\t\tconst loop = this.loop;\n\n\t\tlet time = this.time + deltaTime;\n\t\tlet loopCount = this._loopCount;\n\n\t\tconst pingPong = ( loop === LoopPingPong );\n\n\t\tif ( deltaTime === 0 ) {\n\n\t\t\tif ( loopCount === - 1 ) return time;\n\n\t\t\treturn ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;\n\n\t\t}\n\n\t\tif ( loop === LoopOnce ) {\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tthis._loopCount = 0;\n\t\t\t\tthis._setEndings( true, true, false );\n\n\t\t\t}\n\n\t\t\thandle_stop: {\n\n\t\t\t\tif ( time >= duration ) {\n\n\t\t\t\t\ttime = duration;\n\n\t\t\t\t} else if ( time < 0 ) {\n\n\t\t\t\t\ttime = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tbreak handle_stop;\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\telse this.enabled = false;\n\n\t\t\t\tthis.time = time;\n\n\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\tdirection: deltaTime < 0 ? - 1 : 1\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} else { // repetitive Repeat or PingPong\n\n\t\t\tif ( loopCount === - 1 ) {\n\n\t\t\t\t// just started\n\n\t\t\t\tif ( deltaTime >= 0 ) {\n\n\t\t\t\t\tloopCount = 0;\n\n\t\t\t\t\tthis._setEndings( true, this.repetitions === 0, pingPong );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// when looping in reverse direction, the initial\n\t\t\t\t\t// transition through zero counts as a repetition,\n\t\t\t\t\t// so leave loopCount at -1\n\n\t\t\t\t\tthis._setEndings( this.repetitions === 0, true, pingPong );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( time >= duration || time < 0 ) {\n\n\t\t\t\t// wrap around\n\n\t\t\t\tconst loopDelta = Math.floor( time / duration ); // signed\n\t\t\t\ttime -= duration * loopDelta;\n\n\t\t\t\tloopCount += Math.abs( loopDelta );\n\n\t\t\t\tconst pending = this.repetitions - loopCount;\n\n\t\t\t\tif ( pending <= 0 ) {\n\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\n\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\n\t\t\t\t\telse this.enabled = false;\n\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'finished', action: this,\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : - 1\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// keep running\n\n\t\t\t\t\tif ( pending === 1 ) {\n\n\t\t\t\t\t\t// entering the last round\n\n\t\t\t\t\t\tconst atStart = deltaTime < 0;\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._loopCount = loopCount;\n\n\t\t\t\t\tthis.time = time;\n\n\t\t\t\t\tthis._mixer.dispatchEvent( {\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tthis.time = time;\n\n\t\t\t}\n\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\n\n\t\t\t\t// invert time for the \"pong round\"\n\n\t\t\t\treturn duration - time;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn time;\n\n\t}\n\n\t_setEndings( atStart, atEnd, pingPong ) {\n\n\t\tconst settings = this._interpolantSettings;\n\n\t\tif ( pingPong ) {\n\n\t\t\tsettings.endingStart = ZeroSlopeEnding;\n\t\t\tsettings.endingEnd = ZeroSlopeEnding;\n\n\t\t} else {\n\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\n\n\t\t\tif ( atStart ) {\n\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingStart = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t\tif ( atEnd ) {\n\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n\n\t\t\t} else {\n\n\t\t\t\tsettings.endingEnd \t = WrapAroundEnding;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_scheduleFading( duration, weightNow, weightThen ) {\n\n\t\tconst mixer = this._mixer, now = mixer.time;\n\t\tlet interpolant = this._weightInterpolant;\n\n\t\tif ( interpolant === null ) {\n\n\t\t\tinterpolant = mixer._lendControlInterpolant();\n\t\t\tthis._weightInterpolant = interpolant;\n\n\t\t}\n\n\t\tconst times = interpolant.parameterPositions,\n\t\t\tvalues = interpolant.sampleValues;\n\n\t\ttimes[ 0 ] = now;\n\t\tvalues[ 0 ] = weightNow;\n\t\ttimes[ 1 ] = now + duration;\n\t\tvalues[ 1 ] = weightThen;\n\n\t\treturn this;\n\n\t}\n\n}\n\nconst _controlInterpolantsResultBuffer = new Float32Array( 1 );\n\n\nclass AnimationMixer extends EventDispatcher {\n\n\tconstructor( root ) {\n\n\t\tsuper();\n\n\t\tthis._root = root;\n\t\tthis._initMemoryManager();\n\t\tthis._accuIndex = 0;\n\t\tthis.time = 0;\n\t\tthis.timeScale = 1.0;\n\n\t}\n\n\t_bindAction( action, prototypeAction ) {\n\n\t\tconst root = action._localRoot || this._root,\n\t\t\ttracks = action._clip.tracks,\n\t\t\tnTracks = tracks.length,\n\t\t\tbindings = action._propertyBindings,\n\t\t\tinterpolants = action._interpolants,\n\t\t\trootUuid = root.uuid,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName;\n\n\t\tlet bindingsByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingsByName === undefined ) {\n\n\t\t\tbindingsByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\n\n\t\t}\n\n\t\tfor ( let i = 0; i !== nTracks; ++ i ) {\n\n\t\t\tconst track = tracks[ i ],\n\t\t\t\ttrackName = track.name;\n\n\t\t\tlet binding = bindingsByName[ trackName ];\n\n\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t} else {\n\n\t\t\t\tbinding = bindings[ i ];\n\n\t\t\t\tif ( binding !== undefined ) {\n\n\t\t\t\t\t// existing binding, make sure the cache knows\n\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\n\n\t\t\t\t\t\t++ binding.referenceCount;\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tconst path = prototypeAction && prototypeAction.\n\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\n\n\t\t\t\tbinding = new PropertyMixer(\n\t\t\t\t\tPropertyBinding.create( root, trackName, path ),\n\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\n\n\t\t\t\t++ binding.referenceCount;\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\n\n\t\t\t\tbindings[ i ] = binding;\n\n\t\t\t}\n\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\n\n\t\t}\n\n\t}\n\n\t_activateAction( action ) {\n\n\t\tif ( ! this._isActiveAction( action ) ) {\n\n\t\t\tif ( action._cacheIndex === null ) {\n\n\t\t\t\t// this action has been forgotten by the cache, but the user\n\t\t\t\t// appears to be still using it -> rebind\n\n\t\t\t\tconst rootUuid = ( action._localRoot || this._root ).uuid,\n\t\t\t\t\tclipUuid = action._clip.uuid,\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\t\t\tthis._bindAction( action,\n\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\n\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\n\n\t\t\t}\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// increment reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\n\n\t\t\t\t\tthis._lendBinding( binding );\n\t\t\t\t\tbinding.saveOriginalState();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._lendAction( action );\n\n\t\t}\n\n\t}\n\n\t_deactivateAction( action ) {\n\n\t\tif ( this._isActiveAction( action ) ) {\n\n\t\t\tconst bindings = action._propertyBindings;\n\n\t\t\t// decrement reference counts / sort out state\n\t\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\t\tconst binding = bindings[ i ];\n\n\t\t\t\tif ( -- binding.useCount === 0 ) {\n\n\t\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\t\tthis._takeBackBinding( binding );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis._takeBackAction( action );\n\n\t\t}\n\n\t}\n\n\t// Memory manager\n\n\t_initMemoryManager() {\n\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\n\t\tthis._nActiveActions = 0;\n\n\t\tthis._actionsByClip = {};\n\t\t// inside:\n\t\t// {\n\t\t// \tknownActions: Array< AnimationAction > - used as prototypes\n\t\t// \tactionByRoot: AnimationAction - lookup\n\t\t// }\n\n\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\n\t\tthis._nActiveBindings = 0;\n\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\n\n\n\t\tthis._controlInterpolants = []; // same game as above\n\t\tthis._nActiveControlInterpolants = 0;\n\n\t\tconst scope = this;\n\n\t\tthis.stats = {\n\n\t\t\tactions: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._actions.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveActions;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tbindings: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._bindings.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveBindings;\n\n\t\t\t\t}\n\t\t\t},\n\t\t\tcontrolInterpolants: {\n\t\t\t\tget total() {\n\n\t\t\t\t\treturn scope._controlInterpolants.length;\n\n\t\t\t\t},\n\t\t\t\tget inUse() {\n\n\t\t\t\t\treturn scope._nActiveControlInterpolants;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t// Memory management for AnimationAction objects\n\n\t_isActiveAction( action ) {\n\n\t\tconst index = action._cacheIndex;\n\t\treturn index !== null && index < this._nActiveActions;\n\n\t}\n\n\t_addInactiveAction( action, clipUuid, rootUuid ) {\n\n\t\tconst actions = this._actions,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tlet actionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip === undefined ) {\n\n\t\t\tactionsForClip = {\n\n\t\t\t\tknownActions: [ action ],\n\t\t\t\tactionByRoot: {}\n\n\t\t\t};\n\n\t\t\taction._byClipCacheIndex = 0;\n\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\n\n\t\t} else {\n\n\t\t\tconst knownActions = actionsForClip.knownActions;\n\n\t\t\taction._byClipCacheIndex = knownActions.length;\n\t\t\tknownActions.push( action );\n\n\t\t}\n\n\t\taction._cacheIndex = actions.length;\n\t\tactions.push( action );\n\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\n\n\t}\n\n\t_removeInactiveAction( action ) {\n\n\t\tconst actions = this._actions,\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\n\t\t\tcacheIndex = action._cacheIndex;\n\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\tactions.pop();\n\n\t\taction._cacheIndex = null;\n\n\n\t\tconst clipUuid = action._clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\n\n\t\t\tlastKnownAction =\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\n\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\n\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\n\t\tknownActionsForClip.pop();\n\n\t\taction._byClipCacheIndex = null;\n\n\n\t\tconst actionByRoot = actionsForClip.actionByRoot,\n\t\t\trootUuid = ( action._localRoot || this._root ).uuid;\n\n\t\tdelete actionByRoot[ rootUuid ];\n\n\t\tif ( knownActionsForClip.length === 0 ) {\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t\tthis._removeInactiveBindingsForAction( action );\n\n\t}\n\n\t_removeInactiveBindingsForAction( action ) {\n\n\t\tconst bindings = action._propertyBindings;\n\n\t\tfor ( let i = 0, n = bindings.length; i !== n; ++ i ) {\n\n\t\t\tconst binding = bindings[ i ];\n\n\t\t\tif ( -- binding.referenceCount === 0 ) {\n\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_lendAction( action ) {\n\n\t\t// [ active actions |  inactive actions  ]\n\t\t// [  active actions >| inactive actions ]\n\t\t//                 s        a\n\t\t//                  <-swap->\n\t\t//                 a        s\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveActions ++,\n\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\n\n\t\taction._cacheIndex = lastActiveIndex;\n\t\tactions[ lastActiveIndex ] = action;\n\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = firstInactiveAction;\n\n\t}\n\n\t_takeBackAction( action ) {\n\n\t\t// [  active actions  | inactive actions ]\n\t\t// [ active actions |< inactive actions  ]\n\t\t//        a        s\n\t\t//         <-swap->\n\t\t//        s        a\n\n\t\tconst actions = this._actions,\n\t\t\tprevIndex = action._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\n\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\n\n\t\taction._cacheIndex = firstInactiveIndex;\n\t\tactions[ firstInactiveIndex ] = action;\n\n\t\tlastActiveAction._cacheIndex = prevIndex;\n\t\tactions[ prevIndex ] = lastActiveAction;\n\n\t}\n\n\t// Memory management for PropertyMixer objects\n\n\t_addInactiveBinding( binding, rootUuid, trackName ) {\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindings = this._bindings;\n\n\t\tlet bindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName === undefined ) {\n\n\t\t\tbindingByName = {};\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\n\n\t\t}\n\n\t\tbindingByName[ trackName ] = binding;\n\n\t\tbinding._cacheIndex = bindings.length;\n\t\tbindings.push( binding );\n\n\t}\n\n\t_removeInactiveBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tpropBinding = binding.binding,\n\t\t\trootUuid = propBinding.rootNode.uuid,\n\t\t\ttrackName = propBinding.path,\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\n\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\n\t\t\tcacheIndex = binding._cacheIndex;\n\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\n\t\tbindings.pop();\n\n\t\tdelete bindingByName[ trackName ];\n\n\t\tif ( Object.keys( bindingByName ).length === 0 ) {\n\n\t\t\tdelete bindingsByRoot[ rootUuid ];\n\n\t\t}\n\n\t}\n\n\t_lendBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\n\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\n\n\t\tbinding._cacheIndex = lastActiveIndex;\n\t\tbindings[ lastActiveIndex ] = binding;\n\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\n\n\t}\n\n\t_takeBackBinding( binding ) {\n\n\t\tconst bindings = this._bindings,\n\t\t\tprevIndex = binding._cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\n\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\n\n\t\tbinding._cacheIndex = firstInactiveIndex;\n\t\tbindings[ firstInactiveIndex ] = binding;\n\n\t\tlastActiveBinding._cacheIndex = prevIndex;\n\t\tbindings[ prevIndex ] = lastActiveBinding;\n\n\t}\n\n\n\t// Memory management of Interpolants for weight and time scale\n\n\t_lendControlInterpolant() {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++;\n\n\t\tlet interpolant = interpolants[ lastActiveIndex ];\n\n\t\tif ( interpolant === undefined ) {\n\n\t\t\tinterpolant = new LinearInterpolant(\n\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\n\t\t\t\t1, _controlInterpolantsResultBuffer );\n\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\n\n\t\t}\n\n\t\treturn interpolant;\n\n\t}\n\n\t_takeBackControlInterpolant( interpolant ) {\n\n\t\tconst interpolants = this._controlInterpolants,\n\t\t\tprevIndex = interpolant.__cacheIndex,\n\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\n\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\n\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\n\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\n\n\t}\n\n\t// return an action for a clip optionally using a custom root target\n\t// object (this method allocates a lot of dynamic memory in case a\n\t// previously unknown clip/root combination is specified)\n\tclipAction( clip, optionalRoot, blendMode ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid;\n\n\t\tlet clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;\n\n\t\tconst clipUuid = clipObject !== null ? clipObject.uuid : clip;\n\n\t\tconst actionsForClip = this._actionsByClip[ clipUuid ];\n\t\tlet prototypeAction = null;\n\n\t\tif ( blendMode === undefined ) {\n\n\t\t\tif ( clipObject !== null ) {\n\n\t\t\t\tblendMode = clipObject.blendMode;\n\n\t\t\t} else {\n\n\t\t\t\tblendMode = NormalAnimationBlendMode;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\tconst existingAction = actionsForClip.actionByRoot[ rootUuid ];\n\n\t\t\tif ( existingAction !== undefined && existingAction.blendMode === blendMode ) {\n\n\t\t\t\treturn existingAction;\n\n\t\t\t}\n\n\t\t\t// we know the clip, so we don't have to parse all\n\t\t\t// the bindings again but can just copy\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\n\n\t\t\t// also, take the clip from the prototype action\n\t\t\tif ( clipObject === null )\n\t\t\t\tclipObject = prototypeAction._clip;\n\n\t\t}\n\n\t\t// clip must be known when specified via string\n\t\tif ( clipObject === null ) return null;\n\n\t\t// allocate all resources required to run it\n\t\tconst newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );\n\n\t\tthis._bindAction( newAction, prototypeAction );\n\n\t\t// and make the action known to the memory manager\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\n\n\t\treturn newAction;\n\n\t}\n\n\t// get an existing action\n\texistingAction( clip, optionalRoot ) {\n\n\t\tconst root = optionalRoot || this._root,\n\t\t\trootUuid = root.uuid,\n\n\t\t\tclipObject = typeof clip === 'string' ?\n\t\t\t\tAnimationClip.findByName( root, clip ) : clip,\n\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\n\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t// deactivates all previously scheduled actions\n\tstopAllAction() {\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions;\n\n\t\tfor ( let i = nActions - 1; i >= 0; -- i ) {\n\n\t\t\tactions[ i ].stop();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// advance the time and update apply the animation\n\tupdate( deltaTime ) {\n\n\t\tdeltaTime *= this.timeScale;\n\n\t\tconst actions = this._actions,\n\t\t\tnActions = this._nActiveActions,\n\n\t\t\ttime = this.time += deltaTime,\n\t\t\ttimeDirection = Math.sign( deltaTime ),\n\n\t\t\taccuIndex = this._accuIndex ^= 1;\n\n\t\t// run active actions\n\n\t\tfor ( let i = 0; i !== nActions; ++ i ) {\n\n\t\t\tconst action = actions[ i ];\n\n\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\n\n\t\t}\n\n\t\t// update scene graph\n\n\t\tconst bindings = this._bindings,\n\t\t\tnBindings = this._nActiveBindings;\n\n\t\tfor ( let i = 0; i !== nBindings; ++ i ) {\n\n\t\t\tbindings[ i ].apply( accuIndex );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Allows you to seek to a specific time in an animation.\n\tsetTime( timeInSeconds ) {\n\n\t\tthis.time = 0; // Zero out time attribute for AnimationMixer object;\n\t\tfor ( let i = 0; i < this._actions.length; i ++ ) {\n\n\t\t\tthis._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.\n\n\t\t}\n\n\t\treturn this.update( timeInSeconds ); // Update used to set exact time. Returns \"this\" AnimationMixer object.\n\n\t}\n\n\t// return this mixer's root target object\n\tgetRoot() {\n\n\t\treturn this._root;\n\n\t}\n\n\t// free all resources specific to a particular clip\n\tuncacheClip( clip ) {\n\n\t\tconst actions = this._actions,\n\t\t\tclipUuid = clip.uuid,\n\t\t\tactionsByClip = this._actionsByClip,\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\n\n\t\tif ( actionsForClip !== undefined ) {\n\n\t\t\t// note: just calling _removeInactiveAction would mess up the\n\t\t\t// iteration state and also require updating the state we can\n\t\t\t// just throw away\n\n\t\t\tconst actionsToRemove = actionsForClip.knownActions;\n\n\t\t\tfor ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\n\n\t\t\t\tconst action = actionsToRemove[ i ];\n\n\t\t\t\tthis._deactivateAction( action );\n\n\t\t\t\tconst cacheIndex = action._cacheIndex,\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\n\n\t\t\t\taction._cacheIndex = null;\n\t\t\t\taction._byClipCacheIndex = null;\n\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\n\t\t\t\tactions.pop();\n\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\n\n\t\t\t}\n\n\t\t\tdelete actionsByClip[ clipUuid ];\n\n\t\t}\n\n\t}\n\n\t// free all resources specific to a particular root target object\n\tuncacheRoot( root ) {\n\n\t\tconst rootUuid = root.uuid,\n\t\t\tactionsByClip = this._actionsByClip;\n\n\t\tfor ( const clipUuid in actionsByClip ) {\n\n\t\t\tconst actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\n\t\t\t\taction = actionByRoot[ rootUuid ];\n\n\t\t\tif ( action !== undefined ) {\n\n\t\t\t\tthis._deactivateAction( action );\n\t\t\t\tthis._removeInactiveAction( action );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bindingsByRoot = this._bindingsByRootAndName,\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\n\n\t\tif ( bindingByName !== undefined ) {\n\n\t\t\tfor ( const trackName in bindingByName ) {\n\n\t\t\t\tconst binding = bindingByName[ trackName ];\n\t\t\t\tbinding.restoreOriginalState();\n\t\t\t\tthis._removeInactiveBinding( binding );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// remove a targeted clip from the cache\n\tuncacheAction( clip, optionalRoot ) {\n\n\t\tconst action = this.existingAction( clip, optionalRoot );\n\n\t\tif ( action !== null ) {\n\n\t\t\tthis._deactivateAction( action );\n\t\t\tthis._removeInactiveAction( action );\n\n\t\t}\n\n\t}\n\n}\n\nclass Uniform {\n\n\tconstructor( value ) {\n\n\t\tthis.value = value;\n\n\t}\n\n\tclone() {\n\n\t\treturn new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );\n\n\t}\n\n}\n\nlet id = 0;\n\nclass UniformsGroup extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.isUniformsGroup = true;\n\n\t\tObject.defineProperty( this, 'id', { value: id ++ } );\n\n\t\tthis.name = '';\n\n\t\tthis.usage = StaticDrawUsage;\n\t\tthis.uniforms = [];\n\n\t}\n\n\tadd( uniform ) {\n\n\t\tthis.uniforms.push( uniform );\n\n\t\treturn this;\n\n\t}\n\n\tremove( uniform ) {\n\n\t\tconst index = this.uniforms.indexOf( uniform );\n\n\t\tif ( index !== - 1 ) this.uniforms.splice( index, 1 );\n\n\t\treturn this;\n\n\t}\n\n\tsetName( name ) {\n\n\t\tthis.name = name;\n\n\t\treturn this;\n\n\t}\n\n\tsetUsage( value ) {\n\n\t\tthis.usage = value;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.name = source.name;\n\t\tthis.usage = source.usage;\n\n\t\tconst uniformsSource = source.uniforms;\n\n\t\tthis.uniforms.length = 0;\n\n\t\tfor ( let i = 0, l = uniformsSource.length; i < l; i ++ ) {\n\n\t\t\tthis.uniforms.push( uniformsSource[ i ].clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nclass InstancedInterleavedBuffer extends InterleavedBuffer {\n\n\tconstructor( array, stride, meshPerAttribute = 1 ) {\n\n\t\tsuper( array, stride );\n\n\t\tthis.isInstancedInterleavedBuffer = true;\n\n\t\tthis.meshPerAttribute = meshPerAttribute;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\n\n\t\treturn this;\n\n\t}\n\n\tclone( data ) {\n\n\t\tconst ib = super.clone( data );\n\n\t\tib.meshPerAttribute = this.meshPerAttribute;\n\n\t\treturn ib;\n\n\t}\n\n\ttoJSON( data ) {\n\n\t\tconst json = super.toJSON( data );\n\n\t\tjson.isInstancedInterleavedBuffer = true;\n\t\tjson.meshPerAttribute = this.meshPerAttribute;\n\n\t\treturn json;\n\n\t}\n\n}\n\nclass GLBufferAttribute {\n\n\tconstructor( buffer, type, itemSize, elementSize, count ) {\n\n\t\tthis.isGLBufferAttribute = true;\n\n\t\tthis.name = '';\n\n\t\tthis.buffer = buffer;\n\t\tthis.type = type;\n\t\tthis.itemSize = itemSize;\n\t\tthis.elementSize = elementSize;\n\t\tthis.count = count;\n\n\t\tthis.version = 0;\n\n\t}\n\n\tset needsUpdate( value ) {\n\n\t\tif ( value === true ) this.version ++;\n\n\t}\n\n\tsetBuffer( buffer ) {\n\n\t\tthis.buffer = buffer;\n\n\t\treturn this;\n\n\t}\n\n\tsetType( type, elementSize ) {\n\n\t\tthis.type = type;\n\t\tthis.elementSize = elementSize;\n\n\t\treturn this;\n\n\t}\n\n\tsetItemSize( itemSize ) {\n\n\t\tthis.itemSize = itemSize;\n\n\t\treturn this;\n\n\t}\n\n\tsetCount( count ) {\n\n\t\tthis.count = count;\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Raycaster {\n\n\tconstructor( origin, direction, near = 0, far = Infinity ) {\n\n\t\tthis.ray = new Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\t\tthis.camera = null;\n\t\tthis.layers = new Layers();\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: { threshold: 1 },\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t}\n\n\tset( origin, direction ) {\n\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.ray.set( origin, direction );\n\n\t}\n\n\tsetFromCamera( coords, camera ) {\n\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\t\t\tthis.camera = camera;\n\n\t\t} else if ( camera.isOrthographicCamera ) {\n\n\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\tthis.camera = camera;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );\n\n\t\t}\n\n\t}\n\n\tintersectObject( object, recursive = true, intersects = [] ) {\n\n\t\tintersectObject( object, this, intersects, recursive );\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n\tintersectObjects( objects, recursive = true, intersects = [] ) {\n\n\t\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t}\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n}\n\nfunction ascSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\tif ( object.layers.test( raycaster.layers ) ) {\n\n\t\tobject.raycast( raycaster, intersects );\n\n\t}\n\n\tif ( recursive === true ) {\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\n *\n * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.\n * The azimuthal angle (theta) is measured from the positive z-axis.\n */\n\n\nclass Spherical {\n\n\tconstructor( radius = 1, phi = 0, theta = 0 ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi; // polar angle\n\t\tthis.theta = theta; // azimuthal angle\n\n\t\treturn this;\n\n\t}\n\n\tset( radius, phi, theta ) {\n\n\t\tthis.radius = radius;\n\t\tthis.phi = phi;\n\t\tthis.theta = theta;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.phi = other.phi;\n\t\tthis.theta = other.theta;\n\n\t\treturn this;\n\n\t}\n\n\t// restrict phi to be between EPS and PI-EPS\n\tmakeSafe() {\n\n\t\tconst EPS = 0.000001;\n\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t}\n\n\tsetFromCartesianCoords( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + y * y + z * z );\n\n\t\tif ( this.radius === 0 ) {\n\n\t\t\tthis.theta = 0;\n\t\t\tthis.phi = 0;\n\n\t\t} else {\n\n\t\t\tthis.theta = Math.atan2( x, z );\n\t\t\tthis.phi = Math.acos( clamp( y / this.radius, - 1, 1 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\n/**\n * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\n */\n\nclass Cylindrical {\n\n\tconstructor( radius = 1, theta = 0, y = 0 ) {\n\n\t\tthis.radius = radius; // distance from the origin to a point in the x-z plane\n\t\tthis.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\n\t\tthis.y = y; // height above the x-z plane\n\n\t\treturn this;\n\n\t}\n\n\tset( radius, theta, y ) {\n\n\t\tthis.radius = radius;\n\t\tthis.theta = theta;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.radius = other.radius;\n\t\tthis.theta = other.theta;\n\t\tthis.y = other.y;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromVector3( v ) {\n\n\t\treturn this.setFromCartesianCoords( v.x, v.y, v.z );\n\n\t}\n\n\tsetFromCartesianCoords( x, y, z ) {\n\n\t\tthis.radius = Math.sqrt( x * x + z * z );\n\t\tthis.theta = Math.atan2( x, z );\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _vector$4 = /*@__PURE__*/ new Vector2();\n\nclass Box2 {\n\n\tconstructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {\n\n\t\tthis.isBox2 = true;\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector$4.copy( size ).multiplyScalar( 0.5 );\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = + Infinity;\n\t\tthis.max.x = this.max.y = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\tgetSize( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ? false : true;\n\n\t}\n\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y;\n\n\t}\n\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t);\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\t// using 4 splitting planes to rule out intersections\n\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ? false : true;\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.clampPoint( point, _vector$4 ).distanceTo( point );\n\n\t}\n\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t}\n\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n}\n\nconst _startP = /*@__PURE__*/ new Vector3();\nconst _startEnd = /*@__PURE__*/ new Vector3();\n\nclass Line3 {\n\n\tconstructor( start = new Vector3(), end = new Vector3() ) {\n\n\t\tthis.start = start;\n\t\tthis.end = end;\n\n\t}\n\n\tset( start, end ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( line ) {\n\n\t\tthis.start.copy( line.start );\n\t\tthis.end.copy( line.end );\n\n\t\treturn this;\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t}\n\n\tdelta( target ) {\n\n\t\treturn target.subVectors( this.end, this.start );\n\n\t}\n\n\tdistanceSq() {\n\n\t\treturn this.start.distanceToSquared( this.end );\n\n\t}\n\n\tdistance() {\n\n\t\treturn this.start.distanceTo( this.end );\n\n\t}\n\n\tat( t, target ) {\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t}\n\n\tclosestPointToPointParameter( point, clampToLine ) {\n\n\t\t_startP.subVectors( point, this.start );\n\t\t_startEnd.subVectors( this.end, this.start );\n\n\t\tconst startEnd2 = _startEnd.dot( _startEnd );\n\t\tconst startEnd_startP = _startEnd.dot( _startP );\n\n\t\tlet t = startEnd_startP / startEnd2;\n\n\t\tif ( clampToLine ) {\n\n\t\t\tt = clamp( t, 0, 1 );\n\n\t\t}\n\n\t\treturn t;\n\n\t}\n\n\tclosestPointToPoint( point, clampToLine, target ) {\n\n\t\tconst t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\treturn this.delta( target ).multiplyScalar( t ).add( this.start );\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.start.applyMatrix4( matrix );\n\t\tthis.end.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t}\n\n\tequals( line ) {\n\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nconst _vector$3 = /*@__PURE__*/ new Vector3();\n\nclass SpotLightHelper extends Object3D {\n\n\tconstructor( light, color ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'SpotLightHelper';\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst positions = [\n\t\t\t0, 0, 0, \t0, 0, 1,\n\t\t\t0, 0, 0, \t1, 0, 1,\n\t\t\t0, 0, 0,\t- 1, 0, 1,\n\t\t\t0, 0, 0, \t0, 1, 1,\n\t\t\t0, 0, 0, \t0, - 1, 1\n\t\t];\n\n\t\tfor ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\n\n\t\t\tconst p1 = ( i / l ) * Math.PI * 2;\n\t\t\tconst p2 = ( j / l ) * Math.PI * 2;\n\n\t\t\tpositions.push(\n\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\n\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\n\t\t\t);\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { fog: false, toneMapped: false } );\n\n\t\tthis.cone = new LineSegments( geometry, material );\n\t\tthis.add( this.cone );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\t\tthis.light.target.updateWorldMatrix( true, false );\n\n\t\tconst coneLength = this.light.distance ? this.light.distance : 1000;\n\t\tconst coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\t_vector$3.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\tthis.cone.lookAt( _vector$3 );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.cone.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.cone.material.color.copy( this.light.color );\n\n\t\t}\n\n\t}\n\n}\n\nconst _vector$2 = /*@__PURE__*/ new Vector3();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\nconst _matrixWorldInv = /*@__PURE__*/ new Matrix4();\n\n\nclass SkeletonHelper extends LineSegments {\n\n\tconstructor( object ) {\n\n\t\tconst bones = getBoneList( object );\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\tconst color1 = new Color( 0, 0, 1 );\n\t\tconst color2 = new Color( 0, 1, 0 );\n\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tcolors.push( color1.r, color1.g, color1.b );\n\t\t\t\tcolors.push( color2.r, color2.g, color2.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.isSkeletonHelper = true;\n\n\t\tthis.type = 'SkeletonHelper';\n\n\t\tthis.root = object;\n\t\tthis.bones = bones;\n\n\t\tthis.matrix = object.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tconst bones = this.bones;\n\n\t\tconst geometry = this.geometry;\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t_matrixWorldInv.copy( this.root.matrixWorld ).invert();\n\n\t\tfor ( let i = 0, j = 0; i < bones.length; i ++ ) {\n\n\t\t\tconst bone = bones[ i ];\n\n\t\t\tif ( bone.parent && bone.parent.isBone ) {\n\n\t\t\t\t_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );\n\t\t\t\t_vector$2.setFromMatrixPosition( _boneMatrix );\n\t\t\t\tposition.setXYZ( j, _vector$2.x, _vector$2.y, _vector$2.z );\n\n\t\t\t\t_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );\n\t\t\t\t_vector$2.setFromMatrixPosition( _boneMatrix );\n\t\t\t\tposition.setXYZ( j + 1, _vector$2.x, _vector$2.y, _vector$2.z );\n\n\t\t\t\tj += 2;\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\n\nfunction getBoneList( object ) {\n\n\tconst boneList = [];\n\n\tif ( object.isBone === true ) {\n\n\t\tboneList.push( object );\n\n\t}\n\n\tfor ( let i = 0; i < object.children.length; i ++ ) {\n\n\t\tboneList.push.apply( boneList, getBoneList( object.children[ i ] ) );\n\n\t}\n\n\treturn boneList;\n\n}\n\nclass PointLightHelper extends Mesh {\n\n\tconstructor( light, sphereSize, color ) {\n\n\t\tconst geometry = new SphereGeometry( sphereSize, 4, 2 );\n\t\tconst material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.light = light;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'PointLightHelper';\n\n\t\tthis.matrix = this.light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\n\t\t/*\n\t// TODO: delete this comment?\n\tconst distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\tconst distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tconst d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightDistance );\n\t*/\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\t/*\n\t\tconst d = this.light.distance;\n\n\t\tif ( d === 0.0 ) {\n\n\t\t\tthis.lightDistance.visible = false;\n\n\t\t} else {\n\n\t\t\tthis.lightDistance.visible = true;\n\t\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t\t}\n\t\t*/\n\n\t}\n\n}\n\nconst _vector$1 = /*@__PURE__*/ new Vector3();\nconst _color1 = /*@__PURE__*/ new Color();\nconst _color2 = /*@__PURE__*/ new Color();\n\nclass HemisphereLightHelper extends Object3D {\n\n\tconstructor( light, size, color ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'HemisphereLightHelper';\n\n\t\tconst geometry = new OctahedronGeometry( size );\n\t\tgeometry.rotateY( Math.PI * 0.5 );\n\n\t\tthis.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );\n\t\tif ( this.color === undefined ) this.material.vertexColors = true;\n\n\t\tconst position = geometry.getAttribute( 'position' );\n\t\tconst colors = new Float32Array( position.count * 3 );\n\n\t\tgeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );\n\n\t\tthis.add( new Mesh( geometry, this.material ) );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.children[ 0 ].geometry.dispose();\n\t\tthis.children[ 0 ].material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.children[ 0 ];\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tconst colors = mesh.geometry.getAttribute( 'color' );\n\n\t\t\t_color1.copy( this.light.color );\n\t\t\t_color2.copy( this.light.groundColor );\n\n\t\t\tfor ( let i = 0, l = colors.count; i < l; i ++ ) {\n\n\t\t\t\tconst color = ( i < ( l / 2 ) ) ? _color1 : _color2;\n\n\t\t\t\tcolors.setXYZ( i, color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t\tcolors.needsUpdate = true;\n\n\t\t}\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\n\t\tmesh.lookAt( _vector$1.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\n\t}\n\n}\n\nclass GridHelper extends LineSegments {\n\n\tconstructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {\n\n\t\tcolor1 = new Color( color1 );\n\t\tcolor2 = new Color( color2 );\n\n\t\tconst center = divisions / 2;\n\t\tconst step = size / divisions;\n\t\tconst halfSize = size / 2;\n\n\t\tconst vertices = [], colors = [];\n\n\t\tfor ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {\n\n\t\t\tvertices.push( - halfSize, 0, k, halfSize, 0, k );\n\t\t\tvertices.push( k, 0, - halfSize, k, 0, halfSize );\n\n\t\t\tconst color = i === center ? color1 : color2;\n\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\t\t\tcolor.toArray( colors, j ); j += 3;\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'GridHelper';\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass PolarGridHelper extends LineSegments {\n\n\tconstructor( radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {\n\n\t\tcolor1 = new Color( color1 );\n\t\tcolor2 = new Color( color2 );\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\t// create the sectors\n\n\t\tif ( sectors > 1 ) {\n\n\t\t\tfor ( let i = 0; i < sectors; i ++ ) {\n\n\t\t\t\tconst v = ( i / sectors ) * ( Math.PI * 2 );\n\n\t\t\t\tconst x = Math.sin( v ) * radius;\n\t\t\t\tconst z = Math.cos( v ) * radius;\n\n\t\t\t\tvertices.push( 0, 0, 0 );\n\t\t\t\tvertices.push( x, 0, z );\n\n\t\t\t\tconst color = ( i & 1 ) ? color1 : color2;\n\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// create the rings\n\n\t\tfor ( let i = 0; i < rings; i ++ ) {\n\n\t\t\tconst color = ( i & 1 ) ? color1 : color2;\n\n\t\t\tconst r = radius - ( radius / rings * i );\n\n\t\t\tfor ( let j = 0; j < divisions; j ++ ) {\n\n\t\t\t\t// first vertex\n\n\t\t\t\tlet v = ( j / divisions ) * ( Math.PI * 2 );\n\n\t\t\t\tlet x = Math.sin( v ) * r;\n\t\t\t\tlet z = Math.cos( v ) * r;\n\n\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t\t// second vertex\n\n\t\t\t\tv = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );\n\n\t\t\t\tx = Math.sin( v ) * r;\n\t\t\t\tz = Math.cos( v ) * r;\n\n\t\t\t\tvertices.push( x, 0, z );\n\t\t\t\tcolors.push( color.r, color.g, color.b );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'PolarGridHelper';\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _v2 = /*@__PURE__*/ new Vector3();\nconst _v3 = /*@__PURE__*/ new Vector3();\n\nclass DirectionalLightHelper extends Object3D {\n\n\tconstructor( light, size, color ) {\n\n\t\tsuper();\n\n\t\tthis.light = light;\n\n\t\tthis.matrix = light.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.color = color;\n\n\t\tthis.type = 'DirectionalLightHelper';\n\n\t\tif ( size === undefined ) size = 1;\n\n\t\tlet geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [\n\t\t\t- size, size, 0,\n\t\t\tsize, size, 0,\n\t\t\tsize, - size, 0,\n\t\t\t- size, - size, 0,\n\t\t\t- size, size, 0\n\t\t], 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { fog: false, toneMapped: false } );\n\n\t\tthis.lightPlane = new Line( geometry, material );\n\t\tthis.add( this.lightPlane );\n\n\t\tgeometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\n\n\t\tthis.targetLine = new Line( geometry, material );\n\t\tthis.add( this.targetLine );\n\n\t\tthis.update();\n\n\t}\n\n\tdispose() {\n\n\t\tthis.lightPlane.geometry.dispose();\n\t\tthis.lightPlane.material.dispose();\n\t\tthis.targetLine.geometry.dispose();\n\t\tthis.targetLine.material.dispose();\n\n\t}\n\n\tupdate() {\n\n\t\tthis.light.updateWorldMatrix( true, false );\n\t\tthis.light.target.updateWorldMatrix( true, false );\n\n\t\t_v1.setFromMatrixPosition( this.light.matrixWorld );\n\t\t_v2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\t_v3.subVectors( _v2, _v1 );\n\n\t\tthis.lightPlane.lookAt( _v2 );\n\n\t\tif ( this.color !== undefined ) {\n\n\t\t\tthis.lightPlane.material.color.set( this.color );\n\t\t\tthis.targetLine.material.color.set( this.color );\n\n\t\t} else {\n\n\t\t\tthis.lightPlane.material.color.copy( this.light.color );\n\t\t\tthis.targetLine.material.color.copy( this.light.color );\n\n\t\t}\n\n\t\tthis.targetLine.lookAt( _v2 );\n\t\tthis.targetLine.scale.z = _v3.length();\n\n\t}\n\n}\n\nconst _vector = /*@__PURE__*/ new Vector3();\nconst _camera = /*@__PURE__*/ new Camera();\n\n/**\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttps://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html\n */\n\nclass CameraHelper extends LineSegments {\n\n\tconstructor( camera ) {\n\n\t\tconst geometry = new BufferGeometry();\n\t\tconst material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );\n\n\t\tconst vertices = [];\n\t\tconst colors = [];\n\n\t\tconst pointMap = {};\n\n\t\t// near\n\n\t\taddLine( 'n1', 'n2' );\n\t\taddLine( 'n2', 'n4' );\n\t\taddLine( 'n4', 'n3' );\n\t\taddLine( 'n3', 'n1' );\n\n\t\t// far\n\n\t\taddLine( 'f1', 'f2' );\n\t\taddLine( 'f2', 'f4' );\n\t\taddLine( 'f4', 'f3' );\n\t\taddLine( 'f3', 'f1' );\n\n\t\t// sides\n\n\t\taddLine( 'n1', 'f1' );\n\t\taddLine( 'n2', 'f2' );\n\t\taddLine( 'n3', 'f3' );\n\t\taddLine( 'n4', 'f4' );\n\n\t\t// cone\n\n\t\taddLine( 'p', 'n1' );\n\t\taddLine( 'p', 'n2' );\n\t\taddLine( 'p', 'n3' );\n\t\taddLine( 'p', 'n4' );\n\n\t\t// up\n\n\t\taddLine( 'u1', 'u2' );\n\t\taddLine( 'u2', 'u3' );\n\t\taddLine( 'u3', 'u1' );\n\n\t\t// target\n\n\t\taddLine( 'c', 't' );\n\t\taddLine( 'p', 'c' );\n\n\t\t// cross\n\n\t\taddLine( 'cn1', 'cn2' );\n\t\taddLine( 'cn3', 'cn4' );\n\n\t\taddLine( 'cf1', 'cf2' );\n\t\taddLine( 'cf3', 'cf4' );\n\n\t\tfunction addLine( a, b ) {\n\n\t\t\taddPoint( a );\n\t\t\taddPoint( b );\n\n\t\t}\n\n\t\tfunction addPoint( id ) {\n\n\t\t\tvertices.push( 0, 0, 0 );\n\t\t\tcolors.push( 0, 0, 0 );\n\n\t\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\t\tpointMap[ id ] = [];\n\n\t\t\t}\n\n\t\t\tpointMap[ id ].push( ( vertices.length / 3 ) - 1 );\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'CameraHelper';\n\n\t\tthis.camera = camera;\n\t\tif ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\n\n\t\tthis.matrix = camera.matrixWorld;\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.pointMap = pointMap;\n\n\t\tthis.update();\n\n\t\t// colors\n\n\t\tconst colorFrustum = new Color( 0xffaa00 );\n\t\tconst colorCone = new Color( 0xff0000 );\n\t\tconst colorUp = new Color( 0x00aaff );\n\t\tconst colorTarget = new Color( 0xffffff );\n\t\tconst colorCross = new Color( 0x333333 );\n\n\t\tthis.setColors( colorFrustum, colorCone, colorUp, colorTarget, colorCross );\n\n\t}\n\n\tsetColors( frustum, cone, up, target, cross ) {\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst colorAttribute = geometry.getAttribute( 'color' );\n\n\t\t// near\n\n\t\tcolorAttribute.setXYZ( 0, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 1, frustum.r, frustum.g, frustum.b ); // n1, n2\n\t\tcolorAttribute.setXYZ( 2, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 3, frustum.r, frustum.g, frustum.b ); // n2, n4\n\t\tcolorAttribute.setXYZ( 4, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 5, frustum.r, frustum.g, frustum.b ); // n4, n3\n\t\tcolorAttribute.setXYZ( 6, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 7, frustum.r, frustum.g, frustum.b ); // n3, n1\n\n\t\t// far\n\n\t\tcolorAttribute.setXYZ( 8, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 9, frustum.r, frustum.g, frustum.b ); // f1, f2\n\t\tcolorAttribute.setXYZ( 10, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 11, frustum.r, frustum.g, frustum.b ); // f2, f4\n\t\tcolorAttribute.setXYZ( 12, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 13, frustum.r, frustum.g, frustum.b ); // f4, f3\n\t\tcolorAttribute.setXYZ( 14, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 15, frustum.r, frustum.g, frustum.b ); // f3, f1\n\n\t\t// sides\n\n\t\tcolorAttribute.setXYZ( 16, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 17, frustum.r, frustum.g, frustum.b ); // n1, f1\n\t\tcolorAttribute.setXYZ( 18, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 19, frustum.r, frustum.g, frustum.b ); // n2, f2\n\t\tcolorAttribute.setXYZ( 20, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 21, frustum.r, frustum.g, frustum.b ); // n3, f3\n\t\tcolorAttribute.setXYZ( 22, frustum.r, frustum.g, frustum.b ); colorAttribute.setXYZ( 23, frustum.r, frustum.g, frustum.b ); // n4, f4\n\n\t\t// cone\n\n\t\tcolorAttribute.setXYZ( 24, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 25, cone.r, cone.g, cone.b ); // p, n1\n\t\tcolorAttribute.setXYZ( 26, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 27, cone.r, cone.g, cone.b ); // p, n2\n\t\tcolorAttribute.setXYZ( 28, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 29, cone.r, cone.g, cone.b ); // p, n3\n\t\tcolorAttribute.setXYZ( 30, cone.r, cone.g, cone.b ); colorAttribute.setXYZ( 31, cone.r, cone.g, cone.b ); // p, n4\n\n\t\t// up\n\n\t\tcolorAttribute.setXYZ( 32, up.r, up.g, up.b ); colorAttribute.setXYZ( 33, up.r, up.g, up.b ); // u1, u2\n\t\tcolorAttribute.setXYZ( 34, up.r, up.g, up.b ); colorAttribute.setXYZ( 35, up.r, up.g, up.b ); // u2, u3\n\t\tcolorAttribute.setXYZ( 36, up.r, up.g, up.b ); colorAttribute.setXYZ( 37, up.r, up.g, up.b ); // u3, u1\n\n\t\t// target\n\n\t\tcolorAttribute.setXYZ( 38, target.r, target.g, target.b ); colorAttribute.setXYZ( 39, target.r, target.g, target.b ); // c, t\n\t\tcolorAttribute.setXYZ( 40, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 41, cross.r, cross.g, cross.b ); // p, c\n\n\t\t// cross\n\n\t\tcolorAttribute.setXYZ( 42, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 43, cross.r, cross.g, cross.b ); // cn1, cn2\n\t\tcolorAttribute.setXYZ( 44, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 45, cross.r, cross.g, cross.b ); // cn3, cn4\n\n\t\tcolorAttribute.setXYZ( 46, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 47, cross.r, cross.g, cross.b ); // cf1, cf2\n\t\tcolorAttribute.setXYZ( 48, cross.r, cross.g, cross.b ); colorAttribute.setXYZ( 49, cross.r, cross.g, cross.b ); // cf3, cf4\n\n\t\tcolorAttribute.needsUpdate = true;\n\n\t}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst pointMap = this.pointMap;\n\n\t\tconst w = 1, h = 1;\n\n\t\t// we need just camera projection matrix inverse\n\t\t// world matrix must be identity\n\n\t\t_camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );\n\n\t\t// center / target\n\n\t\tsetPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );\n\t\tsetPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );\n\n\t\t// near\n\n\t\tsetPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );\n\t\tsetPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );\n\t\tsetPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );\n\t\tsetPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );\n\n\t\t// far\n\n\t\tsetPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );\n\t\tsetPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );\n\t\tsetPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );\n\t\tsetPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );\n\n\t\t// up\n\n\t\tsetPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );\n\t\tsetPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );\n\n\t\t// cross\n\n\t\tsetPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );\n\t\tsetPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );\n\t\tsetPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );\n\t\tsetPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );\n\n\t\tsetPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );\n\t\tsetPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );\n\t\tsetPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );\n\t\tsetPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );\n\n\t\tgeometry.getAttribute( 'position' ).needsUpdate = true;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\n\nfunction setPoint( point, pointMap, geometry, camera, x, y, z ) {\n\n\t_vector.set( x, y, z ).unproject( camera );\n\n\tconst points = pointMap[ point ];\n\n\tif ( points !== undefined ) {\n\n\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tposition.setXYZ( points[ i ], _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}\n\n}\n\nconst _box = /*@__PURE__*/ new Box3();\n\nclass BoxHelper extends LineSegments {\n\n\tconstructor( object, color = 0xffff00 ) {\n\n\t\tconst indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\t\tconst positions = new Float32Array( 8 * 3 );\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.object = object;\n\t\tthis.type = 'BoxHelper';\n\n\t\tthis.matrixAutoUpdate = false;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate( object ) {\n\n\t\tif ( object !== undefined ) {\n\n\t\t\tconsole.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );\n\n\t\t}\n\n\t\tif ( this.object !== undefined ) {\n\n\t\t\t_box.setFromObject( this.object );\n\n\t\t}\n\n\t\tif ( _box.isEmpty() ) return;\n\n\t\tconst min = _box.min;\n\t\tconst max = _box.max;\n\n\t\t/*\n\t\t\t5____4\n\t\t1/___0/|\n\t\t| 6__|_7\n\t\t2/___3/\n\n\t\t0: max.x, max.y, max.z\n\t\t1: min.x, max.y, max.z\n\t\t2: min.x, min.y, max.z\n\t\t3: max.x, min.y, max.z\n\t\t4: max.x, max.y, min.z\n\t\t5: min.x, max.y, min.z\n\t\t6: min.x, min.y, min.z\n\t\t7: max.x, min.y, min.z\n\t\t*/\n\n\t\tconst position = this.geometry.attributes.position;\n\t\tconst array = position.array;\n\n\t\tarray[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;\n\t\tarray[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;\n\t\tarray[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;\n\t\tarray[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\n\n\t\tposition.needsUpdate = true;\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t}\n\n\tsetFromObject( object ) {\n\n\t\tthis.object = object;\n\t\tthis.update();\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.object = source.object;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass Box3Helper extends LineSegments {\n\n\tconstructor( box, color = 0xffff00 ) {\n\n\t\tconst indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\n\n\t\tconst positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];\n\n\t\tconst geometry = new BufferGeometry();\n\n\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\n\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.box = box;\n\n\t\tthis.type = 'Box3Helper';\n\n\t\tthis.geometry.computeBoundingSphere();\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tconst box = this.box;\n\n\t\tif ( box.isEmpty() ) return;\n\n\t\tbox.getCenter( this.position );\n\n\t\tbox.getSize( this.scale );\n\n\t\tthis.scale.multiplyScalar( 0.5 );\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass PlaneHelper extends Line {\n\n\tconstructor( plane, size = 1, hex = 0xffff00 ) {\n\n\t\tconst color = hex;\n\n\t\tconst positions = [ 1, - 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\n\t\tgeometry.computeBoundingSphere();\n\n\t\tsuper( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\n\t\tthis.type = 'PlaneHelper';\n\n\t\tthis.plane = plane;\n\n\t\tthis.size = size;\n\n\t\tconst positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];\n\n\t\tconst geometry2 = new BufferGeometry();\n\t\tgeometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\n\t\tgeometry2.computeBoundingSphere();\n\n\t\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tthis.position.set( 0, 0, 0 );\n\n\t\tthis.scale.set( 0.5 * this.size, 0.5 * this.size, 1 );\n\n\t\tthis.lookAt( this.plane.normal );\n\n\t\tthis.translateZ( - this.plane.constant );\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\t\tthis.children[ 0 ].geometry.dispose();\n\t\tthis.children[ 0 ].material.dispose();\n\n\t}\n\n}\n\nconst _axis = /*@__PURE__*/ new Vector3();\nlet _lineGeometry, _coneGeometry;\n\nclass ArrowHelper extends Object3D {\n\n\t// dir is assumed to be normalized\n\n\tconstructor( dir = new Vector3( 0, 0, 1 ), origin = new Vector3( 0, 0, 0 ), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'ArrowHelper';\n\n\t\tif ( _lineGeometry === undefined ) {\n\n\t\t\t_lineGeometry = new BufferGeometry();\n\t\t\t_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\n\n\t\t\t_coneGeometry = new CylinderGeometry( 0, 0.5, 1, 5, 1 );\n\t\t\t_coneGeometry.translate( 0, - 0.5, 0 );\n\n\t\t}\n\n\t\tthis.position.copy( origin );\n\n\t\tthis.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );\n\t\tthis.line.matrixAutoUpdate = false;\n\t\tthis.add( this.line );\n\n\t\tthis.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );\n\t\tthis.cone.matrixAutoUpdate = false;\n\t\tthis.add( this.cone );\n\n\t\tthis.setDirection( dir );\n\t\tthis.setLength( length, headLength, headWidth );\n\n\t}\n\n\tsetDirection( dir ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\t_axis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\tconst radians = Math.acos( dir.y );\n\n\t\t\tthis.quaternion.setFromAxisAngle( _axis, radians );\n\n\t\t}\n\n\t}\n\n\tsetLength( length, headLength = length * 0.2, headWidth = headLength * 0.2 ) {\n\n\t\tthis.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458\n\t\tthis.line.updateMatrix();\n\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\t\tthis.cone.position.y = length;\n\t\tthis.cone.updateMatrix();\n\n\t}\n\n\tsetColor( color ) {\n\n\t\tthis.line.material.color.set( color );\n\t\tthis.cone.material.color.set( color );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source, false );\n\n\t\tthis.line.copy( source.line );\n\t\tthis.cone.copy( source.cone );\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.line.geometry.dispose();\n\t\tthis.line.material.dispose();\n\t\tthis.cone.geometry.dispose();\n\t\tthis.cone.material.dispose();\n\n\t}\n\n}\n\nclass AxesHelper extends LineSegments {\n\n\tconstructor( size = 1 ) {\n\n\t\tconst vertices = [\n\t\t\t0, 0, 0,\tsize, 0, 0,\n\t\t\t0, 0, 0,\t0, size, 0,\n\t\t\t0, 0, 0,\t0, 0, size\n\t\t];\n\n\t\tconst colors = [\n\t\t\t1, 0, 0,\t1, 0.6, 0,\n\t\t\t0, 1, 0,\t0.6, 1, 0,\n\t\t\t0, 0, 1,\t0, 0.6, 1\n\t\t];\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\n\n\t\tconst material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );\n\n\t\tsuper( geometry, material );\n\n\t\tthis.type = 'AxesHelper';\n\n\t}\n\n\tsetColors( xAxisColor, yAxisColor, zAxisColor ) {\n\n\t\tconst color = new Color();\n\t\tconst array = this.geometry.attributes.color.array;\n\n\t\tcolor.set( xAxisColor );\n\t\tcolor.toArray( array, 0 );\n\t\tcolor.toArray( array, 3 );\n\n\t\tcolor.set( yAxisColor );\n\t\tcolor.toArray( array, 6 );\n\t\tcolor.toArray( array, 9 );\n\n\t\tcolor.set( zAxisColor );\n\t\tcolor.toArray( array, 12 );\n\t\tcolor.toArray( array, 15 );\n\n\t\tthis.geometry.attributes.color.needsUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.geometry.dispose();\n\t\tthis.material.dispose();\n\n\t}\n\n}\n\nclass ShapePath {\n\n\tconstructor() {\n\n\t\tthis.type = 'ShapePath';\n\n\t\tthis.color = new Color();\n\n\t\tthis.subPaths = [];\n\t\tthis.currentPath = null;\n\n\t}\n\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPath = new Path();\n\t\tthis.subPaths.push( this.currentPath );\n\t\tthis.currentPath.moveTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tlineTo( x, y ) {\n\n\t\tthis.currentPath.lineTo( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tsplineThru( pts ) {\n\n\t\tthis.currentPath.splineThru( pts );\n\n\t\treturn this;\n\n\t}\n\n\ttoShapes( isCCW ) {\n\n\t\tfunction toShapesNoHoles( inSubpaths ) {\n\n\t\t\tconst shapes = [];\n\n\t\t\tfor ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {\n\n\t\t\t\tconst tmpPath = inSubpaths[ i ];\n\n\t\t\t\tconst tmpShape = new Shape();\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\n\t\t\t}\n\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\n\n\t\t\tconst polyLen = inPolygon.length;\n\n\t\t\t// inPt on polygon contour => immediate success    or\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\n\t\t\t//  with the horizontal line through inPt, left of inPt\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\n\t\t\tlet inside = false;\n\t\t\tfor ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\n\n\t\t\t\tlet edgeLowPt = inPolygon[ p ];\n\t\t\t\tlet edgeHighPt = inPolygon[ q ];\n\n\t\t\t\tlet edgeDx = edgeHighPt.x - edgeLowPt.x;\n\t\t\t\tlet edgeDy = edgeHighPt.y - edgeLowPt.y;\n\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\n\n\t\t\t\t\t// not parallel\n\t\t\t\t\tif ( edgeDy < 0 ) {\n\n\t\t\t\t\t\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\n\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\n\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconst perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// parallel or collinear\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\n\t\t\t\t\t// continue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn\tinside;\n\n\t\t}\n\n\t\tconst isClockWise = ShapeUtils.isClockWise;\n\n\t\tconst subPaths = this.subPaths;\n\t\tif ( subPaths.length === 0 ) return [];\n\n\t\tlet solid, tmpPath, tmpShape;\n\t\tconst shapes = [];\n\n\t\tif ( subPaths.length === 1 ) {\n\n\t\t\ttmpPath = subPaths[ 0 ];\n\t\t\ttmpShape = new Shape();\n\t\t\ttmpShape.curves = tmpPath.curves;\n\t\t\tshapes.push( tmpShape );\n\t\t\treturn shapes;\n\n\t\t}\n\n\t\tlet holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\n\n\t\t// console.log(\"Holes first\", holesFirst);\n\n\t\tconst betterShapeHoles = [];\n\t\tconst newShapes = [];\n\t\tlet newShapeHoles = [];\n\t\tlet mainIdx = 0;\n\t\tlet tmpPoints;\n\n\t\tnewShapes[ mainIdx ] = undefined;\n\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\tfor ( let i = 0, l = subPaths.length; i < l; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\ttmpPoints = tmpPath.getPoints();\n\t\t\tsolid = isClockWise( tmpPoints );\n\t\t\tsolid = isCCW ? ! solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\n\n\t\t\t\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\n\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t\t// only Holes? -> probably all Shapes with wrong orientation\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\n\n\n\t\tif ( newShapes.length > 1 ) {\n\n\t\t\tlet ambiguous = false;\n\t\t\tlet toChange = 0;\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\n\n\t\t\t\tconst sho = newShapeHoles[ sIdx ];\n\n\t\t\t\tfor ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {\n\n\t\t\t\t\tconst ho = sho[ hIdx ];\n\t\t\t\t\tlet hole_unassigned = true;\n\n\t\t\t\t\tfor ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\n\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\n\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange ++;\n\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\t\t\thole_unassigned = false;\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tambiguous = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( hole_unassigned ) {\n\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( toChange > 0 && ambiguous === false ) {\n\n\t\t\t\tnewShapeHoles = betterShapeHoles;\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet tmpHoles;\n\n\t\tfor ( let i = 0, il = newShapes.length; i < il; i ++ ) {\n\n\t\t\ttmpShape = newShapes[ i ].s;\n\t\t\tshapes.push( tmpShape );\n\t\t\ttmpHoles = newShapeHoles[ i ];\n\n\t\t\tfor ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\n\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//console.log(\"shape\", shapes);\n\n\t\treturn shapes;\n\n\t}\n\n}\n\nif ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {\n\n\t__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {\n\t\trevision: REVISION,\n\t} } ) );\n\n}\n\nif ( typeof window !== 'undefined' ) {\n\n\tif ( window.__THREE__ ) {\n\n\t\tconsole.warn( 'WARNING: Multiple instances of Three.js being imported.' );\n\n\t} else {\n\n\t\twindow.__THREE__ = REVISION;\n\n\t}\n\n}\n\nexport { ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveAnimationBlendMode, AdditiveBlending, AlphaFormat, AlwaysCompare, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightProbe, AnimationAction, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BackSide, BasicDepthPacking, BasicShadowMap, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasTexture, CapsuleGeometry, CatmullRomCurve3, CineonToneMapping, CircleGeometry, ClampToEdgeWrapping, Clock, Color, ColorKeyframeTrack, ColorManagement, CompressedArrayTexture, CompressedTexture, CompressedTextureLoader, ConeGeometry, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CustomToneMapping, CylinderGeometry, Cylindrical, Data3DTexture, DataArrayTexture, DataTexture, DataTextureLoader, DataUtils, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightHelper, DiscreteInterpolant, DisplayP3ColorSpace, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, EqualCompare, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeGeometry, FileLoader, Float16BufferAttribute, Float32BufferAttribute, Float64BufferAttribute, FloatType, Fog, FogExp2, FramebufferTexture, FrontSide, Frustum, GLBufferAttribute, GLSL1, GLSL3, GreaterCompare, GreaterDepth, GreaterEqualCompare, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, HemisphereLightProbe, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, KeepStencilOp, KeyframeTrack, LOD, LatheGeometry, Layers, LessCompare, LessDepth, LessEqualCompare, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LineSegments, LinearEncoding, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, Loader, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, MathUtils, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeverCompare, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, NormalAnimationBlendMode, NormalBlending, NotEqualCompare, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronGeometry, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, PMREMGenerator, Path, PerspectiveCamera, Plane, PlaneGeometry, PlaneHelper, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingGeometry, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, Scene, ShaderChunk, ShaderLib, ShaderMaterial, ShadowMaterial, Shape, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, SphereGeometry, Spherical, SphericalHarmonics3, SplineCurve, SpotLight, SpotLightHelper, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronGeometry, Texture, TextureLoader, TorusGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeGeometry, TwoPassDoubleSide, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, VideoTexture, WebGL1Renderer, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLCoordinateSystem, WebGLCubeRenderTarget, WebGLMultipleRenderTargets, WebGLRenderTarget, WebGLRenderer, WebGLUtils, WebGPUCoordinateSystem, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, _SRGBAFormat, sRGBEncoding };\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet gpuType = - 1;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\n\t\tif ( gpuType !== attribute.gpuType ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tarray.set( attributes[ i ].array, offset );\n\n\t\toffset += attributes[ i ].array.length;\n\n\t}\n\n\tconst result = new BufferAttribute( array, itemSize, normalized );\n\tif ( gpuType !== undefined ) {\n\n\t\tresult.gpuType = gpuType;\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new BufferAttribute(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\ttmpMorphAttributes[ name ] = new BufferAttribute(\n\t\t\t\tnew morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize ),\n\t\t\t\tmorphAttr.itemSize,\n\t\t\t\tmorphAttr.normalized\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst decimalShift = Math.log10( 1 / tolerance );\n\tconst shiftMultiplier = Math.pow( 10, decimalShift );\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewarray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new BufferAttribute(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new BufferAttribute(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n\n// Creates a new, non-indexed geometry with smooth normals everywhere except faces that meet at\n// an angle greater than the crease angle.\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vertors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\tconst resultGeometry = geometry.toNonIndexed();\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nfunction mergeBufferGeometries( geometries, useGroups = false ) {\n\n\tconsole.warn( 'THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries().' ); // @deprecated, r151\n\treturn mergeGeometries( geometries, useGroups );\n\n}\n\nfunction mergeBufferAttributes( attributes ) {\n\n\tconsole.warn( 'THREE.BufferGeometryUtils: mergeBufferAttributes() has been renamed to mergeAttributes().' ); // @deprecated, r151\n\treturn mergeAttributes( attributes );\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeBufferGeometries,\n\tmergeAttributes,\n\tmergeBufferAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n","import {\n\tAnimationClip,\n\tBone,\n\tBox3,\n\tBufferAttribute,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tDirectionalLight,\n\tDoubleSide,\n\tFileLoader,\n\tFrontSide,\n\tGroup,\n\tImageBitmapLoader,\n\tInstancedMesh,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tInterpolant,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tLine,\n\tLineBasicMaterial,\n\tLineLoop,\n\tLineSegments,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tLoader,\n\tLoaderUtils,\n\tMaterial,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tMeshBasicMaterial,\n\tMeshPhysicalMaterial,\n\tMeshStandardMaterial,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tNumberKeyframeTrack,\n\tObject3D,\n\tOrthographicCamera,\n\tPerspectiveCamera,\n\tPointLight,\n\tPoints,\n\tPointsMaterial,\n\tPropertyBinding,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tRepeatWrapping,\n\tSkeleton,\n\tSkinnedMesh,\n\tSphere,\n\tSpotLight,\n\tTexture,\n\tTextureLoader,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack,\n\tSRGBColorSpace\n} from 'three';\nimport { toTrianglesDrawMode } from '../utils/BufferGeometryUtils.js';\n\nclass GLTFLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.dracoLoader = null;\n\t\tthis.ktx2Loader = null;\n\t\tthis.meshoptDecoder = null;\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureBasisUExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureWebPExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureAVIFExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSheenExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsIorExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsEmissiveStrengthExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSpecularExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsIridescenceExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsAnisotropyExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFLightsExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshoptCompression( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshGpuInstancing( parser );\n\n\t\t} );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet resourcePath;\n\n\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\tresourcePath = this.resourcePath;\n\n\t\t} else if ( this.path !== '' ) {\n\n\t\t\tresourcePath = this.path;\n\n\t\t} else {\n\n\t\t\tresourcePath = LoaderUtils.extractUrlBase( url );\n\n\t\t}\n\n\t\t// Tells the LoadingManager to track an extra item, which resolves after\n\t\t// the model is fully loaded. This means the count of items loaded will\n\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\n\t\tthis.manager.itemStart( url );\n\n\t\tconst _onError = function ( e ) {\n\n\t\t\tif ( onError ) {\n\n\t\t\t\tonError( e );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t};\n\n\t\tconst loader = new FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\n\n\t\t\t\t\tonLoad( gltf );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, _onError );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\t_onError( e );\n\n\t\t\t}\n\n\t\t}, onProgress, _onError );\n\n\t}\n\n\tsetDRACOLoader( dracoLoader ) {\n\n\t\tthis.dracoLoader = dracoLoader;\n\t\treturn this;\n\n\t}\n\n\tsetDDSLoader() {\n\n\t\tthrow new Error(\n\n\t\t\t'THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".'\n\n\t\t);\n\n\t}\n\n\tsetKTX2Loader( ktx2Loader ) {\n\n\t\tthis.ktx2Loader = ktx2Loader;\n\t\treturn this;\n\n\t}\n\n\tsetMeshoptDecoder( meshoptDecoder ) {\n\n\t\tthis.meshoptDecoder = meshoptDecoder;\n\t\treturn this;\n\n\t}\n\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tparse( data, path, onLoad, onError ) {\n\n\t\tlet json;\n\t\tconst extensions = {};\n\t\tconst plugins = {};\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tif ( typeof data === 'string' ) {\n\n\t\t\tjson = JSON.parse( data );\n\n\t\t} else if ( data instanceof ArrayBuffer ) {\n\n\t\t\tconst magic = textDecoder.decode( new Uint8Array( data, 0, 4 ) );\n\n\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tjson = JSON.parse( extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content );\n\n\t\t\t} else {\n\n\t\t\t\tjson = JSON.parse( textDecoder.decode( data ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tjson = data;\n\n\t\t}\n\n\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst parser = new GLTFParser( json, {\n\n\t\t\tpath: path || this.resourcePath || '',\n\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\trequestHeader: this.requestHeader,\n\t\t\tmanager: this.manager,\n\t\t\tktx2Loader: this.ktx2Loader,\n\t\t\tmeshoptDecoder: this.meshoptDecoder\n\n\t\t} );\n\n\t\tparser.fileLoader.setRequestHeader( this.requestHeader );\n\n\t\tfor ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {\n\n\t\t\tconst plugin = this.pluginCallbacks[ i ]( parser );\n\t\t\tplugins[ plugin.name ] = plugin;\n\n\t\t\t// Workaround to avoid determining as unknown extension\n\t\t\t// in addUnknownExtensionsToUserData().\n\t\t\t// Remove this workaround if we move all the existing\n\t\t\t// extension handlers to plugin system\n\t\t\textensions[ plugin.name ] = true;\n\n\t\t}\n\n\t\tif ( json.extensionsUsed ) {\n\n\t\t\tfor ( let i = 0; i < json.extensionsUsed.length; ++ i ) {\n\n\t\t\t\tconst extensionName = json.extensionsUsed[ i ];\n\t\t\t\tconst extensionsRequired = json.extensionsRequired || [];\n\n\t\t\t\tswitch ( extensionName ) {\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tparser.setExtensions( extensions );\n\t\tparser.setPlugins( plugins );\n\t\tparser.parse( onLoad, onError );\n\n\t}\n\n\tparseAsync( data, path ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( data, path, resolve, reject );\n\n\t\t} );\n\n\t}\n\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n\n\tlet objects = {};\n\n\treturn\t{\n\n\t\tget: function ( key ) {\n\n\t\t\treturn objects[ key ];\n\n\t\t},\n\n\t\tadd: function ( key, object ) {\n\n\t\t\tobjects[ key ] = object;\n\n\t\t},\n\n\t\tremove: function ( key ) {\n\n\t\t\tdelete objects[ key ];\n\n\t\t},\n\n\t\tremoveAll: function () {\n\n\t\t\tobjects = {};\n\n\t\t}\n\n\t};\n\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n\tKHR_MATERIALS_IOR: 'KHR_materials_ior',\n\tKHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n\tKHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n\tKHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\n\tKHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',\n\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\tKHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n\tKHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\n\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\n\tEXT_TEXTURE_AVIF: 'EXT_texture_avif',\n\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\n\tEXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'\n};\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightsExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n\t\t// Object3D instance caches\n\t\tthis.cache = { refs: {}, uses: {} };\n\n\t}\n\n\t_markDefs() {\n\n\t\tconst parser = this.parser;\n\t\tconst nodeDefs = this.parser.json.nodes || [];\n\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.extensions\n\t\t\t\t\t&& nodeDef.extensions[ this.name ]\n\t\t\t\t\t&& nodeDef.extensions[ this.name ].light !== undefined ) {\n\n\t\t\t\tparser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_loadLight( lightIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst cacheKey = 'light:' + lightIndex;\n\t\tlet dependency = parser.cache.get( cacheKey );\n\n\t\tif ( dependency ) return dependency;\n\n\t\tconst json = parser.json;\n\t\tconst extensions = ( json.extensions && json.extensions[ this.name ] ) || {};\n\t\tconst lightDefs = extensions.lights || [];\n\t\tconst lightDef = lightDefs[ lightIndex ];\n\t\tlet lightNode;\n\n\t\tconst color = new Color( 0xffffff );\n\n\t\tif ( lightDef.color !== undefined ) color.fromArray( lightDef.color );\n\n\t\tconst range = lightDef.range !== undefined ? lightDef.range : 0;\n\n\t\tswitch ( lightDef.type ) {\n\n\t\t\tcase 'directional':\n\t\t\t\tlightNode = new DirectionalLight( color );\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tcase 'point':\n\t\t\t\tlightNode = new PointLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\tbreak;\n\n\t\t\tcase 'spot':\n\t\t\t\tlightNode = new SpotLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\t// Handle spotlight properties.\n\t\t\t\tlightDef.spot = lightDef.spot || {};\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );\n\n\t\t}\n\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\n\t\t// here, because node-level parsing will only override position if explicitly specified.\n\t\tlightNode.position.set( 0, 0, 0 );\n\n\t\tlightNode.decay = 2;\n\n\t\tassignExtrasToUserData( lightNode, lightDef );\n\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\n\n\t\tlightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );\n\n\t\tdependency = Promise.resolve( lightNode );\n\n\t\tparser.cache.add( cacheKey, dependency );\n\n\t\treturn dependency;\n\n\t}\n\n\tgetDependency( type, index ) {\n\n\t\tif ( type !== 'light' ) return;\n\n\t\treturn this._loadLight( index );\n\n\t}\n\n\tcreateNodeAttachment( nodeIndex ) {\n\n\t\tconst self = this;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\t\tconst lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};\n\t\tconst lightIndex = lightDef.light;\n\n\t\tif ( lightIndex === undefined ) return null;\n\n\t\treturn this._loadLight( lightIndex ).then( function ( light ) {\n\n\t\t\treturn parser._getNodeRef( self.cache, lightIndex, light );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t}\n\n\tgetMaterialType() {\n\n\t\treturn MeshBasicMaterial;\n\n\t}\n\n\textendParams( materialParams, materialDef, parser ) {\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness;\n\n\t\tif ( metallicRoughness ) {\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;\n\n\t\tif ( emissiveStrength !== undefined ) {\n\n\t\t\tmaterialParams.emissiveIntensity = emissiveStrength;\n\n\t\t}\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.clearcoatFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\n\n\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = extension.clearcoatNormalTexture.scale;\n\n\t\t\t\tmaterialParams.clearcoatNormalScale = new Vector2( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.iridescenceFactor !== undefined ) {\n\n\t\t\tmaterialParams.iridescence = extension.iridescenceFactor;\n\n\t\t}\n\n\t\tif ( extension.iridescenceTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );\n\n\t\t}\n\n\t\tif ( extension.iridescenceIor !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceIOR = extension.iridescenceIor;\n\n\t\t}\n\n\t\tif ( materialParams.iridescenceThicknessRange === undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange = [ 100, 400 ];\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessMinimum !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessMaximum !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.sheenColor = new Color( 0, 0, 0 );\n\t\tmaterialParams.sheenRoughness = 0;\n\t\tmaterialParams.sheen = 1;\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.sheenColorFactor !== undefined ) {\n\n\t\t\tmaterialParams.sheenColor.fromArray( extension.sheenColorFactor );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.sheenRoughness = extension.sheenRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.sheenColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.transmissionFactor !== undefined ) {\n\n\t\t\tmaterialParams.transmission = extension.transmissionFactor;\n\n\t\t}\n\n\t\tif ( extension.transmissionTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\n\n\t\tif ( extension.thicknessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );\n\n\t\t}\n\n\t\tmaterialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n\n\t\tconst colorArray = extension.attenuationColor || [ 1, 1, 1 ];\n\t\tmaterialParams.attenuationColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IOR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\n\n\t\tif ( extension.specularTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );\n\n\t\t}\n\n\t\tconst colorArray = extension.specularColorFactor || [ 1, 1, 1 ];\n\t\tmaterialParams.specularColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );\n\n\t\tif ( extension.specularColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials anisotropy Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.anisotropyStrength !== undefined ) {\n\n\t\t\tmaterialParams.anisotropy = extension.anisotropyStrength;\n\n\t\t}\n\n\t\tif ( extension.anisotropyRotation !== undefined ) {\n\n\t\t\tmaterialParams.anisotropyRotation = extension.anisotropyRotation;\n\n\t\t}\n\n\t\tif ( extension.anisotropyTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'anisotropyMap', extension.anisotropyTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\nclass GLTFTextureBasisUExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ this.name ];\n\t\tconst loader = parser.options.ktx2Loader;\n\n\t\tif ( ! loader ) {\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );\n\n\t\t\t} else {\n\n\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t}\n\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\nclass GLTFTextureWebPExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t}\n\n\tdetectSupport() {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tconst image = new Image();\n\n\t\t\t\t// Lossy test image. Support for lossy images doesn't guarantee support for all\n\t\t\t\t// WebP images, unfortunately.\n\t\t\t\timage.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t}\n\n}\n\n/**\n * AVIF Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\n */\nclass GLTFTextureAVIFExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: AVIF required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t}\n\n\tdetectSupport() {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tconst image = new Image();\n\n\t\t\t\t// Lossy test image.\n\t\t\t\timage.src = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=';\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t}\n\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\nclass GLTFMeshoptCompression {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n\t\tthis.parser = parser;\n\n\t}\n\n\tloadBufferView( index ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst bufferView = json.bufferViews[ index ];\n\n\t\tif ( bufferView.extensions && bufferView.extensions[ this.name ] ) {\n\n\t\t\tconst extensionDef = bufferView.extensions[ this.name ];\n\n\t\t\tconst buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );\n\t\t\tconst decoder = this.parser.options.meshoptDecoder;\n\n\t\t\tif ( ! decoder || ! decoder.supported ) {\n\n\t\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn buffer.then( function ( res ) {\n\n\t\t\t\tconst byteOffset = extensionDef.byteOffset || 0;\n\t\t\t\tconst byteLength = extensionDef.byteLength || 0;\n\n\t\t\t\tconst count = extensionDef.count;\n\t\t\t\tconst stride = extensionDef.byteStride;\n\n\t\t\t\tconst source = new Uint8Array( res, byteOffset, byteLength );\n\n\t\t\t\tif ( decoder.decodeGltfBufferAsync ) {\n\n\t\t\t\t\treturn decoder.decodeGltfBufferAsync( count, stride, source, extensionDef.mode, extensionDef.filter ).then( function ( res ) {\n\n\t\t\t\t\t\treturn res.buffer;\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n\t\t\t\t\treturn decoder.ready.then( function () {\n\n\t\t\t\t\t\tconst result = new ArrayBuffer( count * stride );\n\t\t\t\t\t\tdecoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );\n\t\t\t\t\t\treturn result;\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n */\nclass GLTFMeshGpuInstancing {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n\t\tthis.parser = parser;\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( ! nodeDef.extensions || ! nodeDef.extensions[ this.name ] ||\n\t\t\tnodeDef.mesh === undefined ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst meshDef = json.meshes[ nodeDef.mesh ];\n\n\t\t// No Points or Lines + Instancing support yet\n\n\t\tfor ( const primitive of meshDef.primitives ) {\n\n\t\t\tif ( primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&\n\t\t\t\t primitive.mode !== undefined ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst extensionDef = nodeDef.extensions[ this.name ];\n\t\tconst attributesDef = extensionDef.attributes;\n\n\t\t// @TODO: Can we support InstancedMesh + SkinnedMesh?\n\n\t\tconst pending = [];\n\t\tconst attributes = {};\n\n\t\tfor ( const key in attributesDef ) {\n\n\t\t\tpending.push( this.parser.getDependency( 'accessor', attributesDef[ key ] ).then( accessor => {\n\n\t\t\t\tattributes[ key ] = accessor;\n\t\t\t\treturn attributes[ key ];\n\n\t\t\t} ) );\n\n\t\t}\n\n\t\tif ( pending.length < 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tpending.push( this.parser.createNodeMesh( nodeIndex ) );\n\n\t\treturn Promise.all( pending ).then( results => {\n\n\t\t\tconst nodeObject = results.pop();\n\t\t\tconst meshes = nodeObject.isGroup ? nodeObject.children : [ nodeObject ];\n\t\t\tconst count = results[ 0 ].count; // All attribute counts should be same\n\t\t\tconst instancedMeshes = [];\n\n\t\t\tfor ( const mesh of meshes ) {\n\n\t\t\t\t// Temporal variables\n\t\t\t\tconst m = new Matrix4();\n\t\t\t\tconst p = new Vector3();\n\t\t\t\tconst q = new Quaternion();\n\t\t\t\tconst s = new Vector3( 1, 1, 1 );\n\n\t\t\t\tconst instancedMesh = new InstancedMesh( mesh.geometry, mesh.material, count );\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tif ( attributes.TRANSLATION ) {\n\n\t\t\t\t\t\tp.fromBufferAttribute( attributes.TRANSLATION, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.ROTATION ) {\n\n\t\t\t\t\t\tq.fromBufferAttribute( attributes.ROTATION, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.SCALE ) {\n\n\t\t\t\t\t\ts.fromBufferAttribute( attributes.SCALE, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinstancedMesh.setMatrixAt( i, m.compose( p, q, s ) );\n\n\t\t\t\t}\n\n\t\t\t\t// Add instance attributes to the geometry, excluding TRS.\n\t\t\t\tfor ( const attributeName in attributes ) {\n\n\t\t\t\t\tif ( attributeName !== 'TRANSLATION' &&\n\t\t\t\t\t\t attributeName !== 'ROTATION' &&\n\t\t\t\t\t\t attributeName !== 'SCALE' ) {\n\n\t\t\t\t\t\tmesh.geometry.setAttribute( attributeName, attributes[ attributeName ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Just in case\n\t\t\t\tObject3D.prototype.copy.call( instancedMesh, mesh );\n\n\t\t\t\tthis.parser.assignFinalMaterial( instancedMesh );\n\n\t\t\t\tinstancedMeshes.push( instancedMesh );\n\n\t\t\t}\n\n\t\t\tif ( nodeObject.isGroup ) {\n\n\t\t\t\tnodeObject.clear();\n\n\t\t\t\tnodeObject.add( ... instancedMeshes );\n\n\t\t\t\treturn nodeObject;\n\n\t\t\t}\n\n\t\t\treturn instancedMeshes[ 0 ];\n\n\t\t} );\n\n\t}\n\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\nclass GLTFBinaryExtension {\n\n\tconstructor( data ) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tconst headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tthis.header = {\n\t\t\tmagic: textDecoder.decode( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\tlength: headerView.getUint32( 8, true )\n\t\t};\n\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\n\n\t\t}\n\n\t\tconst chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n\t\tconst chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tlet chunkIndex = 0;\n\n\t\twhile ( chunkIndex < chunkContentsLength ) {\n\n\t\t\tconst chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tconst chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\tconst contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\tthis.content = textDecoder.decode( contentArray );\n\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\tconst byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\n\t\t}\n\n\t\tif ( this.content === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\nclass GLTFDracoMeshCompressionExtension {\n\n\tconstructor( json, dracoLoader ) {\n\n\t\tif ( ! dracoLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.json = json;\n\t\tthis.dracoLoader = dracoLoader;\n\t\tthis.dracoLoader.preload();\n\n\t}\n\n\tdecodePrimitive( primitive, parser ) {\n\n\t\tconst json = this.json;\n\t\tconst dracoLoader = this.dracoLoader;\n\t\tconst bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\tconst gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\tconst threeAttributeMap = {};\n\t\tconst attributeNormalizedMap = {};\n\t\tconst attributeTypeMap = {};\n\n\t\tfor ( const attributeName in gltfAttributeMap ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\n\n\t\t}\n\n\t\tfor ( const attributeName in primitive.attributes ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\n\n\t\t\t\tconst accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\n\t\t\t\tconst componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType.name;\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\n\n\t\t\t\t\tfor ( const attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\tconst normalized = attributeNormalizedMap[ attributeName ];\n\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( geometry );\n\n\t\t\t\t}, threeAttributeMap, attributeTypeMap );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\nclass GLTFTextureTransformExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n\n\t}\n\n\textendTexture( texture, transform ) {\n\n\t\tif ( ( transform.texCoord === undefined || transform.texCoord === texture.channel )\n\t\t\t&& transform.offset === undefined\n\t\t\t&& transform.rotation === undefined\n\t\t\t&& transform.scale === undefined ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21819.\n\t\t\treturn texture;\n\n\t\t}\n\n\t\ttexture = texture.clone();\n\n\t\tif ( transform.texCoord !== undefined ) {\n\n\t\t\ttexture.channel = transform.texCoord;\n\n\t\t}\n\n\t\tif ( transform.offset !== undefined ) {\n\n\t\t\ttexture.offset.fromArray( transform.offset );\n\n\t\t}\n\n\t\tif ( transform.rotation !== undefined ) {\n\n\t\t\ttexture.rotation = transform.rotation;\n\n\t\t}\n\n\t\tif ( transform.scale !== undefined ) {\n\n\t\t\ttexture.repeat.fromArray( transform.scale );\n\n\t\t}\n\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\nclass GLTFMeshQuantizationExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n\n\t}\n\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// Copies a sample value to the result buffer. See description of glTF\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tvalueSize = this.valueSize,\n\t\t\toffset = index * valueSize * 3 + valueSize;\n\n\t\tfor ( let i = 0; i !== valueSize; i ++ ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer;\n\t\tconst values = this.sampleValues;\n\t\tconst stride = this.valueSize;\n\n\t\tconst stride2 = stride * 2;\n\t\tconst stride3 = stride * 3;\n\n\t\tconst td = t1 - t0;\n\n\t\tconst p = ( t - t0 ) / td;\n\t\tconst pp = p * p;\n\t\tconst ppp = pp * p;\n\n\t\tconst offset1 = i1 * stride3;\n\t\tconst offset0 = offset1 - stride3;\n\n\t\tconst s2 = - 2 * ppp + 3 * pp;\n\t\tconst s3 = ppp - pp;\n\t\tconst s0 = 1 - s2;\n\t\tconst s1 = s3 - pp + p;\n\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\tfor ( let i = 0; i !== stride; i ++ ) {\n\n\t\t\tconst p0 = values[ offset0 + i + stride ]; // splineVertex_k\n\t\t\tconst m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\n\t\t\tconst p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\n\t\t\tconst m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nconst _q = new Quaternion();\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = super.interpolate_( i1, t0, t, t1 );\n\n\t\t_q.fromArray( result ).normalize().toArray( result );\n\n\t\treturn result;\n\n\t}\n\n}\n\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n\tFLOAT: 5126,\n\t//FLOAT_MAT2: 35674,\n\tFLOAT_MAT3: 35675,\n\tFLOAT_MAT4: 35676,\n\tFLOAT_VEC2: 35664,\n\tFLOAT_VEC3: 35665,\n\tFLOAT_VEC4: 35666,\n\tLINEAR: 9729,\n\tREPEAT: 10497,\n\tSAMPLER_2D: 35678,\n\tPOINTS: 0,\n\tLINES: 1,\n\tLINE_LOOP: 2,\n\tLINE_STRIP: 3,\n\tTRIANGLES: 4,\n\tTRIANGLE_STRIP: 5,\n\tTRIANGLE_FAN: 6,\n\tUNSIGNED_BYTE: 5121,\n\tUNSIGNED_SHORT: 5123\n};\n\nconst WEBGL_COMPONENT_TYPES = {\n\t5120: Int8Array,\n\t5121: Uint8Array,\n\t5122: Int16Array,\n\t5123: Uint16Array,\n\t5125: Uint32Array,\n\t5126: Float32Array\n};\n\nconst WEBGL_FILTERS = {\n\t9728: NearestFilter,\n\t9729: LinearFilter,\n\t9984: NearestMipmapNearestFilter,\n\t9985: LinearMipmapNearestFilter,\n\t9986: NearestMipmapLinearFilter,\n\t9987: LinearMipmapLinearFilter\n};\n\nconst WEBGL_WRAPPINGS = {\n\t33071: ClampToEdgeWrapping,\n\t33648: MirroredRepeatWrapping,\n\t10497: RepeatWrapping\n};\n\nconst WEBGL_TYPE_SIZES = {\n\t'SCALAR': 1,\n\t'VEC2': 2,\n\t'VEC3': 3,\n\t'VEC4': 4,\n\t'MAT2': 4,\n\t'MAT3': 9,\n\t'MAT4': 16\n};\n\nconst ATTRIBUTES = {\n\tPOSITION: 'position',\n\tNORMAL: 'normal',\n\tTANGENT: 'tangent',\n\tTEXCOORD_0: 'uv',\n\tTEXCOORD_1: 'uv1',\n\tTEXCOORD_2: 'uv2',\n\tTEXCOORD_3: 'uv3',\n\tCOLOR_0: 'color',\n\tWEIGHTS_0: 'skinWeight',\n\tJOINTS_0: 'skinIndex',\n};\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\ttranslation: 'position',\n\trotation: 'quaternion',\n\tweights: 'morphTargetInfluences'\n};\n\nconst INTERPOLATION = {\n\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\n\tLINEAR: InterpolateLinear,\n\tSTEP: InterpolateDiscrete\n};\n\nconst ALPHA_MODES = {\n\tOPAQUE: 'OPAQUE',\n\tMASK: 'MASK',\n\tBLEND: 'BLEND'\n};\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\nfunction createDefaultMaterial( cache ) {\n\n\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\n\n\t\tcache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {\n\t\t\tcolor: 0xFFFFFF,\n\t\t\temissive: 0x000000,\n\t\t\tmetalness: 1,\n\t\t\troughness: 1,\n\t\t\ttransparent: false,\n\t\t\tdepthTest: true,\n\t\t\tside: FrontSide\n\t\t} );\n\n\t}\n\n\treturn cache[ 'DefaultMaterial' ];\n\n}\n\nfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\n\n\t// Add unknown glTF extensions to an object's userData.\n\n\tfor ( const name in objectDef.extensions ) {\n\n\t\tif ( knownExtensions[ name ] === undefined ) {\n\n\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\n\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData( object, gltfDef ) {\n\n\tif ( gltfDef.extras !== undefined ) {\n\n\t\tif ( typeof gltfDef.extras === 'object' ) {\n\n\t\t\tObject.assign( object.userData, gltfDef.extras );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets( geometry, targets, parser ) {\n\n\tlet hasMorphPosition = false;\n\tlet hasMorphNormal = false;\n\tlet hasMorphColor = false;\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\t\tif ( target.COLOR_0 !== undefined ) hasMorphColor = true;\n\n\t\tif ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;\n\n\t}\n\n\tif ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );\n\n\tconst pendingPositionAccessors = [];\n\tconst pendingNormalAccessors = [];\n\tconst pendingColorAccessors = [];\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( hasMorphPosition ) {\n\n\t\t\tconst pendingAccessor = target.POSITION !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\n\t\t\t\t: geometry.attributes.position;\n\n\t\t\tpendingPositionAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphNormal ) {\n\n\t\t\tconst pendingAccessor = target.NORMAL !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\n\t\t\t\t: geometry.attributes.normal;\n\n\t\t\tpendingNormalAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphColor ) {\n\n\t\t\tconst pendingAccessor = target.COLOR_0 !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.COLOR_0 )\n\t\t\t\t: geometry.attributes.color;\n\n\t\t\tpendingColorAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t}\n\n\treturn Promise.all( [\n\t\tPromise.all( pendingPositionAccessors ),\n\t\tPromise.all( pendingNormalAccessors ),\n\t\tPromise.all( pendingColorAccessors )\n\t] ).then( function ( accessors ) {\n\n\t\tconst morphPositions = accessors[ 0 ];\n\t\tconst morphNormals = accessors[ 1 ];\n\t\tconst morphColors = accessors[ 2 ];\n\n\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\t\tif ( hasMorphColor ) geometry.morphAttributes.color = morphColors;\n\t\tgeometry.morphTargetsRelative = true;\n\n\t\treturn geometry;\n\n\t} );\n\n}\n\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets( mesh, meshDef ) {\n\n\tmesh.updateMorphTargets();\n\n\tif ( meshDef.weights !== undefined ) {\n\n\t\tfor ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t}\n\n\t}\n\n\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\tconst targetNames = meshDef.extras.targetNames;\n\n\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\tfor ( let i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t}\n\n\t}\n\n}\n\nfunction createPrimitiveKey( primitiveDef ) {\n\n\tlet geometryKey;\n\n\tconst dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\n\n\tif ( dracoExtension ) {\n\n\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\n\t\t\t\t+ ':' + dracoExtension.indices\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\n\n\t} else {\n\n\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\n\n\t}\n\n\tif ( primitiveDef.targets !== undefined ) {\n\n\t\tfor ( let i = 0, il = primitiveDef.targets.length; i < il; i ++ ) {\n\n\t\t\tgeometryKey += ':' + createAttributesKey( primitiveDef.targets[ i ] );\n\n\t\t}\n\n\t}\n\n\treturn geometryKey;\n\n}\n\nfunction createAttributesKey( attributes ) {\n\n\tlet attributesKey = '';\n\n\tconst keys = Object.keys( attributes ).sort();\n\n\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\n\n\t}\n\n\treturn attributesKey;\n\n}\n\nfunction getNormalizedComponentScale( constructor ) {\n\n\t// Reference:\n\t// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n\tswitch ( constructor ) {\n\n\t\tcase Int8Array:\n\t\t\treturn 1 / 127;\n\n\t\tcase Uint8Array:\n\t\t\treturn 1 / 255;\n\n\t\tcase Int16Array:\n\t\t\treturn 1 / 32767;\n\n\t\tcase Uint16Array:\n\t\t\treturn 1 / 65535;\n\n\t\tdefault:\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );\n\n\t}\n\n}\n\nfunction getImageURIMimeType( uri ) {\n\n\tif ( uri.search( /\\.jpe?g($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/jpeg/ ) === 0 ) return 'image/jpeg';\n\tif ( uri.search( /\\.webp($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/webp/ ) === 0 ) return 'image/webp';\n\n\treturn 'image/png';\n\n}\n\nconst _identityMatrix = new Matrix4();\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n\n\tconstructor( json = {}, options = {} ) {\n\n\t\tthis.json = json;\n\t\tthis.extensions = {};\n\t\tthis.plugins = {};\n\t\tthis.options = options;\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// associations between Three.js objects and glTF elements\n\t\tthis.associations = new Map();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = {};\n\n\t\t// Node cache\n\t\tthis.nodeCache = {};\n\n\t\t// Object3D instance caches\n\t\tthis.meshCache = { refs: {}, uses: {} };\n\t\tthis.cameraCache = { refs: {}, uses: {} };\n\t\tthis.lightCache = { refs: {}, uses: {} };\n\n\t\tthis.sourceCache = {};\n\t\tthis.textureCache = {};\n\n\t\t// Track node names, to ensure no duplicates\n\t\tthis.nodeNamesUsed = {};\n\n\t\t// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n\t\t// expensive work of uploading a texture to the GPU off the main thread.\n\n\t\tlet isSafari = false;\n\t\tlet isFirefox = false;\n\t\tlet firefoxVersion = - 1;\n\n\t\tif ( typeof navigator !== 'undefined' ) {\n\n\t\t\tisSafari = /^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === true;\n\t\t\tisFirefox = navigator.userAgent.indexOf( 'Firefox' ) > - 1;\n\t\t\tfirefoxVersion = isFirefox ? navigator.userAgent.match( /Firefox\\/([0-9]+)\\./ )[ 1 ] : - 1;\n\n\t\t}\n\n\t\tif ( typeof createImageBitmap === 'undefined' || isSafari || ( isFirefox && firefoxVersion < 98 ) ) {\n\n\t\t\tthis.textureLoader = new TextureLoader( this.options.manager );\n\n\t\t} else {\n\n\t\t\tthis.textureLoader = new ImageBitmapLoader( this.options.manager );\n\n\t\t}\n\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\t\tthis.textureLoader.setRequestHeader( this.options.requestHeader );\n\n\t\tthis.fileLoader = new FileLoader( this.options.manager );\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\n\n\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\n\n\t\t\tthis.fileLoader.setWithCredentials( true );\n\n\t\t}\n\n\t}\n\n\tsetExtensions( extensions ) {\n\n\t\tthis.extensions = extensions;\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\tparse( onLoad, onError ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\t\tthis.nodeCache = {};\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\treturn ext._markDefs && ext._markDefs();\n\n\t\t} );\n\n\t\tPromise.all( this._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.beforeRoot && ext.beforeRoot();\n\n\t\t} ) ).then( function () {\n\n\t\t\treturn Promise.all( [\n\n\t\t\t\tparser.getDependencies( 'scene' ),\n\t\t\t\tparser.getDependencies( 'animation' ),\n\t\t\t\tparser.getDependencies( 'camera' ),\n\n\t\t\t] );\n\n\t\t} ).then( function ( dependencies ) {\n\n\t\t\tconst result = {\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\n\t\t\t\tscenes: dependencies[ 0 ],\n\t\t\t\tanimations: dependencies[ 1 ],\n\t\t\t\tcameras: dependencies[ 2 ],\n\t\t\t\tasset: json.asset,\n\t\t\t\tparser: parser,\n\t\t\t\tuserData: {}\n\t\t\t};\n\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\n\n\t\t\tassignExtrasToUserData( result, json );\n\n\t\t\tPromise.all( parser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.afterRoot && ext.afterRoot( result );\n\n\t\t\t} ) ).then( function () {\n\n\t\t\t\tonLoad( result );\n\n\t\t\t} );\n\n\t\t} ).catch( onError );\n\n\t}\n\n\t/**\n\t * Marks the special nodes/meshes in json for efficient parse.\n\t */\n\t_markDefs() {\n\n\t\tconst nodeDefs = this.json.nodes || [];\n\t\tconst skinDefs = this.json.skins || [];\n\t\tconst meshDefs = this.json.meshes || [];\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\tconst joints = skinDefs[ skinIndex ].joints;\n\n\t\t\tfor ( let i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Iterate over all nodes, marking references to shared resources,\n\t\t// as well as skeleton joints.\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.meshCache, nodeDef.mesh );\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.cameraCache, nodeDef.camera );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Counts references to shared node / Object3D resources. These resources\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\n\t * Textures) can be reused directly and are not marked here.\n\t *\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t */\n\t_addNodeRef( cache, index ) {\n\n\t\tif ( index === undefined ) return;\n\n\t\tif ( cache.refs[ index ] === undefined ) {\n\n\t\t\tcache.refs[ index ] = cache.uses[ index ] = 0;\n\n\t\t}\n\n\t\tcache.refs[ index ] ++;\n\n\t}\n\n\t/** Returns a reference to a shared resource, cloning it if necessary. */\n\t_getNodeRef( cache, index, object ) {\n\n\t\tif ( cache.refs[ index ] <= 1 ) return object;\n\n\t\tconst ref = object.clone();\n\n\t\t// Propagates mappings to the cloned object, prevents mappings on the\n\t\t// original object from being lost.\n\t\tconst updateMappings = ( original, clone ) => {\n\n\t\t\tconst mappings = this.associations.get( original );\n\t\t\tif ( mappings != null ) {\n\n\t\t\t\tthis.associations.set( clone, mappings );\n\n\t\t\t}\n\n\t\t\tfor ( const [ i, child ] of original.children.entries() ) {\n\n\t\t\t\tupdateMappings( child, clone.children[ i ] );\n\n\t\t\t}\n\n\t\t};\n\n\t\tupdateMappings( object, ref );\n\n\t\tref.name += '_instance_' + ( cache.uses[ index ] ++ );\n\n\t\treturn ref;\n\n\t}\n\n\t_invokeOne( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.push( this );\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) return result;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t_invokeAll( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.unshift( this );\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) pending.push( result );\n\n\t\t}\n\n\t\treturn pending;\n\n\t}\n\n\t/**\n\t * Requests the specified dependency asynchronously, with caching.\n\t * @param {string} type\n\t * @param {number} index\n\t * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n\t */\n\tgetDependency( type, index ) {\n\n\t\tconst cacheKey = type + ':' + index;\n\t\tlet dependency = this.cache.get( cacheKey );\n\n\t\tif ( ! dependency ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadNode && ext.loadNode( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadAnimation && ext.loadAnimation( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext != this && ext.getDependency && ext.getDependency( type, index );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tif ( ! dependency ) {\n\n\t\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t}\n\n\t\treturn dependency;\n\n\t}\n\n\t/**\n\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t * @param {string} type\n\t * @return {Promise<Array<Object>>}\n\t */\n\tgetDependencies( type ) {\n\n\t\tlet dependencies = this.cache.get( type );\n\n\t\tif ( ! dependencies ) {\n\n\t\t\tconst parser = this;\n\t\t\tconst defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t} ) );\n\n\t\t\tthis.cache.add( type, dependencies );\n\n\t\t}\n\n\t\treturn dependencies;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBuffer( bufferIndex ) {\n\n\t\tconst bufferDef = this.json.buffers[ bufferIndex ];\n\t\tconst loader = this.fileLoader;\n\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\n\t\t}\n\n\t\tconst options = this.options;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tloader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferViewIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBufferView( bufferViewIndex ) {\n\n\t\tconst bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\tconst byteLength = bufferViewDef.byteLength || 0;\n\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t * @param {number} accessorIndex\n\t * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n\t */\n\tloadAccessor( accessorIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\t\t\tconst normalized = accessorDef.normalized === true;\n\n\t\t\tconst array = new TypedArray( accessorDef.count * itemSize );\n\t\t\treturn Promise.resolve( new BufferAttribute( array, itemSize, normalized ) );\n\n\t\t}\n\n\t\tconst pendingBufferViews = [];\n\n\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t} else {\n\n\t\t\tpendingBufferViews.push( null );\n\n\t\t}\n\n\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t}\n\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\tconst bufferView = bufferViews[ 0 ];\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tconst elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tconst itemBytes = elementBytes * itemSize;\n\t\t\tconst byteOffset = accessorDef.byteOffset || 0;\n\t\t\tconst byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\n\t\t\tconst normalized = accessorDef.normalized === true;\n\t\t\tlet array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\n\t\t\t\tconst ibSlice = Math.floor( byteOffset / byteStride );\n\t\t\t\tconst ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n\t\t\t\tlet ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new InterleavedBuffer( array, byteStride / elementBytes );\n\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\n\n\t\t\t} else {\n\n\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tconst itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tconst TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\tconst byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tconst byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tconst sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\tconst sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst index = sparseIndices[ i ];\n\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t * @param {number} textureIndex\n\t * @return {Promise<THREE.Texture|null>}\n\t */\n\tloadTexture( textureIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceIndex = textureDef.source;\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tlet loader = this.textureLoader;\n\n\t\tif ( sourceDef.uri ) {\n\n\t\t\tconst handler = options.manager.getHandler( sourceDef.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.loadTextureImage( textureIndex, sourceIndex, loader );\n\n\t}\n\n\tloadTextureImage( textureIndex, sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;\n\n\t\tif ( this.textureCache[ cacheKey ] ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21559.\n\t\t\treturn this.textureCache[ cacheKey ];\n\n\t\t}\n\n\t\tconst promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {\n\n\t\t\ttexture.flipY = false;\n\n\t\t\ttexture.name = textureDef.name || sourceDef.name || '';\n\n\t\t\tif ( texture.name === '' && typeof sourceDef.uri === 'string' && sourceDef.uri.startsWith( 'data:image/' ) === false ) {\n\n\t\t\t\ttexture.name = sourceDef.uri;\n\n\t\t\t}\n\n\t\t\tconst samplers = json.samplers || {};\n\t\t\tconst sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;\n\n\t\t\tparser.associations.set( texture, { textures: textureIndex } );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function () {\n\n\t\t\treturn null;\n\n\t\t} );\n\n\t\tthis.textureCache[ cacheKey ] = promise;\n\n\t\treturn promise;\n\n\t}\n\n\tloadImageSource( sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( this.sourceCache[ sourceIndex ] !== undefined ) {\n\n\t\t\treturn this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );\n\n\t\t}\n\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst URL = self.URL || self.webkitURL;\n\n\t\tlet sourceURI = sourceDef.uri || '';\n\t\tlet isObjectURL = false;\n\n\t\tif ( sourceDef.bufferView !== undefined ) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tconst blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\treturn sourceURI;\n\n\t\t\t} );\n\n\t\t} else if ( sourceDef.uri === undefined ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );\n\n\t\t}\n\n\t\tconst promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tlet onLoad = resolve;\n\n\t\t\t\tif ( loader.isImageBitmapLoader === true ) {\n\n\t\t\t\t\tonLoad = function ( imageBitmap ) {\n\n\t\t\t\t\t\tconst texture = new Texture( imageBitmap );\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tresolve( texture );\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tloader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );\n\n\t\t\t} );\n\n\t\t} ).then( function ( texture ) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t}\n\n\t\t\ttexture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function ( error ) {\n\n\t\t\tconsole.error( 'THREE.GLTFLoader: Couldn\\'t load texture', sourceURI );\n\t\t\tthrow error;\n\n\t\t} );\n\n\t\tthis.sourceCache[ sourceIndex ] = promise;\n\t\treturn promise;\n\n\t}\n\n\t/**\n\t * Asynchronously assigns a texture to the given material parameters.\n\t * @param {Object} materialParams\n\t * @param {string} mapName\n\t * @param {Object} mapDef\n\t * @return {Promise<Texture>}\n\t */\n\tassignTexture( materialParams, mapName, mapDef, colorSpace ) {\n\n\t\tconst parser = this;\n\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\n\n\t\t\tif ( ! texture ) return null;\n\n\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord > 0 ) {\n\n\t\t\t\ttexture = texture.clone();\n\t\t\t\ttexture.channel = mapDef.texCoord;\n\n\t\t\t}\n\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\n\n\t\t\t\tconst transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\tconst gltfReference = parser.associations.get( texture );\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\n\t\t\t\t\tparser.associations.set( texture, gltfReference );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( colorSpace !== undefined ) {\n\n\t\t\t\ttexture.colorSpace = colorSpace;\n\n\t\t\t}\n\n\t\t\tmaterialParams[ mapName ] = texture;\n\n\t\t\treturn texture;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\n\t * already has a material (generated from the glTF material options alone)\n\t * but reuse of the same glTF material may require multiple threejs materials\n\t * to accommodate different primitive types, defines, etc. New materials will\n\t * be created if necessary, and reused from a cache.\n\t * @param  {Object3D} mesh Mesh, Line, or Points instance.\n\t */\n\tassignFinalMaterial( mesh ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tlet material = mesh.material;\n\n\t\tconst useDerivativeTangents = geometry.attributes.tangent === undefined;\n\t\tconst useVertexColors = geometry.attributes.color !== undefined;\n\t\tconst useFlatShading = geometry.attributes.normal === undefined;\n\n\t\tif ( mesh.isPoints ) {\n\n\t\t\tconst cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\tlet pointsMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\tpointsMaterial = new PointsMaterial();\n\t\t\t\tMaterial.prototype.copy.call( pointsMaterial, material );\n\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = pointsMaterial;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tconst cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\tlet lineMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\tlineMaterial = new LineBasicMaterial();\n\t\t\t\tMaterial.prototype.copy.call( lineMaterial, material );\n\t\t\t\tlineMaterial.color.copy( material.color );\n\t\t\t\tlineMaterial.map = material.map;\n\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = lineMaterial;\n\n\t\t}\n\n\t\t// Clone the material if it will be modified\n\t\tif ( useDerivativeTangents || useVertexColors || useFlatShading ) {\n\n\t\t\tlet cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n\t\t\tif ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\n\n\t\t\tlet cachedMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! cachedMaterial ) {\n\n\t\t\t\tcachedMaterial = material.clone();\n\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\n\n\t\t\t\tif ( useDerivativeTangents ) {\n\n\t\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\t\tif ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;\n\t\t\t\t\tif ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\n\n\t\t\t\tthis.associations.set( cachedMaterial, this.associations.get( material ) );\n\n\t\t\t}\n\n\t\t\tmaterial = cachedMaterial;\n\n\t\t}\n\n\t\tmesh.material = material;\n\n\t}\n\n\tgetMaterialType( /* materialIndex */ ) {\n\n\t\treturn MeshStandardMaterial;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t * @param {number} materialIndex\n\t * @return {Promise<Material>}\n\t */\n\tloadMaterial( materialIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst materialDef = json.materials[ materialIndex ];\n\n\t\tlet materialType;\n\t\tconst materialParams = {};\n\t\tconst materialExtensions = materialDef.extensions || {};\n\n\t\tconst pending = [];\n\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\tconst kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\tmaterialType = kmuExtension.getMaterialType();\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );\n\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialType = this._invokeOne( function ( ext ) {\n\n\t\t\t\treturn ext.getMaterialType && ext.getMaterialType( materialIndex );\n\n\t\t\t} );\n\n\t\t\tpending.push( Promise.all( this._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );\n\n\t\t\t} ) ) );\n\n\t\t}\n\n\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\tmaterialParams.side = DoubleSide;\n\n\t\t}\n\n\t\tconst alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\tmaterialParams.transparent = true;\n\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\n\t\t\tmaterialParams.depthWrite = false;\n\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\n\n\t\t\tmaterialParams.normalScale = new Vector2( 1, 1 );\n\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = materialDef.normalTexture.scale;\n\n\t\t\t\tmaterialParams.normalScale.set( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\n\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tmaterialParams.emissive = new Color().fromArray( materialDef.emissiveFactor );\n\n\t\t}\n\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\tconst material = new materialType( materialParams );\n\n\t\t\tif ( materialDef.name ) material.name = materialDef.name;\n\n\t\t\tassignExtrasToUserData( material, materialDef );\n\n\t\t\tparser.associations.set( material, { materials: materialIndex } );\n\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\n\n\t\t\treturn material;\n\n\t\t} );\n\n\t}\n\n\t/** When Object3D instances are targeted by animation, they need unique names. */\n\tcreateUniqueName( originalName ) {\n\n\t\tconst sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );\n\n\t\tif ( sanitizedName in this.nodeNamesUsed ) {\n\n\t\t\treturn sanitizedName + '_' + ( ++ this.nodeNamesUsed[ sanitizedName ] );\n\n\t\t} else {\n\n\t\t\tthis.nodeNamesUsed[ sanitizedName ] = 0;\n\n\t\t\treturn sanitizedName;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t *\n\t * Creates BufferGeometries from primitives.\n\t *\n\t * @param {Array<GLTF.Primitive>} primitives\n\t * @return {Promise<Array<BufferGeometry>>}\n\t */\n\tloadGeometries( primitives ) {\n\n\t\tconst parser = this;\n\t\tconst extensions = this.extensions;\n\t\tconst cache = this.primitiveCache;\n\n\t\tfunction createDracoPrimitive( primitive ) {\n\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t.then( function ( geometry ) {\n\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = primitives[ i ];\n\t\t\tconst cacheKey = createPrimitiveKey( primitive );\n\n\t\t\t// See if we've already created this geometry\n\t\t\tconst cached = cache[ cacheKey ];\n\n\t\t\tif ( cached ) {\n\n\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\tpending.push( cached.promise );\n\n\t\t\t} else {\n\n\t\t\t\tlet geometryPromise;\n\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );\n\n\t\t\t\t}\n\n\t\t\t\t// Cache this geometry\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\n\n\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t * @param {number} meshIndex\n\t * @return {Promise<Group|Mesh|SkinnedMesh>}\n\t */\n\tloadMesh( meshIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\tconst meshDef = json.meshes[ meshIndex ];\n\t\tconst primitives = meshDef.primitives;\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst material = primitives[ i ].material === undefined\n\t\t\t\t? createDefaultMaterial( this.cache )\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\n\n\t\t\tpending.push( material );\n\n\t\t}\n\n\t\tpending.push( parser.loadGeometries( primitives ) );\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst materials = results.slice( 0, results.length - 1 );\n\t\t\tconst geometries = results[ results.length - 1 ];\n\n\t\t\tconst meshes = [];\n\n\t\t\tfor ( let i = 0, il = geometries.length; i < il; i ++ ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\t// 1. create Mesh\n\n\t\t\t\tlet mesh;\n\n\t\t\t\tconst material = materials[ i ];\n\n\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\n\t\t\t\t\t\t? new SkinnedMesh( geometry, material )\n\t\t\t\t\t\t: new Mesh( geometry, material );\n\n\t\t\t\t\tif ( mesh.isSkinnedMesh === true ) {\n\n\t\t\t\t\t\t// normalize skin weights to fix malformed assets (see #15319)\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\tmesh = new LineSegments( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\tmesh = new Line( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\tmesh = new LineLoop( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\tmesh = new Points( geometry, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t}\n\n\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\n\n\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );\n\n\t\t\t\tassignExtrasToUserData( mesh, meshDef );\n\n\t\t\t\tif ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );\n\n\t\t\t\tparser.assignFinalMaterial( mesh );\n\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tparser.associations.set( meshes[ i ], {\n\t\t\t\t\tmeshes: meshIndex,\n\t\t\t\t\tprimitives: i\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( meshes.length === 1 ) {\n\n\t\t\t\tif ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, meshes[ 0 ], meshDef );\n\n\t\t\t\treturn meshes[ 0 ];\n\n\t\t\t}\n\n\t\t\tconst group = new Group();\n\n\t\t\tif ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, group, meshDef );\n\n\t\t\tparser.associations.set( group, { meshes: meshIndex } );\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t * @param {number} cameraIndex\n\t * @return {Promise<THREE.Camera>}\n\t */\n\tloadCamera( cameraIndex ) {\n\n\t\tlet camera;\n\t\tconst cameraDef = this.json.cameras[ cameraIndex ];\n\t\tconst params = cameraDef[ cameraDef.type ];\n\n\t\tif ( ! params ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\tcamera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\tcamera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );\n\n\t\t}\n\n\t\tif ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );\n\n\t\tassignExtrasToUserData( camera, cameraDef );\n\n\t\treturn Promise.resolve( camera );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t * @param {number} skinIndex\n\t * @return {Promise<Skeleton>}\n\t */\n\tloadSkin( skinIndex ) {\n\n\t\tconst skinDef = this.json.skins[ skinIndex ];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = skinDef.joints.length; i < il; i ++ ) {\n\n\t\t\tpending.push( this._loadNodeShallow( skinDef.joints[ i ] ) );\n\n\t\t}\n\n\t\tif ( skinDef.inverseBindMatrices !== undefined ) {\n\n\t\t\tpending.push( this.getDependency( 'accessor', skinDef.inverseBindMatrices ) );\n\n\t\t} else {\n\n\t\t\tpending.push( null );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst inverseBindMatrices = results.pop();\n\t\t\tconst jointNodes = results;\n\n\t\t\t// Note that bones (joint nodes) may or may not be in the\n\t\t\t// scene graph at this time.\n\n\t\t\tconst bones = [];\n\t\t\tconst boneInverses = [];\n\n\t\t\tfor ( let i = 0, il = jointNodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst jointNode = jointNodes[ i ];\n\n\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\tconst mat = new Matrix4();\n\n\t\t\t\t\tif ( inverseBindMatrices !== null ) {\n\n\t\t\t\t\t\tmat.fromArray( inverseBindMatrices.array, i * 16 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Skeleton( bones, boneInverses );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t * @param {number} animationIndex\n\t * @return {Promise<AnimationClip>}\n\t */\n\tloadAnimation( animationIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\n\t\tconst animationDef = json.animations[ animationIndex ];\n\t\tconst animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n\n\t\tconst pendingNodes = [];\n\t\tconst pendingInputAccessors = [];\n\t\tconst pendingOutputAccessors = [];\n\t\tconst pendingSamplers = [];\n\t\tconst pendingTargets = [];\n\n\t\tfor ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\tconst channel = animationDef.channels[ i ];\n\t\t\tconst sampler = animationDef.samplers[ channel.sampler ];\n\t\t\tconst target = channel.target;\n\t\t\tconst name = target.node;\n\t\t\tconst input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\tconst output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\tif ( target.node === undefined ) continue;\n\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\n\t\t\tpendingSamplers.push( sampler );\n\t\t\tpendingTargets.push( target );\n\n\t\t}\n\n\t\treturn Promise.all( [\n\n\t\t\tPromise.all( pendingNodes ),\n\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\tPromise.all( pendingSamplers ),\n\t\t\tPromise.all( pendingTargets )\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tconst nodes = dependencies[ 0 ];\n\t\t\tconst inputAccessors = dependencies[ 1 ];\n\t\t\tconst outputAccessors = dependencies[ 2 ];\n\t\t\tconst samplers = dependencies[ 3 ];\n\t\t\tconst targets = dependencies[ 4 ];\n\n\t\t\tconst tracks = [];\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\t\t\t\tconst inputAccessor = inputAccessors[ i ];\n\t\t\t\tconst outputAccessor = outputAccessors[ i ];\n\t\t\t\tconst sampler = samplers[ i ];\n\t\t\t\tconst target = targets[ i ];\n\n\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\tif ( node.updateMatrix ) {\n\n\t\t\t\t\tnode.updateMatrix();\n\t\t\t\t\tnode.matrixAutoUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tconst createdTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target );\n\n\t\t\t\tif ( createdTracks ) {\n\n\t\t\t\t\tfor ( let k = 0; k < createdTracks.length; k ++ ) {\n\n\t\t\t\t\t\ttracks.push( createdTracks[ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( animationName, undefined, tracks );\n\n\t\t} );\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( nodeDef.mesh === undefined ) return null;\n\n\t\treturn parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\n\n\t\t\tconst node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );\n\n\t\t\t// if weights are provided on the node, override weights on the mesh.\n\t\t\tif ( nodeDef.weights !== undefined ) {\n\n\t\t\t\tnode.traverse( function ( o ) {\n\n\t\t\t\t\tif ( ! o.isMesh ) return;\n\n\t\t\t\t\tfor ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t * @param {number} nodeIndex\n\t * @return {Promise<Object3D>}\n\t */\n\tloadNode( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tconst nodePending = parser._loadNodeShallow( nodeIndex );\n\n\t\tconst childPending = [];\n\t\tconst childrenDef = nodeDef.children || [];\n\n\t\tfor ( let i = 0, il = childrenDef.length; i < il; i ++ ) {\n\n\t\t\tchildPending.push( parser.getDependency( 'node', childrenDef[ i ] ) );\n\n\t\t}\n\n\t\tconst skeletonPending = nodeDef.skin === undefined\n\t\t\t? Promise.resolve( null )\n\t\t\t: parser.getDependency( 'skin', nodeDef.skin );\n\n\t\treturn Promise.all( [\n\t\t\tnodePending,\n\t\t\tPromise.all( childPending ),\n\t\t\tskeletonPending\n\t\t] ).then( function ( results ) {\n\n\t\t\tconst node = results[ 0 ];\n\t\t\tconst children = results[ 1 ];\n\t\t\tconst skeleton = results[ 2 ];\n\n\t\t\tif ( skeleton !== null ) {\n\n\t\t\t\t// This full traverse should be fine because\n\t\t\t\t// child glTF nodes have not been added to this node yet.\n\t\t\t\tnode.traverse( function ( mesh ) {\n\n\t\t\t\t\tif ( ! mesh.isSkinnedMesh ) return;\n\n\t\t\t\t\tmesh.bind( skeleton, _identityMatrix );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\tnode.add( children[ i ] );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t// ._loadNodeShallow() parses a single node.\n\t// skin and child nodes are created and added in .loadNode() (no '_' prefix).\n\t_loadNodeShallow( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst parser = this;\n\n\t\t// This method is called from .loadNode() and .loadSkin().\n\t\t// Cache a node to avoid duplication.\n\n\t\tif ( this.nodeCache[ nodeIndex ] !== undefined ) {\n\n\t\t\treturn this.nodeCache[ nodeIndex ];\n\n\t\t}\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\t// reserve node's name before its dependencies, so the root has the intended name.\n\t\tconst nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';\n\n\t\tconst pending = [];\n\n\t\tconst meshPromise = parser._invokeOne( function ( ext ) {\n\n\t\t\treturn ext.createNodeMesh && ext.createNodeMesh( nodeIndex );\n\n\t\t} );\n\n\t\tif ( meshPromise ) {\n\n\t\t\tpending.push( meshPromise );\n\n\t\t}\n\n\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {\n\n\t\t\t\treturn parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );\n\n\t\t\t} ) );\n\n\t\t}\n\n\t\tparser._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );\n\n\t\t} ).forEach( function ( promise ) {\n\n\t\t\tpending.push( promise );\n\n\t\t} );\n\n\t\tthis.nodeCache[ nodeIndex ] = Promise.all( pending ).then( function ( objects ) {\n\n\t\t\tlet node;\n\n\t\t\t// .isBone isn't in glTF spec. See ._markDefs\n\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\tnode = new Bone();\n\n\t\t\t} else if ( objects.length > 1 ) {\n\n\t\t\t\tnode = new Group();\n\n\t\t\t} else if ( objects.length === 1 ) {\n\n\t\t\t\tnode = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tnode = new Object3D();\n\n\t\t\t}\n\n\t\t\tif ( node !== objects[ 0 ] ) {\n\n\t\t\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\tnode.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.name ) {\n\n\t\t\t\tnode.userData.name = nodeDef.name;\n\t\t\t\tnode.name = nodeName;\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( node, nodeDef );\n\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\n\n\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\tconst matrix = new Matrix4();\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\tnode.applyMatrix4( matrix );\n\n\t\t\t} else {\n\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! parser.associations.has( node ) ) {\n\n\t\t\t\tparser.associations.set( node, {} );\n\n\t\t\t}\n\n\t\t\tparser.associations.get( node ).nodes = nodeIndex;\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t\treturn this.nodeCache[ nodeIndex ];\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t * @param {number} sceneIndex\n\t * @return {Promise<Group>}\n\t */\n\tloadScene( sceneIndex ) {\n\n\t\tconst extensions = this.extensions;\n\t\tconst sceneDef = this.json.scenes[ sceneIndex ];\n\t\tconst parser = this;\n\n\t\t// Loader returns Group, not Scene.\n\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\t\tconst scene = new Group();\n\t\tif ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );\n\n\t\tassignExtrasToUserData( scene, sceneDef );\n\n\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\n\n\t\tconst nodeIds = sceneDef.nodes || [];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\tpending.push( parser.getDependency( 'node', nodeIds[ i ] ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function ( nodes ) {\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tscene.add( nodes[ i ] );\n\n\t\t\t}\n\n\t\t\t// Removes dangling associations, associations that reference a node that\n\t\t\t// didn't make it into the scene.\n\t\t\tconst reduceAssociations = ( node ) => {\n\n\t\t\t\tconst reducedAssociations = new Map();\n\n\t\t\t\tfor ( const [ key, value ] of parser.associations ) {\n\n\t\t\t\t\tif ( key instanceof Material || key instanceof Texture ) {\n\n\t\t\t\t\t\treducedAssociations.set( key, value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnode.traverse( ( node ) => {\n\n\t\t\t\t\tconst mappings = parser.associations.get( node );\n\n\t\t\t\t\tif ( mappings != null ) {\n\n\t\t\t\t\t\treducedAssociations.set( node, mappings );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn reducedAssociations;\n\n\t\t\t};\n\n\t\t\tparser.associations = reduceAssociations( scene );\n\n\t\t\treturn scene;\n\n\t\t} );\n\n\t}\n\n\t_createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target ) {\n\n\t\tconst tracks = [];\n\n\t\tconst targetName = node.name ? node.name : node.uuid;\n\n\t\tconst targetNames = [];\n\n\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\tnode.traverse( function ( object ) {\n\n\t\t\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\ttargetNames.push( targetName );\n\n\t\t}\n\n\t\tlet TypedKeyframeTrack;\n\n\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\tTypedKeyframeTrack = QuaternionKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tcase PATH_PROPERTIES.position:\n\t\t\tcase PATH_PROPERTIES.scale:\n\t\t\tdefault:\n\t\t\t\tswitch ( outputAccessor.itemSize ) {\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tconst interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;\n\n\t\tconst outputArray = this._getArrayFromAccessor( outputAccessor );\n\n\t\tfor ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\tconst track = new TypedKeyframeTrack(\n\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\tinputAccessor.array,\n\t\t\t\toutputArray,\n\t\t\t\tinterpolation\n\t\t\t);\n\n\t\t\t// Override interpolation with custom factory method.\n\t\t\tif ( interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\tthis._createCubicSplineTrackInterpolant( track );\n\n\t\t\t}\n\n\t\t\ttracks.push( track );\n\n\t\t}\n\n\t\treturn tracks;\n\n\t}\n\n\t_getArrayFromAccessor( accessor ) {\n\n\t\tlet outputArray = accessor.array;\n\n\t\tif ( accessor.normalized ) {\n\n\t\t\tconst scale = getNormalizedComponentScale( outputArray.constructor );\n\t\t\tconst scaled = new Float32Array( outputArray.length );\n\n\t\t\tfor ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {\n\n\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\n\n\t\t\t}\n\n\t\t\toutputArray = scaled;\n\n\t\t}\n\n\t\treturn outputArray;\n\n\t}\n\n\t_createCubicSplineTrackInterpolant( track ) {\n\n\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\tconst interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n\n\t\t\treturn new interpolantType( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t};\n\n\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t}\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst box = new Box3();\n\n\tif ( attributes.POSITION !== undefined ) {\n\n\t\tconst accessor = parser.json.accessors[ attributes.POSITION ];\n\n\t\tconst min = accessor.min;\n\t\tconst max = accessor.max;\n\n\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\tbox.set(\n\t\t\t\tnew Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),\n\t\t\t\tnew Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )\n\t\t\t);\n\n\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\tbox.min.multiplyScalar( boxScale );\n\t\t\t\tbox.max.multiplyScalar( boxScale );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\treturn;\n\n\t\t}\n\n\t} else {\n\n\t\treturn;\n\n\t}\n\n\tconst targets = primitiveDef.targets;\n\n\tif ( targets !== undefined ) {\n\n\t\tconst maxDisplacement = new Vector3();\n\t\tconst vector = new Vector3();\n\n\t\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tconst target = targets[ i ];\n\n\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\tconst accessor = parser.json.accessors[ target.POSITION ];\n\t\t\t\tconst min = accessor.min;\n\t\t\t\tconst max = accessor.max;\n\n\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\n\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\n\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\n\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\n\n\n\t\t\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\t\t\tvector.multiplyScalar( boxScale );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\n\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\t\t\t\t\tmaxDisplacement.max( vector );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\t\tbox.expandByVector( maxDisplacement );\n\n\t}\n\n\tgeometry.boundingBox = box;\n\n\tconst sphere = new Sphere();\n\n\tbox.getCenter( sphere.center );\n\tsphere.radius = box.min.distanceTo( box.max ) / 2;\n\n\tgeometry.boundingSphere = sphere;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst pending = [];\n\n\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\n\n\t\treturn parser.getDependency( 'accessor', accessorIndex )\n\t\t\t.then( function ( accessor ) {\n\n\t\t\t\tgeometry.setAttribute( attributeName, accessor );\n\n\t\t\t} );\n\n\t}\n\n\tfor ( const gltfAttributeName in attributes ) {\n\n\t\tconst threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\n\n\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\n\n\t}\n\n\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\n\n\t\tconst accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\n\n\t\t\tgeometry.setIndex( accessor );\n\n\t\t} );\n\n\t\tpending.push( accessor );\n\n\t}\n\n\tassignExtrasToUserData( geometry, primitiveDef );\n\n\tcomputeBounds( geometry, primitiveDef, parser );\n\n\treturn Promise.all( pending ).then( function () {\n\n\t\treturn primitiveDef.targets !== undefined\n\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\n\t\t\t: geometry;\n\n\t} );\n\n}\n\nexport { GLTFLoader };\n","import * as THREE from 'three'\nimport {GLTFLoader} from 'three/examples/jsm/loaders/GLTFLoader.js'\n\n\nexport {\n    loadResource,\n};\n\n//Loader\nconst loadingManager = new THREE.LoadingManager(\n    () =>\n    {\n        document.getElementById(\"complete\").addEventListener(\"animationend\", function() {\n            document.getElementById(\"load\").style.cursor = \"auto\"\n            document.getElementById(\"load\").classList.remove(\"load-non\")\n            document.getElementById(\"load\").classList.add(\"load-active\")\n        }, false);\n\n        document.getElementById(\"load\").addEventListener('animationend', function(){\n            document.getElementById(\"load\").classList.add(\"hidden\")\n        }, false);\n    }\n)\n\nfunction loadResource(url) {\n    const extension = url.split('.').pop();\n    let loader;\n\n    switch (extension) {\n        case 'jpg':\n        case 'png':\n            loader = new THREE.TextureLoader(loadingManager);\n            break;\n        case 'glb':\n        case 'gltf':\n            loader = new GLTFLoader(loadingManager);\n            break;\n        case 'json':\n            loader = new THREE.FontLoader(loadingManager)\n            break;\n        case 'txt':\n            loader = new THREE.FileLoader(loadingManager)\n            break;\n        default:\n            return Promise.reject(new Error(`unknown resource type [${extension}]`));\n    }\n\n    return new Promise((resolve, reject) => {\n        const onLoad = (resource) => resolve(resource);\n        const onProgress = () => {};\n        const onError = (e) => {\n            console.error('Failed to load resource: ' + e.target.src);\n            reject(e);\n        };\n\n        loader.load(url, onLoad, onProgress, onError);\n    });\n}","import * as THREE from 'three'\n\nexport const cameraHelper = {\n    init: initCameraHelper,\n    switch: (oeuvre) => {},\n    update: () => {},\n};\n\nfunction initCameraHelper(camera, target, controllerScope, cameraId) {\n\n    cameraHelper.switch = (oeuvre, chassis) => {\n        switch (cameraId++) {\n            case 0:\n                console.info('Game camera');\n                camera.position.set(-50, 16.5, 15);\n                camera.fov = 90;\n                cameraHelper.update = () => \n                {\n                    camera.lookAt(target.position)\n                    camera.position.set(target.position.x + 50, target.position.y + 50, target.position.z - 50)\n                };\n\n                // target.remove(camera);\n                // camera.fov = 70;\n                // cameraHelper.update = initChaseCamera(camera, target);\n                break;\n            case 1:\n                console.info('No camera');\n                break;\n            case 2:\n                console.info('Galerie camera');\n                target.add(camera);\n                camera.position.set(0, 4.5, -15);\n                camera.rotation.set(0, 3.1, 0);\n                camera.fov = 50;\n                cameraHelper.update = () => {};\n                break;\n            case 3:\n                console.log('Oeuvre camera')\n                target.remove(camera)\n                oeuvre.object.add(camera)\n                camera.position.set(-10, 15, 150);\n                camera.rotation.set(0, 0, 0);\n                camera.fov = 90;\n                cameraHelper.update = () => {};\n                break;\n            case 4:\n                console.log('Camera Mentions Lgales')\n                target.add(camera);\n                camera.position.set(-25, 10.5, 15);\n                camera.rotation.set(0, 4.65, 0);\n                camera.fov = 90;\n                cameraHelper.update = () => {};\n                break;\n            case 5:\n                console.log('Camera Hub')\n                camera.position.set(-50, 16.5, 15);\n                camera.fov = 90;\n                cameraHelper.update = () => \n                {\n                    camera.lookAt(target.position)\n                    camera.position.set(target.position.x, target.position.y + 35, target.position.z + 60)\n                };\n                break;\n            default:\n                cameraId = 0;\n                cameraHelper.switch();\n        }\n    }\n\n    cameraHelper.switch();\n}\n\nfunction initChaseCamera(camera, target) {\n    const cameraMovementSpeed = 0.05; \n    const cameraLookPositionHeightOffset = 5;\n    const cameraMountPosition = new THREE.Vector3();\n    const cameraLookPosition = new THREE.Vector3();\n    const chaseCameraMountPositionHelper = new THREE.Object3D();\n    chaseCameraMountPositionHelper.position.set(-30, 25, -5);\n    target.add(chaseCameraMountPositionHelper);\n\n    return () => {\n        chaseCameraMountPositionHelper.getWorldPosition(cameraMountPosition);\n\n        if (cameraMountPosition.y < target.position.y) {\n            cameraMountPosition.setY(target.position.y);\n        }\n\n        camera.position.lerp(cameraMountPosition, cameraMovementSpeed);\n        cameraLookPosition.copy(target.position).y += cameraLookPositionHeightOffset;\n\n        camera.lookAt(cameraLookPosition);\n    };\n}\n","function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/*!\n * GSAP 3.12.2\n * https://greensock.com\n *\n * @license Copyright 2008-2023, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar _config = {\n  autoSleep: 120,\n  force3D: \"auto\",\n  nullTargetWarn: 1,\n  units: {\n    lineHeight: \"\"\n  }\n},\n    _defaults = {\n  duration: .5,\n  overwrite: false,\n  delay: 0\n},\n    _suppressOverwrites,\n    _reverting,\n    _context,\n    _bigNum = 1e8,\n    _tinyNum = 1 / _bigNum,\n    _2PI = Math.PI * 2,\n    _HALF_PI = _2PI / 4,\n    _gsID = 0,\n    _sqrt = Math.sqrt,\n    _cos = Math.cos,\n    _sin = Math.sin,\n    _isString = function _isString(value) {\n  return typeof value === \"string\";\n},\n    _isFunction = function _isFunction(value) {\n  return typeof value === \"function\";\n},\n    _isNumber = function _isNumber(value) {\n  return typeof value === \"number\";\n},\n    _isUndefined = function _isUndefined(value) {\n  return typeof value === \"undefined\";\n},\n    _isObject = function _isObject(value) {\n  return typeof value === \"object\";\n},\n    _isNotFalse = function _isNotFalse(value) {\n  return value !== false;\n},\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _isFuncOrString = function _isFuncOrString(value) {\n  return _isFunction(value) || _isString(value);\n},\n    _isTypedArray = typeof ArrayBuffer === \"function\" && ArrayBuffer.isView || function () {},\n    // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().\n_isArray = Array.isArray,\n    _strictNumExp = /(?:-?\\.?\\d|\\.)+/gi,\n    //only numbers (including negatives and decimals) but NOT relative values.\n_numExp = /[-+=.]*\\d+[.e\\-+]*\\d*[e\\-+]*\\d*/g,\n    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\n_numWithUnitExp = /[-+=.]*\\d+[.e-]*\\d*[a-z%]*/g,\n    _complexStringNumExp = /[-+=.]*\\d+\\.?\\d*(?:e-|e\\+)?\\d*/gi,\n    //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.\n_relExp = /[+-]=-?[.\\d]+/,\n    _delimitedValueExp = /[^,'\"\\[\\]\\s]+/gi,\n    // previously /[#\\-+.]*\\b[a-z\\d\\-=+%.]+/gi but didn't catch special characters.\n_unitExp = /^[+\\-=e\\s\\d]*\\d+[.\\d]*([a-z]*|%)\\s*$/i,\n    _globalTimeline,\n    _win,\n    _coreInitted,\n    _doc,\n    _globals = {},\n    _installScope = {},\n    _coreReady,\n    _install = function _install(scope) {\n  return (_installScope = _merge(scope, _globals)) && gsap;\n},\n    _missingPlugin = function _missingPlugin(property, value) {\n  return console.warn(\"Invalid property\", property, \"set to\", value, \"Missing plugin? gsap.registerPlugin()\");\n},\n    _warn = function _warn(message, suppress) {\n  return !suppress && console.warn(message);\n},\n    _addGlobal = function _addGlobal(name, obj) {\n  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;\n},\n    _emptyFunc = function _emptyFunc() {\n  return 0;\n},\n    _startAtRevertConfig = {\n  suppressEvents: true,\n  isStart: true,\n  kill: false\n},\n    _revertConfigNoKill = {\n  suppressEvents: true,\n  kill: false\n},\n    _revertConfig = {\n  suppressEvents: true\n},\n    _reservedProps = {},\n    _lazyTweens = [],\n    _lazyLookup = {},\n    _lastRenderedFrame,\n    _plugins = {},\n    _effects = {},\n    _nextGCFrame = 30,\n    _harnessPlugins = [],\n    _callbackNames = \"\",\n    _harness = function _harness(targets) {\n  var target = targets[0],\n      harnessPlugin,\n      i;\n  _isObject(target) || _isFunction(target) || (targets = [targets]);\n\n  if (!(harnessPlugin = (target._gsap || {}).harness)) {\n    // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)\n    i = _harnessPlugins.length;\n\n    while (i-- && !_harnessPlugins[i].targetTest(target)) {}\n\n    harnessPlugin = _harnessPlugins[i];\n  }\n\n  i = targets.length;\n\n  while (i--) {\n    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);\n  }\n\n  return targets;\n},\n    _getCache = function _getCache(target) {\n  return target._gsap || _harness(toArray(target))[0]._gsap;\n},\n    _getProperty = function _getProperty(target, property, v) {\n  return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;\n},\n    _forEachName = function _forEachName(names, func) {\n  return (names = names.split(\",\")).forEach(func) || names;\n},\n    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).\n_round = function _round(value) {\n  return Math.round(value * 100000) / 100000 || 0;\n},\n    _roundPrecise = function _roundPrecise(value) {\n  return Math.round(value * 10000000) / 10000000 || 0;\n},\n    // increased precision mostly for timing values.\n_parseRelative = function _parseRelative(start, value) {\n  var operator = value.charAt(0),\n      end = parseFloat(value.substr(2));\n  start = parseFloat(start);\n  return operator === \"+\" ? start + end : operator === \"-\" ? start - end : operator === \"*\" ? start * end : start / end;\n},\n    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {\n  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.\n  var l = toFind.length,\n      i = 0;\n\n  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}\n\n  return i < l;\n},\n    _lazyRender = function _lazyRender() {\n  var l = _lazyTweens.length,\n      a = _lazyTweens.slice(0),\n      i,\n      tween;\n\n  _lazyLookup = {};\n  _lazyTweens.length = 0;\n\n  for (i = 0; i < l; i++) {\n    tween = a[i];\n    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);\n  }\n},\n    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {\n  _lazyTweens.length && !_reverting && _lazyRender();\n  animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));\n  _lazyTweens.length && !_reverting && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.\n},\n    _numericIfPossible = function _numericIfPossible(value) {\n  var n = parseFloat(value);\n  return (n || n === 0) && (value + \"\").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;\n},\n    _passThrough = function _passThrough(p) {\n  return p;\n},\n    _setDefaults = function _setDefaults(obj, defaults) {\n  for (var p in defaults) {\n    p in obj || (obj[p] = defaults[p]);\n  }\n\n  return obj;\n},\n    _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {\n  return function (obj, defaults) {\n    for (var p in defaults) {\n      p in obj || p === \"duration\" && excludeDuration || p === \"ease\" || (obj[p] = defaults[p]);\n    }\n  };\n},\n    _merge = function _merge(base, toMerge) {\n  for (var p in toMerge) {\n    base[p] = toMerge[p];\n  }\n\n  return base;\n},\n    _mergeDeep = function _mergeDeep(base, toMerge) {\n  for (var p in toMerge) {\n    p !== \"__proto__\" && p !== \"constructor\" && p !== \"prototype\" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);\n  }\n\n  return base;\n},\n    _copyExcluding = function _copyExcluding(obj, excluding) {\n  var copy = {},\n      p;\n\n  for (p in obj) {\n    p in excluding || (copy[p] = obj[p]);\n  }\n\n  return copy;\n},\n    _inheritDefaults = function _inheritDefaults(vars) {\n  var parent = vars.parent || _globalTimeline,\n      func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;\n\n  if (_isNotFalse(vars.inherit)) {\n    while (parent) {\n      func(vars, parent.vars.defaults);\n      parent = parent.parent || parent._dp;\n    }\n  }\n\n  return vars;\n},\n    _arraysMatch = function _arraysMatch(a1, a2) {\n  var i = a1.length,\n      match = i === a2.length;\n\n  while (match && i-- && a1[i] === a2[i]) {}\n\n  return i < 0;\n},\n    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {\n  if (firstProp === void 0) {\n    firstProp = \"_first\";\n  }\n\n  if (lastProp === void 0) {\n    lastProp = \"_last\";\n  }\n\n  var prev = parent[lastProp],\n      t;\n\n  if (sortBy) {\n    t = child[sortBy];\n\n    while (prev && prev[sortBy] > t) {\n      prev = prev._prev;\n    }\n  }\n\n  if (prev) {\n    child._next = prev._next;\n    prev._next = child;\n  } else {\n    child._next = parent[firstProp];\n    parent[firstProp] = child;\n  }\n\n  if (child._next) {\n    child._next._prev = child;\n  } else {\n    parent[lastProp] = child;\n  }\n\n  child._prev = prev;\n  child.parent = child._dp = parent;\n  return child;\n},\n    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {\n  if (firstProp === void 0) {\n    firstProp = \"_first\";\n  }\n\n  if (lastProp === void 0) {\n    lastProp = \"_last\";\n  }\n\n  var prev = child._prev,\n      next = child._next;\n\n  if (prev) {\n    prev._next = next;\n  } else if (parent[firstProp] === child) {\n    parent[firstProp] = next;\n  }\n\n  if (next) {\n    next._prev = prev;\n  } else if (parent[lastProp] === child) {\n    parent[lastProp] = prev;\n  }\n\n  child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.\n},\n    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {\n  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);\n  child._act = 0;\n},\n    _uncache = function _uncache(animation, child) {\n  if (animation && (!child || child._end > animation._dur || child._start < 0)) {\n    // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)\n    var a = animation;\n\n    while (a) {\n      a._dirty = 1;\n      a = a.parent;\n    }\n  }\n\n  return animation;\n},\n    _recacheAncestors = function _recacheAncestors(animation) {\n  var parent = animation.parent;\n\n  while (parent && parent.parent) {\n    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.\n    parent._dirty = 1;\n    parent.totalDuration();\n    parent = parent.parent;\n  }\n\n  return animation;\n},\n    _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {\n  return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));\n},\n    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {\n  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);\n},\n    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {\n  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;\n},\n    // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.\n_animationCycle = function _animationCycle(tTime, cycleDuration) {\n  var whole = Math.floor(tTime /= cycleDuration);\n  return tTime && whole === tTime ? whole - 1 : whole;\n},\n    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {\n  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);\n},\n    _setEnd = function _setEnd(animation) {\n  return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));\n},\n    _alignPlayhead = function _alignPlayhead(animation, totalTime) {\n  // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.\n  var parent = animation._dp;\n\n  if (parent && parent.smoothChildTiming && animation._ts) {\n    animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));\n\n    _setEnd(animation);\n\n    parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.\n  }\n\n  return animation;\n},\n\n/*\n_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {\n\tlet cycleDuration = duration + repeatDelay,\n\t\ttime = _round(clampedTotalTime % cycleDuration);\n\tif (time > duration) {\n\t\ttime = duration;\n\t}\n\treturn (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;\n},\n*/\n_postAddChecks = function _postAddChecks(timeline, child) {\n  var t;\n\n  if (child._time || !child._dur && child._initted || child._start < timeline._time && (child._dur || !child.add)) {\n    // in case, for example, the _start is moved on a tween that has already rendered, or if it's being inserted into a timeline BEFORE where the playhead is currently. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning. Special case: if it's a timeline (has .add() method) and no duration, we can skip rendering because the user may be populating it AFTER adding it to a parent timeline (unconventional, but possible, and we wouldn't want it to get removed if the parent's autoRemoveChildren is true).\n    t = _parentToChildTotalTime(timeline.rawTime(), child);\n\n    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {\n      child.render(t, true);\n    }\n  } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.\n\n\n  if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {\n    //in case any of the ancestors had completed but should now be enabled...\n    if (timeline._dur < timeline.duration()) {\n      t = timeline;\n\n      while (t._dp) {\n        t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.\n\n        t = t._dp;\n      }\n    }\n\n    timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.\n  }\n},\n    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {\n  child.parent && _removeFromParent(child);\n  child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);\n  child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));\n\n  _addLinkedListItem(timeline, child, \"_first\", \"_last\", timeline._sort ? \"_start\" : 0);\n\n  _isFromOrFromStart(child) || (timeline._recent = child);\n  skipChecks || _postAddChecks(timeline, child);\n  timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime); // if the timeline is reversed and the new child makes it longer, we may need to adjust the parent's _start (push it back)\n\n  return timeline;\n},\n    _scrollTrigger = function _scrollTrigger(animation, trigger) {\n  return (_globals.ScrollTrigger || _missingPlugin(\"scrollTrigger\", trigger)) && _globals.ScrollTrigger.create(trigger, animation);\n},\n    _attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {\n  _initTween(tween, time, tTime);\n\n  if (!tween._initted) {\n    return 1;\n  }\n\n  if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {\n    _lazyTweens.push(tween);\n\n    tween._lazy = [tTime, suppressEvents];\n    return 1;\n  }\n},\n    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {\n  var parent = _ref.parent;\n  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));\n},\n    // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0\n_isFromOrFromStart = function _isFromOrFromStart(_ref2) {\n  var data = _ref2.data;\n  return data === \"isFromStart\" || data === \"isStart\";\n},\n    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {\n  var prevRatio = tween.ratio,\n      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,\n      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the \"startAt\" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any \"from\" and \"fromTo\" startAt tweens are rendered the first time at a ratio of 1.\n  repeatDelay = tween._rDelay,\n      tTime = 0,\n      pt,\n      iteration,\n      prevIteration;\n\n  if (repeatDelay && tween._repeat) {\n    // in case there's a zero-duration tween that has a repeat with a repeatDelay\n    tTime = _clamp(0, tween._tDur, totalTime);\n    iteration = _animationCycle(tTime, repeatDelay);\n    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);\n\n    if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {\n      // if iteration changed\n      prevRatio = 1 - ratio;\n      tween.vars.repeatRefresh && tween._initted && tween.invalidate();\n    }\n  }\n\n  if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {\n    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {\n      // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.\n      return;\n    }\n\n    prevIteration = tween._zTime;\n    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\n\n    suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.\n\n    tween.ratio = ratio;\n    tween._from && (ratio = 1 - ratio);\n    tween._time = 0;\n    tween._tTime = tTime;\n    pt = tween._pt;\n\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n\n    totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);\n    tween._onUpdate && !suppressEvents && _callback(tween, \"onUpdate\");\n    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, \"onRepeat\");\n\n    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {\n      ratio && _removeFromParent(tween, 1);\n\n      if (!suppressEvents && !_reverting) {\n        _callback(tween, ratio ? \"onComplete\" : \"onReverseComplete\", true);\n\n        tween._prom && tween._prom();\n      }\n    }\n  } else if (!tween._zTime) {\n    tween._zTime = totalTime;\n  }\n},\n    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {\n  var child;\n\n  if (time > prevTime) {\n    child = animation._first;\n\n    while (child && child._start <= time) {\n      if (child.data === \"isPause\" && child._start > prevTime) {\n        return child;\n      }\n\n      child = child._next;\n    }\n  } else {\n    child = animation._last;\n\n    while (child && child._start >= time) {\n      if (child.data === \"isPause\" && child._start < prevTime) {\n        return child;\n      }\n\n      child = child._prev;\n    }\n  }\n},\n    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {\n  var repeat = animation._repeat,\n      dur = _roundPrecise(duration) || 0,\n      totalProgress = animation._tTime / animation._tDur;\n  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);\n  animation._dur = dur;\n  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);\n  totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);\n  animation.parent && _setEnd(animation);\n  skipUncache || _uncache(animation.parent, animation);\n  return animation;\n},\n    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {\n  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);\n},\n    _zeroPosition = {\n  _start: 0,\n  endTime: _emptyFunc,\n  totalDuration: _emptyFunc\n},\n    _parsePosition = function _parsePosition(animation, position, percentAnimation) {\n  var labels = animation.labels,\n      recent = animation._recent || _zeroPosition,\n      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,\n      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.\n  i,\n      offset,\n      isPercent;\n\n  if (_isString(position) && (isNaN(position) || position in labels)) {\n    //if the string is a number like \"1\", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).\n    offset = position.charAt(0);\n    isPercent = position.substr(-1) === \"%\";\n    i = position.indexOf(\"=\");\n\n    if (offset === \"<\" || offset === \">\") {\n      i >= 0 && (position = position.replace(/=/, \"\"));\n      return (offset === \"<\" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);\n    }\n\n    if (i < 0) {\n      position in labels || (labels[position] = clippedDuration);\n      return labels[position];\n    }\n\n    offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));\n\n    if (isPercent && percentAnimation) {\n      offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();\n    }\n\n    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;\n  }\n\n  return position == null ? clippedDuration : +position;\n},\n    _createTweenType = function _createTweenType(type, params, timeline) {\n  var isLegacy = _isNumber(params[1]),\n      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),\n      vars = params[varsIndex],\n      irVars,\n      parent;\n\n  isLegacy && (vars.duration = params[1]);\n  vars.parent = timeline;\n\n  if (type) {\n    irVars = vars;\n    parent = timeline;\n\n    while (parent && !(\"immediateRender\" in irVars)) {\n      // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.\n      irVars = parent.vars.defaults || {};\n      parent = _isNotFalse(parent.vars.inherit) && parent.parent;\n    }\n\n    vars.immediateRender = _isNotFalse(irVars.immediateRender);\n    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // \"from\" vars\n  }\n\n  return new Tween(params[0], vars, params[varsIndex + 1]);\n},\n    _conditionalReturn = function _conditionalReturn(value, func) {\n  return value || value === 0 ? func(value) : func;\n},\n    _clamp = function _clamp(min, max, value) {\n  return value < min ? min : value > max ? max : value;\n},\n    getUnit = function getUnit(value, v) {\n  return !_isString(value) || !(v = _unitExp.exec(value)) ? \"\" : v[1];\n},\n    // note: protect against padded numbers as strings, like \"100.100\". That shouldn't return \"00\" as the unit. If it's numeric, return no unit.\nclamp = function clamp(min, max, value) {\n  return _conditionalReturn(value, function (v) {\n    return _clamp(min, max, v);\n  });\n},\n    _slice = [].slice,\n    _isArrayLike = function _isArrayLike(value, nonEmpty) {\n  return value && _isObject(value) && \"length\" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;\n},\n    _flatten = function _flatten(ar, leaveStrings, accumulator) {\n  if (accumulator === void 0) {\n    accumulator = [];\n  }\n\n  return ar.forEach(function (value) {\n    var _accumulator;\n\n    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);\n  }) || accumulator;\n},\n    //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.\ntoArray = function toArray(value, scope, leaveStrings) {\n  return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];\n},\n    selector = function selector(value) {\n  value = toArray(value)[0] || _warn(\"Invalid scope\") || {};\n  return function (v) {\n    var el = value.current || value.nativeElement || value;\n    return toArray(v, el.querySelectorAll ? el : el === value ? _warn(\"Invalid scope\") || _doc.createElement(\"div\") : value);\n  };\n},\n    shuffle = function shuffle(a) {\n  return a.sort(function () {\n    return .5 - Math.random();\n  });\n},\n    // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;\n//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following\ndistribute = function distribute(v) {\n  if (_isFunction(v)) {\n    return v;\n  }\n\n  var vars = _isObject(v) ? v : {\n    each: v\n  },\n      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total \"amount\" that's chunked out among them all.\n  ease = _parseEase(vars.ease),\n      from = vars.from || 0,\n      base = parseFloat(vars.base) || 0,\n      cache = {},\n      isDecimal = from > 0 && from < 1,\n      ratios = isNaN(from) || isDecimal,\n      axis = vars.axis,\n      ratioX = from,\n      ratioY = from;\n\n  if (_isString(from)) {\n    ratioX = ratioY = {\n      center: .5,\n      edges: .5,\n      end: 1\n    }[from] || 0;\n  } else if (!isDecimal && ratios) {\n    ratioX = from[0];\n    ratioY = from[1];\n  }\n\n  return function (i, target, a) {\n    var l = (a || vars).length,\n        distances = cache[l],\n        originX,\n        originY,\n        x,\n        y,\n        d,\n        j,\n        max,\n        min,\n        wrapAt;\n\n    if (!distances) {\n      wrapAt = vars.grid === \"auto\" ? 0 : (vars.grid || [1, _bigNum])[1];\n\n      if (!wrapAt) {\n        max = -_bigNum;\n\n        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}\n\n        wrapAt--;\n      }\n\n      distances = cache[l] = [];\n      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;\n      originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;\n      max = 0;\n      min = _bigNum;\n\n      for (j = 0; j < l; j++) {\n        x = j % wrapAt - originX;\n        y = originY - (j / wrapAt | 0);\n        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === \"y\" ? y : x);\n        d > max && (max = d);\n        d < min && (min = d);\n      }\n\n      from === \"random\" && shuffle(distances);\n      distances.max = max - min;\n      distances.min = min;\n      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === \"y\" ? l / wrapAt : wrapAt) || 0) * (from === \"edges\" ? -1 : 1);\n      distances.b = l < 0 ? base - l : base;\n      distances.u = getUnit(vars.amount || vars.each) || 0; //unit\n\n      ease = ease && l < 0 ? _invertEase(ease) : ease;\n    }\n\n    l = (distances[i] - distances.min) / distances.max || 0;\n    return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors\n  };\n},\n    _roundModifier = function _roundModifier(v) {\n  //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.\n  var p = Math.pow(10, ((v + \"\").split(\".\")[1] || \"\").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())\n\n  return function (raw) {\n    var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);\n\n    return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!\n  };\n},\n    snap = function snap(snapTo, value) {\n  var isArray = _isArray(snapTo),\n      radius,\n      is2D;\n\n  if (!isArray && _isObject(snapTo)) {\n    radius = isArray = snapTo.radius || _bigNum;\n\n    if (snapTo.values) {\n      snapTo = toArray(snapTo.values);\n\n      if (is2D = !_isNumber(snapTo[0])) {\n        radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.\n      }\n    } else {\n      snapTo = _roundModifier(snapTo.increment);\n    }\n  }\n\n  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {\n    is2D = snapTo(raw);\n    return Math.abs(is2D - raw) <= radius ? is2D : raw;\n  } : function (raw) {\n    var x = parseFloat(is2D ? raw.x : raw),\n        y = parseFloat(is2D ? raw.y : 0),\n        min = _bigNum,\n        closest = 0,\n        i = snapTo.length,\n        dx,\n        dy;\n\n    while (i--) {\n      if (is2D) {\n        dx = snapTo[i].x - x;\n        dy = snapTo[i].y - y;\n        dx = dx * dx + dy * dy;\n      } else {\n        dx = Math.abs(snapTo[i] - x);\n      }\n\n      if (dx < min) {\n        min = dx;\n        closest = i;\n      }\n    }\n\n    closest = !radius || min <= radius ? snapTo[closest] : raw;\n    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);\n  });\n},\n    random = function random(min, max, roundingIncrement, returnFunction) {\n  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {\n    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + \"\").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;\n  });\n},\n    pipe = function pipe() {\n  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {\n    functions[_key] = arguments[_key];\n  }\n\n  return function (value) {\n    return functions.reduce(function (v, f) {\n      return f(v);\n    }, value);\n  };\n},\n    unitize = function unitize(func, unit) {\n  return function (value) {\n    return func(parseFloat(value)) + (unit || getUnit(value));\n  };\n},\n    normalize = function normalize(min, max, value) {\n  return mapRange(min, max, 0, 1, value);\n},\n    _wrapArray = function _wrapArray(a, wrapper, value) {\n  return _conditionalReturn(value, function (index) {\n    return a[~~wrapper(index)];\n  });\n},\n    wrap = function wrap(min, max, value) {\n  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).\n  var range = max - min;\n  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {\n    return (range + (value - min) % range) % range + min;\n  });\n},\n    wrapYoyo = function wrapYoyo(min, max, value) {\n  var range = max - min,\n      total = range * 2;\n  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {\n    value = (total + (value - min) % total) % total || 0;\n    return min + (value > range ? total - value : value);\n  });\n},\n    _replaceRandom = function _replaceRandom(value) {\n  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])\n  var prev = 0,\n      s = \"\",\n      i,\n      nums,\n      end,\n      isArray;\n\n  while (~(i = value.indexOf(\"random(\", prev))) {\n    end = value.indexOf(\")\", i);\n    isArray = value.charAt(i + 7) === \"[\";\n    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);\n    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);\n    prev = end + 1;\n  }\n\n  return s + value.substr(prev, value.length - prev);\n},\n    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {\n  var inRange = inMax - inMin,\n      outRange = outMax - outMin;\n  return _conditionalReturn(value, function (value) {\n    return outMin + ((value - inMin) / inRange * outRange || 0);\n  });\n},\n    interpolate = function interpolate(start, end, progress, mutate) {\n  var func = isNaN(start + end) ? 0 : function (p) {\n    return (1 - p) * start + p * end;\n  };\n\n  if (!func) {\n    var isString = _isString(start),\n        master = {},\n        p,\n        i,\n        interpolators,\n        l,\n        il;\n\n    progress === true && (mutate = 1) && (progress = null);\n\n    if (isString) {\n      start = {\n        p: start\n      };\n      end = {\n        p: end\n      };\n    } else if (_isArray(start) && !_isArray(end)) {\n      interpolators = [];\n      l = start.length;\n      il = l - 2;\n\n      for (i = 1; i < l; i++) {\n        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.\n      }\n\n      l--;\n\n      func = function func(p) {\n        p *= l;\n        var i = Math.min(il, ~~p);\n        return interpolators[i](p - i);\n      };\n\n      progress = end;\n    } else if (!mutate) {\n      start = _merge(_isArray(start) ? [] : {}, start);\n    }\n\n    if (!interpolators) {\n      for (p in end) {\n        _addPropTween.call(master, start, p, \"get\", end[p]);\n      }\n\n      func = function func(p) {\n        return _renderPropTweens(p, master) || (isString ? start.p : start);\n      };\n    }\n  }\n\n  return _conditionalReturn(progress, func);\n},\n    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {\n  //used for nextLabel() and previousLabel()\n  var labels = timeline.labels,\n      min = _bigNum,\n      p,\n      distance,\n      label;\n\n  for (p in labels) {\n    distance = labels[p] - fromTime;\n\n    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {\n      label = p;\n      min = distance;\n    }\n  }\n\n  return label;\n},\n    _callback = function _callback(animation, type, executeLazyFirst) {\n  var v = animation.vars,\n      callback = v[type],\n      prevContext = _context,\n      context = animation._ctx,\n      params,\n      scope,\n      result;\n\n  if (!callback) {\n    return;\n  }\n\n  params = v[type + \"Params\"];\n  scope = v.callbackScope || animation;\n  executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.\n\n  context && (_context = context);\n  result = params ? callback.apply(scope, params) : callback.call(scope);\n  _context = prevContext;\n  return result;\n},\n    _interrupt = function _interrupt(animation) {\n  _removeFromParent(animation);\n\n  animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);\n  animation.progress() < 1 && _callback(animation, \"onInterrupt\");\n  return animation;\n},\n    _quickTween,\n    _registerPluginQueue = [],\n    _createPlugin = function _createPlugin(config) {\n  if (_windowExists() && config) {\n    // edge case: some build tools may pass in a null/undefined value\n    config = !config.name && config[\"default\"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.\n\n    var name = config.name,\n        isFunc = _isFunction(config),\n        Plugin = name && !isFunc && config.init ? function () {\n      this._props = [];\n    } : config,\n        //in case someone passes in an object that's not a plugin, like CustomEase\n    instanceDefaults = {\n      init: _emptyFunc,\n      render: _renderPropTweens,\n      add: _addPropTween,\n      kill: _killPropTweensOf,\n      modifier: _addPluginModifier,\n      rawVars: 0\n    },\n        statics = {\n      targetTest: 0,\n      get: 0,\n      getSetter: _getSetter,\n      aliases: {},\n      register: 0\n    };\n\n    _wake();\n\n    if (config !== Plugin) {\n      if (_plugins[name]) {\n        return;\n      }\n\n      _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods\n\n\n      _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods\n\n\n      _plugins[Plugin.prop = name] = Plugin;\n\n      if (config.targetTest) {\n        _harnessPlugins.push(Plugin);\n\n        _reservedProps[name] = 1;\n      }\n\n      name = (name === \"css\" ? \"CSS\" : name.charAt(0).toUpperCase() + name.substr(1)) + \"Plugin\"; //for the global name. \"motionPath\" should become MotionPathPlugin\n    }\n\n    _addGlobal(name, Plugin);\n\n    config.register && config.register(gsap, Plugin, PropTween);\n  } else {\n    config && _registerPluginQueue.push(config);\n  }\n},\n\n/*\n * --------------------------------------------------------------------------------------\n * COLORS\n * --------------------------------------------------------------------------------------\n */\n_255 = 255,\n    _colorLookup = {\n  aqua: [0, _255, _255],\n  lime: [0, _255, 0],\n  silver: [192, 192, 192],\n  black: [0, 0, 0],\n  maroon: [128, 0, 0],\n  teal: [0, 128, 128],\n  blue: [0, 0, _255],\n  navy: [0, 0, 128],\n  white: [_255, _255, _255],\n  olive: [128, 128, 0],\n  yellow: [_255, _255, 0],\n  orange: [_255, 165, 0],\n  gray: [128, 128, 128],\n  purple: [128, 0, 128],\n  green: [0, 128, 0],\n  red: [_255, 0, 0],\n  pink: [_255, 192, 203],\n  cyan: [0, _255, _255],\n  transparent: [_255, _255, _255, 0]\n},\n    // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:\n// let ctx = _doc.createElement(\"canvas\").getContext(\"2d\");\n// _forEachName(\"aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan\", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});\n_hue = function _hue(h, m1, m2) {\n  h += h < 0 ? 1 : h > 1 ? -1 : 0;\n  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;\n},\n    splitColor = function splitColor(v, toHSL, forceAlpha) {\n  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,\n      r,\n      g,\n      b,\n      h,\n      s,\n      l,\n      max,\n      min,\n      d,\n      wasHSL;\n\n  if (!a) {\n    if (v.substr(-1) === \",\") {\n      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:\"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)\" - in this example \"blue,\" has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.\n      v = v.substr(0, v.length - 1);\n    }\n\n    if (_colorLookup[v]) {\n      a = _colorLookup[v];\n    } else if (v.charAt(0) === \"#\") {\n      if (v.length < 6) {\n        //for shorthand like #9F0 or #9F0F (could have alpha)\n        r = v.charAt(1);\n        g = v.charAt(2);\n        b = v.charAt(3);\n        v = \"#\" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : \"\");\n      }\n\n      if (v.length === 9) {\n        // hex with alpha, like #fd5e53ff\n        a = parseInt(v.substr(1, 6), 16);\n        return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];\n      }\n\n      v = parseInt(v.substr(1), 16);\n      a = [v >> 16, v >> 8 & _255, v & _255];\n    } else if (v.substr(0, 3) === \"hsl\") {\n      a = wasHSL = v.match(_strictNumExp);\n\n      if (!toHSL) {\n        h = +a[0] % 360 / 360;\n        s = +a[1] / 100;\n        l = +a[2] / 100;\n        g = l <= .5 ? l * (s + 1) : l + s - l * s;\n        r = l * 2 - g;\n        a.length > 3 && (a[3] *= 1); //cast as number\n\n        a[0] = _hue(h + 1 / 3, r, g);\n        a[1] = _hue(h, r, g);\n        a[2] = _hue(h - 1 / 3, r, g);\n      } else if (~v.indexOf(\"=\")) {\n        //if relative values are found, just return the raw strings with the relative prefixes in place.\n        a = v.match(_numExp);\n        forceAlpha && a.length < 4 && (a[3] = 1);\n        return a;\n      }\n    } else {\n      a = v.match(_strictNumExp) || _colorLookup.transparent;\n    }\n\n    a = a.map(Number);\n  }\n\n  if (toHSL && !wasHSL) {\n    r = a[0] / _255;\n    g = a[1] / _255;\n    b = a[2] / _255;\n    max = Math.max(r, g, b);\n    min = Math.min(r, g, b);\n    l = (max + min) / 2;\n\n    if (max === min) {\n      h = s = 0;\n    } else {\n      d = max - min;\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;\n      h *= 60;\n    }\n\n    a[0] = ~~(h + .5);\n    a[1] = ~~(s * 100 + .5);\n    a[2] = ~~(l * 100 + .5);\n  }\n\n  forceAlpha && a.length < 4 && (a[3] = 1);\n  return a;\n},\n    _colorOrderData = function _colorOrderData(v) {\n  // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a \"c\" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()\n  var values = [],\n      c = [],\n      i = -1;\n  v.split(_colorExp).forEach(function (v) {\n    var a = v.match(_numWithUnitExp) || [];\n    values.push.apply(values, a);\n    c.push(i += a.length + 1);\n  });\n  values.c = c;\n  return values;\n},\n    _formatColors = function _formatColors(s, toHSL, orderMatchData) {\n  var result = \"\",\n      colors = (s + result).match(_colorExp),\n      type = toHSL ? \"hsla(\" : \"rgba(\",\n      i = 0,\n      c,\n      shell,\n      d,\n      l;\n\n  if (!colors) {\n    return s;\n  }\n\n  colors = colors.map(function (color) {\n    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + \",\" + color[1] + \"%,\" + color[2] + \"%,\" + color[3] : color.join(\",\")) + \")\";\n  });\n\n  if (orderMatchData) {\n    d = _colorOrderData(s);\n    c = orderMatchData.c;\n\n    if (c.join(result) !== d.c.join(result)) {\n      shell = s.replace(_colorExp, \"1\").split(_numWithUnitExp);\n      l = shell.length - 1;\n\n      for (; i < l; i++) {\n        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + \"0,0,0,0)\" : (d.length ? d : colors.length ? colors : orderMatchData).shift());\n      }\n    }\n  }\n\n  if (!shell) {\n    shell = s.split(_colorExp);\n    l = shell.length - 1;\n\n    for (; i < l; i++) {\n      result += shell[i] + colors[i];\n    }\n  }\n\n  return result + shell[l];\n},\n    _colorExp = function () {\n  var s = \"(?:\\\\b(?:(?:rgb|rgba|hsl|hsla)\\\\(.+?\\\\))|\\\\B#(?:[0-9a-f]{3,4}){1,2}\\\\b\",\n      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,\n  p;\n\n  for (p in _colorLookup) {\n    s += \"|\" + p + \"\\\\b\";\n  }\n\n  return new RegExp(s + \")\", \"gi\");\n}(),\n    _hslExp = /hsl[a]?\\(/,\n    _colorStringFilter = function _colorStringFilter(a) {\n  var combined = a.join(\" \"),\n      toHSL;\n  _colorExp.lastIndex = 0;\n\n  if (_colorExp.test(combined)) {\n    toHSL = _hslExp.test(combined);\n    a[1] = _formatColors(a[1], toHSL);\n    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.\n\n    return true;\n  }\n},\n\n/*\n * --------------------------------------------------------------------------------------\n * TICKER\n * --------------------------------------------------------------------------------------\n */\n_tickerActive,\n    _ticker = function () {\n  var _getTime = Date.now,\n      _lagThreshold = 500,\n      _adjustedLag = 33,\n      _startTime = _getTime(),\n      _lastUpdate = _startTime,\n      _gap = 1000 / 240,\n      _nextTime = _gap,\n      _listeners = [],\n      _id,\n      _req,\n      _raf,\n      _self,\n      _delta,\n      _i,\n      _tick = function _tick(v) {\n    var elapsed = _getTime() - _lastUpdate,\n        manual = v === true,\n        overlap,\n        dispatch,\n        time,\n        frame;\n\n    elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);\n    _lastUpdate += elapsed;\n    time = _lastUpdate - _startTime;\n    overlap = time - _nextTime;\n\n    if (overlap > 0 || manual) {\n      frame = ++_self.frame;\n      _delta = time - _self.time * 1000;\n      _self.time = time = time / 1000;\n      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);\n      dispatch = 1;\n    }\n\n    manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the \"tick\" event so that timing is maintained. Otherwise, if processing the \"tick\" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.\n\n    if (dispatch) {\n      for (_i = 0; _i < _listeners.length; _i++) {\n        // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.\n        _listeners[_i](time, _delta, frame, v);\n      }\n    }\n  };\n\n  _self = {\n    time: 0,\n    frame: 0,\n    tick: function tick() {\n      _tick(true);\n    },\n    deltaRatio: function deltaRatio(fps) {\n      return _delta / (1000 / (fps || 60));\n    },\n    wake: function wake() {\n      if (_coreReady) {\n        if (!_coreInitted && _windowExists()) {\n          _win = _coreInitted = window;\n          _doc = _win.document || {};\n          _globals.gsap = gsap;\n          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);\n\n          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});\n\n          _raf = _win.requestAnimationFrame;\n\n          _registerPluginQueue.forEach(_createPlugin);\n        }\n\n        _id && _self.sleep();\n\n        _req = _raf || function (f) {\n          return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);\n        };\n\n        _tickerActive = 1;\n\n        _tick(2);\n      }\n    },\n    sleep: function sleep() {\n      (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);\n      _tickerActive = 0;\n      _req = _emptyFunc;\n    },\n    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {\n      _lagThreshold = threshold || Infinity; // zero should be interpreted as basically unlimited\n\n      _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);\n    },\n    fps: function fps(_fps) {\n      _gap = 1000 / (_fps || 240);\n      _nextTime = _self.time * 1000 + _gap;\n    },\n    add: function add(callback, once, prioritize) {\n      var func = once ? function (t, d, f, v) {\n        callback(t, d, f, v);\n\n        _self.remove(func);\n      } : callback;\n\n      _self.remove(callback);\n\n      _listeners[prioritize ? \"unshift\" : \"push\"](func);\n\n      _wake();\n\n      return func;\n    },\n    remove: function remove(callback, i) {\n      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;\n    },\n    _listeners: _listeners\n  };\n  return _self;\n}(),\n    _wake = function _wake() {\n  return !_tickerActive && _ticker.wake();\n},\n    //also ensures the core classes are initialized.\n\n/*\n* -------------------------------------------------\n* EASING\n* -------------------------------------------------\n*/\n_easeMap = {},\n    _customEaseExp = /^[\\d.\\-M][\\d.\\-,\\s]/,\n    _quotesExp = /[\"']/g,\n    _parseObjectInString = function _parseObjectInString(value) {\n  //takes a string like \"{wiggles:10, type:anticipate})\" and turns it into a real object. Notice it ends in \")\" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.\n  var obj = {},\n      split = value.substr(1, value.length - 3).split(\":\"),\n      key = split[0],\n      i = 1,\n      l = split.length,\n      index,\n      val,\n      parsedVal;\n\n  for (; i < l; i++) {\n    val = split[i];\n    index = i !== l - 1 ? val.lastIndexOf(\",\") : val.length;\n    parsedVal = val.substr(0, index);\n    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, \"\").trim() : +parsedVal;\n    key = val.substr(index + 1).trim();\n  }\n\n  return obj;\n},\n    _valueInParentheses = function _valueInParentheses(value) {\n  var open = value.indexOf(\"(\") + 1,\n      close = value.indexOf(\")\"),\n      nested = value.indexOf(\"(\", open);\n  return value.substring(open, ~nested && nested < close ? value.indexOf(\")\", close + 1) : close);\n},\n    _configEaseFromString = function _configEaseFromString(name) {\n  //name can be a string like \"elastic.out(1,0.5)\", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).\n  var split = (name + \"\").split(\"(\"),\n      ease = _easeMap[split[0]];\n  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf(\"{\") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(\",\").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE(\"\", name) : ease;\n},\n    _invertEase = function _invertEase(ease) {\n  return function (p) {\n    return 1 - ease(1 - p);\n  };\n},\n    // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.\n_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {\n  var child = timeline._first,\n      ease;\n\n  while (child) {\n    if (child instanceof Timeline) {\n      _propagateYoyoEase(child, isYoyo);\n    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {\n      if (child.timeline) {\n        _propagateYoyoEase(child.timeline, isYoyo);\n      } else {\n        ease = child._ease;\n        child._ease = child._yEase;\n        child._yEase = ease;\n        child._yoyo = isYoyo;\n      }\n    }\n\n    child = child._next;\n  }\n},\n    _parseEase = function _parseEase(ease, defaultEase) {\n  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;\n},\n    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {\n  if (easeOut === void 0) {\n    easeOut = function easeOut(p) {\n      return 1 - easeIn(1 - p);\n    };\n  }\n\n  if (easeInOut === void 0) {\n    easeInOut = function easeInOut(p) {\n      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;\n    };\n  }\n\n  var ease = {\n    easeIn: easeIn,\n    easeOut: easeOut,\n    easeInOut: easeInOut\n  },\n      lowercaseName;\n\n  _forEachName(names, function (name) {\n    _easeMap[name] = _globals[name] = ease;\n    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;\n\n    for (var p in ease) {\n      _easeMap[lowercaseName + (p === \"easeIn\" ? \".in\" : p === \"easeOut\" ? \".out\" : \".inOut\")] = _easeMap[name + \".\" + p] = ease[p];\n    }\n  });\n\n  return ease;\n},\n    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {\n  return function (p) {\n    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;\n  };\n},\n    _configElastic = function _configElastic(type, amplitude, period) {\n  var p1 = amplitude >= 1 ? amplitude : 1,\n      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.\n  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),\n      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),\n      easeOut = function easeOut(p) {\n    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;\n  },\n      ease = type === \"out\" ? easeOut : type === \"in\" ? function (p) {\n    return 1 - easeOut(1 - p);\n  } : _easeInOutFromOut(easeOut);\n\n  p2 = _2PI / p2; //precalculate to optimize\n\n  ease.config = function (amplitude, period) {\n    return _configElastic(type, amplitude, period);\n  };\n\n  return ease;\n},\n    _configBack = function _configBack(type, overshoot) {\n  if (overshoot === void 0) {\n    overshoot = 1.70158;\n  }\n\n  var easeOut = function easeOut(p) {\n    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;\n  },\n      ease = type === \"out\" ? easeOut : type === \"in\" ? function (p) {\n    return 1 - easeOut(1 - p);\n  } : _easeInOutFromOut(easeOut);\n\n  ease.config = function (overshoot) {\n    return _configBack(type, overshoot);\n  };\n\n  return ease;\n}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\n// _weightedEase = ratio => {\n// \tlet y = 0.5 + ratio / 2;\n// \treturn p => (2 * (1 - p) * p * y + p * p);\n// },\n// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.\n// _weightedEaseStrong = ratio => {\n// \tratio = .5 + ratio / 2;\n// \tlet o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),\n// \t\tb = ratio - o,\n// \t\tc = ratio + o;\n// \treturn p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;\n// };\n\n\n_forEachName(\"Linear,Quad,Cubic,Quart,Quint,Strong\", function (name, i) {\n  var power = i < 5 ? i + 1 : i;\n\n  _insertEase(name + \",Power\" + (power - 1), i ? function (p) {\n    return Math.pow(p, power);\n  } : function (p) {\n    return p;\n  }, function (p) {\n    return 1 - Math.pow(1 - p, power);\n  }, function (p) {\n    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;\n  });\n});\n\n_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;\n\n_insertEase(\"Elastic\", _configElastic(\"in\"), _configElastic(\"out\"), _configElastic());\n\n(function (n, c) {\n  var n1 = 1 / c,\n      n2 = 2 * n1,\n      n3 = 2.5 * n1,\n      easeOut = function easeOut(p) {\n    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;\n  };\n\n  _insertEase(\"Bounce\", function (p) {\n    return 1 - easeOut(1 - p);\n  }, easeOut);\n})(7.5625, 2.75);\n\n_insertEase(\"Expo\", function (p) {\n  return p ? Math.pow(2, 10 * (p - 1)) : 0;\n});\n\n_insertEase(\"Circ\", function (p) {\n  return -(_sqrt(1 - p * p) - 1);\n});\n\n_insertEase(\"Sine\", function (p) {\n  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;\n});\n\n_insertEase(\"Back\", _configBack(\"in\"), _configBack(\"out\"), _configBack());\n\n_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {\n  config: function config(steps, immediateStart) {\n    if (steps === void 0) {\n      steps = 1;\n    }\n\n    var p1 = 1 / steps,\n        p2 = steps + (immediateStart ? 0 : 1),\n        p3 = immediateStart ? 1 : 0,\n        max = 1 - _tinyNum;\n    return function (p) {\n      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;\n    };\n  }\n};\n_defaults.ease = _easeMap[\"quad.out\"];\n\n_forEachName(\"onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt\", function (name) {\n  return _callbackNames += name + \",\" + name + \"Params,\";\n});\n/*\n * --------------------------------------------------------------------------------------\n * CACHE\n * --------------------------------------------------------------------------------------\n */\n\n\nexport var GSCache = function GSCache(target, harness) {\n  this.id = _gsID++;\n  target._gsap = this;\n  this.target = target;\n  this.harness = harness;\n  this.get = harness ? harness.get : _getProperty;\n  this.set = harness ? harness.getSetter : _getSetter;\n};\n/*\n * --------------------------------------------------------------------------------------\n * ANIMATION\n * --------------------------------------------------------------------------------------\n */\n\nexport var Animation = /*#__PURE__*/function () {\n  function Animation(vars) {\n    this.vars = vars;\n    this._delay = +vars.delay || 0;\n\n    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {\n      // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.\n      this._rDelay = vars.repeatDelay || 0;\n      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;\n    }\n\n    this._ts = 1;\n\n    _setDuration(this, +vars.duration, 1, 1);\n\n    this.data = vars.data;\n\n    if (_context) {\n      this._ctx = _context;\n\n      _context.data.push(this);\n    }\n\n    _tickerActive || _ticker.wake();\n  }\n\n  var _proto = Animation.prototype;\n\n  _proto.delay = function delay(value) {\n    if (value || value === 0) {\n      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);\n      this._delay = value;\n      return this;\n    }\n\n    return this._delay;\n  };\n\n  _proto.duration = function duration(value) {\n    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;\n  };\n\n  _proto.totalDuration = function totalDuration(value) {\n    if (!arguments.length) {\n      return this._tDur;\n    }\n\n    this._dirty = 0;\n    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));\n  };\n\n  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {\n    _wake();\n\n    if (!arguments.length) {\n      return this._tTime;\n    }\n\n    var parent = this._dp;\n\n    if (parent && parent.smoothChildTiming && this._ts) {\n      _alignPlayhead(this, _totalTime);\n\n      !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.\n      //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.\n\n      while (parent && parent.parent) {\n        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {\n          parent.totalTime(parent._tTime, true);\n        }\n\n        parent = parent.parent;\n      }\n\n      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {\n        //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.\n        _addToTimeline(this._dp, this, this._start - this._delay);\n      }\n    }\n\n    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {\n      // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)\n      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause\n      //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)\n      //   this._lock = 1;\n\n      _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;\n      //}\n\n    }\n\n    return this;\n  };\n\n  _proto.time = function time(value, suppressEvents) {\n    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!\n  };\n\n  _proto.totalProgress = function totalProgress(value, suppressEvents) {\n    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;\n  };\n\n  _proto.progress = function progress(value, suppressEvents) {\n    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;\n  };\n\n  _proto.iteration = function iteration(value, suppressEvents) {\n    var cycleDuration = this.duration() + this._rDelay;\n\n    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;\n  } // potential future addition:\n  // isPlayingBackwards() {\n  // \tlet animation = this,\n  // \t\torientation = 1; // 1 = forward, -1 = backward\n  // \twhile (animation) {\n  // \t\torientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;\n  // \t\tanimation = animation.parent;\n  // \t}\n  // \treturn orientation < 0;\n  // }\n  ;\n\n  _proto.timeScale = function timeScale(value) {\n    if (!arguments.length) {\n      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.\n    }\n\n    if (this._rts === value) {\n      return this;\n    }\n\n    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.\n    // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.\n    //(+value < 0 && this._rts >= 0) && _callback(this, \"onReverse\", true);\n    // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.\n\n    this._rts = +value || 0;\n    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.\n\n    this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), true);\n\n    _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.\n\n\n    return _recacheAncestors(this);\n  };\n\n  _proto.paused = function paused(value) {\n    if (!arguments.length) {\n      return this._ps;\n    }\n\n    if (this._ps !== value) {\n      this._ps = value;\n\n      if (value) {\n        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.\n\n        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the \"real\" timeScale as _rts (recorded time scale)\n      } else {\n        _wake();\n\n        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.\n\n        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.\n      }\n    }\n\n    return this;\n  };\n\n  _proto.startTime = function startTime(value) {\n    if (arguments.length) {\n      this._start = value;\n      var parent = this.parent || this._dp;\n      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);\n      return this;\n    }\n\n    return this._start;\n  };\n\n  _proto.endTime = function endTime(includeRepeats) {\n    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);\n  };\n\n  _proto.rawTime = function rawTime(wrapRepeats) {\n    var parent = this.parent || this._dp; // _dp = detached parent\n\n    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);\n  };\n\n  _proto.revert = function revert(config) {\n    if (config === void 0) {\n      config = _revertConfig;\n    }\n\n    var prevIsReverting = _reverting;\n    _reverting = config;\n\n    if (this._initted || this._startAt) {\n      this.timeline && this.timeline.revert(config);\n      this.totalTime(-0.01, config.suppressEvents);\n    }\n\n    this.data !== \"nested\" && config.kill !== false && this.kill();\n    _reverting = prevIsReverting;\n    return this;\n  };\n\n  _proto.globalTime = function globalTime(rawTime) {\n    var animation = this,\n        time = arguments.length ? rawTime : animation.rawTime();\n\n    while (animation) {\n      time = animation._start + time / (animation._ts || 1);\n      animation = animation._dp;\n    }\n\n    return !this.parent && this._sat ? this._sat.vars.immediateRender ? -Infinity : this._sat.globalTime(rawTime) : time; // the _startAt tweens for .fromTo() and .from() that have immediateRender should always be FIRST in the timeline (important for context.revert()). \"_sat\" stands for _startAtTween, referring to the parent tween that created the _startAt. We must discern if that tween had immediateRender so that we can know whether or not to prioritize it in revert().\n  };\n\n  _proto.repeat = function repeat(value) {\n    if (arguments.length) {\n      this._repeat = value === Infinity ? -2 : value;\n      return _onUpdateTotalDuration(this);\n    }\n\n    return this._repeat === -2 ? Infinity : this._repeat;\n  };\n\n  _proto.repeatDelay = function repeatDelay(value) {\n    if (arguments.length) {\n      var time = this._time;\n      this._rDelay = value;\n\n      _onUpdateTotalDuration(this);\n\n      return time ? this.time(time) : this;\n    }\n\n    return this._rDelay;\n  };\n\n  _proto.yoyo = function yoyo(value) {\n    if (arguments.length) {\n      this._yoyo = value;\n      return this;\n    }\n\n    return this._yoyo;\n  };\n\n  _proto.seek = function seek(position, suppressEvents) {\n    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));\n  };\n\n  _proto.restart = function restart(includeDelay, suppressEvents) {\n    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));\n  };\n\n  _proto.play = function play(from, suppressEvents) {\n    from != null && this.seek(from, suppressEvents);\n    return this.reversed(false).paused(false);\n  };\n\n  _proto.reverse = function reverse(from, suppressEvents) {\n    from != null && this.seek(from || this.totalDuration(), suppressEvents);\n    return this.reversed(true).paused(false);\n  };\n\n  _proto.pause = function pause(atTime, suppressEvents) {\n    atTime != null && this.seek(atTime, suppressEvents);\n    return this.paused(true);\n  };\n\n  _proto.resume = function resume() {\n    return this.paused(false);\n  };\n\n  _proto.reversed = function reversed(value) {\n    if (arguments.length) {\n      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.\n\n      return this;\n    }\n\n    return this._rts < 0;\n  };\n\n  _proto.invalidate = function invalidate() {\n    this._initted = this._act = 0;\n    this._zTime = -_tinyNum;\n    return this;\n  };\n\n  _proto.isActive = function isActive() {\n    var parent = this.parent || this._dp,\n        start = this._start,\n        rawTime;\n    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);\n  };\n\n  _proto.eventCallback = function eventCallback(type, callback, params) {\n    var vars = this.vars;\n\n    if (arguments.length > 1) {\n      if (!callback) {\n        delete vars[type];\n      } else {\n        vars[type] = callback;\n        params && (vars[type + \"Params\"] = params);\n        type === \"onUpdate\" && (this._onUpdate = callback);\n      }\n\n      return this;\n    }\n\n    return vars[type];\n  };\n\n  _proto.then = function then(onFulfilled) {\n    var self = this;\n    return new Promise(function (resolve) {\n      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,\n          _resolve = function _resolve() {\n        var _then = self.then;\n        self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)\n\n        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);\n        resolve(f);\n        self.then = _then;\n      };\n\n      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {\n        _resolve();\n      } else {\n        self._prom = _resolve;\n      }\n    });\n  };\n\n  _proto.kill = function kill() {\n    _interrupt(this);\n  };\n\n  return Animation;\n}();\n\n_setDefaults(Animation.prototype, {\n  _time: 0,\n  _start: 0,\n  _end: 0,\n  _tTime: 0,\n  _tDur: 0,\n  _dirty: 0,\n  _repeat: 0,\n  _yoyo: false,\n  parent: null,\n  _initted: false,\n  _rDelay: 0,\n  _ts: 1,\n  _dp: 0,\n  ratio: 0,\n  _zTime: -_tinyNum,\n  _prom: 0,\n  _ps: false,\n  _rts: 1\n});\n/*\n * -------------------------------------------------\n * TIMELINE\n * -------------------------------------------------\n */\n\n\nexport var Timeline = /*#__PURE__*/function (_Animation) {\n  _inheritsLoose(Timeline, _Animation);\n\n  function Timeline(vars, position) {\n    var _this;\n\n    if (vars === void 0) {\n      vars = {};\n    }\n\n    _this = _Animation.call(this, vars) || this;\n    _this.labels = {};\n    _this.smoothChildTiming = !!vars.smoothChildTiming;\n    _this.autoRemoveChildren = !!vars.autoRemoveChildren;\n    _this._sort = _isNotFalse(vars.sortChildren);\n    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);\n    vars.reversed && _this.reverse();\n    vars.paused && _this.paused(true);\n    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);\n    return _this;\n  }\n\n  var _proto2 = Timeline.prototype;\n\n  _proto2.to = function to(targets, vars, position) {\n    _createTweenType(0, arguments, this);\n\n    return this;\n  };\n\n  _proto2.from = function from(targets, vars, position) {\n    _createTweenType(1, arguments, this);\n\n    return this;\n  };\n\n  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {\n    _createTweenType(2, arguments, this);\n\n    return this;\n  };\n\n  _proto2.set = function set(targets, vars, position) {\n    vars.duration = 0;\n    vars.parent = this;\n    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);\n    vars.immediateRender = !!vars.immediateRender;\n    new Tween(targets, vars, _parsePosition(this, position), 1);\n    return this;\n  };\n\n  _proto2.call = function call(callback, params, position) {\n    return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);\n  } //ONLY for backward compatibility! Maybe delete?\n  ;\n\n  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    vars.duration = duration;\n    vars.stagger = vars.stagger || stagger;\n    vars.onComplete = onCompleteAll;\n    vars.onCompleteParams = onCompleteAllParams;\n    vars.parent = this;\n    new Tween(targets, vars, _parsePosition(this, position));\n    return this;\n  };\n\n  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    vars.runBackwards = 1;\n    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);\n    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);\n  };\n\n  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {\n    toVars.startAt = fromVars;\n    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);\n    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);\n  };\n\n  _proto2.render = function render(totalTime, suppressEvents, force) {\n    var prevTime = this._time,\n        tDur = this._dirty ? this.totalDuration() : this._tDur,\n        dur = this._dur,\n        tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),\n        // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.\n    crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),\n        time,\n        child,\n        next,\n        iteration,\n        cycleDuration,\n        prevPaused,\n        pauseTween,\n        timeScale,\n        prevStart,\n        prevIteration,\n        yoyo,\n        isYoyo;\n    this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);\n\n    if (tTime !== this._tTime || force || crossingStart) {\n      if (prevTime !== this._time && dur) {\n        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).\n        tTime += this._time - prevTime;\n        totalTime += this._time - prevTime;\n      }\n\n      time = tTime;\n      prevStart = this._start;\n      timeScale = this._ts;\n      prevPaused = !timeScale;\n\n      if (crossingStart) {\n        dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.\n\n        (totalTime || !suppressEvents) && (this._zTime = totalTime);\n      }\n\n      if (this._repeat) {\n        //adjust the time for repeats and yoyos\n        yoyo = this._yoyo;\n        cycleDuration = dur + this._rDelay;\n\n        if (this._repeat < -1 && totalTime < 0) {\n          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n        }\n\n        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\n\n        if (tTime === tDur) {\n          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)\n          iteration = this._repeat;\n          time = dur;\n        } else {\n          iteration = ~~(tTime / cycleDuration);\n\n          if (iteration && iteration === tTime / cycleDuration) {\n            time = dur;\n            iteration--;\n          }\n\n          time > dur && (time = dur);\n        }\n\n        prevIteration = _animationCycle(this._tTime, cycleDuration);\n        !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005 also, this._tTime - prevIteration * cycleDuration - this._dur <= 0 just checks to make sure it wasn't previously in the \"repeatDelay\" portion\n\n        if (yoyo && iteration & 1) {\n          time = dur - time;\n          isYoyo = 1;\n        }\n        /*\n        make sure children at the end/beginning of the timeline are rendered properly. If, for example,\n        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which\n        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there\n        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So\n        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must\n        ensure that zero-duration tweens at the very beginning or end of the Timeline work.\n        */\n\n\n        if (iteration !== prevIteration && !this._lock) {\n          var rewinding = yoyo && prevIteration & 1,\n              doesWrap = rewinding === (yoyo && iteration & 1);\n          iteration < prevIteration && (rewinding = !rewinding);\n          prevTime = rewinding ? 0 : tTime % dur ? dur : tTime; // if the playhead is landing exactly at the end of an iteration, use that totalTime rather than only the duration, otherwise it'll skip the 2nd render since it's effectively at the same time.\n\n          this._lock = 1;\n          this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;\n          this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.\n\n          !suppressEvents && this.parent && _callback(this, \"onRepeat\");\n          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);\n\n          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {\n            // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.\n            return this;\n          }\n\n          dur = this._dur; // in case the duration changed in the onRepeat\n\n          tDur = this._tDur;\n\n          if (doesWrap) {\n            this._lock = 2;\n            prevTime = rewinding ? dur : -0.0001;\n            this.render(prevTime, true);\n            this.vars.repeatRefresh && !isYoyo && this.invalidate();\n          }\n\n          this._lock = 0;\n\n          if (!this._ts && !prevPaused) {\n            return this;\n          } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.\n\n\n          _propagateYoyoEase(this, isYoyo);\n        }\n      }\n\n      if (this._hasPause && !this._forcing && this._lock < 2) {\n        pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));\n\n        if (pauseTween) {\n          tTime -= time - (time = pauseTween._start);\n        }\n      }\n\n      this._tTime = tTime;\n      this._time = time;\n      this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.\n\n      if (!this._initted) {\n        this._onUpdate = this.vars.onUpdate;\n        this._initted = 1;\n        this._zTime = totalTime;\n        prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).\n      }\n\n      if (!prevTime && time && !suppressEvents && !iteration) {\n        _callback(this, \"onStart\");\n\n        if (this._tTime !== tTime) {\n          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.\n          return this;\n        }\n      }\n\n      if (time >= prevTime && totalTime >= 0) {\n        child = this._first;\n\n        while (child) {\n          next = child._next;\n\n          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {\n            if (child.parent !== this) {\n              // an extreme edge case - the child's render could do something like kill() the \"next\" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\n              return this.render(totalTime, suppressEvents, force);\n            }\n\n            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);\n\n            if (time !== this._time || !this._ts && !prevPaused) {\n              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\n              pauseTween = 0;\n              next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)\n\n              break;\n            }\n          }\n\n          child = next;\n        }\n      } else {\n        child = this._last;\n        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.\n\n        while (child) {\n          next = child._prev;\n\n          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {\n            if (child.parent !== this) {\n              // an extreme edge case - the child's render could do something like kill() the \"next\" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.\n              return this.render(totalTime, suppressEvents, force);\n            }\n\n            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt)); // if reverting, we should always force renders of initted tweens (but remember that .fromTo() or .from() may have a _startAt but not _initted yet). If, for example, a .fromTo() tween with a stagger (which creates an internal timeline) gets reverted BEFORE some of its child tweens render for the first time, it may not properly trigger them to revert.\n\n            if (time !== this._time || !this._ts && !prevPaused) {\n              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete\n              pauseTween = 0;\n              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)\n\n              break;\n            }\n          }\n\n          child = next;\n        }\n      }\n\n      if (pauseTween && !suppressEvents) {\n        this.pause();\n        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;\n\n        if (this._ts) {\n          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).\n          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.\n\n          _setEnd(this);\n\n          return this.render(totalTime, suppressEvents, force);\n        }\n      }\n\n      this._onUpdate && !suppressEvents && _callback(this, \"onUpdate\", true);\n      if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {\n        // remember, a child's callback may alter this timeline's playhead or timeScale which is why we need to add some of these checks.\n        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\n\n        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {\n          _callback(this, tTime === tDur && totalTime >= 0 ? \"onComplete\" : \"onReverseComplete\", true);\n\n          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n        }\n      }\n    }\n\n    return this;\n  };\n\n  _proto2.add = function add(child, position) {\n    var _this2 = this;\n\n    _isNumber(position) || (position = _parsePosition(this, position, child));\n\n    if (!(child instanceof Animation)) {\n      if (_isArray(child)) {\n        child.forEach(function (obj) {\n          return _this2.add(obj, position);\n        });\n        return this;\n      }\n\n      if (_isString(child)) {\n        return this.addLabel(child, position);\n      }\n\n      if (_isFunction(child)) {\n        child = Tween.delayedCall(0, child);\n      } else {\n        return this;\n      }\n    }\n\n    return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!\n  };\n\n  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {\n    if (nested === void 0) {\n      nested = true;\n    }\n\n    if (tweens === void 0) {\n      tweens = true;\n    }\n\n    if (timelines === void 0) {\n      timelines = true;\n    }\n\n    if (ignoreBeforeTime === void 0) {\n      ignoreBeforeTime = -_bigNum;\n    }\n\n    var a = [],\n        child = this._first;\n\n    while (child) {\n      if (child._start >= ignoreBeforeTime) {\n        if (child instanceof Tween) {\n          tweens && a.push(child);\n        } else {\n          timelines && a.push(child);\n          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));\n        }\n      }\n\n      child = child._next;\n    }\n\n    return a;\n  };\n\n  _proto2.getById = function getById(id) {\n    var animations = this.getChildren(1, 1, 1),\n        i = animations.length;\n\n    while (i--) {\n      if (animations[i].vars.id === id) {\n        return animations[i];\n      }\n    }\n  };\n\n  _proto2.remove = function remove(child) {\n    if (_isString(child)) {\n      return this.removeLabel(child);\n    }\n\n    if (_isFunction(child)) {\n      return this.killTweensOf(child);\n    }\n\n    _removeLinkedListItem(this, child);\n\n    if (child === this._recent) {\n      this._recent = this._last;\n    }\n\n    return _uncache(this);\n  };\n\n  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {\n    if (!arguments.length) {\n      return this._tTime;\n    }\n\n    this._forcing = 1;\n\n    if (!this._dp && this._ts) {\n      //special case for the global timeline (or any other that has no parent or detached parent).\n      this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));\n    }\n\n    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);\n\n    this._forcing = 0;\n    return this;\n  };\n\n  _proto2.addLabel = function addLabel(label, position) {\n    this.labels[label] = _parsePosition(this, position);\n    return this;\n  };\n\n  _proto2.removeLabel = function removeLabel(label) {\n    delete this.labels[label];\n    return this;\n  };\n\n  _proto2.addPause = function addPause(position, callback, params) {\n    var t = Tween.delayedCall(0, callback || _emptyFunc, params);\n    t.data = \"isPause\";\n    this._hasPause = 1;\n    return _addToTimeline(this, t, _parsePosition(this, position));\n  };\n\n  _proto2.removePause = function removePause(position) {\n    var child = this._first;\n    position = _parsePosition(this, position);\n\n    while (child) {\n      if (child._start === position && child.data === \"isPause\") {\n        _removeFromParent(child);\n      }\n\n      child = child._next;\n    }\n  };\n\n  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n    var tweens = this.getTweensOf(targets, onlyActive),\n        i = tweens.length;\n\n    while (i--) {\n      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);\n    }\n\n    return this;\n  };\n\n  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {\n    var a = [],\n        parsedTargets = toArray(targets),\n        child = this._first,\n        isGlobalTime = _isNumber(onlyActive),\n        // a number is interpreted as a global time. If the animation spans\n    children;\n\n    while (child) {\n      if (child instanceof Tween) {\n        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {\n          // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.\n          a.push(child);\n        }\n      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {\n        a.push.apply(a, children);\n      }\n\n      child = child._next;\n    }\n\n    return a;\n  } // potential future feature - targets() on timelines\n  // targets() {\n  // \tlet result = [];\n  // \tthis.getChildren(true, true, false).forEach(t => result.push(...t.targets()));\n  // \treturn result.filter((v, i) => result.indexOf(v) === i);\n  // }\n  ;\n\n  _proto2.tweenTo = function tweenTo(position, vars) {\n    vars = vars || {};\n\n    var tl = this,\n        endTime = _parsePosition(tl, position),\n        _vars = vars,\n        startAt = _vars.startAt,\n        _onStart = _vars.onStart,\n        onStartParams = _vars.onStartParams,\n        immediateRender = _vars.immediateRender,\n        initted,\n        tween = Tween.to(tl, _setDefaults({\n      ease: vars.ease || \"none\",\n      lazy: false,\n      immediateRender: false,\n      time: endTime,\n      overwrite: \"auto\",\n      duration: vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,\n      onStart: function onStart() {\n        tl.pause();\n\n        if (!initted) {\n          var duration = vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale());\n          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);\n          initted = 1;\n        }\n\n        _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.\n      }\n    }, vars));\n\n    return immediateRender ? tween.render(0) : tween;\n  };\n\n  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {\n    return this.tweenTo(toPosition, _setDefaults({\n      startAt: {\n        time: _parsePosition(this, fromPosition)\n      }\n    }, vars));\n  };\n\n  _proto2.recent = function recent() {\n    return this._recent;\n  };\n\n  _proto2.nextLabel = function nextLabel(afterTime) {\n    if (afterTime === void 0) {\n      afterTime = this._time;\n    }\n\n    return _getLabelInDirection(this, _parsePosition(this, afterTime));\n  };\n\n  _proto2.previousLabel = function previousLabel(beforeTime) {\n    if (beforeTime === void 0) {\n      beforeTime = this._time;\n    }\n\n    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);\n  };\n\n  _proto2.currentLabel = function currentLabel(value) {\n    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);\n  };\n\n  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {\n    if (ignoreBeforeTime === void 0) {\n      ignoreBeforeTime = 0;\n    }\n\n    var child = this._first,\n        labels = this.labels,\n        p;\n\n    while (child) {\n      if (child._start >= ignoreBeforeTime) {\n        child._start += amount;\n        child._end += amount;\n      }\n\n      child = child._next;\n    }\n\n    if (adjustLabels) {\n      for (p in labels) {\n        if (labels[p] >= ignoreBeforeTime) {\n          labels[p] += amount;\n        }\n      }\n    }\n\n    return _uncache(this);\n  };\n\n  _proto2.invalidate = function invalidate(soft) {\n    var child = this._first;\n    this._lock = 0;\n\n    while (child) {\n      child.invalidate(soft);\n      child = child._next;\n    }\n\n    return _Animation.prototype.invalidate.call(this, soft);\n  };\n\n  _proto2.clear = function clear(includeLabels) {\n    if (includeLabels === void 0) {\n      includeLabels = true;\n    }\n\n    var child = this._first,\n        next;\n\n    while (child) {\n      next = child._next;\n      this.remove(child);\n      child = next;\n    }\n\n    this._dp && (this._time = this._tTime = this._pTime = 0);\n    includeLabels && (this.labels = {});\n    return _uncache(this);\n  };\n\n  _proto2.totalDuration = function totalDuration(value) {\n    var max = 0,\n        self = this,\n        child = self._last,\n        prevStart = _bigNum,\n        prev,\n        start,\n        parent;\n\n    if (arguments.length) {\n      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));\n    }\n\n    if (self._dirty) {\n      parent = self.parent;\n\n      while (child) {\n        prev = child._prev; //record it here in case the tween changes position in the sequence...\n\n        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.\n\n        start = child._start;\n\n        if (start > prevStart && self._sort && child._ts && !self._lock) {\n          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence\n          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().\n\n          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;\n        } else {\n          prevStart = start;\n        }\n\n        if (start < 0 && child._ts) {\n          //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.\n          max -= start;\n\n          if (!parent && !self._dp || parent && parent.smoothChildTiming) {\n            self._start += start / self._ts;\n            self._time -= start;\n            self._tTime -= start;\n          }\n\n          self.shiftChildren(-start, false, -1e999);\n          prevStart = 0;\n        }\n\n        child._end > max && child._ts && (max = child._end);\n        child = prev;\n      }\n\n      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);\n\n      self._dirty = 0;\n    }\n\n    return self._tDur;\n  };\n\n  Timeline.updateRoot = function updateRoot(time) {\n    if (_globalTimeline._ts) {\n      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));\n\n      _lastRenderedFrame = _ticker.frame;\n    }\n\n    if (_ticker.frame >= _nextGCFrame) {\n      _nextGCFrame += _config.autoSleep || 120;\n      var child = _globalTimeline._first;\n      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {\n        while (child && !child._ts) {\n          child = child._next;\n        }\n\n        child || _ticker.sleep();\n      }\n    }\n  };\n\n  return Timeline;\n}(Animation);\n\n_setDefaults(Timeline.prototype, {\n  _lock: 0,\n  _hasPause: 0,\n  _forcing: 0\n});\n\nvar _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {\n  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\n  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),\n      index = 0,\n      matchIndex = 0,\n      result,\n      startNums,\n      color,\n      endNum,\n      chunk,\n      startNum,\n      hasRandom,\n      a;\n  pt.b = start;\n  pt.e = end;\n  start += \"\"; //ensure values are strings\n\n  end += \"\";\n\n  if (hasRandom = ~end.indexOf(\"random(\")) {\n    end = _replaceRandom(end);\n  }\n\n  if (stringFilter) {\n    a = [start, end];\n    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.\n\n    start = a[0];\n    end = a[1];\n  }\n\n  startNums = start.match(_complexStringNumExp) || [];\n\n  while (result = _complexStringNumExp.exec(end)) {\n    endNum = result[0];\n    chunk = end.substring(index, result.index);\n\n    if (color) {\n      color = (color + 1) % 5;\n    } else if (chunk.substr(-5) === \"rgba(\") {\n      color = 1;\n    }\n\n    if (endNum !== startNums[matchIndex++]) {\n      startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.\n\n      pt._pt = {\n        _next: pt._pt,\n        p: chunk || matchIndex === 1 ? chunk : \",\",\n        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n        s: startNum,\n        c: endNum.charAt(1) === \"=\" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,\n        m: color && color < 4 ? Math.round : 0\n      };\n      index = _complexStringNumExp.lastIndex;\n    }\n  }\n\n  pt.c = index < end.length ? end.substring(index, end.length) : \"\"; //we use the \"c\" of the PropTween to store the final part of the string (after the last number)\n\n  pt.fp = funcParam;\n\n  if (_relExp.test(end) || hasRandom) {\n    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).\n  }\n\n  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\n\n  return pt;\n},\n    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {\n  _isFunction(end) && (end = end(index || 0, target, targets));\n  var currentValue = target[prop],\n      parsedStart = start !== \"get\" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf(\"set\") || !_isFunction(target[\"get\" + prop.substr(3)]) ? prop : \"get\" + prop.substr(3)](funcParam) : target[prop](),\n      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,\n      pt;\n\n  if (_isString(end)) {\n    if (~end.indexOf(\"random(\")) {\n      end = _replaceRandom(end);\n    }\n\n    if (end.charAt(1) === \"=\") {\n      pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);\n\n      if (pt || pt === 0) {\n        // to avoid isNaN, like if someone passes in a value like \"!= whatever\"\n        end = pt;\n      }\n    }\n  }\n\n  if (!optional || parsedStart !== end || _forceAllPropTweens) {\n    if (!isNaN(parsedStart * end) && end !== \"\") {\n      // fun fact: any number multiplied by \"\" is evaluated as the number 0!\n      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === \"boolean\" ? _renderBoolean : _renderPlain, 0, setter);\n      funcParam && (pt.fp = funcParam);\n      modifier && pt.modifier(modifier, this, target);\n      return this._pt = pt;\n    }\n\n    !currentValue && !(prop in target) && _missingPlugin(prop, end);\n    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);\n  }\n},\n    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with \"random()\" in them. It does NOT process relative values.\n_processVars = function _processVars(vars, index, target, targets, tween) {\n  _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));\n\n  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {\n    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;\n  }\n\n  var copy = {},\n      p;\n\n  for (p in vars) {\n    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);\n  }\n\n  return copy;\n},\n    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {\n  var plugin, pt, ptLookup, i;\n\n  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {\n    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);\n\n    if (tween !== _quickTween) {\n      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.\n\n      i = plugin._props.length;\n\n      while (i--) {\n        ptLookup[plugin._props[i]] = pt;\n      }\n    }\n  }\n\n  return plugin;\n},\n    _overwritingTween,\n    //store a reference temporarily so we can avoid overwriting itself.\n_forceAllPropTweens,\n    _initTween = function _initTween(tween, time, tTime) {\n  var vars = tween.vars,\n      ease = vars.ease,\n      startAt = vars.startAt,\n      immediateRender = vars.immediateRender,\n      lazy = vars.lazy,\n      onUpdate = vars.onUpdate,\n      onUpdateParams = vars.onUpdateParams,\n      callbackScope = vars.callbackScope,\n      runBackwards = vars.runBackwards,\n      yoyoEase = vars.yoyoEase,\n      keyframes = vars.keyframes,\n      autoRevert = vars.autoRevert,\n      dur = tween._dur,\n      prevStartAt = tween._startAt,\n      targets = tween._targets,\n      parent = tween.parent,\n      fullTargets = parent && parent.data === \"nested\" ? parent.vars.targets : targets,\n      autoOverwrite = tween._overwrite === \"auto\" && !_suppressOverwrites,\n      tl = tween.timeline,\n      cleanVars,\n      i,\n      p,\n      pt,\n      target,\n      hasPriority,\n      gsData,\n      harness,\n      plugin,\n      ptLookup,\n      index,\n      harnessVars,\n      overwritten;\n  tl && (!keyframes || !ease) && (ease = \"none\");\n  tween._ease = _parseEase(ease, _defaults.ease);\n  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;\n\n  if (yoyoEase && tween._yoyo && !tween._repeat) {\n    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.\n    yoyoEase = tween._yEase;\n    tween._yEase = tween._ease;\n    tween._ease = yoyoEase;\n  }\n\n  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.\n\n  if (!tl || keyframes && !vars.stagger) {\n    //if there's an internal timeline, skip all the parsing because we passed that task down the chain.\n    harness = targets[0] ? _getCache(targets[0]).harness : 0;\n    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an \"x\" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.\n\n    cleanVars = _copyExcluding(vars, _reservedProps);\n\n    if (prevStartAt) {\n      prevStartAt._zTime < 0 && prevStartAt.progress(1); // in case it's a lazy startAt that hasn't rendered yet.\n\n      time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig); // if it's a \"startAt\" (not \"from()\" or runBackwards: true), we only need to do a shallow revert (keep transforms cached in CSSPlugin)\n      // don't just _removeFromParent(prevStartAt.render(-1, true)) because that'll leave inline styles. We're creating a new _startAt for \"startAt\" tweens that re-capture things to ensure that if the pre-tween values changed since the tween was created, they're recorded.\n\n      prevStartAt._lazy = 0;\n    }\n\n    if (startAt) {\n      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({\n        data: \"isStart\",\n        overwrite: false,\n        parent: parent,\n        immediateRender: true,\n        lazy: !prevStartAt && _isNotFalse(lazy),\n        startAt: null,\n        delay: 0,\n        onUpdate: onUpdate,\n        onUpdateParams: onUpdateParams,\n        callbackScope: callbackScope,\n        stagger: 0\n      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);\n\n\n      tween._startAt._dp = 0; // don't allow it to get put back into root timeline! Like when revert() is called and totalTime() gets set.\n\n      tween._startAt._sat = tween; // used in globalTime(). _sat stands for _startAtTween\n\n      time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.\n\n      if (immediateRender) {\n        if (dur && time <= 0 && tTime <= 0) {\n          // check tTime here because in the case of a yoyo tween whose playhead gets pushed to the end like tween.progress(1), we should allow it through so that the onComplete gets fired properly.\n          time && (tween._zTime = time);\n          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.\n        }\n      }\n    } else if (runBackwards && dur) {\n      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)\n      if (!prevStartAt) {\n        time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0\n\n        p = _setDefaults({\n          overwrite: false,\n          data: \"isFromStart\",\n          //we tag the tween with as \"isFromStart\" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a \"from()\" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:\"height\", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.\n          lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),\n          immediateRender: immediateRender,\n          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)\n          stagger: 0,\n          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(\".class\", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})\n\n        }, cleanVars);\n        harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})\n\n        _removeFromParent(tween._startAt = Tween.set(targets, p));\n\n        tween._startAt._dp = 0; // don't allow it to get put back into root timeline!\n\n        tween._startAt._sat = tween; // used in globalTime()\n\n        time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));\n        tween._zTime = time;\n\n        if (!immediateRender) {\n          _initTween(tween._startAt, _tinyNum, _tinyNum); //ensures that the initial values are recorded\n\n        } else if (!time) {\n          return;\n        }\n      }\n    }\n\n    tween._pt = tween._ptCache = 0;\n    lazy = dur && _isNotFalse(lazy) || lazy && !dur;\n\n    for (i = 0; i < targets.length; i++) {\n      target = targets[i];\n      gsData = target._gsap || _harness(targets)[i]._gsap;\n      tween._ptLookup[i] = ptLookup = {};\n      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)\n\n      index = fullTargets === targets ? i : fullTargets.indexOf(target);\n\n      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {\n        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);\n\n        plugin._props.forEach(function (name) {\n          ptLookup[name] = pt;\n        });\n\n        plugin.priority && (hasPriority = 1);\n      }\n\n      if (!harness || harnessVars) {\n        for (p in cleanVars) {\n          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {\n            plugin.priority && (hasPriority = 1);\n          } else {\n            ptLookup[p] = pt = _addPropTween.call(tween, target, p, \"get\", cleanVars[p], index, fullTargets, 0, vars.stringFilter);\n          }\n        }\n      }\n\n      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);\n\n      if (autoOverwrite && tween._pt) {\n        _overwritingTween = tween;\n\n        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!\n\n\n        overwritten = !tween.parent;\n        _overwritingTween = 0;\n      }\n\n      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);\n    }\n\n    hasPriority && _sortPropTweensByPriority(tween);\n    tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.\n  }\n\n  tween._onUpdate = onUpdate;\n  tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.\n\n  keyframes && time <= 0 && tl.render(_bigNum, true, true); // if there's a 0% keyframe, it'll render in the \"before\" state for any staggered/delayed animations thus when the following tween initializes, it'll use the \"before\" state instead of the \"after\" state as the initial values.\n},\n    _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time) {\n  var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],\n      pt,\n      rootPT,\n      lookup,\n      i;\n\n  if (!ptCache) {\n    ptCache = tween._ptCache[property] = [];\n    lookup = tween._ptLookup;\n    i = tween._targets.length;\n\n    while (i--) {\n      pt = lookup[i][property];\n\n      if (pt && pt.d && pt.d._pt) {\n        // it's a plugin, so find the nested PropTween\n        pt = pt.d._pt;\n\n        while (pt && pt.p !== property && pt.fp !== property) {\n          // \"fp\" is functionParam for things like setting CSS variables which require .setProperty(\"--var-name\", value)\n          pt = pt._next;\n        }\n      }\n\n      if (!pt) {\n        // there is no PropTween associated with that property, so we must FORCE one to be created and ditch out of this\n        // if the tween has other properties that already rendered at new positions, we'd normally have to rewind to put them back like tween.render(0, true) before forcing an _initTween(), but that can create another edge case like tweening a timeline's progress would trigger onUpdates to fire which could move other things around. It's better to just inform users that .resetTo() should ONLY be used for tweens that already have that property. For example, you can't gsap.to(...{ y: 0 }) and then tween.restTo(\"x\", 200) for example.\n        _forceAllPropTweens = 1; // otherwise, when we _addPropTween() and it finds no change between the start and end values, it skips creating a PropTween (for efficiency...why tween when there's no difference?) but in this case we NEED that PropTween created so we can edit it.\n\n        tween.vars[property] = \"+=0\";\n\n        _initTween(tween, time);\n\n        _forceAllPropTweens = 0;\n        return 1;\n      }\n\n      ptCache.push(pt);\n    }\n  }\n\n  i = ptCache.length;\n\n  while (i--) {\n    rootPT = ptCache[i];\n    pt = rootPT._pt || rootPT; // complex values may have nested PropTweens. We only accommodate the FIRST value.\n\n    pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;\n    pt.c = value - pt.s;\n    rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e)); // mainly for CSSPlugin (end value)\n\n    rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b)); // (beginning value)\n  }\n},\n    _addAliasesToVars = function _addAliasesToVars(targets, vars) {\n  var harness = targets[0] ? _getCache(targets[0]).harness : 0,\n      propertyAliases = harness && harness.aliases,\n      copy,\n      p,\n      i,\n      aliases;\n\n  if (!propertyAliases) {\n    return vars;\n  }\n\n  copy = _merge({}, vars);\n\n  for (p in propertyAliases) {\n    if (p in copy) {\n      aliases = propertyAliases[p].split(\",\");\n      i = aliases.length;\n\n      while (i--) {\n        copy[aliases[i]] = copy[p];\n      }\n    }\n  }\n\n  return copy;\n},\n    // parses multiple formats, like {\"0%\": {x: 100}, {\"50%\": {x: -20}} and { x: {\"0%\": 100, \"50%\": -20} }, and an \"ease\" can be set on any object. We populate an \"allProps\" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a \"t\" (time), \"v\", (value), and \"e\" (ease) property. This allows us to piece together a timeline later.\n_parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {\n  var ease = obj.ease || easeEach || \"power1.inOut\",\n      p,\n      a;\n\n  if (_isArray(obj)) {\n    a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease\n\n    obj.forEach(function (value, i) {\n      return a.push({\n        t: i / (obj.length - 1) * 100,\n        v: value,\n        e: ease\n      });\n    });\n  } else {\n    for (p in obj) {\n      a = allProps[p] || (allProps[p] = []);\n      p === \"ease\" || a.push({\n        t: parseFloat(prop),\n        v: obj[p],\n        e: ease\n      });\n    }\n  }\n},\n    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {\n  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf(\"random(\") ? _replaceRandom(value) : value;\n},\n    _staggerTweenProps = _callbackNames + \"repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert\",\n    _staggerPropsToSkip = {};\n\n_forEachName(_staggerTweenProps + \",id,stagger,delay,duration,paused,scrollTrigger\", function (name) {\n  return _staggerPropsToSkip[name] = 1;\n});\n/*\n * --------------------------------------------------------------------------------------\n * TWEEN\n * --------------------------------------------------------------------------------------\n */\n\n\nexport var Tween = /*#__PURE__*/function (_Animation2) {\n  _inheritsLoose(Tween, _Animation2);\n\n  function Tween(targets, vars, position, skipInherit) {\n    var _this3;\n\n    if (typeof vars === \"number\") {\n      position.duration = vars;\n      vars = position;\n      position = null;\n    }\n\n    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;\n    var _this3$vars = _this3.vars,\n        duration = _this3$vars.duration,\n        delay = _this3$vars.delay,\n        immediateRender = _this3$vars.immediateRender,\n        stagger = _this3$vars.stagger,\n        overwrite = _this3$vars.overwrite,\n        keyframes = _this3$vars.keyframes,\n        defaults = _this3$vars.defaults,\n        scrollTrigger = _this3$vars.scrollTrigger,\n        yoyoEase = _this3$vars.yoyoEase,\n        parent = vars.parent || _globalTimeline,\n        parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : \"length\" in vars) ? [targets] : toArray(targets),\n        tl,\n        i,\n        copy,\n        l,\n        p,\n        curTarget,\n        staggerFunc,\n        staggerVarsToMerge;\n    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn(\"GSAP target \" + targets + \" not found. https://greensock.com\", !_config.nullTargetWarn) || [];\n    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property\n\n    _this3._overwrite = overwrite;\n\n    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n      vars = _this3.vars;\n      tl = _this3.timeline = new Timeline({\n        data: \"nested\",\n        defaults: defaults || {},\n        targets: parent && parent.data === \"nested\" ? parent.vars.targets : parsedTargets\n      }); // we need to store the targets because for staggers and keyframes, we end up creating an individual tween for each but function-based values need to know the index and the whole Array of targets.\n\n      tl.kill();\n      tl.parent = tl._dp = _assertThisInitialized(_this3);\n      tl._start = 0;\n\n      if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n        l = parsedTargets.length;\n        staggerFunc = stagger && distribute(stagger);\n\n        if (_isObject(stagger)) {\n          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.\n          for (p in stagger) {\n            if (~_staggerTweenProps.indexOf(p)) {\n              staggerVarsToMerge || (staggerVarsToMerge = {});\n              staggerVarsToMerge[p] = stagger[p];\n            }\n          }\n        }\n\n        for (i = 0; i < l; i++) {\n          copy = _copyExcluding(vars, _staggerPropsToSkip);\n          copy.stagger = 0;\n          yoyoEase && (copy.yoyoEase = yoyoEase);\n          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);\n          curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.\n\n          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);\n          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;\n\n          if (!stagger && l === 1 && copy.delay) {\n            // if someone does delay:\"random(1, 5)\", repeat:-1, for example, the delay shouldn't be inside the repeat.\n            _this3._delay = delay = copy.delay;\n            _this3._start += delay;\n            copy.delay = 0;\n          }\n\n          tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);\n          tl._ease = _easeMap.none;\n        }\n\n        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!\n      } else if (keyframes) {\n        _inheritDefaults(_setDefaults(tl.vars.defaults, {\n          ease: \"none\"\n        }));\n\n        tl._ease = _parseEase(keyframes.ease || vars.ease || \"none\");\n        var time = 0,\n            a,\n            kf,\n            v;\n\n        if (_isArray(keyframes)) {\n          keyframes.forEach(function (frame) {\n            return tl.to(parsedTargets, frame, \">\");\n          });\n          tl.duration(); // to ensure tl._dur is cached because we tap into it for performance purposes in the render() method.\n        } else {\n          copy = {};\n\n          for (p in keyframes) {\n            p === \"ease\" || p === \"easeEach\" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);\n          }\n\n          for (p in copy) {\n            a = copy[p].sort(function (a, b) {\n              return a.t - b.t;\n            });\n            time = 0;\n\n            for (i = 0; i < a.length; i++) {\n              kf = a[i];\n              v = {\n                ease: kf.e,\n                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration\n              };\n              v[p] = kf.v;\n              tl.to(parsedTargets, v, time);\n              time += v.duration;\n            }\n          }\n\n          tl.duration() < duration && tl.to({}, {\n            duration: duration - tl.duration()\n          }); // in case keyframes didn't go to 100%\n        }\n      }\n\n      duration || _this3.duration(duration = tl.duration());\n    } else {\n      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)\n    }\n\n    if (overwrite === true && !_suppressOverwrites) {\n      _overwritingTween = _assertThisInitialized(_this3);\n\n      _globalTimeline.killTweensOf(parsedTargets);\n\n      _overwritingTween = 0;\n    }\n\n    _addToTimeline(parent, _assertThisInitialized(_this3), position);\n\n    vars.reversed && _this3.reverse();\n    vars.paused && _this3.paused(true);\n\n    if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== \"nested\") {\n      _this3._tTime = -_tinyNum; //forces a render without having to set the render() \"force\" parameter to true because we want to allow lazying by default (using the \"force\" parameter always forces an immediate full render)\n\n      _this3.render(Math.max(0, -delay) || 0); //in case delay is negative\n\n    }\n\n    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);\n    return _this3;\n  }\n\n  var _proto3 = Tween.prototype;\n\n  _proto3.render = function render(totalTime, suppressEvents, force) {\n    var prevTime = this._time,\n        tDur = this._tDur,\n        dur = this._dur,\n        isNegative = totalTime < 0,\n        tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime,\n        time,\n        pt,\n        iteration,\n        cycleDuration,\n        prevIteration,\n        isYoyo,\n        ratio,\n        timeline,\n        yoyoEase;\n\n    if (!dur) {\n      _renderZeroDurationTween(this, totalTime, suppressEvents, force);\n    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {\n      //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)\n      time = tTime;\n      timeline = this.timeline;\n\n      if (this._repeat) {\n        //adjust the time for repeats and yoyos\n        cycleDuration = dur + this._rDelay;\n\n        if (this._repeat < -1 && isNegative) {\n          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n        }\n\n        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)\n\n        if (tTime === tDur) {\n          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)\n          iteration = this._repeat;\n          time = dur;\n        } else {\n          iteration = ~~(tTime / cycleDuration);\n\n          if (iteration && iteration === tTime / cycleDuration) {\n            time = dur;\n            iteration--;\n          }\n\n          time > dur && (time = dur);\n        }\n\n        isYoyo = this._yoyo && iteration & 1;\n\n        if (isYoyo) {\n          yoyoEase = this._yEase;\n          time = dur - time;\n        }\n\n        prevIteration = _animationCycle(this._tTime, cycleDuration);\n\n        if (time === prevTime && !force && this._initted) {\n          //could be during the repeatDelay part. No need to render and fire callbacks.\n          this._tTime = tTime;\n          return this;\n        }\n\n        if (iteration !== prevIteration) {\n          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality\n\n          if (this.vars.repeatRefresh && !isYoyo && !this._lock) {\n            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.\n\n            this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;\n          }\n        }\n      }\n\n      if (!this._initted) {\n        if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {\n          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.\n\n          return this;\n        }\n\n        if (prevTime !== this._time) {\n          // rare edge case - during initialization, an onUpdate in the _startAt (.fromTo()) might force this tween to render at a different spot in which case we should ditch this render() call so that it doesn't revert the values.\n          return this;\n        }\n\n        if (dur !== this._dur) {\n          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.\n          return this.render(totalTime, suppressEvents, force);\n        }\n      }\n\n      this._tTime = tTime;\n      this._time = time;\n\n      if (!this._act && this._ts) {\n        this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.\n\n        this._lazy = 0;\n      }\n\n      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);\n\n      if (this._from) {\n        this.ratio = ratio = 1 - ratio;\n      }\n\n      if (time && !prevTime && !suppressEvents && !iteration) {\n        _callback(this, \"onStart\");\n\n        if (this._tTime !== tTime) {\n          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.\n          return this;\n        }\n      }\n\n      pt = this._pt;\n\n      while (pt) {\n        pt.r(ratio, pt.d);\n        pt = pt._next;\n      }\n\n      timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);\n\n      if (this._onUpdate && !suppressEvents) {\n        isNegative && _rewindStartAt(this, totalTime, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.\n\n        _callback(this, \"onUpdate\");\n      }\n\n      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, \"onRepeat\");\n\n      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {\n        isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);\n        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.\n\n        if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {\n          // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();\n          _callback(this, tTime === tDur ? \"onComplete\" : \"onReverseComplete\", true);\n\n          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n        }\n      }\n    }\n\n    return this;\n  };\n\n  _proto3.targets = function targets() {\n    return this._targets;\n  };\n\n  _proto3.invalidate = function invalidate(soft) {\n    // \"soft\" gives us a way to clear out everything EXCEPT the recorded pre-\"from\" portion of from() tweens. Otherwise, for example, if you tween.progress(1).render(0, true true).invalidate(), the \"from\" values would persist and then on the next render, the from() tweens would initialize and the current value would match the \"from\" values, thus animate from the same value to the same value (no animation). We tap into this in ScrollTrigger's refresh() where we must push a tween to completion and then back again but honor its init state in case the tween is dependent on another tween further up on the page.\n    (!soft || !this.vars.runBackwards) && (this._startAt = 0);\n    this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;\n    this._ptLookup = [];\n    this.timeline && this.timeline.invalidate(soft);\n    return _Animation2.prototype.invalidate.call(this, soft);\n  };\n\n  _proto3.resetTo = function resetTo(property, value, start, startIsRelative) {\n    _tickerActive || _ticker.wake();\n    this._ts || this.play();\n    var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),\n        ratio;\n    this._initted || _initTween(this, time);\n    ratio = this._ease(time / this._dur); // don't just get tween.ratio because it may not have rendered yet.\n    // possible future addition to allow an object with multiple values to update, like tween.resetTo({x: 100, y: 200}); At this point, it doesn't seem worth the added kb given the fact that most users will likely opt for the convenient gsap.quickTo() way of interacting with this method.\n    // if (_isObject(property)) { // performance optimization\n    // \tfor (p in property) {\n    // \t\tif (_updatePropTweens(this, p, property[p], value ? value[p] : null, start, ratio, time)) {\n    // \t\t\treturn this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.\n    // \t\t}\n    // \t}\n    // } else {\n\n    if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time)) {\n      return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.\n    } //}\n\n\n    _alignPlayhead(this, 0);\n\n    this.parent || _addLinkedListItem(this._dp, this, \"_first\", \"_last\", this._dp._sort ? \"_start\" : 0);\n    return this.render(0);\n  };\n\n  _proto3.kill = function kill(targets, vars) {\n    if (vars === void 0) {\n      vars = \"all\";\n    }\n\n    if (!targets && (!vars || vars === \"all\")) {\n      this._lazy = this._pt = 0;\n      return this.parent ? _interrupt(this) : this;\n    }\n\n    if (this.timeline) {\n      var tDur = this.timeline.totalDuration();\n      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.\n\n      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.\n\n      return this;\n    }\n\n    var parsedTargets = this._targets,\n        killingTargets = targets ? toArray(targets) : parsedTargets,\n        propTweenLookup = this._ptLookup,\n        firstPT = this._pt,\n        overwrittenProps,\n        curLookup,\n        curOverwriteProps,\n        props,\n        p,\n        pt,\n        i;\n\n    if ((!vars || vars === \"all\") && _arraysMatch(parsedTargets, killingTargets)) {\n      vars === \"all\" && (this._pt = 0);\n      return _interrupt(this);\n    }\n\n    overwrittenProps = this._op = this._op || [];\n\n    if (vars !== \"all\") {\n      //so people can pass in a comma-delimited list of property names\n      if (_isString(vars)) {\n        p = {};\n\n        _forEachName(vars, function (name) {\n          return p[name] = 1;\n        });\n\n        vars = p;\n      }\n\n      vars = _addAliasesToVars(parsedTargets, vars);\n    }\n\n    i = parsedTargets.length;\n\n    while (i--) {\n      if (~killingTargets.indexOf(parsedTargets[i])) {\n        curLookup = propTweenLookup[i];\n\n        if (vars === \"all\") {\n          overwrittenProps[i] = vars;\n          props = curLookup;\n          curOverwriteProps = {};\n        } else {\n          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};\n          props = vars;\n        }\n\n        for (p in props) {\n          pt = curLookup && curLookup[p];\n\n          if (pt) {\n            if (!(\"kill\" in pt.d) || pt.d.kill(p) === true) {\n              _removeLinkedListItem(this, pt, \"_pt\");\n            }\n\n            delete curLookup[p];\n          }\n\n          if (curOverwriteProps !== \"all\") {\n            curOverwriteProps[p] = 1;\n          }\n        }\n      }\n    }\n\n    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.\n\n    return this;\n  };\n\n  Tween.to = function to(targets, vars) {\n    return new Tween(targets, vars, arguments[2]);\n  };\n\n  Tween.from = function from(targets, vars) {\n    return _createTweenType(1, arguments);\n  };\n\n  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {\n    return new Tween(callback, 0, {\n      immediateRender: false,\n      lazy: false,\n      overwrite: false,\n      delay: delay,\n      onComplete: callback,\n      onReverseComplete: callback,\n      onCompleteParams: params,\n      onReverseCompleteParams: params,\n      callbackScope: scope\n    }); // we must use onReverseComplete too for things like timeline.add(() => {...}) which should be triggered in BOTH directions (forward and reverse)\n  };\n\n  Tween.fromTo = function fromTo(targets, fromVars, toVars) {\n    return _createTweenType(2, arguments);\n  };\n\n  Tween.set = function set(targets, vars) {\n    vars.duration = 0;\n    vars.repeatDelay || (vars.repeat = 0);\n    return new Tween(targets, vars);\n  };\n\n  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n    return _globalTimeline.killTweensOf(targets, props, onlyActive);\n  };\n\n  return Tween;\n}(Animation);\n\n_setDefaults(Tween.prototype, {\n  _targets: [],\n  _lazy: 0,\n  _startAt: 0,\n  _op: 0,\n  _onInit: 0\n}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)\n// _forEachName(\"to,from,fromTo,set,call,add,addLabel,addPause\", name => {\n// \tTween.prototype[name] = function() {\n// \t\tlet tl = new Timeline();\n// \t\treturn _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));\n// \t}\n// });\n//for backward compatibility. Leverage the timeline calls.\n\n\n_forEachName(\"staggerTo,staggerFrom,staggerFromTo\", function (name) {\n  Tween[name] = function () {\n    var tl = new Timeline(),\n        params = _slice.call(arguments, 0);\n\n    params.splice(name === \"staggerFromTo\" ? 5 : 4, 0, 0);\n    return tl[name].apply(tl, params);\n  };\n});\n/*\n * --------------------------------------------------------------------------------------\n * PROPTWEEN\n * --------------------------------------------------------------------------------------\n */\n\n\nvar _setterPlain = function _setterPlain(target, property, value) {\n  return target[property] = value;\n},\n    _setterFunc = function _setterFunc(target, property, value) {\n  return target[property](value);\n},\n    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {\n  return target[property](data.fp, value);\n},\n    _setterAttribute = function _setterAttribute(target, property, value) {\n  return target.setAttribute(property, value);\n},\n    _getSetter = function _getSetter(target, property) {\n  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;\n},\n    _renderPlain = function _renderPlain(ratio, data) {\n  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);\n},\n    _renderBoolean = function _renderBoolean(ratio, data) {\n  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);\n},\n    _renderComplexString = function _renderComplexString(ratio, data) {\n  var pt = data._pt,\n      s = \"\";\n\n  if (!ratio && data.b) {\n    //b = beginning string\n    s = data.b;\n  } else if (ratio === 1 && data.e) {\n    //e = ending string\n    s = data.e;\n  } else {\n    while (pt) {\n      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the \"p\" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.\n\n      pt = pt._next;\n    }\n\n    s += data.c; //we use the \"c\" of the PropTween to store the final chunk of non-numeric text.\n  }\n\n  data.set(data.t, data.p, s, data);\n},\n    _renderPropTweens = function _renderPropTweens(ratio, data) {\n  var pt = data._pt;\n\n  while (pt) {\n    pt.r(ratio, pt.d);\n    pt = pt._next;\n  }\n},\n    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {\n  var pt = this._pt,\n      next;\n\n  while (pt) {\n    next = pt._next;\n    pt.p === property && pt.modifier(modifier, tween, target);\n    pt = next;\n  }\n},\n    _killPropTweensOf = function _killPropTweensOf(property) {\n  var pt = this._pt,\n      hasNonDependentRemaining,\n      next;\n\n  while (pt) {\n    next = pt._next;\n\n    if (pt.p === property && !pt.op || pt.op === property) {\n      _removeLinkedListItem(this, pt, \"_pt\");\n    } else if (!pt.dep) {\n      hasNonDependentRemaining = 1;\n    }\n\n    pt = next;\n  }\n\n  return !hasNonDependentRemaining;\n},\n    _setterWithModifier = function _setterWithModifier(target, property, value, data) {\n  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);\n},\n    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {\n  var pt = parent._pt,\n      next,\n      pt2,\n      first,\n      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)\n\n  while (pt) {\n    next = pt._next;\n    pt2 = first;\n\n    while (pt2 && pt2.pr > pt.pr) {\n      pt2 = pt2._next;\n    }\n\n    if (pt._prev = pt2 ? pt2._prev : last) {\n      pt._prev._next = pt;\n    } else {\n      first = pt;\n    }\n\n    if (pt._next = pt2) {\n      pt2._prev = pt;\n    } else {\n      last = pt;\n    }\n\n    pt = next;\n  }\n\n  parent._pt = first;\n}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)\n\n\nexport var PropTween = /*#__PURE__*/function () {\n  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {\n    this.t = target;\n    this.s = start;\n    this.c = change;\n    this.p = prop;\n    this.r = renderer || _renderPlain;\n    this.d = data || this;\n    this.set = setter || _setterPlain;\n    this.pr = priority || 0;\n    this._next = next;\n\n    if (next) {\n      next._prev = this;\n    }\n  }\n\n  var _proto4 = PropTween.prototype;\n\n  _proto4.modifier = function modifier(func, tween, target) {\n    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)\n\n    this.set = _setterWithModifier;\n    this.m = func;\n    this.mt = target; //modifier target\n\n    this.tween = tween;\n  };\n\n  return PropTween;\n}(); //Initialization tasks\n\n_forEachName(_callbackNames + \"parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger\", function (name) {\n  return _reservedProps[name] = 1;\n});\n\n_globals.TweenMax = _globals.TweenLite = Tween;\n_globals.TimelineLite = _globals.TimelineMax = Timeline;\n_globalTimeline = new Timeline({\n  sortChildren: false,\n  defaults: _defaults,\n  autoRemoveChildren: true,\n  id: \"root\",\n  smoothChildTiming: true\n});\n_config.stringFilter = _colorStringFilter;\n\nvar _media = [],\n    _listeners = {},\n    _emptyArray = [],\n    _lastMediaTime = 0,\n    _contextID = 0,\n    _dispatch = function _dispatch(type) {\n  return (_listeners[type] || _emptyArray).map(function (f) {\n    return f();\n  });\n},\n    _onMediaChange = function _onMediaChange() {\n  var time = Date.now(),\n      matches = [];\n\n  if (time - _lastMediaTime > 2) {\n    _dispatch(\"matchMediaInit\");\n\n    _media.forEach(function (c) {\n      var queries = c.queries,\n          conditions = c.conditions,\n          match,\n          p,\n          anyMatch,\n          toggled;\n\n      for (p in queries) {\n        match = _win.matchMedia(queries[p]).matches; // Firefox doesn't update the \"matches\" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.\n\n        match && (anyMatch = 1);\n\n        if (match !== conditions[p]) {\n          conditions[p] = match;\n          toggled = 1;\n        }\n      }\n\n      if (toggled) {\n        c.revert();\n        anyMatch && matches.push(c);\n      }\n    });\n\n    _dispatch(\"matchMediaRevert\");\n\n    matches.forEach(function (c) {\n      return c.onMatch(c);\n    });\n    _lastMediaTime = time;\n\n    _dispatch(\"matchMedia\");\n  }\n};\n\nvar Context = /*#__PURE__*/function () {\n  function Context(func, scope) {\n    this.selector = scope && selector(scope);\n    this.data = [];\n    this._r = []; // returned/cleanup functions\n\n    this.isReverted = false;\n    this.id = _contextID++; // to work around issues that frameworks like Vue cause by making things into Proxies which make it impossible to do something like _media.indexOf(this) because \"this\" would no longer refer to the Context instance itself - it'd refer to a Proxy! We needed a way to identify the context uniquely\n\n    func && this.add(func);\n  }\n\n  var _proto5 = Context.prototype;\n\n  _proto5.add = function add(name, func, scope) {\n    // possible future addition if we need the ability to add() an animation to a context and for whatever reason cannot create that animation inside of a context.add(() => {...}) function.\n    // if (name && _isFunction(name.revert)) {\n    // \tthis.data.push(name);\n    // \treturn (name._ctx = this);\n    // }\n    if (_isFunction(name)) {\n      scope = func;\n      func = name;\n      name = _isFunction;\n    }\n\n    var self = this,\n        f = function f() {\n      var prev = _context,\n          prevSelector = self.selector,\n          result;\n      prev && prev !== self && prev.data.push(self);\n      scope && (self.selector = selector(scope));\n      _context = self;\n      result = func.apply(self, arguments);\n      _isFunction(result) && self._r.push(result);\n      _context = prev;\n      self.selector = prevSelector;\n      self.isReverted = false;\n      return result;\n    };\n\n    self.last = f;\n    return name === _isFunction ? f(self) : name ? self[name] = f : f;\n  };\n\n  _proto5.ignore = function ignore(func) {\n    var prev = _context;\n    _context = null;\n    func(this);\n    _context = prev;\n  };\n\n  _proto5.getTweens = function getTweens() {\n    var a = [];\n    this.data.forEach(function (e) {\n      return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === \"nested\") && a.push(e);\n    });\n    return a;\n  };\n\n  _proto5.clear = function clear() {\n    this._r.length = this.data.length = 0;\n  };\n\n  _proto5.kill = function kill(revert, matchMedia) {\n    var _this4 = this;\n\n    if (revert) {\n      var tweens = this.getTweens();\n      this.data.forEach(function (t) {\n        // Flip plugin tweens are very different in that they should actually be pushed to their end. The plugin replaces the timeline's .revert() method to do exactly that. But we also need to remove any of those nested tweens inside the flip timeline so that they don't get individually reverted.\n        if (t.data === \"isFlip\") {\n          t.revert();\n          t.getChildren(true, true, false).forEach(function (tween) {\n            return tweens.splice(tweens.indexOf(tween), 1);\n          });\n        }\n      }); // save as an object so that we can cache the globalTime for each tween to optimize performance during the sort\n\n      tweens.map(function (t) {\n        return {\n          g: t.globalTime(0),\n          t: t\n        };\n      }).sort(function (a, b) {\n        return b.g - a.g || -Infinity;\n      }).forEach(function (o) {\n        return o.t.revert(revert);\n      }); // note: all of the _startAt tweens should be reverted in reverse order that they were created, and they'll all have the same globalTime (-1) so the \" || -1\" in the sort keeps the order properly.\n\n      this.data.forEach(function (e) {\n        return !(e instanceof Tween) && e.revert && e.revert(revert);\n      });\n\n      this._r.forEach(function (f) {\n        return f(revert, _this4);\n      });\n\n      this.isReverted = true;\n    } else {\n      this.data.forEach(function (e) {\n        return e.kill && e.kill();\n      });\n    }\n\n    this.clear();\n\n    if (matchMedia) {\n      var i = _media.length;\n\n      while (i--) {\n        // previously, we checked _media.indexOf(this), but some frameworks like Vue enforce Proxy objects that make it impossible to get the proper result that way, so we must use a unique ID number instead.\n        _media[i].id === this.id && _media.splice(i, 1);\n      }\n    }\n  };\n\n  _proto5.revert = function revert(config) {\n    this.kill(config || {});\n  };\n\n  return Context;\n}();\n\nvar MatchMedia = /*#__PURE__*/function () {\n  function MatchMedia(scope) {\n    this.contexts = [];\n    this.scope = scope;\n  }\n\n  var _proto6 = MatchMedia.prototype;\n\n  _proto6.add = function add(conditions, func, scope) {\n    _isObject(conditions) || (conditions = {\n      matches: conditions\n    });\n    var context = new Context(0, scope || this.scope),\n        cond = context.conditions = {},\n        mq,\n        p,\n        active;\n    _context && !context.selector && (context.selector = _context.selector); // in case a context is created inside a context. Like a gsap.matchMedia() that's inside a scoped gsap.context()\n\n    this.contexts.push(context);\n    func = context.add(\"onMatch\", func);\n    context.queries = conditions;\n\n    for (p in conditions) {\n      if (p === \"all\") {\n        active = 1;\n      } else {\n        mq = _win.matchMedia(conditions[p]);\n\n        if (mq) {\n          _media.indexOf(context) < 0 && _media.push(context);\n          (cond[p] = mq.matches) && (active = 1);\n          mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener(\"change\", _onMediaChange);\n        }\n      }\n    }\n\n    active && func(context);\n    return this;\n  } // refresh() {\n  // \tlet time = _lastMediaTime,\n  // \t\tmedia = _media;\n  // \t_lastMediaTime = -1;\n  // \t_media = this.contexts;\n  // \t_onMediaChange();\n  // \t_lastMediaTime = time;\n  // \t_media = media;\n  // }\n  ;\n\n  _proto6.revert = function revert(config) {\n    this.kill(config || {});\n  };\n\n  _proto6.kill = function kill(revert) {\n    this.contexts.forEach(function (c) {\n      return c.kill(revert, true);\n    });\n  };\n\n  return MatchMedia;\n}();\n/*\n * --------------------------------------------------------------------------------------\n * GSAP\n * --------------------------------------------------------------------------------------\n */\n\n\nvar _gsap = {\n  registerPlugin: function registerPlugin() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    args.forEach(function (config) {\n      return _createPlugin(config);\n    });\n  },\n  timeline: function timeline(vars) {\n    return new Timeline(vars);\n  },\n  getTweensOf: function getTweensOf(targets, onlyActive) {\n    return _globalTimeline.getTweensOf(targets, onlyActive);\n  },\n  getProperty: function getProperty(target, property, unit, uncache) {\n    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in\n\n    var getter = _getCache(target || {}).get,\n        format = unit ? _passThrough : _numericIfPossible;\n\n    unit === \"native\" && (unit = \"\");\n    return !target ? target : !property ? function (property, unit, uncache) {\n      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n  },\n  quickSetter: function quickSetter(target, property, unit) {\n    target = toArray(target);\n\n    if (target.length > 1) {\n      var setters = target.map(function (t) {\n        return gsap.quickSetter(t, property, unit);\n      }),\n          l = setters.length;\n      return function (value) {\n        var i = l;\n\n        while (i--) {\n          setters[i](value);\n        }\n      };\n    }\n\n    target = target[0] || {};\n\n    var Plugin = _plugins[property],\n        cache = _getCache(target),\n        p = cache.harness && (cache.harness.aliases || {})[property] || property,\n        // in case it's an alias, like \"rotate\" for \"rotation\".\n    setter = Plugin ? function (value) {\n      var p = new Plugin();\n      _quickTween._pt = 0;\n      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);\n      p.render(1, p);\n      _quickTween._pt && _renderPropTweens(1, _quickTween);\n    } : cache.set(target, p);\n\n    return Plugin ? setter : function (value) {\n      return setter(target, p, unit ? value + unit : value, cache, 1);\n    };\n  },\n  quickTo: function quickTo(target, property, vars) {\n    var _merge2;\n\n    var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = \"+=0.1\", _merge2.paused = true, _merge2), vars || {})),\n        func = function func(value, start, startIsRelative) {\n      return tween.resetTo(property, value, start, startIsRelative);\n    };\n\n    func.tween = tween;\n    return func;\n  },\n  isTweening: function isTweening(targets) {\n    return _globalTimeline.getTweensOf(targets, true).length > 0;\n  },\n  defaults: function defaults(value) {\n    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));\n    return _mergeDeep(_defaults, value || {});\n  },\n  config: function config(value) {\n    return _mergeDeep(_config, value || {});\n  },\n  registerEffect: function registerEffect(_ref3) {\n    var name = _ref3.name,\n        effect = _ref3.effect,\n        plugins = _ref3.plugins,\n        defaults = _ref3.defaults,\n        extendTimeline = _ref3.extendTimeline;\n    (plugins || \"\").split(\",\").forEach(function (pluginName) {\n      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + \" effect requires \" + pluginName + \" plugin.\");\n    });\n\n    _effects[name] = function (targets, vars, tl) {\n      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);\n    };\n\n    if (extendTimeline) {\n      Timeline.prototype[name] = function (targets, vars, position) {\n        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);\n      };\n    }\n  },\n  registerEase: function registerEase(name, ease) {\n    _easeMap[name] = _parseEase(ease);\n  },\n  parseEase: function parseEase(ease, defaultEase) {\n    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;\n  },\n  getById: function getById(id) {\n    return _globalTimeline.getById(id);\n  },\n  exportRoot: function exportRoot(vars, includeDelayedCalls) {\n    if (vars === void 0) {\n      vars = {};\n    }\n\n    var tl = new Timeline(vars),\n        child,\n        next;\n    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);\n\n    _globalTimeline.remove(tl);\n\n    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).\n\n    tl._time = tl._tTime = _globalTimeline._time;\n    child = _globalTimeline._first;\n\n    while (child) {\n      next = child._next;\n\n      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {\n        _addToTimeline(tl, child, child._start - child._delay);\n      }\n\n      child = next;\n    }\n\n    _addToTimeline(_globalTimeline, tl, 0);\n\n    return tl;\n  },\n  context: function context(func, scope) {\n    return func ? new Context(func, scope) : _context;\n  },\n  matchMedia: function matchMedia(scope) {\n    return new MatchMedia(scope);\n  },\n  matchMediaRefresh: function matchMediaRefresh() {\n    return _media.forEach(function (c) {\n      var cond = c.conditions,\n          found,\n          p;\n\n      for (p in cond) {\n        if (cond[p]) {\n          cond[p] = false;\n          found = 1;\n        }\n      }\n\n      found && c.revert();\n    }) || _onMediaChange();\n  },\n  addEventListener: function addEventListener(type, callback) {\n    var a = _listeners[type] || (_listeners[type] = []);\n    ~a.indexOf(callback) || a.push(callback);\n  },\n  removeEventListener: function removeEventListener(type, callback) {\n    var a = _listeners[type],\n        i = a && a.indexOf(callback);\n    i >= 0 && a.splice(i, 1);\n  },\n  utils: {\n    wrap: wrap,\n    wrapYoyo: wrapYoyo,\n    distribute: distribute,\n    random: random,\n    snap: snap,\n    normalize: normalize,\n    getUnit: getUnit,\n    clamp: clamp,\n    splitColor: splitColor,\n    toArray: toArray,\n    selector: selector,\n    mapRange: mapRange,\n    pipe: pipe,\n    unitize: unitize,\n    interpolate: interpolate,\n    shuffle: shuffle\n  },\n  install: _install,\n  effects: _effects,\n  ticker: _ticker,\n  updateRoot: Timeline.updateRoot,\n  plugins: _plugins,\n  globalTimeline: _globalTimeline,\n  core: {\n    PropTween: PropTween,\n    globals: _addGlobal,\n    Tween: Tween,\n    Timeline: Timeline,\n    Animation: Animation,\n    getCache: _getCache,\n    _removeLinkedListItem: _removeLinkedListItem,\n    reverting: function reverting() {\n      return _reverting;\n    },\n    context: function context(toAdd) {\n      if (toAdd && _context) {\n        _context.data.push(toAdd);\n\n        toAdd._ctx = _context;\n      }\n\n      return _context;\n    },\n    suppressOverwrites: function suppressOverwrites(value) {\n      return _suppressOverwrites = value;\n    }\n  }\n};\n\n_forEachName(\"to,from,fromTo,delayedCall,set,killTweensOf\", function (name) {\n  return _gsap[name] = Tween[name];\n});\n\n_ticker.add(Timeline.updateRoot);\n\n_quickTween = _gsap.to({}, {\n  duration: 0\n}); // ---- EXTRA PLUGINS --------------------------------------------------------\n\nvar _getPluginPropTween = function _getPluginPropTween(plugin, prop) {\n  var pt = plugin._pt;\n\n  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {\n    pt = pt._next;\n  }\n\n  return pt;\n},\n    _addModifiers = function _addModifiers(tween, modifiers) {\n  var targets = tween._targets,\n      p,\n      i,\n      pt;\n\n  for (p in modifiers) {\n    i = targets.length;\n\n    while (i--) {\n      pt = tween._ptLookup[i][p];\n\n      if (pt && (pt = pt.d)) {\n        if (pt._pt) {\n          // is a plugin\n          pt = _getPluginPropTween(pt, p);\n        }\n\n        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);\n      }\n    }\n  }\n},\n    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {\n  return {\n    name: name,\n    rawVars: 1,\n    //don't pre-process function-based values or \"random()\" strings.\n    init: function init(target, vars, tween) {\n      tween._onInit = function (tween) {\n        var temp, p;\n\n        if (_isString(vars)) {\n          temp = {};\n\n          _forEachName(vars, function (name) {\n            return temp[name] = 1;\n          }); //if the user passes in a comma-delimited list of property names to roundProps, like \"x,y\", we round to whole numbers.\n\n\n          vars = temp;\n        }\n\n        if (modifier) {\n          temp = {};\n\n          for (p in vars) {\n            temp[p] = modifier(vars[p]);\n          }\n\n          vars = temp;\n        }\n\n        _addModifiers(tween, vars);\n      };\n    }\n  };\n}; //register core plugins\n\n\nexport var gsap = _gsap.registerPlugin({\n  name: \"attr\",\n  init: function init(target, vars, tween, index, targets) {\n    var p, pt, v;\n    this.tween = tween;\n\n    for (p in vars) {\n      v = target.getAttribute(p) || \"\";\n      pt = this.add(target, \"setAttribute\", (v || 0) + \"\", vars[p], index, targets, 0, 0, p);\n      pt.op = p;\n      pt.b = v; // record the beginning value so we can revert()\n\n      this._props.push(p);\n    }\n  },\n  render: function render(ratio, data) {\n    var pt = data._pt;\n\n    while (pt) {\n      _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d); // if reverting, go back to the original (pt.b)\n\n      pt = pt._next;\n    }\n  }\n}, {\n  name: \"endArray\",\n  init: function init(target, value) {\n    var i = value.length;\n\n    while (i--) {\n      this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);\n    }\n  }\n}, _buildModifierPlugin(\"roundProps\", _roundModifier), _buildModifierPlugin(\"modifiers\"), _buildModifierPlugin(\"snap\", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.\n\nTween.version = Timeline.version = gsap.version = \"3.12.2\";\n_coreReady = 1;\n_windowExists() && _wake();\nvar Power0 = _easeMap.Power0,\n    Power1 = _easeMap.Power1,\n    Power2 = _easeMap.Power2,\n    Power3 = _easeMap.Power3,\n    Power4 = _easeMap.Power4,\n    Linear = _easeMap.Linear,\n    Quad = _easeMap.Quad,\n    Cubic = _easeMap.Cubic,\n    Quart = _easeMap.Quart,\n    Quint = _easeMap.Quint,\n    Strong = _easeMap.Strong,\n    Elastic = _easeMap.Elastic,\n    Back = _easeMap.Back,\n    SteppedEase = _easeMap.SteppedEase,\n    Bounce = _easeMap.Bounce,\n    Sine = _easeMap.Sine,\n    Expo = _easeMap.Expo,\n    Circ = _easeMap.Circ;\nexport { Power0, Power1, Power2, Power3, Power4, Linear, Quad, Cubic, Quart, Quint, Strong, Elastic, Back, SteppedEase, Bounce, Sine, Expo, Circ };\nexport { Tween as TweenMax, Tween as TweenLite, Timeline as TimelineMax, Timeline as TimelineLite, gsap as default, wrap, wrapYoyo, distribute, random, snap, normalize, getUnit, clamp, splitColor, toArray, selector, mapRange, pipe, unitize, interpolate, shuffle }; //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.\n\nexport { _getProperty, _numExp, _numWithUnitExp, _isString, _isUndefined, _renderComplexString, _relExp, _setDefaults, _removeLinkedListItem, _forEachName, _sortPropTweensByPriority, _colorStringFilter, _replaceRandom, _checkPlugin, _plugins, _ticker, _config, _roundModifier, _round, _missingPlugin, _getSetter, _getCache, _colorExp, _parseRelative };","/*!\n * CSSPlugin 3.12.2\n * https://greensock.com\n *\n * Copyright 2008-2023, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nimport { gsap, _getProperty, _numExp, _numWithUnitExp, getUnit, _isString, _isUndefined, _renderComplexString, _relExp, _forEachName, _sortPropTweensByPriority, _colorStringFilter, _checkPlugin, _replaceRandom, _plugins, GSCache, PropTween, _config, _ticker, _round, _missingPlugin, _getSetter, _getCache, _colorExp, _parseRelative, _setDefaults, _removeLinkedListItem //for the commented-out className feature.\n} from \"./gsap-core.js\";\n\nvar _win,\n    _doc,\n    _docElement,\n    _pluginInitted,\n    _tempDiv,\n    _tempDivStyler,\n    _recentSetterPlugin,\n    _reverting,\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _transformProps = {},\n    _RAD2DEG = 180 / Math.PI,\n    _DEG2RAD = Math.PI / 180,\n    _atan2 = Math.atan2,\n    _bigNum = 1e8,\n    _capsExp = /([A-Z])/g,\n    _horizontalExp = /(left|right|width|margin|padding|x)/i,\n    _complexExp = /[\\s,\\(]\\S/,\n    _propertyAliases = {\n  autoAlpha: \"opacity,visibility\",\n  scale: \"scaleX,scaleY\",\n  alpha: \"opacity\"\n},\n    _renderCSSProp = function _renderCSSProp(ratio, data) {\n  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\n},\n    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {\n  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\n},\n    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {\n  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);\n},\n    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)\n_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {\n  var value = data.s + data.c * ratio;\n  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);\n},\n    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {\n  return data.set(data.t, data.p, ratio ? data.e : data.b, data);\n},\n    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {\n  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);\n},\n    _setterCSSStyle = function _setterCSSStyle(target, property, value) {\n  return target.style[property] = value;\n},\n    _setterCSSProp = function _setterCSSProp(target, property, value) {\n  return target.style.setProperty(property, value);\n},\n    _setterTransform = function _setterTransform(target, property, value) {\n  return target._gsap[property] = value;\n},\n    _setterScale = function _setterScale(target, property, value) {\n  return target._gsap.scaleX = target._gsap.scaleY = value;\n},\n    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {\n  var cache = target._gsap;\n  cache.scaleX = cache.scaleY = value;\n  cache.renderTransform(ratio, cache);\n},\n    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {\n  var cache = target._gsap;\n  cache[property] = value;\n  cache.renderTransform(ratio, cache);\n},\n    _transformProp = \"transform\",\n    _transformOriginProp = _transformProp + \"Origin\",\n    _saveStyle = function _saveStyle(property, isNotCSS) {\n  var _this = this;\n\n  var target = this.target,\n      style = target.style;\n\n  if (property in _transformProps && style) {\n    this.tfm = this.tfm || {};\n\n    if (property !== \"transform\") {\n      property = _propertyAliases[property] || property;\n      ~property.indexOf(\",\") ? property.split(\",\").forEach(function (a) {\n        return _this.tfm[a] = _get(target, a);\n      }) : this.tfm[property] = target._gsap.x ? target._gsap[property] : _get(target, property); // note: scale would map to \"scaleX,scaleY\", thus we loop and apply them both.\n    } else {\n      return _propertyAliases.transform.split(\",\").forEach(function (p) {\n        return _saveStyle.call(_this, p, isNotCSS);\n      });\n    }\n\n    if (this.props.indexOf(_transformProp) >= 0) {\n      return;\n    }\n\n    if (target._gsap.svg) {\n      this.svgo = target.getAttribute(\"data-svg-origin\");\n      this.props.push(_transformOriginProp, isNotCSS, \"\");\n    }\n\n    property = _transformProp;\n  }\n\n  (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);\n},\n    _removeIndependentTransforms = function _removeIndependentTransforms(style) {\n  if (style.translate) {\n    style.removeProperty(\"translate\");\n    style.removeProperty(\"scale\");\n    style.removeProperty(\"rotate\");\n  }\n},\n    _revertStyle = function _revertStyle() {\n  var props = this.props,\n      target = this.target,\n      style = target.style,\n      cache = target._gsap,\n      i,\n      p;\n\n  for (i = 0; i < props.length; i += 3) {\n    // stored like this: property, isNotCSS, value\n    props[i + 1] ? target[props[i]] = props[i + 2] : props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === \"--\" ? props[i] : props[i].replace(_capsExp, \"-$1\").toLowerCase());\n  }\n\n  if (this.tfm) {\n    for (p in this.tfm) {\n      cache[p] = this.tfm[p];\n    }\n\n    if (cache.svg) {\n      cache.renderTransform();\n      target.setAttribute(\"data-svg-origin\", this.svgo || \"\");\n    }\n\n    i = _reverting();\n\n    if ((!i || !i.isStart) && !style[_transformProp]) {\n      _removeIndependentTransforms(style);\n\n      cache.uncache = 1; // if it's a startAt that's being reverted in the _initTween() of the core, we don't need to uncache transforms. This is purely a performance optimization.\n    }\n  }\n},\n    _getStyleSaver = function _getStyleSaver(target, properties) {\n  var saver = {\n    target: target,\n    props: [],\n    revert: _revertStyle,\n    save: _saveStyle\n  };\n  target._gsap || gsap.core.getCache(target); // just make sure there's a _gsap cache defined because we read from it in _saveStyle() and it's more efficient to just check it here once.\n\n  properties && properties.split(\",\").forEach(function (p) {\n    return saver.save(p);\n  });\n  return saver;\n},\n    _supports3D,\n    _createElement = function _createElement(type, ns) {\n  var e = _doc.createElementNS ? _doc.createElementNS((ns || \"http://www.w3.org/1999/xhtml\").replace(/^https/, \"http\"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making \"style\" inaccessible.\n\n  return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).\n},\n    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {\n  var cs = getComputedStyle(target);\n  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, \"-$1\").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || \"\"; //css variables may not need caps swapped out for dashes and lowercase.\n},\n    _prefixes = \"O,Moz,ms,Ms,Webkit\".split(\",\"),\n    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {\n  var e = element || _tempDiv,\n      s = e.style,\n      i = 5;\n\n  if (property in s && !preferPrefix) {\n    return property;\n  }\n\n  property = property.charAt(0).toUpperCase() + property.substr(1);\n\n  while (i-- && !(_prefixes[i] + property in s)) {}\n\n  return i < 0 ? null : (i === 3 ? \"ms\" : i >= 0 ? _prefixes[i] : \"\") + property;\n},\n    _initCore = function _initCore() {\n  if (_windowExists() && window.document) {\n    _win = window;\n    _doc = _win.document;\n    _docElement = _doc.documentElement;\n    _tempDiv = _createElement(\"div\") || {\n      style: {}\n    };\n    _tempDivStyler = _createElement(\"div\");\n    _transformProp = _checkPropPrefix(_transformProp);\n    _transformOriginProp = _transformProp + \"Origin\";\n    _tempDiv.style.cssText = \"border-width:0;line-height:0;position:absolute;padding:0\"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.\n\n    _supports3D = !!_checkPropPrefix(\"perspective\");\n    _reverting = gsap.core.reverting;\n    _pluginInitted = 1;\n  }\n},\n    _getBBoxHack = function _getBBoxHack(swapIfPossible) {\n  //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).\n  var svg = _createElement(\"svg\", this.ownerSVGElement && this.ownerSVGElement.getAttribute(\"xmlns\") || \"http://www.w3.org/2000/svg\"),\n      oldParent = this.parentNode,\n      oldSibling = this.nextSibling,\n      oldCSS = this.style.cssText,\n      bbox;\n\n  _docElement.appendChild(svg);\n\n  svg.appendChild(this);\n  this.style.display = \"block\";\n\n  if (swapIfPossible) {\n    try {\n      bbox = this.getBBox();\n      this._gsapBBox = this.getBBox; //store the original\n\n      this.getBBox = _getBBoxHack;\n    } catch (e) {}\n  } else if (this._gsapBBox) {\n    bbox = this._gsapBBox();\n  }\n\n  if (oldParent) {\n    if (oldSibling) {\n      oldParent.insertBefore(this, oldSibling);\n    } else {\n      oldParent.appendChild(this);\n    }\n  }\n\n  _docElement.removeChild(svg);\n\n  this.style.cssText = oldCSS;\n  return bbox;\n},\n    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {\n  var i = attributesArray.length;\n\n  while (i--) {\n    if (target.hasAttribute(attributesArray[i])) {\n      return target.getAttribute(attributesArray[i]);\n    }\n  }\n},\n    _getBBox = function _getBBox(target) {\n  var bounds;\n\n  try {\n    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118\n  } catch (error) {\n    bounds = _getBBoxHack.call(target, true);\n  }\n\n  bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.\n\n  return bounds && !bounds.width && !bounds.x && !bounds.y ? {\n    x: +_getAttributeFallbacks(target, [\"x\", \"cx\", \"x1\"]) || 0,\n    y: +_getAttributeFallbacks(target, [\"y\", \"cy\", \"y1\"]) || 0,\n    width: 0,\n    height: 0\n  } : bounds;\n},\n    _isSVG = function _isSVG(e) {\n  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));\n},\n    //reports if the element is an SVG on which getBBox() actually works\n_removeProperty = function _removeProperty(target, property) {\n  if (property) {\n    var style = target.style;\n\n    if (property in _transformProps && property !== _transformOriginProp) {\n      property = _transformProp;\n    }\n\n    if (style.removeProperty) {\n      if (property.substr(0, 2) === \"ms\" || property.substr(0, 6) === \"webkit\") {\n        //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be \"ms-transform\" instead of \"-ms-transform\" for IE9, for example)\n        property = \"-\" + property;\n      }\n\n      style.removeProperty(property.replace(_capsExp, \"-$1\").toLowerCase());\n    } else {\n      //note: old versions of IE use \"removeAttribute()\" instead of \"removeProperty()\"\n      style.removeAttribute(property);\n    }\n  }\n},\n    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {\n  var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);\n  plugin._pt = pt;\n  pt.b = beginning;\n  pt.e = end;\n\n  plugin._props.push(property);\n\n  return pt;\n},\n    _nonConvertibleUnits = {\n  deg: 1,\n  rad: 1,\n  turn: 1\n},\n    _nonStandardLayouts = {\n  grid: 1,\n  flex: 1\n},\n    //takes a single value like 20px and converts it to the unit specified, like \"%\", returning only the numeric amount.\n_convertToUnit = function _convertToUnit(target, property, value, unit) {\n  var curValue = parseFloat(value) || 0,\n      curUnit = (value + \"\").trim().substr((curValue + \"\").length) || \"px\",\n      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()\n  style = _tempDiv.style,\n      horizontal = _horizontalExp.test(property),\n      isRootSVG = target.tagName.toLowerCase() === \"svg\",\n      measureProperty = (isRootSVG ? \"client\" : \"offset\") + (horizontal ? \"Width\" : \"Height\"),\n      amount = 100,\n      toPixels = unit === \"px\",\n      toPercent = unit === \"%\",\n      px,\n      parent,\n      cache,\n      isSVG;\n\n  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {\n    return curValue;\n  }\n\n  curUnit !== \"px\" && !toPixels && (curValue = _convertToUnit(target, property, value, \"px\"));\n  isSVG = target.getCTM && _isSVG(target);\n\n  if ((toPercent || curUnit === \"%\") && (_transformProps[property] || ~property.indexOf(\"adius\"))) {\n    px = isSVG ? target.getBBox()[horizontal ? \"width\" : \"height\"] : target[measureProperty];\n    return _round(toPercent ? curValue / px * amount : curValue / 100 * px);\n  }\n\n  style[horizontal ? \"width\" : \"height\"] = amount + (toPixels ? curUnit : unit);\n  parent = ~property.indexOf(\"adius\") || unit === \"em\" && target.appendChild && !isRootSVG ? target : target.parentNode;\n\n  if (isSVG) {\n    parent = (target.ownerSVGElement || {}).parentNode;\n  }\n\n  if (!parent || parent === _doc || !parent.appendChild) {\n    parent = _doc.body;\n  }\n\n  cache = parent._gsap;\n\n  if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {\n    return _round(curValue / cache.width * amount);\n  } else {\n    (toPercent || curUnit === \"%\") && !_nonStandardLayouts[_getComputedProperty(parent, \"display\")] && (style.position = _getComputedProperty(target, \"position\"));\n    parent === target && (style.position = \"static\"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.\n\n    parent.appendChild(_tempDiv);\n    px = _tempDiv[measureProperty];\n    parent.removeChild(_tempDiv);\n    style.position = \"absolute\";\n\n    if (horizontal && toPercent) {\n      cache = _getCache(parent);\n      cache.time = _ticker.time;\n      cache.width = parent[measureProperty];\n    }\n  }\n\n  return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);\n},\n    _get = function _get(target, property, unit, uncache) {\n  var value;\n  _pluginInitted || _initCore();\n\n  if (property in _propertyAliases && property !== \"transform\") {\n    property = _propertyAliases[property];\n\n    if (~property.indexOf(\",\")) {\n      property = property.split(\",\")[0];\n    }\n  }\n\n  if (_transformProps[property] && property !== \"transform\") {\n    value = _parseTransform(target, uncache);\n    value = property !== \"transformOrigin\" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + \" \" + value.zOrigin + \"px\";\n  } else {\n    value = target.style[property];\n\n    if (!value || value === \"auto\" || uncache || ~(value + \"\").indexOf(\"calc(\")) {\n      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === \"opacity\" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius\n    }\n  }\n\n  return unit && !~(value + \"\").trim().indexOf(\" \") ? _convertToUnit(target, property, value, unit) + unit : value;\n},\n    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {\n  // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus \"this\" would refer to the plugin.\n  if (!start || start === \"none\") {\n    // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style (\"clipPath\" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as \"none\" whereas WebkitClipPath reports accurately like \"ellipse(100% 0% at 50% 0%)\", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/\n    var p = _checkPropPrefix(prop, target, 1),\n        s = p && _getComputedProperty(target, p, 1);\n\n    if (s && s !== start) {\n      prop = p;\n      start = s;\n    } else if (prop === \"borderColor\") {\n      start = _getComputedProperty(target, \"borderTopColor\"); // Firefox bug: always reports \"borderColor\" as \"\", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/\n    }\n  }\n\n  var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString),\n      index = 0,\n      matchIndex = 0,\n      a,\n      result,\n      startValues,\n      startNum,\n      color,\n      startValue,\n      endValue,\n      endNum,\n      chunk,\n      endUnit,\n      startUnit,\n      endValues;\n  pt.b = start;\n  pt.e = end;\n  start += \"\"; // ensure values are strings\n\n  end += \"\";\n\n  if (end === \"auto\") {\n    target.style[prop] = end;\n    end = _getComputedProperty(target, prop) || end;\n    target.style[prop] = start;\n  }\n\n  a = [start, end];\n\n  _colorStringFilter(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().\n\n\n  start = a[0];\n  end = a[1];\n  startValues = start.match(_numWithUnitExp) || [];\n  endValues = end.match(_numWithUnitExp) || [];\n\n  if (endValues.length) {\n    while (result = _numWithUnitExp.exec(end)) {\n      endValue = result[0];\n      chunk = end.substring(index, result.index);\n\n      if (color) {\n        color = (color + 1) % 5;\n      } else if (chunk.substr(-5) === \"rgba(\" || chunk.substr(-5) === \"hsla(\") {\n        color = 1;\n      }\n\n      if (endValue !== (startValue = startValues[matchIndex++] || \"\")) {\n        startNum = parseFloat(startValue) || 0;\n        startUnit = startValue.substr((startNum + \"\").length);\n        endValue.charAt(1) === \"=\" && (endValue = _parseRelative(startNum, endValue) + startUnit);\n        endNum = parseFloat(endValue);\n        endUnit = endValue.substr((endNum + \"\").length);\n        index = _numWithUnitExp.lastIndex - endUnit.length;\n\n        if (!endUnit) {\n          //if something like \"perspective:300\" is passed in and we must add a unit to the end\n          endUnit = endUnit || _config.units[prop] || startUnit;\n\n          if (index === end.length) {\n            end += endUnit;\n            pt.e += endUnit;\n          }\n        }\n\n        if (startUnit !== endUnit) {\n          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;\n        } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.\n\n\n        pt._pt = {\n          _next: pt._pt,\n          p: chunk || matchIndex === 1 ? chunk : \",\",\n          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.\n          s: startNum,\n          c: endNum - startNum,\n          m: color && color < 4 || prop === \"zIndex\" ? Math.round : 0\n        };\n      }\n    }\n\n    pt.c = index < end.length ? end.substring(index, end.length) : \"\"; //we use the \"c\" of the PropTween to store the final part of the string (after the last number)\n  } else {\n    pt.r = prop === \"display\" && end === \"none\" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;\n  }\n\n  _relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).\n\n  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus \"this\" would refer to the plugin.\n\n  return pt;\n},\n    _keywordToPercent = {\n  top: \"0%\",\n  bottom: \"100%\",\n  left: \"0%\",\n  right: \"100%\",\n  center: \"50%\"\n},\n    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {\n  var split = value.split(\" \"),\n      x = split[0],\n      y = split[1] || \"50%\";\n\n  if (x === \"top\" || x === \"bottom\" || y === \"left\" || y === \"right\") {\n    //the user provided them in the wrong order, so flip them\n    value = x;\n    x = y;\n    y = value;\n  }\n\n  split[0] = _keywordToPercent[x] || x;\n  split[1] = _keywordToPercent[y] || y;\n  return split.join(\" \");\n},\n    _renderClearProps = function _renderClearProps(ratio, data) {\n  if (data.tween && data.tween._time === data.tween._dur) {\n    var target = data.t,\n        style = target.style,\n        props = data.u,\n        cache = target._gsap,\n        prop,\n        clearTransforms,\n        i;\n\n    if (props === \"all\" || props === true) {\n      style.cssText = \"\";\n      clearTransforms = 1;\n    } else {\n      props = props.split(\",\");\n      i = props.length;\n\n      while (--i > -1) {\n        prop = props[i];\n\n        if (_transformProps[prop]) {\n          clearTransforms = 1;\n          prop = prop === \"transformOrigin\" ? _transformOriginProp : _transformProp;\n        }\n\n        _removeProperty(target, prop);\n      }\n    }\n\n    if (clearTransforms) {\n      _removeProperty(target, _transformProp);\n\n      if (cache) {\n        cache.svg && target.removeAttribute(\"transform\");\n\n        _parseTransform(target, 1); // force all the cached values back to \"normal\"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.\n\n\n        cache.uncache = 1;\n\n        _removeIndependentTransforms(style);\n      }\n    }\n  }\n},\n    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.\n_specialProps = {\n  clearProps: function clearProps(plugin, target, property, endValue, tween) {\n    if (tween.data !== \"isFromStart\") {\n      var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);\n      pt.u = endValue;\n      pt.pr = -10;\n      pt.tween = tween;\n\n      plugin._props.push(property);\n\n      return 1;\n    }\n  }\n  /* className feature (about 0.4kb gzipped).\n  , className(plugin, target, property, endValue, tween) {\n  \tlet _renderClassName = (ratio, data) => {\n  \t\t\tdata.css.render(ratio, data.css);\n  \t\t\tif (!ratio || ratio === 1) {\n  \t\t\t\tlet inline = data.rmv,\n  \t\t\t\t\ttarget = data.t,\n  \t\t\t\t\tp;\n  \t\t\t\ttarget.setAttribute(\"class\", ratio ? data.e : data.b);\n  \t\t\t\tfor (p in inline) {\n  \t\t\t\t\t_removeProperty(target, p);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t},\n  \t\t_getAllStyles = (target) => {\n  \t\t\tlet styles = {},\n  \t\t\t\tcomputed = getComputedStyle(target),\n  \t\t\t\tp;\n  \t\t\tfor (p in computed) {\n  \t\t\t\tif (isNaN(p) && p !== \"cssText\" && p !== \"length\") {\n  \t\t\t\t\tstyles[p] = computed[p];\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\t_setDefaults(styles, _parseTransform(target, 1));\n  \t\t\treturn styles;\n  \t\t},\n  \t\tstartClassList = target.getAttribute(\"class\"),\n  \t\tstyle = target.style,\n  \t\tcssText = style.cssText,\n  \t\tcache = target._gsap,\n  \t\tclassPT = cache.classPT,\n  \t\tinlineToRemoveAtEnd = {},\n  \t\tdata = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== \"=\") ? endValue : startClassList.replace(new RegExp(\"(?:\\\\s|^)\" + endValue.substr(2) + \"(?![\\\\w-])\"), \"\") + ((endValue.charAt(0) === \"+\") ? \" \" + endValue.substr(2) : \"\")},\n  \t\tchangingVars = {},\n  \t\tstartVars = _getAllStyles(target),\n  \t\ttransformRelated = /(transform|perspective)/i,\n  \t\tendVars, p;\n  \tif (classPT) {\n  \t\tclassPT.r(1, classPT.d);\n  \t\t_removeLinkedListItem(classPT.d.plugin, classPT, \"_pt\");\n  \t}\n  \ttarget.setAttribute(\"class\", data.e);\n  \tendVars = _getAllStyles(target, true);\n  \ttarget.setAttribute(\"class\", startClassList);\n  \tfor (p in endVars) {\n  \t\tif (endVars[p] !== startVars[p] && !transformRelated.test(p)) {\n  \t\t\tchangingVars[p] = endVars[p];\n  \t\t\tif (!style[p] && style[p] !== \"0\") {\n  \t\t\t\tinlineToRemoveAtEnd[p] = 1;\n  \t\t\t}\n  \t\t}\n  \t}\n  \tcache.classPT = plugin._pt = new PropTween(plugin._pt, target, \"className\", 0, 0, _renderClassName, data, 0, -11);\n  \tif (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.\n  \t\tstyle.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).\n  \t}\n  \t_parseTransform(target, true); //to clear the caching of transforms\n  \tdata.css = new gsap.plugins.css();\n  \tdata.css.init(target, changingVars, tween);\n  \tplugin._props.push(...data.css._props);\n  \treturn 1;\n  }\n  */\n\n},\n\n/*\n * --------------------------------------------------------------------------------------\n * TRANSFORMS\n * --------------------------------------------------------------------------------------\n */\n_identity2DMatrix = [1, 0, 0, 1, 0, 0],\n    _rotationalProperties = {},\n    _isNullTransform = function _isNullTransform(value) {\n  return value === \"matrix(1, 0, 0, 1, 0, 0)\" || value === \"none\" || !value;\n},\n    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {\n  var matrixString = _getComputedProperty(target, _transformProp);\n\n  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);\n},\n    _getMatrix = function _getMatrix(target, force2D) {\n  var cache = target._gsap || _getCache(target),\n      style = target.style,\n      matrix = _getComputedTransformMatrixAsArray(target),\n      parent,\n      nextSibling,\n      temp,\n      addedToDOM;\n\n  if (cache.svg && target.getAttribute(\"transform\")) {\n    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like \"translate(50,60) rotate(135,0,0)\" are parsed because it mashes it into a matrix.\n\n    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];\n    return matrix.join(\",\") === \"1,0,0,1,0,0\" ? _identity2DMatrix : matrix;\n  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {\n    //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n    //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not \"none\". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).\n    temp = style.display;\n    style.display = \"block\";\n    parent = target.parentNode;\n\n    if (!parent || !target.offsetParent) {\n      // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375\n      addedToDOM = 1; //flag\n\n      nextSibling = target.nextElementSibling;\n\n      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly\n\n    }\n\n    matrix = _getComputedTransformMatrixAsArray(target);\n    temp ? style.display = temp : _removeProperty(target, \"display\");\n\n    if (addedToDOM) {\n      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);\n    }\n  }\n\n  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;\n},\n    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {\n  var cache = target._gsap,\n      matrix = matrixArray || _getMatrix(target, true),\n      xOriginOld = cache.xOrigin || 0,\n      yOriginOld = cache.yOrigin || 0,\n      xOffsetOld = cache.xOffset || 0,\n      yOffsetOld = cache.yOffset || 0,\n      a = matrix[0],\n      b = matrix[1],\n      c = matrix[2],\n      d = matrix[3],\n      tx = matrix[4],\n      ty = matrix[5],\n      originSplit = origin.split(\" \"),\n      xOrigin = parseFloat(originSplit[0]) || 0,\n      yOrigin = parseFloat(originSplit[1]) || 0,\n      bounds,\n      determinant,\n      x,\n      y;\n\n  if (!originIsAbsolute) {\n    bounds = _getBBox(target);\n    xOrigin = bounds.x + (~originSplit[0].indexOf(\"%\") ? xOrigin / 100 * bounds.width : xOrigin);\n    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf(\"%\") ? yOrigin / 100 * bounds.height : yOrigin);\n  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {\n    //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.\n    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;\n    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;\n    xOrigin = x;\n    yOrigin = y;\n  }\n\n  if (smooth || smooth !== false && cache.smooth) {\n    tx = xOrigin - xOriginOld;\n    ty = yOrigin - yOriginOld;\n    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;\n    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;\n  } else {\n    cache.xOffset = cache.yOffset = 0;\n  }\n\n  cache.xOrigin = xOrigin;\n  cache.yOrigin = yOrigin;\n  cache.smooth = !!smooth;\n  cache.origin = origin;\n  cache.originIsAbsolute = !!originIsAbsolute;\n  target.style[_transformOriginProp] = \"0px 0px\"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).\n\n  if (pluginToAddPropTweensTo) {\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOrigin\", xOriginOld, xOrigin);\n\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOrigin\", yOriginOld, yOrigin);\n\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOffset\", xOffsetOld, cache.xOffset);\n\n    _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOffset\", yOffsetOld, cache.yOffset);\n  }\n\n  target.setAttribute(\"data-svg-origin\", xOrigin + \" \" + yOrigin);\n},\n    _parseTransform = function _parseTransform(target, uncache) {\n  var cache = target._gsap || new GSCache(target);\n\n  if (\"x\" in cache && !uncache && !cache.uncache) {\n    return cache;\n  }\n\n  var style = target.style,\n      invertedScaleX = cache.scaleX < 0,\n      px = \"px\",\n      deg = \"deg\",\n      cs = getComputedStyle(target),\n      origin = _getComputedProperty(target, _transformOriginProp) || \"0\",\n      x,\n      y,\n      z,\n      scaleX,\n      scaleY,\n      rotation,\n      rotationX,\n      rotationY,\n      skewX,\n      skewY,\n      perspective,\n      xOrigin,\n      yOrigin,\n      matrix,\n      angle,\n      cos,\n      sin,\n      a,\n      b,\n      c,\n      d,\n      a12,\n      a22,\n      t1,\n      t2,\n      t3,\n      a13,\n      a23,\n      a33,\n      a42,\n      a43,\n      a32;\n  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;\n  scaleX = scaleY = 1;\n  cache.svg = !!(target.getCTM && _isSVG(target));\n\n  if (cs.translate) {\n    // accommodate independent transforms by combining them into normal ones.\n    if (cs.translate !== \"none\" || cs.scale !== \"none\" || cs.rotate !== \"none\") {\n      style[_transformProp] = (cs.translate !== \"none\" ? \"translate3d(\" + (cs.translate + \" 0 0\").split(\" \").slice(0, 3).join(\", \") + \") \" : \"\") + (cs.rotate !== \"none\" ? \"rotate(\" + cs.rotate + \") \" : \"\") + (cs.scale !== \"none\" ? \"scale(\" + cs.scale.split(\" \").join(\",\") + \") \" : \"\") + (cs[_transformProp] !== \"none\" ? cs[_transformProp] : \"\");\n    }\n\n    style.scale = style.rotate = style.translate = \"none\";\n  }\n\n  matrix = _getMatrix(target, cache.svg);\n\n  if (cache.svg) {\n    if (cache.uncache) {\n      // if cache.uncache is true (and maybe if origin is 0,0), we need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + \"px \" + (cache.yOrigin - bbox.y) + \"px\". Previously we let the data-svg-origin stay instead, but when introducing revert(), it complicated things.\n      t2 = target.getBBox();\n      origin = cache.xOrigin - t2.x + \"px \" + (cache.yOrigin - t2.y) + \"px\";\n      t1 = \"\";\n    } else {\n      t1 = !uncache && target.getAttribute(\"data-svg-origin\"); //  Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.\n    }\n\n    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);\n  }\n\n  xOrigin = cache.xOrigin || 0;\n  yOrigin = cache.yOrigin || 0;\n\n  if (matrix !== _identity2DMatrix) {\n    a = matrix[0]; //a11\n\n    b = matrix[1]; //a21\n\n    c = matrix[2]; //a31\n\n    d = matrix[3]; //a41\n\n    x = a12 = matrix[4];\n    y = a22 = matrix[5]; //2D matrix\n\n    if (matrix.length === 6) {\n      scaleX = Math.sqrt(a * a + b * b);\n      scaleY = Math.sqrt(d * d + c * c);\n      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).\n\n      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;\n      skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));\n\n      if (cache.svg) {\n        x -= xOrigin - (xOrigin * a + yOrigin * c);\n        y -= yOrigin - (xOrigin * b + yOrigin * d);\n      } //3D matrix\n\n    } else {\n      a32 = matrix[6];\n      a42 = matrix[7];\n      a13 = matrix[8];\n      a23 = matrix[9];\n      a33 = matrix[10];\n      a43 = matrix[11];\n      x = matrix[12];\n      y = matrix[13];\n      z = matrix[14];\n      angle = _atan2(a32, a33);\n      rotationX = angle * _RAD2DEG; //rotationX\n\n      if (angle) {\n        cos = Math.cos(-angle);\n        sin = Math.sin(-angle);\n        t1 = a12 * cos + a13 * sin;\n        t2 = a22 * cos + a23 * sin;\n        t3 = a32 * cos + a33 * sin;\n        a13 = a12 * -sin + a13 * cos;\n        a23 = a22 * -sin + a23 * cos;\n        a33 = a32 * -sin + a33 * cos;\n        a43 = a42 * -sin + a43 * cos;\n        a12 = t1;\n        a22 = t2;\n        a32 = t3;\n      } //rotationY\n\n\n      angle = _atan2(-c, a33);\n      rotationY = angle * _RAD2DEG;\n\n      if (angle) {\n        cos = Math.cos(-angle);\n        sin = Math.sin(-angle);\n        t1 = a * cos - a13 * sin;\n        t2 = b * cos - a23 * sin;\n        t3 = c * cos - a33 * sin;\n        a43 = d * sin + a43 * cos;\n        a = t1;\n        b = t2;\n        c = t3;\n      } //rotationZ\n\n\n      angle = _atan2(b, a);\n      rotation = angle * _RAD2DEG;\n\n      if (angle) {\n        cos = Math.cos(angle);\n        sin = Math.sin(angle);\n        t1 = a * cos + b * sin;\n        t2 = a12 * cos + a22 * sin;\n        b = b * cos - a * sin;\n        a22 = a22 * cos - a12 * sin;\n        a = t1;\n        a12 = t2;\n      }\n\n      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {\n        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.\n        rotationX = rotation = 0;\n        rotationY = 180 - rotationY;\n      }\n\n      scaleX = _round(Math.sqrt(a * a + b * b + c * c));\n      scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));\n      angle = _atan2(a12, a22);\n      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;\n      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;\n    }\n\n    if (cache.svg) {\n      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).\n      t1 = target.getAttribute(\"transform\");\n      cache.forceCSS = target.setAttribute(\"transform\", \"\") || !_isNullTransform(_getComputedProperty(target, _transformProp));\n      t1 && target.setAttribute(\"transform\", t1);\n    }\n  }\n\n  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {\n    if (invertedScaleX) {\n      scaleX *= -1;\n      skewX += rotation <= 0 ? 180 : -180;\n      rotation += rotation <= 0 ? 180 : -180;\n    } else {\n      scaleY *= -1;\n      skewX += skewX <= 0 ? 180 : -180;\n    }\n  }\n\n  uncache = uncache || cache.uncache;\n  cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;\n  cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;\n  cache.z = z + px;\n  cache.scaleX = _round(scaleX);\n  cache.scaleY = _round(scaleY);\n  cache.rotation = _round(rotation) + deg;\n  cache.rotationX = _round(rotationX) + deg;\n  cache.rotationY = _round(rotationY) + deg;\n  cache.skewX = skewX + deg;\n  cache.skewY = skewY + deg;\n  cache.transformPerspective = perspective + px;\n\n  if (cache.zOrigin = parseFloat(origin.split(\" \")[2]) || 0) {\n    style[_transformOriginProp] = _firstTwoOnly(origin);\n  }\n\n  cache.xOffset = cache.yOffset = 0;\n  cache.force3D = _config.force3D;\n  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;\n  cache.uncache = 0;\n  return cache;\n},\n    _firstTwoOnly = function _firstTwoOnly(value) {\n  return (value = value.split(\" \"))[0] + \" \" + value[1];\n},\n    //for handling transformOrigin values, stripping out the 3rd dimension\n_addPxTranslate = function _addPxTranslate(target, start, value) {\n  var unit = getUnit(start);\n  return _round(parseFloat(start) + parseFloat(_convertToUnit(target, \"x\", value + \"px\", unit))) + unit;\n},\n    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {\n  cache.z = \"0px\";\n  cache.rotationY = cache.rotationX = \"0deg\";\n  cache.force3D = 0;\n\n  _renderCSSTransforms(ratio, cache);\n},\n    _zeroDeg = \"0deg\",\n    _zeroPx = \"0px\",\n    _endParenthesis = \") \",\n    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {\n  var _ref = cache || this,\n      xPercent = _ref.xPercent,\n      yPercent = _ref.yPercent,\n      x = _ref.x,\n      y = _ref.y,\n      z = _ref.z,\n      rotation = _ref.rotation,\n      rotationY = _ref.rotationY,\n      rotationX = _ref.rotationX,\n      skewX = _ref.skewX,\n      skewY = _ref.skewY,\n      scaleX = _ref.scaleX,\n      scaleY = _ref.scaleY,\n      transformPerspective = _ref.transformPerspective,\n      force3D = _ref.force3D,\n      target = _ref.target,\n      zOrigin = _ref.zOrigin,\n      transforms = \"\",\n      use3D = force3D === \"auto\" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)\n\n\n  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {\n    var angle = parseFloat(rotationY) * _DEG2RAD,\n        a13 = Math.sin(angle),\n        a33 = Math.cos(angle),\n        cos;\n\n    angle = parseFloat(rotationX) * _DEG2RAD;\n    cos = Math.cos(angle);\n    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);\n    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);\n    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);\n  }\n\n  if (transformPerspective !== _zeroPx) {\n    transforms += \"perspective(\" + transformPerspective + _endParenthesis;\n  }\n\n  if (xPercent || yPercent) {\n    transforms += \"translate(\" + xPercent + \"%, \" + yPercent + \"%) \";\n  }\n\n  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {\n    transforms += z !== _zeroPx || use3D ? \"translate3d(\" + x + \", \" + y + \", \" + z + \") \" : \"translate(\" + x + \", \" + y + _endParenthesis;\n  }\n\n  if (rotation !== _zeroDeg) {\n    transforms += \"rotate(\" + rotation + _endParenthesis;\n  }\n\n  if (rotationY !== _zeroDeg) {\n    transforms += \"rotateY(\" + rotationY + _endParenthesis;\n  }\n\n  if (rotationX !== _zeroDeg) {\n    transforms += \"rotateX(\" + rotationX + _endParenthesis;\n  }\n\n  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {\n    transforms += \"skew(\" + skewX + \", \" + skewY + _endParenthesis;\n  }\n\n  if (scaleX !== 1 || scaleY !== 1) {\n    transforms += \"scale(\" + scaleX + \", \" + scaleY + _endParenthesis;\n  }\n\n  target.style[_transformProp] = transforms || \"translate(0, 0)\";\n},\n    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {\n  var _ref2 = cache || this,\n      xPercent = _ref2.xPercent,\n      yPercent = _ref2.yPercent,\n      x = _ref2.x,\n      y = _ref2.y,\n      rotation = _ref2.rotation,\n      skewX = _ref2.skewX,\n      skewY = _ref2.skewY,\n      scaleX = _ref2.scaleX,\n      scaleY = _ref2.scaleY,\n      target = _ref2.target,\n      xOrigin = _ref2.xOrigin,\n      yOrigin = _ref2.yOrigin,\n      xOffset = _ref2.xOffset,\n      yOffset = _ref2.yOffset,\n      forceCSS = _ref2.forceCSS,\n      tx = parseFloat(x),\n      ty = parseFloat(y),\n      a11,\n      a21,\n      a12,\n      a22,\n      temp;\n\n  rotation = parseFloat(rotation);\n  skewX = parseFloat(skewX);\n  skewY = parseFloat(skewY);\n\n  if (skewY) {\n    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.\n    skewY = parseFloat(skewY);\n    skewX += skewY;\n    rotation += skewY;\n  }\n\n  if (rotation || skewX) {\n    rotation *= _DEG2RAD;\n    skewX *= _DEG2RAD;\n    a11 = Math.cos(rotation) * scaleX;\n    a21 = Math.sin(rotation) * scaleX;\n    a12 = Math.sin(rotation - skewX) * -scaleY;\n    a22 = Math.cos(rotation - skewX) * scaleY;\n\n    if (skewX) {\n      skewY *= _DEG2RAD;\n      temp = Math.tan(skewX - skewY);\n      temp = Math.sqrt(1 + temp * temp);\n      a12 *= temp;\n      a22 *= temp;\n\n      if (skewY) {\n        temp = Math.tan(skewY);\n        temp = Math.sqrt(1 + temp * temp);\n        a11 *= temp;\n        a21 *= temp;\n      }\n    }\n\n    a11 = _round(a11);\n    a21 = _round(a21);\n    a12 = _round(a12);\n    a22 = _round(a22);\n  } else {\n    a11 = scaleX;\n    a22 = scaleY;\n    a21 = a12 = 0;\n  }\n\n  if (tx && !~(x + \"\").indexOf(\"px\") || ty && !~(y + \"\").indexOf(\"px\")) {\n    tx = _convertToUnit(target, \"x\", x, \"px\");\n    ty = _convertToUnit(target, \"y\", y, \"px\");\n  }\n\n  if (xOrigin || yOrigin || xOffset || yOffset) {\n    tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);\n    ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);\n  }\n\n  if (xPercent || yPercent) {\n    //The SVG spec doesn't support percentage-based translation in the \"transform\" attribute, so we merge it into the translation to simulate it.\n    temp = target.getBBox();\n    tx = _round(tx + xPercent / 100 * temp.width);\n    ty = _round(ty + yPercent / 100 * temp.height);\n  }\n\n  temp = \"matrix(\" + a11 + \",\" + a21 + \",\" + a12 + \",\" + a22 + \",\" + tx + \",\" + ty + \")\";\n  target.setAttribute(\"transform\", temp);\n  forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the transform attribute changes!)\n},\n    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {\n  var cap = 360,\n      isString = _isString(endValue),\n      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf(\"rad\") ? _RAD2DEG : 1),\n      change = endNum - startNum,\n      finalValue = startNum + change + \"deg\",\n      direction,\n      pt;\n\n  if (isString) {\n    direction = endValue.split(\"_\")[1];\n\n    if (direction === \"short\") {\n      change %= cap;\n\n      if (change !== change % (cap / 2)) {\n        change += change < 0 ? cap : -cap;\n      }\n    }\n\n    if (direction === \"cw\" && change < 0) {\n      change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;\n    } else if (direction === \"ccw\" && change > 0) {\n      change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;\n    }\n  }\n\n  plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);\n  pt.e = finalValue;\n  pt.u = \"deg\";\n\n  plugin._props.push(property);\n\n  return pt;\n},\n    _assign = function _assign(target, source) {\n  // Internet Explorer doesn't have Object.assign(), so we recreate it here.\n  for (var p in source) {\n    target[p] = source[p];\n  }\n\n  return target;\n},\n    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {\n  //for handling cases where someone passes in a whole transform string, like transform: \"scale(2, 3) rotate(20deg) translateY(30em)\"\n  var startCache = _assign({}, target._gsap),\n      exclude = \"perspective,force3D,transformOrigin,svgOrigin\",\n      style = target.style,\n      endCache,\n      p,\n      startValue,\n      endValue,\n      startNum,\n      endNum,\n      startUnit,\n      endUnit;\n\n  if (startCache.svg) {\n    startValue = target.getAttribute(\"transform\");\n    target.setAttribute(\"transform\", \"\");\n    style[_transformProp] = transforms;\n    endCache = _parseTransform(target, 1);\n\n    _removeProperty(target, _transformProp);\n\n    target.setAttribute(\"transform\", startValue);\n  } else {\n    startValue = getComputedStyle(target)[_transformProp];\n    style[_transformProp] = transforms;\n    endCache = _parseTransform(target, 1);\n    style[_transformProp] = startValue;\n  }\n\n  for (p in _transformProps) {\n    startValue = startCache[p];\n    endValue = endCache[p];\n\n    if (startValue !== endValue && exclude.indexOf(p) < 0) {\n      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.\n      startUnit = getUnit(startValue);\n      endUnit = getUnit(endValue);\n      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);\n      endNum = parseFloat(endValue);\n      plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);\n      plugin._pt.u = endUnit || 0;\n\n      plugin._props.push(p);\n    }\n  }\n\n  _assign(endCache, startCache);\n}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.\n\n\n_forEachName(\"padding,margin,Width,Radius\", function (name, index) {\n  var t = \"Top\",\n      r = \"Right\",\n      b = \"Bottom\",\n      l = \"Left\",\n      props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {\n    return index < 2 ? name + side : \"border\" + side + name;\n  });\n\n  _specialProps[index > 1 ? \"border\" + name : name] = function (plugin, target, property, endValue, tween) {\n    var a, vars;\n\n    if (arguments.length < 4) {\n      // getter, passed target, property, and unit (from _get())\n      a = props.map(function (prop) {\n        return _get(plugin, prop, property);\n      });\n      vars = a.join(\" \");\n      return vars.split(a[0]).length === 5 ? a[0] : vars;\n    }\n\n    a = (endValue + \"\").split(\" \");\n    vars = {};\n    props.forEach(function (prop, i) {\n      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];\n    });\n    plugin.init(target, vars, tween);\n  };\n});\n\nexport var CSSPlugin = {\n  name: \"css\",\n  register: _initCore,\n  targetTest: function targetTest(target) {\n    return target.style && target.nodeType;\n  },\n  init: function init(target, vars, tween, index, targets) {\n    var props = this._props,\n        style = target.style,\n        startAt = tween.vars.startAt,\n        startValue,\n        endValue,\n        endNum,\n        startNum,\n        type,\n        specialProp,\n        p,\n        startUnit,\n        endUnit,\n        relative,\n        isTransformRelated,\n        transformPropTween,\n        cache,\n        smooth,\n        hasPriority,\n        inlineProps;\n    _pluginInitted || _initCore(); // we may call init() multiple times on the same plugin instance, like when adding special properties, so make sure we don't overwrite the revert data or inlineProps\n\n    this.styles = this.styles || _getStyleSaver(target);\n    inlineProps = this.styles.props;\n    this.tween = tween;\n\n    for (p in vars) {\n      if (p === \"autoRound\") {\n        continue;\n      }\n\n      endValue = vars[p];\n\n      if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {\n        // plugins\n        continue;\n      }\n\n      type = typeof endValue;\n      specialProp = _specialProps[p];\n\n      if (type === \"function\") {\n        endValue = endValue.call(tween, index, target, targets);\n        type = typeof endValue;\n      }\n\n      if (type === \"string\" && ~endValue.indexOf(\"random(\")) {\n        endValue = _replaceRandom(endValue);\n      }\n\n      if (specialProp) {\n        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);\n      } else if (p.substr(0, 2) === \"--\") {\n        //CSS variable\n        startValue = (getComputedStyle(target).getPropertyValue(p) + \"\").trim();\n        endValue += \"\";\n        _colorExp.lastIndex = 0;\n\n        if (!_colorExp.test(startValue)) {\n          // colors don't have units\n          startUnit = getUnit(startValue);\n          endUnit = getUnit(endValue);\n        }\n\n        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);\n        this.add(style, \"setProperty\", startValue, endValue, index, targets, 0, 0, p);\n        props.push(p);\n        inlineProps.push(p, 0, style[p]);\n      } else if (type !== \"undefined\") {\n        if (startAt && p in startAt) {\n          // in case someone hard-codes a complex value as the start, like top: \"calc(2vh / 2)\". Without this, it'd use the computed value (always in px)\n          startValue = typeof startAt[p] === \"function\" ? startAt[p].call(tween, index, target, targets) : startAt[p];\n          _isString(startValue) && ~startValue.indexOf(\"random(\") && (startValue = _replaceRandom(startValue));\n          getUnit(startValue + \"\") || (startValue += _config.units[p] || getUnit(_get(target, p)) || \"\"); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.\n\n          (startValue + \"\").charAt(1) === \"=\" && (startValue = _get(target, p)); // can't work with relative values\n        } else {\n          startValue = _get(target, p);\n        }\n\n        startNum = parseFloat(startValue);\n        relative = type === \"string\" && endValue.charAt(1) === \"=\" && endValue.substr(0, 2);\n        relative && (endValue = endValue.substr(2));\n        endNum = parseFloat(endValue);\n\n        if (p in _propertyAliases) {\n          if (p === \"autoAlpha\") {\n            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.\n            if (startNum === 1 && _get(target, \"visibility\") === \"hidden\" && endNum) {\n              //if visibility is initially set to \"hidden\", we should interpret that as intent to make opacity 0 (a convenience)\n              startNum = 0;\n            }\n\n            inlineProps.push(\"visibility\", 0, style.visibility);\n\n            _addNonTweeningPT(this, style, \"visibility\", startNum ? \"inherit\" : \"hidden\", endNum ? \"inherit\" : \"hidden\", !endNum);\n          }\n\n          if (p !== \"scale\" && p !== \"transform\") {\n            p = _propertyAliases[p];\n            ~p.indexOf(\",\") && (p = p.split(\",\")[0]);\n          }\n        }\n\n        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---\n\n        if (isTransformRelated) {\n          this.styles.save(p);\n\n          if (!transformPropTween) {\n            cache = target._gsap;\n            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:\"translateX(50vw)\"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.\n\n            smooth = vars.smoothOrigin !== false && cache.smooth;\n            transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)\n\n            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.\n          }\n\n          if (p === \"scale\") {\n            this._pt = new PropTween(this._pt, cache, \"scaleY\", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);\n            this._pt.u = 0;\n            props.push(\"scaleY\", p);\n            p += \"X\";\n          } else if (p === \"transformOrigin\") {\n            inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);\n            endValue = _convertKeywordsToPercentages(endValue); //in case something like \"left top\" or \"bottom right\" is passed in. Convert to percentages.\n\n            if (cache.svg) {\n              _applySVGOrigin(target, endValue, 0, smooth, 0, this);\n            } else {\n              endUnit = parseFloat(endValue.split(\" \")[2]) || 0; //handle the zOrigin separately!\n\n              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, \"zOrigin\", cache.zOrigin, endUnit);\n\n              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));\n            }\n\n            continue;\n          } else if (p === \"svgOrigin\") {\n            _applySVGOrigin(target, endValue, 1, smooth, 0, this);\n\n            continue;\n          } else if (p in _rotationalProperties) {\n            _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);\n\n            continue;\n          } else if (p === \"smoothOrigin\") {\n            _addNonTweeningPT(this, cache, \"smooth\", cache.smooth, endValue);\n\n            continue;\n          } else if (p === \"force3D\") {\n            cache[p] = endValue;\n            continue;\n          } else if (p === \"transform\") {\n            _addRawTransformPTs(this, endValue, target);\n\n            continue;\n          }\n        } else if (!(p in style)) {\n          p = _checkPropPrefix(p) || p;\n        }\n\n        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {\n          startUnit = (startValue + \"\").substr((startNum + \"\").length);\n          endNum || (endNum = 0); // protect against NaN\n\n          endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);\n          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));\n          this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === \"px\" || p === \"zIndex\") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);\n          this._pt.u = endUnit || 0;\n\n          if (startUnit !== endUnit && endUnit !== \"%\") {\n            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a \"b\" (beginning) property and point to a render method that handles that. (performance optimization)\n            this._pt.b = startValue;\n            this._pt.r = _renderCSSPropWithBeginning;\n          }\n        } else if (!(p in style)) {\n          if (p in target) {\n            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.\n            this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);\n          } else if (p !== \"parseTransform\") {\n            _missingPlugin(p, endValue);\n\n            continue;\n          }\n        } else {\n          _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);\n        }\n\n        isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p]));\n        props.push(p);\n      }\n    }\n\n    hasPriority && _sortPropTweensByPriority(this);\n  },\n  render: function render(ratio, data) {\n    if (data.tween._time || !_reverting()) {\n      var pt = data._pt;\n\n      while (pt) {\n        pt.r(ratio, pt.d);\n        pt = pt._next;\n      }\n    } else {\n      data.styles.revert();\n    }\n  },\n  get: _get,\n  aliases: _propertyAliases,\n  getSetter: function getSetter(target, property, plugin) {\n    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like \"x\" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.\n    var p = _propertyAliases[property];\n    p && p.indexOf(\",\") < 0 && (property = p);\n    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, \"x\")) ? plugin && _recentSetterPlugin === plugin ? property === \"scale\" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === \"scale\" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf(\"-\") ? _setterCSSProp : _getSetter(target, property);\n  },\n  core: {\n    _removeProperty: _removeProperty,\n    _getMatrix: _getMatrix\n  }\n};\ngsap.utils.checkPrefix = _checkPropPrefix;\ngsap.core.getStyleSaver = _getStyleSaver;\n\n(function (positionAndScale, rotation, others, aliases) {\n  var all = _forEachName(positionAndScale + \",\" + rotation + \",\" + others, function (name) {\n    _transformProps[name] = 1;\n  });\n\n  _forEachName(rotation, function (name) {\n    _config.units[name] = \"deg\";\n    _rotationalProperties[name] = 1;\n  });\n\n  _propertyAliases[all[13]] = positionAndScale + \",\" + rotation;\n\n  _forEachName(aliases, function (name) {\n    var split = name.split(\":\");\n    _propertyAliases[split[1]] = all[split[0]];\n  });\n})(\"x,y,z,scale,scaleX,scaleY,xPercent,yPercent\", \"rotation,rotationX,rotationY,skewX,skewY\", \"transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective\", \"0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY\");\n\n_forEachName(\"x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective\", function (name) {\n  _config.units[name] = \"px\";\n});\n\ngsap.registerPlugin(CSSPlugin);\nexport { CSSPlugin as default, _getBBox, _createElement, _checkPropPrefix as checkPrefix };","import { gsap, Power0, Power1, Power2, Power3, Power4, Linear, Quad, Cubic, Quart, Quint, Strong, Elastic, Back, SteppedEase, Bounce, Sine, Expo, Circ, TweenLite, TimelineLite, TimelineMax } from \"./gsap-core.js\";\nimport { CSSPlugin } from \"./CSSPlugin.js\";\nvar gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap,\n    // to protect from tree shaking\nTweenMaxWithCSS = gsapWithCSS.core.Tween;\nexport { gsapWithCSS as gsap, gsapWithCSS as default, CSSPlugin, TweenMaxWithCSS as TweenMax, TweenLite, TimelineMax, TimelineLite, Power0, Power1, Power2, Power3, Power4, Linear, Quad, Cubic, Quart, Quint, Strong, Elastic, Back, SteppedEase, Bounce, Sine, Expo, Circ };","import '../style/main.scss'\nimport * as THREE from 'three'\nimport * as utils from '../utils.js';\nimport {cameraHelper} from '../cameraHelper.js';\nimport gsap from 'gsap'\nimport '../menu.js'\n\nconst gScene = new THREE.Scene();\nconst gRenderer = new THREE.WebGLRenderer(/*{antialias: true}*/{\n    canvas: document.querySelector('.webgl')\n});\ngRenderer.setPixelRatio(window.devicePixelRatio);\ngRenderer.setSize(window.innerWidth, window.innerHeight);\ndocument.body.appendChild(gRenderer.domElement);\n\nconst clock = new THREE.Clock()\n\n/**\n * Sizes\n */\n const sizes = {}\n sizes.width = window.innerWidth\n sizes.height = window.innerHeight\n \n window.addEventListener('resize', () =>\n {\n     // Save sizes\n     sizes.width = window.innerWidth\n     sizes.height = window.innerHeight\n \n     // Update camera\n     camera.aspect = sizes.width / sizes.height\n     camera.updateProjectionMatrix()\n \n     // Update renderer\n     gRenderer.setSize(sizes.width, sizes.height)\n })\n\n\n/**\n * Camera\n */\nconst camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height)\ncamera.position.y = 40\ncamera.position.z = 90\ngScene.add(camera)\n\n/**\n * Lights\n */\nvar ambientLight = new THREE.AmbientLight('#686868', 1);\ngScene.add(ambientLight);\nvar pointLight = new THREE.PointLight(0xffffff, 2, 1000);\npointLight.position.set(50, 500, 120);\ngScene.add(pointLight);\nconst bluePointLight = new THREE.PointLight('#0000FF', 4, 400)\nbluePointLight.position.set(-100, -50, -50)\ngScene.add(bluePointLight)\nconst redPointLight = new THREE.PointLight('#FF0000', 2, 400)\nredPointLight.position.set(100, 0, -50)\ngScene.add(redPointLight)\n\n\nconst raycaster = new THREE.Raycaster()\nconst mouse = new THREE.Vector2();\n\nvar backCard\n\nvar heightCard = 50;\nvar heightArtist = -25;\n\nvar fond, planeFond;\n\nvar backCardPNG, modelGLTF;\n\nvar objetJSON;\nvar backgroundTextures = []\nvar categorieTextures = [];\nvar cardTextures = [];\nvar cardArtists = [];\nvar cardCategories = [];\nvar i = -1;\nvar total = -1;\n\nvar categoriesToTest = [];\nvar ecartCard = 30;\n\n(async function init() {\n\n    const [varJSON] = await Promise.all([\n        utils.loadResource('infos/artists.txt')\n    ]);\n\n    objetJSON = JSON.parse(varJSON);\n\n    const cardGeometry = new THREE.PlaneGeometry(29.5, 45.5)\n\n    /**\n     * Affichage des lments en fonction du contenu JSON\n     */\n    for(var each in objetJSON.categories){\n        i++\n\n        // Chargement des fonds de catgorie\n        backgroundTextures[i] = await Promise.all([\n            utils.loadResource(objetJSON.categories[each].background)\n        ]);\n\n        categorieTextures[i] = await Promise.all([\n            utils.loadResource(objetJSON.categories[each].texture)\n        ]);\n        cardCategories[i] = new THREE.Mesh(\n            cardGeometry,\n            new THREE.MeshBasicMaterial({transparent: true, map: categorieTextures[i][0]}),\n        )\n        cardCategories[i].name = objetJSON.categories[each].name_cat\n        \n        // if(objetJSON.categories.length%2 == 0){\n            if(cardCategories[i-1]){\n                //Placement en fonction de celle de gauche\n                cardCategories[i].position.set(cardCategories[i-1].position.x + ecartCard, heightCard, 0)\n            } else {\n                cardCategories[i].position.set(-((objetJSON.categories.length/2)*ecartCard)+15, heightCard, 0)\n            }\n        // }\n\n        categoriesToTest[i] = cardCategories[i]\n        gScene.add(cardCategories[i])\n\n\n        for(var artist in objetJSON.categories[each].artists){\n            total++\n            \n            cardTextures[total] = await Promise.all([\n                utils.loadResource(objetJSON.categories[each].artists[artist].texture)\n            ])\n            cardArtists[total] = new THREE.Mesh(\n                cardGeometry,\n                new THREE.MeshBasicMaterial({transparent: true, map: cardTextures[total][0]}),\n            )\n        }\n    };\n\n\n    [backCardPNG, modelGLTF] = await Promise.all([\n        utils.loadResource('image/artists/backCard.png'),\n        utils.loadResource('model/Scne.gltf')\n    ]);\n\n    /**\n     * Dco\n     */\n    // Modele 3D\n    fond = modelGLTF.scene\n    fond.scale.set(20, 20, 20)\n    fond.position.z = -250\n    fond.position.y = -180\n    gScene.add(fond)\n\n    // Plane pour dcorer\n    planeFond = new THREE.Mesh(\n        new THREE.PlaneGeometry(1280, 720),\n        new THREE.MeshBasicMaterial({opacity: 0, transparent: true})\n    )\n    planeFond.name = \"ecran\"\n    planeFond.position.set(0, 50, -700)\n    \n    // Dos de carte\n    backCard = new THREE.Mesh(\n        cardGeometry,\n        new THREE.MeshBasicMaterial({map: backCardPNG, transparent: true})\n    )\n    backCard.position.set(0, 50, -1)\n    backCard.rotation.y = -3\n\n    render();\n})();\n\nlet currentIntersect = null\nlet currentArtist = null\n\n/**\n * Curseur de souris\n */\nlet mouseCursor = document.querySelector(\"#cursor\")\nwindow.addEventListener( 'mousemove', onMouseMove, false );\nfunction onMouseMove(event){\n    mouseCursor.style.top = event.clientY + \"px\"\n    mouseCursor.style.left = event.clientX + \"px\"\n    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;\n    mouse.y = - (event.clientY / window.innerHeight) *2 +1;\n}\n\nvar intersects\nvar artistesClicked = false;\nvar currentArtistsClicked = [];\nvar retour = false;\nvar speedAnim = 0.5 ;\nvar ecartArtist = 20;\n\nwindow.addEventListener('click', () => {\n    document.getElementById(\"hub_arrow\").onclick = function(){\n        // window.location.pathname = \"./immersions/index.html\";\n        window.location.pathname = \"./index.html\";\n    }\n    if(document.getElementById(\"cursor\").classList.contains('cross')){\n        document.getElementById(\"cursor\").classList.remove(\"cross\")\n    }else\n    if(currentIntersect){\n        document.getElementById(\"arrow\").onclick = function(){\n            retour = true;\n            for(var card in currentArtistsClicked){\n                console.log(\"here\")\n                gsap.to(currentArtistsClicked[card].position, {duration: speedAnim, x:0, y:heightArtist, z: 0})\n                gsap.to(currentArtistsClicked[card].rotation, {duration: speedAnim, z:0})\n            }\n            document.getElementById(\"arrow\").classList.add(\"hidden\")\n\n            setTimeout(function(){\n                gScene.add(backCard);\n                gsap.to(backCard.rotation, {duration: speedAnim, y: 0})\n                gsap.to(backCard.position, {duration: speedAnim, z: 1})\n                for(var card in currentArtistsClicked){\n                    gsap.to(currentArtistsClicked[card].rotation, {duration: speedAnim, y: -3})\n                }\n                document.getElementById(\"hub_arrow\").classList.remove(\"hidden\")\n            }, speedAnim * 1000)\n\n            setTimeout(function(){\n                for(var card in currentArtistsClicked){\n                    gScene.remove(currentArtistsClicked[card])\n                }\n                gScene.remove(planeFond)\n                gsap.to(backCard.position, {duration: speedAnim, y:heightCard})\n            }, speedAnim * 1000 *2)\n            setTimeout(function(){\n                currentArtistsClicked = []\n                cardCategories.forEach(category =>{\n                    gScene.add(category)\n                    gsap.to(category.rotation, {duration: speedAnim, y:0, z:0})\n                })\n                gsap.to(backCard.rotation, {duration: speedAnim, y:-3})\n                gsap.to(backCard.position, {duration: speedAnim, z: -1})\n            }, speedAnim * 1000 * 3)\n\n            setTimeout(function(){\n                gScene.remove(backCard)\n                // if(cardCategories[i-1]){\n                    for(var op = 0; op<cardCategories.length; op++){\n                        if(cardCategories[0] && cardCategories[op] != cardCategories[0]){\n                    //Placement en fonction de celle de gauche\n                            gsap.to(cardCategories[op].position, {duration: speedAnim, x : cardCategories[0].position.x + ecartCard*(op+0.5-cardCategories.length/2), y: heightCard, z: 0})\n                        } else {\n                            gsap.to(cardCategories[op].position, {duration: speedAnim, x: -((cardCategories.length/2)*ecartCard)+15, y: heightCard,z: 0})\n                        }\n                    }\n                artistesClicked = false\n                \n            }, speedAnim * 1000 * 4)\n            \n            setTimeout(function(){\n                cardCategories.forEach(category =>{\n                gsap.to(category.position, {duration: speedAnim, z:0})\n            })\n                artistesClicked = false\n                retour = false\n            }, speedAnim * 1000 * 5)\n            \n        }\n\n        /**\n         * Logique d'animation des cartes\n         */\n        for(var variable in objetJSON.categories){\n            var path = currentIntersect.object.material.map.image.src;\n            var page = path.split(\"artists/\").pop().split(\"/card\")[0];\n            var backgroundCompared = backgroundTextures[variable][0]\n            var compare = backgroundCompared.image.currentSrc.split(\"artists/\").pop().split(\"/fond\")[0];\n            if(page == compare){\n                planeFond.material.map = backgroundCompared\n            }\n\n            var localIntersect = currentIntersect.object.name\n\n            if(currentIntersect.object.name == objetJSON.categories[variable].name_cat){\n                document.getElementById(\"hub_arrow\").classList.add(\"hidden\")\n                document.getElementById(\"arrow\").classList.remove(\"hidden\")\n                gScene.add(backCard);\n\n                cardCategories.forEach(category =>{\n                    gsap.to(category.position, {duration: speedAnim, x: 0, y:50})\n                })\n                gsap.to(currentIntersect.object.position, {duration: speedAnim, x: 0, y:50, z:0.1})\n\n                setTimeout(function(){\n                    gsap.to(backCard.rotation, {duration: speedAnim, y: 0})\n                    gsap.to(backCard.position, {duration: speedAnim, z: 1})\n                    cardCategories.forEach(category =>{\n                        gsap.to(category.rotation, {duration: speedAnim, y:3})\n                    })\n                }, speedAnim * 1000)\n\n                setTimeout(function(){\n                    cardCategories.forEach(category =>{\n                        gScene.remove(category)\n                    })\n                    gsap.to(backCard.position, {duration: speedAnim, y: heightArtist})\n                    gScene.add(planeFond)\n                }, speedAnim * 1000 * 2)\n\n                setTimeout(function(){\n                    cardArtists.forEach(card => {\n                        var lien = card.material.map.image.currentSrc.split(\"artists/\").pop().split(\"/nomine\")[0];\n                        if(lien == localIntersect){\n                            card.position.y = heightArtist\n                            card.rotation.y = -3\n                            currentArtistsClicked.push(card)\n                        }\n                    })\n                    currentArtistsClicked.forEach(add => {\n                        gScene.add(add)\n                        gsap.to(add.rotation, {duration: speedAnim, y:0})\n                    })                    \n                    gsap.to(backCard.rotation, {duration:speedAnim, y:3})\n                }, speedAnim * 1000 * 3)\n\n                setTimeout(function(){\n                    gScene.remove(backCard)\n                    if(currentArtistsClicked.length%2 == 1){\n                            for(var card in currentArtistsClicked){\n                                if(currentArtistsClicked[card-1]){\n                                    gsap.to(currentArtistsClicked[card].rotation, {duration: speedAnim, z : currentArtistsClicked[card].rotation.z - 0.01*Math.PI})   \n                                } else {\n                                    gsap.to(currentArtistsClicked[card].position, {duration: speedAnim, x: -((currentArtistsClicked.length/2)*ecartArtist)+15, y: heightArtist, z: 0})\n                                    gsap.to(currentArtistsClicked[card].rotation, {duration: speedAnim, z : (currentArtistsClicked.length/2)*0.02*Math.PI})\n                                }\n                                if(currentArtistsClicked[card-1] && currentArtistsClicked[card].position.x == currentArtistsClicked[card-1].position.x){\n                                    setTimeout(function(){\n                                        currentArtistsClicked[card-1].position.x += 10\n                                    }, speedAnim * 200)\n                                    \n                                }\n                            }\n                    } else {\n                        for(var op = 0; op<currentArtistsClicked.length; op++){\n                            if(currentArtistsClicked[0] && currentArtistsClicked[op] != currentArtistsClicked[0]){\n                                gsap.to(currentArtistsClicked[op].rotation, {duration: speedAnim, z: currentArtistsClicked[0].rotation.z - op*0.01*Math.PI})\n                                gsap.to(currentArtistsClicked[op].position, {duration:speedAnim, x: currentArtistsClicked[0].position.x+ecartArtist*(op-1)})\n                            } else {\n                                gsap.to(currentArtistsClicked[op].rotation, {duration: speedAnim, z : (currentArtistsClicked.length/2)*0.02*Math.PI})\n                                gsap.to(currentArtistsClicked[op].position, {duration: speedAnim, x: -((currentArtistsClicked.length/2)*ecartArtist)+(currentArtistsClicked.length*5), y: heightArtist, z: 0})\n                            }\n                        }\n                    }\n                }, speedAnim * 1000 * 4)\n\n            }\n            else if(retour == false){\n                for(var artist in currentArtistsClicked){\n                    if(currentIntersect.object == currentArtistsClicked[artist]){\n                        gsap.to(currentIntersect.object.position, {duration: 1, x: 0, y: 45, z:50})\n                        gsap.to(currentIntersect.object.rotation, {duration: 1, z: 0})\n                    }\n                }\n                artistesClicked = true\n                if(currentArtist && currentArtist != currentIntersect){\n                    for(var op = 0; op<currentArtistsClicked.length; op++){\n                        if(currentArtistsClicked[0] && currentArtistsClicked[op] != currentArtistsClicked[0]){\n                            gsap.to(currentArtistsClicked[op].rotation, {duration: speedAnim, z: currentArtistsClicked[0].rotation.z - op*0.01*Math.PI})\n                            gsap.to(currentArtistsClicked[op].position, {duration:speedAnim, x: currentArtistsClicked[0].position.x+ecartArtist*(op-1), y: heightArtist, z: 0})\n                        } else {\n                            gsap.to(currentArtistsClicked[op].rotation, {duration: speedAnim, z : (currentArtistsClicked.length/2)*0.02*Math.PI})\n                            gsap.to(currentArtistsClicked[op].position, {duration: speedAnim, x: -((currentArtistsClicked.length/2)*ecartArtist)+(currentArtistsClicked.length*5), y: heightArtist, z: 0})\n                        }\n                    }\n                }\n            }\n            currentArtist = currentIntersect\n        }\n    }\n})\n\n\n\nfunction render() {\n    if(document.getElementById(\"load\").classList.contains(\"hidden\")){\n\n    const elapsedTime = clock.getElapsedTime()\n\n    // Opacit du fond\n    if(retour == true && planeFond.material.opacity>0){\n        planeFond.material.opacity -=0.02\n    } else if(gScene.getObjectByName(\"ecran\") && planeFond.material.opacity<1){\n        planeFond.material.opacity += 0.02\n    }\n\n    gsap.to(fond.rotation, {repeat: -1, y: elapsedTime})\n\n    /**\n     * Raycast\n     */\n    raycaster.setFromCamera(mouse, camera)\n\n    if(currentArtistsClicked.length != 0){\n        intersects = raycaster.intersectObjects(currentArtistsClicked)\n    }else {\n        intersects = raycaster.intersectObjects(categoriesToTest);\n    }\n\n    if(intersects.length){\n\n        if(!currentIntersect && !artistesClicked){\n            intersects[0].object.translateZ(5)\n        }\n\n        if(currentIntersect && currentIntersect.object.name !== intersects[0].object.name && !artistesClicked){\n            intersects[0].object.translateZ(5)\n            currentIntersect.object.translateZ(-5)\n        }\n        \n        currentIntersect = intersects[0]\n    } else {\n        if(currentIntersect && !artistesClicked){\n\n            currentIntersect.object.translateZ(-5)\n        }\n        \n        currentIntersect = null\n    }   \n}\n    cameraHelper.update();\n    gRenderer.render(gScene, camera);\n\n    requestAnimationFrame(render);\n}"],"names":["document","body","addEventListener","e","preventDefault","stopPropagation","clientX","x","clientY","y","showing","anchorX","anchorY","wheel","style","setProperty","classList","add","setAttribute","remove","undefined","value","window","location","href","links","onMouseMove","touches","min","querySelector","dx","dy","index","Math","sqrt","deg","atan2","PI","floor","console","log","documentElement","getElementById","onclick","contains","___CSS_LOADER_EXPORT___","___CSS_LOADER_URL_REPLACEMENT_0___","___CSS_LOADER_URL_REPLACEMENT_1___","___CSS_LOADER_URL_REPLACEMENT_2___","___CSS_LOADER_URL_REPLACEMENT_3___","___CSS_LOADER_URL_REPLACEMENT_4___","___CSS_LOADER_URL_REPLACEMENT_5___","___CSS_LOADER_URL_REPLACEMENT_6___","___CSS_LOADER_URL_REPLACEMENT_7___","___CSS_LOADER_URL_REPLACEMENT_8___","___CSS_LOADER_URL_REPLACEMENT_9___","___CSS_LOADER_URL_REPLACEMENT_10___","___CSS_LOADER_URL_REPLACEMENT_11___","push","module","id","exports","cssWithMappingToString","list","toString","this","map","item","content","concat","join","i","modules","mediaQuery","dedupe","alreadyImportedModules","length","_i","_arrayLikeToArray","arr","len","arr2","Array","_item","isArray","_arrayWithHoles","Symbol","iterator","_s","_e","_arr","_n","_d","call","next","done","err","_iterableToArrayLimit","o","minLen","n","Object","prototype","slice","constructor","name","from","test","_unsupportedIterableToArray","TypeError","_nonIterableRest","cssMapping","btoa","base64","unescape","encodeURIComponent","JSON","stringify","data","sourceMapping","sourceURLs","sources","source","sourceRoot","url","options","__esModule","default","hash","needQuotes","replace","memo","getTarget","target","styleTarget","HTMLIFrameElement","contentDocument","head","stylesInDom","getIndexByIdentifier","identifier","result","modulesToDom","idCountMap","identifiers","base","count","obj","css","media","sourceMap","references","updater","addStyle","insertStyleElement","createElement","attributes","nonce","keys","forEach","key","insert","Error","appendChild","textStore","replaceText","replacement","filter","Boolean","applyToSingletonTag","styleSheet","cssText","cssNode","createTextNode","childNodes","removeChild","insertBefore","applyToTag","removeAttribute","firstChild","singleton","singletonCounter","update","styleIndex","bind","parentNode","removeStyleElement","newObj","all","atob","lastIdentifiers","newList","newLastIdentifiers","_index","splice","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","d","a","definition","defineProperty","enumerable","get","prop","hasOwnProperty","r","toStringTag","nc","locals","REVISION","PCFShadowMap","PCFSoftShadowMap","VSMShadowMap","FrontSide","DoubleSide","AddEquation","MultiplyOperation","MixOperation","AddOperation","NoToneMapping","LinearToneMapping","ReinhardToneMapping","CineonToneMapping","ACESFilmicToneMapping","CustomToneMapping","CubeReflectionMapping","CubeRefractionMapping","CubeUVReflectionMapping","RepeatWrapping","ClampToEdgeWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipmapNearestFilter","NearestMipmapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipmapLinearFilter","UnsignedByteType","UnsignedShortType","UnsignedIntType","FloatType","HalfFloatType","UnsignedInt248Type","RGBAFormat","DepthFormat","DepthStencilFormat","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGBA_BPTC_Format","InterpolateDiscrete","InterpolateLinear","InterpolateSmooth","TrianglesDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","sRGBEncoding","SRGBColorSpace","LinearSRGBColorSpace","DisplayP3ColorSpace","KeepStencilOp","StaticDrawUsage","GLSL3","_SRGBAFormat","WebGLCoordinateSystem","WebGPUCoordinateSystem","EventDispatcher","type","listener","_listeners","listeners","indexOf","hasEventListener","removeEventListener","listenerArray","dispatchEvent","event","array","l","_lut","_seed","DEG2RAD","RAD2DEG","generateUUID","d0","random","d1","d2","d3","toLowerCase","clamp","max","euclideanModulo","m","lerp","t","isPowerOfTwo","ceilPowerOfTwo","pow","ceil","LN2","floorPowerOfTwo","denormalize","Float32Array","Uint32Array","Uint16Array","Uint8Array","Int32Array","Int16Array","Int8Array","normalize","round","MathUtils","mapLinear","a1","a2","b1","b2","inverseLerp","damp","lambda","dt","exp","pingpong","abs","smoothstep","smootherstep","randInt","low","high","randFloat","randFloatSpread","range","seededRandom","s","imul","degToRad","degrees","radToDeg","radians","setQuaternionFromProperEuler","q","b","c","order","cos","sin","c2","s2","c13","s13","c1_3","s1_3","c3_1","s3_1","set","warn","Vector2","isVector2","width","height","setScalar","scalar","setX","setY","setComponent","getComponent","clone","copy","v","addScalar","addVectors","addScaledVector","sub","subScalar","subVectors","multiply","multiplyScalar","divide","divideScalar","applyMatrix3","elements","clampScalar","minVal","maxVal","clampLength","roundToZero","negate","dot","cross","lengthSq","manhattanLength","angle","angleTo","denominator","theta","acos","distanceTo","distanceToSquared","manhattanDistanceTo","setLength","alpha","lerpVectors","v1","v2","equals","fromArray","offset","toArray","fromBufferAttribute","attribute","getX","getY","rotateAround","center","Matrix3","n11","n12","n13","n21","n22","n23","n31","n32","n33","isMatrix3","te","identity","me","extractBasis","xAxis","yAxis","zAxis","setFromMatrix3Column","setFromMatrix4","multiplyMatrices","premultiply","ae","be","a11","a12","a13","a21","a22","a23","a31","a32","a33","b11","b12","b13","b21","b22","b23","b31","b32","b33","determinant","f","g","h","invert","t11","t12","t13","det","detInv","transpose","tmp","getNormalMatrix","matrix4","transposeIntoArray","setUvTransform","tx","ty","sx","sy","rotation","cx","cy","scale","_m3","makeScale","rotate","makeRotation","translate","makeTranslation","matrix","arrayNeedsUint32","createElementNS","Uint8ClampedArray","Float64Array","_cache","warnOnce","message","SRGBToLinear","LinearToSRGB","LINEAR_SRGB_TO_LINEAR_DISPLAY_P3","LINEAR_DISPLAY_P3_TO_LINEAR_SRGB","TO_LINEAR","color","convertSRGBToLinear","FROM_LINEAR","convertLinearToSRGB","ColorManagement","enabled","legacyMode","workingColorSpace","colorSpace","convert","sourceColorSpace","targetColorSpace","sourceToLinear","targetFromLinear","fromWorkingColorSpace","toWorkingColorSpace","_canvas","ImageUtils","static","image","src","HTMLCanvasElement","canvas","context","getContext","ImageData","putImageData","drawImage","toDataURL","HTMLImageElement","ImageBitmap","imageData","getImageData","sourceId","Source","isSource","uuid","version","needsUpdate","toJSON","meta","isRootObject","images","output","isDataTexture","serializeImage","getDataURL","textureId","Texture","DEFAULT_IMAGE","mapping","DEFAULT_MAPPING","wrapS","wrapT","magFilter","minFilter","format","anisotropy","DEFAULT_ANISOTROPY","NoColorSpace","super","isTexture","mipmaps","channel","internalFormat","repeat","matrixAutoUpdate","generateMipmaps","premultiplyAlpha","flipY","unpackAlignment","userData","onUpdate","isRenderTargetTexture","needsPMREMUpdate","updateMatrix","parse","textures","metadata","generator","wrap","dispose","transformUv","uv","encoding","Vector4","z","w","isVector4","setZ","setW","applyMatrix4","setAxisAngleFromQuaternion","setAxisAngleFromRotationMatrix","epsilon","epsilon2","m11","m12","m13","m21","m22","m23","m31","m32","m33","xx","yy","zz","xy","xz","yz","getZ","getW","WebGLRenderTarget","isWebGLRenderTarget","depth","scissor","scissorTest","viewport","texture","depthBuffer","stencilBuffer","depthTexture","samples","setSize","assign","DataArrayTexture","isDataArrayTexture","wrapR","Data3DTexture","isData3DTexture","Quaternion","isQuaternion","_x","_y","_z","_w","dst","dstOffset","src0","srcOffset0","src1","srcOffset1","x0","y0","z0","w0","x1","y1","z1","w1","dir","sqrSin","Number","EPSILON","tDir","_onChangeCallback","quaternion","setFromEuler","euler","_order","c1","c3","s1","s3","setFromAxisAngle","axis","halfAngle","setFromRotationMatrix","trace","setFromUnitVectors","vFrom","vTo","rotateTowards","step","slerp","conjugate","multiplyQuaternions","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","qb","cosHalfTheta","sqrSinHalfTheta","sinHalfTheta","halfTheta","ratioA","ratioB","slerpQuaternions","qa","u1","sqrt1u1","sqrtu1","u2","u3","_onChange","callback","isVector3","multiplyVectors","applyEuler","applyQuaternion","_quaternion$4","applyAxisAngle","applyNormalMatrix","qx","qy","qz","qw","ix","iy","iz","iw","project","camera","matrixWorldInverse","projectionMatrix","unproject","projectionMatrixInverse","matrixWorld","transformDirection","crossVectors","ax","ay","az","bx","by","bz","projectOnVector","projectOnPlane","planeNormal","_vector$b","reflect","normal","dz","setFromSpherical","setFromSphericalCoords","radius","phi","sinPhiRadius","setFromCylindrical","setFromCylindricalCoords","setFromMatrixPosition","setFromMatrixScale","setFromMatrixColumn","sz","setFromColor","randomDirection","u","Box3","isBox3","setFromArray","makeEmpty","il","expandByPoint","_vector$a","setFromBufferAttribute","setFromPoints","points","setFromCenterAndSize","size","halfSize","setFromObject","object","precise","expandByObject","box","isEmpty","getCenter","getSize","point","expandByVector","vector","expandByScalar","updateWorldMatrix","boundingBox","computeBoundingBox","_box$3","union","geometry","position","children","containsPoint","containsBox","getParameter","intersectsBox","intersectsSphere","sphere","clampPoint","intersectsPlane","plane","constant","intersectsTriangle","triangle","_center","_extents","_v0$2","_v1$7","_v2$4","_f0","_f1","_f2","axes","satForAxes","_triangleNormal","distanceToPoint","getBoundingSphere","intersect","_points","_testAxis","v0","extents","j","p0","p1","p2","_box$2","_v1$6","_v2$3","Sphere","optionalCenter","maxRadiusSq","radiusSum","deltaLengthSq","getBoundingBox","getMaxScaleOnAxis","delta","_vector$9","_segCenter","_segDir","_diff","_edge1","_edge2","_normal$1","Ray","origin","direction","ray","at","lookAt","recast","closestPointToPoint","directionDistance","distanceSqToPoint","distanceSqToSegment","optionalPointOnRay","optionalPointOnSegment","segExtent","a01","b0","s0","sqrDist","extDet","invDet","intersectSphere","tca","radius2","thc","t0","t1","distanceToPlane","intersectPlane","distToPoint","intersectBox","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","isNaN","intersectTriangle","backfaceCulling","sign","DdN","DdQxE2","DdE1xQ","QdN","Matrix4","n14","n24","n34","n41","n42","n43","n44","isMatrix4","copyPosition","setFromMatrix3","makeBasis","extractRotation","scaleX","_v1$5","scaleY","scaleZ","makeRotationFromEuler","af","bf","ce","cf","de","df","ac","ad","bc","bd","makeRotationFromQuaternion","compose","_zero","_one","eye","up","a14","a24","a34","a41","a42","a43","a44","b14","b24","b34","b41","b42","b43","b44","setPosition","t14","scaleXSq","scaleYSq","scaleZSq","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","makeShear","yx","zx","zy","x2","y2","z2","wx","wy","wz","decompose","_m1$2","invSX","invSY","invSZ","makePerspective","left","right","top","bottom","near","far","coordinateSystem","makeOrthographic","p","zInv","_matrix","_quaternion$3","Euler","DEFAULT_ORDER","isEuler","asin","setFromQuaternion","setFromVector3","reorder","newOrder","Layers","mask","enable","enableAll","toggle","disable","disableAll","layers","isEnabled","_object3DId","_v1$4","_q1","_m1$1","_target","_position$3","_scale$2","_quaternion$2","_xAxis","_yAxis","_zAxis","_addedEvent","_removedEvent","Object3D","isObject3D","parent","DEFAULT_UP","defineProperties","configurable","modelViewMatrix","normalMatrix","DEFAULT_MATRIX_AUTO_UPDATE","matrixWorldNeedsUpdate","matrixWorldAutoUpdate","DEFAULT_MATRIX_WORLD_AUTO_UPDATE","visible","castShadow","receiveShadow","frustumCulled","renderOrder","animations","onBeforeRender","onAfterRender","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","setRotationFromQuaternion","rotateOnAxis","rotateOnWorldAxis","rotateX","rotateY","rotateZ","translateOnAxis","distance","translateX","translateY","translateZ","localToWorld","worldToLocal","isCamera","isLight","arguments","error","removeFromParent","clear","attach","getObjectById","getObjectByProperty","getObjectByName","getObjectsByProperty","childResult","getWorldPosition","getWorldQuaternion","getWorldScale","getWorldDirection","raycast","traverse","traverseVisible","traverseAncestors","updateMatrixWorld","force","child","updateParents","updateChildren","geometries","materials","shapes","skeletons","nodes","serialize","library","element","isInstancedMesh","instanceMatrix","instanceColor","isScene","background","isColor","environment","isMesh","isLine","isPoints","parameters","shape","isSkinnedMesh","bindMode","bindMatrix","skeleton","material","uuids","animation","extractFromCache","cache","values","recursive","_v0$1","_v1$3","_v2$2","_v3$1","_vab","_vac","_vbc","_vap","_vbp","_vcp","warnedGetUV","Triangle","targetLengthSq","dot00","dot01","dot02","dot11","dot12","denom","invDenom","getBarycoord","p3","uv1","uv2","uv3","getInterpolation","v3","setFromPointsAndIndices","i0","i1","i2","setFromAttributeAndIndices","getArea","getMidpoint","getNormal","getPlane","setFromCoplanarPoints","getUV","isFrontFacing","d4","vc","d5","d6","vb","va","materialId","Material","isMaterial","blending","side","vertexColors","opacity","transparent","alphaHash","blendSrc","blendDst","blendEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","depthFunc","depthTest","depthWrite","stencilWriteMask","stencilFunc","stencilRef","stencilFuncMask","stencilFail","stencilZFail","stencilZPass","stencilWrite","clippingPlanes","clipIntersection","clipShadows","shadowSide","colorWrite","precision","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","dithering","alphaToCoverage","premultipliedAlpha","forceSinglePass","toneMapped","_alphaTest","alphaTest","onBuild","onBeforeCompile","customProgramCacheKey","setValues","newValue","currentValue","getHex","roughness","metalness","sheen","sheenColor","sheenRoughness","emissive","emissiveIntensity","specular","specularIntensity","specularColor","shininess","clearcoat","clearcoatRoughness","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","clearcoatNormalScale","iridescence","iridescenceIOR","iridescenceThicknessRange","iridescenceMap","iridescenceThicknessMap","anisotropyRotation","anisotropyMap","matcap","alphaMap","lightMap","lightMapIntensity","aoMap","aoMapIntensity","bumpMap","bumpScale","normalMap","normalMapType","normalScale","displacementMap","displacementScale","displacementBias","roughnessMap","metalnessMap","emissiveMap","specularMap","specularIntensityMap","specularColorMap","envMap","combine","envMapIntensity","reflectivity","refractionRatio","gradientMap","transmission","transmissionMap","thickness","thicknessMap","attenuationDistance","Infinity","attenuationColor","sizeAttenuation","linewidth","dashSize","gapSize","wireframe","wireframeLinewidth","wireframeLinecap","wireframeLinejoin","flatShading","fog","srcPlanes","dstPlanes","_colorKeywords","_hslA","_hslB","hue2rgb","Color","setHex","setStyle","setRGB","hex","setHSL","handleAlpha","string","parseFloat","exec","components","parseInt","charAt","setColorName","copySRGBToLinear","copyLinearToSRGB","_color","getHexString","getHSL","hue","saturation","lightness","getRGB","getStyle","toFixed","offsetHSL","addColors","color1","color2","lerpColors","lerpHSL","NAMES","MeshBasicMaterial","isMeshBasicMaterial","_vector$8","_vector2$1","itemSize","normalized","isBufferAttribute","usage","updateRange","gpuType","onUploadCallback","setUsage","copyAt","index1","index2","copyArray","setXY","setXYZ","setXYZW","onUpload","Uint16BufferAttribute","Uint32BufferAttribute","_id$1","_m1","_obj","_offset","_box$1","_boxMorphTargets","_vector$7","isBufferGeometry","morphAttributes","morphTargetsRelative","groups","boundingSphere","drawRange","start","getIndex","setIndex","getAttribute","deleteAttribute","hasAttribute","addGroup","materialIndex","clearGroups","setDrawRange","tangent","computeBoundingSphere","morphAttributesPosition","isGLBufferAttribute","morphAttribute","jl","computeTangents","indices","positions","normals","uvs","nVertices","tangents","tan1","tan2","vA","vB","vC","uvA","uvB","uvC","sdir","tdir","handleTriangle","isFinite","group","tmp2","n2","handleVertex","computeVertexNormals","positionAttribute","normalAttribute","pA","pB","pC","nA","nB","nC","cb","ab","normalizeNormals","toNonIndexed","convertBufferAttribute","array2","isInterleavedBufferAttribute","stride","geometry2","newAttribute","morphArray","hasMorphAttributes","attributeArray","_inverseMatrix$3","_ray$3","_sphere$5","_sphereHitAt","_vA$1","_vB$1","_vC$1","_tempA","_morphA","_uvA$1","_uvB$1","_uvC$1","_normalA","_normalB","_normalC","_intersectionPoint","_intersectionPointWorld","Mesh","updateMorphTargets","morphTargetInfluences","morphTargetDictionary","ml","String","getVertexPosition","morphPosition","morphInfluences","influence","raycaster","intersects","_computeIntersections","rayLocalSpace","intersection","groupMaterial","checkGeometryIntersection","faceIndex","face","checkIntersection","BoxGeometry","widthSegments","heightSegments","depthSegments","scope","vertices","numberOfVertices","groupStart","buildPlane","udir","vdir","gridX","gridY","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","groupCount","cloneUniforms","property","mergeUniforms","uniforms","merged","getUnlitUniformColorSpace","renderer","getRenderTarget","outputColorSpace","UniformsUtils","merge","ShaderMaterial","isShaderMaterial","defines","uniformsGroups","vertexShader","fragmentShader","lights","clipping","extensions","derivatives","fragDepth","drawBuffers","shaderTextureLOD","defaultAttributeValues","index0AttributeName","uniformsNeedUpdate","glslVersion","cloneUniformsGroups","Camera","PerspectiveCamera","fov","aspect","isPerspectiveCamera","zoom","focus","view","filmGauge","filmOffset","updateProjectionMatrix","setFocalLength","focalLength","vExtentSlope","getFilmHeight","atan","getFocalLength","tan","getEffectiveFOV","getFilmWidth","setViewOffset","fullWidth","fullHeight","offsetX","offsetY","clearViewOffset","skew","CubeCamera","renderTarget","cameraPX","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","updateCoordinateSystem","cameras","scene","currentRenderTarget","currentToneMapping","toneMapping","currentXrEnabled","xr","setRenderTarget","render","CubeTexture","isCubeTexture","WebGLCubeRenderTarget","isWebGLCubeRenderTarget","fromEquirectangularTexture","shader","tEquirect","mesh","currentMinFilter","stencil","_vector1","_vector2","_normalMatrix","Plane","isPlane","setComponents","setFromNormalAndCoplanarPoint","inverseNormalLength","distanceToSphere","projectPoint","intersectLine","line","intersectsLine","startSign","endSign","end","coplanarPoint","optionalNormalMatrix","referencePoint","_sphere$4","_vector$6","Frustum","p4","p5","planes","frustum","setFromProjectionMatrix","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","intersectsObject","intersectsSprite","sprite","negRadius","WebGLAnimation","isAnimating","animationLoop","requestId","onAnimationFrame","time","frame","requestAnimationFrame","stop","cancelAnimationFrame","setAnimationLoop","setContext","WebGLAttributes","gl","capabilities","isWebGL2","buffers","WeakMap","deleteBuffer","buffer","delete","bufferType","cached","bytesPerElement","elementSize","createBuffer","bindBuffer","bufferData","FLOAT","isFloat16BufferAttribute","HALF_FLOAT","UNSIGNED_SHORT","SHORT","UNSIGNED_INT","INT","BYTE","UNSIGNED_BYTE","BYTES_PER_ELEMENT","bufferSubData","subarray","updateBuffer","PlaneGeometry","width_half","height_half","segment_width","segment_height","ShaderChunk","alphahash_fragment","alphahash_pars_fragment","alphamap_fragment","alphamap_pars_fragment","alphatest_fragment","alphatest_pars_fragment","aomap_fragment","aomap_pars_fragment","begin_vertex","beginnormal_vertex","bsdfs","iridescence_fragment","bumpmap_pars_fragment","clipping_planes_fragment","clipping_planes_pars_fragment","clipping_planes_pars_vertex","clipping_planes_vertex","color_fragment","color_pars_fragment","color_pars_vertex","color_vertex","common","cube_uv_reflection_fragment","defaultnormal_vertex","displacementmap_pars_vertex","displacementmap_vertex","emissivemap_fragment","emissivemap_pars_fragment","colorspace_fragment","colorspace_pars_fragment","envmap_fragment","envmap_common_pars_fragment","envmap_pars_fragment","envmap_pars_vertex","envmap_physical_pars_fragment","envmap_vertex","fog_vertex","fog_pars_vertex","fog_fragment","fog_pars_fragment","gradientmap_pars_fragment","lightmap_fragment","lightmap_pars_fragment","lights_lambert_fragment","lights_lambert_pars_fragment","lights_pars_begin","lights_toon_fragment","lights_toon_pars_fragment","lights_phong_fragment","lights_phong_pars_fragment","lights_physical_fragment","lights_physical_pars_fragment","lights_fragment_begin","lights_fragment_maps","lights_fragment_end","logdepthbuf_fragment","logdepthbuf_pars_fragment","logdepthbuf_pars_vertex","logdepthbuf_vertex","map_fragment","map_pars_fragment","map_particle_fragment","map_particle_pars_fragment","metalnessmap_fragment","metalnessmap_pars_fragment","morphcolor_vertex","morphnormal_vertex","morphtarget_pars_vertex","morphtarget_vertex","normal_fragment_begin","normal_fragment_maps","normal_pars_fragment","normal_pars_vertex","normal_vertex","normalmap_pars_fragment","clearcoat_normal_fragment_begin","clearcoat_normal_fragment_maps","clearcoat_pars_fragment","iridescence_pars_fragment","opaque_fragment","packing","premultiplied_alpha_fragment","project_vertex","dithering_fragment","dithering_pars_fragment","roughnessmap_fragment","roughnessmap_pars_fragment","shadowmap_pars_fragment","shadowmap_pars_vertex","shadowmap_vertex","shadowmask_pars_fragment","skinbase_vertex","skinning_pars_vertex","skinning_vertex","skinnormal_vertex","specularmap_fragment","specularmap_pars_fragment","tonemapping_fragment","tonemapping_pars_fragment","transmission_fragment","transmission_pars_fragment","uv_pars_fragment","uv_pars_vertex","uv_vertex","worldpos_vertex","background_vert","background_frag","backgroundCube_vert","backgroundCube_frag","cube_vert","cube_frag","depth_vert","depth_frag","distanceRGBA_vert","distanceRGBA_frag","equirect_vert","equirect_frag","linedashed_vert","linedashed_frag","meshbasic_vert","meshbasic_frag","meshlambert_vert","meshlambert_frag","meshmatcap_vert","meshmatcap_frag","meshnormal_vert","meshnormal_frag","meshphong_vert","meshphong_frag","meshphysical_vert","meshphysical_frag","meshtoon_vert","meshtoon_frag","points_vert","points_frag","shadow_vert","shadow_frag","sprite_vert","sprite_frag","UniformsLib","diffuse","mapTransform","alphaMapTransform","specularmap","specularMapTransform","envmap","flipEnvMap","ior","aomap","aoMapTransform","lightmap","lightMapTransform","bumpmap","bumpMapTransform","normalmap","normalMapTransform","displacementmap","displacementMapTransform","emissivemap","emissiveMapTransform","metalnessmap","metalnessMapTransform","roughnessmap","roughnessMapTransform","gradientmap","fogDensity","fogNear","fogFar","fogColor","ambientLightColor","lightProbe","directionalLights","properties","directionalLightShadows","shadowBias","shadowNormalBias","shadowRadius","shadowMapSize","directionalShadowMap","directionalShadowMatrix","spotLights","coneCos","penumbraCos","decay","spotLightShadows","spotLightMap","spotShadowMap","spotLightMatrix","pointLights","pointLightShadows","shadowCameraNear","shadowCameraFar","pointShadowMap","pointShadowMatrix","hemisphereLights","skyColor","groundColor","rectAreaLights","ltc_1","ltc_2","uvTransform","ShaderLib","basic","lambert","phong","standard","toon","dashed","totalSize","t2D","backgroundIntensity","backgroundCube","backgroundBlurriness","cube","tCube","tFlip","equirect","distanceRGBA","referencePosition","nearDistance","farDistance","shadow","physical","clearcoatMapTransform","clearcoatNormalMapTransform","clearcoatRoughnessMapTransform","iridescenceMapTransform","iridescenceThicknessMinimum","iridescenceThicknessMaximum","iridescenceThicknessMapTransform","sheenColorMap","sheenColorMapTransform","sheenRoughnessMap","sheenRoughnessMapTransform","transmissionMapTransform","transmissionSamplerSize","transmissionSamplerMap","thicknessMapTransform","specularColorMapTransform","specularIntensityMapTransform","anisotropyVector","anisotropyMapTransform","_rgb","WebGLBackground","cubemaps","cubeuvmaps","state","objects","clearColor","planeMesh","boxMesh","clearAlpha","currentBackground","currentBackgroundVersion","currentTonemapping","setClear","getClearColor","setClearColor","getClearAlpha","setClearAlpha","renderList","forceClear","getEnvironmentBlendMode","autoClear","autoClearColor","autoClearDepth","autoClearStencil","unshift","WebGLBindingStates","maxVertexAttributes","MAX_VERTEX_ATTRIBS","extension","vaoAvailable","bindingStates","defaultState","createBindingState","currentState","forceUpdate","bindVertexArrayObject","vao","bindVertexArray","bindVertexArrayOES","deleteVertexArrayObject","deleteVertexArray","deleteVertexArrayOES","newAttributes","enabledAttributes","attributeDivisors","program","initAttributes","enableAttribute","enableAttributeAndDivisor","meshPerAttribute","enableVertexAttribArray","disableUnusedAttributes","disableVertexAttribArray","vertexAttribPointer","integer","vertexAttribIPointer","reset","resetDefaultState","setup","updateBuffers","programMap","stateMap","createVertexArray","createVertexArrayOES","getBindingState","cachedAttributes","geometryAttributes","attributesNum","programAttributes","getAttributes","cachedAttribute","geometryAttribute","saveCache","ELEMENT_ARRAY_BUFFER","isInstancedBufferGeometry","materialDefaultAttributeValues","programAttribute","isInstancedInterleavedBuffer","locationSize","_maxInstanceCount","ARRAY_BUFFER","isInstancedBufferAttribute","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","vertexAttrib1fv","setupVertexAttributes","geometryId","programId","releaseStatesOfGeometry","releaseStatesOfProgram","WebGLBufferRenderer","info","mode","setMode","drawArrays","renderInstances","primcount","methodName","WebGLCapabilities","maxAnisotropy","getMaxPrecision","getShaderPrecisionFormat","VERTEX_SHADER","HIGH_FLOAT","FRAGMENT_SHADER","MEDIUM_FLOAT","WebGL2RenderingContext","maxPrecision","has","logarithmicDepthBuffer","maxTextures","MAX_TEXTURE_IMAGE_UNITS","maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","maxTextureSize","MAX_TEXTURE_SIZE","maxCubemapSize","MAX_CUBE_MAP_TEXTURE_SIZE","maxAttributes","maxVertexUniforms","MAX_VERTEX_UNIFORM_VECTORS","maxVaryings","MAX_VARYING_VECTORS","maxFragmentUniforms","MAX_FRAGMENT_UNIFORM_VECTORS","vertexTextures","floatFragmentTextures","getMaxAnisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT","floatVertexTextures","maxSamples","MAX_SAMPLES","WebGLClipping","globalState","numGlobalPlanes","localClippingEnabled","renderingShadows","viewNormalMatrix","uniform","projectPlanes","skipTransform","nPlanes","dstArray","flatSize","viewMatrix","i4","numPlanes","numIntersection","init","enableLocalClipping","beginShadows","endShadows","setGlobalState","setState","useCache","materialProperties","nGlobal","lGlobal","clippingState","WebGLCubeMaps","mapTextureMapping","onTextureDispose","cubemap","OrthographicCamera","isOrthographicCamera","scaleW","scaleH","EXTRA_LOD_SIGMA","_flatCamera","_clearColor","_oldTarget","PHI","INV_PHI","_axisDirections","PMREMGenerator","_renderer","_pingPongRenderTarget","_lodMax","_cubeSize","_lodPlanes","_sizeLods","_sigmas","_blurMaterial","_cubemapMaterial","_equirectMaterial","_compileMaterial","fromScene","sigma","_setSize","cubeUVRenderTarget","_allocateTargets","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","fromEquirectangular","equirectangular","_fromTexture","fromCubemap","compileCubemapShader","_getCubemapMaterial","compileEquirectangularShader","_getEquirectMaterial","_dispose","cubeSize","log2","outputTarget","_setViewport","_textureToCubeUV","params","_createRenderTarget","sizeLods","lodPlanes","sigmas","lodMax","lod","totalLods","sizeLod","texelSize","cubeFaces","positionSize","uvSize","faceIndexSize","coordinates","fill","_createPlanes","weights","poleAxis","_getBlurShader","tmpMesh","compile","cubeCamera","upSign","forwardSign","originalAutoClear","backgroundMaterial","backgroundBox","useSolidColor","col","lodIn","lodOut","pingPongRenderTarget","_halfBlur","targetIn","targetOut","sigmaRadians","blurMaterial","blurMesh","blurUniforms","pixels","radiansPerPixel","sigmaPixels","sum","weight","outputSize","WebGLCubeUVMaps","cubeUVmaps","pmremGenerator","cubemapUV","isEquirectMap","isCubeMap","isCubeTextureComplete","WebGLExtensions","getExtension","WebGLGeometries","wireframeAttributes","onGeometryDispose","memory","updateWireframeAttribute","geometryIndex","geometryPosition","previousAttribute","getWireframeAttribute","currentAttribute","WebGLIndexedBufferRenderer","drawElements","WebGLInfo","calls","triangles","lines","programs","autoReset","instanceCount","TRIANGLES","LINES","LINE_STRIP","LINE_LOOP","POINTS","numericalSort","absNumericalSort","WebGLMorphtargets","influencesList","morphTextures","morph","workInfluences","objectInfluences","morphTargetsCount","entry","hasMorphPosition","hasMorphNormals","hasMorphColors","morphTargets","morphNormals","morphColors","vertexDataCount","vertexDataStride","morphTarget","morphNormal","morphColor","disposeTexture","morphInfluencesSum","morphBaseInfluence","getUniforms","setValue","influences","sort","MAX_SAFE_INTEGER","WebGLObjects","updateMap","onInstancedMeshDispose","instancedMesh","buffergeometry","emptyTexture","emptyArrayTexture","empty3dTexture","emptyCubeTexture","arrayCacheF32","arrayCacheI32","mat4array","mat3array","mat2array","flatten","nBlocks","blockSize","firstElem","arraysEqual","allocTexUnits","allocateTextureUnit","setValueV1f","uniform1f","addr","setValueV2f","uniform2f","uniform2fv","setValueV3f","uniform3f","uniform3fv","setValueV4f","uniform4f","uniform4fv","setValueM2","uniformMatrix2fv","setValueM3","uniformMatrix3fv","setValueM4","uniformMatrix4fv","setValueV1i","uniform1i","setValueV2i","uniform2i","uniform2iv","setValueV3i","uniform3i","uniform3iv","setValueV4i","uniform4i","uniform4iv","setValueV1ui","uniform1ui","setValueV2ui","uniform2ui","uniform2uiv","setValueV3ui","uniform3ui","uniform3uiv","setValueV4ui","uniform4ui","uniform4uiv","setValueT1","unit","setTexture2D","setValueT3D1","setTexture3D","setValueT6","setTextureCube","setValueT2DArray1","setTexture2DArray","setValueV1fArray","uniform1fv","setValueV2fArray","setValueV3fArray","setValueV4fArray","setValueM2Array","setValueM3Array","setValueM4Array","setValueV1iArray","uniform1iv","setValueV2iArray","setValueV3iArray","setValueV4iArray","setValueV1uiArray","uniform1uiv","setValueV2uiArray","setValueV3uiArray","setValueV4uiArray","setValueT1Array","units","setValueT3DArray","setValueT6Array","setValueT2DArrayArray","SingleUniform","activeInfo","getSingularSetter","PureArrayUniform","getPureArraySetter","StructuredUniform","seq","RePathPart","addUniform","container","uniformObject","parseUniform","path","pathLength","lastIndex","match","matchEnd","idIsIndex","subscript","WebGLUniforms","getProgramParameter","ACTIVE_UNIFORMS","getActiveUniform","getUniformLocation","setOptional","WebGLShader","createShader","shaderSource","compileShader","programIdCount","getShaderErrors","status","getShaderParameter","COMPILE_STATUS","errors","getShaderInfoLog","trim","errorMatches","errorLine","toUpperCase","split","lines2","to","handleSource","getShaderSource","getTexelEncodingFunction","functionName","getEncodingComponents","getToneMappingFunction","toneMappingName","filterEmptyLine","replaceLightNums","numSpotLightCoords","numSpotLightShadows","numSpotLightMaps","numSpotLightShadowsWithMaps","numDirLights","numSpotLights","numRectAreaLights","numPointLights","numHemiLights","numDirLightShadows","numPointLightShadows","replaceClippingPlaneNums","numClippingPlanes","numClipIntersection","includePattern","resolveIncludes","includeReplacer","shaderChunkMap","Map","include","newInclude","unrollLoopPattern","unrollLoops","loopReplacer","snippet","generatePrecision","precisionstring","WebGLProgram","cacheKey","shadowMapTypeDefine","shadowMapType","generateShadowMapTypeDefine","envMapTypeDefine","envMapMode","generateEnvMapTypeDefine","envMapModeDefine","generateEnvMapModeDefine","envMapBlendingDefine","generateEnvMapBlendingDefine","envMapCubeUVSize","imageHeight","envMapCubeUVHeight","maxMip","texelHeight","texelWidth","generateCubeUVSize","customExtensions","extensionDerivatives","normalMapTangentSpace","shaderID","extensionFragDepth","rendererExtensionFragDepth","extensionDrawBuffers","rendererExtensionDrawBuffers","extensionShaderTextureLOD","rendererExtensionShaderTextureLod","generateExtensions","customDefines","chunks","generateDefines","createProgram","prefixVertex","prefixFragment","versionString","isRawShaderMaterial","shaderType","shaderName","instancing","instancingColor","useFog","fogExp2","normalMapObjectSpace","mapUv","alphaMapUv","lightMapUv","aoMapUv","emissiveMapUv","bumpMapUv","normalMapUv","displacementMapUv","metalnessMapUv","roughnessMapUv","anisotropyMapUv","clearcoatMapUv","clearcoatNormalMapUv","clearcoatRoughnessMapUv","iridescenceMapUv","iridescenceThicknessMapUv","sheenColorMapUv","sheenRoughnessMapUv","specularMapUv","specularColorMapUv","specularIntensityMapUv","transmissionMapUv","thicknessMapUv","vertexTangents","vertexAlphas","vertexUv1s","vertexUv2s","vertexUv3s","pointsUvs","skinning","morphTextureStride","doubleSided","flipSided","shadowMapEnabled","useLegacyLights","opaque","useDepthPacking","depthPacking","vertexGlsl","fragmentGlsl","glVertexShader","glFragmentShader","attachShader","bindAttribLocation","linkProgram","debug","checkShaderErrors","programLog","getProgramInfoLog","vertexLog","fragmentLog","runnable","haveDiagnostics","LINK_STATUS","onShaderError","vertexErrors","fragmentErrors","getError","VALIDATE_STATUS","diagnostics","prefix","cachedUniforms","deleteShader","ACTIVE_ATTRIBUTES","getActiveAttrib","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","getAttribLocation","fetchAttributeLocations","destroy","deleteProgram","usedTimes","_id","WebGLShaderCache","shaderCache","materialCache","vertexShaderStage","_getShaderStage","fragmentShaderStage","materialShaders","_getShaderCacheForMaterial","shaderStage","code","getVertexShaderID","getFragmentShaderID","Set","stage","WebGLShaderStage","WebGLPrograms","_programLayers","_customShaders","IS_WEBGL2","SUPPORTS_VERTEX_TEXTURES","shaderIDs","MeshDepthMaterial","MeshDistanceMaterial","MeshNormalMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial","MeshStandardMaterial","MeshPhysicalMaterial","MeshMatcapMaterial","LineBasicMaterial","LineDashedMaterial","PointsMaterial","ShadowMaterial","SpriteMaterial","getChannel","getParameters","shadows","isMeshStandardMaterial","customVertexShaderID","customFragmentShaderID","IS_INSTANCEDMESH","HAS_MAP","HAS_MATCAP","HAS_ENVMAP","HAS_AOMAP","HAS_LIGHTMAP","HAS_BUMPMAP","HAS_NORMALMAP","HAS_DISPLACEMENTMAP","HAS_EMISSIVEMAP","HAS_METALNESSMAP","HAS_ROUGHNESSMAP","HAS_ANISOTROPY","HAS_CLEARCOAT","HAS_IRIDESCENCE","HAS_SHEEN","HAS_TRANSMISSION","HAS_ANISOTROPYMAP","HAS_CLEARCOATMAP","HAS_CLEARCOAT_NORMALMAP","HAS_CLEARCOAT_ROUGHNESSMAP","HAS_IRIDESCENCEMAP","HAS_IRIDESCENCE_THICKNESSMAP","HAS_SHEEN_COLORMAP","HAS_SHEEN_ROUGHNESSMAP","HAS_SPECULARMAP","HAS_SPECULAR_COLORMAP","HAS_SPECULAR_INTENSITYMAP","HAS_TRANSMISSIONMAP","HAS_THICKNESSMAP","HAS_GRADIENTMAP","HAS_ALPHAMAP","HAS_ALPHATEST","HAS_ALPHAHASH","HAS_EXTENSIONS","HAS_ATTRIBUTE_UV1","HAS_ATTRIBUTE_UV2","HAS_ATTRIBUTE_UV3","supportsVertexTextures","isXRRenderTarget","isFogExp2","directional","spot","rectArea","hemi","shadowMap","getProgramCacheKey","morphAttributeCount","getProgramCacheKeyParameters","getProgramCacheKeyBooleans","acquireProgram","pl","preexistingProgram","releaseProgram","pop","releaseShaderCache","WebGLProperties","painterSortStable","groupOrder","reversePainterSortStable","WebGLRenderList","renderItems","renderItemsIndex","transmissive","getNextRenderItem","renderItem","finish","customOpaqueSort","customTransparentSort","WebGLRenderLists","lists","renderCallDepth","listArray","UniformsCache","light","halfWidth","halfHeight","nextVersion","shadowCastingAndTexturingLightsFirst","lightA","lightB","WebGLLights","shadowCache","ShadowUniformsCache","directionalLength","pointLength","spotLength","rectAreaLength","hemiLength","numDirectionalShadows","numPointShadows","numSpotShadows","numSpotMaps","ambient","probe","directionalShadow","spotShadow","rectAreaLTC1","rectAreaLTC2","pointShadow","vector3","matrix42","numSpotShadowsWithMaps","scaleFactor","intensity","isAmbientLight","isLightProbe","sh","coefficients","isDirectionalLight","shadowUniforms","bias","normalBias","mapSize","isSpotLight","penumbra","updateMatrices","isRectAreaLight","isPointLight","isHemisphereLight","LTC_FLOAT_1","LTC_FLOAT_2","LTC_HALF_1","LTC_HALF_2","setupView","WebGLRenderState","lightsArray","shadowsArray","setupLights","setupLightsView","pushLight","pushShadow","shadowLight","WebGLRenderStates","renderStates","renderStateArray","renderState","isMeshDepthMaterial","isMeshDistanceMaterial","WebGLShadowMap","_objects","_capabilities","_frustum","_shadowMapSize","_viewportSize","_viewport","_depthMaterial","_distanceMaterial","_materialCache","_maxTextureSize","shadowMaterialVertical","VSM_SAMPLES","shadow_pass","resolution","shadowMaterialHorizontal","HORIZONTAL_PASS","fullScreenTri","fullScreenMesh","autoUpdate","_previousType","VSMPass","blurSamples","mapPass","renderBufferDirect","getDepthMaterial","customMaterial","customDistanceMaterial","customDepthMaterial","keyA","keyB","materialsForVariant","cachedMaterial","renderObject","shadowCamera","k","kl","depthMaterial","activeCubeFace","getActiveCubeFace","activeMipmapLevel","getActiveMipmapLevel","_state","setBlending","setTest","setScissorTest","toVSM","fromVSM","shadowFrameExtents","getFrameExtents","pars","viewportCount","getViewportCount","vp","getViewport","getFrustum","isPointLightShadow","WebGLState","colorBuffer","locked","currentColorMask","currentColorClear","setMask","colorMask","setLocked","lock","currentDepthMask","currentDepthFunc","currentDepthClear","DEPTH_TEST","depthMask","setFunc","NEVER","ALWAYS","LESS","LEQUAL","EQUAL","GEQUAL","GREATER","NOTEQUAL","clearDepth","currentStencilMask","currentStencilFunc","currentStencilRef","currentStencilFuncMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentStencilClear","stencilTest","STENCIL_TEST","stencilMask","setOp","stencilOp","clearStencil","uboBindings","uboProgramMap","enabledCapabilities","currentBoundFramebuffers","currentDrawbuffers","defaultDrawbuffers","currentProgram","currentBlendingEnabled","currentBlending","currentBlendEquation","currentBlendSrc","currentBlendDst","currentBlendEquationAlpha","currentBlendSrcAlpha","currentBlendDstAlpha","currentPremultipledAlpha","currentFlipSided","currentCullFace","currentLineWidth","currentPolygonOffsetFactor","currentPolygonOffsetUnits","MAX_COMBINED_TEXTURE_IMAGE_UNITS","lineWidthAvailable","glVersion","VERSION","currentTextureSlot","currentBoundTextures","scissorParam","SCISSOR_BOX","viewportParam","VIEWPORT","currentScissor","currentViewport","createTexture","dimensions","bindTexture","texParameteri","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","TEXTURE_3D","TEXTURE_2D_ARRAY","texImage2D","RGBA","texImage3D","emptyTextures","TEXTURE_2D","TEXTURE_CUBE_MAP","TEXTURE_CUBE_MAP_POSITIVE_X","setFlipSided","setCullFace","CULL_FACE","equationToGL","FUNC_ADD","FUNC_SUBTRACT","FUNC_REVERSE_SUBTRACT","MIN","MAX","MIN_EXT","MAX_EXT","factorToGL","ZERO","ONE","SRC_COLOR","SRC_ALPHA","SRC_ALPHA_SATURATE","DST_COLOR","DST_ALPHA","ONE_MINUS_SRC_COLOR","ONE_MINUS_SRC_ALPHA","ONE_MINUS_DST_COLOR","ONE_MINUS_DST_ALPHA","BLEND","blendEquationSeparate","blendFuncSeparate","blendFunc","frontFace","CW","CCW","cullFace","BACK","FRONT","FRONT_AND_BACK","setPolygonOffset","factor","POLYGON_OFFSET_FILL","bindFramebuffer","framebuffer","DRAW_FRAMEBUFFER","FRAMEBUFFER","isWebGLMultipleRenderTargets","COLOR_ATTACHMENT0","drawBuffersWEBGL","useProgram","setMaterial","frontFaceCW","SAMPLE_ALPHA_TO_COVERAGE","setLineWidth","lineWidth","SCISSOR_TEST","activeTexture","webglSlot","TEXTURE0","webglType","webglTexture","boundTexture","unbindTexture","compressedTexImage2D","apply","compressedTexImage3D","updateUBOMapping","uniformsGroup","blockIndex","getUniformBlockIndex","uniformBlockBinding","__bindingPointIndex","texStorage2D","texStorage3D","texSubImage2D","texSubImage3D","compressedTexSubImage2D","compressedTexSubImage3D","KEEP","READ_FRAMEBUFFER","WebGLTextures","_gl","utils","multisampledRTTExt","supportsInvalidateFramebuffer","navigator","userAgent","_videoTextures","_sources","useOffscreenCanvas","OffscreenCanvas","createCanvas","resizeImage","needsPowerOfTwo","needsNewCanvas","maxSize","isPowerOfTwo$1","textureNeedsGenerateMipmaps","supportsMips","generateMipmap","getInternalFormat","internalFormatName","glFormat","glType","forceLinearTransfer","RED","R32F","R16F","R8","RG","RG32F","RG16F","RG8","RGBA32F","RGBA16F","SRGB8_ALPHA8","RGBA8","UNSIGNED_SHORT_4_4_4_4","RGBA4","UNSIGNED_SHORT_5_5_5_1","RGB5_A1","getMipLevels","isFramebufferTexture","isCompressedTexture","filterFallback","LINEAR","textureProperties","__webglInit","webglTextures","__cacheKey","deleteTexture","deallocateTexture","isVideoTexture","onRenderTargetDispose","renderTargetProperties","__webglTexture","deleteFramebuffer","__webglFramebuffer","__webglDepthbuffer","deleteRenderbuffer","__webglMultisampledFramebuffer","__webglColorRenderbuffer","__webglDepthRenderbuffer","attachmentProperties","deallocateRenderTarget","textureUnits","slot","updateVideoTexture","__version","complete","uploadTexture","wrappingToGL","REPEAT","CLAMP_TO_EDGE","MIRRORED_REPEAT","filterToGL","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","compareToGL","setTextureParameters","textureType","TEXTURE_WRAP_S","TEXTURE_WRAP_T","TEXTURE_WRAP_R","compareFunction","TEXTURE_COMPARE_MODE","COMPARE_REF_TO_TEXTURE","TEXTURE_COMPARE_FUNC","__currentAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","initTexture","forceUpload","textureCacheKey","getTextureCacheKey","isCompressedArrayTexture","sourceProperties","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","UNPACK_COLORSPACE_CONVERSION_WEBGL","NONE","textureNeedsPowerOfTwo","verifyColorSpace","mipmap","glInternalFormat","useTexStorage","allocateMemory","levels","isDepthTexture","DEPTH_COMPONENT","DEPTH_COMPONENT32F","DEPTH_COMPONENT24","DEPTH24_STENCIL8","DEPTH_COMPONENT16","DEPTH_STENCIL","setupFrameBufferTexture","attachment","textureTarget","__hasExternalTextures","useMultisampledRTT","framebufferTexture2DMultisampleEXT","getRenderTargetSamples","TEXTURE_CUBE_MAP_NEGATIVE_Z","framebufferTexture2D","setupRenderBufferStorage","renderbuffer","isMultisample","bindRenderbuffer","RENDERBUFFER","renderbufferStorageMultisampleEXT","renderbufferStorageMultisample","renderbufferStorage","framebufferRenderbuffer","DEPTH_ATTACHMENT","DEPTH_STENCIL_ATTACHMENT","setupDepthRenderbuffer","isCube","__autoAllocateDepthBuffer","webglDepthTexture","setupDepthTexture","createRenderbuffer","__useRenderToTexture","sRGBToLinear","textureUnit","resetTextureUnits","isCompressed","cubeImage","mipmapImage","uploadCubeTexture","rebindTextures","colorTexture","setupRenderTarget","isMultipleRenderTargets","createFramebuffer","glTextureType","isWebGL3DRenderTarget","isWebGLArrayRenderTarget","updateRenderTargetMipmap","updateMultisampleRenderTarget","COLOR_BUFFER_BIT","invalidationArray","depthStyle","ignoreDepthValues","__ignoreDepthValues","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","invalidateFramebuffer","blitFramebuffer","WebGLUtils","HALF_FLOAT_OES","ALPHA","LUMINANCE","LUMINANCE_ALPHA","SRGB_ALPHA_EXT","RED_INTEGER","RG_INTEGER","RGBA_INTEGER","COMPRESSED_SRGB_S3TC_DXT1_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT","COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","COMPRESSED_RGB_ETC1_WEBGL","COMPRESSED_SRGB8_ETC2","COMPRESSED_RGB8_ETC2","COMPRESSED_SRGB8_ALPHA8_ETC2_EAC","COMPRESSED_RGBA8_ETC2_EAC","COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR","COMPRESSED_RGBA_ASTC_4x4_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR","COMPRESSED_RGBA_ASTC_5x4_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR","COMPRESSED_RGBA_ASTC_5x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR","COMPRESSED_RGBA_ASTC_6x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR","COMPRESSED_RGBA_ASTC_6x6_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR","COMPRESSED_RGBA_ASTC_8x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR","COMPRESSED_RGBA_ASTC_8x6_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR","COMPRESSED_RGBA_ASTC_8x8_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR","COMPRESSED_RGBA_ASTC_10x5_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR","COMPRESSED_RGBA_ASTC_10x6_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR","COMPRESSED_RGBA_ASTC_10x8_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR","COMPRESSED_RGBA_ASTC_10x10_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR","COMPRESSED_RGBA_ASTC_12x10_KHR","COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR","COMPRESSED_RGBA_ASTC_12x12_KHR","COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT","COMPRESSED_RGBA_BPTC_UNORM_EXT","COMPRESSED_RED_RGTC1_EXT","COMPRESSED_SIGNED_RED_RGTC1_EXT","COMPRESSED_RED_GREEN_RGTC2_EXT","COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT","UNSIGNED_INT_24_8","UNSIGNED_INT_24_8_WEBGL","ArrayCamera","isArrayCamera","Group","isGroup","_moveEvent","WebXRController","_targetRay","_grip","_hand","getHandSpace","joints","inputState","pinching","getTargetRaySpace","hasLinearVelocity","linearVelocity","hasAngularVelocity","angularVelocity","getGripSpace","connect","inputSource","hand","inputjoint","_getHandJoint","disconnect","referenceSpace","inputPose","gripPose","handPose","targetRay","grip","session","visibilityState","jointPose","getJointPose","joint","transform","jointRadius","indexTip","thumbTip","distanceToPinch","threshold","handedness","gripSpace","getPose","targetRaySpace","jointName","DepthTexture","WebXRManager","framebufferScaleFactor","referenceSpaceType","foveation","customReferenceSpace","pose","glBinding","glProjLayer","glBaseLayer","xrFrame","getContextAttributes","initialRenderTarget","newRenderTarget","controllers","controllerInputSources","cameraL","cameraR","cameraXR","_currentDepthNear","_currentDepthFar","onSessionEvent","controllerIndex","controller","onSessionEnd","onInputSourcesChange","isPresenting","removed","added","cameraAutoUpdate","getController","getControllerGrip","getHand","setFramebufferScaleFactor","setReferenceSpaceType","getReferenceSpace","setReferenceSpace","space","getBaseLayer","getBinding","getFrame","getSession","setSession","async","xrCompatible","makeXRCompatible","layerInit","antialias","XRWebGLLayer","updateRenderState","baseLayer","framebufferWidth","framebufferHeight","depthFormat","depthType","glDepthFormat","projectionlayerInit","colorFormat","XRWebGLBinding","createProjectionLayer","textureWidth","textureHeight","setFoveation","requestReferenceSpace","environmentBlendMode","cameraLPos","cameraRPos","updateCamera","depthNear","depthFar","ipd","projL","projR","topFov","bottomFov","leftFov","rightFov","zOffset","xOffset","near2","far2","left2","right2","top2","bottom2","setProjectionFromUnion","updateUserCamera","getCamera","getFoveation","fixedFoveation","onAnimationFrameCallback","getViewerPose","views","setRenderTargetFramebuffer","cameraXRNeedsUpdate","glSubImage","getViewSubImage","setRenderTargetTextures","depthStencilTexture","detectedPlanes","WebGLMaterials","refreshTransformUniform","refreshUniformsCommon","refreshFogUniforms","isFog","density","refreshMaterialUniforms","pixelRatio","transmissionRenderTarget","isMeshLambertMaterial","isMeshToonMaterial","refreshUniformsToon","isMeshPhongMaterial","refreshUniformsPhong","refreshUniformsStandard","isMeshPhysicalMaterial","refreshUniformsPhysical","isMeshMatcapMaterial","refreshUniformsMatcap","refreshUniformsDistance","isMeshNormalMaterial","isLineBasicMaterial","refreshUniformsLine","isLineDashedMaterial","refreshUniformsDash","isPointsMaterial","refreshUniformsPoints","isSpriteMaterial","refreshUniformsSprites","isShadowMaterial","WebGLUniformsGroups","updateList","allocatedBindingPoints","maxBindingPoints","MAX_UNIFORM_BUFFER_BINDINGS","hasUniformChanged","tempValues","cachedObjects","cachedObject","getUniformSize","boundary","storage","onUniformsGroupsDispose","webglProgram","chunkOffset","infos","__data","__offset","__size","__cache","prepareUniformsGroup","bindingPointIndex","allocateBindingPointIndex","UNIFORM_BUFFER","bindBufferBase","arrayOffset","updateBufferData","createCanvasElement","display","WebGLRenderer","preserveDrawingBuffer","powerPreference","failIfMajorPerformanceCaveat","_alpha","isWebGLRenderer","uintClearColor","intClearColor","currentRenderList","currentRenderState","renderListStack","renderStateStack","domElement","sortObjects","toneMappingExposure","_this","_isContextLost","_currentActiveCubeFace","_currentActiveMipmapLevel","_currentRenderTarget","_currentMaterialId","_currentCamera","_currentViewport","_currentScissor","_currentScissorTest","_currentClearColor","_currentClearAlpha","_width","_height","_pixelRatio","_opaqueSort","_transparentSort","_scissor","_scissorTest","_clippingEnabled","_localClippingEnabled","_transmissionRenderTarget","_projScreenMatrix","_vector3","_emptyScene","overrideMaterial","getTargetPixelRatio","programCache","renderLists","morphtargets","bufferRenderer","indexedBufferRenderer","contextNames","contextAttributes","contextName","onContextLost","onContextRestore","onContextCreationError","isWebGL1Renderer","shift","WebGLRenderingContext","initGLContext","infoAutoReset","shadowMapAutoUpdate","shadowMapNeedsUpdate","statusMessage","onMaterialDispose","releaseMaterialProgramReferences","deallocateMaterial","forceContextLoss","loseContext","forceContextRestore","restoreContext","getPixelRatio","setPixelRatio","updateStyle","setViewport","getDrawingBufferSize","setDrawingBufferSize","getCurrentViewport","getScissor","setScissor","getScissorTest","boolean","setOpaqueSort","method","setTransparentSort","bits","isIntegerFormat","targetFormat","targetType","isUnsignedType","clearBufferuiv","COLOR","clearBufferiv","onXRSessionStart","onXRSessionEnd","needsProgramChange","needsLights","lightsStateVersion","getProgram","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","uCamPos","cameraPosition","boneTexture","computeBoneTexture","boneTextureSize","isMeshGouraudMaterial","upload","uniformsList","setProgram","rangeFactor","drawStart","drawEnd","drawCount","isLineSegments","isLineLoop","isSprite","maxInstanceCount","prepare","projectObject","isLOD","renderScene","opaqueObjects","transmissiveObjects","transparentObjects","renderObjects","renderTargetNeedsUpdate","currentSide","renderTransmissionPass","programCacheKey","updateCommonMaterialProperties","materialNeedsLights","progUniforms","seqWithValue","self","camera2","defaultFramebuffer","__useDefaultFramebuffer","useDefaultFramebuffer","isRenderTarget3D","layer","framebufferTextureLayer","readRenderTargetPixels","activeCubeFaceIndex","textureFormat","IMPLEMENTATION_COLOR_READ_FORMAT","halfFloatSupportedByExt","IMPLEMENTATION_COLOR_READ_TYPE","readPixels","copyFramebufferToTexture","level","levelScale","copyTexSubImage2D","copyTextureToTexture","srcTexture","dstTexture","copyTextureToTexture3D","sourceBox","glTarget","unpackRowLen","UNPACK_ROW_LENGTH","unpackImageHeight","UNPACK_IMAGE_HEIGHT","unpackSkipPixels","UNPACK_SKIP_PIXELS","unpackSkipRows","UNPACK_SKIP_ROWS","unpackSkipImages","UNPACK_SKIP_IMAGES","resetState","__THREE_DEVTOOLS__","CustomEvent","detail","physicallyCorrectLights","outputEncoding","Scene","isInterleavedBuffer","arrayBuffers","_uuid","ib","_vector$5","interleavedBuffer","interleavedBuffers","_basePosition","_skinIndex","_skinWeight","_matrix4","_vertex","_sphere$3","_inverseMatrix$2","_ray$2","SkinnedMesh","bindMatrixInverse","applyBoneTransform","calculateInverses","normalizeSkinWeights","skinWeight","skinIndex","boneIndex","bones","boneInverses","boneTransform","Bone","isBone","DataTexture","_offsetMatrix","_identityMatrix","Skeleton","boneMatrices","inverse","bone","getBoneByName","fromJSON","json","boneInverse","_instanceLocalMatrix","_instanceWorldMatrix","_instanceIntersects","_box3","_identity","_mesh","_sphere$2","InstancedMesh","setMatrixAt","getMatrixAt","getColorAt","raycastTimes","instanceId","setColorAt","linecap","linejoin","_start$1","_end$1","_inverseMatrix$1","_ray$1","_sphere$1","Line","computeLineDistances","lineDistances","localThreshold","localThresholdSq","vStart","vEnd","interSegment","interRay","_start","_end","LineSegments","LineLoop","_inverseMatrix","_ray","_sphere","_position$2","Points","testPoint","rayPointDistanceSq","intersectPoint","distanceToRay","_anisotropy","_clearcoat","_iridescence","_sheen","_transmission","arraySlice","isTypedArray","convertArray","forceClone","ArrayBuffer","isView","DataView","getKeyframeOrder","times","sortedArray","nValues","srcOffset","flattenJSON","jsonKeys","valuePropertyName","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","_cachedIndex","valueSize","settings","DefaultSettings_","evaluate","pp","validate_interval","seek","linear_scan","forward_scan","giveUpAt","copySampleValue_","t1global","mid","intervalChanged_","interpolate_","getSettings_","CubicInterpolant","_weightPrev","_offsetPrev","_weightNext","_offsetNext","endingStart","endingEnd","iPrev","iNext","tPrev","tNext","halfDt","o1","o0","oP","oN","wP","wN","ppp","sP","sN","LinearInterpolant","offset1","offset0","weight1","weight0","DiscreteInterpolant","KeyframeTrack","interpolation","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","track","trackType","ValueTypeName","InterpolantFactoryMethodDiscrete","getValueSize","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","factoryMethod","createInterpolant","timeOffset","timeScale","startTime","endTime","nKeys","validate","valid","prevTime","currTime","optimize","smoothInterpolation","writeIndex","keep","offsetP","offsetN","readOffset","writeOffset","TypedKeyframeTrack","BooleanKeyframeTrack","ColorKeyframeTrack","NumberKeyframeTrack","QuaternionLinearInterpolant","slerpFlat","QuaternionKeyframeTrack","StringKeyframeTrack","VectorKeyframeTrack","AnimationClip","duration","tracks","blendMode","NormalAnimationBlendMode","resetDuration","jsonTracks","frameTime","fps","parseKeyframeTrack","clip","clipTracks","morphTargetSequence","noLoop","numMorphTargets","objectOrClipArray","clipArray","animationToMorphTargets","pattern","parts","animationMorphTargets","clips","CreateFromMorphTargetSequence","addNonemptyTrack","trackName","animationKeys","propertyName","destTracks","clipName","hierarchyTracks","hierarchy","morphTargetNames","morphTargetName","animationKey","boneName","typeName","getTrackTypeForValueTypeName","Cache","files","file","LoadingManager","onLoad","onProgress","onError","urlModifier","isLoading","itemsLoaded","itemsTotal","handlers","onStart","itemStart","itemEnd","itemError","resolveURL","setURLModifier","addHandler","regex","loader","removeHandler","getHandler","global","DefaultLoadingManager","Loader","manager","crossOrigin","withCredentials","resourcePath","requestHeader","load","loadAsync","Promise","resolve","reject","setCrossOrigin","setWithCredentials","setPath","setResourcePath","setRequestHeader","DEFAULT_MATERIAL_NAME","loading","HttpError","response","FileLoader","setTimeout","req","Request","headers","Headers","credentials","mimeType","responseType","fetch","then","ReadableStream","getReader","callbacks","reader","contentLength","total","lengthComputable","loaded","stream","readData","read","close","byteLength","ProgressEvent","enqueue","Response","statusText","arrayBuffer","blob","text","DOMParser","parseFromString","label","decoder","TextDecoder","decode","catch","finally","setResponseType","setMimeType","ImageLoader","onImageLoad","removeEventListeners","onImageError","TextureLoader","Light","_projScreenMatrix$1","_lightPositionWorld$1","_lookTarget$1","LightShadow","_frameExtents","_viewportCount","_viewports","shadowMatrix","viewportIndex","SpotLightShadow","isSpotLightShadow","SpotLight","power","_lightPositionWorld","_lookTarget","PointLightShadow","_cubeDirections","_cubeUps","PointLight","DirectionalLightShadow","isDirectionalLightShadow","DirectionalLight","AmbientLight","LoaderUtils","fromCharCode","decodeURIComponent","escape","lastIndexOf","ImageBitmapLoader","isImageBitmapLoader","createImageBitmap","setOptions","fetchOptions","res","colorSpaceConversion","imageBitmap","Clock","autoStart","oldTime","elapsedTime","running","now","getElapsedTime","getDelta","diff","newTime","performance","Date","_RESERVED_CHARS_RE","_reservedRe","RegExp","_wordChar","_wordCharOrDot","_trackRe","_supportedObjectNames","PropertyBinding","rootNode","parsedPath","parseTrackName","node","findNode","nodeName","getValue","_getValue_unbound","_setValue_unbound","root","isAnimationObjectGroup","Composite","matches","results","objectName","objectIndex","propertyIndex","lastDot","substring","searchNodeSubtree","childNode","subTreeNode","_getValue_unavailable","_setValue_unavailable","_getValue_direct","targetObject","_getValue_array","resolvedProperty","_getValue_arrayElement","_getValue_toArray","_setValue_direct","_setValue_direct_setNeedsUpdate","_setValue_direct_setMatrixWorldNeedsUpdate","_setValue_array","dest","_setValue_array_setNeedsUpdate","_setValue_array_setMatrixWorldNeedsUpdate","_setValue_arrayElement","_setValue_arrayElement_setNeedsUpdate","_setValue_arrayElement_setMatrixWorldNeedsUpdate","_setValue_fromArray","_setValue_fromArray_setNeedsUpdate","_setValue_fromArray_setMatrixWorldNeedsUpdate","targetArray","sourceArray","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","ArrayElement","HasFromToArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","unbind","targetGroup","optionalParsedPath","_targetGroup","_bindings","subscribe_","firstValidIndex","nCachedObjects_","binding","bindings","Raycaster","LOD","Sprite","setFromCamera","coords","intersectObject","ascSort","intersectObjects","toTrianglesDrawMode","drawMode","numberOfTriangles","newIndices","newGeometry","revision","__THREE__","GLTFLoader","dracoLoader","ktx2Loader","meshoptDecoder","pluginCallbacks","register","parser","GLTFMaterialsClearcoatExtension","GLTFTextureBasisUExtension","GLTFTextureWebPExtension","GLTFTextureAVIFExtension","GLTFMaterialsSheenExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsEmissiveStrengthExtension","GLTFMaterialsSpecularExtension","GLTFMaterialsIridescenceExtension","GLTFMaterialsAnisotropyExtension","GLTFLightsExtension","GLTFMeshoptCompression","GLTFMeshGpuInstancing","extractUrlBase","_onError","gltf","setDRACOLoader","setDDSLoader","setKTX2Loader","setMeshoptDecoder","unregister","plugins","textDecoder","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","KHR_BINARY_GLTF","GLTFBinaryExtension","asset","GLTFParser","fileLoader","plugin","extensionsUsed","extensionName","extensionsRequired","KHR_MATERIALS_UNLIT","GLTFMaterialsUnlitExtension","KHR_DRACO_MESH_COMPRESSION","GLTFDracoMeshCompressionExtension","KHR_TEXTURE_TRANSFORM","GLTFTextureTransformExtension","KHR_MESH_QUANTIZATION","GLTFMeshQuantizationExtension","setExtensions","setPlugins","parseAsync","GLTFRegistry","removeAll","KHR_LIGHTS_PUNCTUAL","KHR_MATERIALS_CLEARCOAT","KHR_MATERIALS_IOR","KHR_MATERIALS_SHEEN","KHR_MATERIALS_SPECULAR","KHR_MATERIALS_TRANSMISSION","KHR_MATERIALS_IRIDESCENCE","KHR_MATERIALS_ANISOTROPY","KHR_MATERIALS_VOLUME","KHR_TEXTURE_BASISU","KHR_MATERIALS_EMISSIVE_STRENGTH","EXT_TEXTURE_WEBP","EXT_TEXTURE_AVIF","EXT_MESHOPT_COMPRESSION","EXT_MESH_GPU_INSTANCING","refs","uses","_markDefs","nodeDefs","nodeIndex","nodeLength","nodeDef","_addNodeRef","_loadLight","lightIndex","dependency","lightDef","lightNode","innerConeAngle","outerConeAngle","assignExtrasToUserData","createUniqueName","getDependency","createNodeAttachment","_getNodeRef","getMaterialType","extendParams","materialParams","materialDef","pending","metallicRoughness","pbrMetallicRoughness","baseColorFactor","baseColorTexture","assignTexture","extendMaterialParams","emissiveStrength","clearcoatFactor","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughnessTexture","clearcoatNormalTexture","iridescenceFactor","iridescenceTexture","iridescenceIor","iridescenceThicknessTexture","sheenColorFactor","sheenRoughnessFactor","sheenColorTexture","sheenRoughnessTexture","transmissionFactor","transmissionTexture","thicknessFactor","thicknessTexture","colorArray","specularFactor","specularTexture","specularColorFactor","specularColorTexture","anisotropyStrength","anisotropyTexture","loadTexture","textureIndex","textureDef","loadTextureImage","isSupported","textureLoader","uri","handler","detectSupport","Image","onload","onerror","loadBufferView","bufferView","bufferViews","extensionDef","supported","byteOffset","byteStride","decodeGltfBufferAsync","ready","decodeGltfBuffer","createNodeMesh","meshDef","meshes","primitive","primitives","WEBGL_CONSTANTS","TRIANGLE_STRIP","TRIANGLE_FAN","attributesDef","accessor","nodeObject","instancedMeshes","TRANSLATION","ROTATION","SCALE","attributeName","assignFinalMaterial","headerView","header","magic","getUint32","chunkContentsLength","chunkView","chunkIndex","chunkLength","chunkType","contentArray","preload","decodePrimitive","bufferViewIndex","gltfAttributeMap","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","threeAttributeName","ATTRIBUTES","accessorDef","accessors","componentType","WEBGL_COMPONENT_TYPES","decodeDracoFile","extendTexture","texCoord","GLTFCubicSplineInterpolant","stride2","stride3","td","m0","m1","_q","GLTFCubicSplineQuaternionInterpolant","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","SAMPLER_2D","WEBGL_FILTERS","WEBGL_WRAPPINGS","WEBGL_TYPE_SIZES","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","TEXCOORD_2","TEXCOORD_3","COLOR_0","WEIGHTS_0","JOINTS_0","PATH_PROPERTIES","translation","INTERPOLATION","CUBICSPLINE","STEP","addUnknownExtensionsToUserData","knownExtensions","objectDef","gltfExtensions","gltfDef","extras","targetNames","createPrimitiveKey","primitiveDef","geometryKey","dracoExtension","createAttributesKey","targets","attributesKey","getNormalizedComponentScale","associations","primitiveCache","nodeCache","meshCache","cameraCache","lightCache","sourceCache","textureCache","nodeNamesUsed","isSafari","isFirefox","firefoxVersion","_invokeAll","ext","beforeRoot","getDependencies","dependencies","scenes","afterRoot","skinDefs","skins","meshDefs","skinLength","skin","ref","updateMappings","original","mappings","entries","_invokeOne","func","loadScene","loadNode","loadMesh","loadAccessor","loadBuffer","loadMaterial","loadSkin","loadAnimation","loadCamera","defs","def","bufferIndex","bufferDef","bufferViewDef","accessorIndex","sparse","TypedArray","pendingBufferViews","elementBytes","itemBytes","bufferAttribute","ibSlice","ibCacheKey","itemSizeIndices","SCALAR","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","sourceIndex","sourceDef","sampler","promise","loadImageSource","startsWith","samplers","URL","webkitURL","sourceURI","isObjectURL","Blob","createObjectURL","revokeObjectURL","search","mapName","mapDef","gltfReference","useDerivativeTangents","useVertexColors","useFlatShading","pointsMaterial","lineMaterial","materialType","kmuExtension","metallicFactor","roughnessFactor","metallicRoughnessTexture","alphaMode","alphaCutoff","normalTexture","occlusionTexture","strength","emissiveFactor","emissiveTexture","originalName","sanitizedName","sanitizeNodeName","loadGeometries","createDracoPrimitive","addPrimitiveAttributes","geometryPromise","meshIndex","cameraIndex","cameraDef","yfov","aspectRatio","znear","zfar","xmag","ymag","skinDef","_loadNodeShallow","inverseBindMatrices","jointNodes","jointNode","mat","animationIndex","animationDef","animationName","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","channels","input","inputAccessors","outputAccessors","inputAccessor","outputAccessor","createdTracks","_createAnimationTracks","nodePending","childPending","childrenDef","skeletonPending","meshPromise","sceneIndex","sceneDef","nodeIds","reducedAssociations","reduceAssociations","targetName","outputArray","_getArrayFromAccessor","_createCubicSplineTrackInterpolant","scaled","isInterpolantFactoryMethodGLTFCubicSpline","assignAttributeAccessor","gltfAttributeName","boxScale","maxDisplacement","computeBounds","hasMorphNormal","hasMorphColor","pendingPositionAccessors","pendingNormalAccessors","pendingColorAccessors","pendingAccessor","morphPositions","addMorphTargets","loadingManager","THREE","cursor","loadResource","resource","cameraHelper","controllerScope","cameraId","switch","oeuvre","chassis","_assertThisInitialized","ReferenceError","_inheritsLoose","subClass","superClass","create","__proto__","_suppressOverwrites","_reverting","_globalTimeline","_win","_coreInitted","_doc","_coreReady","_lastRenderedFrame","_quickTween","_tickerActive","n1","easeOut","_config","autoSleep","force3D","nullTargetWarn","lineHeight","_defaults","overwrite","delay","_bigNum","_tinyNum","_2PI","_HALF_PI","_gsID","_sqrt","_cos","_sin","_isString","_isFunction","_isNumber","_isUndefined","_isObject","_isNotFalse","_windowExists","_isFuncOrString","_isTypedArray","_isArray","_strictNumExp","_numExp","_numWithUnitExp","_complexStringNumExp","_relExp","_delimitedValueExp","_unitExp","_globals","_installScope","_install","_merge","gsap","_missingPlugin","_warn","suppress","_addGlobal","_emptyFunc","_startAtRevertConfig","suppressEvents","isStart","kill","_revertConfigNoKill","_revertConfig","_reservedProps","_lazyTweens","_lazyLookup","_plugins","_effects","_nextGCFrame","_harnessPlugins","_callbackNames","_harness","harnessPlugin","_gsap","harness","targetTest","GSCache","_getCache","_getProperty","_forEachName","names","_round","_roundPrecise","_parseRelative","operator","substr","_arrayContainsAny","toSearch","toFind","_lazyRender","tween","_lazy","_lazySafeRender","_initted","_startAt","_numericIfPossible","_passThrough","_setDefaults","defaults","toMerge","_mergeDeep","_copyExcluding","excluding","_inheritDefaults","vars","excludeDuration","keyframes","inherit","_dp","_addLinkedListItem","firstProp","lastProp","sortBy","prev","_prev","_next","_removeLinkedListItem","_removeFromParent","onlyIfParentHasAutoRemove","autoRemoveChildren","_act","_uncache","_dur","_dirty","_rewindStartAt","totalTime","revert","immediateRender","autoRevert","_hasNoPausedAncestors","_ts","_elapsedCycleDuration","_repeat","_animationCycle","_tTime","_rDelay","tTime","cycleDuration","whole","_parentToChildTotalTime","parentTime","totalDuration","_tDur","_setEnd","_rts","_alignPlayhead","smoothChildTiming","_time","_postAddChecks","timeline","rawTime","_clamp","_zTime","_addToTimeline","skipChecks","_parsePosition","_delay","_sort","_isFromOrFromStart","_recent","_scrollTrigger","trigger","ScrollTrigger","_attemptInitTween","_initTween","_pt","lazy","_ticker","_parentPlayheadIsBeforeStart","_ref","_lock","_ref2","_setDuration","skipUncache","leavePlayhead","dur","totalProgress","_onUpdateTotalDuration","Timeline","_zeroPosition","percentAnimation","isPercent","labels","recent","clippedDuration","_createTweenType","irVars","isLegacy","varsIndex","runBackwards","startAt","Tween","_conditionalReturn","getUnit","_slice","_isArrayLike","nonEmpty","nodeType","leaveStrings","selector","_wake","ar","accumulator","_accumulator","_flatten","querySelectorAll","el","current","nativeElement","shuffle","distribute","each","ease","_parseEase","isDecimal","ratios","ratioX","ratioY","edges","originX","originY","wrapAt","distances","grid","getBoundingClientRect","amount","_invertEase","_roundModifier","raw","snap","snapTo","is2D","increment","closest","roundingIncrement","returnFunction","_wrapArray","wrapper","_replaceRandom","nums","mapRange","inMin","inMax","outMin","outMax","inRange","outRange","_getLabelInDirection","fromTime","backward","_callback","executeLazyFirst","prevContext","_ctx","callbackScope","_interrupt","scrollTrigger","progress","_registerPluginQueue","_createPlugin","config","isFunc","Plugin","_props","instanceDefaults","_renderPropTweens","_addPropTween","_killPropTweensOf","modifier","_addPluginModifier","rawVars","statics","getSetter","_getSetter","aliases","PropTween","_255","_colorLookup","aqua","lime","silver","black","maroon","teal","blue","navy","white","olive","yellow","orange","gray","purple","green","red","pink","cyan","_hue","m2","splitColor","toHSL","forceAlpha","wasHSL","_colorOrderData","_colorExp","_formatColors","orderMatchData","shell","colors","_hslExp","_colorStringFilter","combined","_req","_raf","_self","_delta","_getTime","_lagThreshold","_adjustedLag","_startTime","_lastUpdate","_gap","_nextTime","_tick","overlap","dispatch","elapsed","manual","tick","deltaRatio","wake","gsapVersions","GreenSockGlobals","sleep","clearTimeout","lagSmoothing","adjustedLag","_fps","once","prioritize","_easeMap","_customEaseExp","_quotesExp","_parseObjectInString","val","parsedVal","_propagateYoyoEase","isYoyo","_first","yoyoEase","_yoyo","_ease","_yEase","defaultEase","open","nested","_CE","_configEaseFromString","_insertEase","easeIn","easeInOut","lowercaseName","_easeInOutFromOut","_configElastic","amplitude","period","_configBack","overshoot","Linear","easeNone","none","SteppedEase","steps","immediateStart","Animation","repeatDelay","yoyo","_proto","_totalTime","_ptLookup","_pTime","ratio","iteration","_ps","_recacheAncestors","paused","includeRepeats","wrapRepeats","prevIsReverting","globalTime","_sat","restart","includeDelay","play","reversed","reverse","pause","atTime","resume","invalidate","isActive","eventCallback","_onUpdate","onFulfilled","_resolve","_then","_prom","_Animation","sortChildren","_proto2","fromTo","fromVars","toVars","delayedCall","staggerTo","stagger","onCompleteAll","onCompleteAllParams","onComplete","onCompleteParams","staggerFrom","staggerFromTo","prevPaused","pauseTween","prevStart","prevIteration","tDur","crossingStart","rewinding","doesWrap","repeatRefresh","onRepeat","_hasPause","_forcing","_last","_findNextPauseTween","adjustedTime","_this2","addLabel","getChildren","tweens","timelines","ignoreBeforeTime","getById","removeLabel","killTweensOf","_totalTime2","addPause","removePause","props","onlyActive","getTweensOf","_overwritingTween","parsedTargets","isGlobalTime","_targets","tweenTo","initted","tl","_vars","_onStart","onStartParams","tweenFromTo","fromPosition","toPosition","nextLabel","afterTime","previousLabel","beforeTime","currentLabel","shiftChildren","adjustLabels","soft","includeLabels","updateRoot","_forceAllPropTweens","_addComplexStringPropTween","setter","stringFilter","funcParam","startNums","endNum","chunk","startNum","hasRandom","pt","_renderComplexString","matchIndex","fp","optional","parsedStart","_setterFuncWithParam","_setterFunc","_setterPlain","_renderBoolean","_renderPlain","_checkPlugin","ptLookup","_parseFuncOrString","_processVars","priority","cleanVars","hasPriority","gsData","harnessVars","overwritten","onUpdateParams","prevStartAt","fullTargets","autoOverwrite","_overwrite","_from","_ptCache","_op","_sortPropTweensByPriority","_onInit","_parseKeyframe","allProps","easeEach","_staggerTweenProps","_staggerPropsToSkip","_Animation2","skipInherit","_this3","curTarget","staggerFunc","staggerVarsToMerge","_this3$vars","kf","_proto3","isNegative","prevRatio","_renderZeroDurationTween","resetTo","startIsRelative","rootPT","lookup","ptCache","_updatePropTweens","overwrittenProps","curLookup","curOverwriteProps","killingTargets","propTweenLookup","firstPT","_arraysMatch","propertyAliases","_addAliasesToVars","onReverseComplete","onReverseCompleteParams","_setterAttribute","hasNonDependentRemaining","op","dep","_setterWithModifier","mSet","mt","pt2","first","last","pr","change","TweenMax","TweenLite","TimelineLite","TimelineMax","_media","_emptyArray","_lastMediaTime","_contextID","_dispatch","_onMediaChange","anyMatch","toggled","queries","conditions","matchMedia","onMatch","Context","_r","isReverted","_proto5","prevSelector","ignore","getTweens","_this4","MatchMedia","contexts","_proto6","mq","active","cond","addListener","registerPlugin","_len2","args","_key2","getProperty","uncache","quickSetter","setters","quickTo","_merge2","isTweening","registerEffect","_ref3","effect","extendTimeline","pluginName","registerEase","parseEase","exportRoot","includeDelayedCalls","matchMediaRefresh","found","wrapYoyo","pipe","_len","functions","_key","reduce","unitize","interpolate","mutate","interpolators","isString","master","install","effects","ticker","globalTimeline","core","globals","getCache","reverting","toAdd","suppressOverwrites","_getPluginPropTween","_buildModifierPlugin","temp","modifiers","_addModifiers","Power0","Power1","Power2","Power3","Power4","Quad","Cubic","Quart","Quint","Strong","Elastic","Back","Bounce","Sine","Expo","Circ","_docElement","_pluginInitted","_tempDiv","_recentSetterPlugin","_supports3D","_transformProps","_RAD2DEG","_DEG2RAD","_atan2","_capsExp","_horizontalExp","_complexExp","_propertyAliases","autoAlpha","_renderCSSProp","_renderPropWithEnd","_renderCSSPropWithBeginning","_renderRoundedCSSProp","_renderNonTweeningValue","_renderNonTweeningValueOnlyAtEnd","_setterCSSStyle","_setterCSSProp","_setterTransform","_setterScale","_setterScaleWithRender","renderTransform","_setterTransformWithRender","_transformProp","_transformOriginProp","_saveStyle","isNotCSS","tfm","_get","svg","svgo","_removeIndependentTransforms","removeProperty","_revertStyle","_getStyleSaver","saver","save","_createElement","ns","_getComputedProperty","skipPrefixFallback","cs","getComputedStyle","getPropertyValue","_checkPropPrefix","_prefixes","preferPrefix","_initCore","_getBBoxHack","swapIfPossible","bbox","ownerSVGElement","oldParent","oldSibling","nextSibling","oldCSS","getBBox","_gsapBBox","_getAttributeFallbacks","attributesArray","_getBBox","bounds","_isSVG","getCTM","_removeProperty","_addNonTweeningPT","beginning","onlySetAtEnd","_nonConvertibleUnits","rad","turn","_nonStandardLayouts","flex","_convertToUnit","px","isSVG","curValue","curUnit","horizontal","isRootSVG","tagName","measureProperty","toPixels","toPercent","_parseTransform","_firstTwoOnly","zOrigin","_specialProps","_tweenComplexCSSString","startValues","startValue","endValue","endUnit","startUnit","_keywordToPercent","_renderClearProps","clearTransforms","clearProps","_identity2DMatrix","_rotationalProperties","_isNullTransform","_getComputedTransformMatrixAsArray","matrixString","_getMatrix","force2D","addedToDOM","baseVal","consolidate","offsetParent","nextElementSibling","_applySVGOrigin","originIsAbsolute","smooth","matrixArray","pluginToAddPropTweensTo","xOriginOld","xOrigin","yOriginOld","yOrigin","xOffsetOld","yOffsetOld","yOffset","originSplit","rotationX","rotationY","skewX","skewY","perspective","t2","t3","invertedScaleX","forceCSS","xPercent","offsetWidth","yPercent","offsetHeight","transformPerspective","_renderSVGTransforms","_renderCSSTransforms","_renderNon3DTransforms","_addPxTranslate","_zeroDeg","_zeroPx","_endParenthesis","transforms","use3D","_addRotationalPropTween","cap","finalValue","_assign","_addRawTransformPTs","endCache","startCache","CSSPlugin","specialProp","relative","isTransformRelated","transformPropTween","inlineProps","styles","visibility","parseTransform","smoothOrigin","autoRound","checkPrefix","getStyleSaver","positionAndScale","gsapWithCSS","gScene","gRenderer","devicePixelRatio","innerWidth","innerHeight","clock","sizes","ambientLight","pointLight","bluePointLight","redPointLight","mouse","backCard","fond","planeFond","backCardPNG","modelGLTF","objetJSON","heightArtist","backgroundTextures","categorieTextures","cardTextures","cardArtists","cardCategories","categoriesToTest","varJSON","cardGeometry","categories","artist","name_cat","artists","currentIntersect","currentArtist","mouseCursor","artistesClicked","currentArtistsClicked","retour","speedAnim","pathname","variable","card","category","page","backgroundCompared","currentSrc","localIntersect"],"sourceRoot":""}